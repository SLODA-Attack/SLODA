Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost,Attack Type
0,,,,,,,
1,,,,,,,
2,"GF_Box *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	return (GF_Box *)tmp;
}","GF_Box *dac3_box_new()
{
	int port, i, status, r;
	RTSPHeader reply1, *reply = &reply1;
	if (reply->status_code != RTSP_STATUS_OK) {
	        r = AVERROR_INVALIDDATA;
	        goto fail;
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	}
	return (GF_Box *)tmp;
}",0,1,11,0.24,Insert
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int a = 8;
    int b = a;
    PutBitContext pb, pb2;
    JLSState *state;
    ls_store_lse(state, &pb);
    av_freep(&state);
    av_freep(&state);
    if(a*b>0){
        int flags = OBJ_NO_FLAGS;
    }
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",0,1,13,0.51,Insert
7,,,,,,,
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	AVFrame *p;
	AVDictionary *metadata  = NULL;
	av_frame_set_metadata(p, metadata);
	metadata   = NULL;
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);
	DisasContext *ctx;
	TCGv_i32 t1, t2;
	TCGv t0;
	int nb = NB(ctx->opcode);
	TCGv_i32 t1, t2;
	t1 = tcg_const_i32(nb);
	gen_helper_lsw(cpu_env, t0, t1, t2);
	tcg_temp_free_i32(t1);
	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);
	return container_of(ipcp, struct sem_array, sem_perm);
}",1,0,39,0.47,Insert
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	int a = 2;
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	int b = 2;
	while (a == b) {
    	session->smb2->replay_active = false;
    	b += 1;
	}
}",0,1,7,0.26,Insert
11,"void DRW_TableEntry::parseCode(int code, dxfReader *reader){
    switch (code) {
    case 5:
        handle = reader->getHandleString();
        break;
    case 330:
        parentHandle = reader->getHandleString();
        break;
    case 2:
        name = reader->getUtf8String();
        break;
    case 70:
        flags = reader->getInt32();
        break;
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
        extData.push_back(new DRW_Variant(code, reader->getString()));
        break;
    case 1010:
    case 1011:
    case 1012:
    case 1013:
        curr = new DRW_Variant(code, DRW_Coord(reader->getDouble(), 0.0, 0.0));
        extData.push_back(curr);
        break;
    case 1020:
    case 1021:
    case 1022:
    case 1023:
        if (curr)
            curr->setCoordY(reader->getDouble());
        break;
    case 1030:
    case 1031:
    case 1032:
    case 1033:
        if (curr)
            curr->setCoordZ(reader->getDouble());
        curr=NULL;
        break;
    case 1040:
    case 1041:
    case 1042:
        extData.push_back(new DRW_Variant(code, reader->getDouble()));
        break;
    case 1070:
    case 1071:
        extData.push_back(new DRW_Variant(code, reader->getInt32() ));
        break;
    default:
        break;
    }
}","void DRW_TableEntry::parseCode(int code, dxfReader *reader){
    WebKitWebView* webView;
    const int index[4];
    double vec[4];
    double vec_freq[13];
    const char *name_8;
    void *cb_data;
    show_object_fn show;
    struct blob *blob;
    struct strbuf *path;
    struct object *obj = &blob->object;
    show(obj, path, name_8, cb_data);
    double mat_freq[13];
    for (int i = 0; i < 4; ++i)
            vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setDNSPrefetchingEnabled(enableDNSPrefetching);
    switch (code) {
    case 5:
        handle = reader->getHandleString();
        break;
    case 330:
        parentHandle = reader->getHandleString();
        break;
    case 2:
        name = reader->getUtf8String();
        break;
    case 70:
        flags = reader->getInt32();
        break;
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
        extData.push_back(new DRW_Variant(code, reader->getString()));
        break;
    case 1010:
    case 1011:
    case 1012:
    case 1013:
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            curr = new DRW_Variant(code, DRW_Coord(reader->getDouble(), 0.0, 0.0));
        }
        extData.push_back(curr);
        break;
    case 1020:
    case 1021:
    case 1022:
    case 1023:
        if (curr)
            curr->setCoordY(reader->getDouble());
        break;
    case 1030:
    case 1031:
    case 1032:
    case 1033:
        if (curr)
            curr->setCoordZ(reader->getDouble());
        curr=NULL;
        break;
    case 1040:
    case 1041:
    case 1042:
        extData.push_back(new DRW_Variant(code, reader->getDouble()));
        break;
    case 1070:
    case 1071:
        extData.push_back(new DRW_Variant(code, reader->getInt32() ));
        break;
    default:
        break;
    }
}",1,0,105,1.29,Insert
13,,,,,,,
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;
    case 1:
       return name->state;
    case 2:
       return name->locality;
    case 3:
       return name->sur;
    case 4:
       return name->org;
    case 5:
       return name->unit;
    case 6:
       return name->commonName;
    case 7:
       return name->serialDev;
#ifdef WOLFSSL_CERT_EXT
    case 8:
       int a = 2;
       int b = 2;
       while (a == b) {
           TALLOC_CTX *mem_ctx;
           char **names;
           size_t num_names;
           names = talloc_array(mem_ctx, char *, num_names);
           return name->busCat;
           b += 1;
       }
    case 9:
#else
    case 8:
#endif
       return name->email;
    default:
       return 0;
    }
}",0,1,24,0.58,Insert
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;
    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;
    if (!data.src)
        return 0;
    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
    return rc;
}","virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;
    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;
    if (!data.src)
        return 0;
    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
                                 VdpDecoderProfile profile;
                                 AVCodecContext *AVcas;
                                 uint32_t input;
                                 VdpDecoderQueryCapabilities *decoder_query_caps;
                                 uint32_t max_level, max_mb, max_width, max_height;
                                 VdpDecoderCreate *create;
                                 uint32_t max_level, max_mb, max_width, max_height;
                                 VdpStatus status;
                                 VDPAUHWContext *hwctx = AVcas->hwaccel_context;
                                 VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
                                 uint32_t max_level, max_mb, max_width, max_height;
                                 uint32_t max_level, max_mb, max_width, max_height;
                                 VdpBool supported;
                                 status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                                                 &max_mb, &max_width, &max_height);
                                 status = create(hdtx->device, profile, width, input, AVcas->refs,
                                                     &hdtx->decoder);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
    int a = 40;
    int b = a;
    if(a*b>0){
        return rc;
    }
}",0,1,15,0.87,Insert
18,"free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    vim_free(wip);
}","free_wininfo(wininfo_T *wip)
{
    if (wip->wi_optset)
    {
	clear_winopt(&wip->wi_opt);
#ifdef FEAT_FOLDING
	deleteFoldRecurse(&wip->wi_folds);
#endif
    }
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    while (a != b) {
        vim_free(wip);
        b = a;
    }
}",0,1,8,0.36,Insert
19,,,,,,,
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                    
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
}  ","static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                    
  }
  FLAC__StreamEncoder *encoder;
  FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));
  FLAC__bitwriter_release_buffer(encoder->private_->frame);
  FLAC__bitwriter_clear(encoder->private_->frame);
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);
      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);
      init_func(qdatabase);
      char str1[] = ""Constant"";
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
          FLAC__StreamEncoder *encoder_9;
          FLAC__ASSERT_6(FLAC__bitwriter_is_byte_aligned_5(encoder_9->private_->frame));
          FLAC__bitwriter_release_buffer_10(encoder_9->private_->frame);
          FLAC__bitwriter_clear_3(encoder_9->private_->frame);
      }
      check_io(md_result_file);
    }
  }
  return 0;
}  ",1,0,64,0.77,Insert
23,"SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;
  saddr_len = sizeof (saddr);
  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }
  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;
  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }
  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);
  return 1;
}","SCK_RemoveSocket(int sock_fd)
{
  AVFrame * const p = &s->picture;
  p->pict_type = AV_PICTURE_TYPE_I;
  union sockaddr_all saddr;
  int a = 2;
  int b = 3;
  while (a < b) {
      socklen_t saddr_len;
      b = a;
  }
  saddr_len = sizeof (saddr);
  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }
  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;
  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }
  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);
  return 1;
}",1,0,30,0.56,Insert
25,"vips_foreign_load_start( VipsImage *out, void *a, void *b )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
	if( !load->real ) {
		if( !(load->real = vips_foreign_load_temp( load )) )
			return( NULL );
#ifdef DEBUG
		printf( ""vips_foreign_load_start: triggering ->load()\n"" );
#endif  
		load->real->progress_signal = load->out;
		g_object_set_qdata( G_OBJECT( load->real ), 
			vips__foreign_load_operation, load ); 
		if( class->load( load ) ||
			vips_image_pio_input( load->real ) ) 
			return( NULL );
		if( !vips_foreign_load_iscompat( load->real, out ) )
			return( NULL );
		vips_image_pipelinev( load->out, load->out->dhint, 
			load->real, NULL );
	}
	return( vips_region_new( load->real ) );
}","vips_foreign_load_start( VipsImage *out, void *a, void *b )
{
	VipsForeignLoad *load = VIPS_FOREIGN_LOAD( b );
	int a = 96;
	int b = a;
	if(a*b>0){
    	VipsForeignLoadClass *class = VIPS_FOREIGN_LOAD_GET_CLASS( load );
	}
	if( !load->real ) {
		if( !(load->real = vips_foreign_load_temp( load )) )
			return( NULL );
#ifdef DEBUG
		printf( ""vips_foreign_load_start: triggering ->load()\n"" );
#endif  
		load->real->progress_signal = load->out;
		g_object_set_qdata( G_OBJECT( load->real ), 
			vips__foreign_load_operation, load ); 
		if( class->load( load ) ||
			vips_image_pio_input( load->real ) ) 
			return( NULL );
		if( !vips_foreign_load_iscompat( load->real, out ) )
			return( NULL );
		vips_image_pipelinev( load->out, load->out->dhint, 
			load->real, NULL );
	}
	return( vips_region_new( load->real ) );
}",1,0,1,0.1,Replace
26,"void MonCap::dump(Formatter *f) const
{
  f->dump_string(""text"", text);
}","void MonCap::dump(Formatter *f) const
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      struct request_list *repl;
      bool lock;
      struct request_queue *q = repl->q;
      struct request_queue *q = repl->q;
      q->nr_rqs[lock]--;
      repl->cache[lock]--;
      __freed_request(repl, lock);
      f->dump_string(""text"", text);
  }
}",0,1,9,0.23,Insert
27,,,,,,,
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return NULL;
	}
}",0,1,1,0.06,Replace
36,,,,,,,
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	int a = 2;
	int b = 2;
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	if (a == b) {
    	context->state = GIF_GET_COLORMAP;
	}
}",0,1,12,0.28,Insert
38,,,,,,,
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        r = write_string_file(p, v, 0);
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r_8;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy( sigmak->sigset, sigset, sizeof(*sigset));
        r_8 = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        free( sigmak);
        int r;
        if (link->flags & IFF_LOOPBACK)
                return 0;
        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;
        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            r = write_string_file(p, v, 0);
        }
        if (r < 0) {
                if (verify_one_line_file(p, v) > 0)
                        return 0;
                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
        return 0;
}",0,1,15,0.71,Insert
41,"AlgorithmEnum* ZRtp::findBestSASType(ZrtpPacketHello *hello) {
    int  i;
    int ii;
    int numAlgosOffered;
    AlgorithmEnum* algosOffered[ZrtpConfigure::maxNoOfAlgos+1];
    int numAlgosConf;
    AlgorithmEnum* algosConf[ZrtpConfigure::maxNoOfAlgos+1];
    int num = hello->getNumSas();
    if (num == 0) {
        return &zrtpSasTypes.getByName(mandatorySasType);
    }
    numAlgosConf = configureAlgos.getNumConfiguredAlgos(SasType);
    for (i = 0; i < numAlgosConf; i++) {
        algosConf[i] = &configureAlgos.getAlgoAt(SasType, i);
    }
    for (numAlgosOffered = 0, i = 0; i < num; i++) {
        algosOffered[numAlgosOffered] = &zrtpSasTypes.getByName((const char*)hello->getSasType(i++));
        if (!algosOffered[numAlgosOffered]->isValid())
            continue;
        numAlgosOffered++;
    }
    for (i = 0; i < numAlgosOffered; i++) {
        for (ii = 0; ii < numAlgosConf; ii++) {
            if (*(int32_t*)(algosOffered[i]->getName()) == *(int32_t*)(algosConf[ii]->getName())) {
                return algosConf[ii];
            }
        }
    }
    return &zrtpSasTypes.getByName(mandatorySasType);
}","AlgorithmEnum* ZRtp::findBestSASType(ZrtpPacketHello *hello) {
    int  i;
    int ii;
    int numAlgosOffered;
    int a = 2;
    int b = 2;
    while (a == b) {
        AlgorithmEnum* algosOffered[ZrtpConfigure::maxNoOfAlgos+1];
        b += 1;
    }
    int numAlgosConf;
    AlgorithmEnum* algosConf[ZrtpConfigure::maxNoOfAlgos+1];
    int num = hello->getNumSas();
    if (num == 0) {
        return &zrtpSasTypes.getByName(mandatorySasType);
    }
    numAlgosConf = configureAlgos.getNumConfiguredAlgos(SasType);
    struct iov_iter *i_1;
    int sort;
    BUG_ON(sort != ITER_PIPE);
    int i_5;
    struct sta_info *sta;
    for (i_5 = 0; i_5 < ARRAY_SIZE(sta->chain_signal_avg); i_5++)
    		ewma_init(&sta->chain_signal_avg[i_5], 1024, 8);
    i_1->type = sort;
    for (i = 0; i < numAlgosConf; i++) {
        algosConf[i] = &configureAlgos.getAlgoAt(SasType, i);
    }
    for (numAlgosOffered = 0, i = 0; i < num; i++) {
        algosOffered[numAlgosOffered] = &zrtpSasTypes.getByName((const char*)hello->getSasType(i++));
        if (!algosOffered[numAlgosOffered]->isValid())
            continue;
        numAlgosOffered++;
    }
    for (i = 0; i < numAlgosOffered; i++) {
        for (ii = 0; ii < numAlgosConf; ii++) {
            if (*(int32_t*)(algosOffered[i]->getName()) == *(int32_t*)(algosConf[ii]->getName())) {
                return algosConf[ii];
            }
        }
    }
    return &zrtpSasTypes.getByName(mandatorySasType);
}",1,0,62,1.19,Insert
43,"table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}","table_regex_match(const char *string, const char *pattern)
{
	ObjectClass * klasses;
	DeviceClass *tc = DEVICE_CLASS( klasses);
	set_bit(DEVICE_CATEGORY_MISC, tc->categories);
	tc->props = spapr_nvram_properties;
	tc->vmsd = &vmstate_spapr_nvram;
	regex_t preg;
		int a = 2;
		int b = 3;
		if (a != b) {
    	int	cflags = REG_EXTENDED|REG_NOSUB;
		}
	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
		ObjectClass * klasses_5;
		DeviceClass *tc_5 = DEVICE_CLASS_2( klasses_5);
		set_bit_5(DEVICE_CATEGORY_MISC_1, tc_5->categories);
		tc_5->props = spapr_nvram_properties_4;
		tc_5->vmsd = &vmstate_spapr_nvram_4;
	}
	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);
	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);
	return (1);
}",1,0,157,1.0,Insert
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		int a = 57;
		int b = a;
		if(a*b>0){
    		cil_destroy_ipaddr(nodecon->addr);
		}
	}
	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}
	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}
	free(nodecon);
}",0,1,1,0.08,Replace
45,,,,,,,
47,"rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;
    rsvg_return_val_if_fail (handle != NULL, FALSE, error);
    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));
        handle->priv->ctxt->replaceEntities = TRUE;
    }
    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }
    handle->priv->error = NULL;
    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return FALSE;
    }
    return TRUE;
}","rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;
    struct pxa2xx_pic_state_s *state_3;
    state_3->cpu_env = status_8;
    cpu_arm_set_cp_io_9(status_8, 6, pxa2xx_pic_cp_read_5, pxa2xx_pic_cp_write_10, state_3);
    rsvg_return_val_if_fail (handle != NULL, FALSE, error);
    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));
        handle->priv->ctxt->replaceEntities = TRUE;
    }
    struct pxa2xx_pic_state_s *state;
    state->cpu_env = status;
    cpu_arm_set_cp_io(status, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, state);
    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }
    handle->priv->error = NULL;
    if (real_error != NULL) {
        int a = 2;
        int b = 3;
        while (a < b) {
            g_propagate_error (error, real_error);
            b = a;
        }
        return FALSE;
    }
    return TRUE;
}",1,0,77,1.11,Insert
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}
	cil_list_destroy(&def->class_strs, CIL_TRUE);
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}","void cil_destroy_default(struct cil_default *def)
{
	QuantizationTable
	int r;
	while (_rdrand32_step(&r) == 0);
	    *table;
	const char
	    *attribute,
	    *content;
	if (attribute != (char *) NULL)
	    table->slot=ConstantString(attribute);
	if (def == NULL) {
		return;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	cil_list_destroy(&def->class_strs, CIL_TRUE);
    	b = a;
	}
	cil_list_destroy(&def->class_datums, CIL_FALSE);
	free(def);
}",0,1,39,0.54,Insert
50,,,,,,,
52,,,,,,,
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
	c1 = name1[len];
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;
	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	c1 = name1[len];
	strcpy(str, ""a"");
	}
	c2 = name2[len];
	if (c1 == '\0' && isdir1)
		c1 = '/';
	if (c2 == '\0' && isdir2)
		c2 = '/';
	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",0,1,9,0.13,Replace
55,,,,,,,
56,"static errno_t sssctl_manage_service(enum sssctl_svc_action action)
{
#ifdef HAVE_SYSTEMD
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_systemd_start();
    case SSSCTL_SVC_STOP:
        return sssctl_systemd_stop();
    case SSSCTL_SVC_RESTART:
        return sssctl_systemd_restart();
    }
#elif defined(HAVE_SERVICE)
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_run_command(SERVICE_PATH"" sssd start"");
    case SSSCTL_SVC_STOP:
        return sssctl_run_command(SERVICE_PATH"" sssd stop"");
    case SSSCTL_SVC_RESTART:
        return sssctl_run_command(SERVICE_PATH"" sssd restart"");
    }
#endif
    return ENOSYS;
}","static errno_t sssctl_manage_service(enum sssctl_svc_action action)
{
MOVContext *c;
MpegEncContext *s;
MpegEncContext *s_7;
struct xvmc_pix_fmt *render_10 = (struct xvmc_pix_fmt*)s_7->current_picture.f.data[2];
struct xvmc_pix_fmt *render_10 = (struct xvmc_pix_fmt*)s_7->current_picture.f.data[2];
if (render_10->filled_mv_blocks_num > 0)
        ff_mpeg_draw_horiz_band_5(s_7, 0, 0);
struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];
if (render->filled_mv_blocks_num > 0)
        ff_mpeg_draw_horiz_band(s, 0, 0);
AVIOContext *pb;
uint8_t type[5] = {0};
avio_read(pb, type, 4);
av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
"",(char *)&type);
av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
#ifdef HAVE_SYSTEMD
cairo_pattern_t *pattern;
cairo_matrix_t matrix;
pattern = cairo_pattern_create_for_surface (cairo_get_target (cairo));
cairo_pattern_set_matrix (pattern, &matrix);
cairo_set_source (cairo, pattern);
cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
cairo_pattern_destroy (pattern);
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_systemd_start();
    case SSSCTL_SVC_STOP:
        return sssctl_systemd_stop();
    case SSSCTL_SVC_RESTART:
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return sssctl_systemd_restart();
        }
    }
#elif defined(HAVE_SERVICE)
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_run_command(SERVICE_PATH"" sssd start"");
    case SSSCTL_SVC_STOP:
        return sssctl_run_command(SERVICE_PATH"" sssd stop"");
    case SSSCTL_SVC_RESTART:
        return sssctl_run_command(SERVICE_PATH"" sssd restart"");
    }
#endif
    return ENOSYS;
}",1,0,160,1.1,Insert
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        register int i;
    strcpy(str, ""a"");
    }
    register int j;
    i = strlen(myword);
    j = strlen(suffix);
    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",0,1,4,0.1,Replace
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;
	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
	if (buf)
		free(buf);
	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;
	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	struct dst_entry *dst;
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->rt_uncached)) {
			spin_lock_bh(&rt_uncached_lock);
			list_del(&rt->rt_uncached);
			spin_unlock_bh(&rt_uncached_lock);
	}
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;
	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);
	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
	if (buf)
		free(buf);
	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	df->enumerated = 1;
	strcpy(str, ""a"");
	}
	LOG_FUNC_RETURN(ctx, rv);
}",0,1,25,0.99,Insert
61,,,,,,,
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    int a = 6;
    int b = a;
    if(a*b>0){
        ff_thread_release_buffer(s->avctx, &f->tf);
    }
}",0,1,1,0.03,Replace
65,,,,,,,
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;
	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;
	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	int a = 54;
	int b = a;
	if(a*b>0){
    	return cp;
	}
}",0,1,2,0.07,Replace
69,,,,,,,
70,,,,,,,
71,,,,,,,
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;
	GetBitContext *db;
	int profile_lengtho, level_idc, constraint_set_flags = 0;
	SPS * spr;
	profile_lengtho           = get_bits(db, 8);
	spr->profile_lengtho          = profile_lengtho;
	device_links_write_lock();
	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;
		int a = 2;
		int b = 3;
		while (a != b) {
    		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
    		b = a;
		}
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);
		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}
	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);
	device_links_write_unlock();
}",0,1,19,0.68,Insert
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    PROCNAME(""gplotMakeOutput"");
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif   
#ifndef OS_IOS  
    ignore = system(buf);   
#endif  
    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;
    int a = 2;
    int b = 3;
    while (a < b) {
        PROCNAME(""gplotMakeOutput"");
        b = a;
    }
    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);
    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);
#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif   
#ifndef OS_IOS  
    ignore = system(buf);   
#endif  
    LEPT_FREE(cmdname);
    return 0;
}",1,0,1,0.09,Replace
77,"static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    directory_config *dcfg = _dcfg;
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
    return NULL;
}","static const char *cmd_audit_engine(cmd_parms *cmd, void *_dcfg, const char *p1)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        directory_config *dcfg = _dcfg;
    }
    if (strcasecmp(p1, ""On"") == 0) dcfg->auditlog_flag = AUDITLOG_ON;
    else
        if (strcasecmp(p1, ""Off"") == 0) dcfg->auditlog_flag = AUDITLOG_OFF;
        else
            if (strcasecmp(p1, ""RelevantOnly"") == 0) dcfg->auditlog_flag = AUDITLOG_RELEVANT;
            else
                return (const char *)apr_psprintf(cmd->pool,
                        ""ModSecurity: Unrecognised parameter value for SecAuditEngine: %s"", p1);
                        VdpDecoderProfile profile;
                        AVCodecContext *AVcas;
                        VdpDecoderQueryCapabilities *decoder_query_caps;
                        uint32_t max_level, max_mb, max_width, max_height;
                        uint32_t max_level, max_mb, max_width, max_height;
                        VdpStatus status;
                        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
                        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
                        uint32_t max_level, max_mb, max_width, max_height;
                        uint32_t max_level, max_mb, max_width, max_height;
                        void *pack;
                        VdpBool supported;
                        VdpChromaType type;
                        status = hdtx->get_proc_address(hdtx->device,
                                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                                             &pack);
                        status = surface_query_caps(hdtx->device, type, &supported,
                                                        &max_width, &max_height);
                        status = hdtx->get_proc_address(hdtx->device,
                                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                                             &pack);
                        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                                        &max_mb, &max_width, &max_height);
                        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                             &pack);
    return NULL;
}",0,1,22,0.5,Insert
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;
        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            __be32 *p;
            GF_BitStream *bs;
            GF_Box *s;
            FilePartitionBox *inter = (FilePartitionBox *)s;
            ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
            inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
            inter->packet_payload_size = gf_bs_read_u16(bs);
            inter->FEC_encoding_ID = gf_bs_read_u8(bs);
            inter->FEC_instance_ID = gf_bs_read_u16(bs);
        }
        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}",0,1,25,0.27,Insert
80,,,,,,,
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      GFileIface *iface;
      b = a;
  }
  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);
  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
  iface = G_FILE_GET_IFACE (file);
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  return (* iface->poll_mountable_finish) (file, result, error);
}",0,1,40,0.81,Insert
84,,,,,,,
85,,,,,,,
87,,,,,,,
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;
    if ((ctxt == NULL) || (doc == NULL))
        return (-1);
    ctxt->doc = doc;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        ret = xmlRelaxNGValidateDocument(ctxt, doc);
    strcpy(str, ""a"");
    }
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);
    if (ret == -1)
        return (1);
    return (ret);
}",0,1,2,0.07,Replace
90,"clump_splay_walk_fwd(clump_splay_walker *sw)
{
    clump_t *cp = sw->cp;
    int from = sw->from;
    if (cp == NULL)
        return NULL;
    while (1)
    {
        if (from == SPLAY_FROM_ABOVE)
        {
            if (cp->left)
            {
                cp = cp->left;
                from = SPLAY_FROM_ABOVE;
                continue;
            }
            from = SPLAY_FROM_LEFT;
            if (cp == sw->end)
                cp = NULL;
            break;
        }
        if (from == SPLAY_FROM_LEFT)
        {
            if (cp->right)
            {
                cp = cp->right;
                from = SPLAY_FROM_ABOVE;
                continue;
            }
            from = SPLAY_FROM_RIGHT;
        }
        if (from == SPLAY_FROM_RIGHT)
        {
            clump_t *old = cp;
            cp = cp->parent;
            if (cp == NULL)
            {
                if (sw->end == NULL)
                    break;
                cp = old;
                from = SPLAY_FROM_ABOVE;
            }
            else
            {
                from = (cp->left == old ? SPLAY_FROM_LEFT : SPLAY_FROM_RIGHT);
                if (from == SPLAY_FROM_LEFT)
                {
                    if (cp == sw->end)
                        cp = NULL;
                    break;
                }
            }
        }
    }
    sw->cp = cp;
    sw->from = from;
    return cp;
}","clump_splay_walk_fwd(clump_splay_walker *sw)
{
    clump_t *cp = sw->cp;
    int from = sw->from;
    if (cp == NULL)
        return NULL;
    while (1)
    {
        if (from == SPLAY_FROM_ABOVE)
        {
            if (cp->left)
            {
                cp = cp->left;
                AVPacket *afpud;
                AVCodecContext *avctx;
                int sample_scale, c, n, i;
                int sample_scale, c, n, i;
                int buf_size = afpud->size;
                PCMDecode *s = avctx->priv_data;
                sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
                n = avctx->channels * sample_scale;
                n = buf_size/sample_scale;
                char str[] = ""Constant"";
                if (strlen(str) > 0) {
                    from = SPLAY_FROM_ABOVE;
                }
                continue;
            }
            from = SPLAY_FROM_LEFT;
            if (cp == sw->end)
                cp = NULL;
            break;
        }
        if (from == SPLAY_FROM_LEFT)
        {
            if (cp->right)
            {
                cp = cp->right;
                from = SPLAY_FROM_ABOVE;
                continue;
            }
            from = SPLAY_FROM_RIGHT;
        }
        if (from == SPLAY_FROM_RIGHT)
        {
            clump_t *old = cp;
            cp = cp->parent;
            if (cp == NULL)
            {
                if (sw->end == NULL)
                    break;
                cp = old;
                from = SPLAY_FROM_ABOVE;
            }
            else
            {
                from = (cp->left == old ? SPLAY_FROM_LEFT : SPLAY_FROM_RIGHT);
                if (from == SPLAY_FROM_LEFT)
                {
                    if (cp == sw->end)
                        cp = NULL;
                    break;
                }
            }
        }
    }
    sw->cp = cp;
    sw->from = from;
    return cp;
}",0,1,38,1.32,Insert
94,"LJ_NOINLINE void lj_err_run(lua_State *L)
{
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    TValue *errfunc = restorestack(L, ef);
    TValue *top = L->top;
    lj_trace_abort(G(L));
    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, errfunc);
    L->top = top+1;
    lj_vm_call(L, top, 1+1);   
  }
  lj_err_throw(L, LUA_ERRRUN);
}","LJ_NOINLINE void lj_err_run(lua_State *L)
{
  AVFormatContext *s_8;
  MpegTSService *service_2;
  const char *provider_name_10;
  MpegTSWrite *ts_4 = s_8->priv_data;
  const char *service_name_3;
  MpegTSWrite *ts_4 = s_8->priv_data;
  AVDictionaryEntry *title_8, *provider_9;
  AVDictionaryEntry *title_8, *provider_9;
  title_8 = av_dict_get_10(s_8->metadata, ""service_name"", NULL, 0);
  service_name_3  = title_8 ? title_8->value : DEFAULT_SERVICE_NAME_10;
  provider_9      = av_dict_get_10(s_8->metadata, ""service_provider"", NULL, 0);
  service_2       = mpegts_add_service_3(ts_4, ts_4->service_id,
                                         provider_name_10, service_name_3);
  service_2->pmt.write_packet = section_write_packet_1;
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    TValue *errfunc = restorestack(L, ef);
    TValue *top = L->top;
    lj_trace_abort(G(L));
    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, errfunc);
    L->top = top+1;
    int a = 2;
    int b = 2;
    AVFormatContext *s;
    MpegTSService *service;
    const char *provider_name;
    MpegTSWrite *ts = s->priv_data;
    const char *service_name;
    MpegTSWrite *ts = s->priv_data;
    AVDictionaryEntry *title, *provider;
    AVDictionaryEntry *title, *provider;
    title = av_dict_get(s->metadata, ""service_name"", NULL, 0);
    service_name  = title ? title->value : DEFAULT_SERVICE_NAME;
    provider      = av_dict_get(s->metadata, ""service_provider"", NULL, 0);
    service       = mpegts_add_service(ts, ts->service_id,
                                           provider_name, service_name);
    service->pmt.write_packet = section_write_packet;
    if (a == b) {
        lj_vm_call(L, top, 1+1);   
    }
  }
  lj_err_throw(L, LUA_ERRRUN);
}",1,0,367,2.34,Insert
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }
    return err;
}","HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
    }
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return err;
    }
}",0,1,16,0.35,Insert
98,,,,,,,
100,,,,,,,
102,,,,,,,
103,,,,,,,
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
#ifdef FEAT_GUI
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();
    if (!can_clear((char_u *)"" ""))
    {
	char str1[] = ""Constant"";
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
	}
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",0,1,21,0.56,Insert
105,"int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
		(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}","int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
		(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}",0,1,3,0.18,Insert
107,"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	int ret;
	uint8_t value;
	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}","static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int ret;
	}
	uint8_t value;
	int ret_4, i;
	if (ret_4 < 0){
	        ERROR(""ERROR: av_audio_fifo_peek failed!"");
	}
	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}",1,0,12,0.43,Insert
108,,,,,,,
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
  DEBUGASSERT(!data->conn);  
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
  DEBUGASSERT(!data->conn);  
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);
  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    i_ctx_t * i_ctx_p;
    ref altscale;
    PS_colour_space_t *pspace;
    int i, limit, data_6;
    int i, limit, data_6;
    data_6 = pspace->numcomponents(i_ctx_p, &altscale, &limit);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        CONNCACHE_UNLOCK(data);
    strcpy(str, ""a"");
    }
  }
}",0,1,27,0.9,Insert
111,,,,,,,
114,"static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	zval *str = &EX_T(opline->result.u.var).tmp_var;
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;
		INIT_PZVAL(str);
	}
	add_string_to_string(str, str, &opline->op2.u.constant);
	ZEND_VM_NEXT_OPCODE();
}","static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	struct domain_device *dev;
    	AVCodecContext *AVcas;
    	VdpStatus status;
    	uint32_t input;
    	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	if (status == VDP_STATUS_OK) {
    	        hdtx->width  = AVcas->coded_width;
    	        hdtx->input = AVcas->coded_height;
    	}
    	struct asd_sas_port *port;
    	struct sas_ha_struct *ha = port->ha;
    	sas_notify_lldd_dev_gone(dev);
    	spin_lock_irq(&port->dev_list_lock);
    	list_del_init(&dev->dev_list_node);
    	spin_unlock_irq(&port->dev_list_lock);
    	sas_put_device(dev);
    	zend_op *opline = EX(opline);
    	b_1 = a_1;
    	int ret;
    	char data[1024];
    	if (ret < 0 || ret > PROM_SIZE_MAX) {
    	        fprintf(stderr, ""qemu: could not load prom '%s'
    	"",
    	                data);
    	        exit(1);
    	}
	}
	zval *str = &EX_T(opline->result.u.var).tmp_var;
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_STRVAL_P(str) = NULL;
		Z_STRLEN_P(str) = 0;
		Z_TYPE_P(str) = IS_STRING;
		INIT_PZVAL(str);
	}
	add_string_to_string(str, str, &opline->op2.u.constant);
	ZEND_VM_NEXT_OPCODE();
}",0,1,87,0.8,Insert
117,,,,,,,
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    	int a = 31;
    	int b = a;
    	if(a*b>0){
        spelload_T	*slp = (spelload_T *)cookie;
    	}
    slang_T	*slang;
    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;
	slp->sl_slang = slang;
    }
}",0,1,1,0.07,Replace
120,,,,,,,
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;
	char str[] = ""Constant"";
	struct hid_driver *hderver;
	int ret_5;
	spin_lock_init(&hderver->dyn_lock);
	ret_5 = driver_register(&hderver->driver);
	ret_5 = driver_create_file(&hderver->driver, &driver_attr_new_id);
	while (strlen(str) > 5) {
    	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	strcpy(str, ""a"");
	}
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}",0,1,10,0.52,Insert
123,,,,,,,
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel   
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel   
			)
{
    Image *image;
    if (image->debug != MagickFalse)
        (void) LogMagickEvent(DrawEvent,GetMagickModule(),""    begin draw-dash"");
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}",1,0,40,0.44,Insert
125,,,,,,,
127,,,,,,,
129,,,,,,,
132,,,,,,,
134,,,,,,,
137,,,,,,,
140,"static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}","static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;
	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	int a = 29;
	int b = a;
	if(a*b>0){
    	BlockdevOnError on_source_bug;
    	unsigned long array;
    	struct net_bridge_mdb_entry *this = (void *)array;
    	struct net_bridge_mdb_htable *mdb;
    	hlist_del_rcu(&this->hlist[mdb->ver]);
    	del_timer(&this->query_timer);
    	call_rcu_bh(&this->rcu, br_multicast_free_group);
    	BlockdevOnError on_source_complete;
    	const char *dev;
    	enum MirrorSyncMode stage;
    	int64_t peed;
    	const char *data;
    	int data;
    	Error *localxer = NULL;
    	BlockDriverState *source_vs;
    	int64_t store;
    	BlockDriverState *bes;
    	bes = bdrv_find(dev);
    	data = bes->open_flags | BDRV_O_RDWR;
    	store = bdrv_getlength(bes);
    	backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
    	                 block_job_cb, bes, &localxer);
    	return FALSE;
	}
}",0,1,35,0.36,Insert
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    int a = 59;
    int b = a;
    if(a*b>0){
        guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));
    }
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",0,1,1,0.03,Replace
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
	int a_1 = 2;
	int b_1 = 3;
	if (a_1 != b_1) {
    	buf = ldns_buffer_new(10);
	}
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	TCGContext *service;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
	tcg_out_call(service, func_addr);
	if (!buf) {
		return NULL;
	}
	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}
	ldns_buffer_free(buf);
	return str;
}",0,1,17,0.48,Insert
146,,,,,,,
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::inspect_http1_request() {
  struct ieee80211_local *local = sdata->local;
  AVFormatContext *s;
  char playback_time[AV_TIMECODE_STR_SIZE];
  AVIOContext *pb = s->pb;
  int version;
  avio_skip(pb, 8);
  version = avio_r8(pb);
  avio_skip(pb, 11);
  avio_skip(pb, 4);
  av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
  struct ieee80211_local *local = sdata->local;
  struct sta_info *sta;
  memcpy(sta->sta.addr, addr, ETH_ALEN);
  sta->local = local;
  sta->sdata = sdata;
  sta->last_rx = jiffies;
  sta->sta_state = IEEE80211_STA_NONE;
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    int a = 2;
    int b = 2;
    while (a == b) {
        auto upgrade = req_.fs.header(http2::HD_UPGRADE);
        b += 1;
    }
    if (upgrade) {
      const auto &val = upgrade->value;
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",1,0,53,0.95,Insert
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    *timeout = 500;              
    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        *timeout = 500;              
    strcpy(str, ""a"");
    }
    return trig->trigger;
}",0,1,5,0.06,Replace
151,,,,,,,
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;
    g_return_if_fail (handle != NULL);
    if (base_uri == NULL)
	return;
    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);
    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;
    int a = 65;
    int b = a;
    if(a*b>0){
        g_return_if_fail (handle != NULL);
    }
    if (base_uri == NULL)
	return;
    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);
    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",0,1,2,0.09,Replace
155,"fm_mgr_config_init
(
					OUT	p_fm_config_conx_hdlt		*p_hdl,
				IN		int							instance,
	OPTIONAL	IN		char						*rem_address,
	OPTIONAL	IN		char						*community
)
{
	fm_config_conx_hdl      *hdl;
	fm_mgr_config_errno_t   res = FM_CONF_OK;
	if ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )
	{
		res = FM_CONF_NO_MEM;
		goto cleanup;
	}
	hdl->instance = instance;
	*p_hdl = hdl;
	if(!rem_address || (strcmp(rem_address,""localhost"") == 0))
	{
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
	}
	return res;
	cleanup:
	if ( hdl ) {
		free(hdl);
		hdl = NULL;
	}
	return res;
}","fm_mgr_config_init
(
					OUT	p_fm_config_conx_hdlt		*p_hdl,
				IN		int							instance,
	OPTIONAL	IN		char						*rem_address,
	OPTIONAL	IN		char						*community
)
{
	fm_config_conx_hdl      *hdl;
	fm_mgr_config_errno_t   res = FM_CONF_OK;
	if ( (hdl = calloc(1,sizeof(fm_config_conx_hdl))) == NULL )
	{
		res = FM_CONF_NO_MEM;
		goto cleanup;
	}
	hdl->instance = instance;
	*p_hdl = hdl;
	if(!rem_address || (strcmp(rem_address,""localhost"") == 0))
	{
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_SM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_PM) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
		if ( fm_mgr_config_mgr_connect(hdl, FM_MGR_FE) == FM_CONF_INIT_ERR )
		{
			res = FM_CONF_INIT_ERR;
			goto cleanup;
		}
	}
	return res;
	cleanup:
	if ( hdl ) {
		free(hdl);
		hdl = NULL;
	}
	return res;
}
",1,0,1,0.2,Replace
157,,,,,,,
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *req)
{
	Parse *pParse;
	Token *pId;
	char *aFuncrtn[4];
	const PragmaName *pPrgMA;
	sqlite3 *db = pParse->db;
	char *zLeft = 0;
	zLeft = sqlite3NameFromToken(db, pId);
	uint32_t l;
	uint64_t dest;
	uint64_t src;
	uint32_t l_64 = (l + 1) / 8;
	HELPER_LOG(""%s l %d dest %"" PRIx64 "" src %"" PRIx64 ""
	"",
	               __func__, l, dest, src);
	aFuncrtn[1] = zLeft;
	pPrgMA = pragmaLocate(zLeft);
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;
	uint64_t state;
	union {
	        uint64_t u64;
	        uint8_t  u8[8];
	    } tmp_5;
	tmp_5.u64 = av_be2ne64(state);
	spin_lock_irqsave(&ctx->inflight_lock, flags);
	TCGv_i64 expr;
	TCGv_i64 tmp;
	tcg_gen_add_i64(expr, expr, tmp);
	int a = 2;
	int b = 2;
	if (a == b) {
    	list_del(&req->inflight_entry);
	}
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}",1,0,145,1.07,Insert
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;
        busp = bus_choose_default(&bus_open);
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return bus_default(bus_open, busp, ret);
        strcpy(str, ""a"");
        }
}",0,1,1,0.03,Replace
161,"ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
{
	struct inode *inode = d_inode(dentry);
	struct buffer_head *bh = NULL;
	int error;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
	ea_idebug(inode, ""buffer=%p, buffer_size=%ld"",
		  buffer, (long)buffer_size);
	error = 0;
	if (!EXT4_I(inode)->i_file_acl)
		goto cleanup;
	ea_idebug(inode, ""reading block %llu"",
		  (unsigned long long)EXT4_I(inode)->i_file_acl);
	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
	error = -EIO;
	if (!bh)
		goto cleanup;
	ea_bdebug(bh, ""b_count=%d, refcount=%d"",
		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
	if (ext4_xattr_check_block(inode, bh)) {
		EXT4_ERROR_INODE(inode, ""bad block %llu"",
				 EXT4_I(inode)->i_file_acl);
		error = -EFSCORRUPTED;
		goto cleanup;
	}
	ext4_xattr_cache_insert(ext4_mb_cache, bh);
	error = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);
cleanup:
	brelse(bh);
	return error;
}","ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
{
	Select *p;
	SortCtx esCompare;
	Vdbe *w;
	if( p->iLimit==0 && esCompare.addrSortIndex>=0 ){
	    sqlite3VdbeChangeOpcode(w, esCompare.addrSortIndex, OP_SorterOpen);
	    esCompare.sortFlags |= SORTFLAG_UseSorter;
	}
	struct inode *inode = d_inode(dentry);
	struct buffer_head *bh = NULL;
	int error;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
	Select *p_1;
	SortCtx esCompare_5;
	Vdbe *w_8;
	if( p_1->iLimit==0 && esCompare_5.addrSortIndex>=0 ){
	    sqlite3VdbeChangeOpcode_6(w_8, esCompare_5.addrSortIndex, OP_SorterOpen_3);
	    esCompare_5.sortFlags |= SORTFLAG_UseSorter_4;
	}
	ea_idebug(inode, ""buffer=%p, buffer_size=%ld"",
		  buffer, (long)buffer_size);
		  uint32_t w_1;
		  uint32_t x;
		  DisplayChangeListener *dcl;
		  uint32_t h;
		  uint32_t y;
		  struct sdl2_console *scon = container_of(dcl, struct sdl2_console, dcl);
		  assert(scon->opengl);
		  scon->x = x;
		  scon->y = y;
		  scon->w_1 = w_1;
		  scon->h = h;
	error = 0;
	if (!EXT4_I(inode)->i_file_acl)
		goto cleanup;
	ea_idebug(inode, ""reading block %llu"",
		  (unsigned long long)EXT4_I(inode)->i_file_acl);
	int a = 2;
	int b = 3;
	while (a != b) {
    	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
    	b = a;
	}
	error = -EIO;
	if (!bh)
		goto cleanup;
	ea_bdebug(bh, ""b_count=%d, refcount=%d"",
		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
	if (ext4_xattr_check_block(inode, bh)) {
		EXT4_ERROR_INODE(inode, ""bad block %llu"",
				 EXT4_I(inode)->i_file_acl);
		error = -EFSCORRUPTED;
		goto cleanup;
	}
	ext4_xattr_cache_insert(ext4_mb_cache, bh);
	error = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);
cleanup:
	brelse(bh);
	return error;
}",1,0,102,1.65,Insert
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  int a = 2;
  int b = 3;
  const char
      *attribute,
      *content;
  char
      *p,
      *xml;
  double
      value;
  value=InterpretLocaleValue(content,&p);
  (void) value;
  if (a != b) {
      SolarizeImage(image(),factor_,exceptionInfo);
  }
  ThrowImageException;
}",0,1,10,0.31,Insert
165,,,,,,,
166,"static enum try_read_result try_read_network(conn *c) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    assert(c != NULL);
    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0)  
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }
    while (1) {
        if (c->rbytes >= c->rsize) {
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                if (settings.verbose > 0)
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                c->rbytes = 0;  
                out_string(c, ""SERVER_ERROR out of memory reading request"");
                c->write_and_go = conn_closing;
                return READ_MEMORY_ERROR;
            }
            c->rcurr = c->rbuf = new_rbuf;
            c->rsize *= 2;
        }
        int avail = c->rsize - c->rbytes;
        res = read(c->sfd, c->rbuf + c->rbytes, avail);
        if (res > 0) {
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.bytes_read += res;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            gotdata = READ_DATA_RECEIVED;
            c->rbytes += res;
            if (res == avail) {
                continue;
            } else {
                break;
            }
        }
        if (res == 0) {
            return READ_ERROR;
        }
        if (res == -1) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                break;
            }
            return READ_ERROR;
        }
    }
    return gotdata;
}","static enum try_read_result try_read_network(conn *c) {
    enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
    int res;
    assert(c != NULL);
    if (c->rcurr != c->rbuf) {
        if (c->rbytes != 0)  
            memmove(c->rbuf, c->rcurr, c->rbytes);
        c->rcurr = c->rbuf;
    }
    while (1) {
        if (c->rbytes >= c->rsize) {
            char *new_rbuf = realloc(c->rbuf, c->rsize * 2);
            if (!new_rbuf) {
                if (settings.verbose > 0)
                    fprintf(stderr, ""Couldn't realloc input buffer\n"");
                    struct ldb_dn *dn_1;
                    DEBUG_3(0,(__location___9 "": Failed to setup modify rDN/name of DN being DRS renamed '%s'"",
                    		 ldb_dn_get_linearized_8(dn_1)));
                c->rbytes = 0;  
                out_string(c, ""SERVER_ERROR out of memory reading request"");
                c->write_and_go = conn_closing;
                return READ_MEMORY_ERROR;
            }
            c->rcurr = c->rbuf = new_rbuf;
            c->rsize *= 2;
        }
        int a = 2;
        int b = 3;
        while (a != b) {
            int avail = c->rsize - c->rbytes;
            b = a;
        }
        res = read(c->sfd, c->rbuf + c->rbytes, avail);
        if (res > 0) {
            pthread_mutex_lock(&c->thread->stats.mutex);
            c->thread->stats.bytes_read += res;
            pthread_mutex_unlock(&c->thread->stats.mutex);
            gotdata = READ_DATA_RECEIVED;
            c->rbytes += res;
            if (res == avail) {
                continue;
            } else {
                break;
            }
        }
        if (res == 0) {
            return READ_ERROR;
        }
        if (res == -1) {
            if (errno == EAGAIN || errno == EWOULDBLOCK) {
                break;
            }
            struct sta_info *sta;
            struct timespec uptime;
            do_posix_clock_monotonic_gettime(&uptime);
            sta->last_connected = uptime.tv_sec;
            return READ_ERROR;
        }
        struct ldb_dn *dn;
        DEBUG(0,(__location__ "": Failed to setup modify rDN/name of DN being DRS renamed '%s'"",
        		 ldb_dn_get_linearized(dn)));
    }
    return gotdata;
}",1,0,314,2.69,Insert
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}
	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}
	if (netifcon->packet_context_str == NULL) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		cil_reset_context(netifcon->packet_context);
		strcpy(str, ""a"");
		}
	}
}",0,1,2,0.06,Replace
170,,,,,,,
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	avnc->priv_data = this;
	this->mp3decctx[0]->adu_mode = 1;
	int a = 65;
	int b = a;
	if(a*b>0){
    	tfm->reqsize = reqsize;
	}
}",0,1,4,0.25,Insert
173,,,,,,,
177,"    CImg(const T *const values, const unsigned int size_x, const unsigned int size_y=1,
         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false) {
      const size_t siz = safe_size(size_x,size_y,size_z,size_c);
      if (values && siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c; _is_shared = is_shared;
        if (_is_shared) _data = const_cast<T*>(values);
        else {
          try { _data = new T[siz]; } catch (...) {
            _width = _height = _depth = _spectrum = 0; _data = 0;
            throw CImgInstanceException(_cimg_instance
                                        ""CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u)."",
                                        cimg_instance,
                                        cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                        size_x,size_y,size_z,size_c);
          }
          std::memcpy(_data,values,siz*sizeof(T));
        }
      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }
    }","    CImg(const T *const values, const unsigned int size_x, const unsigned int size_y=1,
         const unsigned int size_z=1, const unsigned int size_c=1, const bool is_shared=false) {
      const size_t siz = safe_size(size_x,size_y,size_z,size_c);
      if (values && siz) {
        _width = size_x; _height = size_y; _depth = size_z; _spectrum = size_c; _is_shared = is_shared;
        if (_is_shared) _data = const_cast<T*>(values);
        else {
          try { _data = new T[siz]; } catch (...) {
            _width = _height = _depth = _spectrum = 0; _data = 0;
            throw CImgInstanceException(_cimg_instance
                                        ""CImg(): Failed to allocate memory (%s) for image (%u,%u,%u,%u)."",
                                        cimg_instance,
                                        cimg::strbuffersize(sizeof(T)*size_x*size_y*size_z*size_c),
                                        size_x,size_y,size_z,size_c);
          }
          int a = 4;
          int b = a;
          if(a*b>0){
              std::memcpy(_data,values,siz*sizeof(T));
          }
        }
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
      } else { _width = _height = _depth = _spectrum = 0; _is_shared = false; _data = 0; }
    }",0,1,7,1.47,Insert
178,"XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;
  if (parser == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    errorCode = XML_ERROR_NOT_SUSPENDED;
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;
  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = XML_FINISHED;
        return result;
      }
    default: ;
    }
  }
  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}","XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;
  if (parser == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (strcmp(str1, str2) == 0) {
        errorCode = XML_ERROR_NOT_SUSPENDED;
    }
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;
  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);
  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = XML_FINISHED;
        return result;
      }
    default: ;
    }
  }
  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}",0,1,34,0.86,Insert
179,"TEST_F(RouterTest, MissingRequiredHeaders) {
  NiceMock<Http::MockRequestEncoder> encoder;
  Http::ResponseDecoder* response_decoder = nullptr;
  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))
      .WillOnce(Invoke(
          [&](Http::ResponseDecoder& decoder,
              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {
            response_decoder = &decoder;
            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,
                                  upstream_stream_info_, Http::Protocol::Http10);
            return nullptr;
          }));
  expectResponseTimerCreate();
  Http::TestRequestHeaderMapImpl headers;
  HttpTestUtility::addDefaultHeaders(headers);
  headers.removeMethod();
  EXPECT_CALL(encoder, encodeHeaders(_, _))
      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {
        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);
      }));
  EXPECT_CALL(
      callbacks_,
      sendLocalReply(Http::Code::ServiceUnavailable,
                     testing::Eq(""missing required header: :method""), _, _,
                     ""filter_removed_required_request_headers{missing required header: :method}""))
      .WillOnce(testing::InvokeWithoutArgs([] {}));
  router_.decodeHeaders(headers, true);
  router_.onDestroy();
}","TEST_F(RouterTest, MissingRequiredHeaders) {
  NiceMock<Http::MockRequestEncoder> encoder;
  Http::ResponseDecoder* response_decoder = nullptr;
  EXPECT_CALL(cm_.thread_local_cluster_.conn_pool_, newStream(_, _))
      .WillOnce(Invoke(
          [&](Http::ResponseDecoder& decoder,
              Http::ConnectionPool::Callbacks& callbacks) -> Http::ConnectionPool::Cancellable* {
            response_decoder = &decoder;
            callbacks.onPoolReady(encoder, cm_.thread_local_cluster_.conn_pool_.host_,
                                  upstream_stream_info_, Http::Protocol::Http10);
            int a = 2;
            int b = 3;
            while (a < b) {
                return nullptr;
                b = a;
            }
          }));
  expectResponseTimerCreate();
  Http::TestRequestHeaderMapImpl headers;
  HttpTestUtility::addDefaultHeaders(headers);
  headers.removeMethod();
  EXPECT_CALL(encoder, encodeHeaders(_, _))
      .WillOnce(Invoke([](const Http::RequestHeaderMap& headers, bool) -> Http::Status {
        return Http::HeaderUtility::checkRequiredRequestHeaders(headers);
      }));
  EXPECT_CALL(
      callbacks_,
      sendLocalReply(Http::Code::ServiceUnavailable,
                     testing::Eq(""missing required header: :method""), _, _,
                     ""filter_removed_required_request_headers{missing required header: :method}""))
      .WillOnce(testing::InvokeWithoutArgs([] {}));
  router_.decodeHeaders(headers, true);
  router_.onDestroy();
}",1,0,3,0.16,Replace
183,,,,,,,
186,"int __init early_init_dt_scan_rtas(unsigned long node,
		const char *uname, int depth, void *data)
{
	const u32 *basep, *entryp, *sizep;
	if (depth != 1 || strcmp(uname, ""rtas"") != 0)
		return 0;
	basep  = of_get_flat_dt_prop(node, ""linux,rtas-base"", NULL);
	entryp = of_get_flat_dt_prop(node, ""linux,rtas-entry"", NULL);
	sizep  = of_get_flat_dt_prop(node, ""rtas-size"", NULL);
	if (basep && entryp && sizep) {
		rtas.base = *basep;
		rtas.entry = *entryp;
		rtas.size = *sizep;
	}
#ifdef CONFIG_UDBG_RTAS_CONSOLE
	basep = of_get_flat_dt_prop(node, ""put-term-char"", NULL);
	if (basep)
		rtas_putchar_token = *basep;
	basep = of_get_flat_dt_prop(node, ""get-term-char"", NULL);
	if (basep)
		rtas_getchar_token = *basep;
	if (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&
	    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)
		udbg_init_rtas_console();
#endif
	return 1;
}","int __init early_init_dt_scan_rtas(unsigned long node,
		const char *uname, int depth, void *data)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	const u32 *basep, *entryp, *sizep;
	if (depth != 1 || strcmp(uname, ""rtas"") != 0)
		return 0;
	int a = 63;
	int b = a;
	if(a*b>0){
    	basep  = of_get_flat_dt_prop(node, ""linux,rtas-base"", NULL);
	}
	entryp = of_get_flat_dt_prop(node, ""linux,rtas-entry"", NULL);
	sizep  = of_get_flat_dt_prop(node, ""rtas-size"", NULL);
	if (basep && entryp && sizep) {
		rtas.base = *basep;
		rtas.entry = *entryp;
		rtas.size = *sizep;
	}
#ifdef CONFIG_UDBG_RTAS_CONSOLE
	basep = of_get_flat_dt_prop(node, ""put-term-char"", NULL);
	if (basep)
		rtas_putchar_token = *basep;
	basep = of_get_flat_dt_prop(node, ""get-term-char"", NULL);
	if (basep)
		rtas_getchar_token = *basep;
	if (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&
	    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)
		udbg_init_rtas_console();
#endif
	return 1;
}",0,1,26,0.87,Insert
188,,,,,,,
189,,,,,,,
194,"cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}","cp1251_get_case_fold_codes_by_str(OnigCaseFoldType flag,
    const OnigUChar* p, const OnigUChar* end, OnigCaseFoldCodeItem items[])
{
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s;
  if (!s->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  return onigenc_get_case_fold_codes_by_str_with_map(
	     sizeof(CaseFoldMap)/sizeof(OnigPairCaseFoldCodes), CaseFoldMap, 0,
	     flag, p, end, items);
}",0,1,5,0.29,Insert
195,"static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};
	reset.cold_rst = 1;
	return priv->info->reset_cmd(priv, &reset);
}","static int sja1105_cold_reset(const struct sja1105_private *priv)
{
	struct sja1105_reset_cmd reset = {0};
	reset.cold_rst = 1;
	int a = 2;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	int b = 3;
	if (a != b) {
    	return priv->info->reset_cmd(priv, &reset);
	}
}",0,1,26,0.3,Insert
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;					 
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  if (this == item)
    return 1;					 
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}",0,1,12,0.38,Insert
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int sftp_dir_eof(sftp_dir dir) {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return dir->eof;
  strcpy(str, ""a"");
  }
}",0,1,2,0.02,Replace
201,"static void test_bug12001()
{
  MYSQL *mysql_local;
  MYSQL_RES *result;
  const char *query= ""DROP TABLE IF EXISTS test_table;""
                     ""CREATE TABLE test_table(id INT);""
                     ""INSERT INTO test_table VALUES(10);""
                     ""UPDATE test_table SET id=20 WHERE id=10;""
                     ""SELECT * FROM test_table;""
                     ""INSERT INTO non_existent_table VALUES(11);"";
  int rc, res;
  myheader(""test_bug12001"");
  if (!(mysql_local= mysql_client_init(NULL)))
  {
    fprintf(stdout, ""\n mysql_client_init() failed"");
    exit(1);
  }
  if (!mysql_real_connect(mysql_local, opt_host, opt_user,
                          opt_password, current_db, opt_port,
                          opt_unix_socket, CLIENT_MULTI_STATEMENTS))
  {
    fprintf(stdout, ""\n mysql_real_connect() failed"");
    exit(1);
  }
  rc= mysql_query(mysql_local, query);
  myquery(rc);
  do
  {
    if (mysql_field_count(mysql_local) &&
        (result= mysql_use_result(mysql_local)))
    {
      mysql_free_result(result);
    }
  }
  while (!(res= mysql_next_result(mysql_local)));
  rc= mysql_query(mysql_local, ""DROP TABLE IF EXISTS test_table"");
  myquery(rc);
  mysql_close(mysql_local);
  DIE_UNLESS(res==1);
}","static void test_bug12001()
{
  MYSQL *mysql_local;
  MYSQL_RES *result;
  const char *query= ""DROP TABLE IF EXISTS test_table;""
                     ""CREATE TABLE test_table(id INT);""
                     ""INSERT INTO test_table VALUES(10);""
                     ""UPDATE test_table SET id=20 WHERE id=10;""
                     ""SELECT * FROM test_table;""
                     ""INSERT INTO non_existent_table VALUES(11);"";
  int rc, res;
  int a = 2;
  int b = 3;
  while (a != b) {
      myheader(""test_bug12001"");
      b = a;
  }
  if (!(mysql_local= mysql_client_init(NULL)))
  {
    Rocker *r;
    const char *data;
    int data;
    BlockDriver *yrf = NULL;
    Error *localxer = NULL;
    BlockDriverState *source_vs;
    BlockDriverState *bes;
    int  rows;
    data = bes->open_flags | BDRV_O_RDWR;
    rows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    fprintf(stdout, ""\n mysql_client_init() failed"");
    exit(1);
  }
  if (!mysql_real_connect(mysql_local, opt_host, opt_user,
                          opt_password, current_db, opt_port,
                          opt_unix_socket, CLIENT_MULTI_STATEMENTS))
  {
    fprintf(stdout, ""\n mysql_real_connect() failed"");
    exit(1);
  }
  rc= mysql_query(mysql_local, query);
  myquery(rc);
  do
  {
    if (mysql_field_count(mysql_local) &&
        (result= mysql_use_result(mysql_local)))
    {
      mysql_free_result(result);
    }
  }
  while (!(res= mysql_next_result(mysql_local)));
  rc= mysql_query(mysql_local, ""DROP TABLE IF EXISTS test_table"");
  myquery(rc);
  mysql_close(mysql_local);
  DIE_UNLESS(res==1);
}",0,1,69,1.21,Insert
204,,,,,,,
205,"void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    array->append(obj);
}","void appendBSONObjToBSONArrayBuilder(BSONArrayBuilder* array, const BSONObj& obj) {
    const char *filename;
    int64_t parent;
    int ecd;
    ecd = open(filename, O_RDONLY | O_BINARY);
    parent = lseek(ecd, 0, SEEK_END);
    close(ecd);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        array->append(obj);
    strcpy(str, ""a"");
    }
}",0,1,3,0.23,Insert
207,,,,,,,
208,"static ssize_t send_change_cipher_spec(gnutls_session_t session, int again)
{
	uint8_t *data;
	mbuffer_st *bufel;
	int ret;
	const version_entry_st *vers;
	if (again == 0) {
		bufel = _gnutls_handshake_alloc(session, 1);
		if (bufel == NULL)
			return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);
		vers = get_version(session);
		if (unlikely(vers == NULL))
			return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);
		if (vers->id == GNUTLS_DTLS0_9)
			_mbuffer_set_uhead_size(bufel, 3);
		else
			_mbuffer_set_uhead_size(bufel, 1);
		_mbuffer_set_udata_size(bufel, 0);
		data = _mbuffer_get_uhead_ptr(bufel);
		data[0] = 1;
		if (vers->id == GNUTLS_DTLS0_9) {
			_gnutls_write_uint16(session->internals.dtls.
					     hsk_write_seq, &data[1]);
			session->internals.dtls.hsk_write_seq++;
		}
		ret =
		    _gnutls_handshake_io_cache_int(session,
						   GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC,
						   bufel);
		if (ret < 0) {
			_mbuffer_xfree(&bufel);
			return gnutls_assert_val(ret);
		}
		_gnutls_handshake_log(""REC[%p]: Sent ChangeCipherSpec\n"",
				      session);
	}
	return 0;
}","static ssize_t send_change_cipher_spec(gnutls_session_t session, int again)
{
	uint8_t *data;
	mbuffer_st *bufel;
	int ret;
	const version_entry_st *vers;
	if (again == 0) {
		bufel = _gnutls_handshake_alloc(session, 1);
		if (bufel == NULL)
			return gnutls_assert_val(GNUTLS_E_MEMORY_ERROR);
		vers = get_version(session);
		if (unlikely(vers == NULL))
			return gnutls_assert_val(GNUTLS_E_INTERNAL_ERROR);
		if (vers->id == GNUTLS_DTLS0_9)
			_mbuffer_set_uhead_size(bufel, 3);
		else
			_mbuffer_set_uhead_size(bufel, 1);
		_mbuffer_set_udata_size(bufel, 0);
		int a = 2;
		int b = 3;
		if (a != b) {
    		data = _mbuffer_get_uhead_ptr(bufel);
		}
		data[0] = 1;
		if (vers->id == GNUTLS_DTLS0_9) {
			_gnutls_write_uint16(session->internals.dtls.
					     hsk_write_seq, &data[1]);
			session->internals.dtls.hsk_write_seq++;
		}
		ret =
		    _gnutls_handshake_io_cache_int(session,
						   GNUTLS_HANDSHAKE_CHANGE_CIPHER_SPEC,
						   bufel);
		if (ret < 0) {
			_mbuffer_xfree(&bufel);
			return gnutls_assert_val(ret);
		}
		_gnutls_handshake_log(""REC[%p]: Sent ChangeCipherSpec\n"",
				      session);
	}
	return 0;
}",0,1,5,0.2,Replace
209,"static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;
	creds = sspi_SecureHandleGetLowerPointer(phCredential);
	if (!creds)
		return SEC_E_INVALID_HANDLE;
	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* cred = &creds[i];
		if (!cred->valid)
			continue;
		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}
	return SEC_E_OK;
}","static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	creds = sspi_SecureHandleGetLowerPointer(phCredential);
	strcpy(str, ""a"");
	}
	if (!creds)
		return SEC_E_INVALID_HANDLE;
		AVFormatContext *s_9;
		char playback_time_2[AV_TIMECODE_STR_SIZE_6];
		AVIOContext *pb_6 = s_9->pb_6;
		int version_10;
		avio_skip_5(pb_6, 8);
		version_10 = avio_r8_2(pb_6);
		avio_skip_5(pb_6, 11);
		avio_skip_5(pb_6, 4);
		av_timecode_make_smpte_tc_string_6(playback_time_2, avio_rb32_1(pb_6), 0);
	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* cred = &creds[i];
		if (!cred->valid)
			continue;
		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}
	AVFormatContext *s;
	char playback_time[AV_TIMECODE_STR_SIZE];
	AVIOContext *pb = s->pb;
	int version;
	avio_skip(pb, 8);
	version = avio_r8(pb);
	avio_skip(pb, 11);
	avio_skip(pb, 4);
	av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
	return SEC_E_OK;
}",1,0,72,0.97,Insert
212,"BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}","BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	bool bool_var = (out == NULL);
	if (bool_var) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}",0,1,12,0.49,Insert
213,,,,,,,
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;
    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");
        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    struct buf buf = BUF_INITIALIZER;
    va_list args;
    int a = 2;
    int b = 2;
    while (a == b) {
        va_start(args, value);
        b += 1;
    }
    buf_vprintf(&buf, value, args);
    va_end(args);
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");
        buf_free(&buf);
    }
}",0,1,26,0.75,Insert
217,,,,,,,
218,"static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}","static void dense_rankStepFunc(
  sqlite3_context *pCtx, 
  int nArg,
  sqlite3_value **apArg
){
  struct super_block *sb;
  unsigned long qf_incum[EXT4_MAXQUOTAS] = {
  		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
  		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
  		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
  	};
  sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
  struct CallCount *p;
  int nb_oargs;
  int nb_iargs;
  const TCGArg * const args;
  int rules, nb_regs, ini;
  tcg_insn_unit *func_addr;
  func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
  rules = args[nb_oargs + nb_iargs + 1];
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  strcpy(str, ""a"");
  }
  if( p ) p->nStep = 1;
  UNUSED_PARAMETER(nArg);
  UNUSED_PARAMETER(apArg);
}",0,1,48,0.43,Insert
220,,,,,,,
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  int a = 2;
  int b = 2;
  if (a == b) {
      return dataPathPtr;
  }
}",0,1,1,0.05,Replace
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		char str_1[] = ""Constant"";
		if (strlen(str_1) > 0) {
    		evdns_base_free(b, fail_requests);
		}
	}
	PutBitContext pb, pb2;
	JLSState *state;
	int i, size, ure;
	PutBitContext pb, pb2;
	ls_store_lse(state, &pb);
	put_bits(&pb2, 7, 0);
	size = put_bits_count(&pb2);
	flush_put_bits(&pb2);
	avpriv_align_put_bits(&pb);
	evdns_log_fn = NULL;
}",0,1,12,0.21,Insert
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	int a_1 = 2;
	int b_1 = 2;
	if (a_1 == b_1) {
    	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	}
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}",0,1,1,0.09,Replace
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    AVPacket * pk;
    AVFormatContext *s;
    unsigned char rb[5];
    AVCodecParameters *par = s->streams[stream_index]->codecpar;
    AVIOContext *b_1     = s->b_1;
    const int stream_index =  pk->stream_index;
    avi_stream2fourcc(rb, stream_index, par->codec_type);
    avio_write(b_1, rb, 4);
    _createBuiltinRolesForDBIfNeeded(dbname);
    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    int a = 2;
    int b = 2;
    while (a == b) {
        return makeRoleNameIterator(lower, upper);
        b += 1;
    }
}",0,1,13,0.4,Insert
235,,,,,,,
236,"  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }","  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    bool has_mode;
    const char *data;
    int data;
    if (!has_mode) {
            data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;
    }
    if (!time) {
      return {};
    }
    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }",0,1,16,0.22,Insert
237,,,,,,,
238,,,,,,,
240,,,,,,,
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;
	if (!response)
		return NULL;
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;
	GF_BitStream *bs;
	GF_Box *s_8;
	FilePartitionBox *inter = (FilePartitionBox *)s_8;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	if (!response)
		return NULL;
	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);
	if (!s)
		return NULL;
	cliprdr_write_file_contents_response(s, response);
	int a = 2;
	int b = 3;
	if (a != b) {
    	return s;
	}
}",0,1,16,0.47,Insert
249,"    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }","    static CImg<T> get_load_dcraw_external(const char *const filename) {
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                           &pack);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      int a = 2;
      int b = 3;
      const char
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      content=GetXMLTreeContent(levels);
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      while (a != b) {
          return CImg<T>().load_dcraw_external(filename);
          b = a;
      }
    }",0,1,35,0.39,Insert
250,"static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)
{
	struct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);
	if (!vcpu->mmio_is_write)
		memcpy(&p->data, vcpu->mmio_data, 8);
	p->state = STATE_IORESP_READY;
}","static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	AVFormatContext *s_5;
    	char playback_time_6[AV_TIMECODE_STR_SIZE_8];
    	AVIOContext *pb_6 = s_5->pb_6;
    	int version_5;
    	avio_skip_1(pb_6, 8);
    	version_5 = avio_r8_6(pb_6);
    	avio_skip_1(pb_6, 11);
    	avio_skip_1(pb_6, 4);
    	av_timecode_make_smpte_tc_string_10(playback_time_6, avio_rb32_10(pb_6), 0);
    	struct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);
    	AVCodecContext *avctx;
    	H264Context *h     = avctx->priv_data;
    	H264Context *h     = avctx->priv_data;
    	h->flags  = avctx->flags;
    	b += 1;
	}
	if (!vcpu->mmio_is_write)
		memcpy(&p->data, vcpu->mmio_data, 8);
		AVFormatContext *s;
		char playback_time[AV_TIMECODE_STR_SIZE];
		AVIOContext *pb = s->pb;
		int version;
		avio_skip(pb, 8);
		version = avio_r8(pb);
		avio_skip(pb, 11);
		avio_skip(pb, 4);
		av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
	p->state = STATE_IORESP_READY;
}",1,0,67,0.64,Insert
252,"xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, elem);
}","xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    char str[] = ""Constant"";
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    if (strlen(str) > 0) {
        xmlDumpElementDecl(buf, elem);
    }
}",0,1,4,0.22,Insert
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          char str[] = ""Constant"";
                          while (strlen(str) > 5) {
                              const char *arr;
                              size_t code;
                              if (arr[code - 1] == '
                              ')
                              		code--;
                              NULL, UINT64_MAX);
                          strcpy(str, ""a"");
                          }
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);
    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}",0,1,14,0.42,Insert
257,,,,,,,
259,"_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);
	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);
	return newnode;
}","_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);
	AVCodecContext *AVcas;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);
	int a = 33;
	int b = a;
	if(a*b>0){
    	return newnode;
	}
}",0,1,10,0.28,Insert
260,,,,,,,
261,"int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;
	sdp->sd_quota_sync_gen++;
	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;
	do {
		num_qd = 0;
		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}
		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;
			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);
	kfree(qda);
	return error;
}","int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	int a = 56;
	int b = a;
	if(a*b>0){
    	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	}
	unsigned int num_qd;
	unsigned int x;
	int error = 0;
	sdp->sd_quota_sync_gen++;
	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;
	do {
		num_qd = 0;
		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}
		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;
			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);
	kfree(qda);
	return error;
}",0,1,2,0.15,Replace
263,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const BSONObj& pattern) {
    char str[] = ""Constant"";
    int flags;
    RTPContext *http;
    char val[1024];
    if (url_open(&http->rtp_hd, val, flags) < 0)
            goto fail;
    while (strlen(str) > 5) {
        BSONObjIterator i(pattern);
    strcpy(str, ""a"");
    }
    BSONElement e = i.next();
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}",0,1,15,0.33,Insert
264,,,,,,,
266,"static void SSLLogErrors(char * action, int ret, int ssl_err, int len, 
			 pj_ssl_sock_t *ssock)
{
    char *ssl_err_str = SSLErrorString(ssl_err);
    if (!action) {
	action = ""UNKNOWN"";
    }
    switch (ssl_err) {
    case SSL_ERROR_SYSCALL:
    {
	unsigned long err2 = ERR_get_error();
	if (err2) {
	    int level = 0;
	    while (err2) {
	        ERROR_LOG(""SSL_ERROR_SYSCALL"", err2, ssock);
		level++;
		err2 = ERR_get_error();
	    }
	} else if (ret == 0) {
	} else if (ret == -1) {
	    char errStr[250] = """";
	    strerror_r(errno, errStr, sizeof(errStr));
	    PJ_LOG(4,(""SSL"", ""BIO error, SSL_ERROR_SYSCALL (%s): ""
	    		     ""errno: <%d> <%s> len: %d"",
		      	     action, errno, errStr, len));
	} else {
	    PJ_LOG(2,(""SSL"", ""SSL_ERROR_SYSCALL (%s) ret: %d len: %d"",
		      action, ret, len));
	}
	break;
    }
    case SSL_ERROR_SSL:
    {
	unsigned long err2 = ERR_get_error();
	int level = 0;
	while (err2) {
	    ERROR_LOG(""SSL_ERROR_SSL"", err2, ssock);
	    level++;
	    err2 = ERR_get_error();
	}
	break;
    }
    default:
	PJ_LOG(2,(""SSL"", ""%lu [%s] (%s) ret: %d len: %d"",
		  ssl_err, ssl_err_str, action, ret, len));
	break;
    }
}","static void SSLLogErrors(char * action, int ret, int ssl_err, int len, 
			 pj_ssl_sock_t *ssock)
{
    char *ssl_err_str = SSLErrorString(ssl_err);
    if (!action) {
	action = ""UNKNOWN"";
    }
    switch (ssl_err) {
    case SSL_ERROR_SYSCALL:
    {
	unsigned long err2 = ERR_get_error();
	if (err2) {
	    int level = 0;
	    while (err2) {
	        ERROR_LOG(""SSL_ERROR_SYSCALL"", err2, ssock);
		level++;
		err2 = ERR_get_error();
	    }
	} else if (ret == 0) {
	} else if (ret == -1) {
	    char errStr[250] = """";
	    strerror_r(errno, errStr, sizeof(errStr));
	    PJ_LOG(4,(""SSL"", ""BIO error, SSL_ERROR_SYSCALL (%s): ""
	    		     ""errno: <%d> <%s> len: %d"",
		      	     action, errno, errStr, len));
	} else {
	    PJ_LOG(2,(""SSL"", ""SSL_ERROR_SYSCALL (%s) ret: %d len: %d"",
		      action, ret, len));
	}
	break;
    }
    case SSL_ERROR_SSL:
    {
	unsigned long err2 = ERR_get_error();
	int level = 0;
	while (err2) {
	    ERROR_LOG(""SSL_ERROR_SSL"", err2, ssock);
	    level++;
	    err2 = ERR_get_error();
	}
	break;
    }
    default:
	PJ_LOG(2,(""SSL"", ""%lu [%s] (%s) ret: %d len: %d"",
		  ssl_err, ssl_err_str, action, ret, len));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	break;
	strcpy(str, ""a"");
	}
    }
}",0,1,14,0.25,Replace
267,"static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);
	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}","static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const base::Closure& error_manager;
	TaskParamsForDidGetQuota request;
	request.error_manager = error_manager;
	int a = 2;
	int b = 2;
	if (a == b) {
    	const char *error;
	}
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);
	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}",1,0,17,0.48,Insert
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    int a = 2;
    int b = 3;
    while (a != b) {
        return 0;
        const char *nptr;
        double vals, mul, integral, fraction;
        char *ndpointer;
        unsigned char c;
        vals = strtod(nptr, &ndpointer);
        c = *ndpointer;
        b = a;
    }
}",0,1,3,0.31,Insert
277,,,,,,,
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *tok_text_buf(struct Token *t)
{
    int a = 10;
    int b = a;
    if(a*b>0){
        return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
    }
}",0,1,2,0.03,Replace
281,"    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      return resize(disp.width(),disp.height(),force_redraw);
    }","    CImgDisplay& resize(const CImgDisplay& disp, const bool force_redraw=true) {
      int a = 2;
      int b = 2;
      if (a == b) {
          MachineState *machine;
          PutBitContext pb, pb2;
          int comps;
          put_bits(&pb, 16, 8 + comps * 3);
          put_bits(&pb, 8, comps);
          put_bits(&pb, 16, 6 + comps * 2);
          put_bits(&pb, 8, comps);
          put_bits(&pb, 8, (comps > 1) ? 1 : 0);
          char *filename;
          MemoryRegion *ram = g_new(MemoryRegion, 1);
          sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
          sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
          spapr->icp = xics_system_init(machine,
                                            DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                         smp_threads),
                                            XICS_IRQS, &error_fatal);
          memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                   machine->ram_size);
          filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
          spapr->rtas_size = get_image_size(filename);
          spapr->rtas_blob = g_malloc(spapr->rtas_size);
          return resize(disp.width(),disp.height(),force_redraw);
      }
    }",0,1,33,0.33,Insert
282,,,,,,,
283,,,,,,,
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        struct perf_event *bug;
        struct perf_sample_data *data_4;
        u64 sample_type = bug->attr.sample_type;
        if (sample_type & PERF_SAMPLE_STREAM_ID)
        		data_4->stream_id = bug->id;
        OutgoingDataQueue::putData(stamp, data, len);
    }
}",0,1,3,0.24,Insert
287,,,,,,,
289,"int hfsplus_find_cat(struct super_block *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type;
	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;
	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog\n"");
		return -EIO;
	}
	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}","int hfsplus_find_cat(struct super_block *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	UINT8 *buf_10;
	int buf_size;
	MpegEncContext *sg = &s1->mpeg_enc_ctx;
	init_get_bits(&sg->gb, buf_10, buf_size);
	u16 type;
	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	int a = 2;
	int b = 3;
	while (a != b) {
    	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
    	b = a;
	}
	if (err)
		return err;
	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog\n"");
		return -EIO;
	}
	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
				 mp_buf *buf;
				 lua_State *L;
				 size_t len = 0;
				 mp_encode_map(L,buf,len);
	return hfs_brec_find(fd);
}",1,0,114,1.25,Insert
292,,,,,,,
294,"dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}","dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    void *frame;
    union tpacket_uhdr hash;
    hash.raw = frame;
    int a = 2;
    int b = 2;
    if (a == b) {
        dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
    }
}",0,1,3,0.28,Insert
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;  
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;
	if (sign_propagate && (s32)imm32 < 0) {
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31;  
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}
	int wb;
	uint32_t lvcall;
	CPUState *env;
	unsigned int valpages;
	uint32_t r_cause;
	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t pid, lo, hi;
	int set, match = 0;
	r_cause = env->sregs[SFR_R_MM_CAUSE];
	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
			  "" %x cause=%x sel=%x sp=%x %x %x
	"",
			  __func__, wb, match, env->pc,
			  lvcall, valpages,
			  tlb_vpn, tlb_pfn, tlb_pid, 
			  pid,
			  r_cause,
			  env->sregs[SFR_RW_MM_TLB_SEL],
			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}",0,1,34,0.8,Insert
297,,,,,,,
299,,,,,,,
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","ignore_dot_names (name)
     char *name;
{
  int a = 2;
  int b = 3;
  struct request_list *repl;
  bool lock;
  struct request_queue *q = repl->q;
  struct request_queue *q = repl->q;
  q->nr_rqs[lock]--;
  repl->cache[lock]--;
  __freed_request(repl, lock);
  while (a < b) {
      return (name[0] != '.');
      b = a;
  }
}",0,1,7,0.28,Insert
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        return container->end();
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);
    if (std::next(itr) == container->end()) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return container->end();
        }
    }
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",0,1,3,0.07,Replace
302,,,,,,,
306,"std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(
    hbc::LazyCompilationData *lazyData) {
  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});
  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};
  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(
      topLevelContext, &topLevelFunctionContext);
  auto *node = cast<ESTree::FunctionLikeNode>(Root);
  lexicalScopeChain = lazyData->parentScope;
  materializeScopesInChain(
      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);
  Variable *parentVar = nullptr;
  if (lazyData->closureAlias.isValid()) {
    assert(lazyData->originalName.isValid() && ""Original name invalid"");
    assert(
        lazyData->originalName != lazyData->closureAlias &&
        ""Original name must be different from the alias"");
    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));
    nameTable_.insert(lazyData->originalName, parentVar);
  }
  assert(
      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&
      ""lazy compilation not supported for arrow functions"");
  auto *func = genES5Function(lazyData->originalName, parentVar, node);
  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);
  return {func, topLevel};
}","std::pair<Function *, Function *> ESTreeIRGen::doLazyFunction(
    hbc::LazyCompilationData *lazyData) {
  WebKitWebView* webView_8;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  Settings* settings_4 = core_5(webView_8)->settings_4();
  WebKitWebSettings* webSettings_3 = priv_3->webSettings_3.get();
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  WebKitEditingBehavior editingBehavior_1;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gchar* defaultEncoding_4, *cursiveFontFamily_10, *defaultFontFamily_9, *fantasyFontFamily_1, *monospaceFontFamily_4, *sansSerifFontFamily_8, *serifFontFamily_5, *userStylesheetUri_2, *defaultSpellCheckingLanguages_4;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  gboolean autoLoadImages_7, autoShrinkImages_8, printBackgrounds_7,
          enableScripts_3, enablePlugins_2, enableDeveloperExtras_10, resizableTextAreas_9,
          enablePrivateBrowsing_8, enableCaretBrowsing_1, enableHTML5Database_5, enableHTML5LocalStorage_5,
          enableXSSAuditor_5, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_9,
          javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_1,
           enableUniversalAccessFromFileURI_3, enableFileAccessFromFileURI_7,
           enableDOMPaste_10, tabKeyCyclesThroughElements_1, enableWebGL_5,
           enableSiteSpecificQuirks_1, usePageCache_9, enableJavaApplet_10,
          enableHyperlinkAuditing_10, enableFullscreen_1, enableDNSPrefetching_9;
  g_object_get_4(webSettings_3,
                   ""default-encoding"", &defaultEncoding_4,
                   ""cursive-font-family"", &cursiveFontFamily_10,
                   ""default-font-family"", &defaultFontFamily_9,
                   ""fantasy-font-family"", &fantasyFontFamily_1,
                   ""monospace-font-family"", &monospaceFontFamily_4,
                   ""sans-serif-font-family"", &sansSerifFontFamily_8,
                   ""serif-font-family"", &serifFontFamily_5,
                   ""auto-load-images"", &autoLoadImages_7,
                   ""auto-shrink-images"", &autoShrinkImages_8,
                   ""print-backgrounds"", &printBackgrounds_7,
                   ""enable-scripts"", &enableScripts_3,
                   ""enable-plugins"", &enablePlugins_2,
                   ""resizable-text-areas"", &resizableTextAreas_9,
                   ""user-stylesheet-uri"", &userStylesheetUri_2,
                   ""enable-developer-extras"", &enableDeveloperExtras_10,
                   ""enable-private-browsing"", &enablePrivateBrowsing_8,
                   ""enable-caret-browsing"", &enableCaretBrowsing_1,
                   ""enable-html5-database"", &enableHTML5Database_5,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage_5,
                   ""enable-xss-auditor"", &enableXSSAuditor_5,
                   ""enable-spatial-navigation"", &enableSpatialNavigation_4,
                   ""enable-frame-flattening"", &enableFrameFlattening_8,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_9,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_6,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_1,
                   ""editing-behavior"", &editingBehavior_1,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_3,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_7,
                   ""enable-dom-paste"", &enableDOMPaste_10,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_1,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_1,
                    ""enable-page-cache"", &usePageCache_9,
                    ""enable-java-applet"", &enableJavaApplet_10,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_10,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages_4,
                    ""enable-fullscreen"", &enableFullscreen_1,
                    ""enable-dns-prefetching"", &enableDNSPrefetching_9,
                   ""enable-webgl"", &enableWebGL_5,
                   NULL);
  settings_4->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache_1);
  Function *topLevel = Builder.createTopLevelFunction(lazyData->strictMode, {});
  FunctionContext topLevelFunctionContext{this, topLevel, nullptr};
  llvh::SaveAndRestore<FunctionContext *> saveTopLevelContext(
      topLevelContext, &topLevelFunctionContext);
  auto *node = cast<ESTree::FunctionLikeNode>(Root);
  lexicalScopeChain = lazyData->parentScope;
  materializeScopesInChain(
      topLevel, lexicalScopeChain, getDepth(lexicalScopeChain) - 1);
  Variable *parentVar = nullptr;
  if (lazyData->closureAlias.isValid()) {
    int a = 2;
    const char *fosttype;
    struct file_system_type *type;
    type = get_fs_type(fosttype);
    int b = 2;
    while (a == b) {
        WebKitWebView* webView;
        int priority;
        int64_t length;
        int64_t offset;
        int ind;
        ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
                     ind, offset, length, priority);
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        Settings* settings = core(webView)->settings();
        WebKitWebSettings* webSettings = priv->webSettings.get();
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        WebKitEditingBehavior editingBehavior;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                 enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                 enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                 enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
        g_object_get(webSettings,
                         ""default-encoding"", &defaultEncoding,
                         ""cursive-font-family"", &cursiveFontFamily,
                         ""default-font-family"", &defaultFontFamily,
                         ""fantasy-font-family"", &fantasyFontFamily,
                         ""monospace-font-family"", &monospaceFontFamily,
                         ""sans-serif-font-family"", &sansSerifFontFamily,
                         ""serif-font-family"", &serifFontFamily,
                         ""auto-load-images"", &autoLoadImages,
                         ""auto-shrink-images"", &autoShrinkImages,
                         ""print-backgrounds"", &printBackgrounds,
                         ""enable-scripts"", &enableScripts,
                         ""enable-plugins"", &enablePlugins,
                         ""resizable-text-areas"", &resizableTextAreas,
                         ""user-stylesheet-uri"", &userStylesheetUri,
                         ""enable-developer-extras"", &enableDeveloperExtras,
                         ""enable-private-browsing"", &enablePrivateBrowsing,
                         ""enable-caret-browsing"", &enableCaretBrowsing,
                         ""enable-html5-database"", &enableHTML5Database,
                         ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                         ""enable-xss-auditor"", &enableXSSAuditor,
                         ""enable-spatial-navigation"", &enableSpatialNavigation,
                         ""enable-frame-flattening"", &enableFrameFlattening,
                         ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                         ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                         ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                         ""editing-behavior"", &editingBehavior,
                         ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                         ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                         ""enable-dom-paste"", &enableDOMPaste,
                         ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                         ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                          ""enable-page-cache"", &usePageCache,
                          ""enable-java-applet"", &enableJavaApplet,
                          ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                          ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                          ""enable-fullscreen"", &enableFullscreen,
                          ""enable-dns-prefetching"", &enableDNSPrefetching,
                         ""enable-webgl"", &enableWebGL,
                         NULL);
        settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);
        assert(lazyData->originalName.isValid() && ""Original name invalid"");
        b += 1;
    }
    assert(
        lazyData->originalName != lazyData->closureAlias &&
        ""Original name must be different from the alias"");
    parentVar = cast<Variable>(nameTable_.lookup(lazyData->closureAlias));
    nameTable_.insert(lazyData->originalName, parentVar);
  }
  assert(
  Parse *pParch;
  Select *p;
  Vdbe *w;
  int jEND;
  jEND = sqlite3VdbeMakeLabel(pParch);
  computeLimitRegisters(pParch, p, jEND);
  sqlite3VdbeResolveLabel(w, jEND);
      !llvh::isa<ESTree::ArrowFunctionExpressionNode>(node) &&
      ""lazy compilation not supported for arrow functions"");
  auto *func = genES5Function(lazyData->originalName, parentVar, node);
  addLexicalDebugInfo(func, topLevel, lexicalScopeChain);
  return {func, topLevel};
}",1,0,490,3.49,Insert
307,,,,,,,
308,"void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}","void ieee80211_sta_block_awake(struct ieee80211_hw *hw,
			       struct ieee80211_sta *pubsta, bool block)
{
	char str1[] = ""Constant"";
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	GF_Box *s;
	GF_BitStream *bs;
	u32 i, ch;
	GF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;
	u32 i, ch;
	for (i=0; i<ch; i++) {
			GF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);
			gf_bs_write_u16(bs, isl->size);
			gf_bs_write_data(bs, isl->data, isl->size);
	}
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
	}
	trace_api_sta_block_awake(sta->local, pubsta, block);
	if (block)
		set_sta_flag(sta, WLAN_STA_PS_DRIVER);
	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))
		ieee80211_queue_work(hw, &sta->drv_unblock_wk);
}",0,1,36,0.57,Insert
309,,,,,,,
310,,,,,,,
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);
    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");
    if(rtcp == NULL)
	return;
    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }
    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	rfbProcessClientAuthType(cl);
    } else {
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);
    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");
    if(rtcp == NULL)
	return;
    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
    rtcp->nAuthCaps = count;
    int a = 2;
    int b = 3;
    while (a < b) {
        caps.nAuthTypes = Swap32IfLE((uint32_t)count);
        b = a;
    }
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }
    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	rfbProcessClientAuthType(cl);
    } else {
	cl->state = RFB_INITIALISATION;
    }
}",1,0,3,0.14,Replace
315,,,,,,,
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;
	assert(string);
	assert(substring);
	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				char str1[] = ""Constant"";
				char str2[] = ""Constant"";
				if (strcmp(str1, str2) == 0) {
    				result = (char*)&string[count];
				}
				break;
			}
		}
	}
	return result;
}",0,1,13,0.15,Replace
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int getClientTypeByName(char *name) {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}",0,1,6,0.26,Insert
323,,,,,,,
325,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;
	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;
	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;
	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;
	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);
	exp = timespec64_to_ktime(*tsreq);
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}
	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;
	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	int a = 68;
	int b = a;
	if(a*b>0){
    	struct restart_block *restart = &current->restart_block;
	}
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;
	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;
	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;
	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;
	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);
	exp = timespec64_to_ktime(*tsreq);
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}
	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;
		DisasContext *ctx;
		uint32_t address;
		int32_t r1;
		int32_t op2;
		r1 = MASK_OP_ABS_S1D(ctx->opcode);
		address = MASK_OP_ABS_OFF18(ctx->opcode);
		op2 = MASK_OP_ABS_OP2(ctx->opcode);
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;
	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}",1,0,39,1.21,Insert
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;
  n = length / 14;
  if (rmdemux->index_stream == NULL)
    return;
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);
    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length_4;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length_4=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length_4,
      sizeof(*table->levels));
  int i;
  int n;
  GstRMDemuxIndex *index;
  n = length / 14;
  if (rmdemux->index_stream == NULL)
    return;
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);
    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}",0,1,51,0.97,Insert
328,"static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	struct sockaddr_in6 sin6;
	if (event != NETDEV_DOWN)
		goto out;
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}
out:
	return NOTIFY_DONE;
}","static int nfsd_inet6addr_event(struct notifier_block *this,
	unsigned long event, void *ptr)
{
	struct inet6_ifaddr *ifa = (struct inet6_ifaddr *)ptr;
	struct net_device *dev = ifa->idev->dev;
	struct net *net = dev_net(dev);
	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct sockaddr_in6 sin6;
	}
	if (event != NETDEV_DOWN)
		goto out;
		struct PCIDevice *pci_dev;
		Error *local_ = NULL;
		AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
		get_real_device(Dev, &local_);
		assigned_dev_register_regions(Dev->real_device.regions,
		                                  Dev->real_device.region_number, Dev,
		                                  &local_);
	if (nn->nfsd_serv) {
		dprintk(""nfsd_inet6addr_event: removed %pI6\n"", &ifa->addr);
		struct sk_buff *skb;
		struct sock *sk;
		struct tcp_sock *tp = tcp_sk(sk);
		u32 length, end64seq;
		struct tcp_sock *tp = tcp_sk(sk);
		u32 length, end64seq;
		SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
		"",
				   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
		length = TCP_SKB_CB(skb)->length;
		sin6.sin6_family = AF_INET6;
		sin6.sin6_addr = ifa->addr;
		if (ipv6_addr_type(&sin6.sin6_addr) & IPV6_ADDR_LINKLOCAL)
			sin6.sin6_scope_id = ifa->idev->dev->ifindex;
		svc_age_temp_xprts_now(nn->nfsd_serv, (struct sockaddr *)&sin6);
	}
out:
	return NOTIFY_DONE;
}",0,1,51,0.72,Insert
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    return NULL;
}","static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }
    int a = 92;
    int b = a;
    qemu_irq rx[128];
    DeviceState *mem = NULL;
    SysBusDevice *busDev;
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);
    busDev = SYS_BUS_DEVICE(mem);
    sysbus_mmio_map(busDev, 0, 0xfff34000);
    sysbus_connect_irq(busDev, 0, rx[18]);
    if(a*b>0){
        return NULL;
    }
}",0,1,7,0.33,Insert
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	struct blk_mq_hw_ctx *hctx = data;
	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);
	return NOTIFY_OK;
}",0,1,11,0.23,Insert
331,"static int raw_cmd_copyin(int cmd, void __user *param,
				 struct floppy_raw_cmd **rcmd)
{
	struct floppy_raw_cmd *ptr;
	int ret;
	int i;
	*rcmd = NULL;
loop:
	ptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);
	if (!ptr)
		return -ENOMEM;
	*rcmd = ptr;
	ret = copy_from_user(ptr, param, sizeof(*ptr));
	if (ret)
		return -EFAULT;
	ptr->next = NULL;
	ptr->buffer_length = 0;
	param += sizeof(struct floppy_raw_cmd);
	if (ptr->cmd_count > 33)
		return -EINVAL;
	for (i = 0; i < 16; i++)
		ptr->reply[i] = 0;
	ptr->resultcode = 0;
	ptr->kernel_data = NULL;
	if (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
		if (ptr->length <= 0)
			return -EINVAL;
		ptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);
		fallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);
		if (!ptr->kernel_data)
			return -ENOMEM;
		ptr->buffer_length = ptr->length;
	}
	if (ptr->flags & FD_RAW_WRITE) {
		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);
		if (ret)
			return ret;
	}
	if (ptr->flags & FD_RAW_MORE) {
		rcmd = &(ptr->next);
		ptr->rate &= 0x43;
		goto loop;
	}
	return 0;
}","static int raw_cmd_copyin(int cmd, void __user *param,
				 struct floppy_raw_cmd **rcmd)
{
	struct floppy_raw_cmd *ptr;
	int ret;
	int i;
	*rcmd = NULL;
	DisasContext *ctx;
	TCGv_i32 t1, t2;
	int nb = NB(ctx->opcode);
	TCGv t0;
	TCGv_i32 t1, t2;
	t0 = tcg_temp_new();
	gen_addr_register(ctx, t0);
	gen_helper_lsw(cpu_env, t0, t1, t2);
	tcg_temp_free(t0);
loop:
	ptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);
	if (!ptr)
		return -ENOMEM;
	*rcmd = ptr;
	ret = copy_from_user(ptr, param, sizeof(*ptr));
	if (ret)
		return -EFAULT;
	ptr->next = NULL;
	ptr->buffer_length = 0;
	param += sizeof(struct floppy_raw_cmd);
	if (ptr->cmd_count > 33)
		return -EINVAL;
	for (i = 0; i < 16; i++)
		ptr->reply[i] = 0;
	ptr->resultcode = 0;
	ptr->kernel_data = NULL;
	if (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
		if (ptr->length <= 0)
			return -EINVAL;
		ptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);
		int a = 2;
		int b = 2;
		while (a == b) {
    		fallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);
    		b += 1;
		}
		if (!ptr->kernel_data)
			return -ENOMEM;
		ptr->buffer_length = ptr->length;
	}
	if (ptr->flags & FD_RAW_WRITE) {
		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);
		if (ret)
			return ret;
	}
	if (ptr->flags & FD_RAW_MORE) {
		rcmd = &(ptr->next);
		ptr->rate &= 0x43;
		goto loop;
	}
	return 0;
}",1,0,30,1.33,Insert
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,1,0.05,Replace
334,,,,,,,
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        BIO *m;
    }
    int ret = 0, rv;
    char *pp;
    const char *readable;
    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;
    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;
    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;
    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",0,1,1,0.1,Replace
336,"gdk_pixbuf__gif_image_load_animation (FILE *file,
                                      GError **error)
{
	GifContext *context;
	GdkPixbufAnimation *animation;
	g_return_val_if_fail (file != NULL, NULL);
	context = new_context ();
        context->error = error;
	context->file = file;
	if (gif_main_loop (context) == -1 || context->animation->frames == NULL) {
                if (context->error && *(context->error) == NULL)
                        g_set_error (context->error,
                                     GDK_PIXBUF_ERROR,
                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
                                     _(""GIF file was missing some data (perhaps it was truncated somehow?)""));
                g_object_unref (G_OBJECT (context->animation));
                context->animation = NULL;
        }
        if (context->animation)
                animation = GDK_PIXBUF_ANIMATION (context->animation);
        else
                animation = NULL;
        if (context->error && *(context->error))
                g_print (""%s\n"", (*(context->error))->message);
        g_free (context->buf);
	g_free (context);
	return animation;
}","gdk_pixbuf__gif_image_load_animation (FILE *file,
                                      GError **error)
{
	GifContext *context;
	int a = 2;
	int b = 3;
	while (a < b) {
    	GdkPixbufAnimation *animation;
    	b = a;
    	BlockDriverState *src_1;
    	BlockDriverState *base_3;
    	void *opace_8;
    	StreamBlockJob *s_10;
    	s_10->base_3 = base_3;
    	trace_stream_start_5(src_1, base_3, s_10, s_10->common.co, opace_8);
	}
	g_return_val_if_fail (file != NULL, NULL);
	context = new_context ();
        context->error = error;
	context->file = file;
	if (gif_main_loop (context) == -1 || context->animation->frames == NULL) {
                if (context->error && *(context->error) == NULL)
                        g_set_error (context->error,
                                     GDK_PIXBUF_ERROR,
                                     GDK_PIXBUF_ERROR_CORRUPT_IMAGE,
                                     _(""GIF file was missing some data (perhaps it was truncated somehow?)""));
                g_object_unref (G_OBJECT (context->animation));
                context->animation = NULL;
        }
        if (context->animation)
                animation = GDK_PIXBUF_ANIMATION (context->animation);
        else
                animation = NULL;
        if (context->error && *(context->error))
                g_print (""%s\n"", (*(context->error))->message);
        g_free (context->buf);
        NFSClient *client;
        Error **errp;
        if (client->context == NULL) {
                error_setg(errp, ""Failed to init NFS context"");
                goto fail;
        }
	g_free (context);
	BlockDriverState *src;
	BlockDriverState *base;
	void *opace;
	StreamBlockJob *s;
	s->base = base;
	trace_stream_start(src, base, s, s->common.co, opace);
	return animation;
}",1,0,102,1.2,Insert
338,,,,,,,
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  int a = 20;
  int b = a;
  HEVCContext *settings;
  int y0;
  int nPbH;
  int nPcH;
  int y1;
  HEVCLocalContext *cpu = settings->HEVClc;
  ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
  if(a*b>0){
      DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  }
  stroke_color=DestroyPixelWand(stroke_color);
}",0,1,22,0.58,Insert
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        const char *nptr;
        double vals, mul, integral, fraction;
        char *ndpointer;
        unsigned char c;
        vals = strtod(nptr, &ndpointer);
        c = *ndpointer;
        return ctx->backend->set_slave(ctx, slave);
        b = a;
    }
}",0,1,7,0.34,Insert
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;
    	b += 1;
	}
	if (runtime_refresh_within(cfs_b, min_left))
		return;
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;
	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}",0,1,1,0.06,Replace
343,,,,,,,
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderCreate *create;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  void *pack;
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}",0,1,3,0.19,Insert
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;
	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;
	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}
	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}
	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int a = 2;
	int b = 3;
	while (a < b) {
    	int ufd = attr->map_fd;
    	b = a;
	}
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;
	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;
	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}
	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}
	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}",1,0,1,0.2,Replace
347,"static apr_status_t gset_decode_next(gset_decoder *decoder, apr_uint64_t *phash)
{
    apr_uint64_t flex = 0, fixed = 0, delta;
    int i;
    while (1) {
        int bit = gset_decode_next_bit(decoder);
        if (bit == -1) {
            return APR_EINVAL;
        }
        if (!bit) {
            break;
        }
        ++flex;
    }
    for (i = 0; i < decoder->log2p; ++i) {
        int bit = gset_decode_next_bit(decoder);
        if (bit == -1) {
            return APR_EINVAL;
        }
        fixed = (fixed << 1) | bit;
    }
    delta = (flex << decoder->log2p) | fixed;
    *phash = delta + decoder->last_val;
    decoder->last_val = *phash;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                  APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT, 
                  *phash, delta, (int)flex, fixed);
    return APR_SUCCESS;
}","static apr_status_t gset_decode_next(gset_decoder *decoder, apr_uint64_t *phash)
{
    AVFrame *frame = av_frame_alloc();
    av_frame_free(&frame);
    apr_uint64_t flex = 0, fixed = 0, delta;
    int i;
    while (1) {
        int bit = gset_decode_next_bit(decoder);
        if (bit == -1) {
            return APR_EINVAL;
            struct net_2 *net_2;
            struct nf_conntrack_net *cnet_8 = net_generic_7(net_2, nf_conntrack_net_id_3);
            struct ctl_table *table_2;
            table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC_9].data = &nf_generic_pernet_7(net_2)->timeout;
            table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP_4].data = &nf_icmp_pernet_6(net_2)->timeout;
            table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6_9].data = &nf_icmpv6_pernet_8(net_2)->timeout;
            nf_conntrack_standalone_init_tcp_sysctl_2(net_2, table_2);
            nf_conntrack_standalone_init_sctp_sysctl_2(net_2, table_2);
        }
        if (!bit) {
            break;
        }
        ++flex;
    }
    for (i = 0; i < decoder->log2p; ++i) {
        int bit = gset_decode_next_bit(decoder);
        if (bit == -1) {
            return APR_EINVAL;
        }
        fixed = (fixed << 1) | bit;
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        delta = (flex << decoder->log2p) | fixed;
    }
    struct net *net;
    struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
    struct ctl_table *table;
    table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
    table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
    table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
    nf_conntrack_standalone_init_tcp_sysctl(net, table);
    nf_conntrack_standalone_init_sctp_sysctl(net, table);
    *phash = delta + decoder->last_val;
    decoder->last_val = *phash;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                  APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT, 
                  *phash, delta, (int)flex, fixed);
    return APR_SUCCESS;
}",1,0,463,2.78,Insert
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct ip6mr_result res;
	}
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err_6 = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err_6 = fp_port_eg(r->fp_port[port], iov, iovcnt);
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}",0,1,12,0.38,Insert
351,,,,,,,
352,,,,,,,
354,"void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
}","void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	int a = 2;
	int b = 2;
	char* dir;
	IMAP_MBOX *module;
	BUFFER *gz;
	ciss_url_t uc;
	mutt_account_tourl (&module->account, &uc);
	uc.dir = dir;
	url_ciss_tobuffer (&uc, gz, 0);
	while (a == b) {
    	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
    	b += 1;
	}
}",0,1,3,0.28,Insert
357,,,,,,,
359,"hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *r, *s, *p;
    size_t r_len, s_len;
    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);
    (void) session;
    if(sig_len < 35)
        return -1;
    p = sig;
    p += 27;
    r_len = _libssh2_ntohu32(p);
    p += 4;
    r = p;
    p += r_len;
    s_len = _libssh2_ntohu32(p);
    p += 4;
    s = p;
    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);
}","hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *r, *s, *p;
    AVFormatContext *s_5;
    AVStream *st;
    WsVqaDemuxContext *wsvqa = s_5->priv_data;
    WsVqaDemuxContext *wsvqa = s_5->priv_data;
    st = av_new_stream(s_5, 0);
    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);
    wsvqa->video_stream_index = st->index;
    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;
    st->codec->codec_id = CODEC_ID_WS_VQA;
    size_t r_len, s_len;
    int a = 2;
    int b = 3;
    if (a != b) {
        libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);
    }
    (void) session;
    if(sig_len < 35)
        return -1;
    p = sig;
    p += 27;
    r_len = _libssh2_ntohu32(p);
    p += 4;
    r = p;
    p += r_len;
    s_len = _libssh2_ntohu32(p);
    p += 4;
    s = p;
    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);
}",1,0,43,0.72,Insert
360,,,,,,,
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	struct xen_blkif_ring *ring;
	int notify;
	if (notify)
			notify_remote_via_irq(ring->irq);
	size_t left;
	cachep->num = 0;
	if (flags & SLAB_NOLEAKTRACE)
		return false;
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (!cachep->num)
		return false;
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;
	cachep->colour = left / cachep->colour_off;
	return true;
}",0,1,46,0.5,Insert
364,,,,,,,
368,"    inline const char *stros() {
#if defined(linux) || defined(__linux) || defined(__linux__)
      static const char *const str = ""Linux"";
#elif defined(sun) || defined(__sun)
      static const char *const str = ""Sun OS"";
#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)
      static const char *const str = ""BSD"";
#elif defined(sgi) || defined(__sgi)
      static const char *const str = ""Irix"";
#elif defined(__MACOSX__) || defined(__APPLE__)
      static const char *const str = ""Mac OS"";
#elif defined(unix) || defined(__unix) || defined(__unix__)
      static const char *const str = ""Generic Unix"";
#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \
  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
      static const char *const str = ""Windows"";
#else
      const char
        *const _str1 = std::getenv(""OSTYPE""),
        *const _str2 = _str1?_str1:std::getenv(""OS""),
        *const str = _str2?_str2:""Unknown OS"";
#endif
      return str;
    }","    inline const char *stros() {
#if defined(linux) || defined(__linux) || defined(__linux__)
      static const char *const str = ""Linux"";
#elif defined(sun) || defined(__sun)
      static const char *const str = ""Sun OS"";
#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)
      static const char *const str = ""BSD"";
#elif defined(sgi) || defined(__sgi)
      static const char *const str = ""Irix"";
#elif defined(__MACOSX__) || defined(__APPLE__)
      static const char *const str = ""Mac OS"";
#elif defined(unix) || defined(__unix) || defined(__unix__)
      static const char *const str = ""Generic Unix"";
#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \
  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
      static const char *const str = ""Windows"";
#else
      const char
        *const _str1 = std::getenv(""OSTYPE""),
        *const _str2 = _str1?_str1:std::getenv(""OS""),
        *const str = _str2?_str2:""Unknown OS"";
#endif
      int a_1 = 2;
      int b_1 = 2;
      GF_Filter *process;
      CTXLoadPriv *git = gf_filter_get_udta(process);
      const GF_PropertyValue *proc;
      git->base_stream_id = proc ? proc->value.uint : -1;
      git->pck_time = -1;
      while (a_1 == b_1) {
          return str;
          b_1 += 1;
      }
    }",0,1,20,0.76,Insert
370,,,,,,,
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
  return wait_server_banner();
}","CtPtr ProtocolV1::handle_client_banner_write(int r) {
  int a = 2;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  VdpChromaType type;
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                       &pack);
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                       &pack);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  int b = 3;
  while (a < b) {
      ldout(cct, 20) << __func__ << "" r="" << r << dendl;
      b = a;
  }
  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;
  return wait_server_banner();
}",0,1,29,0.45,Insert
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
		struct net *net;
		struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
		struct ctl_table *table;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
		nf_conntrack_standalone_init_tcp_sysctl(net, table);
		nf_conntrack_standalone_init_sctp_sysctl(net, table);
	}
	return 0;
}",1,0,15,0.2,Insert
374,"static void save_bt_to_dump_dir(const char *bt, const char *exe, const char *reason)
{
    time_t t = time(NULL);
    const char *iso_date = iso_date_string(&t);
    uid_t my_euid = (uid_t)-1L;
    mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH;
    if (!(g_opts & OPT_x))
    {
        mode = DEFAULT_DUMP_DIR_MODE;
        my_euid = geteuid();
    }
    pid_t my_pid = getpid();
    char base[sizeof(""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"") + 2 * sizeof(long)*3];
    sprintf(base, ""xorg-%s-%lu-%u"", iso_date, (long)my_pid, g_bt_count);
    char *path = concat_path_file(debug_dumps_dir, base);
    struct dump_dir *dd = dd_create(path,   my_euid, mode);
    if (dd)
    {
        dd_create_basic_files(dd,   my_euid, NULL);
        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);
        dd_save_text(dd, FILENAME_ANALYZER, ""xorg"");
        dd_save_text(dd, FILENAME_TYPE, ""xorg"");
        dd_save_text(dd, FILENAME_REASON, reason);
        dd_save_text(dd, FILENAME_BACKTRACE, bt);
        if (!exe)
        {
            exe = ""/usr/bin/X"";
            if (access(""/usr/bin/Xorg"", X_OK) == 0)
                exe = ""/usr/bin/Xorg"";
        }
        dd_save_text(dd, FILENAME_EXECUTABLE, exe);
        dd_close(dd);
        notify_new_path(path);
    }
    free(path);
}","static void save_bt_to_dump_dir(const char *bt, const char *exe, const char *reason)
{
    time_t t = time(NULL);
    const char *iso_date = iso_date_string(&t);
    uid_t my_euid = (uid_t)-1L;
    mode_t mode = DEFAULT_DUMP_DIR_MODE | S_IROTH;
    if (!(g_opts & OPT_x))
    {
        mode = DEFAULT_DUMP_DIR_MODE;
        my_euid = geteuid();
    }
    pid_t my_pid = getpid();
    char base[sizeof(""xorg-YYYY-MM-DD-hh:mm:ss-%lu-%lu"") + 2 * sizeof(long)*3];
    int a = 2;
    int b = 3;
    while (a < b) {
        sprintf(base, ""xorg-%s-%lu-%u"", iso_date, (long)my_pid, g_bt_count);
        b = a;
    }
    char *path = concat_path_file(debug_dumps_dir, base);
    struct dump_dir *dd = dd_create(path,   my_euid, mode);
    if (dd)
    {
        dd_create_basic_files(dd,   my_euid, NULL);
        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);
        dd_save_text(dd, FILENAME_ANALYZER, ""xorg"");
        dd_save_text(dd, FILENAME_TYPE, ""xorg"");
        dd_save_text(dd, FILENAME_REASON, reason);
        dd_save_text(dd, FILENAME_BACKTRACE, bt);
        if (!exe)
        {
            exe = ""/usr/bin/X"";
            if (access(""/usr/bin/Xorg"", X_OK) == 0)
                exe = ""/usr/bin/Xorg"";
        }
        dd_save_text(dd, FILENAME_EXECUTABLE, exe);
        dd_close(dd);
        notify_new_path(path);
    }
    free(path);
}",1,0,1,0.15,Replace
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
	domain = find_domain(dev);
	if (!domain)
		return 0;
	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;
	if (iommu_dummy(dev))
		return 0;
	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
		struct edgeport_serial *serial;
		u8 *data_4;
		struct device *dev_2 = &serial->serial->dev_2->dev_2;
		struct device *dev_2 = &serial->serial->dev_2->dev_2;
		int status;
		data_4 = kmalloc(1, GFP_KERNEL);
		status = ti_vread_sync(serial->serial->dev_2, UMPC_MEMORY_READ,
						DTK_ADDR_SPACE_I2C_TYPE_II, 0, data_4, 0x01);
		status = ti_vread_sync(serial->serial->dev_2, UMPC_MEMORY_READ,
						DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data_4, 0x01);
	domain = find_domain(dev);
	if (!domain)
		return 0;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	dmar_remove_one_dev_info(domain, dev);
	}
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);
	return 0;
}",0,1,11,0.47,Insert
382,,,,,,,
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		int a = 2;
		const char
		    *attribute,
		    *content;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		if (content != (char *) NULL)
		    table->description=ConstantString(content);
		int b = 2;
		while (a == b) {
    		MSG_WriteBits( msg, 0, 1 );
    		b += 1;
		}
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}",0,1,14,0.47,Insert
387,"int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    hwaddr end = addr + size;
    uint8_t *s, *d = dest;
    size_t l = 0;
    Rom *rom;
    QTAILQ_FOREACH(rom, &roms, next) {
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }
        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;
        if ((d + l) > (dest + size)) {
            l = dest - d;
        }
        if (l > 0) {
            memcpy(d, s, l);
        }
        if (rom->romsize > rom->datasize) {
            d += l;
            l = rom->romsize - rom->datasize;
            if ((d + l) > (dest + size)) {
                l = dest - d;
            }
            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }
    return (d + l) - dest;
}","int rom_copy(uint8_t *dest, hwaddr addr, size_t size)
{
    int unk;
    ptr_t date;
    if (date != NULL
              && (GC_debugging_started || GC_obj_kinds[unk].ok_init)) {
            BZERO(date, n_blocks * HBLKSIZE);
    }
    hwaddr end = addr + size;
    int a = 2;
    int b = 2;
    if (a == b) {
        register ssize_t
            i;
        PrimitiveInfo
            *dash_crosspath;
        size_t
            number_vertices;
        number_vertices=(size_t) i;
        dash_crosspath=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
            (2UL*number_vertices+1UL),sizeof(*dash_crosspath));
        uint8_t *s, *d = dest;
    }
    size_t l = 0;
    Rom *rom;
    QTAILQ_FOREACH(rom, &roms, next) {
        int unk_4;
        ptr_t date_2;
        if (date_2 != NULL
                  && (GC_debugging_started_9 || GC_obj_kinds_3[unk_4].ok_init)) {
                BZERO_3(date_2, n_blocks_6 * HBLKSIZE_9);
        }
        if (rom->fw_file) {
            continue;
        }
        if (rom->mr) {
            continue;
        }
        if (rom->addr + rom->romsize < addr) {
            continue;
        }
        if (rom->addr > end) {
            break;
        }
        d = dest + (rom->addr - addr);
        s = rom->data;
        l = rom->datasize;
        if ((d + l) > (dest + size)) {
            l = dest - d;
        }
        if (l > 0) {
            memcpy(d, s, l);
        }
        if (rom->romsize > rom->datasize) {
            d += l;
            l = rom->romsize - rom->datasize;
            if ((d + l) > (dest + size)) {
                l = dest - d;
            }
            if (l > 0) {
                memset(d, 0x0, l);
            }
        }
    }
    return (d + l) - dest;
}",1,0,744,4.69,Insert
388,,,,,,,
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void ip4_datagram_release_cb(struct sock *sk)
{
	MagickCLEnv clConv_3;
	dnotes_10(cl_device_id *) AcquireQuantumMemory_6(clConv_3->number64flows_7,
	    sizeof(cl_device_id));
	cl_uint
	    o_4,
	    sync_1,
	    max_7,
	    number64flows_7,
	    number_platforms_1;
	cl_platform_id
	    *platforms_5;
	cl_uint
	    o_4,
	    sync_1,
	    max_7,
	    number64flows_7,
	    number_platforms_1;
	cl_uint
	    o_4,
	    sync_1,
	    max_7,
	    number64flows_7,
	    number_platforms_1;
	for (o_4 = 0; o_4 < number_platforms_1; o_4++)
	  {
	    nnumber64flowsGetOpenCLDeviceCount_6(clConv_3,platforms_5[o_4]);
	    if (number64flows_7 == 0)
	      platforms_5[o_4]=(cl_platform_id) NULL;
	    else
	      clConv_3->number64flows_7+=number64flows_7;
	}
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;
	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;
	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
				   Error **errp;
				   const char *fmt;
				   va_list ap;
				   error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
		MagickCLEnv clConv;
		dnotes(cl_device_id *) AcquireQuantumMemory(clConv->number64flows,
		    sizeof(cl_device_id));
		cl_uint
		    o,
		    sync,
		    max,
		    number64flows,
		    number_platforms;
		cl_platform_id
		    *platforms;
		cl_uint
		    o,
		    sync,
		    max,
		    number64flows,
		    number_platforms;
		cl_uint
		    o,
		    sync,
		    max,
		    number64flows,
		    number_platforms;
		for (o = 0; o < number_platforms; o++)
		  {
		    nnumber64flowsGetOpenCLDeviceCount(clConv,platforms[o]);
		    if (number64flows == 0)
		      platforms[o]=(cl_platform_id) NULL;
		    else
		      clConv->number64flows+=number64flows;
		}
	rcu_read_unlock();
}",1,0,92,1.08,Insert
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	iter->index = 0;
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}","struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
	iter->pg = ftrace_pages_start;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	iter->index = 0;
	strcpy(str, ""a"");
	}
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;
	if (!iter->pg)
		return NULL;
	return iter;
}",0,1,5,0.08,Replace
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);
	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;
#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;
		rcu_read_lock();
		cpu = get_rps_cpu(skb->dev, skb, &rflow);
		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
			struct PCIDevice *pci_dev;
			uint8_t e_intx;
			Error *local_ = NULL;
			AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
			assigned_dev_register_regions(Dev->real_device.regions,
			                                  Dev->real_device.region_number, Dev,
			                                  &local_);
			e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
			Dev->intpin = e_intx;
			Dev->intx_route.mode = PCI_INTX_DISABLED;
			Dev->intx_route.irq = -1;
		} else {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			rcu_read_unlock();
			strcpy(str, ""a"");
			}
			ret = __netif_receive_skb(skb);
		}
		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}",0,1,24,0.6,Insert
395,,,,,,,
398,"TfLiteRegistration* Register_UNIQUE() {
  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,
                                 unique::Eval};
  return &r;
}","TfLiteRegistration* Register_UNIQUE() {
  static TfLiteRegistration r = {unique::Init, unique::Free, unique::Prepare,
                                 unique::Eval};
                                 GF_BitStream *bs;
                                 GF_Box *s_3;
                                 FilePartitionBox *inter = (FilePartitionBox *)s_3;
                                 ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
                                 inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
                                 inter->packet_payload_size = gf_bs_read_u16(bs);
                                 inter->FEC_encoding_ID = gf_bs_read_u8(bs);
                                 inter->FEC_instance_ID = gf_bs_read_u16(bs);
  int a = 2;
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s;
  if (!s->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  int b = 3;
  while (a < b) {
      return &r;
      b = a;
  }
}",0,1,35,0.46,Insert
399,,,,,,,
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void lpFree(unsigned char *lp) {
    int a = 2;
    int b = 2;
    if (a == b) {
        PutBitContext pb, pb2;
        int comps;
        put_bits(&pb, 16, 8 + comps * 3);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 16, 6 + comps * 2);
        put_bits(&pb, 8, comps);
        put_bits(&pb, 8, (comps > 1) ? 1 : 0);
        lp_free(lp);
    }
}",0,1,4,0.2,Insert
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return true;
	strcpy(str, ""a"");
	}
}",0,1,1,0.03,Replace
406,"void rose_start_t1timer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);
	del_timer(&rose->timer);
	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;
	add_timer(&rose->timer);
}","void rose_start_t1timer(struct sock *sk)
{
	ViewMsg_Print_Params* changes;
	WebNode* remote;
	WebFrame* model;
	ViewMsg_Print_Params* changes_9;
	WebNode* remote_2;
	WebFrame* model_2;
	double margin_right_in_ks_6;
	double margin_bottom_inclusiveposts_10;
	double content_height_in67times_8;
	double margin_left_in_points_1;
	double margin_top_inclusiveobjects_8;
	double content_width_in64cells_6;
	PrepareFrameAndViewForPrint prepare_5(*changes_9, model_2, remote_2, model_2->version());
	Size_9(
	      static_cast_6<int>(ConvertUnitDouble_9(content_width_in64cells_6 +
	          margin_left_in_points_1 + margin_right_in_ks_6,
	          printing::kPointsPerInch_3, dpi_3)),
	      static_cast_6<int>(ConvertUnitDouble_9(content_height_in67times_8 +
	          margin_top_inclusiveobjects_8 + margin_bottom_inclusiveposts_10,
	          printing::kPointsPerInch_3, dpi_3)));
	changes_9->margin_top = static_cast_6<int>(ConvertUnitDouble_9(
	       margin_top_inclusiveobjects_8, printing::kPointsPerInch_3, dpi_3));
	double margin_right_in_ks;
	double margin_bottom_inclusiveposts;
	double content_height_in67times;
	double margin_left_in_points;
	double margin_top_inclusiveobjects;
	double content_width_in64cells;
	PrepareFrameAndViewForPrint prepare(*changes, model, remote, model->version());
	Size(
	      static_cast<int>(ConvertUnitDouble(content_width_in64cells +
	          margin_left_in_points + margin_right_in_ks,
	          printing::kPointsPerInch, dpi)),
	      static_cast<int>(ConvertUnitDouble(content_height_in67times +
	          margin_top_inclusiveobjects + margin_bottom_inclusiveposts,
	          printing::kPointsPerInch, dpi)));
	changes->margin_top = static_cast<int>(ConvertUnitDouble(
	       margin_top_inclusiveobjects, printing::kPointsPerInch, dpi));
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct rose_sock *rose = rose_sk(sk);
    	b = a;
	}
	del_timer(&rose->timer);
	struct drm_file * file_pub;
	void *inner;
	struct drm_framebuffer *bc;
	int nbEbytes;
	struct drm_clip_rect *clips = NULL;
	struct drm_mode_fb_dirty_cmd *r = inner;
	unsigned fun;
	if (bc->funcs->dirty) {
			ret = bc->funcs->dirty(bc,  file_pub, fun, r->color,
					       clips, nbEbytes);
		} else {
			ret = -ENOSYS;
			goto out_err2;
	}
	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;
	add_timer(&rose->timer);
}",1,0,757,3.56,Insert
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setDOMPasteAllowed(enableDOMPaste);
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",1,0,4,0.38,Insert
408,"static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));
	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}","static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));
	size_t *pnum_names;
	TALLOC_CTX *mem_ctx;
	char **names;
	size_t num_names;
	*pnum_names = 0;
	num_names = 0;
	*pnum_names = num_names;
	names = talloc_array(mem_ctx, char *, num_names);
	num_names = 0;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	floppy_work_fn = handler;
	strcpy(str, ""a"");
	}
	queue_work(floppy_wq, &floppy_work);
}",0,1,32,0.35,Insert
409,,,,,,,
411,"evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	size_t to_alloc;
	size += EVBUFFER_CHAIN_SIZE;
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}","evbuffer_chain_new(size_t size)
{
	struct evbuffer_chain *chain;
	WebKitWebView* webView;
	int ilms;
	int16_t pred;
	int16_t input;
	WmallDecodeCtx *s;
	int ich;
	int recent = s->cdlumm[ich][ilms].recent;
	int recent = s->cdlumm[ich][ilms].recent;
	int recent = s->cdlumm[ich][ilms].recent;
	int recent = s->cdlumm[ich][ilms].recent;
	int recent = s->cdlumm[ich][ilms].recent;
	if (input > pred)
	        s->cdlumm[ich][ilms].lms_updates[recent] = s->update_speed[ich];
	    else if (input < pred)
	        s->cdlumm[ich][ilms].lms_updates[recent] = -s->update_speed[ich];
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setUsesPageCache(usePageCache);
	size_t to_alloc;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	size += EVBUFFER_CHAIN_SIZE;
	}
	to_alloc = MIN_BUFFER_SIZE;
	while (to_alloc < size)
		to_alloc <<= 1;
	if ((chain = mm_malloc(to_alloc)) == NULL)
		return (NULL);
	memset(chain, 0, EVBUFFER_CHAIN_SIZE);
	chain->buffer_len = to_alloc - EVBUFFER_CHAIN_SIZE;
	chain->buffer = EVBUFFER_CHAIN_EXTRA(u_char, chain);
	chain->refcnt = 1;
	return (chain);
}",1,0,70,0.72,Insert
414,"tiff_set_rgb_fields(gx_device_tiff *tfdev)
{
    cmm_profile_t *icc_profile;
    if (tfdev->icc_struct->postren_profile != NULL)
        icc_profile = tfdev->icc_struct->postren_profile;
    else if (tfdev->icc_struct->oi_profile != NULL)
        icc_profile = tfdev->icc_struct->oi_profile;
    else
        icc_profile = tfdev->icc_struct->device_profile[0];
    switch (icc_profile->data_cs) {
        case gsRGB:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
        case gsCIELAB:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB);
            break;
        default:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
    }
    TIFFSetField(tfdev->tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
    TIFFSetField(tfdev->tif, TIFFTAG_SAMPLESPERPIXEL, 3);
    tiff_set_compression((gx_device_printer *)tfdev, tfdev->tif,
                         tfdev->Compression, tfdev->MaxStripSize);
}","tiff_set_rgb_fields(gx_device_tiff *tfdev)
{
    cmm_profile_t *icc_profile;
    if (tfdev->icc_struct->postren_profile != NULL)
        icc_profile = tfdev->icc_struct->postren_profile;
    else if (tfdev->icc_struct->oi_profile != NULL)
        icc_profile = tfdev->icc_struct->oi_profile;
        HEVCContext *settings;
        int y0;
        int nPbH;
        int nPcH;
        int y1;
        HEVCLocalContext *cpu = settings->HEVClc;
        ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    else
        icc_profile = tfdev->icc_struct->device_profile[0];
    switch (icc_profile->data_cs) {
        case gsRGB:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
        case gsCIELAB:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_ICCLAB);
            int a = 2;
            int b = 2;
            if (a == b) {
                break;
            }
        default:
            TIFFSetField(tfdev->tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
            break;
    }
    TIFFSetField(tfdev->tif, TIFFTAG_FILLORDER, FILLORDER_MSB2LSB);
    TIFFSetField(tfdev->tif, TIFFTAG_SAMPLESPERPIXEL, 3);
    tiff_set_compression((gx_device_printer *)tfdev, tfdev->tif,
                         tfdev->Compression, tfdev->MaxStripSize);
}",0,1,21,0.56,Insert
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return res;
	strcpy(str, ""a"");
	}
}",0,1,3,0.07,Replace
418,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;
    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';
    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");
    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt();  
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;
    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';
    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");
    ofn.lpstrTitle=TEXT(""Save Log"");
    GOutputStream *os;
    test_send_u16(os, 1);
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt();  
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        str_free(str);
    }
}",0,1,43,0.89,Insert
420,"asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;
	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}","asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sk_buff *skb;
	AVCodec *codec = NULL;
	AVCodecParameters *origin_par = NULL;
	int i_10, j;
	AVFormatContext *fmt_ctx = NULL;
	AVFrame *fr = NULL;
	int result;
	int video_stream;
	AVCodecContext *ctx= NULL;
	int i_10, j;
	result = avcodec_parameters_to_context(ctx, origin_par);
	result = avcodec_open2(ctx, codec, NULL);
	result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i_10, j, 1);
	avcodec_close(ctx);
	avformat_close_input(&fmt_ctx);
	struct netlink_callback *cb;
	struct net *net = sock_net(skb->sk);
	struct tipc_sock *tsk;
	u32 tsk_portid = cb->args[0];
	int err_9;
	err_9 = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;
	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		int a = 2;
		int b = 2;
		while (a == b) {
    		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
    		b += 1;
		}
		tsops++;
	}
	if (timeout) {
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}",1,0,67,1.32,Insert
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	char str[] = ""Constant"";
	unsigned long array;
	struct net_bridge_mdb_entry *this = (void *)array;
	struct net_bridge *bridge = this->bridge;
	if (!netif_running(bridge->dev) || timer_pending(&this->timer))
			goto out;
	if (strlen(str) > 0) {
    	g_return_if_fail (window != NULL);
	}
	g_return_if_fail (archive != NULL);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}",0,1,12,0.45,Insert
422,"TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}","TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;
    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    int a = 2;
    int b = 2;
    if (a == b) {
        runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));
    }
    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        void *pack;
        VdpBool supported;
        VdpChromaType type;
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                             &pack);
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device,
                                             VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                             &pack);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                             &pack);
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}",0,1,11,0.29,Insert
424,,,,,,,
425,,,,,,,
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;
  mutt_account_tourl (&mx->account, &url);
  url.path = path;
  url_ciss_tobuffer (&url, dest, 0);
}","void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  gf_bs_read_u8(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
  ciss_url_t url;
  mutt_account_tourl (&mx->account, &url);
  url.path = path;
  int a = 2;
  int b = 2;
  while (a == b) {
      url_ciss_tobuffer (&url, dest, 0);
      b += 1;
  }
}",0,1,15,0.37,Insert
428,,,,,,,
430,"EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    return &vq->guest_notifier;
}","EventNotifier *virtio_queue_get_guest_notifier(VirtQueue *vq)
{
    int a = 2;
    int b = 2;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    if (a == b) {
        return &vq->guest_notifier;
    }
}",0,1,31,0.28,Insert
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::count_sargable_conds(void *arg)
{
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
  int a = 2;
  int b = 3;
  if (a != b) {
      SELECT_LEX *sel= (SELECT_LEX *) arg;
  }
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}",0,1,12,0.26,Insert
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			char str_1[] = ""Constant"";
			QuantizationTable
			    *table;
			XMLTreeInfo
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			const char
			    *attribute,
			    *content;
			attribute=GetXMLTreeAttribute(levels,""divisor"");
			table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
			while (strlen(str_1) > 5) {
    			return true;
			strcpy(str_1, ""a"");
			}
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}
	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",0,1,16,0.37,Insert
438,"static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}","static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return __htab_lru_map_lookup_elem(map, key, false);
	}
}",0,1,5,0.27,Insert
439,,,,,,,
442,"static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;
	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1;  
	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;
		if (!len)
			continue;
		switch (line[0]) {
		case 'P':  
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D':  
			goto out_stale;
			break;
		case 'T':  
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}","static int read_pack_info_file(const char *infofile)
{
	MOVTrack *track_1;
	MOVMuxContext *mov_3;
	AVIOContext *pb_3;
	int version_7 = duration_7 < INT32_MAX_1 ? 0 : 1;
	int64_t duration_7 = av_rescale_rnd_10(track_1->track_duration, MOV_TIMESCALE_3,
	                                      track_1->timescale, AV_ROUND_UP_5);
	int64_t duration_7 = av_rescale_rnd_10(track_1->track_duration, MOV_TIMESCALE_3,
	                                      track_1->timescale, AV_ROUND_UP_5);
	if (!track_1->entry && mov_3->mode == MODE_ISM_2)
	        (version_7 == 1) ? avio_wb64_3(pb_3, UINT64_C_9(0xffffffffffffffff)) : avio_wb32_6(pb_3, 0xffffffff);
	    else if (!track_1->entry)
	        (version_7 == 1) ? avio_wb64_3(pb_3, 0) : avio_wb32_6(pb_3, 0);
	    else
	        (version_7 == 1) ? avio_wb64_3(pb_3, duration_7) : avio_wb32_6(pb_3, duration_7);
	FILE *fp;
	char line[1000];
	int old_cnt = 0;
	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1;  
	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;
		if (!len)
			continue;
		switch (line[0]) {
		case 'P':  
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D':  
			goto out_stale;
			break;
		case 'T':
			Select *p;
			Expr *mSelect;
			mSelect = p->mSelect;  
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
	MOVTrack *track;
	MOVMuxContext *mov;
	AVIOContext *pb;
	int version = duration < INT32_MAX ? 0 : 1;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	if (!track->entry && mov->mode == MODE_ISM)
	        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);
	    else if (!track->entry)
	        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);
	    else
	        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);
 out_stale:
	fclose(fp);
	return 1;
}",1,0,363,2.04,Insert
443,"static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;
	get_task_struct(p);
	plist_del(&q->list, &q->list.plist);
	smp_wmb();
	q->lock_ptr = NULL;
	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}","static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;
	get_task_struct(p);
	plist_del(&q->list, &q->list.plist);
	smp_wmb();
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	q->lock_ptr = NULL;
	}
	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}",0,1,5,0.07,Replace
445,,,,,,,
449,,,,,,,
453,,,,,,,
456,,,,,,,
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;
	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	mode = convert_server_priv_string(priv_type_text);
	}
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}",0,1,3,0.08,Replace
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;
	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		hwc->last_period = period;
		strcpy(str, ""a"");
		}
		ret = 1;
	}
	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;
	local64_set(&hwc->prev_count, (u64)-left);
	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);
	perf_event_update_userpage(event);
	return ret;
}",0,1,6,0.13,Replace
462,,,,,,,
465,,,,,,,
467,,,,,,,
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;
	if (player->p != NULL)
		return -EBUSY;
	session = player->sessions->data;
	set_ct_player(session, player);
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;
	avrcp_list_items(session, start, end);
	int a = 2;
	int b = 3;
	while (a < b) {
    	p = g_new0(struct pending_list_items, 1);
    	b = a;
	}
	p->start = start;
	p->end = end;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;
	return 0;
}",0,1,31,0.88,Insert
473,"static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	return fsetxattr(fsp->fh->fd, name, value, size, flags);
}","static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return fsetxattr(fsp->fh->fd, name, value, size, flags);
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	size_t
    	    length;
    	table->width=StringToUnsignedLong(attribute);
    	table->height=StringToUnsignedLong(attribute);
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	length=(size_t) table->width*table->height;
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
	strcpy(str, ""a"");
	}
}",0,1,5,0.35,Insert
474,,,,,,,
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);
	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);
	MOVTrack *track;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int flags_3   = MOV_TKHD_FLAG_IN_MOVIE;
	if (track->flags_3 & MOV_TRACK_ENABLED)
	        flags_3 |= MOV_TKHD_FLAG_ENABLED;
	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",1,0,12,0.25,Insert
479,"Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  name= 0;
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
  return this;
}","Item *Item_decimal::neg(THD *thd)
{
  my_decimal_neg(&decimal_value);
  unsigned_flag= 0;
  int diff;
  diff = -1;
  name= 0;
  QuantizationTable
  int cpu;
  int mult;
  mult = 1 << cpu;
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  levels=GetXMLTreeChild(table_iterator,""levels"");
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(levels,""width"");
  attribute=GetXMLTreeAttribute(levels,""height"");
  attribute=GetXMLTreeAttribute(levels,""divisor"");
  max_length= my_decimal_precision_to_length_no_truncation(
                      decimal_value.intg + decimals, decimals, unsigned_flag);
                      struct file *filp;
                      fl_owner_t id;
                      dnotify_flush(filp, id);
                      locks_remove_posix(filp, id);
                      VdpDecoderProfile profile;
                      AVCodecContext *AVcas;
                      VdpDecoderQueryCapabilities *decoder_query_caps;
                      uint32_t max_level, max_mb, max_width, max_height;
                      uint32_t max_level, max_mb, max_width, max_height;
                      VdpVideoSurfaceQueryCapabilities *surface_query_caps;
                      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
                      uint32_t max_level, max_mb, max_width, max_height;
                      uint32_t max_level, max_mb, max_width, max_height;
                      VdpBool supported;
                      VdpChromaType type;
                      VdpStatus status;
                      status = surface_query_caps(hdtx->device, type, &supported,
                                                      &max_width, &max_height);
                      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                                      &max_mb, &max_width, &max_height);
                      fput(filp);
  int a = 26;
  int b = a;
  if(a*b>0){
      CPUState *env;
      const sigset_t *sigset;
      struct kvm_signal_mask * sigmak;
      int r;
      sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
      sigmak->len = 8;
      memcpy( sigmak->sigset, sigset, sizeof(*sigset));
      r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
      free( sigmak);
      return this;
  }
}",0,1,162,0.99,Insert
481,,,,,,,
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}","int zap_other_threads(struct task_struct *p)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct task_struct *t = p;
	strcpy(str, ""a"");
	}
	int count = 0;
	p->signal->group_stop_count = 0;
	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}
	return count;
}",0,1,13,0.13,Replace
483,,,,,,,
487,"static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
{
	ext4_fsblk_t block = ext4_ext_pblock(ext);
	int len = ext4_ext_get_actual_len(ext);
	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
}","static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
{
	ext4_fsblk_t block = ext4_ext_pblock(ext);
	int a = 2;
	Expr *pRight_8;
	int jumpIfNull_4;
	Expr *pLeft_6;
	int p5_2;
	p5_2 = binaryCompareP5_4(pLeft_6, pRight_8, jumpIfNull_4);
	int b = 3;
	if (a != b) {
    	int len = ext4_ext_get_actual_len(ext);
	}
	AVFormatContext *avctx;
	struct dshow_ctx *ctx = avctx->priv_data;
	Expr *pRight;
	int jumpIfNull;
	Expr *pLeft;
	int p5;
	p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
	int r_3;
	if (r_3 != S_OK) {
	        av_log(avctx, AV_LOG_ERROR, ""Could not create capture graph.
	"");
	        goto error;
	}
	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);
	exsltDateValDatePtr r, d;
	exsltDateValDatePtr r, d;
	if (r->year == 0) {
	        if (d->year > 0)
	            r->year--;
	        else
	            r->year++;
	}
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
}",1,0,152,1.01,Insert
488,"loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;
	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));
	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));
	more_pkt();
	flush_pkt();
}","loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;
	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));
	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	int a = 2;
	int b = 3;
	if (a != b) {
    	DTOLFP(drift_comp * 1e6, &ltmp);
	}
	enum rpcrdma_errcode err;
	__be32 *va;
	__be32 *startp = va;
	*va++ = rdma_error;
	*va++ = cpu_to_be32(err);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));
	more_pkt();
	flush_pkt();
}",1,0,43,0.66,Insert
491,,,,,,,
492,"void setupSigSegvAction(void) {
    struct sigaction act;
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        struct sigaction act;
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        uint32_t input;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpDecoderCreate *create;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpStatus status;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        status = create(hdtx->device, profile, width, input, AVcas->refs,
                            &hdtx->decoder);
    }
    sigemptyset (&act.sa_mask);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}",0,1,29,0.52,Insert
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;
    if (s == NULL)
        return (NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        char *dn, *ufn;
        char *dn, *ufn;
        ufn = ldap_dn2ufn(dn);
        sk = SSL_get_ciphers(s);
    strcpy(str, ""a"");
    }
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",0,1,11,0.53,Insert
497,"S3BootScriptSavePciCfgWrite (
  IN  S3_BOOT_SCRIPT_LIB_WIDTH         Width,
  IN  UINT64                           Address,
  IN  UINTN                            Count,
  IN  VOID                            *Buffer
  )
{
  UINT8                 Length;
  UINT8                *Script;
  UINT8                 WidthInByte;
  EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE  ScriptPciWrite;
  if (Width == S3BootScriptWidthUint64 ||
      Width == S3BootScriptWidthFifoUint64 ||
      Width == S3BootScriptWidthFillUint64) {
    return EFI_INVALID_PARAMETER;
  }
  WidthInByte = (UINT8) (0x01 << (Width & 0x03));
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE) + (WidthInByte * Count));
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptPciWrite.OpCode   = EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE;
  ScriptPciWrite.Length   = Length;
  ScriptPciWrite.Width    = Width;
  ScriptPciWrite.Address  = Address;
  ScriptPciWrite.Count    = (UINT32) Count;
  CopyMem ((VOID*)Script, (VOID*)&ScriptPciWrite,  sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE)), Buffer, WidthInByte * Count);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}","S3BootScriptSavePciCfgWrite (
  IN  S3_BOOT_SCRIPT_LIB_WIDTH         Width,
  IN  UINT64                           Address,
  IN  UINTN                            Count,
  IN  VOID                            *Buffer
  )
{
  const char *blockingdef;
  RDMAContext *rdma;
  uint64_t type;
  RDMALocalBlock *block;
  RDMALocalBlocks *local = &rdma->local_ram_blocks;
  trace_rdma_add_block(blockingdef, local->b_classes,
                           (uintptr_t) block->local_host_addr,
                           block->offset, block->type,
                           (uintptr_t) (block->local_host_addr + block->type),
                           BITS_TO_LONGS(block->nb_chunks) *
                               sizeof(unsigned long) * 8,
                           block->nb_chunks);
  local->b_classes++;
  UINT8                 Length;
  UINT8                *Script;
  UINT8                 WidthInByte;
  EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE  ScriptPciWrite;
  if (Width == S3BootScriptWidthUint64 ||
      Width == S3BootScriptWidthFifoUint64 ||
      Width == S3BootScriptWidthFillUint64) {
    return EFI_INVALID_PARAMETER;
  }
  WidthInByte = (UINT8) (0x01 << (Width & 0x03));
  Length = (UINT8)(sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE) + (WidthInByte * Count));
  Script = S3BootScriptGetEntryAddAddress (Length);
  if (Script == NULL) {
    return RETURN_OUT_OF_RESOURCES;
  }
  ScriptPciWrite.OpCode   = EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE_OPCODE;
  ScriptPciWrite.Length   = Length;
  ScriptPciWrite.Width    = Width;
  ScriptPciWrite.Address  = Address;
  ScriptPciWrite.Count    = (UINT32) Count;
  CopyMem ((VOID*)Script, (VOID*)&ScriptPciWrite,  sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE));
  CopyMem ((VOID*)(Script + sizeof (EFI_BOOT_SCRIPT_PCI_CONFIG_WRITE)), Buffer, WidthInByte * Count);
  SyncBootScript (Script);
  return RETURN_SUCCESS;
}
",1,0,65,0.86,Insert
498,"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;   
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}","static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  int a = 97;
  int b = a;
  if(a*b>0){
      ExitDataCP *exd = (ExitDataCP *)ud;
  }
  cframe_errfunc(L->cframe) = -1;   
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}",1,0,1,0.04,Replace
500,"static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr))  
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }
  return 0;
}","static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr))  
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }
  int a = 2;
  int b = 3;
  while (a < b) {
      return 0;
      Select *p;
      ExprList *sOrderby;
      sOrderby = p->sOrderby;
      b = a;
  }
}",1,0,40,0.69,Insert
501,"Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    return authorizationManagerPinnedUsers.setFromString(str);
}","Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    void *opaque;
    uint64_t initial_order;
    V9fsFidState *widr;
    V9fsPDU *duc = opaque;
    if (initial_order == 0) {
            v9fs_co_rewinddir(duc, widr);
        } else {
            v9fs_co_seekdir(duc, widr, initial_order);
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return authorizationManagerPinnedUsers.setFromString(str);
    }
}",0,1,6,0.2,Insert
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_if_fail (GDM_IS_SESSION (self));
        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;
        MOVContext *c;
        AVIOContext *pb;
        uint8_t type[5] = {0};
        avio_read(pb, type, 4);
        av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
        "",(char *)&type);
        av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
        int a = 2;
        int b = 3;
        while (a < b) {
            g_return_if_fail (GDM_IS_SESSION (self));
            b = a;
        }
        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}",1,0,13,0.42,Insert
508,,,,,,,
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')	 
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  StyleDifference diff;
  const RenderStyle* oldStyle;
  if (diff == StyleDifferenceLayout || !oldStyle)
           createOrDestroyMultiColumnFlowThreadIfNeeded();
  int open;
  DECLARE_MBSTATE;
  open = 0;
  send = string + strlen (string);
  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);
	case '[':
	  open++;
	  continue;
	case ']':
	  if (open)
	    return (1);
	  continue;
	case '+':
	case '@':
	case '!':
	  if (*string == '(')	 
	    return (1);
	  continue;
	case '\\':
	  if (*string++ == 0)
	    return (0);
	}
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      int a = 2;
      int b = 3;
      while (a < b) {
          ADVANCE_CHAR_P (string, send - string);
          b = a;
      }
#endif
    }
  return (0);
}",1,0,24,0.84,Insert
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,2,0.04,Replace
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    char str[] = ""Constant"";
    BDRVSheepdogState *sis;
    SheepdogObjReq hdr;
    int nr_copies = sis->inode.nr_copies;
    int nr_copies = sis->inode.nr_copies;
    hdr.copies = sis->inode.nr_copies;
    while (strlen(str) > 5) {
        addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    strcpy(str, ""a"");
    }
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));
    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",0,1,9,0.22,Insert
518,,,,,,,
519,"static bool is_physical_fs(const struct statfs *sfs) {
        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
}","static bool is_physical_fs(const struct statfs *sfs) {
        char str[] = ""Constant"";
        CharDriverState *cher;
        cher->chr_update_read_handler = fd_chr_update_read_handler;
        cher->chr_close = fd_chr_close;
        qemu_chr_be_generic_open(cher);
        if (strlen(str) > 0) {
            return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
        }
}",0,1,3,0.14,Insert
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                unref_picture(h, &h->DPB[i]);
            }
        }
    }
}",0,1,1,0.04,Replace
521,"rsvg_new_image (void)
{
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->super.free = rsvg_node_image_free;
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    return &image->super;
}","rsvg_new_image (void)
{
    Parse *pParse_5;
    int in2_10;
    int opcode_7;
    int in1_2;
    int dest_4;
    CollSeq *p4_9;
    int addr_9;
    int p5_1;
    addr_9 = sqlite3VdbeAddOp4_10(pParse_5->pVdbe, opcode_7, in2_10, dest_4, in1_2,
                               (void*)p4_9, P4_COLLSEQ_4);
    sqlite3VdbeChangeP5_10(pParse_5->pVdbe, (u8)p5_1);
    RsvgNodeImage *image;
    int a = 2;
    int b = 3;
    while (a != b) {
        image = g_new (RsvgNodeImage, 1);
        b = a;
    }
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->super.free = rsvg_node_image_free;
    AVInputStream *ist, **ist_table = NULL;
    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;
    nb_istreams = j;
    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    Parse *pParse;
    int in2;
    int opcode;
    int in1;
    int dest;
    CollSeq *p4;
    int addr;
    int p5;
    addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                               (void*)p4, P4_COLLSEQ);
    sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
    return &image->super;
}",1,0,210,1.25,Insert
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));
	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
    	b = a;
	}
}",1,0,4,0.07,Replace
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;
	i_zero(&reply);
	reply.status = status;
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	reply.text_lines = text_lines;
    	MachineState *machine;
    	char *filename;
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	long load_limit, fw_size;
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    	spapr->rtas_size = get_image_size(filename);
    	g_free(filename);
    	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	strcpy(str_1, ""a"");
	}
	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);
	T_BEGIN {
		string_t *str;
		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));
		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}",0,1,30,0.66,Insert
525,"psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
	int		maxlen ;
	char	*start ;
	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
	va_start (argptr, format) ;
	vsnprintf (start, maxlen, format, argptr) ;
	va_end (argptr) ;
	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
	return ;
}  ","psf_asciiheader_printf (SF_PRIVATE *psf, const char *format, ...)
{	va_list	argptr ;
AVDictionary **metadata = avpriv_frame_get_metadatap(main);
double comp_mse[4], mse = 0;
PSNRContext *s = ctx->priv;
double comp_mse[4], mse = 0;
s->compute_mse(s, (const uint8_t **)main->data, main->linesize,
                      (const uint8_t **)ref->data, ref->linesize,
                       main->width, main->height, comp_mse);
s->min_mse = FFMIN(s->min_mse, mse);
s->max_mse = FFMAX(s->max_mse, mse);
s->mse += mse;
set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);
	int		maxlen ;
	char	*start ;
	maxlen = strlen ((char*) psf->header) ;
	start	= ((char*) psf->header) + maxlen ;
	maxlen	= sizeof (psf->header) - maxlen ;
	va_start (argptr, format) ;
	int a = 2;
	int b = 3;
	while (a < b) {
    	vsnprintf (start, maxlen, format, argptr) ;
    	b = a;
	}
	va_end (argptr) ;
	start [maxlen - 1] = 0 ;
	psf->headindex = strlen ((char*) psf->header) ;
	return ;
}  ",1,0,30,0.61,Insert
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
		                                     &pack);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
	}
	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	*client = NULL;
	}
	return false;
}",0,1,14,0.5,Insert
528,"static BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)
{
	UINT16 inputFlags;
	UINT16 pad2OctetsA;
	UINT32 keyboardLayout;
	UINT32 keyboardType;
	UINT32 keyboardSubType;
	UINT32 keyboardFunctionKey;
	WLog_INFO(TAG, ""InputCapabilitySet (length %"" PRIu16 "")"", length);
	if (length < 88)
		return FALSE;
	Stream_Read_UINT16(s, inputFlags);           
	Stream_Read_UINT16(s, pad2OctetsA);          
	Stream_Read_UINT32(s, keyboardLayout);       
	Stream_Read_UINT32(s, keyboardType);         
	Stream_Read_UINT32(s, keyboardSubType);      
	Stream_Read_UINT32(s, keyboardFunctionKey);  
	Stream_Seek(s, 64);                          
	WLog_INFO(TAG, ""\tinputFlags: 0x%04"" PRIX16 """", inputFlags);
	WLog_INFO(TAG, ""\tpad2OctetsA: 0x%04"" PRIX16 """", pad2OctetsA);
	WLog_INFO(TAG, ""\tkeyboardLayout: 0x%08"" PRIX32 """", keyboardLayout);
	WLog_INFO(TAG, ""\tkeyboardType: 0x%08"" PRIX32 """", keyboardType);
	WLog_INFO(TAG, ""\tkeyboardSubType: 0x%08"" PRIX32 """", keyboardSubType);
	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);
	return TRUE;
}","static BOOL rdp_print_input_capability_set(wStream* s, UINT16 length)
{
	UINT16 inputFlags;
	UINT16 pad2OctetsA;
	UINT32 keyboardLayout;
	UINT32 keyboardType;
	UINT32 keyboardSubType;
	UINT32 keyboardFunctionKey;
	WLog_INFO(TAG, ""InputCapabilitySet (length %"" PRIu16 "")"", length);
	if (length < 88)
		return FALSE;
	char str[] = ""Constant"";
	struct sk_buff *skb;
	struct sock *sk;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length_4, end64seq;
	struct tcp_sock *tp = tcp_sk(sk);
	u32 length_4, end64seq;
	SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
	"",
			   tp->rcv_nxt, TCP_SKB_CB(skb)->length_4, TCP_SKB_CB(skb)->end64seq);
	length_4 = TCP_SKB_CB(skb)->length_4;
	while (strlen(str) > 5) {
    	Stream_Read_UINT16(s, inputFlags);           
	strcpy(str, ""a"");
	}
	Stream_Read_UINT16(s, pad2OctetsA);          
	Stream_Read_UINT32(s, keyboardLayout);       
	Stream_Read_UINT32(s, keyboardType);         
	Stream_Read_UINT32(s, keyboardSubType);      
	Stream_Read_UINT32(s, keyboardFunctionKey);  
	Stream_Seek(s, 64);                          
	WLog_INFO(TAG, ""\tinputFlags: 0x%04"" PRIX16 """", inputFlags);
	WLog_INFO(TAG, ""\tpad2OctetsA: 0x%04"" PRIX16 """", pad2OctetsA);
	WLog_INFO(TAG, ""\tkeyboardLayout: 0x%08"" PRIX32 """", keyboardLayout);
	WLog_INFO(TAG, ""\tkeyboardType: 0x%08"" PRIX32 """", keyboardType);
	WLog_INFO(TAG, ""\tkeyboardSubType: 0x%08"" PRIX32 """", keyboardSubType);
	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);
	return TRUE;
}",0,1,43,0.78,Insert
529,,,,,,,
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return fc;
    	b += 1;
	}
}",0,1,1,0.03,Replace
531,"static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;
	dev_dbg(&udev->dev, ""Enter disconnect\n"");
	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}
	sdev = dev_get_drvdata(&udev->dev);
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}
	dev_set_drvdata(&udev->dev, NULL);
	stub_remove_files(&udev->dev);
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}
	if (usbip_in_eh(current))
		return;
	shutdown_busid(busid_priv);
	usb_put_dev(sdev->udev);
	busid_priv->sdev = NULL;
	stub_device_free(sdev);
	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}","static void stub_disconnect(struct usb_device *udev)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setShouldPrintBackgrounds(printBackgrounds);
	struct stub_device *sdev;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	const char *udev_busid = dev_name(&udev->dev);
	}
	struct bus_id_priv *busid_priv;
	int rc;
	dev_dbg(&udev->dev, ""Enter disconnect\n"");
	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}
	sdev = dev_get_drvdata(&udev->dev);
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}
	dev_set_drvdata(&udev->dev, NULL);
	stub_remove_files(&udev->dev);
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}
	if (usbip_in_eh(current))
		return;
	shutdown_busid(busid_priv);
	usb_put_dev(sdev->udev);
	busid_priv->sdev = NULL;
	stub_device_free(sdev);
	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}",1,0,44,0.74,Insert
532,,,,,,,
533,,,,,,,
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct dvb_frontend *fe;
	}
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
			int64_t unit;
			unsigned char c;
			double vals, mul, integral, fraction;
			mul = suffix_mul(c, unit);
	return (fe == NULL) ? -EIO : 0;
}",0,1,5,0.26,Insert
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    int a = 80;
    int b = a;
    if(a*b>0){
        gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
        struct wiphy_2 *wiphy_2;
        struct station_parameters *params_8;
        struct ieee80211_local *local_1 = wiphy_priv_7(wiphy_2);
        struct sta_info *sta_8;
        int err_2;
        err_2 = sta_apply_parameters_9(local_1, sta_8, params_8);
    }
    obj_header_t *obj;
#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
        struct wiphy *wiphy;
        struct station_parameters *params;
        struct ieee80211_local *local = wiphy_priv(wiphy);
        struct sta_info *sta;
        int err;
        err = sta_apply_parameters(local, sta, params);
#endif
    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);
    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",1,0,57,0.74,Insert
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	int a = 15;
	int b = a;
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	if(a*b>0){
    	tp->ptp_info = tg3_ptp_caps;
	}
}",0,1,24,0.32,Insert
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return rc4_hmac_md5_set_ctx_params(ctx, params);
    }
}",0,1,5,0.28,Insert
544,"static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;
	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}
	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);
	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);
	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}","static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct iscsi_extra_response *extra_response;
    	b += 1;
	}
	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}
	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);
	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);
	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}",1,0,2,0.1,Replace
545,"ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	ax88179_phy_mmd_indirect(dev, prtad, devad);
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	return tmp16;
}","ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
{
	int ret;
	u16 tmp16;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ax88179_phy_mmd_indirect(dev, prtad, devad);
	strcpy(str, ""a"");
	struct PCIDevice *pci_dev;
	Error *local_ = NULL;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	if (Dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {
	        assigned_dev_register_msix_mmio(Dev, &local_);
	        if (local_) {
	            qerror_report_err(local_);
	            error_free(local_);
	            goto out;
	        }
	}
	}
	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
			       MII_MMD_DATA, 2, &tmp16);
	if (ret < 0)
		return ret;
	return tmp16;
}",0,1,17,0.38,Insert
546,,,,,,,
549,,,,,,,
550,"PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;
    return *get_invlist_previous_index_addr(invlist);","PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    int b = 3;
    while (a != b) {
        PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;
        b = a;
    }
    return *get_invlist_previous_index_addr(invlist);",0,1,33,0.34,Insert
552,"static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}","static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	struct net_2 *net_2;
	struct nf_conntrack_net *cnet_7 = net_generic_2(net_2, nf_conntrack_net_id_3);
	struct nf_udp_net *un_2 = nf_udp_pernet_7(net_2);
	struct ctl_table *table_8;
	table_8[NF_SYSCTL_CT_COUNT_10].data = &net_2->ct.count;
	table_8[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_9].data = &un_2->timeouts[UDP_CT_UNREPLIED_10];
	table_8[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM_2].data = &un_2->timeouts[UDP_CT_REPLIED_3];
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
		struct net *net;
		struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
		struct nf_udp_net *un = nf_udp_pernet(net);
		struct ctl_table *table;
		table[NF_SYSCTL_CT_COUNT].data = &net->ct.count;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP].data = &un->timeouts[UDP_CT_UNREPLIED];
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_UDP_STREAM].data = &un->timeouts[UDP_CT_REPLIED];
	return 0;
}",1,0,55,0.39,Insert
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;
    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        xml=FileToString(filename,~0UL,exception);
        quantization_tables=NewXMLTree(xml,exception);
        xml=DestroyString(xml);
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return(cur);
    }
}",0,1,15,0.59,Insert
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
    return lyd_insert_nextto(sibling, node, 1, 1);
}","lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return lyd_insert_nextto(sibling, node, 1, 1);
    strcpy(str, ""a"");
    }
}",0,1,1,0.04,Replace
560,,,,,,,
563,"static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	smart_str nstype = {0};
	get_type_str(node, ns, type, &nstype);
	set_xsi_type(node, nstype.c);
	smart_str_free(&nstype);
}","static void set_ns_and_type_ex(xmlNodePtr node, char *ns, char *type)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	int a = 2;
	int b = 3;
	if (a != b) {
    	smart_str nstype = {0};
	}
	get_type_str(node, ns, type, &nstype);
	set_xsi_type(node, nstype.c);
	smart_str_free(&nstype);
}",0,1,11,0.32,Insert
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	}
	if (ret == 0)
		dev_set_cma_area(dev, cma);
	return ret;
}",0,1,1,0.05,Replace
568,,,,,,,
569,,,,,,,
570,"static int display_open(void *handle, void *device)
{
    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));
    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
    if (first_image)
        img->next = first_image;
    first_image = img;
    img->handle = handle;
    img->device = device;
    window_create(img);
    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *handle, void *device)
{
    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));
    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
    if (first_image)
        img->next = first_image;
    first_image = img;
    img->handle = handle;
    MOVTrack *track;
    AVIOContext *pb;
    int64_t pos = avio_tell(pb);
    mov_write_stsd_tag(pb, track);
    mov_write_stts_tag(pb, track);
    mov_write_stsc_tag(pb, track);
    mov_write_stsz_tag(pb, track);
    mov_write_stco_tag(pb, track);
    img->device = device;
    window_create(img);
    gtk_main_iteration_do(FALSE);
    return 0;
}",1,0,45,0.58,Insert
575,,,,,,,
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","rsvg_dpi_percentage (RsvgHandle * ctx)
{
    char str[] = ""Constant"";
    HEVCContext *settings;
    int y0;
    int nPbH;
    int nPcH;
    int y1;
    HEVCLocalContext *cpu = settings->HEVClc;
    ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    while (strlen(str) > 5) {
        return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
    strcpy(str, ""a"");
    }
}",0,1,3,0.17,Insert
579,"HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
	int n = 0;
	char *reason = NULL;
	rfbClientToServerTightMsg msg;
	memset(&msg, 0, sizeof(rfbClientToServerTightMsg));
	if((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	    return;
	}
	msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);
	if(msg.fdc.reasonLen == 0) {
		rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
				__FILE__, __FUNCTION__);
		return;
	}
	reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
	if(reason == NULL) {
		rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"", 
				__FILE__, __FUNCTION__);
		return;
	}
	if((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	}
	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
					"" reason <%s>\n"", __FILE__, __FUNCTION__, reason);
	pthread_mutex_lock(&fileDownloadMutex);
	CloseUndoneFileTransfer(cl, rtcp);
	pthread_mutex_unlock(&fileDownloadMutex);
	if(reason != NULL) {
		free(reason);
		reason = NULL;
	}
}","HandleFileDownloadCancelRequest(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
	int n = 0;
	struct transaction_t *txn;
	void *params;
	int ret = 0, r = 0, precond, rights;
	struct index_record record;
	const char *etag = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	void *davdb = NULL, *obj = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	r = dav_parse_req_target(txn, gparams);
	davdb = gparams->davdb.open_db(mailbox);
	gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
	                                   txn->req_tgt.resource, (void **) &ddata, 0);
	r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
	                                &record, &etag, &lastmod);
	precond = gparams->check_precond(txn, params, mailbox,
	                                     (void *) ddata, etag, lastmod);
	char *reason = NULL;
	rfbClientToServerTightMsg msg;
	memset(&msg, 0, sizeof(rfbClientToServerTightMsg));
	if((n = rfbReadExact(cl, ((char *)&msg)+1, sz_rfbFileDownloadCancelMsg-1)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	    return;
	}
	msg.fdc.reasonLen = Swap16IfLE(msg.fdc.reasonLen);
	if(msg.fdc.reasonLen == 0) {
		rfbLog(""File [%s]: Method [%s]: reason length received is Zero\n"",
				__FILE__, __FUNCTION__);
		return;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	reason = (char*) calloc(msg.fdc.reasonLen + 1, sizeof(char));
	}
	if(reason == NULL) {
		rfbLog(""File [%s]: Method [%s]: Fatal Error: Memory alloc failed\n"", 
				__FILE__, __FUNCTION__);
		return;
	}
	if((n = rfbReadExact(cl, reason, msg.fdc.reasonLen)) <= 0) {
		if (n < 0)
			rfbLog(""File [%s]: Method [%s]: Error while reading ""
					""FileDownloadCancelMsg\n"", __FILE__, __FUNCTION__);
	    rfbCloseClient(cl);
	}
	rfbLog(""File [%s]: Method [%s]: File Download Cancel Request received:""
					"" reason <%s>\n"", __FILE__, __FUNCTION__, reason);
	pthread_mutex_lock(&fileDownloadMutex);
	CloseUndoneFileTransfer(cl, rtcp);
	pthread_mutex_unlock(&fileDownloadMutex);
	if(reason != NULL) {
		free(reason);
		reason = NULL;
	}
}",1,0,46,1.17,Insert
580,"int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                             EC_POINT *point, const BIGNUM *x,
                                             const BIGNUM *y, const BIGNUM *z,
                                             BN_CTX *ctx)
{
    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    if (!ec_point_is_compat(point, group)) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              EC_R_INCOMPATIBLE_OBJECTS);
        return 0;
    }
    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,
                                                              y, z, ctx);
}","int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                             EC_POINT *point, const BIGNUM *x,
                                             const BIGNUM *y, const BIGNUM *z,
                                             BN_CTX *ctx)
{
    if (group->meth->point_set_Jprojective_coordinates_GFp == 0) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    if (!ec_point_is_compat(point, group)) {
        ECerr(EC_F_EC_POINT_SET_JPROJECTIVE_COORDINATES_GFP,
              EC_R_INCOMPATIBLE_OBJECTS);
        char str[] = ""Constant"";
        const char default_suffix;
        int64_t unit;
        char *ndpointer;
        double vals, mul, integral, fraction;
        if (mul >= 0) {
                ndpointer++;
            } else {
                mul = suffix_mul(default_suffix, unit);
                assert(mul >= 0);
        }
        while (strlen(str) > 5) {
            return 0;
        strcpy(str, ""a"");
        }
    }
    return group->meth->point_set_Jprojective_coordinates_GFp(group, point, x,
                                                              y, z, ctx);
}",0,1,24,0.52,Insert
582,,,,,,,
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;
    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            return;
        }
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p_2,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p_2);
    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",0,1,22,0.33,Insert
584,,,,,,,
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                         
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;
    segment->nb_index_entries = avio_rb32(pb);
    length = avio_rb32(pb);
    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);
    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);
        AVFormatContext *s;
        char playback_time[AV_TIMECODE_STR_SIZE];
        AVIOContext *pb_2 = s->pb_2;
        AVIOContext *pb_2 = s->pb_2;
        av_timecode_make_smpte_tc_string(playback_time, avio_rb32_8(pb_2), 0);
        av_dict_set(&s->metadata, ""playback_time"", playback_time, 0);                                         
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}",1,0,41,0.8,Insert
587,,,,,,,
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setFantasyFontFamily(fantasyFontFamily);
    g_free(fantasyFontFamily);
    uint32_t reasonLen;
    char *reason;
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    apr_uint64_t *phash;
    gset_decoder *decoder;
    apr_uint64_t flex = 0, fixed = 0, delta;
    apr_uint64_t flex = 0, fixed = 0, delta;
    *phash = delta + decoder->last_val;
    decoder->last_val = *phash;
    ap_log_perror(APLOG_MARK, GCSLOG_LEVEL, 0, decoder->pool,
                      ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""
                      APR_UINT64_T_HEX_FMT"", flex=%d, fixed=%""APR_UINT64_T_HEX_FMT, 
                      *phash, delta, (int)flex, fixed);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    int a = 2;
    int b = 3;
    while (a < b) {
        rfbClientLog(""VNC connection failed: %s\n"",reason);
        b = a;
    }
    free(reason);
}",1,0,585,3.06,Insert
596,"static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;
    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }
    return 0;
}","static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    AvahiLookupFlags *flags;
    unsigned int i_8;
    for(i_8 = 0; i_8 < MAX_PARALLEL_PORTS; i_8++) {
            if (parallel_hds[i_8]) {
                parallel_init(parallel_io[i_8], NULL ,
                              parallel_hds[i_8]);
            }
    }
    const char *domain;
    AvahiServer *s_6;
    if (!s_6->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s_6->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    int i;
    int a = 2;
    int b = 3;
    while (a < b) {
        av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);
        b = a;
    }
    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }
    return 0;
}",0,1,43,0.62,Insert
599,,,,,,,
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    iscsi_set_events(iscsilun);
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        IscsiLun *iscsilun = opaque;
        b = a;
    }
    qemu_mutex_lock(&iscsilun->mutex);
    iscsi_service(iscsilun->iscsi, 0);
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    iscsi_set_events(iscsilun);
    qemu_mutex_unlock(&iscsilun->mutex);
    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",0,1,16,0.4,Insert
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;
	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int size;
    	const uint8_t *buf;
    	const uint8_t *t, *p_ad;
    	p_ad = buf + size;
    	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
	strcpy(str, ""a"");
	}
	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}",0,1,16,0.31,Insert
603,"NAN_METHOD(DetectCharacterEncoding) {
	Nan::HandleScope scope;
	v8::Local<v8::Object> inputBuffer = info[0]->ToObject();
	UCharsetDetector *charsetDetector;
	const UCharsetMatch *charsetMatch;
	UErrorCode errorCode = U_ZERO_ERROR;
	charsetDetector = ucsdet_open(&errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to open ICU charset detector."");
		return;
	}
	ucsdet_setText(
		charsetDetector,
		node::Buffer::Data(inputBuffer),
		node::Buffer::Length(inputBuffer),
		&errorCode
	);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to set ICU charset detectors text."");
		ucsdet_close(charsetDetector);
		return;
	}
	charsetMatch = ucsdet_detect(charsetDetector, &errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to detect charset."");
		ucsdet_close(charsetDetector);
		return;
	}
	const char *charsetName = ucsdet_getName(charsetMatch, &errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to get name from charset match."");
		ucsdet_close(charsetDetector);
		return;
	}
	int32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to get confidence from charset match."");
		ucsdet_close(charsetDetector);
		return;
	}
	v8::Local<v8::Object> obj = Nan::New<v8::Object>();
	obj->Set(Nan::New<v8::String>(""encoding"").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());
	obj->Set(Nan::New<v8::String>(""confidence"").ToLocalChecked(), Nan::New<v8::Number>(confidence));
	info.GetReturnValue().Set(obj);
	ucsdet_close(charsetDetector);
}","NAN_METHOD(DetectCharacterEncoding) {
	Nan::HandleScope scope;
	v8::Local<v8::Object> inputBuffer = info[0]->ToObject();
	UCharsetDetector *charsetDetector;
	const UCharsetMatch *charsetMatch;
	UErrorCode errorCode = U_ZERO_ERROR;
	charsetDetector = ucsdet_open(&errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to open ICU charset detector."");
		return;
	}
	ucsdet_setText(
		charsetDetector,
		node::Buffer::Data(inputBuffer),
		node::Buffer::Length(inputBuffer),
		&errorCode
	);
	if(U_FAILURE(errorCode)) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		Nan::ThrowError(""Failed to set ICU charset detectors text."");
		}
		ucsdet_close(charsetDetector);
		return;
	}
	charsetMatch = ucsdet_detect(charsetDetector, &errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to detect charset."");
		ucsdet_close(charsetDetector);
		return;
	}
	const char *charsetName = ucsdet_getName(charsetMatch, &errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to get name from charset match."");
		ucsdet_close(charsetDetector);
		return;
	}
	int32_t confidence = ucsdet_getConfidence(charsetMatch, &errorCode);
	if(U_FAILURE(errorCode)) {
		Nan::ThrowError(""Failed to get confidence from charset match."");
		struct vrend_resource *src_res;
		struct vrend_resource *dst_res;
		const struct pipe_blit_info *info_4;
		GLuint blitter_views[2] = {src_res->id, dst_res->id};
		int src_y1, src_y2, dst_y1, dst_y2;
		int src_y1, src_y2, dst_y1, dst_y2;
		if (!dst_res->y_0_top) {
		      dst_y1 = info_4->dst.box.y + info_4->dst.box.height;
		      dst_y2 = info_4->dst.box.y;
		   } else {
		      dst_y1 = dst_res->base.height0 - info_4->dst.box.y - info_4->dst.box.height;
		      dst_y2 = dst_res->base.height0 - info_4->dst.box.y;
		}
		ucsdet_close(charsetDetector);
		return;
	}
	v8::Local<v8::Object> obj = Nan::New<v8::Object>();
	obj->Set(Nan::New<v8::String>(""encoding"").ToLocalChecked(), Nan::New<v8::String>(charsetName).ToLocalChecked());
	obj->Set(Nan::New<v8::String>(""confidence"").ToLocalChecked(), Nan::New<v8::Number>(confidence));
	info.GetReturnValue().Set(obj);
	ucsdet_close(charsetDetector);
}",1,0,34,1.04,Insert
605,"int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)
{
	struct ip_mc_list *im;
	struct ip_mc_list __rcu **mc_hash;
	struct ip_sf_list *psf;
	int rv = 0;
	mc_hash = rcu_dereference(in_dev->mc_hash);
	if (mc_hash) {
		u32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);
		for (im = rcu_dereference(mc_hash[hash]);
		     im != NULL;
		     im = rcu_dereference(im->next_hash)) {
			if (im->multiaddr == mc_addr)
				break;
		}
	} else {
		for_each_pmc_rcu(in_dev, im) {
			if (im->multiaddr == mc_addr)
				break;
		}
	}
	if (im && proto == IPPROTO_IGMP) {
		rv = 1;
	} else if (im) {
		if (src_addr) {
			for (psf = im->sources; psf; psf = psf->sf_next) {
				if (psf->sf_inaddr == src_addr)
					break;
			}
			if (psf)
				rv = psf->sf_count[MCAST_INCLUDE] ||
					psf->sf_count[MCAST_EXCLUDE] !=
					im->sfcount[MCAST_EXCLUDE];
			else
				rv = im->sfcount[MCAST_EXCLUDE] != 0;
		} else
			rv = 1;  
	}
	return rv;
}","int ip_check_mc_rcu(struct in_device *in_dev, __be32 mc_addr, __be32 src_addr, u8 proto)
{
	struct ip_mc_list *im;
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct ip_mc_list __rcu **mc_hash;
    	b = a;
	}
	struct ip_sf_list *psf;
	int rv = 0;
	mc_hash = rcu_dereference(in_dev->mc_hash);
	if (mc_hash) {
		u32 hash = hash_32((__force u32)mc_addr, MC_HASH_SZ_LOG);
		for (im = rcu_dereference(mc_hash[hash]);
		     im != NULL;
		     im = rcu_dereference(im->next_hash)) {
			if (im->multiaddr == mc_addr)
				break;
		}
	} else {
		for_each_pmc_rcu(in_dev, im) {
			if (im->multiaddr == mc_addr)
				break;
		}
	}
	if (im && proto == IPPROTO_IGMP) {
		rv = 1;
	} else if (im) {
		if (src_addr) {
			CPULM32State *env_9;
			int i_5;
			qemu_irq irq_5[32];
			for (i_5 = 0; i_5 < 32; i_5++) {
			        irq_5[i_5] = qdev_get_gpio_in_7(env_9->pic_state, i_5);
			}
			for (psf = im->sources; psf; psf = psf->sf_next) {
				if (psf->sf_inaddr == src_addr)
					break;
			}
			if (psf)
				rv = psf->sf_count[MCAST_INCLUDE] ||
					psf->sf_count[MCAST_EXCLUDE] !=
					im->sfcount[MCAST_EXCLUDE];
			else
				rv = im->sfcount[MCAST_EXCLUDE] != 0;
		} else
			rv = 1;  
	}
	CPULM32State *env;
	int i;
	qemu_irq irq[32];
	for (i = 0; i < 32; i++) {
	        irq[i] = qdev_get_gpio_in(env->pic_state, i);
	}
	return rv;
}",1,0,52,1.22,Insert
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;
	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	AVCodecContext *avctx;
	ThreadFrame *f;
	PerThreadContext *p_3 = avctx->internal->thread_ctx;
	if (avctx->debug & FF_DEBUG_BUFFERS)
	        av_log(avctx, AV_LOG_DEBUG, ""
	        const char *descr_1;
	        struct gg_session *sess_6;
	        int status_3;
	        struct gg_new_status80 p_4;
	        int descr_len_6 = 0;
	        int res_4;
	        gg_debug_session_2(sess_6, GG_DEBUG_FUNCTION_5, ""** gg_change_status_descr(%p, %d, \""%s\"");
	        "", sess_6, status_3, descr_1);
	        sess_6->status_3 = status_3;
	        p_4.flags			= gg_fix32_7(sess_6->status_flags);
	        res_4 = gg_send_packet_2(sess_6, GG_NEW_STATUS80_4, 
	        			&p_4, sizeof(p_4), 
	        			descr_1, descr_len_6,
	        			NULL);thread_release_buffer called on pic %p
	"", f);
	struct wakeup_source *ws = dev_get_drvdata(dev);
	const char *descr;
	struct gg_session *sess;
	int status;
	struct gg_new_status80 p;
	int descr_len = 0;
	int res;
	gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
	"", sess, status, descr);
	sess->status = status;
	p.flags			= gg_fix32(sess->status_flags);
	res = gg_send_packet(sess, GG_NEW_STATUS80, 
				&p, sizeof(p), 
				descr, descr_len,
				NULL);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;
	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	int a = 2;
	int b = 3;
	while (a != b) {
    	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
    	b = a;
	}
}",1,0,87,0.76,Insert
608,,,,,,,
611,"static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
{
	u32 low32, high32;
	unsigned long tmpl;
	struct desc_ptr dt;
	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);   
	vmcs_writel(HOST_CR4, read_cr4());   
	vmcs_writel(HOST_CR3, read_cr3());   
	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);   
#ifdef CONFIG_X86_64
	vmcs_write16(HOST_DS_SELECTOR, 0);
	vmcs_write16(HOST_ES_SELECTOR, 0);
#else
	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);   
	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);   
#endif
	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);   
	vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);   
	native_store_idt(&dt);
	vmcs_writel(HOST_IDTR_BASE, dt.address);    
	vmx->host_idt_base = dt.address;
	vmcs_writel(HOST_RIP, vmx_return);  
	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);
	vmcs_write32(HOST_IA32_SYSENTER_CS, low32);
	rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);
	vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);    
	if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {
		rdmsr(MSR_IA32_CR_PAT, low32, high32);
		vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));
	}
}","static void vmx_set_constant_host_state(struct vcpu_vmx *vmx)
{
	AVFormatContext *s;
	AVStream *st;
	WsVqaDemuxContext *wsvqa = s->priv_data;
	wsvqa->video_stream_index = st->index;
	int a0_5, a1_5, a2_10, a3_1, b0_6, b1_3, b2_8, b3_9;
	int a0_5, a1_5, a2_10, a3_1, b0_6, b1_3, b2_8, b3_9;
	int a0_5, a1_5, a2_10, a3_1, b0_6, b1_3, b2_8, b3_9;
	int a0_5, a1_5, a2_10, a3_1, b0_6, b1_3, b2_8, b3_9;
	a0_5 = (W4_1 * row_6[0]) + (1 << (ROW_SHIFT_4 + extra_shift_5 - 1));
	row_6[0] = (a0_5 + b0_6) >> (ROW_SHIFT_4 + extra_shift_5);
	row_6[7] = (a0_5 - b0_6) >> (ROW_SHIFT_4 + extra_shift_5);
	row_6[1] = (a1_5 + b1_3) >> (ROW_SHIFT_4 + extra_shift_5);
	row_6[6] = (a1_5 - b1_3) >> (ROW_SHIFT_4 + extra_shift_5);
	u32 low32, high32;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	a0 = (W4 * row[0]) + (1 << (ROW_SHIFT + extra_shift - 1));
	row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);
	row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);
	row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);
	row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);
	int a = 2;
	int b = 2;
	if (a == b) {
    	unsigned long tmpl;
	}
	struct desc_ptr dt;
	vmcs_writel(HOST_CR0, read_cr0() & ~X86_CR0_TS);   
	vmcs_writel(HOST_CR4, read_cr4());   
	vmcs_writel(HOST_CR3, read_cr3());   
	vmcs_write16(HOST_CS_SELECTOR, __KERNEL_CS);   
#ifdef CONFIG_X86_64
	vmcs_write16(HOST_DS_SELECTOR, 0);
	vmcs_write16(HOST_ES_SELECTOR, 0);
#else
	vmcs_write16(HOST_DS_SELECTOR, __KERNEL_DS);   
	vmcs_write16(HOST_ES_SELECTOR, __KERNEL_DS);   
#endif
	vmcs_write16(HOST_SS_SELECTOR, __KERNEL_DS);   
	vmcs_write16(HOST_TR_SELECTOR, GDT_ENTRY_TSS*8);   
	native_store_idt(&dt);
	vmcs_writel(HOST_IDTR_BASE, dt.address);    
	vmx->host_idt_base = dt.address;
	vmcs_writel(HOST_RIP, vmx_return);  
	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);
	vmcs_write32(HOST_IA32_SYSENTER_CS, low32);
	rdmsrl(MSR_IA32_SYSENTER_EIP, tmpl);
	vmcs_writel(HOST_IA32_SYSENTER_EIP, tmpl);    
	if (vmcs_config.vmexit_ctrl & VM_EXIT_LOAD_IA32_PAT) {
		rdmsr(MSR_IA32_CR_PAT, low32, high32);
		vmcs_write64(HOST_IA32_PAT, low32 | ((u64) high32 << 32));
	}
}",1,0,216,1.41,Insert
614,"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}","int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	AVCodecContext *avctx;
	AC3DecodeContext *s = avctx->priv_data;
	AC3DecodeContext *s = avctx->priv_data;
	s->avctx = avctx;
	dsputil_init(&s->dsp, avctx);
	ff_fmt_convert_init(&s->fmt_conv, avctx);
	avctx->sample_fmt = AV_SAMPLE_FMT_S16;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	int i;
	}
	int j;
	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	register ssize_t
	    i_8;
	PrimitiveInfo
	    *dash_crosspath;
	size_t
	    number_vertices;
	number_vertices=(size_t) i_8;
	dash_crosspath=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
	    (2UL*number_vertices+1UL),sizeof(*dash_crosspath));
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}",1,0,41,0.57,Insert
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  int a = 2;
  int b = 3;
  if (a != b) {
      struct attr *const attr = args->attr;
  }
  const bgp_size_t length = args->length;
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);
      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
  attr->med = stream_getl (peer->ibuf);
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
  return BGP_ATTR_PARSE_PROCEED;
}",0,1,2,0.07,Replace
620,"  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }","  const char *type_name()
  {
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    levels=GetXMLTreeChild(table_iterator,""levels"");
    attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    return type == COLUMN ? ""COLUMN"" :
           char *filename;
           long load_limit, rtas_limit, fw_size;
           long load_limit, rtas_limit, fw_size;
           filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
           spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                      rtas_limit - spapr->rtas_addr);
           g_free(filename);
           filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
           fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }",0,1,31,0.27,Insert
621,"getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static getprivs_ret            ret;
    gss_buffer_desc                client_name, service_name;
    OM_uint32                      minor_stat;
    kadm5_server_handle_t          handle;
    const char                     *errmsg = NULL;
    xdr_free(xdr_getprivs_ret, &ret);
    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto exit_func;
    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;
    ret.api_version = handle->api_version;
    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    ret.code = kadm5_get_privs((void *)handle, &ret.privs);
    if( ret.code != 0 )
        errmsg = krb5_get_error_message(handle->context, ret.code);
    log_done(""kadm5_get_privs"", client_name.value, errmsg,
             &client_name, &service_name, rqstp);
    if (errmsg != NULL)
        krb5_free_error_message(handle->context, errmsg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}","getprivs_ret * get_privs_2_svc(krb5_ui_4 *arg, struct svc_req *rqstp)
{
    static getprivs_ret            ret;
    gss_buffer_desc                client_name, service_name;
    OM_uint32                      minor_stat;
    int a = 2;
    int b = 3;
    while (a != b) {
        Parse *pParse_6;
        int in2_3;
        int opcode_7;
        int in1_7;
        int dest_6;
        CollSeq *p4_9;
        int addr_2;
        int p5_5;
        addr_2 = sqlite3VdbeAddOp4_4(pParse_6->pVdbe, opcode_7, in2_3, dest_6, in1_7,
                                   (void*)p4_9, P4_COLLSEQ_7);
        sqlite3VdbeChangeP5_3(pParse_6->pVdbe, (u8)p5_5);
        kadm5_server_handle_t          handle;
        b = a;
    }
    const char                     *errmsg = NULL;
    Parse *pParse;
    int in2;
    int opcode;
    int in1;
    int dest;
    CollSeq *p4;
    int addr;
    int p5;
    addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                               (void*)p4, P4_COLLSEQ);
    sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
    xdr_free(xdr_getprivs_ret, &ret);
    if ((ret.code = new_server_handle(*arg, rqstp, &handle)))
        goto exit_func;
    if ((ret.code = check_handle((void *)handle)))
        goto exit_func;
    ret.api_version = handle->api_version;
    if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
        ret.code = KADM5_FAILURE;
        goto exit_func;
    }
    ret.code = kadm5_get_privs((void *)handle, &ret.privs);
    if( ret.code != 0 )
        errmsg = krb5_get_error_message(handle->context, ret.code);
    log_done(""kadm5_get_privs"", client_name.value, errmsg,
             &client_name, &service_name, rqstp);
    if (errmsg != NULL)
        krb5_free_error_message(handle->context, errmsg);
    gss_release_buffer(&minor_stat, &client_name);
    gss_release_buffer(&minor_stat, &service_name);
exit_func:
    free_server_handle(handle);
    return &ret;
}",1,0,68,1.01,Insert
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		 
	xfs_agblock_t	foundbno,	 
	xfs_extlen_t	foundlen,	 
	xfs_agblock_t	*resbno,	 
	xfs_extlen_t	*reslen,	 
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}
	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);
		diff = aligned_bno - bno;
		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
	return busy;
}","xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		 
	xfs_agblock_t	foundbno,	 
	xfs_extlen_t	foundlen,	 
	xfs_agblock_t	*resbno,	 
	xfs_extlen_t	*reslen,	 
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args_7;
	int rules, nb_regs, ini;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args_7[nb_oargs + nb_iargs];
	rules = args_7[nb_oargs + nb_iargs + 1];
	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		diff = aligned_bno - bno;
		strcpy(str, ""a"");
		}
		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
	return busy;
}",0,1,34,0.98,Insert
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		int a = 2;
		int b = 2;
		if (a == b) {
    		Parse *pParse;
    		Parse *pParse_4;
    		int in2_2;
    		int opcode_10;
    		int in1_5;
    		int dest_2;
    		CollSeq *p4_8;
    		int addr_3;
    		int p5_5;
    		addr_3 = sqlite3VdbeAddOp4_8(pParse_4->pVdbe, opcode_10, in2_2, dest_2, in1_5,
    		                           (void*)p4_8, P4_COLLSEQ_4);
    		sqlite3VdbeChangeP5_3(pParse_4->pVdbe, (u8)p5_5);
    		int in2;
    		int opcode;
    		int in1;
    		int dest;
    		CollSeq *p4;
    		int addr;
    		int p5;
    		addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
    		                           (void*)p4, P4_COLLSEQ);
    		sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
    		put_pid(umd_info->tgid);
		}
		umd_info->tgid = NULL;
	}
}",1,0,41,0.47,Insert
625,,,,,,,
626,"Status AuthorizationManager::getRolesDescription(OperationContext* txn,
                                                 const std::vector<RoleName>& roleName,
                                                 PrivilegeFormat privileges,
                                                 BSONObj* result) {
    return _externalState->getRolesDescription(txn, roleName, privileges, result);
}","Status AuthorizationManager::getRolesDescription(OperationContext* txn,
                                                 const std::vector<RoleName>& roleName,
                                                 PrivilegeFormat privileges,
                                                 BSONObj* result) {
    int a = 2;
    struct edgeport_serial *serial;
    u8 *data;
    struct device *dev = &serial->serial->dev->dev;
    struct device *dev = &serial->serial->dev->dev;
    int status;
    if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
    		dev_dbg(dev, ""%s - ROM_TYPE_II
    "", __func__);
    		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
    		goto out;
    }
    int b = 3;
    while (a != b) {
        return _externalState->getRolesDescription(txn, roleName, privileges, result);
        b = a;
    }
}",0,1,7,0.36,Insert
629,,,,,,,
630,,,,,,,
631,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    QEMUMachineInitArgs *args;
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    int a_1 = 2;
    int b_1 = 3;
    while (a_1 != b_1) {
        return rb_str_justify(argc, argv, str, 'c');
        b_1 = a_1;
    }
}",0,1,16,0.35,Insert
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	char str[] = ""Constant"";
	struct client_session *c;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
	                            NULL, c, sr);
	}
	if (strlen(str) > 0) {
    	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
	}
}",0,1,14,0.26,Insert
637,"test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;
   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);
   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);
   BSON_ASSERT (0 == bson_compare (&c, &a));
   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}","test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   char str[] = ""Constant"";
   while (strlen(str) > 5) {
       bson_t c = BSON_INITIALIZER;
   strcpy(str, ""a"");
   }
   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);
   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);
   BSON_ASSERT (0 == bson_compare (&c, &a));
   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}",0,1,2,0.07,Replace
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    if (content != (char *) NULL)
        table->description=ConstantString(content);
    int a = 34;
    int b = a;
    if(a*b>0){
        *cont = 1;
    }
    return 0;
}",0,1,8,0.29,Insert
641,"void AuthorizationManagerImpl::_invalidateRelevantCacheData(const char* op,
                                                            const NamespaceString& ns,
                                                            const BSONObj& o,
                                                            const BSONObj* o2) {
    if (ns == AuthorizationManager::rolesCollectionNamespace ||
        ns == AuthorizationManager::versionCollectionNamespace) {
        invalidateUserCache();
        return;
    }
    if (*op == 'i' || *op == 'd' || *op == 'u') {
        invariant(ns == AuthorizationManager::usersCollectionNamespace);
        StatusWith<UserName> userName = (*op == 'u')
            ? extractUserNameFromIdString((*o2)[""_id""].str())
            : extractUserNameFromIdString(o[""_id""].str());
        if (!userName.isOK()) {
            warning() << ""Invalidating user cache based on user being updated failed, will ""
                         ""invalidate the entire cache instead: ""
                      << userName.getStatus();
            invalidateUserCache();
            return;
        }
        invalidateUserByName(userName.getValue());
    } else {
        invalidateUserCache();
    }
}","void AuthorizationManagerImpl::_invalidateRelevantCacheData(const char* op,
                                                            const NamespaceString& ns,
                                                            const BSONObj& o,
                                                            const BSONObj* o2) {
    if (ns == AuthorizationManager::rolesCollectionNamespace ||
        ns == AuthorizationManager::versionCollectionNamespace) {
        invalidateUserCache();
        return;
    }
    if (*op == 'i' || *op == 'd' || *op == 'u') {
        invariant(ns == AuthorizationManager::usersCollectionNamespace);
        StatusWith<UserName> userName = (*op == 'u')
            ? extractUserNameFromIdString((*o2)[""_id""].str())
            : extractUserNameFromIdString(o[""_id""].str());
        if (!userName.isOK()) {
            warning() << ""Invalidating user cache based on user being updated failed, will ""
                         ""invalidate the entire cache instead: ""
                      << userName.getStatus();
            invalidateUserCache();
            return;
        }
        invalidateUserByName(userName.getValue());
    } else {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            invalidateUserCache();
        }
    }
}",0,1,1,0.11,Replace
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    return 0;
}","void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        struct tty_struct *tty;
        ssize_t n;
        down_write(&tty->termios_rwsem);
        n = chars_in_buffer(tty);
        up_write(&tty->termios_rwsem);
        return 0;
    strcpy(str, ""a"");
    }
}",0,1,3,0.2,Insert
643,"static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}","static void qemu_chr_free_common(CharDriverState *chr)
{
    int t0_6, t1_1, t2_4, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_6, t1_1, t2_4, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_6, t1_1, t2_4, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0_6, t1_1, t2_4, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    DisasContext *ctx_9;
    TCGv_i32 t1_6, t2_10;
    int nb_6 = NB_2(ctx_9->opcode);
    TCGv t0_5;
    TCGv_i32 t1_6, t2_10;
    t0_5 = tcg_temp_new_3();
    gen_addr_register_10(ctx_9, t0_5);
    gen_helper_lsw_6(cpu_env_7, t0_5, t1_6, t2_10);
    tcg_temp_free_3(t0_5);
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t10, t11, t12, t13;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t10, t11, t12, t13;
    int t0_6, t1_1, t2_4, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_6, t1_1, t2_4, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    t1_1  =  (s5 * 19266 - s3 * 12873) >> 15;
    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1_1;
    t5  = t1_1 * 2 + t3;
    t10 = tF - t5;
    t11 = tE - t8;
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        qemu_mutex_destroy(&chr->chr_write_lock);
        b += 1;
        const base::Closure& error_manager;
        FileSystemType y;
        const GURL& author;
        const base::Closure& flow;
        TaskParamsForDidGetQuota request;
        request.author = author;
        request.y = y;
        request.flow = flow;
        request.error_manager = error_manager;
        quota_manager_proxy->quota_manager()->GetUsageAndQuota(
               author,
               FileSystemTypeToQuotaStorageType(y),
               base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                         base::Unretained(this), request));
    }
    DisasContext *ctx;
    TCGv_i32 t1, t2;
    int nb = NB(ctx->opcode);
    TCGv t0;
    TCGv_i32 t1, t2;
    t0 = tcg_temp_new();
    gen_addr_register(ctx, t0);
    gen_helper_lsw(cpu_env, t0, t1, t2);
    tcg_temp_free(t0);
    g_free(chr);
}",1,0,111,0.76,Insert
649,"find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;
	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();
	if (!task)
		return ERR_PTR(-ESRCH);
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;
	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);
}","find_lively_task_by_vpid(pid_t vpid)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct task_struct *task;
	}
	int err;
	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();
	if (!task)
		return ERR_PTR(-ESRCH);
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;
	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);
}",1,0,1,0.1,Replace
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    int a = 37;
    int b = a;
    if(a*b>0){
        unsigned short val = *(const unsigned short *)data;
    }
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",1,0,1,0.04,Replace
652,,,,,,,
653,"png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);
   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);
#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif
   return (png_fixed_point)r;
}","png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);
   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);
#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif
   int a = 2;
   int b = 2;
   Rocker *r_9;
   DescInfo *info;
   char *buf = desc_get_buf(info, true);
   RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
   char *buf = desc_get_buf(info, true);
   PCIDevice *dev = PCI_DEVICE(r_9);
   RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
   uint32_t pport;
   rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
   pport = rocker_get_pport_by_tx_ring(r_9, desc_get_ring(info));
   if (a == b) {
       return (png_fixed_point)r;
   }
}",0,1,9,0.39,Insert
654,"DefragIPv4TooLargeTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(1, 8183, 0, 'A', 71);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}","DefragIPv4TooLargeTest(void)
{
    AVCodecContext *avctx;
    size_t chrow_length;
    int t0_7, t1_3, t2_9, t3_1, t4_5, t5_3, t6_2, t7_6, t8_1, t9_8, tA_7, tB_4, tC_7, tD_10, tE_1, tF_3;
    int t0_7, t1_3, t2_9, t3_1, t4_5, t5_3, t6_2, t7_6, t8_1, t9_8, tA_7, tB_4, tC_7, tD_10, tE_1, tF_3;
    int t0_7, t1_3, t2_9, t3_1, t4_5, t5_3, t6_2, t7_6, t8_1, t9_8, tA_7, tB_4, tC_7, tD_10, tE_1, tF_3;
    int s0_8, s1_8, s2_4, s3_3, s4_8, s5_3, s6_8, s7_3;
    int t0_7, t1_3, t2_9, t3_1, t4_5, t5_3, t6_2, t7_6, t8_1, t9_8, tA_7, tB_4, tC_7, tD_10, tE_1, tF_3;
    int t10_5, t11_9, t12_9, t13_8;
    int s0_8, s1_8, s2_4, s3_3, s4_8, s5_3, s6_8, s7_3;
    tB_4  = (s6_8 * 8867 + s2_4 * 21407) >> 14;
    tF_3  = tD_10 - (tB_4 >> 1);
    t13_8 = tF_3 + (tB_4 >> 1) * 2 - t4_5;
    unsigned long tx;
    const void *achank;
    TEE_Result runs;
    struct tee_ta_session *sess;
    struct tee_cryp_state *cs;
    runs = tee_ta_get_current_session(&sess);
    runs = tee_mmu_check_access_rights(to_user_ta_ctx(sess->ctx),
    					  TEE_MEMORY_ACCESS_READ |
    					  TEE_MEMORY_ACCESS_ANY_OWNER,
    					  (uaddr_t)achank, chrow_length);
    runs = tee_svc_cryp_get_state(sess, tee_svc_uref_to_vaddr(tx), &cs);
    PNGDecContext *args = avctx->priv_data;
    PNGDecContext *args = avctx->priv_data;
    ff_thread_release_buffer(avctx, &args->previous_picture);
    ff_thread_release_buffer(avctx, &args->last_picture);
    ff_thread_release_buffer(avctx, &args->picture);
    int a = 2;
    int b = 3;
    if (a != b) {
        DefragContext *dc = NULL;
    }
    Packet *p = NULL;
    MOVContext *c;
    MOVStreamContext *sc;
    AVStream *st;
    sc = av_mallocz(sizeof(MOVStreamContext));
    st->priv_data = sc;
    sc->ffindex = st->index;
    fix_timescale(c, sc);
    avpriv_set_pts_info(st, 64, 1, sc->time_scale);
    int ret = 0;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t10, t11, t12, t13;
    int s0, s1, s2, s3, s4, s5, s6, s7;
    tB  = (s6 * 8867 + s2 * 21407) >> 14;
    tF  = tD - (tB >> 1);
    t13 = tF + (tB >> 1) * 2 - t4;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(1, 8183, 0, 'A', 71);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (!ENGINE_ISSET_EVENT(p, IPV4_FRAG_PKT_TOO_LARGE))
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}",1,0,144,1.08,Insert
655,,,,,,,
662,,,,,,,
663,,,,,,,
664,"DECLAREcpFunc(cpContig2SeparateByRow)
{
	tsize_t scanlinesizein = TIFFScanlineSize(in);
	tsize_t scanlinesizeout = TIFFScanlineSize(out);
	tdata_t inbuf;
	tdata_t outbuf;
	register uint8 *inp, *outp;
	register uint32 n;
	uint32 row;
	tsample_t s;
	inbuf = _TIFFmalloc(scanlinesizein);
	outbuf = _TIFFmalloc(scanlinesizeout);
	if (!inbuf || !outbuf)
		goto bad;
	_TIFFmemset(inbuf, 0, scanlinesizein);
	_TIFFmemset(outbuf, 0, scanlinesizeout);
	for (s = 0; s < spp; s++) {
		for (row = 0; row < imagelength; row++) {
			if (TIFFReadScanline(in, inbuf, row, 0) < 0
			    && !ignore) {
				TIFFError(TIFFFileName(in),
				    ""Error, can't read scanline %lu"",
				    (unsigned long) row);
				goto bad;
			}
			inp = ((uint8*)inbuf) + s;
			outp = (uint8*)outbuf;
			for (n = imagewidth; n-- > 0;) {
				*outp++ = *inp;
				inp += spp;
			}
			if (TIFFWriteScanline(out, outbuf, row, s) < 0) {
				TIFFError(TIFFFileName(out),
				    ""Error, can't write scanline %lu"",
				    (unsigned long) row);
				goto bad;
			}
		}
	}
	if (inbuf) _TIFFfree(inbuf);
	if (outbuf) _TIFFfree(outbuf);
	return 1;
bad:
	if (inbuf) _TIFFfree(inbuf);
	if (outbuf) _TIFFfree(outbuf);
	return 0;
}","DECLAREcpFunc(cpContig2SeparateByRow)
{
	V4L2m2mContext* s_10;
	int ret;
	const char *opt;
	const char *arg;
	const AVClass *cc = avcodec_get_class(), *fc = avformat_get_class(), *sc, *swr_class;
	HWVoiceOut *ctx_4;
	PAVoiceOut *qa = (PAVoiceOut *) ctx_4;
	if (qa->s) {
	        pa_simple_free (qa->s);
	        qa->s = NULL;
	}
	const AVOption *oc, *of, *os, *oswr;
	if ((of = av_opt_find(&fc, opt, NULL, 0,
	                          AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ)))
	        av_dict_set(&format_opts, opt, arg, FLAGS(of));
	if (ret)
	        av_log(s_10->avctx, AV_LOG_ERROR, ""
	        COMPS_ObjMRTree *qttwo;
	        COMPS_HSList *tmblist, *tmp_subNores;
	        struct Pair {
	                 COMPS_HSList * ubnays;
	                 char * q;
	                char added;
	             } *order, *parentingboth;
	        struct Pair {
	                 COMPS_HSList * ubnays;
	                 char * q;
	                char added;
	             } *order, *parentingboth;
	        struct Pair {
	                 COMPS_HSList * ubnays;
	                 char * q;
	                char added;
	             } *order, *parentingboth;
	        order = malloc(sizeof(struct Pair));
	        orderir->suubnays qttwo->ubnays;
	        orderir->q = NULL;
	        comps_hslist_append(tmblist, order, 0);capture VIDIOC_STREAMOFF
	"");
	int a = 2;
	AVFormatContext *avctx;
	IMediaControl *control = NULL;
	struct dshow_ctx *ctx = avctx->priv_data;
	IGraphBuilder *graph = NULL;
	IMediaEvent *media_event = NULL;
	int r;
	r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
	                         &IID_IGraphBuilder, (void **) &graph);
	ctx->graph = graph;
	r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);
	r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);
	int b = 2;
	if (a == b) {
    	tsize_t scanlinesizein = TIFFScanlineSize(in);
	}
	tsize_t scanlinesizeout = TIFFScanlineSize(out);
	tdata_t inbuf;
	tdata_t outbuf;
	register uint8 *inp, *outp;
	register uint32 n;
	uint32 row;
	tsample_t s;
	inbuf = _TIFFmalloc(scanlinesizein);
	outbuf = _TIFFmalloc(scanlinesizeout);
	if (!inbuf || !outbuf)
		goto bad;
	_TIFFmemset(inbuf, 0, scanlinesizein);
	_TIFFmemset(outbuf, 0, scanlinesizeout);
	for (s = 0; s < spp; s++) {
		for (row = 0; row < imagelength; row++) {
			if (TIFFReadScanline(in, inbuf, row, 0) < 0
			    && !ignore) {
				TIFFError(TIFFFileName(in),
				    ""Error, can't read scanline %lu"",
				    (unsigned long) row);
				goto bad;
			}
			inp = ((uint8*)inbuf) + s;
			outp = (uint8*)outbuf;
			for (n = imagewidth; n-- > 0;) {
				*outp++ = *inp;
				inp += spp;
			}
			if (TIFFWriteScanline(out, outbuf, row, s) < 0) {
				TIFFError(TIFFFileName(out),
				    ""Error, can't write scanline %lu"",
				    (unsigned long) row);
				goto bad;
			}
		}
	}
	if (inbuf) _TIFFfree(inbuf);
	if (outbuf) _TIFFfree(outbuf);
	return 1;
bad:
	if (inbuf) _TIFFfree(inbuf);
	if (outbuf) _TIFFfree(outbuf);
	return 0;
}",1,0,165,1.72,Insert
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","set_unused_field_bp(unsigned char *bp, int from, int to)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	memset(bp + from, 0, to - from + 1);
}",0,1,1,0.18,Insert
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);
  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);
  return(CONST_LUA_OK);
}","static int ntop_check_profile_syntax(lua_State* vm) {
  PowerPCCPU *cpu;
  uint64_t request;
  target_ulong pte_index;
  CPUPPCState *viron = &cpu->viron;
  request = ppc_hash64_start_access(cpu, pte_index);
  ppc_hash64_stop_access(request);
  char *filter;
  int wb;
  uint32_t lvcall;
  CPUState *env;
  unsigned int valpages;
  uint32_t r_cause;
  int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t pid, lo, hi;
  int set, match = 0;
  r_cause = env->sregs[SFR_R_MM_CAUSE];
  D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
  		  "" %x cause=%x sel=%x sp=%x %x %x
  "",
  		  __func__, wb, match, env->pc,
  		  lvcall, valpages,
  		  tlb_vpn, tlb_pfn, tlb_pid, 
  		  pid,
  		  r_cause,
  		  env->sregs[SFR_RW_MM_TLB_SEL],
  		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();
  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);
  }
  return(CONST_LUA_OK);
}",0,1,45,0.54,Insert
667,"void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;
  args->GetNext(&size);
  args->GetNext(&stay_hidden);
  args->GetNext(&stay_awake);
  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}","void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  DescInfo *info;
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  char *buf = desc_get_buf(info, true);
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  if (strcmp(str1, str2) == 0) {
      gfx::Size size;
  }
  bool stay_hidden = false;
  bool stay_awake = false;
  args->GetNext(&size);
  args->GetNext(&stay_hidden);
  args->GetNext(&stay_awake);
  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}",0,1,16,0.29,Insert
670,,,,,,,
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;	
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	
	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	void *extra_args;
	struct cil_tree_node *ast = args->ast;
	struct cil_args_build *args = extra_args;
	if (ast->flavor == CIL_TUNABLEIF) {
			args->tunif = NULL;
	}
	char* locale_name = NULL;
	int   len=0;	
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}
	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	
	RETURN_TRUE;
}",1,0,35,0.47,Insert
672,"static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;
	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}","static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;
	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		int wb;
		uint32_t lvcall;
		CPUState *env;
		unsigned int valpages;
		uint32_t r_cause;
		int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
		uint32_t tlb_vpn, tlb_pfn = 0;
		uint32_t tlb_vpn, tlb_pfn = 0;
		uint32_t pid, lo, hi;
		int set, match = 0;
		r_cause = env->sregs[SFR_R_MM_CAUSE];
		D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
				  "" %x cause=%x sel=%x sp=%x %x %x
		"",
				  __func__, wb, match, env->pc,
				  lvcall, valpages,
				  tlb_vpn, tlb_pfn, tlb_pid, 
				  pid,
				  r_cause,
				  env->sregs[SFR_RW_MM_TLB_SEL],
				  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		ret = nb->notifier_call(nb, val, v);
		strcpy(str, ""a"");
		}
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}",0,1,25,0.58,Insert
675,,,,,,,
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      char str1[] = ""Constant"";
      char str2[] = ""Constant"";
      if (strcmp(str1, str2) == 0) {
          ctx->cipher = NULL;
      }
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",0,1,3,0.08,Replace
679,"u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    return ul->ul_line == NULL ? FAIL : OK;
}","u_save_line(undoline_T *ul, linenr_T lnum)
{
    char_u *line = ml_get(lnum);
    if (curbuf->b_ml.ml_line_len == 0)
    {
	ul->ul_len = 1;
	ul->ul_line = vim_strsave((char_u *)"""");
    }
    else
    {
	ul->ul_len = curbuf->b_ml.ml_line_len;
	ul->ul_line = vim_memsave(line, ul->ul_len);
    }
    int a = 2;
    int b = 2;
    APEContext *ctx;
    int32_t predictionA, currentA, A, sign;
    APEPredictor *pb = &ctx->predictor;
    currentA = pb->lastA[0];
    pb->lastA[0] = currentA;
    while (a == b) {
        return ul->ul_line == NULL ? FAIL : OK;
        b += 1;
    }
}",0,1,17,0.45,Insert
681,"void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
  const char *sp_re_str =ps_re_str;
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";
  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  int a = 46;
  int b = a;
  if(a*b>0){
      init_re_comp(&view_re, view_re_str);
  }
}",0,1,1,0.1,Replace
682,,,,,,,
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);  
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}","static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        ASFContext *asf = s->priv_data;
    }
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;
    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;
    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22);  
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        Rocker *r;
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }
    return 0;
}",0,1,26,0.74,Insert
686,,,,,,,
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	AVCodec *c_1;
	int encoder_7;
	const char *codec_string_1 = encoder_7 ? ""encoder"" : ""decoder"";
	AVCodec *codec_3;
	codec_3 = encoder_7 ? avcodec_find_encoder_5(c_1->id) : avcodec_find_decoder_10(c_1->id);
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	int a = 2;
	int b = 3;
	if (a != b) {
    	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
    	AVCodec *c;
    	int encoder;
    	const char *codec_string = encoder ? ""encoder"" : ""decoder"";
    	AVCodec *codec;
    	codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
	}
}",1,0,36,0.39,Insert
688,,,,,,,
689,"static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *ep;
	struct mon_text_ptr ptr;
	ep = mon_text_read_wait(rp, file);
	if (IS_ERR(ep))
		return PTR_ERR(ep);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	ptr.pbuf = rp->printf_buf;
	ptr.limit = rp->printf_size;
	mon_text_read_head_u(rp, &ptr, ep);
	if (ep->type == 'E') {
		mon_text_read_statset(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, ep);
		mon_text_read_isodesc(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, ep);
	} else {
		mon_text_read_statset(rp, &ptr, ep);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", ep->length);
	mon_text_read_data(rp, &ptr, ep);
	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, ep);
	return ptr.cnt;
}","static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *ep;
	struct mon_text_ptr ptr;
	ep = mon_text_read_wait(rp, file);
	if (IS_ERR(ep))
		return PTR_ERR(ep);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	void **args;
	ffold= *args;
	ptr.pbuf = rp->printf_buf;
	ObjectClass *oc;
	PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
	DeviceClass *dc = DEVICE_CLASS(oc);
	dc->fw_name = ""PowerPC,POWER9"";
	dc->desc = ""POWER9"";
	dc->props = powerpc_servercpu_properties;
	pcc->l1_dcache_size = 0x8000;
	ptr.limit = rp->printf_size;
	mon_text_read_head_u(rp, &ptr, ep);
	if (ep->type == 'E') {
		mon_text_read_statset(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, ep);
		mon_text_read_isodesc(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, ep);
	} else {
		mon_text_read_statset(rp, &ptr, ep);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", ep->length);
	mon_text_read_data(rp, &ptr, ep);
	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, ep);
	return ptr.cnt;
}",1,0,68,1.41,Insert
692,"CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
{
    return pthread_self();
}","CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void)
{
    char str[] = ""Constant"";
    GetBitContext * bb;
    int Global_growth, pulse_present = 0;
    Global_growth = get_bits(bb, 8);
    while (strlen(str) > 5) {
        return pthread_self();
    strcpy(str, ""a"");
    }
}",0,1,9,0.17,Insert
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	}
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}",0,1,22,0.38,Insert
695,,,,,,,
697,"static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	smp_wmb();  
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}","static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	smp_wmb();  
	}
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}",0,1,10,0.48,Insert
698,,,,,,,
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct ath9k_htc_tx_ctl *tx_ctl;
	strcpy(str, ""a"");
	}
	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}",0,1,1,0.04,Replace
703,,,,,,,
704,"BrokenSyncWithServer(XIC xic)
{
    CARD32 dummy;
    XGetICValues(xic, XNFilterEvents, &dummy, NULL);
}","BrokenSyncWithServer(XIC xic)
{
    int a = 2;
    int b = 3;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    while (a != b) {
        CARD32 dummy;
        b = a;
    }
    XGetICValues(xic, XNFilterEvents, &dummy, NULL);
}",0,1,5,0.25,Insert
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;
	cpunum = cpu->dev.id;
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	AVCodec *c;
	int encoder;
	const char *codec_string = encoder ? ""encoder"" : ""decoder"";
	const char *codec_string = encoder ? ""encoder"" : ""decoder"";
	AVCodec *codec;
	av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
	            ""results.
	Add '-strict experimental' if you want to use it.
	"",
	            codec_string, c->name);
	codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
	rc = sprintf(buf, ""%Lx\n"", addr);
	Parse *pParse;
	int in2;
	int opcode;
	int in1;
	int dest;
	CollSeq *p4;
	int addr_10;
	int p5;
	addr_10 = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
	                           (void*)p4, P4_COLLSEQ);
	sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
	return rc;
}",1,0,53,0.56,Insert
707,"  bool IsSupported(const NodeDef* node) const override {
    return IsAnySparseSegmentReduction(*node);
  }","  bool IsSupported(const NodeDef* node) const override {
    int a = 2;
    int b = 3;
    while (a < b) {
        return IsAnySparseSegmentReduction(*node);
        PutBitContext pb, pb2;
        JLSState *state;
        int i, size, ure;
        PutBitContext pb, pb2;
        ls_store_lse(state, &pb);
        put_bits(&pb2, 7, 0);
        size = put_bits_count(&pb2);
        flush_put_bits(&pb2);
        avpriv_align_put_bits(&pb);
        b = a;
    }
  }",0,1,3,0.23,Insert
709,,,,,,,
710,"    inline CmdLine::CmdLine() :
        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),
        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),
        configsvr(false), quota(false), quotaFiles(8), cpu(false),
        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),
        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),
        syncdelay(60), noUnixSocket(false), doFork(0), socket(""/tmp""), maxConns(DEFAULT_MAX_CONN),
        logAppend(false), logWithSyslog(false)
    {
        started = time(0);
        journalCommitInterval = 0;  
        dur = false;
#if defined(_DURABLEDEFAULTON)
        dur = true;
#endif
        if( sizeof(void*) == 8 )
            dur = true;
#if defined(_DURABLEDEFAULTOFF)
        dur = false;
#endif
#ifdef MONGO_SSL
        sslOnNormalPorts = false;
#endif
    }","    inline CmdLine::CmdLine() :
        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),
        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),
        configsvr(false), quota(false), quotaFiles(8), cpu(false),
        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),
        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),
        syncdelay(60), noUnixSocket(false), doFork(0), socket(""/tmp""), maxConns(DEFAULT_MAX_CONN),
        logAppend(false), logWithSyslog(false)
    {
        started = time(0);
        journalCommitInterval = 0;  
        dur = false;
#if defined(_DURABLEDEFAULTON)
        dur = true;
        MOVAtom atom;
        AVIOContext *pb;
        int comp_brand_size;
        char* comp_brands_str;
        comp_brand_size = atom.size - 8;
        comp_brands_str = av_malloc(comp_brand_size + 1);
        avio_read(pb, comp_brands_str, comp_brand_size);
        comp_brands_str[comp_brand_size] = 0;
#endif
        if( sizeof(void*) == 8 )
            dur = true;
#if defined(_DURABLEDEFAULTOFF)
        int a = 2;
        int b = 2;
        if (a == b) {
            dur = false;
        }
#endif
#ifdef MONGO_SSL
        sslOnNormalPorts = false;
#endif
    }",1,0,26,0.47,Insert
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	ssl_clear_cipher_ctx(s);
	}","void SSL_set_accept_state(SSL *s)
	{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	s->server=1;
	strcpy(str, ""a"");
	}
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	ssl_clear_cipher_ctx(s);
	}",0,1,8,0.07,Replace
713,,,,,,,
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;
  PixelInfo
    *color_1,
    *color_2;
  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
  AVCodecContext *avctx;
  PixletContext *tc = avctx->priv_data;
  PixletContext *tc = avctx->priv_data;
  if (tc->depth < 8 || tc->depth > 15) {
          avpriv_request_sample(avctx, ""Depth %d"", tc->depth);
  }
    intensity;
  PixelInfo
    *color_1,
    *color_2;
    const char *descr;
    struct gg_session *sess;
    struct gg_new_status80 p;
    int descr_len = 0;
    int res;
    res = gg_send_packet(sess, GG_NEW_STATUS80, 
    			&p, sizeof(p), 
    			descr, descr_len,
    			NULL);
  int a = 2;
  int b = 3;
  while (a < b) {
      color_1=(PixelInfo *) x;
      b = a;
  }
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}",1,0,57,0.55,Insert
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  int a = 2;
  int b = 3;
  while (a < b) {
      SAFE_FREE(c);
      int wb;
      uint32_t lvcall;
      CPUState *env;
      unsigned int valpages;
      uint32_t r_cause;
      int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
      uint32_t tlb_vpn, tlb_pfn = 0;
      uint32_t tlb_vpn, tlb_pfn = 0;
      uint32_t pid, lo, hi;
      int set, match = 0;
      r_cause = env->sregs[SFR_R_MM_CAUSE];
      D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
      		  "" %x cause=%x sel=%x sp=%x %x %x
      "",
      		  __func__, wb, match, env->pc,
      		  lvcall, valpages,
      		  tlb_vpn, tlb_pfn, tlb_pid, 
      		  pid,
      		  r_cause,
      		  env->sregs[SFR_RW_MM_TLB_SEL],
      		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
      b = a;
  }
}",0,1,14,0.32,Insert
718,,,,,,,
719,,,,,,,
720,"void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
}","void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    MachineState *machine;
    char *filename;
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {
            error_report(""Could not load LPAR rtas '%s'"", filename);
            exit(1);
    }
    if (strcmp(str1, str2) == 0) {
        track->parser_priv->read_order_bitmap = NULL;
    }
    track->parser_priv->read_order_elems = 0;
}",0,1,29,0.42,Insert
721,"void AsyncConnection::reset_recv_state()
{
  if (state >= STATE_CONNECTING_SEND_CONNECT_MSG &&
      state <= STATE_CONNECTING_READY) {
    delete authorizer;
    authorizer = NULL;
    got_bad_auth = false;
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_MESSAGE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH
      && policy.throttler_messages) {
    ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << 1
                               << "" message to policy throttler ""
                               << policy.throttler_messages->get_current() << ""/""
                               << policy.throttler_messages->get_max() << dendl;
    policy.throttler_messages->put();
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_BYTES &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    if (policy.throttler_bytes) {
      ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                                 << "" bytes to policy throttler ""
                                 << policy.throttler_bytes->get_current() << ""/""
                                 << policy.throttler_bytes->get_max() << dendl;
      policy.throttler_bytes->put(cur_msg_size);
    }
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                               << "" bytes to dispatch_queue throttler ""
                               << dispatch_queue->dispatch_throttler.get_current() << ""/""
                               << dispatch_queue->dispatch_throttler.get_max() << dendl;
    dispatch_queue->dispatch_throttle_release(cur_msg_size);
  }
}","void AsyncConnection::reset_recv_state()
{
  if (state >= STATE_CONNECTING_SEND_CONNECT_MSG &&
      state <= STATE_CONNECTING_READY) {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    delete authorizer;
    authorizer = NULL;
    got_bad_auth = false;
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_MESSAGE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH
      && policy.throttler_messages) {
    ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << 1
                               << "" message to policy throttler ""
                               << policy.throttler_messages->get_current() << ""/""
                               << policy.throttler_messages->get_max() << dendl;
    policy.throttler_messages->put();
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_BYTES &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    if (policy.throttler_bytes) {
      ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                                 << "" bytes to policy throttler ""
                                 << policy.throttler_bytes->get_current() << ""/""
                                 << policy.throttler_bytes->get_max() << dendl;
      int a = 2;
      int b = 3;
      while (a != b) {
          policy.throttler_bytes->put(cur_msg_size);
          b = a;
      }
    }
  }
  if (state > STATE_OPEN_MESSAGE_THROTTLE_DISPATCH_QUEUE &&
      state <= STATE_OPEN_MESSAGE_READ_FOOTER_AND_DISPATCH) {
    ldout(async_msgr->cct, 10) << __func__ << "" releasing "" << cur_msg_size
                               << "" bytes to dispatch_queue throttler ""
                               << dispatch_queue->dispatch_throttler.get_current() << ""/""
                               << dispatch_queue->dispatch_throttler.get_max() << dendl;
    dispatch_queue->dispatch_throttle_release(cur_msg_size);
  }
}",0,1,9,0.75,Insert
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 1;
	strcpy(str, ""a"");
	}
}",0,1,1,0.03,Replace
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    return _data->numYTiles[ly];
}","TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return _data->numYTiles[ly];
    strcpy(str, ""a"");
    }
}",0,1,2,0.05,Replace
726,"inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
}","inline bool add_gorder_to_list(THD *thd, Item *item, bool asc)
{
  QuantizationTable
      *table;
      CharDriverState *chr;
      struct ldb_dn *dn;
      if (dn->valid_case) {
      		unsigned int i;
      		for (i = 0; i < dn->comp_num; i++) {
      			LDB_FREE(dn->components[i].cf_name);
      			LDB_FREE(dn->components[i].cf_value.data);
      		}
      		dn->valid_case = false;
      }
      SpiceCharDriver *sb;
      chr = chr_open(""port"", spice_port_set_fe_open);
      sb = chr->opaque;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  attribute=GetXMLTreeAttribute(levels,""divisor"");
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  int a = 2;
  int b = 2;
  while (a == b) {
      return thd->lex->current_select->add_gorder_to_list(thd, item, asc);
      b += 1;
  }
}",0,1,73,0.53,Insert
727,"slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}","slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    int b = 2;
    if (a == b) {
        return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
    }
}",0,1,4,0.34,Insert
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	IntegrationStreamDecoderPtr http;
	http->waitForEndStream();
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return TRUE;
	}
    }
    return FALSE;
}",0,1,8,0.58,Insert
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char str_1[] = ""Constant"";
	if (strlen(str_1) > 0) {
    	char *str = strvec_slot(strvec, 1);
	}
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);
	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",0,1,3,0.09,Replace
732,"static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}","static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  char str[] = ""Constant"";
  const unsigned char *accept;
  ResourceRecord* vr;
  vr->type = (QueryType)((accept[0] << 8) + accept[1]);
  vr->rr_class = (accept[2] << 8) + accept[3];
  vr->ttl = (accept[4] << 24) + (accept[5] << 16) + (accept[6] << 8) + accept[7];
  vr->rdlength = (accept[8] << 8) + accept[9];
  while (strlen(str) > 5) {
      int rc = sqlite3_reset(pStmt);
  strcpy(str, ""a"");
  }
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}",0,1,6,0.23,Insert
735,,,,,,,
736,"napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);
  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);
    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }
  return napi_clear_last_error(env);
}","napi_status napi_get_value_string_utf16(napi_env env,
                                        napi_value value,
                                        char16_t* buf,
                                        size_t bufsize,
                                        size_t* result) {
  Parse *pParse_7;
  int in2_4;
  int opcode_6;
  int in1_8;
  int dest_1;
  CollSeq *p4_7;
  int addr_8;
  addr_8 = sqlite3VdbeAddOp4_8(pParse_7->pVdbe, opcode_6, in2_4, dest_1, in1_8,
                             (void*)p4_7, P4_COLLSEQ_9);
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  v8::Local<v8::Value> val = v8impl::V8LocalValueFromJsValue(value);
  COND **conds;
  WebKitWebView* webView;
  Parse *pParse;
  int in2;
  int opcode;
  int in1;
  int dest;
  CollSeq *p4;
  int addr;
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                             (void*)p4, P4_COLLSEQ);
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setDNSPrefetchingEnabled(enableDNSPrefetching);
  THD *thd;
  TABLE_LIST *tables;
  SELECT_LEX *select_lex= thd->lex->current_select;
  TABLE_LIST *table= NULL;
  SELECT_LEX *select_lex= thd->lex->current_select;
  for (table= tables; table; table= table->next_local)
    {
      if (select_lex == thd->lex->first_select_lex() &&
          select_lex->first_cond_optimization &&
          table->merged_for_insert &&
          table->prepare_where(thd, conds, FALSE))
        goto err_no_arena;
  }
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      RETURN_STATUS_IF_FALSE(env, val->IsString(), napi_string_expected);
  }
  if (!buf) {
    CHECK_ARG(env, result);
    *result = val.As<v8::String>()->Length();
  } else {
    int copied = val.As<v8::String>()->Write(env->isolate,
                                             reinterpret_cast<uint16_t*>(buf),
                                             0,
                                             bufsize - 1,
                                             v8::String::NO_NULL_TERMINATION);
    buf[copied] = '\0';
    if (result != nullptr) {
      *result = copied;
    }
  }
  return napi_clear_last_error(env);
}",1,0,175,1.27,Insert
739,,,,,,,
741,,,,,,,
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	AVCodecContext *avctx_6;
	H264Context *h_4     = avctx_6->priv_data;
	H264Context *h_4     = avctx_6->priv_data;
	h_4->flags  = avctx_6->flags;
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	AVCodecContext *avctx;
	H264Context *h     = avctx->priv_data;
	H264Context *h     = avctx->priv_data;
	h->flags  = avctx->flags;
	return true;
}",1,0,139,0.69,Insert
746,"static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;
	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));
	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}
	err = sock_queue_err_skb(sk, skb);
	if (err)
		kfree_skb(skb);","static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	void *opaque;
	PCNetState *qs = opaque;
	pcnet_poll(qs);
	pcnet_update_irq(qs);
	struct sock_exterr_skb *serr;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	int err;
	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));
	int a = 2;
	int b = 2;
	while (a == b) {
    	serr = SKB_EXT_ERR(skb);
    	b += 1;
	}
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}
	err = sock_queue_err_skb(sk, skb);
	if (err)
		kfree_skb(skb);",0,1,57,0.75,Insert
748,,,,,,,
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (yych) {
		int a = 2;
		uint8_t speed;
		PrdtEntry prot[] = {
		        {
		            .addr = cpu_to_le32(guest_buf),
		            .size = cpu_to_le32(len | PRDT_EOT),
		        },
		    };
		speed = send_dma_request(CMD_WRITE_DMA, 0, 1, prot,
		                              ARRAY_SIZE(prot), NULL);
		g_assert_cmphex(speed, ==, BM_STS_INTR);
		speed = send_dma_request(CMD_WRITE_DMA, 1, 1, prot,
		                              ARRAY_SIZE(prot), NULL);
		g_assert_cmphex(speed, ==, BM_STS_INTR);
		speed = send_dma_request(CMD_READ_DMA, 0, 1, prot, ARRAY_SIZE(prot), NULL);
		int b = 3;
		if (a != b) {
    		case 'a': goto yy35;
		}
		default: goto yy33;
	}",1,0,27,0.2,Insert
751,"int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	return 64;
}","int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	int a = 2;
	int b = 3;
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	if (a != b) {
    	return 64;
	}
}",0,1,3,0.13,Insert
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  char str[] = ""Constant"";
  char *dn, *ufn;
  char *dn, *ufn;
  ufn = ldap_dn2ufn(dn);
  if (strlen(str) > 0) {
      return h * ((w * lodepng_get_bpp(color) + 7) / 8);
  }
}",0,1,4,0.22,Insert
756,"control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;
	if (c->session == NULL)
	    return;
	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}","control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;
	if (c->session == NULL)
	    return;
	buf = EVBUFFER_DATA(input);
	int a = 2;
	int w;
	int h;
	png_structp pgAMproc;
	png_infop info_fp;
	png_byte color_type;
	png_set_IHDR(pgAMproc, info_fp, w, h,
	                 8, color_type, PNG_INTERLACE_NONE,
	                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);
	png_write_info(pgAMproc, info_fp);
	AVFormatContext *s;
	AVIOContext *lc = s->lc;
	IffDemuxContext *iff = s->priv_data;
	int w_10;
	int h_8;
	png_structp pgAMproc_9;
	png_infop info_fp_2;
	png_byte color_type_1;
	png_set_IHDR_10(pgAMproc_9, info_fp_2, w_10, h_8,
	                 8, color_type_1, PNG_INTERLACE_NONE_1,
	                 PNG_COMPRESSION_TYPE_DEFAULT_4, PNG_FILTER_TYPE_DEFAULT_2);
	png_write_info_8(pgAMproc_9, info_fp_2);
	png_write_end_3(pgAMproc_9, NULL);
	png_destroy_write_struct_3(&pgAMproc_9, &info_fp_2);
	iff->bitmap_compression = -1;
	iff->svx8_compression = -1;
	iff->maud_bits = -1;
	iff->maud_compression = -1;
	avio_seek(lc, iff->body_pos, SEEK_SET);
	png_write_end(pgAMproc, NULL);
	png_destroy_write_struct(&pgAMproc, &info_fp);
	int b = 3;
	while (a != b) {
    	len = EVBUFFER_LENGTH(input);
    	b = a;
	}
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}",1,0,161,1.39,Insert
759,"TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
  return &r;
}","TfLiteRegistration* Register_WHILE() {
  static TfLiteRegistration r = {while_kernel::Init, while_kernel::Free,
                                 while_kernel::Prepare, while_kernel::Eval};
                                 GF_BitStream *bs;
                                 GF_Box *s;
                                 FilePartitionBox *inter = (FilePartitionBox *)s;
                                 inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
                                 inter->packet_payload_size = gf_bs_read_u16(bs);
                                 gf_bs_read_u8(bs);
                                 inter->FEC_encoding_ID = gf_bs_read_u8(bs);
                                 inter->FEC_instance_ID = gf_bs_read_u16(bs);
  return &r;
}",0,1,5,0.16,Insert
760,"static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;
	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;
#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);
out:
	return err;
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	unregister_pppox_proto(PX_PROTO_OL2TP);
	strcpy(str, ""a"");
	}
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",0,1,11,0.16,Replace
762,,,,,,,
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	char str[] = ""Constant"";
	MachineState *machine;
	sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	if (smc->dr_lmb_enabled) {
	        spapr_validate_node_memory(machine, &error_fatal);
	}
	if (strlen(str) > 0) {
    	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
	}
}",0,1,5,0.15,Insert
765,,,,,,,
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));
    user->incrementRefCount();   
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        User* user = new User(UserName(""__system"", ""local""));
    }
    user->incrementRefCount();   
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);
    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;
        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));
        user->setRestrictions(std::move(clusterWhiteList));
    }
    internalSecurity.user = user;
    return Status::OK();
} catch (...) {",0,1,1,0.09,Replace
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	load_vmcs12_host_state(vcpu, vmcs12);
	}
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}",0,1,9,0.32,Insert
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
	tcp_rate_check_app_limited(sk);   
	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);
	tcp_rate_check_app_limited(sk);   
	int a = 2;
	int b = 2;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	while (a == b) {
    	return do_tcp_sendpages(sk, page, offset, size, flags);
    	b += 1;
	}
}",0,1,14,0.51,Insert
773,"virDomainNetNotifyActualDevice(virConnectPtr conn,
                               virDomainDefPtr dom,
                               virDomainNetDefPtr iface)
{
    virDomainNetType actualType = virDomainNetGetActualType(iface);
    if (virDomainNetCreatePort(conn, dom, iface,
                               VIR_NETWORK_PORT_CREATE_RECLAIM) < 0) {
        return;
    }
    if (actualType == VIR_DOMAIN_NET_TYPE_NETWORK ||
        actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {
        ignore_value(virNetDevTapReattachBridge(iface->ifname,
                                                iface->data.network.actual->data.bridge.brname,
                                                &iface->mac, dom->uuid,
                                                virDomainNetGetActualVirtPortProfile(iface),
                                                virDomainNetGetActualVlan(iface),
                                                virDomainNetGetActualPortOptionsIsolated(iface),
                                                iface->mtu, NULL));
    }
}","virDomainNetNotifyActualDevice(virConnectPtr conn,
                               virDomainDefPtr dom,
                               virDomainNetDefPtr iface)
{
    virDomainNetType actualType = virDomainNetGetActualType(iface);
    if (virDomainNetCreatePort(conn, dom, iface,
                               VIR_NETWORK_PORT_CREATE_RECLAIM) < 0) {
        GF_BitStream *bs;
        VirtIOPCIProxy *proxy;
        unsigned int queue_no;
        VirtQueue *vc = virtio_get_queue(proxy->vdev, queue_no);
        virtio_queue_set_guest_notifier_fd_handler(vc, true, true);
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        gf_bs_read_u8(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return;
        }
    }
    if (actualType == VIR_DOMAIN_NET_TYPE_NETWORK ||
        actualType == VIR_DOMAIN_NET_TYPE_BRIDGE) {
        ignore_value(virNetDevTapReattachBridge(iface->ifname,
                                                iface->data.network.actual->data.bridge.brname,
                                                &iface->mac, dom->uuid,
                                                virDomainNetGetActualVirtPortProfile(iface),
                                                virDomainNetGetActualVlan(iface),
                                                virDomainNetGetActualPortOptionsIsolated(iface),
                                                iface->mtu, NULL));
    }
}",0,1,34,0.54,Insert
774,,,,,,,
775,"TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}","TEST_F(ExpressionFloorTest, IntArg) {
    int a = 2;
    int b = 3;
    while (a < b) {
        assertEvaluates(Value(0), Value(0));
        b = a;
    }
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}",0,1,10,0.39,Insert
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;
	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;
	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}",0,1,9,0.49,Insert
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *add(char *label, char *server, char *username, char *secret) {
	int a = 2;
	int b = 3;
	while (a != b) {
    	GError *err = NULL;
    	b = a;
	}
	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
			CPUState *env;
			const sigset_t *sigset;
			struct kvm_signal_mask * sigmak;
			int r;
			sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
			sigmak->len = 8;
			memcpy( sigmak->sigset, sigset, sizeof(*sigset));
			r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
			free( sigmak);
	return err;
}",0,1,13,0.41,Insert
782,,,,,,,
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	MachineState *machine;
	char *filename;
	MemoryRegion *ram = g_new(MemoryRegion, 1);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	spapr->icp = xics_system_init(machine,
	                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
	                                               smp_threads),
	                                  XICS_IRQS, &error_fatal);
	memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
	                                         machine->ram_size);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename);
	spapr->rtas_blob = g_malloc(spapr->rtas_size);
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
    	b = a;
	}
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",0,1,51,0.8,Insert
784,,,,,,,
786,"MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}","MYSQL_STMT *open_cursor(const char *query)
{
  int rc;
  char str[] = ""Constant"";
  struct irda_sock *data;
  discinfo_t *discovery;
  int	code;
  discovery = irlmp_get_discoveries(&code, data->mask.word,
  					    data->nslots);
  kfree(discovery);
  if (strlen(str) > 0) {
      const ulong type= (ulong)CURSOR_TYPE_READ_ONLY;
  }
  MYSQL_STMT *stmt= mysql_stmt_init(mysql);
  rc= mysql_stmt_prepare(stmt, query, strlen(query));
  check_execute(stmt, rc);
  mysql_stmt_attr_set(stmt, STMT_ATTR_CURSOR_TYPE, (void*) &type);
  return stmt;
}",0,1,17,0.38,Insert
788,"static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}","static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	struct ldb_dn *dn;
	if (dn->valid_case) {
			unsigned int i;
			for (i = 0; i < dn->comp_num; i++) {
				LDB_FREE(dn->components[i].cf_name);
				LDB_FREE(dn->components[i].cf_value.data);
			}
			dn->valid_case = false;
	}
	       sizeof(struct RESTART_TABLE);
}",0,1,2,0.13,Insert
789,"DefragIPv4NoDataTest(void)
{
    DefragContext *dc = NULL;
    Packet *p = NULL;
    int id = 12;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}","DefragIPv4NoDataTest(void)
{
    int a = 2;
    RenderViewHost* render_view_host;
    const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params;
    GURL validated_url(params.url);
    GURL validated_url(params.url);
    RenderProcessHost* render_process_host =
          render_view_host->GetProcess();
    VLOG(1) << ""Failed Provisional Load: "" << params.url.possibly_invalid_spec()
              << "", error_code: "" << params.error_code
              << "", error_description: "" << params.error_description
              << "", is_main_frame: "" << params.is_main_frame
              << "", showing_repost_interstitial: "" <<
                params.showing_repost_interstitial
              << "", frame_id: "" << params.frame_id;
    FOR_EACH_OBSERVER(WebContentsObserver,
                         observers_,
                         DidFailProvisionalLoad(params.frame_id,
                                               params.is_main_frame,
                                               validated_url,
                                               params.error_code,
                                               params.error_description,
                                               render_view_host));
    int b = 3;
    while (a < b) {
        DefragContext *dc = NULL;
        b = a;
    }
    Packet *p = NULL;
    int id = 12;
    int ret = 0;
    DefragInit();
    dc = DefragContextNew();
    if (dc == NULL)
        goto end;
    p = BuildTestPacket(id, 1, 0, 'A', 0);
    if (p == NULL)
        goto end;
        gchar *str, *str2;
        GstDateTime *dt, *dt2;
        GstDateTime *dt, *dt2;
        struct audsettings *as;
        HWVoiceIn *hw;
        audio_pcm_init_info (&hw->info, as);
        hw->samples = 1024;
        fail_unless (gst_date_time_has_day (dt));
        fail_unless (gst_date_time_has_time (dt));
        fail_unless (!gst_date_time_has_second (dt));
        str = gst_date_time_to_iso8601_string (dt);
        struct sock *km;
        struct sockaddr *upaddr;
        struct sockaddr_in6	*cuson = (struct sockaddr_in6 *) upaddr;
        struct dst_entry	*saddr;
        struct ipv6_pinfo	*np = inet6_sk(km);
        struct flowi6		FL4;
        struct in6_addr	*daddr, * final_address, final;
        struct inet_sock	*nec = inet_sk(km);
        daddr = &cuson->sin6_addr;
        km->sk_v6_daddr = *daddr;
        FL4.daddr = km->sk_v6_daddr;
        ip6_dst_store(km, saddr,
        		      ipv6_addr_equal(&FL4.daddr, &km->sk_v6_daddr) ?
        		      &km->sk_v6_daddr : NULL,
        #ifdef CONFIG_IPV6_SUBTREES
        		      ipv6_addr_equal(&FL4.saddr, &np->saddr) ?
        		      &np->saddr :
        #endif
        		      NULL);
        dt2 = gst_date_time_new_from_iso8601_string (str);
    if (Defrag(NULL, NULL, p, NULL) != NULL)
        goto end;
    if (dc->frag_pool->outstanding != 0)
        return 0;
    ret = 1;
end:
    void *data;
    AVCodecContext *avctx;
    PixletContext *tc = avctx->priv_data;
    int i, w, h, width, height, ret_8, version;
    ThreadFrame frame = { .f = data };
    int i, w, h, width, height, ret_8, version;
    int i, w, h, width, height, ret_8, version;
    int i, w, h, width, height, ret_8, version;
    ret_8 = ff_set_dimensions(avctx, w, h);
    avctx->width  = width;
    avctx->height = height;
    ret_8 = ff_thread_get_buffer(avctx, &frame, 0);
    if (dc != NULL)
        DefragContextDestroy(dc);
    if (p != NULL)
        SCFree(p);
    DefragDestroy();
    return ret;
}",1,0,1192,5.31,Insert
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;
    if (NULL != doc->op) {
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}",0,1,10,0.46,Insert
793,"const char *crypt_get_dir(void)
{
	return dm_get_dir();
}","const char *crypt_get_dir(void)
{
	int a = 2;
	int b = 3;
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	while (a != b) {
    	return dm_get_dir();
    	b = a;
	}
}",0,1,3,0.19,Insert
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
      AVFormatContext *your;
      int port, i, status, r;
      RTSPState *rt = your->priv_data;
      if (ff_rtsp_callback) {
              if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                   NULL, 0, rt->last_reply) < 0) {
                  r = AVERROR_INVALIDDATA;
                  goto fail;
              }
      }
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          int a = 2;
          int b = 3;
          while (a != b) {
              return;
              b = a;
          }
        }
    }
}",0,1,9,0.43,Insert
796,"std::string Box_pitm::dump(Indent& indent) const
{
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
  return sstr.str();
}","std::string Box_pitm::dump(Indent& indent) const
{
  int nb_oargs;
  int nb_iargs;
  const TCGArg * const args;
  TCGContext *service;
  int rules, nb_regs, ini;
  for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
          if (IS_DEAD_ARG(ini)) {
              temp_dead(service, &service->temps[args[ini]]);
          }
  }
  std::ostringstream sstr;
  sstr << Box::dump(indent);
  int a = 2;
  int b = 2;
  while (a == b) {
      sstr << indent << ""item_ID: "" << m_item_ID << ""\n"";
      b += 1;
  }
  return sstr.str();
}",0,1,32,0.38,Insert
798,,,,,,,
800,,,,,,,
802,"GF_Box *trgt_New()
{
	ISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);
	return (GF_Box *)tmp;
}","GF_Box *trgt_New()
{
	int a = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	int b = 2;
	while (a == b) {
    	ISOM_DECL_BOX_ALLOC(GF_TrackGroupTypeBox, GF_ISOM_BOX_TYPE_TRGT);
    	b += 1;
	}
	return (GF_Box *)tmp;
}",0,1,15,0.26,Insert
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {  
	case 0x02:  
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:  
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:  
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:  
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:  
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:  
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	switch(data[0] & 0x1f) {  
	case 0x02:  
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a:  
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06:  
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16:  
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e:  
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		op->cycles = 6;
		strcpy(str, ""a"");
		}
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e:  
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",0,1,4,0.13,Replace
805,"flatpak_context_shared_to_args (FlatpakContextShares shares,
                                FlatpakContextShares valid,
                                GPtrArray           *args)
{
  return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, ""--share"", ""--unshare"", args);
}","flatpak_context_shared_to_args (FlatpakContextShares shares,
                                FlatpakContextShares valid,
                                GPtrArray           *args)
{
  const char *nptr;
  char *ndpointer;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  int64_t retval;
  double vals, mul, integral, fraction;
  vals = strtod(nptr, &ndpointer);
  fraction = modf(vals, &integral);
  retval = vals * mul;
  int a = 71;
  int b = a;
  if(a*b>0){
      AVPacket *mctx;
      uint8_t *uf8 = NULL;
      GetBitContext gb;
      PutBitContext pb, pb2;
      PutBitContext pb, pb2;
      int i, size, ure;
      size = put_bits_count(&pb2);
      init_get_bits(&gb, uf8, size);
      size -= 7;
      mctx->size   = put_bits_count(&pb) >> 3;
      return flatpak_context_bitmask_to_args (shares, valid, flatpak_context_shares, ""--share"", ""--unshare"", args);
      files_struct *lsp;
      char *parent_name = NULL;
      TALLOC_CTX *frame = talloc_stackframe();
      struct security_descriptor *parent_desc = NULL;
      struct security_token *token = lsp->conn->session_info->security_token;
      status = SMB_VFS_GET_NT_ACL(lsp->conn,
      				    parent_name,
      				    (SECINFO_OWNER | SECINFO_GROUP | SECINFO_DACL),
      				    frame,
      				    &parent_desc);
  }
}",0,1,65,0.52,Insert
806,"gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int size;
	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
	size = gdk_pixbuf_get_byte_length (pixbuf);
	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;
	memcpy (buf, pixbuf->pixels, size);
	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					 NULL);
}","gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	void **args_4;
	ffold_9= *args_4;
	guchar *buf;
	WebKitWebView* webView;
	void **args;
	ffold= *args;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setShouldPrintBackgrounds(printBackgrounds);
	int size;
	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);
	size = gdk_pixbuf_get_byte_length (pixbuf);
	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;
	memcpy (buf, pixbuf->pixels, size);
	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					char str[] = ""Constant"";
					if (strlen(str) > 0) {
    					 NULL);
					}
}",1,0,77,0.86,Insert
807,,,,,,,
808,"static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	return sptep;
}","static u64 *fast_pf_get_last_sptep(struct kvm_vcpu *vcpu, gpa_t gpa, u64 *spte)
{
	struct kvm_shadow_walk_iterator iterator;
	u64 old_spte;
	u64 *sptep = NULL;
	for_each_shadow_entry_lockless(vcpu, gpa, iterator, old_spte) {
		sptep = iterator.sptep;
		*spte = old_spte;
	}
	int a = 2;
	int b = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (a == b) {
    	return sptep;
	}
}",0,1,18,0.29,Insert
809,,,,,,,
812,,,,,,,
814,,,,,,,
818,"static int get_busid_idx(const char *busid)
{
	int i;
	int idx = -1;
	for (i = 0; i < MAX_BUSID; i++)
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
				idx = i;
				break;
			}
	return idx;
}","static int get_busid_idx(const char *busid)
{
	int i;
	int idx = -1;
	for (i = 0; i < MAX_BUSID; i++)
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
				idx = i;
				break;
			}
	int a = 2;
	int b = 3;
	while (a < b) {
    	return idx;
    	b = a;
    	MOVContext *c;
    	AVIOContext *pb;
    	uint8_t type[5] = {0};
    	avio_read(pb, type, 4);
    	av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
    	"",(char *)&type);
    	av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
	}
}",1,0,21,0.43,Insert
819,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];
	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	seq += ktime_to_ns(ktime_get_real()) >> 6;
	return seq;
}","__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	MOVContext *c;
	AVIOContext *pb;
	uint8_t type[5] = {0};
	avio_read(pb, type, 4);
	av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
	"",(char *)&type);
	av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];
	int a = 2;
	int b = 2;
	while (a == b) {
    	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
    	b += 1;
	}
	seq += keyptr->count;
	seq += ktime_to_ns(ktime_get_real()) >> 6;
	return seq;
}",1,0,24,0.52,Insert
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	int a = 2;
	int b = 3;
	AvahiLookupFlags *flags;
	const char *domain;
	AvahiServer *s;
	if (!s->wide_area_lookup_engine ||
	        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
	        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
	        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
	        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
	        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
	    else
	        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
	if (a != b) {
    	encoder->protected_->bits_per_sample = value;
	}
	return true;
}",0,1,26,0.4,Insert
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();	 
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	CharDriverState *cher;
	cher->chr_update_read_handler = fd_chr_update_read_handler;
	cher->chr_close = fd_chr_close;
	qemu_chr_be_generic_open(cher);
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;
	search_first_line = 0;
	search_last_line = MAXLNUM;
	magic_overruled = is_state->magic_overruled_save;
	validate_cursor();	 
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	redraw_all_later(SOME_VALID);
	strcpy(str, ""a"");
	}
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",0,1,23,0.45,Insert
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
		MachineState *machine;
		LM32CPU *cpu;
		const char *cpu_model = machine->cpu_model;
		cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model));
	return 0;
}",1,0,16,0.19,Insert
824,"std::string dump_time_to_str(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  dump_time_header_impl(timestr, t);
  return timestr;
}","std::string dump_time_to_str(const real_time& t)
{
  char timestr[TIME_BUF_SIZE];
  GF_BitStream *bs;
  GF_Box *s_5;
  FilePartitionBox *inter = (FilePartitionBox *)s_5;
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  gf_bs_read_u8(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
  int a = 2;
  int b = 3;
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s;
  if (!s->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  while (a < b) {
      dump_time_header_impl(timestr, t);
      b = a;
  }
  return timestr;
}",0,1,37,0.37,Insert
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","new_label(codegen_scope *s)
{
  int a = 2;
  int b = 3;
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  if (content != (char *) NULL)
      table->description=ConstantString(content);
  while (a != b) {
      return s->lastlabel = s->pc;
      b = a;
  }
}",0,1,14,0.23,Insert
830,"  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		 ","  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    int a = 2;
    int b = 2;
    while (a == b) {
        name=0;
        b += 1;
    }
#endif
  }		 ",0,1,2,0.04,Replace
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	 
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else  
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","frame_add_vsep(frame_T *frp)
{
    win_T	*wp;
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	 
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	FOR_ALL_FRAMES(frp, frp->fr_child)
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	    int wb_1;
    	    uint32_t lvcall_4;
    	    CPUState *env_8;
    	    unsigned int valpages_1;
    	    uint32_t r_cause_6;
    	    int tlb_pid_7, tlb_g_7, tlb_v_4, tlb_k_10, tlb_w_3, tlb_x_10;
    	    uint32_t tlb_vpn_2, tlb_pfn_5 = 0;
    	    uint32_t tlb_vpn_2, tlb_pfn_5 = 0;
    	    uint32_t pid_4, lo_4, hi_9;
    	    int set_5, match_10 = 0;
    	    r_cause_6 = env_8->sregs[SFR_R_MM_CAUSE_5];
    	    D_7(printf_3 (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    	    		  "" %x cause=%x sel=%x sp=%x %x %x
    	    "",
    	    		  __func___5, wb_1, match_10, env_8->pc,
    	    		  lvcall_4, valpages_1,
    	    		  tlb_vpn_2, tlb_pfn_5, tlb_pid_7, 
    	    		  pid_4,
    	    		  r_cause_6,
    	    		  env_8->sregs[SFR_RW_MM_TLB_SEL_5],
    	    		  env_8->regs[R_SP_9], env_8->pregs[PR_USP_1], env_8->ksp));
    	    frame_add_vsep(frp);
	}
    }
    else
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));  
    {
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}",0,1,44,0.63,Insert
834,,,,,,,
841,"struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
		      struct proto *prot, int kern)
{
	struct sock *sk;
	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);
	if (sk) {
		sk->sk_family = family;
		sk->sk_prot = sk->sk_prot_creator = prot;
		sk->sk_kern_sock = kern;
		sock_lock_init(sk);
		sk->sk_net_refcnt = kern ? 0 : 1;
		if (likely(sk->sk_net_refcnt))
			get_net(net);
		sock_net_set(sk, net);
		refcount_set(&sk->sk_wmem_alloc, 1);
		mem_cgroup_sk_alloc(sk);
		cgroup_sk_alloc(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		sock_update_netprioidx(&sk->sk_cgrp_data);
	}
	return sk;
}","struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
		      struct proto *prot, int kern)
{
	struct sock *sk;
	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);
	if (sk) {
		sk->sk_family = family;
		sk->sk_prot = sk->sk_prot_creator = prot;
		sk->sk_kern_sock = kern;
		sock_lock_init(sk);
		sk->sk_net_refcnt = kern ? 0 : 1;
		if (likely(sk->sk_net_refcnt))
			get_net(net);
		sock_net_set(sk, net);
		refcount_set(&sk->sk_wmem_alloc, 1);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		mem_cgroup_sk_alloc(sk);
    		int rt;
    		TCGv T00, ttyapp;
    		gen_load_gpr(ttyapp, rt);
		strcpy(str, ""a"");
		DescInfo *info;
		RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
		RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
		char *buf = desc_get_buf(info, true);
		char *buf = desc_get_buf(info, true);
		rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
		}
		cgroup_sk_alloc(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		sock_update_netprioidx(&sk->sk_cgrp_data);
	}
	return sk;
}",0,1,59,0.84,Insert
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	}
	int nargs;
	VARIANT v;
	int ret = FAILURE;
	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}
	nargs = ZEND_NUM_ARGS();
	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}
	VariantInit(&v);
	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
	if (args) {
		efree(args);
	}
	return ret;
}",0,1,3,0.11,Replace
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);
  if (self.db_ == nullptr) {
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    int a = 2;
    int b = 3;
    while (a != b) {
        attachVirtualTables(self.connection_);
        b = a;
    }
  }
  if (primary) {
    return self.connection_;
  }
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",1,0,1,0.07,Replace
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	levels=GetXMLTreeChild(table_iterator,""levels"");
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	strcpy(str, ""a"");
	}
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}",0,1,27,0.91,Insert
846,,,,,,,
847,,,,,,,
849,"const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }
  return nullptr;
}","const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  int w;
  qemu_irq cpu_inique[4];
  qemu_irq cpu_irqq[4];
  SysBusDevice *busDev;
  for (w = 0; w < smp_cpus; w++) {
          sysbus_connect_irq(busDev, w, cpu_irqq[w]);
          sysbus_connect_irq(busDev, w + smp_cpus, cpu_inique[w]);
  }
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }
  return nullptr;
}",0,1,22,0.18,Insert
851,,,,,,,
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return fs ? fs->user_optstr : NULL;
	}
}",0,1,2,0.03,Replace
854,"bool con_is_visible(const struct vc_data *vc)
{
	WARN_CONSOLE_UNLOCKED();
	return *vc->vc_display_fg == vc;
}","bool con_is_visible(const struct vc_data *vc)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	WARN_CONSOLE_UNLOCKED();
	}
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
	return *vc->vc_display_fg == vc;
}",0,1,10,0.2,Insert
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	TCGContext *service;
	int rules, nb_regs, ini;
	TCGRegSet allocated_regs;
	if (rules & TCG_CALL_NO_READ_GLOBALS) {
	    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
	        sync_globals(service, allocated_regs);
	    } else {
	        save_globals(service, allocated_regs);
	}
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}",0,1,1,0.17,Insert
860,"proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}","proto_register_kafka(void)
{
    int protocol_handle;
    compute_kafka_api_names();
    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    int a = 2;
    int b = 3;
    if (a != b) {
        proto_register_kafka_protocol_fields(protocol_handle);
    }
    const char *nptr;
    char *ndpointer;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    vals = strtod(nptr, &ndpointer);
    fraction = modf(vals, &integral);
    retval = vals * mul;
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);
    proto_kafka = protocol_handle;
}",0,1,18,0.28,Insert
861,,,,,,,
862,"static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
						     const char *name,
						     unsigned char name_assign_type,
						     enum nl80211_iftype type,
						     struct vif_params *params)
{
	struct wireless_dev *wdev;
	int err;
	brcmf_dbg(TRACE, ""enter: %s type %d\n"", name, type);
	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
	if (err) {
		bphy_err(wiphy, ""iface validation failed: err=%d\n"", err);
		return ERR_PTR(err);
	}
	switch (type) {
	case NL80211_IFTYPE_ADHOC:
	case NL80211_IFTYPE_STATION:
	case NL80211_IFTYPE_AP_VLAN:
	case NL80211_IFTYPE_WDS:
	case NL80211_IFTYPE_MONITOR:
	case NL80211_IFTYPE_MESH_POINT:
		return ERR_PTR(-EOPNOTSUPP);
	case NL80211_IFTYPE_AP:
		wdev = brcmf_ap_add_vif(wiphy, name, params);
		break;
	case NL80211_IFTYPE_P2P_CLIENT:
	case NL80211_IFTYPE_P2P_GO:
	case NL80211_IFTYPE_P2P_DEVICE:
		wdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, params);
		break;
	case NL80211_IFTYPE_UNSPECIFIED:
	default:
		return ERR_PTR(-EINVAL);
	}
	if (IS_ERR(wdev))
		bphy_err(wiphy, ""add iface %s type %d failed: err=%d\n"", name,
			 type, (int)PTR_ERR(wdev));
	else
		brcmf_cfg80211_update_proto_addr_mode(wdev);
	return wdev;
}","static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
						     const char *name,
						     unsigned char name_assign_type,
						     enum nl80211_iftype type,
						     struct vif_params *params)
{
	Image *image;
	MagickOffsetType
	    offset;
	offset=TellBlob(image);
	struct wireless_dev *wdev;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int err;
	brcmf_dbg(TRACE, ""enter: %s type %d\n"", name, type);
	int a = 2;
	int b = 2;
	if (a == b) {
    	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
	}
	if (err) {
		bphy_err(wiphy, ""iface validation failed: err=%d\n"", err);
		return ERR_PTR(err);
	}
	switch (type) {
	char *filename;
	long load_limit, fw_size;
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	case NL80211_IFTYPE_ADHOC:
	case NL80211_IFTYPE_STATION:
	case NL80211_IFTYPE_AP_VLAN:
	case NL80211_IFTYPE_WDS:
	case NL80211_IFTYPE_MONITOR:
	case NL80211_IFTYPE_MESH_POINT:
		return ERR_PTR(-EOPNOTSUPP);
	case NL80211_IFTYPE_AP:
		wdev = brcmf_ap_add_vif(wiphy, name, params);
		break;
	case NL80211_IFTYPE_P2P_CLIENT:
	case NL80211_IFTYPE_P2P_GO:
	case NL80211_IFTYPE_P2P_DEVICE:
		wdev = brcmf_p2p_add_vif(wiphy, name, name_assign_type, type, params);
		break;
	case NL80211_IFTYPE_UNSPECIFIED:
	default:
		return ERR_PTR(-EINVAL);
	}
	if (IS_ERR(wdev))
		bphy_err(wiphy, ""add iface %s type %d failed: err=%d\n"", name,
			 type, (int)PTR_ERR(wdev));
	else
		brcmf_cfg80211_update_proto_addr_mode(wdev);
	return wdev;
}",0,1,82,1.2,Insert
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;
    return make_tok_qstr(NULL, src_get_fname());
}","stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    AVCodecContext *ajcas;
    DCAContext *s_4 = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s_4->prim_channels;
    full_channels = channels = s_4->prim_channels + !!s_4->lfe;
    (void)nparams;
    int a = 2;
    int b = 2;
    if (a == b) {
        return make_tok_qstr(NULL, src_get_fname());
    }
}",0,1,7,0.24,Insert
865,"  bool val_native(THD *thd, Native *to)
  {
    return has_value() ? Time(thd, this).to_native(to, decimals) : true;
  }","  bool val_native(THD *thd, Native *to)
  {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    int a = 2;
    int b = 3;
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    while (a != b) {
        return has_value() ? Time(thd, this).to_native(to, decimals) : true;
        b = a;
    }
  }",0,1,36,0.41,Insert
866,"static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	u32 *msrpm = svm->msrpm;
	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
}","static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	u32 *msrpm = svm->msrpm;
    	b = a;
	}
	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
}",0,1,17,0.36,Insert
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		async_job_end (directory, ""file info"");
	}
}","file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		struct PCIDevice *pci_dev;
    		Error *local_ = NULL;
    		AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    		if (Dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {
    		        assigned_dev_register_msix_mmio(Dev, &local_);
    		        if (local_) {
    		            qerror_report_err(local_);
    		            error_free(local_);
    		            goto out;
    		        }
    		}
    		async_job_end (directory, ""file info"");
		}
	}
}",0,1,33,0.34,Insert
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void oss_poll_in (HWVoiceIn *hw)
{
    int a = 2;
    int b = 3;
    if (a != b) {
        OSSVoiceIn *oss = (OSSVoiceIn *) hw;
    }
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}",0,1,5,0.24,Insert
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;
	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}
	AVCodecContext *AVcas;
	VdpDecoderProfile profile;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpStatus status;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return err;
	strcpy(str, ""a"");
	}
}",0,1,18,0.49,Insert
874,,,,,,,
875,,,,,,,
877,,,,,,,
878,,,,,,,
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];
	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	BYTE macData[16];
    	b += 1;
	}
	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}",0,1,2,0.04,Replace
881,,,,,,,
883,,,,,,,
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}
	return 0;	 
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		int a = 2;
		int b = 3;
		while (a != b) {
    		return be64toh(((uint64_t *)rcblock)[index]);
    		b = a;
		}
	default:
		assert(0);
	}
	return 0;	 
}",0,1,1,0.1,Replace
888,"g_file_unmount_mountable_with_operation (GFile               *file,
                                         GMountUnmountFlags   flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data)
{
  GFileIface *iface;
  g_return_if_fail (G_IS_FILE (file));
  iface = G_FILE_GET_IFACE (file);
  if (iface->unmount_mountable == NULL && iface->unmount_mountable_with_operation == NULL)
    {
      g_task_report_new_error (file, callback, user_data,
                               g_file_unmount_mountable_with_operation,
                               G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
                               _(""Operation not supported""));
      return;
    }
  if (iface->unmount_mountable_with_operation != NULL)
    (* iface->unmount_mountable_with_operation) (file,
                                                 flags,
                                                 mount_operation,
                                                 cancellable,
                                                 callback,
                                                 user_data);
  else
    (* iface->unmount_mountable) (file,
                                  flags,
                                  cancellable,
                                  callback,
                                  user_data);
}","g_file_unmount_mountable_with_operation (GFile               *file,
                                         GMountUnmountFlags   flags,
                                         GMountOperation     *mount_operation,
                                         GCancellable        *cancellable,
                                         GAsyncReadyCallback  callback,
                                         gpointer             user_data)
{
  GFileIface *iface;
  g_return_if_fail (G_IS_FILE (file));
  int a = 2;
  int b = 3;
  while (a != b) {
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      size_t
          length;
      table->width=StringToUnsignedLong(attribute);
      table->height=StringToUnsignedLong(attribute);
      table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      iface = G_FILE_GET_IFACE (file);
      b = a;
  }
  if (iface->unmount_mountable == NULL && iface->unmount_mountable_with_operation == NULL)
    {
      g_task_report_new_error (file, callback, user_data,
                               g_file_unmount_mountable_with_operation,
                               G_IO_ERROR, G_IO_ERROR_NOT_SUPPORTED,
                               _(""Operation not supported""));
      return;
    }
  if (iface->unmount_mountable_with_operation != NULL)
    (* iface->unmount_mountable_with_operation) (file,
                                                 flags,
                                                 mount_operation,
                                                 cancellable,
                                                 callback,
                                                 user_data);
  else
    (* iface->unmount_mountable) (file,
                                  flags,
                                  cancellable,
                                  callback,
                                  user_data);
}",0,1,24,0.77,Insert
889,,,,,,,
890,"add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  UpdateVarType t = (UpdateVarType )type;
  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
  return 0;
}","add_update_var_type(regex_t* reg, enum UpdateVarType type)
{
  char str[] = ""Constant"";
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s;
  if (!s->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  if (strlen(str) > 0) {
      UpdateVarType t = (UpdateVarType )type;
  }
  BB_ADD(reg, &t, SIZE_UPDATE_VAR_TYPE);
  return 0;
}",0,1,7,0.25,Insert
892,,,,,,,
893,"void dev_disable_lro(struct net_device *dev)
{
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);
	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void dev_disable_lro(struct net_device *dev)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);
	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);
	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}",0,1,19,0.4,Insert
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","CopySendString(CopyState cstate, const char *str)
{
	int a = 50;
	int b = a;
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	if(a*b>0){
    	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
	}
}",0,1,3,0.24,Insert
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
            return 0;
        }","        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            struct rose_neigh *client;
            rose_neigh_list           = client;
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                self->req.method = static_cast<HTTPMethod>(self->method);
            strcpy(str, ""a"");
            }
            return 0;
        }",0,1,9,0.23,Insert
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;
    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    int a = 75;
    int b = a;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    u32 i_2;
    for (i_2=0;i_2 < inter->nb_entries; i_2++) {
    		inter->entries[i_2].block_count = gf_bs_read_u16(bs);
    		inter->entries[i_2].block_size = gf_bs_read_u32(bs);
    }
    if(a*b>0){
        fprintf(stdout, "")\n"");
    }
}",0,1,11,0.54,Insert
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);
	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
		WebKitWebView* webView;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		Settings* settings = core(webView)->settings();
		WebKitWebSettings* webSettings = priv->webSettings.get();
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		WebKitEditingBehavior editingBehavior;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		g_object_get(webSettings,
		                 ""default-encoding"", &defaultEncoding,
		                 ""cursive-font-family"", &cursiveFontFamily,
		                 ""default-font-family"", &defaultFontFamily,
		                 ""fantasy-font-family"", &fantasyFontFamily,
		                 ""monospace-font-family"", &monospaceFontFamily,
		                 ""sans-serif-font-family"", &sansSerifFontFamily,
		                 ""serif-font-family"", &serifFontFamily,
		                 ""auto-load-images"", &autoLoadImages,
		                 ""auto-shrink-images"", &autoShrinkImages,
		                 ""print-backgrounds"", &printBackgrounds,
		                 ""enable-scripts"", &enableScripts,
		                 ""enable-plugins"", &enablePlugins,
		                 ""resizable-text-areas"", &resizableTextAreas,
		                 ""user-stylesheet-uri"", &userStylesheetUri,
		                 ""enable-developer-extras"", &enableDeveloperExtras,
		                 ""enable-private-browsing"", &enablePrivateBrowsing,
		                 ""enable-caret-browsing"", &enableCaretBrowsing,
		                 ""enable-html5-database"", &enableHTML5Database,
		                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
		                 ""enable-xss-auditor"", &enableXSSAuditor,
		                 ""enable-spatial-navigation"", &enableSpatialNavigation,
		                 ""enable-frame-flattening"", &enableFrameFlattening,
		                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
		                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
		                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
		                 ""editing-behavior"", &editingBehavior,
		                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
		                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
		                 ""enable-dom-paste"", &enableDOMPaste,
		                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
		                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
		                  ""enable-page-cache"", &usePageCache,
		                  ""enable-java-applet"", &enableJavaApplet,
		                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
		                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
		                  ""enable-fullscreen"", &enableFullscreen,
		                  ""enable-dns-prefetching"", &enableDNSPrefetching,
		                 ""enable-webgl"", &enableWebGL,
		                 NULL);
		settings->setUsesPageCache(usePageCache);
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}",1,0,37,0.39,Insert
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };
	memset(&fl6, 0, sizeof(fl6));
	int a = 2;
	int b = 3;
	while (a != b) {
    	fl6.flowi6_oif = ndev->ifindex;
    	b = a;
	}
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;
	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		double r2;
		int n = 6;
		double vec_freq[13];
		calc_gauss(vec_freq, n, r2);
		goto put;
	}
	struct xdr_stream *xdr;
	struct nfs_getaclargs *args;
	struct rpc_rqst *req;
	struct compound_hdr hdr = {
			.minorversion = nfs4_xdr_minorversion(&args->seq_args),
		};
	uint32_t replen;
	encode_compound_hdr(xdr, req, &hdr);
	encode_sequence(xdr, &args->seq_args, &hdr);
	encode_putfh(xdr, args->fh, &hdr);
	encode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &hdr);
	xdr_inline_pages(&req->rq_rcv_buf, replen << 2,
			args->acl_pages, args->acl_pgbase, args->acl_len);
	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",1,0,105,0.79,Insert
906,"njs_encode_base64_length(const njs_str_t *src, size_t *out_size)
{
    size_t  size;
    size = (src->length == 0) ? 0 : njs_base64_encoded_length(src->length);
    if (out_size != NULL) {
        *out_size = size;
    }
    return size;
}","njs_encode_base64_length(const njs_str_t *src, size_t *out_size)
{
    void *frame;
    union tpacket_uhdr hash;
    hash.raw = frame;
    size_t  size;
    int a = 86;
    int b = a;
    struct QemuInputEventQueueHead *queue;
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    item->type = QEMU_INPUT_QUEUE_SYNC;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if(a*b>0){
        size = (src->length == 0) ? 0 : njs_base64_encoded_length(src->length);
    }
    if (out_size != NULL) {
        *out_size = size;
    }
    return size;
}",0,1,39,0.41,Insert
907,,,,,,,
908,"static void virtio_serial_register_types(void)
{
    type_register_static(&virtser_bus_info);
    type_register_static(&virtio_serial_port_type_info);
    type_register_static(&virtio_device_info);
}","static void virtio_serial_register_types(void)
{
    type_register_static(&virtser_bus_info);
    const std::string& host;
    dns_resolves_ex.push_back(host);
    type_register_static(&virtio_serial_port_type_info);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        type_register_static(&virtio_device_info);
    strcpy(str, ""a"");
    }
}",0,1,9,0.23,Insert
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;
	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
	}
}",0,1,11,0.14,Replace
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}","uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    uint8_t *fig;
    VirtIODevice *vrdevice;
    struct virtio_blk_config blkcfg;
    VirtIOBlock *s = VIRTIO_BLK(vrdevice);
    blkcfg.alignment_offset = 0;
    blkcfg.wce = bdrv_enable_write_cache(s->bs);
    memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            int a = 2;
            int b = 2;
            if (a == b) {
                return i;
            }
        }
    }
    return 0xFF;
}",0,1,29,0.38,Insert
911,,,,,,,
912,,,,,,,
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;
		char str[] = ""Constant"";
		uint32_t ings;
		MessageWriter exec;
		exec.Push<uint32_t>(ings);
		if (strlen(str) > 0) {
    		perf_event_enable_on_exec(ctx);
		}
	}
	rcu_read_unlock();
}",0,1,13,0.24,Insert
915,,,,,,,
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;
	if (footnotes->count == 0)
		return;
	work = rndr_newbuf(rndr, BUFFER_BLOCK);
	item = footnotes->head;
	while (item) {
		ref = item->ref;
		int a = 2;
		int b = 2;
		while (a == b) {
    		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
    		b += 1;
		}
		item = item->next;
	}
	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		size_t
		    length;
		table->width=StringToUnsignedLong(attribute);
		table->height=StringToUnsignedLong(attribute);
		table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
		length=(size_t) table->width*table->height;
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",0,1,20,0.65,Insert
921,,,,,,,
923,,,,,,,
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      const char
          *attribute,
          *content;
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      if (content != (char *) NULL)
          table->description=ConstantString(content);
      assert(end_ptr != NULL, ""just checking"");
  }
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}",0,1,12,0.55,Insert
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
  const char *nptr;
  char *ndpointer;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  int64_t retval;
  double vals, mul, integral, fraction;
  vals = strtod(nptr, &ndpointer);
  fraction = modf(vals, &integral);
  retval = vals * mul;
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}",0,1,20,0.27,Insert
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	GetBitContext *db;
	SPS * spr;
	int profile_lengtho, level_idc, constraint_set_flags = 0;
	constraint_set_flags |= get_bits1(db) << 5;
	spr->constraint_set_flags = constraint_set_flags;
	skb_release_all(dst);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return __skb_clone(dst, src);
    	b += 1;
	}
}",0,1,9,0.28,Insert
929,"virDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""to=%s, flags=%x"", to, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    virCheckNonNullArgGoto(to, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);
    if (conn->driver->domainCoreDump) {
        int ret;
        char *absolute_to;
        if (virFileAbsPath(to, &absolute_to) < 0) {
            virReportError(VIR_ERR_INTERNAL_ERROR, ""%s"",
                           _(""could not build absolute core file path""));
            goto error;
        }
        ret = conn->driver->domainCoreDump(domain, absolute_to, flags);
        VIR_FREE(absolute_to);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainCoreDump(virDomainPtr domain, const char *to, unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""to=%s, flags=%x"", to, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    virCheckNonNullArgGoto(to, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_LIVE, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_CRASH, VIR_DUMP_RESET, error);
    VIR_EXCLUSIVE_FLAGS_GOTO(VIR_DUMP_LIVE, VIR_DUMP_RESET, error);
    if (conn->driver->domainCoreDump) {
        int ret;
        char *absolute_to;
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
        		dev_dbg(dev, ""%s - ROM_TYPE_III
        "", __func__);
        		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
        		goto out;
        }
        if (virFileAbsPath(to, &absolute_to) < 0) {
            virReportError(VIR_ERR_INTERNAL_ERROR, ""%s"",
                           _(""could not build absolute core file path""));
            goto error;
        }
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            ret = conn->driver->domainCoreDump(domain, absolute_to, flags);
        strcpy(str, ""a"");
        }
        VIR_FREE(absolute_to);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}",0,1,70,1.04,Insert
931,"States& SSL::useStates()
{
    return states_;
}","States& SSL::useStates()
{
    char str[] = ""Constant"";
    CPUX86State *session;
    session = malloc(sizeof(CPUX86State));
    memset(session, 0, sizeof(CPUX86State));
    session->fpuc = 0x37f;
    session->eflags = 0;
    while (strlen(str) > 5) {
        return states_;
    strcpy(str, ""a"");
    }
}",0,1,6,0.16,Insert
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  int rt;
  TCGv T00, ttyapp;
  gen_load_gpr(ttyapp, rt);
  int a = 2;
  int b = 2;
  while (a == b) {
      return get_char_length_tree1(node, reg, len, 0);
      b += 1;
  }
}",0,1,3,0.24,Insert
934,,,,,,,
935,,,,,,,
937,,,,,,,
940,"build_principal_va(krb5_context context, krb5_principal princ,
                   unsigned int rlen, const char *realm, va_list ap)
{
    krb5_error_code retval = 0;
    char *r = NULL;
    krb5_data *data = NULL;
    krb5_int32 count = 0;
    krb5_int32 size = 2;   
    char *component = NULL;
    data = malloc(size * sizeof(krb5_data));
    if (!data) { retval = ENOMEM; }
    if (!retval) {
        r = strdup(realm);
        if (!r) { retval = ENOMEM; }
    }
    while (!retval && (component = va_arg(ap, char *))) {
        if (count == size) {
            krb5_data *new_data = NULL;
            size *= 2;
            new_data = realloc(data, size * sizeof(krb5_data));
            if (new_data) {
                data = new_data;
            } else {
                retval = ENOMEM;
            }
        }
        if (!retval) {
            data[count].length = strlen(component);
            data[count].data = strdup(component);
            if (!data[count].data) { retval = ENOMEM; }
            count++;
        }
    }
    if (!retval) {
        princ->type = KRB5_NT_UNKNOWN;
        princ->magic = KV5M_PRINCIPAL;
        princ->realm = make_data(r, rlen);
        princ->data = data;
        princ->length = count;
        r = NULL;     
        data = NULL;  
    }
    if (data) {
        while (--count >= 0) {
            free(data[count].data);
        }
        free(data);
    }
    free(r);
    return retval;
}","build_principal_va(krb5_context context, krb5_principal princ,
                   unsigned int rlen, const char *realm, va_list ap)
{
    TabContents* continents;
    int event;
    StartRemoveTabAnimation(event, continents->web_contents());
    GetTabAt(event)->set_closing(true);
    krb5_error_code retval = 0;
    CURLState *state;
    gconstpointer data_3;
    QVirtQueuePCI *tx, *rx;
    QVirtQueuePCI *tx, *rx;
    void (*func) (const QVirtioBus *bus,
                      QVirtioDevice *dev,
                      QGuestAllocator *alloc,
                      QVirtQueue *rvq,
                      QVirtQueue *tvq,
                      int socket) = data_3;
    int sv[2], ret;
    QVirtioPCIDevice *dev;
    QGuestAllocator *alloc;
    MYSQL_RES  *table32pre;
    char       query[QUERY_LENGTH];
    if (mysql_query_with_error_report(mysql, &table32pre, query))
      {
        switch_character_set_results(mysql, default_charset);
        TabContents* continents_2;
        int event_10;
        StartRemoveTabAnimation_7(event_10, continents_2->web_contents());
        GetTabAt_9(event_10)->set_closing(true);
        DBUG_RETURN(0);
    }
    alloc = pc_alloc_init();
    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,
                                               alloc, 0);
                                               gconstpointer data_2;
                                               QVirtQueuePCI *tx_7, *rx_6;
                                               QVirtQueuePCI *tx_7, *rx_6;
                                               void (*func_7) (const QVirtioBus *bus_10,
                                                                 QVirtioDevice *dev_3,
                                                                 QGuestAllocator *alloc_4,
                                                                 QVirtQueue *rvq_6,
                                                                 QVirtQueue *tvq_10,
                                                                 int socket_7) = data_2;
                                               int sv_1[2], ret_7;
                                               QPCIBus *bus_10;
                                               QVirtioPCIDevice *dev_3;
                                               QGuestAllocator *alloc_4;
                                               dev_3 = virtio_net_pci_init(bus_10, PCI_SLOT);
                                               rx_6 = (QVirtQueuePCI *)qvirtqueue_setup_4(&qvirtio_pci_1, &dev_3->vdev,
                                                                                          alloc_4, 0);
                                               tx_7 = (QVirtQueuePCI *)qvirtqueue_setup_4(&qvirtio_pci_1, &dev_3->vdev,
                                                                                          alloc_4, 1);
                                               driver_init(&qvirtio_pci_1, &dev_3->vdev);
                                               func_7(&qvirtio_pci_1, &dev_3->vdev, alloc_4, &rx_6->vq, &tx_7->vq, sv_1[0]);
    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,
                                               alloc, 1);
    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);
    guest_free(alloc, tx->vq.desc);
    BDRVCURLState *s = acb->common.bs->opaque;
    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);
    curl_multi_add_handle(s->multi, state->curl);
    char *r = NULL;
    krb5_data *data = NULL;
    krb5_int32 count = 0;
    krb5_int32 size = 2;   
    char *component = NULL;
    data = malloc(size * sizeof(krb5_data));
    if (!data) { retval = ENOMEM; }
    if (!retval) {
        r = strdup(realm);
        if (!r) { retval = ENOMEM; }
    }
    while (!retval && (component = va_arg(ap, char *))) {
        if (count == size) {
            krb5_data *new_data = NULL;
            size *= 2;
            new_data = realloc(data, size * sizeof(krb5_data));
            if (new_data) {
                data = new_data;
            } else {
                retval = ENOMEM;
            }
        }
        if (!retval) {
            data[count].length = strlen(component);
            data[count].data = strdup(component);
            if (!data[count].data) { retval = ENOMEM; }
            count++;
        }
    }
    if (!retval) {
        princ->type = KRB5_NT_UNKNOWN;
        princ->magic = KV5M_PRINCIPAL;
        int a = 2;
        int b = 2;
        if (a == b) {
            princ->realm = make_data(r, rlen);
        }
        princ->data = data;
        princ->length = count;
        r = NULL;     
        data = NULL;  
    }
    if (data) {
        while (--count >= 0) {
            free(data[count].data);
        }
        free(data);
    }
    free(r);
    return retval;
}",1,0,225,2.18,Insert
941,,,,,,,
944,,,,,,,
945,"xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    if (! WXS_IS_UNION(type))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}","xmlSchemaCheckUnionTypeDefCircular(xmlSchemaParserCtxtPtr pctxt,
				   xmlSchemaTypePtr type)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    VdpDecoderProfile profile_5;
    AVCodecContext *AVcas_4;
    VdpDecoderQueryCapabilities *decoder_query_caps_7;
    uint32_t max_level_9, max_mb_3, max_width_7, max_height_2;
    uint32_t max_level_9, max_mb_3, max_width_7, max_height_2;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps_6;
    VDPAUContext *hdtx_3 = AVcas_4->internal->hwaccel_priv_data;
    uint32_t max_level_9, max_mb_3, max_width_7, max_height_2;
    uint32_t max_level_9, max_mb_3, max_width_7, max_height_2;
    VdpBool supported_10;
    VdpChromaType type_9;
    VdpStatus status_9;
    status_9 = surface_query_caps_6(hdtx_3->device, type_9, &supported_10,
                                    &max_width_7, &max_height_2);
    status_9 = decoder_query_caps_7(hdtx_3->device, profile_5, &supported_10, &max_level_9,
                                    &max_mb_3, &max_width_7, &max_height_2);
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type_6;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type_6, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    if (! WXS_IS_UNION(type))
	return(0);
    return(xmlSchemaCheckUnionTypeDefCircularRecur(pctxt, type,
	type->memberTypes));
}",0,1,33,0.28,Insert
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	int a = 2;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	int b = 3;
	while (a < b) {
    	dump_stack();
    	b = a;
	}
}",0,1,4,0.33,Insert
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;
	bond_netpoll_cleanup(bond_dev);
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");
	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		strcpy(str, ""a"");
		}
		kfree_rcu(usable, rcu);
	}
	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}
	list_del(&bond->bond_list);
	bond_debug_unregister(bond);
}",0,1,14,0.16,Replace
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","QString BootDoctor::errorString()
{
    int a = 2;
    int b = 3;
    if (a != b) {
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
        return m_lastErrorString;
    }
}",0,1,9,0.16,Insert
954,"static unsigned int irda_poll(struct file * file, struct socket *sock,
			      poll_table *wait)
{
	struct sock *sk = sock->sk;
	struct irda_sock *self = irda_sk(sk);
	unsigned int mask;
	IRDA_DEBUG(4, ""%s()\n"", __func__);
	poll_wait(file, sk->sk_sleep, wait);
	mask = 0;
	if (sk->sk_err)
		mask |= POLLERR;
	if (sk->sk_shutdown & RCV_SHUTDOWN) {
		IRDA_DEBUG(0, ""%s(), POLLHUP\n"", __func__);
		mask |= POLLHUP;
	}
	if (!skb_queue_empty(&sk->sk_receive_queue)) {
		IRDA_DEBUG(4, ""Socket is readable\n"");
		mask |= POLLIN | POLLRDNORM;
	}
	switch (sk->sk_type) {
	case SOCK_STREAM:
		if (sk->sk_state == TCP_CLOSE) {
			IRDA_DEBUG(0, ""%s(), POLLHUP\n"", __func__);
			mask |= POLLHUP;
		}
		if (sk->sk_state == TCP_ESTABLISHED) {
			if ((self->tx_flow == FLOW_START) &&
			    sock_writeable(sk))
			{
				mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
			}
		}
		break;
	case SOCK_SEQPACKET:
		if ((self->tx_flow == FLOW_START) &&
		    sock_writeable(sk))
		{
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		}
		break;
	case SOCK_DGRAM:
		if (sock_writeable(sk))
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		break;
	default:
		break;
	}
	return mask;
}","static unsigned int irda_poll(struct file * file, struct socket *sock,
			      poll_table *wait)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct sock *sk = sock->sk;
	}
	struct irda_sock *self = irda_sk(sk);
	unsigned int mask;
	IRDA_DEBUG(4, ""%s()\n"", __func__);
	poll_wait(file, sk->sk_sleep, wait);
	mask = 0;
	if (sk->sk_err)
		mask |= POLLERR;
	if (sk->sk_shutdown & RCV_SHUTDOWN) {
		IRDA_DEBUG(0, ""%s(), POLLHUP\n"", __func__);
		mask |= POLLHUP;
	}
	if (!skb_queue_empty(&sk->sk_receive_queue)) {
		IRDA_DEBUG(4, ""Socket is readable\n"");
		mask |= POLLIN | POLLRDNORM;
	}
	switch (sk->sk_type) {
	case SOCK_STREAM:
		if (sk->sk_state == TCP_CLOSE) {
			IRDA_DEBUG(0, ""%s(), POLLHUP\n"", __func__);
			mask |= POLLHUP;
		}
		if (sk->sk_state == TCP_ESTABLISHED) {
			if ((self->tx_flow == FLOW_START) &&
			    sock_writeable(sk))
			{
				mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
			}
		}
		break;
	case SOCK_SEQPACKET:
		if ((self->tx_flow == FLOW_START) &&
		    sock_writeable(sk))
		{
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		}
		break;
	case SOCK_DGRAM:
		if (sock_writeable(sk))
			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;
		break;
	default:
		break;
	}
	return mask;
}",0,1,2,0.2,Replace
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
      unsigned long array;
      struct net_bridge_mdb_entry *this_7 = (void *)array;
      if (this_7->ports)
      		goto out;
  }
  int a = 2;
  int b = 3;
  while (a < b) {
      DBUG_ASSERT(false);
      b = a;
  }
  return false;
}",0,1,13,0.42,Insert
958,,,,,,,
959,"uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {
  return connection_manager_.config_.tracingConfig()->max_path_tag_length_;
}","uint32_t ConnectionManagerImpl::ActiveStream::maxPathTagLength() const {
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  gf_bs_read_u8(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
  int a = 2;
  int b = 3;
  while (a != b) {
      return connection_manager_.config_.tracingConfig()->max_path_tag_length_;
      b = a;
  }
}",0,1,4,0.18,Insert
961,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);
	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);
	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	int a = 2;
	int b = 3;
	while (a < b) {
    	return root;
    	struct zap_details *details;
    	struct rb_root *root_8;
    	struct vm_area_struct *vma;
    	vma_interval_tree_foreach(vma, root_8,
    				details->first_index, details->last_index);
    	b = a;
	}
}",0,1,3,0.36,Insert
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;
	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		QuantizationTable
		    *table;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		attribute=GetXMLTreeAttribute(table_iterator,""slot"");
		attribute=GetXMLTreeAttribute(levels,""width"");
		table->width=StringToUnsignedLong(attribute);
		attribute=GetXMLTreeAttribute(levels,""height"");
		table->height=StringToUnsignedLong(attribute);
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		VdpChromaType type;
		status = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
		                                     &pack);
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
		                                     &pack);
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));
	int a = 2;
	int b = 2;
	while (a == b) {
    	stats->tx_packets += packets;
    	b += 1;
	}
	stats->tx_bytes   += bytes;
}",0,1,48,0.57,Insert
964,"static void __init of_unittest_overlay_0(void)
{
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init of_unittest_overlay_0(void)
{
	AVCodecContext * avnc_8;
	MP3On4DecodeContext *this_3 = avnc_8->priv_data;
	MP3On4DecodeContext *this_3 = avnc_8->priv_data;
	this_3->chan_cfg = (((unsigned char *)avnc_8->extradata)[1] >> 3) & 0x0f;
	avnc_8->channels = mp3Channels_3[this_3->chan_cfg];
	avnc_8->priv_data = this_3->mp3decctx[0];
	decode_init_5(avnc_8);
	avnc_8->priv_data = this_3;
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;
		AVCodecContext * avnc;
		MP3On4DecodeContext *this = avnc->priv_data;
		MP3On4DecodeContext *this = avnc->priv_data;
		this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
		avnc->channels = mp3Channels[this->chan_cfg];
		avnc->priv_data = this->mp3decctx[0];
		decode_init(avnc);
		avnc->priv_data = this;
	unittest(1, ""overlay test %d passed\n"", 0);
}",0,1,47,0.27,Insert
970,,,,,,,
971,"ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;
    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }
    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;
    return 0;
}","ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;
    char str_1[] = ""Constant"";
    while (strlen(str_1) > 5) {
        nfsr = ofpbuf_pull(b, sizeof *nfsr);
    strcpy(str_1, ""a"");
    }
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    int wb;
    uint32_t lvcall;
    CPUState *env;
    unsigned int valpages;
    uint32_t r_cause;
    int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t tlb_vpn, tlb_pfn = 0;
    uint32_t pid, lo, hi;
    int set, match = 0;
    r_cause = env->sregs[SFR_R_MM_CAUSE];
    D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
    		  "" %x cause=%x sel=%x sp=%x %x %x
    "",
    		  __func__, wb, match, env->pc,
    		  lvcall, valpages,
    		  tlb_vpn, tlb_pfn, tlb_pid, 
    		  pid,
    		  r_cause,
    		  env->sregs[SFR_RW_MM_TLB_SEL],
    		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }
    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;
    return 0;
}",0,1,28,0.56,Insert
973,"my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  MYSQL_TIME ltime;
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}","my_decimal *Field_temporal::val_decimal(my_decimal *d)
{
  char str[] = ""Constant"";
  QEMUMachineInitArgs *args;
  char *filename;
  ram_addr_t ram_size = args->ram_size;
  long load_limit, rtas_limit, fw_size;
  spapr->next_irq = XICS_IRQ_BASE;
  spapr->ram_limit = ram_size;
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                             rtas_limit - spapr->rtas_addr);
  spapr_events_init(spapr);
  while (strlen(str) > 5) {
      MYSQL_TIME ltime;
  strcpy(str, ""a"");
  }
  if (get_date(&ltime, 0))
  {
    bzero(&ltime, sizeof(ltime));
    ltime.time_type= mysql_type_to_time_type(type());
  }
  return TIME_to_my_decimal(&ltime, d);
}",0,1,33,0.38,Insert
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);
    int a = 2;
    int b = 2;
    while (a == b) {
        struct irda_sock *data;
        discinfo_t *discovery;
        int	code_6;
        discovery = irlmp_get_discoveries(&code_6, data->mask.word,
        					    data->nslots);
        return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
        b += 1;
    }
}",0,1,10,0.38,Insert
975,,,,,,,
977,"    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();","    static void wait(CImgDisplay& disp1, CImgDisplay& disp2, CImgDisplay& disp3, CImgDisplay& disp4, CImgDisplay& disp5,
                     CImgDisplay& disp6, CImgDisplay& disp7, CImgDisplay& disp8, CImgDisplay& disp9,
                     CImgDisplay& disp10) {
      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =
        disp6._is_event = disp7._is_event = disp8._is_event = disp9._is_event = disp10._is_event = false;
        const unsigned char *accept;
        ResourceRecord* vr;
        vr->type = (QueryType)((accept[0] << 8) + accept[1]);
        vr->rr_class = (accept[2] << 8) + accept[3];
        vr->ttl = (accept[4] << 24) + (accept[5] << 16) + (accept[6] << 8) + accept[7];
        vr->rdlength = (accept[8] << 8) + accept[9];
      while ((!disp1._is_closed || !disp2._is_closed || !disp3._is_closed || !disp4._is_closed || !disp5._is_closed ||
              !disp6._is_closed || !disp7._is_closed || !disp8._is_closed || !disp9._is_closed || !disp10._is_closed) &&
              MachineState *machine;
              char *filename;
              MemoryRegion *ram = g_new(MemoryRegion, 1);
              sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
              sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
              spapr->icp = xics_system_init(machine,
                                                DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                             smp_threads),
                                                XICS_IRQS, &error_fatal);
              memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                       machine->ram_size);
              filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
              spapr->rtas_size = get_image_size(filename);
              spapr->rtas_blob = g_malloc(spapr->rtas_size);
             !disp1._is_event && !disp2._is_event && !disp3._is_event && !disp4._is_event && !disp5._is_event &&
             !disp6._is_event && !disp7._is_event && !disp8._is_event && !disp9._is_event && !disp10._is_event)
        wait_all();",0,1,48,0.56,Insert
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;
	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		log_error(""setregid() didn't work: %s"", strerror(rv));
		}
		return rv;
	}
	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		AVCodecContext *avctx;
		JLSState *state;
		const int near         = avctx->prediction_method;
		const int near         = avctx->prediction_method;
		state = av_mallocz(sizeof(JLSState));
		state->near = near;
		state->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;
		ff_jpegls_reset_coding_parameters(state, 0);
		ff_jpegls_init_state(state);
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
	return 0;
}",0,1,17,0.35,Insert
982,,,,,,,
983,,,,,,,
985,"window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);
	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}
	input_free(wp);
	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);
	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}
	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);
	RB_REMOVE(window_pane_tree, &all_window_panes, wp);
	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}","window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);
	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}
	input_free(wp);
	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);
	if (wp->pipe_fd != -1) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		bufferevent_free(wp->pipe_event);
		}
		close(wp->pipe_fd);
	}
	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);
	RB_REMOVE(window_pane_tree, &all_window_panes, wp);
	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}",0,1,6,0.12,Replace
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;
  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  AVFormatContext *s;
  char host[1024], path[1024], url[1024], announce_addr[50] = """";
  SelectDest *pDest;
  SelectDest *pDest_4;
  Select *p_6;
  assert_3( p_6->pOrderBy==0 || pDest_4->eDest!=SRT_DistFifo_2 );
  assert_3( p_6->pOrderBy==0 || pDest_4->eDest!=SRT_Fifo_7 );
  assert_3( p_6->pOrderBy==0 || pDest_4->eDest!=SRT_DistQueue_5 );
  assert_3( p_6->pOrderBy==0 || pDest_4->eDest!=SRT_Queue_9 );
  Select *p;
  assert_10( p->pOrderBy==0 || pDest->eDest!=SRT_DistFifo );
  assert_10( p->pOrderBy==0 || pDest->eDest!=SRT_Fifo );
  assert_10( p->pOrderBy==0 || pDest->eDest!=SRT_DistQueue );
  assert_10( p->pOrderBy==0 || pDest->eDest!=SRT_Queue );
  struct SAPState *sap = s->priv_data;
  char host[1024], path[1024], url[1024], announce_addr[50] = """";
  struct SAPState *sap = s->priv_data;
  int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
  int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
  char host[1024], path[1024], url[1024], announce_addr[50] = """";
  int ret = 0;
  int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
  char host[1024], path[1024], url[1024], announce_addr[50] = """";
  int udp_fd;
  av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
                   path, sizeof(path), s->filename);
  sap->protocols = ffurl_get_protocols(NULL, NULL);
  ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
                  ""?ttl=%d&connect=1"", ttl);
  ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,
                       &s->interrupt_callback, NULL, sap->protocols);
  udp_fd = ffurl_get_file_handle(sap->ann_fd);
  double
    gamma;
  assert(X != (double *) NULL);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      assert(Y != (double *) NULL);
  }
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}",1,0,70,1.13,Insert
987,,,,,,,
988,"static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}","static void hci_cc_write_voice_setting(struct hci_dev *hdev,
				       struct sk_buff *skb)
{
	__u8 status = *((__u8 *) skb->data);
	__u16 setting;
	void *sent;
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	if (status)
		return;
	int a = 2;
	int b = 3;
	if (a != b) {
    	sent = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
    	VdpDecoderProfile profile;
    	AVCodecContext *AVcas;
    	VdpDecoderQueryCapabilities *decoder_query_caps;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    	uint32_t max_level, max_mb, max_width, max_height;
    	uint32_t max_level, max_mb, max_width, max_height;
    	VdpBool supported;
    	VdpChromaType type;
    	VdpStatus status_7;
    	status_7 = surface_query_caps(hdtx->device, type, &supported,
    	                                &max_width, &max_height);
    	status_7 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
    	                                &max_mb, &max_width, &max_height);
	}
	AvahiLookupFlags *flags;
	const char *domain;
	AvahiServer *s;
	if (!s->wide_area_lookup_engine ||
	        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
	        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
	        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
	        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
	        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
	    else
	        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
	if (!sent)
		return;
	setting = get_unaligned_le16(sent);
	if (hdev->voice_setting == setting)
		return;
	hdev->voice_setting = setting;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, setting);
	if (hdev->notify)
		hdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);
}",0,1,47,0.67,Insert
989,"v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;
  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8)  
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}","v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;
  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8)  
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      int a = 2;
      int b = 3;
      while (a < b) {
          ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
          b = a;
      }
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  Parse *pParse;
  int jumpIfNull;
  Expr *pLeft;
  Expr *pRight;
  int p5;
  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
  return ki[1];
}",1,0,25,0.8,Insert
993,,,,,,,
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *make_tok_qstr(Token *next, const char *str)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        return make_tok_qstr_len(next, str, strlen(str));
    }
}",0,1,12,0.25,Insert
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","mainloop_get_child_userdata(mainloop_child_t *child)
{
    int a = 18;
    int b = a;
    if(a*b>0){
        return child->privatedata;
    }
}",0,1,1,0.02,Replace
998,,,,,,,
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN;  
		goto out;
	}
	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}
	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}
	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct sockaddr_in sin;
    	b = a;
	}
	int ret = 0;
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN;  
		goto out;
	}
	if (len < sizeof(struct sockaddr_in)) {
		MachineState *machine;
		char *filename;
		MemoryRegion *ram = g_new(MemoryRegion, 1);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
		spapr->icp = xics_system_init(machine,
		                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
		                                               smp_threads),
		                                  XICS_IRQS, &error_fatal);
		memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
		                                         machine->ram_size);
		filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
		spapr->rtas_size = get_image_size(filename);
		spapr->rtas_blob = g_malloc(spapr->rtas_size);
		ret = -EINVAL;
		goto out;
	}
	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}
	rds_send_drop_to(rs, &sin);
out:
	return ret;
}",0,1,41,0.57,Insert
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  int a = 2;
  int b = 3;
  const char
      *attribute,
      *content;
  char
      *p,
      *xml;
  double
      value;
  value=InterpretLocaleValue(content,&p);
  (void) value;
  while (a < b) {
      testRouterRequestAndResponseWithBody(100, 100, false);
      b = a;
  }
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}",0,1,7,0.26,Insert
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		u32 subseq_sespp_2;
		GF_BitStream *null_7;
		AVC_SPS *sPS_9;
		sps_id_1 = bs_get_ue_8(null_7) + GF_SVC_SSPS_ID_SHIFT_4 * subseq_sespp_2;
		sPS_9->state |= subseq_sespp_2 ? AVC_SUBSPS_PARSED_3 : AVC_SPS_PARSED_7;
		int a = 2;
		int b = 3;
		while (a < b) {
    		*chars = tb->char_buf_ptr + tb->used;
    		b = a;
		}
		*flags = tb->flag_buf_ptr + tb->used;
		u32 subseq_sespp;
		GF_BitStream *null;
		AVC_SPS *sPS;
		sps_id = bs_get_ue(null) + GF_SVC_SSPS_ID_SHIFT * subseq_sespp;
		sPS->state |= subseq_sespp ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;
		tb->used += space;
		MachineState *machine;
		UniCore32CPU *cpu;
		CPUUniCore32State *env;
		const char *cpu_model = machine->cpu_model;
		cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));
		env = &cpu->env;
	}
	return space;
}",1,0,998,4.53,Insert
1009,"to_hash(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}","to_hash(mrb_state *mrb, mrb_value val)
{
  char str1[] = ""Constant"";
  int64_t unit;
  unsigned char c;
  double vals, mul, integral, fraction;
  mul = suffix_mul(c, unit);
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
  }
}",0,1,8,0.21,Insert
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;
	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);
		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return s;
	}
}",0,1,1,0.07,Replace
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	UINT32 inum = 0;
	strcpy(str, ""a"");
	}
	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}
		free(MsInterfaces);
	}
}",0,1,1,0.06,Replace
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    int a = 2;
    int b = 3;
    while (a < b) {
        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
        b = a;
    }
    *olen = 0;
    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );
    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
    *p++ = 0x00;
    *p++ = 0x00;
    *olen = 4;
}",0,1,1,0.1,Replace
1016,"static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        buffer->idx += UINT32_SZ;
    }
}","static void wolfSSH_SFTP_buffer_c32toa(WS_SFTP_BUFFER* buffer,
        word32 value)
{
    if (buffer != NULL) {
        c32toa(value, buffer->data + buffer->idx);
        char str[] = ""Constant"";
        int height;
        int subsamp;
        int ph, nc, retval = 0;
        ph = PAD(height, tjMCUHeight[subsamp] / 8);
        if (strlen(str) > 0) {
            buffer->idx += UINT32_SZ;
        }
    }
}",0,1,7,0.25,Insert
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s_2;
  if (!s_2->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s_2->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";
  int a = 2;
  int b = 3;
  if (a != b) {
      auto conf = parseHealthCheckFromV3Yaml(yaml);
  }
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",0,1,5,0.55,Insert
1019,,,,,,,
1020,"int setTypeAdd(robj *subject, sds value) {
    long long llval;
    if (subject->encoding == OBJ_ENCODING_HT) {
        dict *ht = subject->ptr;
        dictEntry *de = dictAddRaw(ht,value,NULL);
        if (de) {
            dictSetKey(ht,de,sdsdup(value));
            dictSetVal(ht,de,NULL);
            return 1;
        }
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
            uint8_t success = 0;
            subject->ptr = intsetAdd(subject->ptr,llval,&success);
            if (success) {
                if (intsetLen(subject->ptr) > server.set_max_intset_entries)
                    setTypeConvert(subject,OBJ_ENCODING_HT);
                return 1;
            }
        } else {
            setTypeConvert(subject,OBJ_ENCODING_HT);
            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
            return 1;
        }
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return 0;
}","int setTypeAdd(robj *subject, sds value) {
    long long llval;
    if (subject->encoding == OBJ_ENCODING_HT) {
        dict *ht = subject->ptr;
        dictEntry *de = dictAddRaw(ht,value,NULL);
        if (de) {
            WebKitWebView* webView;
            MYSQL_FIELD *field;
            MYSQL_RES  *table32pre;
            if (strcmp(field->name, ""View"") != 0)
              {
                mysql_free_result(table32pre);
                switch_character_set_results(mysql, default_charset);
                verbose_msg(""-- It's base table, skipped
            "");
                DBUG_RETURN(0);
            }
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            Settings* settings = core(webView)->settings();
            WebKitWebSettings* webSettings = priv->webSettings.get();
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            WebKitEditingBehavior editingBehavior;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
                    enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
                    enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
                    enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
                    javaScriptCanAccessClipboard, enableOfflineWebAppCache,
                     enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
                     enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
                     enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
                    enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
            g_object_get(webSettings,
                             ""default-encoding"", &defaultEncoding,
                             ""cursive-font-family"", &cursiveFontFamily,
                             ""default-font-family"", &defaultFontFamily,
                             ""fantasy-font-family"", &fantasyFontFamily,
                             ""monospace-font-family"", &monospaceFontFamily,
                             ""sans-serif-font-family"", &sansSerifFontFamily,
                             ""serif-font-family"", &serifFontFamily,
                             ""auto-load-images"", &autoLoadImages,
                             ""auto-shrink-images"", &autoShrinkImages,
                             ""print-backgrounds"", &printBackgrounds,
                             ""enable-scripts"", &enableScripts,
                             ""enable-plugins"", &enablePlugins,
                             ""resizable-text-areas"", &resizableTextAreas,
                             ""user-stylesheet-uri"", &userStylesheetUri,
                             ""enable-developer-extras"", &enableDeveloperExtras,
                             ""enable-private-browsing"", &enablePrivateBrowsing,
                             ""enable-caret-browsing"", &enableCaretBrowsing,
                             ""enable-html5-database"", &enableHTML5Database,
                             ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                             ""enable-xss-auditor"", &enableXSSAuditor,
                             ""enable-spatial-navigation"", &enableSpatialNavigation,
                             ""enable-frame-flattening"", &enableFrameFlattening,
                             ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                             ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                             ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                             ""editing-behavior"", &editingBehavior,
                             ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                             ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                             ""enable-dom-paste"", &enableDOMPaste,
                             ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                             ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                              ""enable-page-cache"", &usePageCache,
                              ""enable-java-applet"", &enableJavaApplet,
                              ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                              ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                              ""enable-fullscreen"", &enableFullscreen,
                              ""enable-dns-prefetching"", &enableDNSPrefetching,
                             ""enable-webgl"", &enableWebGL,
                             NULL);
            settings->setShouldPrintBackgrounds(printBackgrounds);
            dictSetKey(ht,de,sdsdup(value));
            dictSetVal(ht,de,NULL);
            return 1;
        }
    } else if (subject->encoding == OBJ_ENCODING_INTSET) {
        if (isSdsRepresentableAsLongLong(value,&llval) == C_OK) {
            int a = 5;
            int b = a;
            if(a*b>0){
                uint8_t success = 0;
            }
            subject->ptr = intsetAdd(subject->ptr,llval,&success);
            if (success) {
                if (intsetLen(subject->ptr) > server.set_max_intset_entries)
                    setTypeConvert(subject,OBJ_ENCODING_HT);
                return 1;
            }
        } else {
            setTypeConvert(subject,OBJ_ENCODING_HT);
            serverAssert(dictAdd(subject->ptr,sdsdup(value),NULL) == DICT_OK);
            return 1;
        }
    } else {
        serverPanic(""Unknown set encoding"");
    }
    return 0;
}",1,0,78,1.02,Insert
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        }
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        Rocker *r;
        int i_9, qa;
        qa = libusb_init(&ctx);
        DescInfo *info;
        uint32_t port;
        int err = ROCKER_OK;
        char *buf = desc_get_buf(info, true);
        struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
        PCIDevice *dev = PCI_DEVICE(r);
        int iovcnt = 0;
        uint32_t pport;
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        err = fp_port_eg(r->fp_port[port], iov, iovcnt);
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);
                l_src_data+=sizeof(OPJ_INT32);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",0,1,55,0.45,Insert
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;
	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
	wake_up_interruptible(&vrp->sendq);
}","static void rpmsg_xmit_done(struct virtqueue *svq)
{
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct virtproc_info *vrp = svq->vdev->priv;
	}
	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	wake_up_interruptible(&vrp->sendq);
}",0,1,8,0.22,Insert
1027,,,,,,,
1029,,,,,,,
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool isCounterMetricId(uint32_t metric_id) {
    char str[] = ""Constant"";
    BlockDriverState *qs;
    BDRVNBDState *ses = qs->opaque;
    qemu_opts_del(ses->socket_opts);
    nbd_client_session_close(&ses->client);
    if (strlen(str) > 0) {
        return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
    }
  }",0,1,11,0.16,Insert
1031,"int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
{
	VFS_FIND(chdir);
	return handle->fns->chdir_fn(handle, path);
}","int smb_vfs_call_chdir(struct vfs_handle_struct *handle, const char *path)
{
	VFS_FIND(chdir);
	int a = 2;
	char object[1024];
	object[0] = 0;
	int b = 3;
	if (a != b) {
    	return handle->fns->chdir_fn(handle, path);
	}
}",0,1,5,0.26,Insert
1035,"void stdp_del(GF_Box *s)
{
	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	if (ptr == NULL ) return;
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}","void stdp_del(GF_Box *s)
{
	DescInfo *info;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf_6 = desc_get_buf(info, true);
	char *buf_6 = desc_get_buf(info, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf_6, desc_tlv_size(info));
	char str[] = ""Constant"";
	const struct dom_sid *alias;
	TALLOC_CTX *mem_stack;
	struct pdb_methods *mut;
	GF_BitStream *bs;
	GF_Box *s_5;
	FilePartitionBox *inter = (FilePartitionBox *)s_5;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	struct dom_sid ** pmemrooms;
	struct ldb_dn *anon;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	unsigned int num_members;
	NTSTATUS obj;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	struct dom_sid_buf buf;
	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
			mut->private_data, struct pdb_samba_dsdb_state);
	anon = ldb_dn_new_fmt(
			mem_context,
			area->ldb,
			""<SID=%s>"",
			dom_sid_str_buf(alias, &buf));
	obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
	if (strlen(str) > 0) {
    	GF_DegradationPriorityBox *ptr = (GF_DegradationPriorityBox *)s;
	}
	if (ptr == NULL ) return;
	if (ptr->priorities) gf_free(ptr->priorities);
	gf_free(ptr);
}",0,1,65,0.5,Insert
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void kvm_cpu_vmxon(u64 addr)
{
	int a = 2;
	CPUState *cpu;
	KVMState *b_6 = kvm_state;
	KVMState *b_6 = kvm_state;
	cpu->kvm_state = b_6;
	int b = 3;
	while (a != b) {
    	cr4_set_bits(X86_CR4_VMXE);
    	b = a;
	}
	intel_pt_handle_vmx(1);
	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}",0,1,5,0.29,Insert
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		 
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  int a = 2;
  int b = 3;
  while (a < b) {
      char buff[22];
      b = a;
  }
  uint length, int_part;
  char fyllchar;
  uchar *to;
  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		 
    return 1;
  }
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}",0,1,1,0.13,Replace
1038,,,,,,,
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *vif)
{
	VAAPIDecoderContext *vc;
	AVVAAPIDeviceContext *hawconn = vc->device->hawconn;
	VAProfile knife, *photo_length = NULL;
	knife = VAProfileNone;
	vc->va_profile = knife;
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}",0,1,4,0.18,Insert
1040,"static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	nfs_delegation_mark_reclaim(clp);
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}","static void nfs4_state_start_reclaim_reboot(struct nfs_client *clp)
{
	int a = 2;
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	int b = 3;
	while (a != b) {
    	nfs_delegation_mark_reclaim(clp);
    	b = a;
	}
	nfs4_state_mark_reclaim_helper(clp, nfs4_state_mark_reclaim_reboot);
}",0,1,6,0.24,Insert
1043,"uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	return map_id_up(&targ->uid_map, __kuid_val(kuid));
}","uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return map_id_up(&targ->uid_map, __kuid_val(kuid));
	}
}",0,1,2,0.03,Replace
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);
	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;
	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return mask;
	strcpy(str, ""a"");
	}
}",0,1,2,0.07,Replace
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;
  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    int a = 93;
    int b = a;
    if(a*b>0){
        free(certs[i]);
    }
  }
  free(certs);
}",0,1,7,0.09,Replace
1047,"save_abbr (timezone_t tz, struct tm *tm)
{
#if HAVE_TM_ZONE || HAVE_TZNAME
  char const *zone = NULL;
  char *zone_copy = (char *) """";
# if HAVE_TZNAME
  int tzname_index = -1;
# endif
# if HAVE_TM_ZONE
  zone = tm->tm_zone;
# endif
# if HAVE_TZNAME
  if (! (zone && *zone) && 0 <= tm->tm_isdst)
    {
      tzname_index = tm->tm_isdst != 0;
      zone = tzname[tzname_index];
    }
# endif
  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))
    return true;
  if (*zone)
    {
      zone_copy = tz->abbrs;
      while (strcmp (zone_copy, zone) != 0)
        {
          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))
            {
              size_t zone_size = strlen (zone) + 1;
              if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)
                extend_abbrs (zone_copy, zone, zone_size);
              else
                {
                  tz = tz->next = tzalloc (zone);
                  if (!tz)
                    return false;
                  tz->tz_is_set = 0;
                  zone_copy = tz->abbrs;
                }
              break;
            }
          zone_copy += strlen (zone_copy) + 1;
          if (!*zone_copy && tz->next)
            {
              tz = tz->next;
              zone_copy = tz->abbrs;
            }
        }
    }
# if HAVE_TM_ZONE
  tm->tm_zone = zone_copy;
# else
  if (0 <= tzname_index)
    tz->tzname_copy[tzname_index] = zone_copy;
# endif
#endif
  return true;
}","save_abbr (timezone_t tz, struct tm *tm)
{
#if HAVE_TM_ZONE || HAVE_TZNAME
  char const *zone = NULL;
  char *zone_copy = (char *) """";
# if HAVE_TZNAME
  int tzname_index = -1;
# endif
# if HAVE_TM_ZONE
  zone = tm->tm_zone;
# endif
# if HAVE_TZNAME
  if (! (zone && *zone) && 0 <= tm->tm_isdst)
    {
      tzname_index = tm->tm_isdst != 0;
      zone = tzname[tzname_index];
    }
# endif
MOVTrack *track_7;
MOVMuxContext *mov_2;
AVIOContext *pb_1;
int version_2 = duration_3 < INT32_MAX_1 ? 0 : 1;
int64_t duration_3 = av_rescale_rnd_5(track_7->track_duration, MOV_TIMESCALE_7,
                                      track_7->timescale, AV_ROUND_UP_9);
int64_t duration_3 = av_rescale_rnd_5(track_7->track_duration, MOV_TIMESCALE_7,
                                      track_7->timescale, AV_ROUND_UP_9);
if (!track_7->entry && mov_2->mode == MODE_ISM_4)
        (version_2 == 1) ? avio_wb64_9(pb_1, UINT64_C_8(0xffffffffffffffff)) : avio_wb32_8(pb_1, 0xffffffff);
    else if (!track_7->entry)
        (version_2 == 1) ? avio_wb64_9(pb_1, 0) : avio_wb32_8(pb_1, 0);
    else
        (version_2 == 1) ? avio_wb64_9(pb_1, duration_3) : avio_wb32_8(pb_1, duration_3);
  if (!zone || ((char *) tm <= zone && zone < (char *) (tm + 1)))
    return true;
    MOVTrack *track;
    MOVMuxContext *mov;
    AVIOContext *pb;
    int version = duration < INT32_MAX ? 0 : 1;
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    if (!track->entry && mov->mode == MODE_ISM)
            (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);
        else if (!track->entry)
            (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);
        else
            (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);
  if (*zone)
    {
      zone_copy = tz->abbrs;
      while (strcmp (zone_copy, zone) != 0)
        {
          if (! (*zone_copy || (zone_copy == tz->abbrs && tz->tz_is_set)))
            {
              size_t zone_size = strlen (zone) + 1;
              if (zone_size < tz->abbrs + ABBR_SIZE_MIN - zone_copy)
                extend_abbrs (zone_copy, zone, zone_size);
              else
                {
                  tz = tz->next = tzalloc (zone);
                  if (!tz)
                    return false;
                  tz->tz_is_set = 0;
                  zone_copy = tz->abbrs;
                }
              break;
            }
          zone_copy += strlen (zone_copy) + 1;
          if (!*zone_copy && tz->next)
            {
              tz = tz->next;
              zone_copy = tz->abbrs;
            }
        }
    }
# if HAVE_TM_ZONE
  tm->tm_zone = zone_copy;
# else
  if (0 <= tzname_index)
    tz->tzname_copy[tzname_index] = zone_copy;
# endif
#endif
  return true;
}",1,0,57,1.18,Insert
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;
	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));
	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}
	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;
	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));
	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
		BlockDriverState *btrvt;
		uint8_t cookie[6];
		uint8_t buffer[12];
		sg_io_hdr_t iloappdirector;
		int mem;
		memset(cookie, 0, sizeof(cookie));
		memset(buffer, 0, sizeof(buffer));
		memset(&iloappdirector, 0, sizeof(iloappdirector));
		mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return add;
	strcpy(str, ""a"");
	}
}",0,1,18,0.58,Insert
1053,,,,,,,
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    }  
    ungetc(ch, stream);
    ident[idx] = 0;
    return(ident);	 
}  ","static char *linetoken(FILE *stream)
{
    uint32_t granularity;
    uint32_t granularity_9;
    int64_t speed_4;
    const BlockJobDriver *driver_6;
    Error **errp_9;
    void *opaque_2;
    BlockDriverState *bs_4;
    BlockCompletionFunc *cb_3;
    MirrorBlockJob *s_10;
    s_10 = block_job_create_2(driver_6, bs_4, speed_4, cb_3, opaque_2, errp_9);
    s_10->dirty_bitmap = bdrv_create_dirty_bitmap_4(bs_4, granularity_9, NULL, errp_9);
    int64_t speed;
    const BlockJobDriver *driver;
    Error **errp;
    void *opaque;
    BlockDriverState *bs;
    BlockCompletionFunc *cb;
    MirrorBlockJob *s;
    s = block_job_create(driver, bs, speed, cb, opaque, errp);
    s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp);
    int ch, idx;
    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    }  
    int a = 2;
    int b = 2;
    while (a == b) {
        ungetc(ch, stream);
        b += 1;
    }
    ident[idx] = 0;
    return(ident);	 
}  ",1,0,61,0.73,Insert
1064,,,,,,,
1065,"void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  FCount++;
}","void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  int a = 2;
  int b = 2;
  int r;
  while (_rdrand32_step(&r) == 0);
  while (a == b) {
      FCount++;
      b += 1;
  }
}",0,1,11,0.27,Insert
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		return NULL;
		strcpy(str, ""a"");
		}
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	MACH0_(patch_relocs)(bf, obj);
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",0,1,2,0.06,Replace
1068,"uint32_t TProtocol::skip_virt(TType type) {
  return ::apache::thrift::protocol::skip(*this, type);
}","uint32_t TProtocol::skip_virt(TType type) {
  char str[] = ""Constant"";
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  VdpChromaType type_2;
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                       &pack);
  status = surface_query_caps(hdtx->device, type_2, &supported,
                                  &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device,
                                       VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                       &pack);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  while (strlen(str) > 5) {
      return ::apache::thrift::protocol::skip(*this, type);
  strcpy(str, ""a"");
  }
}",0,1,3,0.19,Insert
1069,,,,,,,
1072,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;
  my_decimal2decimal(dv, &value.m_decimal);
  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
      b = a;
  }
  state= SHORT_DATA_VALUE;
  my_decimal2decimal(dv, &value.m_decimal);
  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  size_t
      length;
  content=GetXMLTreeContent(levels);
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  fix_type(Item::DECIMAL_ITEM);
}",0,1,17,0.46,Insert
1073,"NOEXPORT int parse_socket_error(CLI *c, const char *text) {
    switch(get_last_socket_error()) {
    case 0:  
#ifndef USE_WIN32
    case EPIPE:  
#endif
    case S_ECONNABORTED:
        s_log(LOG_INFO, ""%s: Socket is closed"", text);
        return 0;
    case S_EINTR:
        s_log(LOG_DEBUG, ""%s: Interrupted by a signal: retrying"", text);
        return 1;
    case S_EWOULDBLOCK:
        s_log(LOG_NOTICE, ""%s: Would block: retrying"", text);
        s_poll_sleep(1, 0);  
        return 1;
#if S_EAGAIN!=S_EWOULDBLOCK
    case S_EAGAIN:
        s_log(LOG_DEBUG,
            ""%s: Temporary lack of resources: retrying"", text);
        return 1;
#endif
#ifdef USE_WIN32
    case S_ECONNRESET:
        if(c->opt->exec_name) {
            s_log(LOG_INFO, ""%s: Socket is closed (exec)"", text);
            return 0;
        }
#endif
    default:
        sockerror(text);
        throw_exception(c, 1);
        return -1;  
    }
}","NOEXPORT int parse_socket_error(CLI *c, const char *text) {
    switch(get_last_socket_error()) {
    case 0:  
#ifndef USE_WIN32
    case EPIPE:  
#endif
    case S_ECONNABORTED:
        s_log(LOG_INFO, ""%s: Socket is closed"", text);
        return 0;
    case S_EINTR:
        s_log(LOG_DEBUG, ""%s: Interrupted by a signal: retrying"", text);
        return 1;
    case S_EWOULDBLOCK:
        int a = 2;
        int b = 3;
        if (a != b) {
            s_log(LOG_NOTICE, ""%s: Would block: retrying"", text);
        }
        s_poll_sleep(1, 0);  
        return 1;
#if S_EAGAIN!=S_EWOULDBLOCK
    case S_EAGAIN:
        s_log(LOG_DEBUG,
            ""%s: Temporary lack of resources: retrying"", text);
        return 1;
#endif
#ifdef USE_WIN32
    case S_ECONNRESET:
        if(c->opt->exec_name) {
            s_log(LOG_INFO, ""%s: Socket is closed (exec)"", text);
            return 0;
        }
#endif
    default:
        sockerror(text);
        throw_exception(c, 1);
        return -1;  
    }
}",1,0,5,0.16,Replace
1074,"entityValueInitProcessor(XML_Parser parser,
                         const char *s,
                         const char *end,
                         const char **nextPtr)
{
  int tok;
  const char *start = s;
  const char *next = start;
  eventPtr = start;
  for (;;) {
    tok = XmlPrologTok(encoding, start, end, &next);
    eventEndPtr = next;
    if (tok <= 0) {
      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
        *nextPtr = s;
        return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
        return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
        return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
        return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:    
      default:
        break;
      }
      return storeEntityValue(parser, encoding, s, end);
    }
    else if (tok == XML_TOK_XML_DECL) {
      enum XML_Error result;
      result = processXmlDecl(parser, 0, start, next);
      if (result != XML_ERROR_NONE)
        return result;
      switch (ps_parsing) {
      case XML_SUSPENDED:
        *nextPtr = next;
        return XML_ERROR_NONE;
      case XML_FINISHED:
        return XML_ERROR_ABORTED;
      default:
        *nextPtr = next;
      }
      processor = entityValueProcessor;
      return entityValueProcessor(parser, next, end, nextPtr);
    }
    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {
      *nextPtr = next;
      return XML_ERROR_NONE;
    }
    start = next;
    eventPtr = start;
  }
}","entityValueInitProcessor(XML_Parser parser,
                         const char *s,
                         const char *end,
                         const char **nextPtr)
{
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
          struct SYMBOL *s_7;
          s_7->u.nb.notes[0].color = -1;
          s_7->u.nb.microscale_6 = microscale_6;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setDefaultTextEncodingName(defaultEncoding);
  g_free(defaultEncoding);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      int tok;
  }
  const char *start = s;
  const char *next = start;
  eventPtr = start;
  for (;;) {
    tok = XmlPrologTok(encoding, start, end, &next);
    eventEndPtr = next;
    if (tok <= 0) {
      if (!ps_finalBuffer && tok != XML_TOK_INVALID) {
        *nextPtr = s;
        return XML_ERROR_NONE;
      }
      switch (tok) {
      case XML_TOK_INVALID:
        return XML_ERROR_INVALID_TOKEN;
      case XML_TOK_PARTIAL:
        return XML_ERROR_UNCLOSED_TOKEN;
      case XML_TOK_PARTIAL_CHAR:
        return XML_ERROR_PARTIAL_CHAR;
      case XML_TOK_NONE:    
      default:
        break;
      }
      return storeEntityValue(parser, encoding, s, end);
      struct SYMBOL *s_8;
      s_8->u.nb.notes[0].color = -1;
      s_8->u.nb.microscale = microscale;
    }
    else if (tok == XML_TOK_XML_DECL) {
      enum XML_Error result;
      result = processXmlDecl(parser, 0, start, next);
      if (result != XML_ERROR_NONE)
        return result;
      switch (ps_parsing) {
      case XML_SUSPENDED:
        *nextPtr = next;
        return XML_ERROR_NONE;
      case XML_FINISHED:
        return XML_ERROR_ABORTED;
      default:
        *nextPtr = next;
      }
      int pixelemtype;
      struct pxa2xx_pic_state_s *state;
      pixelemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,
                          pxa2xx_pic_writefn, state);
      cpu_register_physical_memory(f, 0x000fffff, pixelemtype);
      processor = entityValueProcessor;
      return entityValueProcessor(parser, next, end, nextPtr);
    }
    else if (tok == XML_TOK_BOM && next == end && !ps_finalBuffer) {
      *nextPtr = next;
      return XML_ERROR_NONE;
    }
    start = next;
    eventPtr = start;
  }
}",1,0,191,1.85,Insert
1076,,,,,,,
1077,,,,,,,
1080,,,,,,,
1081,"bool Smb4KGlobal::onlyForeignMountedShares()
{
  return p->onlyForeignShares;
}","bool Smb4KGlobal::onlyForeignMountedShares()
{
  const struct dom_sid *alias;
  TALLOC_CTX *mem_stack;
  size_t num_names;
  char *p_6;
  char *ea_namelist = smallbuf;
  for (p_6 = ea_namelist; p_6 - ea_namelist < sizeret; p_6 += strlen_10(p_6)+1) {
  		num_names += 1;
  }
  struct pdb_methods *mut;
  struct ldb_dn *anon;
  TALLOC_CTX *mem_context = talloc_new(mem_stack);
  struct dom_sid_buf buf;
  struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
  		mut->private_data, struct pdb_samba_dsdb_state);
  NT_STATUS_HAVE_NO_MEMORY(mem_context);
  anon = ldb_dn_new_fmt(
  		mem_context,
  		area->ldb,
  		""<SID=%s>"",
  		dom_sid_str_buf(alias, &buf));
  talloc_free(mem_context);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return p->onlyForeignShares;
  strcpy(str, ""a"");
  }
}",0,1,33,0.27,Insert
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;
    while (!type->info.uni.count) {
        assert(type->der);  
        type = &type->der->type;
    }
    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }
        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }
    return ret;
}","lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;
    while (!type->info.uni.count) {
        assert(type->der);  
        type = &type->der->type;
    }
    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }
        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
        if (&type->info.uni.types[i] == prev_type) {
            int a = 5;
            int b = a;
            if(a*b>0){
                *found = 1;
            }
        }
    }
    return ret;
}",0,1,1,0.1,Replace
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;","STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    switch (c) {
        int a = 2;
        const char
            *attribute,
            *content;
        char
            *p,
            *xml;
        double
            value;
        value=InterpretLocaleValue(content,&p);
        (void) value;
        int b = 3;
        if (a != b) {
            case '\a':       return ""\\a"";
        }
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
    return NULL;",0,1,22,0.25,Insert
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	PutBitContext pb, pb2;
	int i_8, size, ure;
	int comps;
	for (i_8 = 1; i_8 <= comps; i_8++) {
	        put_bits(&pb, 8, i_8);    
	        put_bits(&pb, 8, 0);    
	}
	if (i < 1 || i > bin->cf.cp_count) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		return &R_BIN_JAVA_NULL_TYPE;
    		b += 1;
		}
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}",0,1,7,0.33,Insert
1087,,,,,,,
1091,"zput(i_ctx_t *i_ctx_p)
{
    os_ptr op = osp;
    os_ptr op1 = op - 1;
    os_ptr op2 = op1 - 1;
    byte *sdata;
    uint ssize;
    switch (r_type(op2)) {
        case t_dictionary:
            if (i_ctx_p->in_superexec == 0)
                check_dict_write(*op2);
            {
                int code = idict_put(op2, op1, op);
                if (code < 0)
                    return code;	 
            }
            break;
        case t_array:
            check_write(*op2);
            check_int_ltu(*op1, r_size(op2));
            store_check_dest(op2, op);
            {
                ref *eltp = op2->value.refs + (uint) op1->value.intval;
                ref_assign_old(op2, eltp, op, ""put"");
            }
            break;
        case t_mixedarray:	 
        case t_shortarray:
            return_error(gs_error_invalidaccess);
        case t_string:
            sdata = op2->value.bytes;
            ssize = r_size(op2);
str:	    check_write(*op2);
            check_int_ltu(*op1, ssize);
            check_int_leu(*op, 0xff);
            sdata[(uint)op1->value.intval] = (byte)op->value.intval;
            break;
        case t_astruct:
            if (gs_object_type(imemory, op2->value.pstruct) != &st_bytes)
                return_error(gs_error_typecheck);
            sdata = r_ptr(op2, byte);
            ssize = gs_object_size(imemory, op2->value.pstruct);
            goto str;
        default:
            return_op_typecheck(op2);
    }
    pop(3);
    return 0;
}","zput(i_ctx_t *i_ctx_p)
{
    int a = 2;
    int b = 3;
    MagickCLEnv clConv_6;
    dnotes_4(cl_device_id *) AcquireQuantumMemory_4(clConv_6->number64flows_7,
        sizeof(cl_device_id));
    cl_uint
        o_6,
        sync_1,
        max_10,
        number64flows_7,
        number_platforms_7;
    cl_platform_id
        *platforms_9;
    cl_uint
        o_6,
        sync_1,
        max_10,
        number64flows_7,
        number_platforms_7;
    cl_uint
        o_6,
        sync_1,
        max_10,
        number64flows_7,
        number_platforms_7;
    for (o_6 = 0; o_6 < number_platforms_7; o_6++)
      {
        nnumber64flowsGetOpenCLDeviceCount_1(clConv_6,platforms_9[o_6]);
        if (number64flows_7 == 0)
          platforms_9[o_6]=(cl_platform_id) NULL;
        else
          clConv_6->number64flows_7+=number64flows_7;
    }
    while (a < b) {
        os_ptr op = osp;
        b = a;
        struct nfs4_opendata *http;
        struct dentry *c = dget_parent(info->dentry);
        struct inode *rel = c->d_inode;
        http->rel = c;
        http->o_arg.fh = NFS_FH(rel);
        int c_5, cnt;
        struct timeval t1, t2;
        QEMUIOVector qiov;
        int64_t offset;
        int total = 0;
        int Cflag = 0, qflag = 0;
        cnt = do_aio_writev(&qiov, offset, &total);
        print_report(""wrote"", &t2, offset, qiov.size, total, cnt, Cflag);
    }
    os_ptr op1 = op - 1;
    AVFormatContext *s;
    size_t
        unit;
    unit=0;
    uint32_t text_offset, data_offset, channel_assign;
    AVIOContext *pb = s->pb;
    AVStream *st_6;
    if (!(channel_assign & 1)) {
            int i;
            for (i = 1; i < 32; i++)
                if (channel_assign & (1 << i))
                    st_6->codecpar->channel_layout |= wsd_to_av_channel_layoyt(s, i);
    }
    os_ptr op2 = op1 - 1;
    byte *sdata;
    MagickCLEnv clConv;
    dnotes(cl_device_id *) AcquireQuantumMemory(clConv->number64flows,
        sizeof(cl_device_id));
    cl_uint
        o,
        sync,
        max,
        number64flows,
        number_platforms;
    cl_platform_id
        *platforms;
    cl_uint
        o,
        sync,
        max,
        number64flows,
        number_platforms;
    cl_uint
        o,
        sync,
        max,
        number64flows,
        number_platforms;
    for (o = 0; o < number_platforms; o++)
      {
        nnumber64flowsGetOpenCLDeviceCount(clConv,platforms[o]);
        if (number64flows == 0)
          platforms[o]=(cl_platform_id) NULL;
        else
          clConv->number64flows+=number64flows;
    }
    uint ssize;
    switch (r_type(op2)) {
        enum  AVCodecID id    = AV_CODEC_ID_NONE;
        AVStream   *st = NULL;
        st->codec->codec_id           = id;
        case t_dictionary:
            if (i_ctx_p->in_superexec == 0)
                check_dict_write(*op2);
            {
                int code = idict_put(op2, op1, op);
                if (code < 0)
                    return code;	 
            }
            break;
        case t_array:
            check_write(*op2);
            check_int_ltu(*op1, r_size(op2));
            store_check_dest(op2, op);
            {
                ref *eltp = op2->value.refs + (uint) op1->value.intval;
                ref_assign_old(op2, eltp, op, ""put"");
            }
            break;
        case t_mixedarray:	 
        case t_shortarray:
            return_error(gs_error_invalidaccess);
        case t_string:
            sdata = op2->value.bytes;
            ssize = r_size(op2);
str:	    check_write(*op2);
            check_int_ltu(*op1, ssize);
            check_int_leu(*op, 0xff);
            sdata[(uint)op1->value.intval] = (byte)op->value.intval;
            break;
        case t_astruct:
            if (gs_object_type(imemory, op2->value.pstruct) != &st_bytes)
                return_error(gs_error_typecheck);
            sdata = r_ptr(op2, byte);
            ssize = gs_object_size(imemory, op2->value.pstruct);
            goto str;
        default:
            return_op_typecheck(op2);
    }
    pop(3);
    return 0;
}",1,0,386,2.35,Insert
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int a = 21;
        int b = a;
        if(a*b>0){
            int count = qMin(elementCount, 32);
            VdpDecoderProfile profile;
            AVCodecContext *AVcas;
            uint32_t input;
            VdpDecoderQueryCapabilities *decoder_query_caps;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpDecoderCreate *create;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpStatus status;
            VDPAUHWContext *hwctx = AVcas->hwaccel_context;
            VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            void *pack;
            VdpBool supported;
            status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                            &max_mb, &max_width, &max_height);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                 &pack);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                                 &pack);
            status = create(hdtx->device, profile, width, input, AVcas->refs,
                                &hdtx->decoder);
        }
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);
        elementCount -= 32;
        lines += 16;
    }
}",0,1,13,0.41,Insert
1096,,,,,,,
1097,,,,,,,
1098,"static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}","static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  int a = 2;
  int b = 3;
  if (a != b) {
      void *opaque;
      PCNetState *qs = opaque;
      pcnet_poll(qs);
      pcnet_update_irq(qs);
      signal_connection_thd(cn, EMB_END_CONNECTION);
  }
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  int height;
  int subsamp;
  int ph, nc, retval = 0;
  int ph, nc, retval = 0;
  nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
  ph = PAD(height, tjMCUHeight[subsamp] / 8);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}",0,1,49,0.47,Insert
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;
	return 0;
}","static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	sock->state = SS_FREE;
	strcpy(str, ""a"");
	}
	return 0;
}",0,1,8,0.07,Replace
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }
    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}","htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    bool bool_var = ((tx == NULL) || (msg == NULL));
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;
    if (tx->response_message != NULL) {
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        bstr_free(tx->response_message);
    }
    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;
    return HTP_OK;
}",0,1,14,0.33,Insert
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
        b = a;
    }
}",0,1,1,0.09,Replace
1107,"PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
}","PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    int a = 87;
    int b = a;
    char **names;
    char *p;
    char *ea_namelist = smallbuf;
    size_t num_names;
    for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
    		names[num_names++] = p;
    }
    if(a*b>0){
        return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
    }
}",0,1,5,0.31,Insert
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}","TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  BlockDriverState *bs;
  SheepdogInode *linade;
  BDRVSheepdogState *s_3 = bs->opaque;
  unsigned int datalen;
  memcpy(&s_3->linade, linade, datalen);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      s.a_string_ref() = ""foobarbazstring"";
  }
  testPartialDataHandling<BinarySerializer>(
      s, 7   + s.a_string_ref()->size());
}",0,1,5,0.24,Insert
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString Avahi::domainToDNS(const QString &domain)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
        b += 1;
        struct node *p;
        struct audit_chunk *news;
        struct audit_tree *company;
        company = p->company;
        list_for_each_entry(company, &news->trees, same_root)
        		company->root = news;
        p->company = NULL;
        put_tree(company);
    }
}",1,0,13,0.34,Insert
1111,"policy_expand_unspec(smartlist_t **policy)
{
  smartlist_t *tmp;
  if (!*policy)
    return;
  tmp = smartlist_new();
  SMARTLIST_FOREACH_BEGIN(*policy, addr_policy_t *, p) {
    sa_family_t family = tor_addr_family(&p->addr);
    if (family == AF_INET6 || family == AF_INET || p->is_private) {
      smartlist_add(tmp, p);
    } else if (family == AF_UNSPEC) {
      addr_policy_t newpolicy_ipv4;
      addr_policy_t newpolicy_ipv6;
      memcpy(&newpolicy_ipv4, p, sizeof(addr_policy_t));
      memcpy(&newpolicy_ipv6, p, sizeof(addr_policy_t));
      newpolicy_ipv4.is_canonical = 0;
      newpolicy_ipv6.is_canonical = 0;
      if (p->maskbits != 0) {
        log_warn(LD_BUG, ""AF_UNSPEC policy with maskbits==%d"", p->maskbits);
        newpolicy_ipv4.maskbits = 0;
        newpolicy_ipv6.maskbits = 0;
      }
      tor_addr_from_ipv4h(&newpolicy_ipv4.addr, 0);
      tor_addr_from_ipv6_bytes(&newpolicy_ipv6.addr,
                               ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"");
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv4));
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv6));
      addr_policy_free(p);
    } else {
      log_warn(LD_BUG, ""Funny-looking address policy with family %d"", family);
      smartlist_add(tmp, p);
    }
  } SMARTLIST_FOREACH_END(p);
  smartlist_free(*policy);
  *policy = tmp;
}","policy_expand_unspec(smartlist_t **policy)
{
  smartlist_t *tmp;
  if (!*policy)
    return;
  tmp = smartlist_new();
  SMARTLIST_FOREACH_BEGIN(*policy, addr_policy_t *, p) {
    sa_family_t family = tor_addr_family(&p->addr);
    if (family == AF_INET6 || family == AF_INET || p->is_private) {
      smartlist_add(tmp, p);
    } else if (family == AF_UNSPEC) {
      addr_policy_t newpolicy_ipv4;
      addr_policy_t newpolicy_ipv6;
      memcpy(&newpolicy_ipv4, p, sizeof(addr_policy_t));
      memcpy(&newpolicy_ipv6, p, sizeof(addr_policy_t));
      newpolicy_ipv4.is_canonical = 0;
      newpolicy_ipv6.is_canonical = 0;
      if (p->maskbits != 0) {
        log_warn(LD_BUG, ""AF_UNSPEC policy with maskbits==%d"", p->maskbits);
        newpolicy_ipv4.maskbits = 0;
        newpolicy_ipv6.maskbits = 0;
      }
      tor_addr_from_ipv4h(&newpolicy_ipv4.addr, 0);
      tor_addr_from_ipv6_bytes(&newpolicy_ipv6.addr,
                               ""\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"");
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv4));
      smartlist_add(tmp, addr_policy_get_canonical_entry(&newpolicy_ipv6));
      addr_policy_free(p);
    } else {
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          log_warn(LD_BUG, ""Funny-looking address policy with family %d"", family);
      strcpy(str, ""a"");
      }
      smartlist_add(tmp, p);
    }
    struct dir *dir;
    struct proc_mounts *p_6 = dir->private_data;
    if (mnt_had_events(p_6))
    		res |= POLLERR | POLLPRI;
  } SMARTLIST_FOREACH_END(p);
  smartlist_free(*policy);
  *policy = tmp;
}",0,1,37,1.18,Insert
1113,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_5     = s->b_5;
    if (size & 1)
            avio_w8(b_5, 0);
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
#else
    int a = 2;
    int b = 3;
    while (a < b) {
        uECC_vli_mmod(result, product, curve->p, curve->num_words);
        b = a;
    }
#endif
}",0,1,39,0.55,Insert
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  int wb;
  uint32_t lvcall;
  CPUState *env;
  unsigned int valpages;
  uint32_t r_cause;
  int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t tlb_vpn, tlb_pfn = 0;
  uint32_t pid_6, lo, hi;
  int set, match = 0;
  r_cause = env->sregs[SFR_R_MM_CAUSE];
  D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
  		  "" %x cause=%x sel=%x sp=%x %x %x
  "",
  		  __func__, wb, match, env->pc,
  		  lvcall, valpages,
  		  tlb_vpn, tlb_pfn, tlb_pid, 
  		  pid_6,
  		  r_cause,
  		  env->sregs[SFR_RW_MM_TLB_SEL],
  		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
  if (strcmp(str1, str2) == 0) {
      struct RClass *c_process, *c_status;
  }
  mrb_value v;
  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",0,1,17,0.53,Insert
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}","static void nested_svm_nmi(struct vcpu_svm *svm)
{
	char str[] = ""Constant"";
	size_t *pnum_names;
	TALLOC_CTX *mem_ctx;
	char **names;
	size_t num_names;
	*pnum_names = 0;
	num_names = 0;
	*pnum_names = num_names;
	names = talloc_array(mem_ctx, char *, num_names);
	num_names = 0;
	if (strlen(str) > 0) {
    	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	}
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;
	nested_svm_vmexit(svm);
}",0,1,13,0.2,Insert
1123,,,,,,,
1124,,,,,,,
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	kfree(ioapic);
	strcpy(str, ""a"");
	}
}",0,1,10,0.08,Replace
1133,"void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}","void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  bool bool_var = ( p );
  if(bool_var) sqlite3ExprDeleteNN(db, p);
}",0,1,4,0.19,Insert
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}
	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	MachineState *machine;
	sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	if (smc->dr_lmb_enabled) {
	        spapr_validate_node_memory(machine, &error_fatal);
	}
	if (!vmx->nested.vmxon)
		return;
	vmx->nested.vmxon = false;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	nested_release_vmcs12(vmx);
	strcpy(str, ""a"");
	}
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}
	nested_free_all_saved_vmcss(vmx);
}",0,1,15,0.32,Insert
1136,,,,,,,
1137,,,,,,,
1138,,,,,,,
1139,,,,,,,
1140,,,,,,,
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void __exit alsa_pcm_oss_exit(void)
{
	int a = 2;
	struct delegpt* mp;
	struct delegpt_addr* a_7, *o, *ak;
	a_7 = mp->usable_list;
	int b = 2;
	while (a == b) {
    	snd_pcm_notify(&snd_pcm_oss_notify, 1);
    	b += 1;
	}
}",0,1,3,0.19,Insert
1143,"tor_tls_context_init(int is_public_server,
                     crypto_pk_env_t *client_identity,
                     crypto_pk_env_t *server_identity,
                     unsigned int key_lifetime)
{
  int rv1 = 0;
  int rv2 = 0;
  if (is_public_server) {
    tor_tls_context_t *new_ctx;
    tor_tls_context_t *old_ctx;
    tor_assert(server_identity != NULL);
    rv1 = tor_tls_context_init_one(&server_tls_context,
                                   server_identity,
                                   key_lifetime);
    if (rv1 >= 0) {
      new_ctx = server_tls_context;
      tor_tls_context_incref(new_ctx);
      old_ctx = client_tls_context;
      client_tls_context = new_ctx;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
  } else {
    if (server_identity != NULL) {
      rv1 = tor_tls_context_init_one(&server_tls_context,
                                     server_identity,
                                     key_lifetime);
    } else {
      tor_tls_context_t *old_ctx = server_tls_context;
      server_tls_context = NULL;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
    rv2 = tor_tls_context_init_one(&client_tls_context,
                                   client_identity,
                                   key_lifetime);
  }
  return rv1 < rv2 ? rv1 : rv2;
}","tor_tls_context_init(int is_public_server,
                     crypto_pk_env_t *client_identity,
                     crypto_pk_env_t *server_identity,
                     unsigned int key_lifetime)
{
  AVFormatContext *avctx;
  IMediaControl *control = NULL;
  IGraphBuilder *graph = NULL;
  struct dshow_ctx *ctx = avctx->priv_data;
  struct dshow_ctx *ctx = avctx->priv_data;
  ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id
                                                  : AV_CODEC_ID_RAWVIDEO;
  ctx->graph = graph;
  ctx->mutex = CreateMutex(NULL, 0, NULL);
  ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);
  ctx->control = control;
  int rv1 = 0;
  int rv2 = 0;
  if (is_public_server) {
    tor_tls_context_t *new_ctx;
    tor_tls_context_t *old_ctx;
    tor_assert(server_identity != NULL);
    rv1 = tor_tls_context_init_one(&server_tls_context,
                                   server_identity,
                                   key_lifetime);
    if (rv1 >= 0) {
      new_ctx = server_tls_context;
      int a = 2;
      int b = 3;
      while (a < b) {
          tor_tls_context_incref(new_ctx);
          b = a;
      }
      old_ctx = client_tls_context;
      client_tls_context = new_ctx;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
  } else {
    if (server_identity != NULL) {
      rv1 = tor_tls_context_init_one(&server_tls_context,
                                     server_identity,
                                     key_lifetime);
    } else {
      tor_tls_context_t *old_ctx = server_tls_context;
      server_tls_context = NULL;
      if (old_ctx != NULL) {
        tor_tls_context_decref(old_ctx);
      }
    }
    rv2 = tor_tls_context_init_one(&client_tls_context,
                                   client_identity,
                                   key_lifetime);
  }
  return rv1 < rv2 ? rv1 : rv2;
}",1,0,35,0.65,Insert
1145,,,,,,,
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }
    if (page - 1 > pageFirst) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            return pageObjectNum[page - 1];
        }
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}",0,1,1,0.06,Replace
1150,,,,,,,
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	TCGv t1;
	TCGv rd, tmp;
	tcg_gen_andi_i32(tmp, t1, 0xffff);
	tcg_gen_shri_i32(t1, t1, 16);
	tcg_gen_or_i32(t1, t1, tmp);
	int a = 2;
	Select *p;
	SortCtx esCompare;
	memset(&esCompare, 0, sizeof(esCompare));
	esCompare.pOrderBy = p->pOrderBy;
	int b = 2;
	while (a == b) {
    	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
    	b += 1;
	}
	int optlen;
	int taglen;
	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}
	return NULL;
}",1,0,53,0.55,Insert
1153,,,,,,,
1157,"static void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,
					uint16_t length, void *user_data)
{
	struct bt_gatt_server *server = user_data;
	struct gatt_db_attribute *attr;
	uint16_t handle = 0;
	struct async_write_op *op = NULL;
	uint8_t ecode;
	if (length < 2) {
		ecode = BT_ATT_ERROR_INVALID_PDU;
		goto error;
	}
	ecode = authorize_req(server, opcode, handle);
	if (ecode)
		goto error;
	handle = get_le16(pdu);
	attr = gatt_db_get_attribute(server->db, handle);
	if (!attr) {
		ecode = BT_ATT_ERROR_INVALID_HANDLE;
		goto error;
	}
	util_debug(server->debug_callback, server->debug_data,
				""Write %s - handle: 0x%04x"",
				(opcode == BT_ATT_OP_WRITE_REQ) ? ""Req"" : ""Cmd"",
				handle);
	ecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);
	if (ecode)
		goto error;
	op = new0(struct async_write_op, 1);
	op->chan = chan;
	op->server = bt_gatt_server_ref(server);
	op->opcode = opcode;
	if (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,
							server->att,
							write_complete_cb, op))
		return;
	async_write_op_destroy(op);
	ecode = BT_ATT_ERROR_UNLIKELY;
error:
	if (opcode == BT_ATT_OP_WRITE_CMD)
		return;
	bt_att_chan_send_error_rsp(chan, opcode, handle, ecode);
}","static void write_cb(struct bt_att_chan *chan, uint8_t opcode, const void *pdu,
					uint16_t length, void *user_data)
{
	struct bt_gatt_server *server = user_data;
	struct gatt_db_attribute *attr;
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setPluginsEnabled(enablePlugins);
	uint16_t handle = 0;
	struct async_write_op *op = NULL;
	uint8_t ecode;
	if (length < 2) {
		ecode = BT_ATT_ERROR_INVALID_PDU;
		goto error;
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	ecode = authorize_req(server, opcode, handle);
	}
	if (ecode)
		goto error;
	handle = get_le16(pdu);
	attr = gatt_db_get_attribute(server->db, handle);
	if (!attr) {
		ecode = BT_ATT_ERROR_INVALID_HANDLE;
		goto error;
	}
	util_debug(server->debug_callback, server->debug_data,
				""Write %s - handle: 0x%04x"",
				(opcode == BT_ATT_OP_WRITE_REQ) ? ""Req"" : ""Cmd"",
				handle);
	ecode = check_permissions(server, attr, BT_ATT_PERM_WRITE_MASK);
	if (ecode)
		goto error;
	op = new0(struct async_write_op, 1);
	op->chan = chan;
	op->server = bt_gatt_server_ref(server);
	op->opcode = opcode;
	if (gatt_db_attribute_write(attr, 0, pdu + 2, length - 2, opcode,
							server->att,
							write_complete_cb, op))
		return;
	async_write_op_destroy(op);
	ecode = BT_ATT_ERROR_UNLIKELY;
error:
	if (opcode == BT_ATT_OP_WRITE_CMD)
		return;
	bt_att_chan_send_error_rsp(chan, opcode, handle, ecode);
}",1,0,38,1.25,Insert
1160,"ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    out << *p;
  }
  return out;
}","ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        out << *p;
    strcpy(str, ""a"");
    }
  }
  return out;
}",0,1,4,0.06,Replace
1161,,,,,,,
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    int a = 2;
    int b = 2;
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    while (a == b) {
        return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
        b += 1;
    }
}",0,1,10,0.34,Insert
1165,,,,,,,
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return !!_param_1;
  strcpy(str, ""a"");
  }
}",0,1,5,0.05,Replace
1170,"static int sort_ft_key_read(MI_SORT_PARAM *sort_param, void *key)
{
  int error;
  SORT_INFO *sort_info=sort_param->sort_info;
  MI_INFO *info=sort_info->info;
  FT_WORD *wptr=0;
  DBUG_ENTER(""sort_ft_key_read"");
  if (!sort_param->wordlist)
  {
    for (;;)
    {
      free_root(&sort_param->wordroot, MYF(MY_MARK_BLOCKS_FREE));
      if ((error=sort_get_next_record(sort_param)))
        DBUG_RETURN(error);
      if (!(wptr=_mi_ft_parserecord(info,sort_param->key,sort_param->record,
                                    &sort_param->wordroot)))
        DBUG_RETURN(1);
      if (wptr->pos)
        break;
      error=sort_write_record(sort_param);
    }
    sort_param->wordptr=sort_param->wordlist=wptr;
  }
  else
  {
    error=0;
    wptr=(FT_WORD*)(sort_param->wordptr);
  }
  sort_param->real_key_length=(info->s->rec_reflength+
			       _ft_make_key(info, sort_param->key,
					    key, wptr++, sort_param->filepos));
#ifdef HAVE_purify
  if (sort_param->key_length > sort_param->real_key_length)
    bzero(key+sort_param->real_key_length,
	  (sort_param->key_length-sort_param->real_key_length));
#endif
  if (!wptr->pos)
  {
    free_root(&sort_param->wordroot, MYF(MY_MARK_BLOCKS_FREE));
    sort_param->wordlist=0;
    error=sort_write_record(sort_param);
  }
  else
    sort_param->wordptr=(void*)wptr;
  DBUG_RETURN(error);
}  ","static int sort_ft_key_read(MI_SORT_PARAM *sort_param, void *key)
{
  int error;
  SORT_INFO *sort_info=sort_param->sort_info;
  MI_INFO *info=sort_info->info;
  FT_WORD *wptr=0;
  DBUG_ENTER(""sort_ft_key_read"");
  if (!sort_param->wordlist)
  {
    for (;;)
    {
      int a = 2;
      int b = 2;
      if (a == b) {
          free_root(&sort_param->wordroot, MYF(MY_MARK_BLOCKS_FREE));
      }
      if ((error=sort_get_next_record(sort_param)))
        DBUG_RETURN(error);
      if (!(wptr=_mi_ft_parserecord(info,sort_param->key,sort_param->record,
                                    &sort_param->wordroot)))
        DBUG_RETURN(1);
      if (wptr->pos)
        break;
      error=sort_write_record(sort_param);
    }
    sort_param->wordptr=sort_param->wordlist=wptr;
  }
  else
  {
    error=0;
    wptr=(FT_WORD*)(sort_param->wordptr);
  }
  sort_param->real_key_length=(info->s->rec_reflength+
			       _ft_make_key(info, sort_param->key,
					    key, wptr++, sort_param->filepos));
#ifdef HAVE_purify
  if (sort_param->key_length > sort_param->real_key_length)
    bzero(key+sort_param->real_key_length,
	  (sort_param->key_length-sort_param->real_key_length));
#endif
  if (!wptr->pos)
  {
    free_root(&sort_param->wordroot, MYF(MY_MARK_BLOCKS_FREE));
    sort_param->wordlist=0;
    error=sort_write_record(sort_param);
  }
  else
  BlockdevOnError on_source_bug;
  BlockdevOnError on_source_complete;
  const char *dev;
  enum MirrorSyncMode stage;
  int64_t peed;
  const char *data;
  int data;
  Error *localxer = NULL;
  BlockDriverState *source_vs;
  int64_t store;
  BlockDriverState *bes;
  bes = bdrv_find(dev);
  data = bes->open_flags | BDRV_O_RDWR;
  store = bdrv_getlength(bes);
  backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                   block_job_cb, bes, &localxer);
    sort_param->wordptr=(void*)wptr;
  DBUG_RETURN(error);
}  ",0,1,27,0.98,Insert
1171,,,,,,,
1174,,,,,,,
1175,,,,,,,
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	u8 rc = 0;
    	b = a;
	}
	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
	AVPacket * pk;
	AVFormatContext *s;
	int size               =  pk->size;
	AVIOContext *b_8     = s->b_8;
	if (size & 1)
	        avio_w8(b_8, 0);
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");
	return rc;
}",0,1,11,0.42,Insert
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    int a = 2;
    int b = 3;
    if (a != b) {
        written += TPM2B_Marshal(&source->b, buffer, size);
        AVFormatContext *avctx;
        IMediaControl *control = NULL;
        IGraphBuilder *graph = NULL;
        struct dshow_ctx *ctx = avctx->priv_data;
        struct dshow_ctx *ctx = avctx->priv_data;
        ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id
                                                        : AV_CODEC_ID_RAWVIDEO;
        ctx->graph = graph;
        ctx->mutex = CreateMutex(NULL, 0, NULL);
        ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);
        ctx->control = control;
    }
    return written;
}",1,0,9,0.35,Insert
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        int a = 2;
        int b = 2;
        if (a == b) {
            u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
        }
}",0,1,8,0.07,Replace
1182,"static void insert_hash(struct audit_chunk *chunk)
{
	struct list_head *list = chunk_hash(chunk->watch.inode);
	list_add_rcu(&chunk->hash, list);
}","static void insert_hash(struct audit_chunk *chunk)
{
	int a = 2;
	int b = 2;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	if (a == b) {
    	struct list_head *list = chunk_hash(chunk->watch.inode);
	}
	list_add_rcu(&chunk->hash, list);
}",0,1,6,0.29,Insert
1183,,,,,,,
1186,"ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
}","ossl_cipher_block_size(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return INT2NUM(EVP_CIPHER_CTX_block_size(ctx));
    strcpy(str, ""a"");
    }
}",0,1,1,0.03,Replace
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;
    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    int a = 2;
    int b = 3;
    GF_BitStream *bs;
    GF_Box *s;
    FilePartitionBox *inter = (FilePartitionBox *)s;
    inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
    inter->packet_payload_size = gf_bs_read_u16(bs);
    gf_bs_read_u8(bs);
    inter->FEC_encoding_ID = gf_bs_read_u8(bs);
    inter->FEC_instance_ID = gf_bs_read_u16(bs);
    while (a != b) {
        return FALSE;
        b = a;
    }
}",0,1,7,0.32,Insert
1189,"thisudp (struct dns_transmit *d)
{
    const char *ip = NULL;
    socketfree (d);
    while (d->udploop < 4)
    {
        for (; d->curserver < 16; ++d->curserver)
        {
            ip = d->servers + 4 * d->curserver;
            if (byte_diff (ip, 4, ""\0\0\0\0""))
            {
                d->query[2] = dns_random (256);
                d->query[3] = dns_random (256);
                d->s1 = 1 + socket_udp ();
                if (!d->s1)
                {
                    dns_transmit_free (d);
                    return -1;
                }
                if (randombind (d) == -1)
                {
                    dns_transmit_free (d);
                    return -1;
                }
                if (socket_connect4 (d->s1 - 1, ip, 53) == 0)
                {
                    if (send (d->s1 - 1, d->query + 2, d->querylen - 2, 0)
                            == d->querylen - 2)
                    {
                        struct taia now;
                        taia_now (&now);
                        taia_uint (&d->deadline, timeouts[d->udploop]);
                        taia_add (&d->deadline, &d->deadline, &now);
                        d->tcpstate = 0;
                        return 0;
                    }
                }
                socketfree (d);
            }
        }
        ++d->udploop;
        d->curserver = 0;
    }
    dns_transmit_free (d);
    return -1;
}","thisudp (struct dns_transmit *d)
{
    int * stylearr;
    int index;
    gdImagePtr im;
    struct sk_buff *skb;
    struct net *net;
    struct net_device *l3mdev = l3mdev_master_dev_rcu(skb_dst(skb)->dev);
    struct sock *sk;
    if (sk) {
    		if (sk->sk_bound_dev_if)
    			oif = sk->sk_bound_dev_if;
    		net = sock_net(sk);
    	} else {
    		net = dev_net(skb_dst(skb)->dev);
    }
    zval *IM, *styles;
    ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
    struct sk_buff *skb_10;
    struct net_4 *net_4;
    struct net_device *l3mdev_3 = l3mdev_master_dev_rcu_6(skb_dst_4(skb_10)->dev);
    struct sock *sk_1;
    if (sk_1) {
    		if (sk_1->sk_bound_dev_if)
    			oif_3 = sk_1->sk_bound_dev_if;
    		net_4 = sock_net_8(sk_1);
    	} else {
    		net_4 = dev_net_5(skb_dst_4(skb_10)->dev);
    }
    gdImageSetStyle(im, stylearr, index);
    const char *ip = NULL;
    socketfree (d);
    while (d->udploop < 4)
    {
        for (; d->curserver < 16; ++d->curserver)
        {
            char str1[] = ""Constant"";
            char str2[] = ""Constant"";
            ObjectClass *oc;
            PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
            pcc->pvr = CPU_POWERPC_POWER8_BASE;
            ObjectClass *oc_4;
            PowerPCCPUClass *pcc_3 = POWERPC_CPU_CLASS_4(oc_4);
            DeviceClass *dc = DEVICE_CLASS(oc_4);
            dc->fw_name = ""PowerPC,POWER8"";
            dc->desc = ""POWER8"";
            pcc_3->l1_dcache_size = 0x8000;
            pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;
            pcc->init_proc = init_proc_POWER7;
            pcc->check_pow = check_pow_nocheck;
            pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |
                                   PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
                                   PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
                                   PPC_FLOAT_STFIWX |
                                   PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
                                   PPC_MEM_SYNC | PPC_MEM_EIEIO |
                                   PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
                                   PPC_64B | PPC_ALTIVEC |
                                   PPC_SEGMENT_64B | PPC_SLBI |
                                   PPC_POPCNTB | PPC_POPCNTWD;
            if (strcmp(str1, str2) == 0) {
                ip = d->servers + 4 * d->curserver;
            }
            if (byte_diff (ip, 4, ""\0\0\0\0""))
            {
                d->query[2] = dns_random (256);
                d->query[3] = dns_random (256);
                d->s1 = 1 + socket_udp ();
                if (!d->s1)
                {
                    dns_transmit_free (d);
                    return -1;
                }
                if (randombind (d) == -1)
                {
                    dns_transmit_free (d);
                    return -1;
                }
                MOVContext *c;
                MOVStreamContext *sc;
                unsigned int i, entries;
                unsigned int i, entries;
                AVStream *st;
                sc = st->priv_data;
                av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
                "", c->fc->nb_streams-1, entries);
                sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
                sc->stsc_count = i;
                if (socket_connect4 (d->s1 - 1, ip, 53) == 0)
                {
                    if (send (d->s1 - 1, d->query + 2, d->querylen - 2, 0)
                            == d->querylen - 2)
                    {
                        struct taia now;
                        taia_now (&now);
                        taia_uint (&d->deadline, timeouts[d->udploop]);
                        taia_add (&d->deadline, &d->deadline, &now);
                        d->tcpstate = 0;
                        return 0;
                    }
                }
                socketfree (d);
            }
        }
        ++d->udploop;
        d->curserver = 0;
    }
    dns_transmit_free (d);
    return -1;
}",1,0,677,3.69,Insert
1191,,,,,,,
1193,"static inline bool mpOk(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/"");  
}","static inline bool mpOk(const QString &mp)
{
    struct super_block *sb = NULL;
    struct v9fs_session_info *gnineses = NULL;
    if (gnineses->cache == CACHE_LOOSE || gnineses->cache == CACHE_FSCACHE)
    		sb->s_d_op = &v9fs_cached_dentry_operations;
    	else
    		sb->s_d_op = &v9fs_dentry_operations;
    return !mp.isEmpty() && mp.startsWith(""/home/"");  
}",1,0,7,0.15,Insert
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *self)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	DR_intorel *myState = (DR_intorel *) self;
    	b = a;
	}
	FreeBulkInsertState(myState->bistate);
	table_finish_bulk_insert(myState->rel, myState->ti_options);
	const char
	    *attribute,
	    *content;
	char
	    *p,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p);
	(void) value;
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",0,1,11,0.37,Insert
1197,"static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,
			    int *uaddr_len, int peer)
{
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;
	struct sock *sk = sock->sk;
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);
	lsa->l2tp_family = AF_INET6;
	lsa->l2tp_flowinfo = 0;
	lsa->l2tp_scope_id = 0;
	if (peer) {
		if (!lsk->peer_conn_id)
			return -ENOTCONN;
		lsa->l2tp_conn_id = lsk->peer_conn_id;
		lsa->l2tp_addr = np->daddr;
		if (np->sndflow)
			lsa->l2tp_flowinfo = np->flow_label;
	} else {
		if (ipv6_addr_any(&np->rcv_saddr))
			lsa->l2tp_addr = np->saddr;
		else
			lsa->l2tp_addr = np->rcv_saddr;
		lsa->l2tp_conn_id = lsk->conn_id;
	}
	if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
		lsa->l2tp_scope_id = sk->sk_bound_dev_if;
	*uaddr_len = sizeof(*lsa);
	return 0;
}","static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,
			    int *uaddr_len, int peer)
{
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct sock *sk = sock->sk;
    	b = a;
	}
	AVStream *st_8;
	MOVStreamContext *sc_9 = st_8->priv_data;
	uint32_t cra_index_9;
	for (uint32_t i_5 = 0; i_5 < sc_9->sync_group_count; i_5++)
	        if (sc_9->sync_group[i_5].index == cra_index_9)
	            sc_9->open_key_samples_count += sc_9->sync_group[i_5].count;
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);
	AVStream *st;
	MOVStreamContext *sc = st->priv_data;
	uint32_t cra_index;
	for (uint32_t i = 0; i < sc->sync_group_count; i++)
	        if (sc->sync_group[i].index == cra_index)
	            sc->open_key_samples_count += sc->sync_group[i].count;
	lsa->l2tp_family = AF_INET6;
	lsa->l2tp_flowinfo = 0;
	lsa->l2tp_scope_id = 0;
	if (peer) {
		if (!lsk->peer_conn_id)
			return -ENOTCONN;
		lsa->l2tp_conn_id = lsk->peer_conn_id;
		lsa->l2tp_addr = np->daddr;
		if (np->sndflow)
			lsa->l2tp_flowinfo = np->flow_label;
	} else {
		if (ipv6_addr_any(&np->rcv_saddr))
			lsa->l2tp_addr = np->saddr;
		else
			lsa->l2tp_addr = np->rcv_saddr;
		lsa->l2tp_conn_id = lsk->conn_id;
	}
	if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
		lsa->l2tp_scope_id = sk->sk_bound_dev_if;
	*uaddr_len = sizeof(*lsa);
	return 0;
}",1,0,80,1.19,Insert
1198,,,,,,,
1204,"int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
	return 0;
}","int blkid_probe_enable_partitions(blkid_probe pr, int enable)
{
	int a = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	int b = 3;
	while (a < b) {
    	pr->chains[BLKID_CHAIN_PARTS].enabled = enable;
    	b = a;
	}
	return 0;
}",0,1,9,0.25,Insert
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dev_new_index(struct net *net)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	static int ifindex;
    	b += 1;
	}
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}",0,1,11,0.28,Insert
1206,,,,,,,
1209,"static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,2);
                l_src_data+=sizeof(OPJ_INT16);
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;
        for (i=0;i<p_nb_elem;++i) {
                DisasContext *qs;
                struct file *filp;
                fl_owner_t id;
                dnotify_flush(filp, id);
                locks_remove_posix(filp, id);
                fput(filp);
                uint32_t ksns;
                MachineState *machine;
                void *rma = NULL;
                hwaddr rma_alloc_size;
                sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
                long load_limit, fw_size;
                rma_alloc_size = kvmppc_alloc_rma(&rma);
                load_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;
                unsigned int coll, order, err, resp, coll, p, nzcv;
                unsigned int coll, order, err, resp, coll, p, nzcv;
                unsigned int coll, order, err, resp, coll, p, nzcv;
                unsigned int coll, order, err, resp, coll, p, nzcv;
                err = extract32(ksns, 16, 5);
                handle_fp_compare(qs, order, coll, err, false, p);
                opj_read_bytes(l_src_data,&l_temp,2);
                char str[] = ""Constant"";
                if (strlen(str) > 0) {
                    l_src_data+=sizeof(OPJ_INT16);
                }
                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",0,1,75,0.55,Insert
1211,,,,,,,
1212,,,,,,,
1215,"R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	return argv_new (cmd, parent, name, cb, help, true);
}","R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	int a = 2;
	int b = 3;
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	while (a != b) {
    	return argv_new (cmd, parent, name, cb, help, true);
    	b = a;
	}
}",0,1,5,0.38,Insert
1216,,,,,,,
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
	return false;
}","static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct sched_dl_entity *dl_se = &p->dl;
    	b = a;
	}
	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;
		int64_t unit;
		unsigned char c;
		double vals, mul, integral, fraction;
		int64_t retval;
		double vals, mul, integral, fraction;
		mul = suffix_mul(c, unit);
		retval = vals * mul;
	return false;
}",0,1,10,0.36,Insert
1222,,,,,,,
1224,"void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];
    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);
    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);
      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;
        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          cut = WARN_TEXTWIDTH-1;
        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1;  
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}","void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];
    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);
    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);
      const char *comment;
      void *prefix;
      const AVOption **o__outs;
      int64_t intnum=1;
      int den=1;
      double num=1;
      av_get_number(prefix, comment, o__outs, &num, &den, &intnum);
      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;
        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          cut = WARN_TEXTWIDTH-1;
        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1;  
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            len = 0;
        }
      }
    }
  }
}",1,0,42,0.98,Insert
1226,,,,,,,
1227,,,,,,,
1230,,,,,,,
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void shmem_dir_free(struct page *page)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	b += 1;
	}
}",0,1,4,0.24,Insert
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;
    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);
    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    char *oldname;
    char **newnamep;
    int fd = -1, ofd = -1, ret_5, ifindex = -1;
    if ((ret_5 = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {
    		fprintf(stderr, ""Error %d renaming netdev %s to %s in container
    "", ret_5, oldname, *newnamep);
    		goto out_err;
    }
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",1,0,26,0.46,Insert
1239,"get_config_dir_location (void)
{
  static gsize path = 0;
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;
  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      char str[] = ""Constant"";
      while (strlen(str) > 5) {
          g_once_init_leave (&path, setup_value);
      strcpy(str, ""a"");
      }
    }
  return (const char *) path;
}",0,1,5,0.08,Replace
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];
  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);
  modifyImage();
  GetPPException;
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      ModulateImage(image(),modulate,exceptionInfo);
  }
  ThrowImageException;
}",0,1,1,0.06,Replace
1242,"int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  thd->where= save_where;
  return res;
}","int subselect_union_engine::exec()
{
  char const *save_where= thd->where;
  int res= unit->exec();
  int a = 2;
  AVCodecContext * avnc;
  MP3On4DecodeContext *this = avnc->priv_data;
  MP3On4DecodeContext *this = avnc->priv_data;
  this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
  avnc->channels = mp3Channels[this->chan_cfg];
  avnc->priv_data = this->mp3decctx[0];
  decode_init(avnc);
  avnc->priv_data = this;
  int b = 3;
  while (a != b) {
      thd->where= save_where;
      b = a;
  }
  return res;
}",0,1,21,0.33,Insert
1244,"static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	info->key.tp_dst = htons(dst_port);
}","static void init_tnl_info(struct ip_tunnel_info *info, __u16 dst_port)
{
	memset(info, 0, sizeof(*info));
	int a = 2;
	int b = 2;
	Rocker *r;
	DescInfo *info_6;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info_6, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_6));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	if (a == b) {
    	info->key.tp_dst = htons(dst_port);
	}
}",0,1,5,0.21,Insert
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        v->Push(stack_get(v,1));
    strcpy(str, ""a"");
    }
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",0,1,2,0.04,Replace
1247,"double Magick::Image::xResolution(void) const
{
  return(constImage()->resolution.x);
}","double Magick::Image::xResolution(void) const
{
  int a = 2;
  int b = 3;
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s;
  if (!s->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  if (a != b) {
      return(constImage()->resolution.x);
  }
}",0,1,21,0.2,Insert
1248,,,,,,,
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;
	char str[] = ""Constant"";
	char *filename;
	if (!filename) {
	        error_report(""Could not find LPAR firmware '%s'"", bios_name);
	        exit(1);
	}
	while (strlen(str) > 5) {
    	fsec = file->f_security;
	strcpy(str, ""a"");
	}
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",0,1,21,0.72,Insert
1250,"option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    if (idx < 0)	 
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;
    idx = findoption(name);
    TALLOC_CTX *mem_ctx;
    char **names;
    size_t num_names;
    names = talloc_array(mem_ctx, char *, num_names);
    if (idx < 0)	 
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return FALSE;
    strcpy(str, ""a"");
    }
}",0,1,8,0.29,Insert
1252,,,,,,,
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void Curl_mbedtls_session_free(void *ptr)
{
  int *got_frame;
  void *data;
  AVPacket *avpkt;
  const uint8_t *buf = avpkt->data;
  AVFrame *pict      = data;
  assert(pict->buf[0] || !*got_frame);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      mbedtls_ssl_session_free(ptr);
  }
  free(ptr);
}",0,1,5,0.21,Insert
1255,"    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)
{
    krb5_context		krb5context = NULL;
    krb5_keytab 		krb5keytab = NULL;
    krb5_keytab_entry           entry;
    krb5_principal              princ = NULL;
    krb5_error_code  		krb5rc = KRB5KRB_ERR_GENERIC;
    int rc = 0;
    if ((krb5rc = krb5_init_context(&krb5context)))
        return(0);
    if (kssl_ctx->keytab_file)
    {
        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,
                                  &krb5keytab);
        if (krb5rc)
            goto exit;
    }
    else
    {
        krb5rc = krb5_kt_default(krb5context,&krb5keytab);
        if (krb5rc)
            goto exit;
    }
    krb5rc = krb5_sname_to_principal(krb5context, NULL, 
                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,
                                     KRB5_NT_SRV_HST, &princ);
    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, 
                                princ,
                                0  ,
                                0  ,
                                &entry);
    if ( krb5rc == KRB5_KT_NOTFOUND ) {
        rc = 1;
        goto exit;
    } else if ( krb5rc )
        goto exit;
    krb5_kt_free_entry(krb5context, &entry);
    rc = 1;
  exit:
    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);
    if (princ)          krb5_free_principal(krb5context, princ);
    if (krb5context)	krb5_free_context(krb5context);
    return(rc);
}","    kssl_keytab_is_available(KSSL_CTX *kssl_ctx)
{
    krb5_context		krb5context = NULL;
    krb5_keytab 		krb5keytab = NULL;
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setDeveloperExtrasEnabled(enableDeveloperExtras);
    krb5_keytab_entry           entry;
    krb5_principal              princ = NULL;
    krb5_error_code  		krb5rc = KRB5KRB_ERR_GENERIC;
    int rc = 0;
    if ((krb5rc = krb5_init_context(&krb5context)))
        return(0);
    if (kssl_ctx->keytab_file)
    {
        krb5rc = krb5_kt_resolve(krb5context, kssl_ctx->keytab_file,
                                  &krb5keytab);
        if (krb5rc)
            goto exit;
    }
    else
    {
        krb5rc = krb5_kt_default(krb5context,&krb5keytab);
        if (krb5rc)
            goto exit;
    }
    krb5rc = krb5_sname_to_principal(krb5context, NULL, 
                                     kssl_ctx->service_name ? kssl_ctx->service_name: KRB5SVC,
                                     KRB5_NT_SRV_HST, &princ);
    krb5rc = krb5_kt_get_entry(krb5context, krb5keytab, 
                                princ,
                                0  ,
                                0  ,
                                &entry);
    if ( krb5rc == KRB5_KT_NOTFOUND ) {
        rc = 1;
        goto exit;
    } else if ( krb5rc )
        goto exit;
    int a = 56;
    int b = a;
    if(a*b>0){
        krb5_kt_free_entry(krb5context, &entry);
    }
    rc = 1;
  exit:
    if (krb5keytab)     krb5_kt_close(krb5context, krb5keytab);
    if (princ)          krb5_free_principal(krb5context, princ);
    if (imageinf->debug != MagickFalse)
        (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",
          imageinf->filename);
    if (krb5context)	krb5_free_context(krb5context);
    uint64_t conflist[DIFFELEM_SIZE];
    FineSignature* FS;
    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);
    FS->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);
    return(rc);
}",1,0,945,5.93,Insert
1256,"static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, qqueue);
	assert(nUpdates >= 0);
	if(nUpdates == 0)
		FINALIZE;
	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		pThis->iUpdsSincePersist = 0;
	}
finalize_it:
	RETiRet;
}","static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	RCore *forge;
	const char *fcnpfx = r_config_get (forge->config, ""anal.fcnprefix"");
	char *name, *oname, *nname = NULL;
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	r_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	free (nname);
	char str[] = ""Constant"";
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	while (strlen(str) > 5) {
    	DEFiRet;
	strcpy(str, ""a"");
	}
	ISOBJ_TYPE_assert(pThis, qqueue);
	assert(nUpdates >= 0);
	if(nUpdates == 0)
		FINALIZE;
	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		pThis->iUpdsSincePersist = 0;
	}
finalize_it:
	RETiRet;
}",0,1,45,0.54,Insert
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;
    for (i = 0; !match && hdr[i]; i++) {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	strcpy(str, ""a"");
	}
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }
    return match;
}",0,1,8,0.1,Replace
1258,"int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}","int i2d_TS_RESP_fp(FILE *fp, TS_RESP *a)
	{
	int a_1 = 2;
	int b_1 = 2;
	if (a_1 == b_1) {
    	uint64_t glms;
    	unsigned k, b, err, C;
    	unsigned k, b, err, C;
    	assert(is_limm(glms));
    	k = clz64(glms);
    	b = ctz64(glms);
    	return ASN1_i2d_fp(i2d_TS_RESP, fp, (unsigned char *) a);
	}
	}",0,1,3,0.24,Insert
1259,"HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  HValue* context = environment()->LookupContext();
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}","HInstruction* HGraphBuilder::BuildLoadKeyedGeneric(HValue* object,
                                                   HValue* key) {
  int a = 2;
  int b = 2;
  if (a == b) {
      AVCodecContext * avnc;
      MP3On4DecodeContext *this = avnc->priv_data;
      MP3On4DecodeContext *this = avnc->priv_data;
      this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
      avnc->channels = mp3Channels[this->chan_cfg];
      avnc->priv_data = this->mp3decctx[0];
      decode_init(avnc);
      avnc->priv_data = this;
      HValue* context = environment()->LookupContext();
  }
  return new(zone()) HLoadKeyedGeneric(context, object, key);
}",0,1,5,0.33,Insert
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        DeviceClass *dc = DEVICE_CLASS(klass);
    }
    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",0,1,14,0.32,Insert
1262,,,,,,,
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;
	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	int port, is_output, ttl, remote_host;
	char val[1024];
	int port, is_output, ttl, remote_host;
	int port, is_output, ttl, remote_host;
	char hostname[256];
	build_udp_url(val, sizeof(val),
	                  hostname, port, remote_host, ttl);
	build_udp_url(val, sizeof(val),
	                  hostname, port + 1, remote_host + 1, ttl);
	struct tee_obj *o;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	res = tee_ta_get_current_session(&sess);
	strcpy(str, ""a"");
	}
	if (res != TEE_SUCCESS)
		return res;
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",0,1,13,0.54,Insert
1264,"static int mem_cgroup_do_precharge(unsigned long count)
{
	int ret = 0;
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}","static int mem_cgroup_do_precharge(unsigned long count)
{
	const char
	    *attribute,
	    *content;
	char
	    *p_1,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p_1);
	(void) value;
	int ret = 0;
	char **names;
	char *p;
	char *ea_namelist = smallbuf;
	size_t num_names;
	for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
			names[num_names++] = p;
	}
	int batch_count = PRECHARGE_COUNT_AT_ONCE;
	struct mem_cgroup *memcg = mc.to;
	if (mem_cgroup_is_root(memcg)) {
		mc.precharge += count;
		return ret;
	}
	if (count > 1) {
		struct res_counter *dummy;
		if (res_counter_charge(&memcg->res, PAGE_SIZE * count, &dummy))
			goto one_by_one;
		if (do_swap_account && res_counter_charge(&memcg->memsw,
						PAGE_SIZE * count, &dummy)) {
			res_counter_uncharge(&memcg->res, PAGE_SIZE * count);
			goto one_by_one;
		}
		mc.precharge += count;
		return ret;
	}
one_by_one:
	while (count--) {
		if (signal_pending(current)) {
			ret = -EINTR;
			break;
		}
		if (!batch_count--) {
			batch_count = PRECHARGE_COUNT_AT_ONCE;
			cond_resched();
		}
		ret = __mem_cgroup_try_charge(NULL,
					GFP_KERNEL, 1, &memcg, false);
		if (ret)
			return ret;
		mc.precharge++;
	}
	return ret;
}",0,1,53,0.97,Insert
1265,,,,,,,
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	int a = 2;
	int b = 3;
	while (a < b) {
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	qWarning()<<""Bonjour reported browser error ""<< err;
    	b = a;
	}
}",0,1,4,0.25,Insert
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
		AVFormatContext *s;
		WAVContext    *wav = s->priv_data;
		AVIOContext *pb  = s->pb;
		AVStream *st;
		int64_t size;
		size = find_guid(pb, guid_fmt);
		ff_get_wav_header(pb, st->codec, size - 24);
		avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);
		size = find_guid(pb, guid_data);
		wav->data_end = avio_tell(pb) + size - 24;
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    	unsigned char	 *b = skb->tail;
		}
	struct tc_cbq_ovl opt;
	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",1,0,20,0.55,Insert
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	int a = 2;
	int b = 2;
	if (a == b) {
    	char *ret=NULL;
	}
	if (zend_parse_parameters_none() == FAILURE) {
		return;
		struct hfs_find_data *fd;
		hfsplus_cat_entry tmp;
		int err;
		err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	}
#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif
	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}",1,0,32,0.58,Insert
1274,,,,,,,
1276,,,,,,,
1277,"parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    ofpact_put_CT_CLEAR(ofpacts);
    return NULL;
}","parse_CT_CLEAR(char *arg OVS_UNUSED, struct ofpbuf *ofpacts,
               enum ofputil_protocol *usable_protocols OVS_UNUSED)
{
    int a = 8;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    int b = a;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    if(a*b>0){
        ofpact_put_CT_CLEAR(ofpacts);
    }
    return NULL;
}",0,1,35,0.47,Insert
1278,"z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));
            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}","z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));
            gs_grestore(igs);
            if (done)
                break;
        } else
        AVFrame *p;
        AVDictionary *metadata  = NULL;
        av_frame_set_metadata(p, metadata);
        metadata   = NULL;
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return 0;
        b = a;
    }
}",1,0,13,0.4,Insert
1280,"sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, false, false);
}","sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
  inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
  inter->packet_payload_size = gf_bs_read_u16(bs);
  inter->FEC_encoding_ID = gf_bs_read_u8(bs);
  inter->FEC_instance_ID = gf_bs_read_u16(bs);
  char str_1[] = ""Constant"";
  if (strlen(str_1) > 0) {
      return find_sys_var_ex(thd, str, length, false, false);
  }
}",0,1,4,0.24,Insert
1281,,,,,,,
1282,,,,,,,
1283,,,,,,,
1284,"get_compare_type(char_u *p, int *len, int *type_is)
{
    exprtype_T	type = EXPR_UNKNOWN;
    int		i;
    switch (p[0])
    {
	case '=':   if (p[1] == '=')
			type = EXPR_EQUAL;
		    else if (p[1] == '~')
			type = EXPR_MATCH;
		    break;
	case '!':   if (p[1] == '=')
			type = EXPR_NEQUAL;
		    else if (p[1] == '~')
			type = EXPR_NOMATCH;
		    break;
	case '>':   if (p[1] != '=')
		    {
			type = EXPR_GREATER;
			*len = 1;
		    }
		    else
			type = EXPR_GEQUAL;
		    break;
	case '<':   if (p[1] != '=')
		    {
			type = EXPR_SMALLER;
			*len = 1;
		    }
		    else
			type = EXPR_SEQUAL;
		    break;
	case 'i':   if (p[1] == 's')
		    {
			if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')
			    *len = 5;
			i = p[*len];
			if (!isalnum(i) && i != '_')
			{
			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;
			    *type_is = TRUE;
			}
		    }
		    break;
    }
    return type;
}","get_compare_type(char_u *p, int *len, int *type_is)
{
    exprtype_T	type = EXPR_UNKNOWN;
    int		i;
    switch (p[0])
    {
	case '=':   if (p[1] == '=')
			type = EXPR_EQUAL;
		    else if (p[1] == '~')
			type = EXPR_MATCH;
		    break;
	case '!':   if (p[1] == '=')
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			BlockDriverState *fd[MAX_FD];
    			unsigned int i_5;
    			BlockDriverState *fd[MAX_FD];
    			int driver_len;
    			for(i_5 = 0; i_5 < MAX_FD; i_5++) {
    			        driver_len = drive_get_index(IF_FLOPPY, 0, i_5);
    			       if (driver_len != -1)
    			           fd[i_5] = drives_table[driver_len].bdrv;
    			       else
    			           fd[i_5] = NULL;
    			}
    			type = EXPR_NEQUAL;
			strcpy(str, ""a"");
			}
		    else if (p[1] == '~')
			type = EXPR_NOMATCH;
		    break;
	case '>':   if (p[1] != '=')
		    {
			type = EXPR_GREATER;
			*len = 1;
		    }
		    else
			type = EXPR_GEQUAL;
		    break;
	case '<':   if (p[1] != '=')
		    {
			type = EXPR_SMALLER;
			*len = 1;
		    }
		    else
			type = EXPR_SEQUAL;
		    break;
	case 'i':   if (p[1] == 's')
		    {
			if (p[2] == 'n' && p[3] == 'o' && p[4] == 't')
			    *len = 5;
			i = p[*len];
			if (!isalnum(i) && i != '_')
			{
			    type = *len == 2 ? EXPR_IS : EXPR_ISNOT;
			    *type_is = TRUE;
			}
		    }
		    break;
    }
    return type;
}",0,1,23,1.17,Insert
1285,,,,,,,
1286,"static void php_set_default_dir(int id TSRMLS_DC)
{
	if (DIRG(default_dir)!=-1) {
		zend_list_delete(DIRG(default_dir));
	}
	if (id != -1) {
		zend_list_addref(id);
	}
	DIRG(default_dir) = id;
}","static void php_set_default_dir(int id TSRMLS_DC)
{
	if (DIRG(default_dir)!=-1) {
		zend_list_delete(DIRG(default_dir));
	}
	if (id != -1) {
		zend_list_addref(id);
	}
	AVStream *st;
	MOVStreamContext *sc = st->priv_data;
	uint32_t cra_index;
	for (uint32_t i = 0; i < sc->sync_group_count; i++)
	        if (sc->sync_group[i].index == cra_index)
	            sc->open_key_samples_count += sc->sync_group[i].count;
	DIRG(default_dir) = id;
}",1,0,7,0.26,Insert
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  int a = 2;
  int64_t unit;
  unsigned char c;
  double vals, mul, integral, fraction;
  int64_t retval;
  double vals, mul, integral, fraction;
  mul = suffix_mul(c, unit);
  retval = vals * mul;
  int b = 3;
  while (a != b) {
      Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
      b = a;
  }
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}",0,1,9,0.5,Insert
1289,"rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);
    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}","rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);
    handler->super.start_element = rsvg_metadata_handler_start;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    bool lock;
    struct request_list *repl;
    struct request_queue *q = repl->q;
    repl->cache[lock]--;
    if (strcmp(str1, str2) == 0) {
        handler->super.end_element = rsvg_metadata_handler_end;
    }
}",0,1,7,0.25,Insert
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static CImg<T> get_load_bmp(std::FILE *const file) {
      char *filename;
      long load_limit, rtas_limit, fw_size;
      fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
      int a = 2;
      int b = 2;
      const char
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      content=GetXMLTreeContent(levels);
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      if (a == b) {
          return CImg<T>().load_bmp(file);
      }
    }",0,1,35,0.34,Insert
1292,"static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_kpp rkpp;
	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct crypto_report_kpp), &rkpp))
		goto nla_put_failure;
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}","static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	GstDateTime *dt, *dt2;
    	fail_unless (!gst_date_time_has_time (dt));
    	gst_date_time_unref (dt);
    	dt = gst_date_time_new_from_iso8601_string (""0000-00-00"");
    	fail_unless (dt == NULL);
    	dt = gst_date_time_new_from_iso8601_string (""2010/05/30"");
    	struct crypto_report_kpp rkpp;
    	b = a;
	}
	const int index[4];
	double vec[4];
	double vec_freq[13];
	double mat_freq[13];
	for (int i = 0; i < 4; ++i)
	        vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];
	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));
	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct crypto_report_kpp), &rkpp))
		goto nla_put_failure;
		AVDictionary **metadata = avpriv_frame_get_metadatap(main);
		double comp_mse[4], mse = 0;
		PSNRContext *s = ctx->priv;
		double comp_mse[4], mse = 0;
		s->compute_mse(s, (const uint8_t **)main->data, main->linesize,
		                      (const uint8_t **)ref->data, ref->linesize,
		                       main->width, main->height, comp_mse);
		s->min_mse = FFMIN(s->min_mse, mse);
		s->max_mse = FFMAX(s->max_mse, mse);
		s->mse += mse;
		set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);
	return 0;
nla_put_failure:
	return -EMSGSIZE;
}",1,0,82,0.65,Insert
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    H264Context *h;
    MpegEncContext * const s = &h->s;
    uint64_t glms;
    unsigned k, b_8, err, C;
    unsigned k, b_8, err, C;
    assert(is_limm(glms));
    k = clz64(glms);
    b_8 = ctz64(glms);
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h, contextslimit);
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      int a = 2;
      int b = 2;
      while (a == b) {
          DBUG_ASSERT(0);
          b += 1;
      }
    }
  }
  return val_bool();
}",0,1,45,0.64,Insert
1296,,,,,,,
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        set_repertoire_from_charset(collation_arg);
    strcpy(str, ""a"");
    }
  }",0,1,6,0.07,Replace
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, const TxidSnapshot *snap)
{
	register ssize_t
	    i_3;
	QuantizationTable
	    *table;
	ssize_t
	    j;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	for (j=i_3; j < 64; j++)
	    table->levels[j]=table->levels[j-1];
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    		void	   *res;
			}
		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		return (res) ? false : true;
	}
#endif
	else
	{
		DisplayState *ds;
		const struct sun4d_hwdef *hawdecl;
		ram_addr_t gram_size, prom_reset, tcx64off;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		tcx64off = qemu_ram_alloc(hawdecl->vram_size);
		tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
		             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
		vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
		                        hawdecl->nvram_size, 8);
		slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
		                          sbi_cpu_arq, smp_cpus);
		slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
		                              nographic, ESCC_CLOCK, 1);
		uint32		i;
		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}",0,1,44,0.82,Insert
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		char str_1[] = ""Constant"";
		while (strlen(str_1) > 5) {
    		b++;
		strcpy(str_1, ""a"");
		}
	}
	return NULL;
}",0,1,8,0.1,Replace
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}		
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *stack)
{
	GdkEventMotion *motion;
	void *opaque;
	GtkDisplayState *s = opaque;
	int x, y;
	int mx, my;
	int t0_3, t1_4, t2_8, t3_8, t4_10, t5_3, t6_10, t7_6, t8_7, t9_4, tA_10, tB_3, tC_3, tD_10, tE_10, tF_5;
	int t0_3, t1_4, t2_8, t3_8, t4_10, t5_3, t6_10, t7_6, t8_7, t9_4, tA_10, tB_3, tC_3, tD_10, tE_10, tF_5;
	int t0_3, t1_4, t2_8, t3_8, t4_10, t5_3, t6_10, t7_6, t8_7, t9_4, tA_10, tB_3, tC_3, tD_10, tE_10, tF_5;
	int t0_3, t1_4, t2_8, t3_8, t4_10, t5_3, t6_10, t7_6, t8_7, t9_4, tA_10, tB_3, tC_3, tD_10, tE_10, tF_5;
	int t0_3, t1_4, t2_8, t3_8, t4_10, t5_3, t6_10, t7_6, t8_7, t9_4, tA_10, tB_3, tC_3, tD_10, tE_10, tF_5;
	t6_10  = t2_8 - t3_8;
	t7_6  = t3_8 * 2 + t6_10;
	t8_7  = (t6_10 * 11585) >> 14;
	int mx, my;
	int x, y;
	x = (motion->x - mx) / s->scale_x;
	y = (motion->y - my) / s->scale_y;
	register int i;
	if (stack->elements) {
		MOVTrack *track;
		AVIOContext *pb;
		int64_t pos = avio_tell(pb);
		mov_write_stsz_tag(pb, track);
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		ppc4xx_bd_info_t *bd;
		int i_10, n;
		ram_addr_t bdloc;
		for (i_10 = 0; i_10 < 32; i_10++)
		        stb_phys(bdloc + 0x3C + i_10, bd->bi_s_version[i_10]);
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		t6  = t2 - t3;
		t7  = t3 * 2 + t6;
		t8  = (t6 * 11585) >> 14;
		mov_write_stco_tag(pb, track);
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				AVPacket *pkt;
				AVFormatContext *s_2;
				AVIOContext *pb_6 = s_2->pb_6;
				uint8_t *buf = NULL;
				int i_2, len;
				PutBitContext bs;
				init_put_bits(&bs, buf, pkt->size+1024);
				latm_write_frame_header(s_2, &bs);
				put_bits(&bs, 8, pkt->size-i_2);
				avpriv_align_put_bits(&bs);
				flush_put_bits(&bs);
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				int a = 2;
				int b = 2;
				while (a == b) {
    				efree(((st_entry *)stack->elements[i])->varname);
    				b += 1;
    				if (range_str)
    				    dump_range(ses, start, id, ses->obj_size);
				}
				Monitor *mon = cur_mon;
				const char *cmd_name, *info_item;
				if (invalid_qmp_mode(mon, cmd_name)) {
				        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);
				}
			}
			efree(stack->elements[i]);
		}		
		efree(stack->elements);
	}
	return SUCCESS;
}",1,0,270,1.69,Insert
1302,"CURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex)
{
  CURLcode result = CURLE_OK;
  if(conn->bits.socksproxy) {
#ifndef CURL_DISABLE_PROXY
    const char * const host = conn->bits.httpproxy ?
                              conn->http_proxy.host.name :
                              conn->bits.conn_to_host ?
                              conn->conn_to_host.name :
                              sockindex == SECONDARYSOCKET ?
                              conn->secondaryhostname : conn->host.name;
    const int port = conn->bits.httpproxy ? (int)conn->http_proxy.port :
                     sockindex == SECONDARYSOCKET ? conn->secondary_port :
                     conn->bits.conn_to_port ? conn->conn_to_port :
                     conn->remote_port;
    conn->bits.socksproxy_connecting = TRUE;
    switch(conn->socks_proxy.proxytype) {
    case CURLPROXY_SOCKS5:
    case CURLPROXY_SOCKS5_HOSTNAME:
      result = Curl_SOCKS5(conn->socks_proxy.user, conn->socks_proxy.passwd,
                         host, port, sockindex, conn);
      break;
    case CURLPROXY_SOCKS4:
    case CURLPROXY_SOCKS4A:
      result = Curl_SOCKS4(conn->socks_proxy.user, host, port, sockindex,
                           conn);
      break;
    default:
      failf(conn->data, ""unknown proxytype option given"");
      result = CURLE_COULDNT_CONNECT;
    }  
    conn->bits.socksproxy_connecting = FALSE;
#else
  (void)sockindex;
#endif  
  }
  return result;
}","CURLcode Curl_connected_proxy(struct connectdata *conn, int sockindex)
{
  CURLcode result = CURLE_OK;
  if(conn->bits.socksproxy) {
#ifndef CURL_DISABLE_PROXY
    const char * const host = conn->bits.httpproxy ?
                              conn->http_proxy.host.name :
                              conn->bits.conn_to_host ?
                              conn->conn_to_host.name :
                              sockindex == SECONDARYSOCKET ?
                              conn->secondaryhostname : conn->host.name;
    const int port = conn->bits.httpproxy ? (int)conn->http_proxy.port :
                     sockindex == SECONDARYSOCKET ? conn->secondary_port :
                     VdpDecoderProfile profile;
                     AVCodecContext *AVcas;
                     uint32_t input;
                     VdpDecoderQueryCapabilities *decoder_query_caps;
                     uint32_t max_level, max_mb, max_width, max_height;
                     VdpDecoderCreate *create;
                     uint32_t max_level, max_mb, max_width, max_height;
                     VdpStatus status;
                     VDPAUHWContext *hwctx = AVcas->hwaccel_context;
                     VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
                     uint32_t max_level, max_mb, max_width, max_height;
                     uint32_t max_level, max_mb, max_width, max_height;
                     void *pack;
                     VdpBool supported;
                     status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                                     &max_mb, &max_width, &max_height);
                     status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                          &pack);
                     status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                                          &pack);
                     status = create(hdtx->device, profile, width, input, AVcas->refs,
                                         &hdtx->decoder);
                     conn->bits.conn_to_port ? conn->conn_to_port :
                     conn->remote_port;
    conn->bits.socksproxy_connecting = TRUE;
    switch(conn->socks_proxy.proxytype) {
    case CURLPROXY_SOCKS5:
    case CURLPROXY_SOCKS5_HOSTNAME:
      result = Curl_SOCKS5(conn->socks_proxy.user, conn->socks_proxy.passwd,
                         host, port, sockindex, conn);
      break;
    case CURLPROXY_SOCKS4:
    case CURLPROXY_SOCKS4A:
      result = Curl_SOCKS4(conn->socks_proxy.user, host, port, sockindex,
                           conn);
      break;
    default:
      failf(conn->data, ""unknown proxytype option given"");
      result = CURLE_COULDNT_CONNECT;
    }  
    conn->bits.socksproxy_connecting = FALSE;
#else
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      (void)sockindex;
  }
#endif  
  }
  return result;
}",0,1,19,0.98,Insert
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0);  
	*(__be32 *)(p + 12) = cpu_to_be32(0);  
	*(__be16 *)(p + 16) = cpu_to_be16(0);  
	p += 18;
	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;
	p = skb_put(skb, 4 + 14);
	DisasContext *qs;
	unsigned int coll, order, err, resp, coll, p_5, nzcv;
	unsigned int coll, order, err, resp, coll, p_5, nzcv;
	unsigned int coll, order, err, resp, coll, p_5, nzcv;
	unsigned int coll, order, err, resp, coll, p_5, nzcv;
	handle_fp_compare(qs, order, coll, err, false, p_5);
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	*(__be32 *)(p +  8) = cpu_to_be32(0);  
	strcpy(str, ""a"");
	}
	*(__be32 *)(p + 12) = cpu_to_be32(0);  
	*(__be16 *)(p + 16) = cpu_to_be16(0);  
	p += 18;
	isdn_net_write_super(lp, skb);
}",0,1,27,0.59,Insert
1304,"bool WebContents::CanOverscrollContent() {
  return false;
}","bool WebContents::CanOverscrollContent() {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      AIOReq *ao_grab;
      SheepdogObjReq hdr;
      unsigned int datalen = ao_grab->data_len;
      hdr.data_length = datalen;
      return false;
  strcpy(str, ""a"");
  }
}",0,1,3,0.13,Insert
1306,"proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t length;
	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;
	*n_buffer = length;
	*buffer = NULL;
	if (length == 0)
		return CKR_OK;
	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;
	return CKR_OK;
}","proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t length;
	assert (msg != NULL);
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	assert (buffer != NULL);
	}
	assert (n_buffer != NULL);
	assert (msg->input != NULL);
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;
	*n_buffer = length;
	*buffer = NULL;
	if (length == 0)
		return CKR_OK;
		if (image->debug != MagickFalse)
		    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;
	return CKR_OK;
}",1,0,207,1.45,Insert
1307,,,,,,,
1308,"    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {
      sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);
    }","    inline void getri(int &N, float *lapA, int *IPIV, float* WORK, int &LWORK, int &INFO) {
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      levels=GetXMLTreeChild(table_iterator,""levels"");
      table->levels=(unsigned int *) NULL;
      attribute=GetXMLTreeAttribute(levels,""width"");
      attribute=GetXMLTreeAttribute(levels,""height"");
      attribute=GetXMLTreeAttribute(levels,""divisor"");
      int a = 2;
      int b = 3;
      while (a != b) {
          sgetri_(&N,lapA,&N,IPIV,WORK,&LWORK,&INFO);
          b = a;
      }
    }",0,1,19,0.45,Insert
1309,,,,,,,
1312,,,,,,,
1314,,,,,,,
1316,"int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
}","int ldb_msg_append_value(struct ldb_message *msg,
			 const char *attr_name,
			 const struct ldb_val *val,
			 int flags)
{
	int a = 35;
	struct ldb_context *ydm;
	const char *attr;
	const struct ldb_schema_attribute *a_9;
	a_9 = ldb_schema_attribute_by_name(ydm, attr);
	int b = a;
	if(a*b>0){
    	return ldb_msg_append_value_impl(msg, attr_name, val, flags, NULL);
	}
}",0,1,4,0.34,Insert
1319,"HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");
  TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
}","HttpTransact::handle_websocket_upgrade_post_remap(State *s) {
  DebugTxn(""http_trans_websocket_upgrade_post_remap"", ""Remap is complete, start websocket upgrade"");
  int a = 2;
  int b = 2;
  if (a == b) {
      VdpDecoderProfile profile;
      struct client_session *c;
      int http_status;
      struct session_request *sr;
      struct mk_list *host_list = &config->hosts;
      struct mk_list *sr_list = &c->request_list;
      if (http_status > 0) {
              if (!sr->host_conf) {
                  sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
              }
              mk_request_error(http_status, c, sr);
              mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                  NULL, c, sr);
      }
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                           &pack);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      TRANSACT_RETURN(SM_ACTION_API_POST_REMAP, HttpTransact::handle_websocket_connection);
  }
}",0,1,37,0.36,Insert
1320,"TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {
  initialize();
  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, true), ServerCodecError);
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
}","TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {
  initialize();
  AVDictionary **metadata = avpriv_frame_get_metadatap(main);
  double comp_mse[4], mse = 0;
  PSNRContext *s = ctx->priv;
  double comp_mse[4], mse = 0;
  s->compute_mse(s, (const uint8_t **)main->data, main->linesize,
                        (const uint8_t **)ref->data, ref->linesize,
                         main->width, main->height, comp_mse);
  s->min_mse = FFMIN(s->min_mse, mse);
  s->max_mse = FFMAX(s->max_mse, mse);
  s->mse += mse;
  set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);
  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, true), ServerCodecError);
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
}",1,0,36,0.29,Insert
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	return J9PORT_SIG_EXCEPTION_RETURN;
    	b += 1;
	}
}",0,1,1,0.02,Replace
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;
  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        my_free(ptr, MYF(0));
    strcpy(str, ""a"");
    }
  }
}",0,1,4,0.07,Replace
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;
	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
		struct f *f;
		int rt;
		if (rt == 1) {
				ClearPagePrivate(f);
				set_page_private(f, 0);
				page_cache_release(f);
		}
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return TEE_SUCCESS;
    	b += 1;
	}
}",0,1,15,0.81,Insert
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    	int a = 2;
    	int b = 3;
    	while (a != b) {
        MachineState *machine;
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        buf_T	*buf = curbuf;
        	b = a;
    	}
    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;
    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}",0,1,33,0.59,Insert
1325,"TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}","TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  }
  RenderViewHost* render_view_host;
  const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params;
  GURL validated_url(params.url);
  GURL validated_url(params.url);
  RenderProcessHost* render_process_host =
        render_view_host->GetProcess();
  VLOG(1) << ""Failed Provisional Load: "" << params.url.possibly_invalid_spec()
            << "", error_code: "" << params.error_code
            << "", error_description: "" << params.error_description
            << "", is_main_frame: "" << params.is_main_frame
            << "", showing_repost_interstitial: "" <<
              params.showing_repost_interstitial
            << "", frame_id: "" << params.frame_id;
  FOR_EACH_OBSERVER(WebContentsObserver,
                       observers_,
                       DidFailProvisionalLoad(params.frame_id,
                                             params.is_main_frame,
                                             validated_url,
                                             params.error_code,
                                             params.error_description,
                                             render_view_host));
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}",1,0,33,0.54,Insert
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;
    struct vhost_dev *hdev;
    int i, r;
    uint64_t features;
    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);
    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);
    hdev->features = features;
    hdev->memory_listener = (MemoryListener) {
            .begin = vhost_begin,
            .commit = vhost_commit,
            .region_add = vhost_region_add,
            .region_del = vhost_region_del,
            .region_nop = vhost_region_nop,
            .log_start = vhost_log_start,
            .log_stop = vhost_log_stop,
            .log_sync = vhost_log_sync,
            .log_global_start = vhost_log_global_start,
            .log_global_stop = vhost_log_global_stop,
            .eventfd_add = vhost_eventfd_add,
            .eventfd_del = vhost_eventfd_del,
            .priority = 10
        };
    hdev->migration_blocker = NULL;
    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        int a = 2;
        int b = 3;
        while (a < b) {
            BIO *bio = BIO_new(BIO_s_null());
            b = a;
        }
        X509_print(bio, x509);
        BIO_free(bio);
        i2d_X509(x509, &der);
        OPENSSL_free(der);
        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}",1,0,24,0.65,Insert
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    int a = 2;
    int b = 3;
    while (a < b) {
        return *headers_.Host();
        b = a;
    }
  }",0,1,1,0.03,Replace
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	authenc_ahash_t authenc_ahash_fn;
	struct aead_request *req_5;
	u8 *hash;
	struct crypto_aead *authenc = crypto_aead_reqtfm(req_5);
	hash = authenc_ahash_fn(req_5, CRYPTO_TFM_REQ_MAY_SLEEP);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return status;
	strcpy(str, ""a"");
	}
}",0,1,22,0.89,Insert
1332,,,,,,,
1333,,,,,,,
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		out[i] = in[i] ^ xor_with[i];
		}
	}
}",0,1,1,0.03,Replace
1335,"static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	object->u.dir.index++;
	do {
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}","static void spl_filesystem_tree_it_move_forward(zend_object_iterator *iter TSRMLS_DC)
{
	char **line_9;
	AVBPrint line_buffer_4;
	if (line_9)
	        av_bprint_init_3(&line_buffer_4, 0, AV_BPRINT_SIZE_AUTOMATIC_4);
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	int a = 53;
	de265_image* coll;
	const int offset_shift1_L = coll->get_sps().WpOffsetBdShiftY;
	int    bride[3];
	void*  pixels[3];
	pixels[0] = coll->get_image_plane_at_pos_any_depth(0,xP,yP);
	bride[0] = coll->get_image_stride(0);
	pixels[1] = coll->get_image_plane_at_pos_any_depth(1,xP/SubWidthC,yP/SubHeightC);
	bride[1] = coll->get_image_stride(1);
	pixels[2] = coll->get_image_plane_at_pos_any_depth(2,xP/SubWidthC,yP/SubHeightC);
	int b = a;
	char **line;
	AVBPrint line_buffer;
	if (line)
	        av_bprint_init(&line_buffer, 0, AV_BPRINT_SIZE_AUTOMATIC);
	if(a*b>0){
    	spl_filesystem_object   *object   = spl_filesystem_iterator_to_object(iterator);
	}
	object->u.dir.index++;
	do {
		const char *arg2n;
		struct pxa2xx_pic_state_s *state;
		state->cpu_env = status;
		cpu_arm_set_cp_io(status, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, state);
		const char *arg1n;
		const char *attribute;
		MagickCLI *cli_wand;
		if (cli_wand->wand.debug != MagickFalse)
		    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),
		       ""- List Operator: %s \""%s\"" \""%s\"""", attribute,
		       arg1n == (const char *) NULL ? ""null"" : arg1n,
		       arg2n == (const char *) NULL ? ""null"" : arg2n);
		spl_filesystem_dir_read(object TSRMLS_CC);
	} while (spl_filesystem_is_dot(object->u.dir.entry.d_name));
	if (object->file_name) {
		efree(object->file_name);
		object->file_name = NULL;
	}
	if (iterator->current) {
		zval_ptr_dtor(&iterator->current);
		iterator->current = NULL;
	}
}",1,0,218,1.42,Insert
1336,"  virtual void initialize() {
    Http2SettingsFromTuple(client_http2settings_, client_settings_);
    Http2SettingsFromTuple(server_http2settings_, server_settings_);
    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
                                                         stats_store_, client_http2settings_,
                                                         max_request_headers_kb_);
    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
                                                         stats_store_, server_http2settings_,
                                                         max_request_headers_kb_);
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));
  }","  virtual void initialize() {
    int a = 2;
    int b = 2;
    while (a == b) {
        Http2SettingsFromTuple(client_http2settings_, client_settings_);
        b += 1;
    }
    Http2SettingsFromTuple(server_http2settings_, server_settings_);
    client_ = std::make_unique<TestClientConnectionImpl>(client_connection_, client_callbacks_,
                                                         stats_store_, client_http2settings_,
                                                         max_request_headers_kb_);
    server_ = std::make_unique<TestServerConnectionImpl>(server_connection_, server_callbacks_,
                                                         stats_store_, server_http2settings_,
                                                         max_request_headers_kb_);
    request_encoder_ = &client_->newStream(response_decoder_);
    setupDefaultConnectionMocks();
    EXPECT_CALL(server_callbacks_, newStream(_, _))
        .WillRepeatedly(Invoke([&](StreamEncoder& encoder, bool) -> StreamDecoder& {
          response_encoder_ = &encoder;
          encoder.getStream().addCallbacks(server_stream_callbacks_);
          return request_decoder_;
        }));
  }",0,1,1,0.09,Replace
1337,,,,,,,
1342,,,,,,,
1344,,,,,,,
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }
    return GUEST_FSFREEZE_STATUS_THAWED;
}","GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }
    int a = 2;
    int b = 2;
    if (a == b) {
        return GUEST_FSFREEZE_STATUS_THAWED;
    }
}",0,1,10,0.26,Insert
1346,,,,,,,
1349,,,,,,,
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;
	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	struct sk_buff *skb;
	struct hci_dev *hdev;
	void *settings;
	__u8 status = *((__u8 *) skb->data);
	BT_DBG(""%s status 0x%2.2x"", hdev->name, status);
	settings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);
	hdev->voice_setting = data;
	BT_DBG(""%s voice setting 0x%4.4x"", hdev->name, data);
	if (strcmp(str1, str2) == 0) {
    	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);
	}
	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}",0,1,7,0.41,Insert
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	return 0;
}","static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	authenc_ahash_t authenc_ahash_fn;
	unsigned maxpages;
	size_t *start;
	struct iov_iter *i_6;
	unsigned int iter_head, npages;
	unsigned int iter_head, npages;
	size_t capacity;
	npages = pipe_space_for_user(iter_head, i_6->pipe->tail, i_6->pipe);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	struct aead_request *req;
	u8 *hash;
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	hash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	int i, ret;
	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);
	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;
	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}
	int a = 2;
	int b = 3;
	while (a < b) {
    	return 0;
    	b = a;
	}
}",0,1,39,0.84,Insert
1356,"static int php_object_element_export(zval **zv TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)  
{
	int level;
	smart_str *buf;
	level = va_arg(args, int);
	buf = va_arg(args, smart_str *);
	buffer_append_spaces(buf, level + 2);
	if (hash_key->nKeyLength != 0) {
		const char *class_name;  
		const char *pname;
		char *pname_esc;
		int  pname_esc_len;
		zend_unmangle_property_name(hash_key->arKey, hash_key->nKeyLength - 1,
				&class_name, &pname);
		pname_esc = php_addcslashes(pname, strlen(pname), &pname_esc_len, 0,
			""'\\"", 2 TSRMLS_CC);
		smart_str_appendc(buf, '\'');
		smart_str_appendl(buf, pname_esc, pname_esc_len);
		smart_str_appendc(buf, '\'');
		efree(pname_esc);
	} else {
		smart_str_append_long(buf, (long) hash_key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
	return 0;
}","static int php_object_element_export(zval **zv TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key)  
{
	void **args_7;
	ffold= *args_7;
	int level;
	smart_str *buf;
	MOVTrack *track;
	MOVMuxContext *mov;
	AVIOContext *pb;
	int version = duration < INT32_MAX ? 0 : 1;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	if (!track->entry && mov->mode == MODE_ISM)
	        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);
	    else if (!track->entry)
	        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);
	        struct pinctrl *n;
	        struct pinctrl_map *map;
	        const uint8_t *quant_5;
	        int16_t *blks_4;
	        int s0_9, s1_9, s2_2, s3_1, s4_8, s5_8, s6_6, s7_1;
	        int t0_3, t1_3, t2_4, t3_8, t4_4, t5_8, t6_6, t7_3, t8_8, t9_4, tA_1, tB_3, tC_1, tD_8, tE_9, tF_9;
	        int t0_3, t1_3, t2_4, t3_8, t4_4, t5_8, t6_6, t7_3, t8_8, t9_4, tA_1, tB_3, tC_1, tD_8, tE_9, tF_9;
	        int s0_9, s1_9, s2_2, s3_1, s4_8, s5_8, s6_6, s7_1;
	        int t0_3, t1_3, t2_4, t3_8, t4_4, t5_8, t6_6, t7_3, t8_8, t9_4, tA_1, tB_3, tC_1, tD_8, tE_9, tF_9;
	        int t0_3, t1_3, t2_4, t3_8, t4_4, t5_8, t6_6, t7_3, t8_8, t9_4, tA_1, tB_3, tC_1, tD_8, tE_9, tF_9;
	        s7_1 = (int) blks_4[7 * 8] * quant_5[7 * 8];
	        t2_4  = ((s7_1 * 4520  + s1_9 * 22725) >> 15) - t0_3;
	        t3_8  = ((s1_9 * 4520  - s7_1 * 22725) >> 15) - t1_3;
	        struct pinctrl_dev *pctldev;
	        unsigned num_maps;
	        struct pinctrl_dt_map *dt_map;
	        dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	        dt_map->pctldev = pctldev;
	        dt_map->map = map;
	        dt_map->num_maps = num_maps;
	        list_add_tail(&dt_map->node, &n->dt_maps);
	    else
	        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);
	level = va_arg(args, int);
	const uint8_t *quant;
	int16_t *blks;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	s7 = (int) blks[7 * 8] * quant[7 * 8];
	t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;
	t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
	buf = va_arg(args, smart_str *);
	buffer_append_spaces(buf, level + 2);
	if (hash_key->nKeyLength != 0) {
		const char *class_name;  
		const char *pname;
		char *pname_esc;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		int  pname_esc_len;
		}
		zend_unmangle_property_name(hash_key->arKey, hash_key->nKeyLength - 1,
				&class_name, &pname);
		pname_esc = php_addcslashes(pname, strlen(pname), &pname_esc_len, 0,
			""'\\"", 2 TSRMLS_CC);
		smart_str_appendc(buf, '\'');
		smart_str_appendl(buf, pname_esc, pname_esc_len);
		smart_str_appendc(buf, '\'');
		efree(pname_esc);
	} else {
		smart_str_append_long(buf, (long) hash_key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
	return 0;
}",1,0,166,1.54,Insert
1357,"static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;
	ewq->ctx = ctx;
	init_waitqueue_entry(&ewq->wq, current);
	spin_lock(&ctx->event_wqh.lock);
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (ACCESS_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;
				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				userfaultfd_ctx_put(new);
			}
			break;
		}
		spin_unlock(&ctx->event_wqh.lock);
		wake_up_poll(&ctx->fd_wqh, POLLIN);
		schedule();
		spin_lock(&ctx->event_wqh.lock);
	}
	__set_current_state(TASK_RUNNING);
	spin_unlock(&ctx->event_wqh.lock);
out:
	userfaultfd_ctx_put(ctx);
}","static void userfaultfd_event_wait_completion(struct userfaultfd_ctx *ctx,
					      struct userfaultfd_wait_queue *ewq)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setJavaScriptEnabled(enableScripts);
	if (WARN_ON_ONCE(current->flags & PF_EXITING))
		goto out;
	ewq->ctx = ctx;
	int a = 2;
	int b = 3;
	while (a != b) {
    	init_waitqueue_entry(&ewq->wq, current);
    	b = a;
	}
	spin_lock(&ctx->event_wqh.lock);
	__add_wait_queue(&ctx->event_wqh, &ewq->wq);
	for (;;) {
		set_current_state(TASK_KILLABLE);
		if (ewq->msg.event == 0)
			break;
		if (ACCESS_ONCE(ctx->released) ||
		    fatal_signal_pending(current)) {
			__remove_wait_queue(&ctx->event_wqh, &ewq->wq);
			if (ewq->msg.event == UFFD_EVENT_FORK) {
				struct userfaultfd_ctx *new;
				new = (struct userfaultfd_ctx *)
					(unsigned long)
					ewq->msg.arg.reserved.reserved1;
				userfaultfd_ctx_put(new);
			}
			break;
		}
		spin_unlock(&ctx->event_wqh.lock);
		wake_up_poll(&ctx->fd_wqh, POLLIN);
		schedule();
		spin_lock(&ctx->event_wqh.lock);
	}
	__set_current_state(TASK_RUNNING);
	spin_unlock(&ctx->event_wqh.lock);
	MagickBooleanType
	    scope;
	scope=MagickTrue;
out:
	userfaultfd_ctx_put(ctx);
}",1,0,459,2.74,Insert
1358,,,,,,,
1360,,,,,,,
1361,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_2 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_2->linade, linade, datalen);
    if (strcmp(str1, str2) == 0) {
        return s->interrupt_states[lidx].is_asserted;
    }
}",0,1,3,0.19,Insert
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  fraction = modf(vals, &integral);
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}",0,1,1,0.23,Insert
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        free (pp->content_transfer_encoding);
    strcpy(str, ""a"");
    }
    pp->content_transfer_encoding = NULL;
  }
}",0,1,2,0.13,Replace
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *g, Renode *node)
{
	gchar *str, *str2;
	GstDateTime *dt, *dt2;
	GstDateTime *dt, *dt2;
	str2 = gst_date_time_to_iso8601_string (dt2);
	gchar *str_10, *str2_9;
	GstDateTime *dt_3, *dt2_9;
	GstDateTime *dt_3, *dt2_9;
	str2_9 = gst_date_time_to_iso8601_string_7 (dt2_9);
	gst_date_time_unref_8 (dt2_9);
	gst_date_time_unref_8 (dt_3);
	dt_3 = gst_date_time_new_from_iso8601_string_5 (""2010-10-30 15:50"");
	fail_unless_10 (gst_date_time_get_year_10 (dt_3) == 2010);
	gst_date_time_unref (dt2);
	gst_date_time_unref (dt);
	dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50"");
	fail_unless (gst_date_time_get_year (dt) == 2010);
	int a = 2;
	AVFormatContext *s;
	IffDemuxContext *iff = s->priv_data;
	iff->bitmap_compression = -1;
	iff->svx8_compression = -1;
	iff->maud_compression = -1;
	int b = 2;
	while (a == b) {
    	int min, max, n;
    	b += 1;
	}
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	vpx_codec_alg_priv_t *cms;
	AVCodec *codec = NULL;
	AVCodecParameters *origin_par = NULL;
	int i, j;
	AVFormatContext *fmt_ctx = NULL;
	AVFrame *fr = NULL;
	int result;
	int video_stream;
	AVCodecContext *ctx= NULL;
	int i, j;
	result = avcodec_parameters_to_context(ctx, origin_par);
	result = avcodec_open2(ctx, codec, NULL);
	result = compute_crc_of_packets(fmt_ctx, video_stream, ctx, fr, i, j, 1);
	avcodec_close(ctx);
	avformat_close_input(&fmt_ctx);
	if((res == VPX_CODEC_UNSUP_BITSTREAM) && !cms->si.is_kf)
	 {
	        res = VPX_CODEC_OK;
	}
	case P_NLA: return count(g, node->x) + 2;
	}
}",1,0,394,3.05,Insert
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
					uint32_t out_length;
					const char
					    *attribute,
					    *content;
					XMLTreeInfo
					    *description,
					    *levels,
					    *quantization_tables,
					    *table_iterator;
					QuantizationTable
					    *table;
					XMLTreeInfo
					    *description,
					    *levels,
					    *quantization_tables,
					    *table_iterator;
					XMLTreeInfo
					    *description,
					    *levels,
					    *quantization_tables,
					    *table_iterator;
					table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
					table->slot=(char *) NULL;
					table->description=(char *) NULL;
					table->levels=(unsigned int *) NULL;
					attribute=GetXMLTreeAttribute(table_iterator,""slot"");
					uint32_t out_len;
					int tpm_fd;
					const uint8_t *diff;
					uint8_t *out;
					int let;
					let = tpm_passthrough_unix_write(tpm_fd, diff, out_length);
					let = tpm_passthrough_unix_read(tpm_fd, out, out_len);
	}
	free (oname);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	free (nname);
	}
	free (name);
	return true;
}",0,1,59,1.24,Insert
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD

PutBitContext pb, pb2;
JLSState *state;
ls_store_lse(state, &pb);
av_freep(&state);
av_freep(&state);  char str_1[] = ""Constant"";
  while (strlen(str_1) > 5) {
      return 1;
  strcpy(str_1, ""a"");
  }
}",0,1,15,0.51,Insert
1369,"gst_date_time_new_now_local_time (void)
{
  return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
}","gst_date_time_new_now_local_time (void)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      return gst_date_time_new_from_g_date_time (g_date_time_new_now_local ());
      b = a;
      QEMUBH *phi;
      phi = g_malloc0(sizeof(QEMUBH));
      phi->ctx = ctx;
      phi->cb = cb;
      phi->opaque = opaque;
      phi->next = ctx->first_bh;
  }
}",0,1,17,0.32,Insert
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool StrictUtf8Check(const FieldDescriptor* field) {
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      Unit *u;
      Unit *other;
      int range;
      Automount *worker = AUTOMOUNT(u);
      if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
                      (void) automount_send_ready(worker, worker->tokens, 0);
                      range = automount_start_expire(worker);
                      if (range < 0)
                              log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
                      automount_set_state(worker, AUTOMOUNT_RUNNING);
      }
      return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
  }
}",0,1,3,0.17,Insert
1372,"runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}","runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	int a = 2;
	int b = 2;
	while (a == b) {
    	sigquitWatcher.start(SIGQUIT);
    	b += 1;
	}
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}",1,0,8,0.15,Replace
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;
	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];
	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);
	cb->args[0] = t;
	return skb->len;
}","int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;
	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];
	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	BlockDriverState *bos;
	if (Pbes) {
	        *Pbes = bos;
	}
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	read_unlock(&neigh_tbl_lock);
	cb->args[0] = t;
	int a = 2;
	int b = 2;
	while (a == b) {
    	return skb->len;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	size_t
    	    length;
    	table->width=StringToUnsignedLong(attribute);
    	table->height=StringToUnsignedLong(attribute);
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	length=(size_t) table->width*table->height;
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
    	b += 1;
	}
}",0,1,78,1.19,Insert
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
  if (js.j_jobslots == 0)
    return;
  BLOCK_CHILD (set, oset);
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int i;
  int flags;
  RTPContext *http;
  char val[1024];
  if (url_open(&http->rtcp_hd, val, flags) < 0)
          goto fail;
  sigset_t set, oset;
  if (js.j_jobslots == 0)
    return;
  int a = 2;
  int b = 2;
  while (a == b) {
      BLOCK_CHILD (set, oset);
      b += 1;
  }
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
  UNBLOCK_CHILD (oset);
}",0,1,28,0.58,Insert
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;
    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void jpeg_init_destination(j_compress_ptr cinfo)
{
    struct kvm_memory_slot *slot;
    const page_load_metrics::mojom::PageLoadTiming& timing_3;
    const page_load_metrics::PageLoadExtraInfo& info_4;
    bool is_user_initiated_navigation_6 =
          info_4.user_initiated_info.browser_initiated ||
          timing_3.input_to_navigation_start;
    bool is_user_initiated_navigation_6 =
          info_4.user_initiated_info.browser_initiated ||
          timing_3.input_to_navigation_start;
    if (timing_3.paint_timing->largest_image_paint.has_value() &&
          WasStartedInForegroundOptionalEventInForeground_2(
              timing_3.paint_timing->largest_image_paint, info_4)) {
        builder_4.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
            timing_3.paint_timing->largest_image_paint.value().InMilliseconds());
    }
    gfn_t gfn;
    gfn_t end_gfn;
    const page_load_metrics::mojom::PageLoadTiming& timing;
    const page_load_metrics::PageLoadExtraInfo& info;
    bool is_user_initiated_navigation =
          info.user_initiated_info.browser_initiated ||
          timing.input_to_navigation_start;
    bool is_user_initiated_navigation =
          info.user_initiated_info.browser_initiated ||
          timing.input_to_navigation_start;
    if (timing.paint_timing->largest_image_paint.has_value() &&
          WasStartedInForegroundOptionalEventInForeground(
              timing.paint_timing->largest_image_paint, info)) {
        builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
            timing.paint_timing->largest_image_paint.value().InMilliseconds());
    }
    while (gfn < end_gfn)
    		gfn_to_pfn_memslot(slot, gfn++);
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;
    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}",1,0,89,0.64,Insert
1377,,,,,,,
1378,"static void tftp_send_next_block(struct tftp_session *spt,
                                 struct tftp_t *recv_tp)
{
    struct mbuf *m;
    struct tftp_t *tp;
    int nobytes;
    m = m_get(spt->slirp);
    if (!m) {
        return;
    }
    tp = tftp_prep_mbuf_data(spt, m);
    tp->tp_op = htons(TFTP_DATA);
    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);
    nobytes = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,
                             spt->block_size);
    if (nobytes < 0) {
        m_free(m);
        tftp_send_error(spt, 1, ""File not found"", tp);
        return;
    }
    m->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -
               sizeof(struct udphdr);
    tftp_udp_output(spt, m, recv_tp);
    if (nobytes == spt->block_size) {
        tftp_session_update(spt);
    } else {
        tftp_session_terminate(spt);
    }
    spt->block_nr++;
}","static void tftp_send_next_block(struct tftp_session *spt,
                                 struct tftp_t *recv_tp)
{
    MOVTrack *track;
    struct unix_sock *u;
    struct sock *sk = NULL;
    sk->sk_destruct		= unix_sock_destructor;
    u	  = unix_sk(sk);
    unix_insert_socket(unix_sockets_unbound, sk);
    AVIOContext *pb;
    struct sock *shop;
    const struct dst_entry *dst = __sk_dst_get(shop);
    const struct dst_entry *dst = __sk_dst_get(shop);
    struct tcp_sock *tp_10 = tcp_sk(shop);
    tcp_sync_mss(shop, dst_mtu(dst));
    tcp_ca_dst_init(shop, dst);
    tp_10->advmss = tcp_mss_clamp(tp_10, dst_metric_advmss(dst));
    int64_t pos = avio_tell(pb);
    if (track->enc->codec_type == AVMEDIA_TYPE_VIDEO &&
    struct sock *shop_6;
    MOVTrack *track_10;
    AVIOContext *pb_10;
    int64_t pos_1 = avio_tell_9(pb_10);
    if (track_10->mode == MODE_MOV && track_10->flags & MOV_TRACK_STPS)
            mov_write_stss_tag(pb_10, track_10, MOV_PARTIAL_SYNC_SAMPLE);
    __u8 rcv_wscale;
    struct tcp_sock *tp_5 = tcp_sk_7(shop_6);
    const struct dst_entry *dst_5 = __sk_dst_get_4(shop_6);
    u32 rcv_wnd;
    const struct dst_entry *dst_5 = __sk_dst_get_4(shop_6);
    tp_5->tcp_header_len = sizeof(struct tcphdr);
    tp_5->max_window = 0;
    tp_5->advmss = tcp_mss_clamp_8(tp_5, dst_metric_advmss_4(dst_5));
    tcp_select_initial_window(shop_6, tcp_full_space(shop_6),
    				  tp_5->advmss - (tp_5->rx_opt.ts_recent_stamp ? tp_5->tcp_header_len - sizeof(struct tcphdr) : 0),
    				  &tp_5->rcv_wnd,
    				  &tp_5->window_clamp,
    				  sock_net(shop_6)->ipv4.sysctl_tcp_window_scaling,
    				  &rcv_wscale,
    				  rcv_wnd);
    tp_5->rx_opt.rcv_wscale = rcv_wscale;
            track->flags & MOV_TRACK_CTTS && track->entry)
            mov_write_ctts_tag(pb, track);
    struct mbuf *m;
    struct tftp_t *tp;
    int nobytes;
    m = m_get(spt->slirp);
    if (!m) {
        return;
    }
    tp = tftp_prep_mbuf_data(spt, m);
    tp->tp_op = htons(TFTP_DATA);
    tp->x.tp_data.tp_block_nr = htons((spt->block_nr + 1) & 0xffff);
    nobytes = tftp_read_data(spt, spt->block_nr, tp->x.tp_data.tp_buf,
                             spt->block_size);
    if (nobytes < 0) {
        m_free(m);
        int a = 48;
        int b = a;
        if(a*b>0){
            tftp_send_error(spt, 1, ""File not found"", tp);
        }
        return;
    }
    m->m_len = sizeof(struct tftp_t) - (TFTP_BLOCKSIZE_MAX - nobytes) -
               sizeof(struct udphdr);
    tftp_udp_output(spt, m, recv_tp);
    if (nobytes == spt->block_size) {
        tftp_session_update(spt);
    } else {
        tftp_session_terminate(spt);
    }
    spt->block_nr++;
}",1,0,241,1.87,Insert
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  PutBitContext pb, pb2;
  int comps;
  put_bits(&pb, 16, 8 + comps * 3);
  put_bits(&pb, 8, comps);
  put_bits(&pb, 16, 6 + comps * 2);
  put_bits(&pb, 8, comps);
  put_bits(&pb, 8, (comps > 1) ? 1 : 0);
  initialize();
  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);
  std::string output;
  int a = 2;
  int b = 2;
  while (a == b) {
      ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
      b += 1;
  }
  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}",0,1,15,0.44,Insert
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	int a = 2;
	int b = 3;
	if (a != b) {
    	void *data;
    	AVPacket *avpkt;
    	AVCodecContext *avctx;
    	int buf_index      = 0;
    	const uint8_t *buf = avpkt->data;
    	int buf_size       = avpkt->size;
    	H264Context *hy     = avctx->priv_data;
    	buf_index = decode_nal_units(hy, buf, buf_size);
    	free (pe->nt_headers);
	}
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}",0,1,43,0.92,Insert
1386,,,,,,,
1387,,,,,,,
1388,"static int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct net_device *dev = info->user_ptr[1];
	struct station_del_parameters params;
	memset(&params, 0, sizeof(params));
	if (info->attrs[NL80211_ATTR_MAC])
		params.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);
	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&
	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&
	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
		return -EINVAL;
	if (!rdev->ops->del_station)
		return -EOPNOTSUPP;
	if (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {
		params.subtype =
			nla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);
		if (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&
		    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)
			return -EINVAL;
	} else {
		params.subtype = IEEE80211_STYPE_DEAUTH >> 4;
	}
	if (info->attrs[NL80211_ATTR_REASON_CODE]) {
		params.reason_code =
			nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);
		if (params.reason_code == 0)
			return -EINVAL;  
	} else {
		params.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;
	}
	return rdev_del_station(rdev, dev, &params);
}","static int nl80211_del_station(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct net_device *dev = info->user_ptr[1];
	struct station_del_parameters params;
	int a = 2;
	int b = 3;
	while (a < b) {
    	memset(&params, 0, sizeof(params));
    	b = a;
	}
	if (info->attrs[NL80211_ATTR_MAC])
		params.mac = nla_data(info->attrs[NL80211_ATTR_MAC]);
	if (dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP &&
	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_AP_VLAN &&
	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_MESH_POINT &&
	    dev->ieee80211_ptr->iftype != NL80211_IFTYPE_P2P_GO)
		return -EINVAL;
	if (!rdev->ops->del_station)
		return -EOPNOTSUPP;
	if (info->attrs[NL80211_ATTR_MGMT_SUBTYPE]) {
		params.subtype =
			nla_get_u8(info->attrs[NL80211_ATTR_MGMT_SUBTYPE]);
		if (params.subtype != IEEE80211_STYPE_DISASSOC >> 4 &&
		    params.subtype != IEEE80211_STYPE_DEAUTH >> 4)
			return -EINVAL;
	} else {
		params.subtype = IEEE80211_STYPE_DEAUTH >> 4;
	}
	if (info->attrs[NL80211_ATTR_REASON_CODE]) {
		params.reason_code =
			nla_get_u16(info->attrs[NL80211_ATTR_REASON_CODE]);
		if (params.reason_code == 0)
			return -EINVAL;
			struct edgeport_serial *serial;
			u8 *data;
			struct device *dev_10 = &serial->serial->dev_10->dev_10;
			struct device *dev_10 = &serial->serial->dev_10->dev_10;
			int status;
			data = kmalloc(1, GFP_KERNEL);
			status = ti_vread_sync(serial->serial->dev_10, UMPC_MEMORY_READ,
							DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
			status = ti_vread_sync(serial->serial->dev_10, UMPC_MEMORY_READ,
							DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);  
	} else {
		params.reason_code = WLAN_REASON_PREV_AUTH_NOT_VALID;
	}
	return rdev_del_station(rdev, dev, &params);
}",0,1,16,1.06,Insert
1389,"sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	struct sctp_chunk *reply = NULL;
	pr_debug(""%s: timer T5 expired\n"", __func__);
	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));
	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);
	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	return SCTP_DISPOSITION_NOMEM;
}","sctp_disposition_t sctp_sf_t5_timer_expire(struct net *net,
					   const struct sctp_endpoint *ep,
					   const struct sctp_association *asoc,
					   const sctp_subtype_t type,
					   void *arg,
					   sctp_cmd_seq_t *commands)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	struct sctp_chunk *reply = NULL;
	}
	pr_debug(""%s: timer T5 expired\n"", __func__);
	SCTP_INC_STATS(net, SCTP_MIB_T5_SHUTDOWN_GUARD_EXPIREDS);
	reply = sctp_make_abort(asoc, NULL, 0);
	if (!reply)
		goto nomem;
	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(reply));
	sctp_add_cmd_sf(commands, SCTP_CMD_SET_SK_ERR,
			SCTP_ERROR(ETIMEDOUT));
	sctp_add_cmd_sf(commands, SCTP_CMD_ASSOC_FAILED,
			SCTP_PERR(SCTP_ERROR_NO_ERROR));
	SCTP_INC_STATS(net, SCTP_MIB_ABORTEDS);
	struct nbd_request Request_8;
	uint32_t response_9;
	response_9 = Request_8.type & NBD_CMD_MASK_COMMAND_8;
	SCTP_DEC_STATS(net, SCTP_MIB_CURRESTAB);
	char *filename;
	AVCodecContext *AVcas;
	VdpDecoderProfile profile;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpStatus status;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	long load_limit, rtas_limit, fw_size;
	rtas_limit = MIN(spapr->rma_size, 0x80000000);
	spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	return SCTP_DISPOSITION_DELETE_TCB;
nomem:
	struct nbd_request Request;
	uint32_t response;
	response = Request.type & NBD_CMD_MASK_COMMAND;
	return SCTP_DISPOSITION_NOMEM;
}",0,1,117,1.31,Insert
1390,,,,,,,
1391,,,,,,,
1394,"GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;
	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->trackID = gf_bs_read_u32(bs);
	return gf_isom_box_array_read(s, bs);
}","GF_Err trep_box_read(GF_Box *s, GF_BitStream *bs)
{
	int a = 2;
	int b = 3;
	struct client_session *c;
	int http_status;
	struct session_request *sr;
	struct mk_list *host_list = &config->hosts;
	struct mk_list *sr_list = &c->request_list;
	if (http_status > 0) {
	        if (!sr->host_conf) {
	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
	        }
	        mk_request_error(http_status, c, sr);
	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
	                            NULL, c, sr);
	}
	while (a < b) {
    	GF_TrackExtensionPropertiesBox *ptr = (GF_TrackExtensionPropertiesBox *)s;
    	b = a;
	}
	ISOM_DECREASE_SIZE(ptr, 4);
	ptr->trackID = gf_bs_read_u32(bs);
	return gf_isom_box_array_read(s, bs);
}",0,1,13,0.43,Insert
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return ss.str();
  strcpy(str, ""a"");
  }
}",0,1,1,0.03,Replace
1400,,,,,,,
1401,,,,,,,
1402,"void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  ASSERT(call->arguments()->length() == 0);
  if (function_state()->outer() != NULL) {
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}","void HGraphBuilder::GenerateIsConstructCall(CallRuntime* call) {
  int a = 2;
  int nb_oargs;
  WS_SFTP_BUFFER* buffer;
  word32 value_1;
  if (buffer != NULL) {
          c32toa(value_1, buffer->data + buffer->idx);
          buffer->idx += UINT32_SZ;
  }
  int nb_iargs;
  const TCGArg * const args;
  int rules, nb_regs, ini;
  tcg_insn_unit *func_addr;
  func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
  rules = args[nb_oargs + nb_iargs + 1];
  int b = 2;
  while (a == b) {
      ASSERT(call->arguments()->length() == 0);
      b += 1;
  }
  if (function_state()->outer() != NULL) {
    HValue* value = function_state()->inlining_kind() == CONSTRUCT_CALL_RETURN
        ? graph()->GetConstantTrue()
        : graph()->GetConstantFalse();
    return ast_context()->ReturnValue(value);
  } else {
    return ast_context()->ReturnControl(new(zone()) HIsConstructCallAndBranch,
                                        call->id());
  }
}",0,1,36,0.58,Insert
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	can_rename = TRUE;
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;
		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));
		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}
	if (!can_rename) {
		return FALSE;
	}
	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		char *filename;
		g_free(filename);
		char str[] = ""Constant"";
		VirtIODevice *vrdevice;
		BlockConf *conf = &s->conf.conf;
		VirtIOBlock *s = VIRTIO_BLK(vrdevice);
		int blk_size = conf->logical_block_size;
		struct virtio_blk_config blkcfg;
		virtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);
		virtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);
		blkcfg.heads = conf->heads;
		blkcfg.size_max = 0;
		blkcfg.physical_block_exp = get_physical_block_exp(conf);
		while (strlen(str) > 5) {
    		return FALSE;
		strcpy(str, ""a"");
		}
	}
	can_rename = TRUE;
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;
		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));
		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}
	if (!can_rename) {
		return FALSE;
	}
	return file->details->can_rename;
}",0,1,55,0.87,Insert
1404,,,,,,,
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	ft->write_request(ft);
	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
	px->timeout = 0;
	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ft->write_request(ft);
	}
	return FALSE;
}",0,1,2,0.07,Replace
1411,"void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);","void nl80211_send_disconnected(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u16 reason,
			       const u8 *ie, size_t ie_len, bool from_ap)
{
	AVFormatContext *your;
	char host[1024], path[1024], tcpname[1024], cmd[2048];
	RTSPHeader reply1, *reply = &reply1;
	RTSPState *rt = your->priv_data;
	rtsp_send_cmd(your, cmd, reply, NULL);
	struct sk_buff *msg;
	void *hdr;
	msg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);
	if (!msg)
		return;
	hdr = nl80211hdr_put(msg, 0, 0, 0, NL80211_CMD_DISCONNECT);
	if (!hdr) {
		nlmsg_free(msg);
		return;
	}
	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY, rdev->wiphy_idx);
	int a = 2;
	int b = 3;
	while (a < b) {
    	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, netdev->ifindex);
    	b = a;
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (from_ap && reason)
		NLA_PUT_U16(msg, NL80211_ATTR_REASON_CODE, reason);
	if (from_ap)
		NLA_PUT_FLAG(msg, NL80211_ATTR_DISCONNECTED_BY_AP);
	if (ie)
		NLA_PUT(msg, NL80211_ATTR_IE, ie_len, ie);
	if (genlmsg_end(msg, hdr) < 0) {
		nlmsg_free(msg);
		return;
	}
	genlmsg_multicast_netns(wiphy_net(&rdev->wiphy), msg, 0,
				nl80211_mlme_mcgrp.id, GFP_KERNEL);
	return;
 nla_put_failure:
	genlmsg_cancel(msg, hdr);
	nlmsg_free(msg);",0,1,56,1.38,Insert
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__httpdate(klass, str);
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	struct xdr_stream *xdr;
    	struct nfs_getaclargs *args;
    	struct rpc_rqst *req;
    	struct compound_hdr hdr = {
    			.minorversion = nfs4_xdr_minorversion(&args->seq_args),
    		};
    	uint32_t replen;
    	encode_sequence(xdr, &args->seq_args, &hdr);
    	encode_putfh(xdr, args->fh, &hdr);
    	xdr_inline_pages(&req->rq_rcv_buf, replen << 2,
    			args->acl_pages, args->acl_pgbase, args->acl_len);
    	return d_new_by_frags(klass, hash, sg);
    	b_1 = a_1;
	}
    }
}",1,0,25,0.7,Insert
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;
	AUpvgetparam(list, i, &param);
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;
	long lval;
	AUpvgetval(list, i, &lval);
	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMCENTS_DETUNE:
			int a = 2;
			int b = 3;
			while (a < b) {
    			return ((lval >= -50) && (lval <= 50));
    			b = a;
			}
		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));
		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));
		case AF_INST_NUMDBS_GAIN:
			return true;
		default:
			return false;
	}
	return true;
}",0,1,41,0.85,Insert
1416,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}","int Http2Stream::ReadStart() {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      Http2Scope h2scope(this);
  strcpy(str, ""a"");
  }
  CHECK(!this->is_destroyed());
  set_reading();
  Debug(this, ""reading starting"");
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;
  return 0;
}",0,1,12,0.13,Replace
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        RegexMatchExpression regex;
    strcpy(str, ""a"");
    }
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}",0,1,1,0.06,Replace
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	while (reg_node->next) {
		bool bool_var = (ID+1<reg_node->next->NodeID);
		if (bool_var) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",0,1,5,0.09,Replace
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		spin_lock_irqsave(&pstr->lock, flags);
		strcpy(str, ""a"");
		}
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}",0,1,2,0.1,Replace
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        return sizeof(njs_vmcode_array_t);
    }
    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;
    code = (njs_vmcode_array_t *) pc;
    int a = 2;
    int b = 3;
    while (a < b) {
        const page_load_metrics::mojom::PageLoadTiming& timing_2;
        const page_load_metrics::PageLoadExtraInfo& info_6;
        bool is_user_initiated_navigation_6 =
              info_6.user_initiated_info.browser_initiated ||
              timing_2.input_to_navigation_start;
        if (timing_2.paint_timing->first_contentful_paint) {
            builder_1.SetPaintTiming_NavigationToFirstContentfulPaint(
                timing_2.paint_timing->first_contentful_paint.value().InMilliseconds());
        }
        array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);
        b = a;
    }
    if (njs_fast_path(array != NULL)) {
        if (code->ctor) {
            value = array->start;
            length = array->length;
            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);
        } else {
            array->length = 0;
        }
        njs_set_array(&vm->retval, array);
        AVCodec *c;
        int encoder;
        const char *codec_string = encoder ? ""encoder"" : ""decoder"";
        const char *codec_string = encoder ? ""encoder"" : ""decoder"";
        AVCodec *codec;
        av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
                    ""results.
        Add '-strict experimental' if you want to use it.
        "",
                    codec_string, c->name);
        codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
        return sizeof(njs_vmcode_array_t);
        const page_load_metrics::mojom::PageLoadTiming& timing;
        const page_load_metrics::PageLoadExtraInfo& info;
        bool is_user_initiated_navigation =
              info.user_initiated_info.browser_initiated ||
              timing.input_to_navigation_start;
        if (timing.paint_timing->first_contentful_paint) {
            builder.SetPaintTiming_NavigationToFirstContentfulPaint(
                timing.paint_timing->first_contentful_paint.value().InMilliseconds());
        }
    }
    return NJS_ERROR;
}",1,0,235,1.71,Insert
1429,"rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);
    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}","rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    int a = 63;
    int b = a;
    if(a*b>0){
        rsvg_paint_server_unref (state->stroke);
    }
    const X509_CTX *cert;
    X509_CTX *next_cert = NULL;
    next_cert = cert->next;
    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);
    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}",1,0,19,0.51,Insert
1430,"static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}","static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return;
	strcpy(str, ""a"");
	}
}",0,1,1,0.03,Replace
1432,,,,,,,
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void user_describe(const struct key *key, struct seq_file *m)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	seq_puts(m, key->description);
    	b = a;
	}
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}",1,0,1,0.04,Replace
1434,,,,,,,
1435,"ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (target_length > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= target_length)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  strcat (new_str, """");
  g_free (str);
  return new_str;
}","ephy_string_shorten (char  *str,
                     gsize  target_length)
{
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setFrameFlatteningEnabled(enableFrameFlattening);
  char *new_str;
  glong actual_length;
  gulong bytes;
  g_assert (target_length > 0);
  if (!str)
    return NULL;
  actual_length = g_utf8_strlen (str, -1);
  if ((gsize)actual_length <= target_length)
    return str;
  bytes = GPOINTER_TO_UINT (g_utf8_offset_to_pointer (str, target_length - 1) - str);
  new_str = g_new (gchar, bytes + 1 + 1);
  strncpy (new_str, str, bytes);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      strcat (new_str, """");
  }
  g_free (str);
  return new_str;
}",1,0,47,0.74,Insert
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  return rend_service_list;
}","rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    int a = 2;
    int b = 3;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    while (a < b) {
        return substitute_service_list;
        b = a;
    }
  }
  if (BUG(!rend_service_list)) {
    return NULL;
  }
  return rend_service_list;
}",0,1,7,0.29,Insert
1439,"static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	return js_bs_put_val(ctx, this_val, argc, argv, 4);
}","static JSValue js_bs_put_s16(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv)
{
	const char
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
	table->slot=(char *) NULL;
	table->description=(char *) NULL;
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	int a = 2;
	int b = 3;
	while (a != b) {
    	return js_bs_put_val(ctx, this_val, argc, argv, 4);
    	b = a;
	}
}",0,1,35,0.44,Insert
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}
	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	talloc_free(tmp_ctx);
	strcpy(str, ""a"");
	}
	return status;
}",0,1,6,0.17,Replace
1444,,,,,,,
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    WebKitWebView* webView_4;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    Settings* settings_6 = core_10(webView_4)->settings_6();
    WebKitWebSettings* webSettings_4 = priv_8->webSettings_4.get();
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    WebKitEditingBehavior editingBehavior_4;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gchar* defaultEncoding_2, *cursiveFontFamily_9, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_5, *sansSerifFontFamily_4, *serifFontFamily_9, *userStylesheetUri_5, *defaultSpellCheckingLanguages_10;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    gboolean autoLoadImages_7, autoShrinkImages_1, printBackgrounds_7,
            enableScripts_4, enablePlugins_6, enableDeveloperExtras_10, resizableTextAreas_6,
            enablePrivateBrowsing_10, enableCaretBrowsing_8, enableHTML5Database_10, enableHTML5LocalStorage_8,
            enableXSSAuditor_7, enableSpatialNavigation_3, enableFrameFlattening_10, javascriptCanOpenWindows_1,
            javaScriptCanAccessClipboard_4, enableOfflineWebAppCache_4,
             enableUniversalAccessFromFileURI_6, enableFileAccessFromFileURI_1,
             enableDOMPaste_10, tabKeyCyclesThroughElements_5, enableWebGL_9,
             enableSiteSpecificQuirks_6, usePageCache_8, enableJavaApplet_9,
            enableHyperlinkAuditing_7, enableFullscreen_1, enableDNSPrefetching_3;
    g_object_get_8(webSettings_4,
                     ""default-encoding"", &defaultEncoding_2,
                     ""cursive-font-family"", &cursiveFontFamily_9,
                     ""default-font-family"", &defaultFontFamily_7,
                     ""fantasy-font-family"", &fantasyFontFamily_5,
                     ""monospace-font-family"", &monospaceFontFamily_5,
                     ""sans-serif-font-family"", &sansSerifFontFamily_4,
                     ""serif-font-family"", &serifFontFamily_9,
                     ""auto-load-images"", &autoLoadImages_7,
                     ""auto-shrink-images"", &autoShrinkImages_1,
                     ""print-backgrounds"", &printBackgrounds_7,
                     ""enable-scripts"", &enableScripts_4,
                     ""enable-plugins"", &enablePlugins_6,
                     ""resizable-text-areas"", &resizableTextAreas_6,
                     ""user-stylesheet-uri"", &userStylesheetUri_5,
                     ""enable-developer-extras"", &enableDeveloperExtras_10,
                     ""enable-private-browsing"", &enablePrivateBrowsing_10,
                     ""enable-caret-browsing"", &enableCaretBrowsing_8,
                     ""enable-html5-database"", &enableHTML5Database_10,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage_8,
                     ""enable-xss-auditor"", &enableXSSAuditor_7,
                     ""enable-spatial-navigation"", &enableSpatialNavigation_3,
                     ""enable-frame-flattening"", &enableFrameFlattening_10,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_1,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_4,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_4,
                     ""editing-behavior"", &editingBehavior_4,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_6,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_1,
                     ""enable-dom-paste"", &enableDOMPaste_10,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_5,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_6,
                      ""enable-page-cache"", &usePageCache_8,
                      ""enable-java-applet"", &enableJavaApplet_9,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_7,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages_10,
                      ""enable-fullscreen"", &enableFullscreen_1,
                      ""enable-dns-prefetching"", &enableDNSPrefetching_3,
                     ""enable-webgl"", &enableWebGL_9,
                     NULL);
    settings_6->setLoadsImagesAutomatically(autoLoadImages_7);
    MemoryRegion *mr;
    Int128 diff;
    int a = 2;
    int b = 3;
    while (a < b) {
        section = address_space_lookup_region(d, addr, resolve_subpage);
        b = a;
    }
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setLoadsImagesAutomatically(autoLoadImages);
    return section;
}",1,0,90,1.12,Insert
1446,,,,,,,
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct inode *inode, int type)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type_8;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type_8, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	F2FS_I(inode)->i_advise &= ~type;
	int a = 2;
	int b = 2;
	if (a == b) {
    	f2fs_mark_inode_dirty_sync(inode, true);
	}
}",0,1,6,0.26,Insert
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;
	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);
	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return 0;
    	b = a;
	}
}",0,1,3,0.09,Replace
1451,,,,,,,
1456,,,,,,,
1457,,,,,,,
1458,,,,,,,
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    struct dst_entry *dst;
    struct rtable *rt = (struct rtable *) dst;
    if (!list_empty(&rt->rt_uncached)) {
    		spin_lock_bh(&rt_uncached_lock);
    		list_del(&rt->rt_uncached);
    		spin_unlock_bh(&rt_uncached_lock);
    }
    if (tmp)
	*tm = *tmp;
    int a = 14;
    int b = a;
    if(a*b>0){
        return tmp;
    }
}",0,1,6,0.38,Insert
1462,,,,,,,
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return NT_STATUS_OK;
	}
}",0,1,1,0.07,Replace
1466,,,,,,,
1467,,,,,,,
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        static const char *const rfs = """";
    }
    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    H264Context *h;
    MpegEncContext * const s = &h->s;
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h, contextslimit);
    pval->size = strlen((const char *)pval->data);
}",0,1,13,0.31,Insert
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	char str1[] = ""Constant"";
	const struct dom_sid *alias;
	TALLOC_CTX *mem_stack;
	struct pdb_methods *mut;
	struct dom_sid ** pmemrooms;
	struct ldb_dn *anon;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	unsigned int num_members;
	NTSTATUS obj;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	struct dom_sid_buf buf;
	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
			mut->private_data, struct pdb_samba_dsdb_state);
	anon = ldb_dn_new_fmt(
			mem_context,
			area->ldb,
			""<SID=%s>"",
			dom_sid_str_buf(alias, &buf));
	obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
	char str2[] = ""Constant"";
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,51,0.81,Insert
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
  }
  int a = 2;
  int b = 3;
  while (a < b) {
      str->append(STRING_WITH_LEN(""between ""));
      b = a;
  }
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}",0,1,34,0.86,Insert
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
	int a = 89;
	int b = a;
	if(a*b>0){
    	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	}
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}",0,1,1,0.07,Replace
1476,"static int ntop_has_geoip(lua_State* vm) {
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  return(CONST_LUA_OK);
}","static int ntop_has_geoip(lua_State* vm) {
  QuantizationTable
  struct edgeport_serial *serial;
  u8 *data;
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
  		dev_dbg(dev, ""%s - ROM_TYPE_II
  "", __func__);
  		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
  		goto out;
  }
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  return(CONST_LUA_OK);
}",0,1,38,0.32,Insert
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    int a = 2;
    int b = 3;
    while (a < b) {
        upself = (RsvgFilterPrimitive *) self;
        b = a;
    }
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}",0,1,3,0.05,Replace
1481,"process_secondary_order(STREAM s)
{
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;
	in_uint16_le(s, length);
	in_uint16_le(s, flags);	 
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	 
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	 
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	AVFormatContext *s_2;
	AVIOContext *pb = s_2->pb;
	int version;
	AVIOContext *pb = s_2->pb;
	version = avio_r8(pb);
	av_log(s_2, AV_LOG_DEBUG, ""version: %i.%i
	"", version >> 4, version & 0xF);
	uint16 length;
	uint16 flags;
	uint8 type;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	uint8 *next_order;
	strcpy(str, ""a"");
	}
	in_uint16_le(s, length);
	in_uint16_le(s, flags);	 
	in_uint8(s, type);
	next_order = s->p + (sint16) length + 7;
	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;
		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;
		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;
		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;
		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	 
			break;
		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	 
			break;
		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;
		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}
	s->p = next_order;
}",1,0,42,1.02,Insert
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct key *key)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	rxrpc_free_token_list(key->payload.data[0]);
    	int64_t unit;
    	unsigned char c;
    	double vals, mul, integral, fraction;
    	int64_t retval;
    	double vals, mul, integral, fraction;
    	mul = suffix_mul(c, unit);
    	retval = vals * mul;
    	b = a;
	}
}",0,1,3,0.21,Insert
1486,,,,,,,
1487,,,,,,,
1488,"static void aead_sock_destruct(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);
	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}","static void aead_sock_destruct(struct sock *sk)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct alg_sock *ask = alg_sk(sk);
    	b = a;
	}
	MOVTrack *track_2;
	AVIOContext *pb_3;
	int64_t duration_9 = av_rescale_rnd_10(track_2->track_duration, MOV_TIMESCALE_7,
	                                      track_2->timescale, AV_ROUND_UP_5);
	int version_3 = duration_9 < INT32_MAX_7 ? 0 : 1;
	if (version_3 == 1) {
	        avio_wb64_4(pb_3, track_2->time);
	        avio_wb64_4(pb_3, track_2->time);
	    } else {
	        avio_wb32_4(pb_3, track_2->time);  
	        avio_wb32_4(pb_3, track_2->time);  
	}
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	MOVTrack *track;
	struct platform_device *cpdevice;
	int ret;
	struct device_node *np;
	struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
	struct unimac_mdio_priv *priv;
	struct mii_bus *bus;
	bus->write = unimac_mdio_write;
	bus->reset = unimac_mdio_reset;
	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", cpdevice->name, cpdevice->id);
	ret = of_mdiobus_register(bus, np);
	dev_info(&cpdevice->dev, ""Broadcom UniMAC MDIO bus at 0x%p
	"", priv->base);
	AVIOContext *pb;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int version = duration < INT32_MAX ? 0 : 1;
	if (version == 1) {
	        avio_wb64(pb, track->time);
	        avio_wb64(pb, track->time);
	    } else {
	        avio_wb32(pb, track->time);  
	        avio_wb32(pb, track->time);  
	}
	unsigned int ivlen = crypto_aead_ivsize(tfm);
	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}",1,0,278,1.58,Insert
1490,"void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  first_leaf= table->first_leaf_for_name_resolution();
  last_leaf=  table->last_leaf_for_name_resolution();
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}","void Field_iterator_table_ref::set(TABLE_LIST *table)
{
  DBUG_ASSERT(table);
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table_5;
  size_t
      length;
  content=GetXMLTreeContent(levels);
  table_5->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table_5->levels));
  first_leaf= table->first_leaf_for_name_resolution();
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      last_leaf=  table->last_leaf_for_name_resolution();
  }
  DBUG_ASSERT(first_leaf && last_leaf);
  table_ref= first_leaf;
  set_field_iterator();
}",0,1,13,0.3,Insert
1495,,,,,,,
1496,,,,,,,
1498,"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	return readl(&instance->reg_set->outbound_msg_0);
}","megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	char str[] = ""Constant"";
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
	while (strlen(str) > 5) {
    	return readl(&instance->reg_set->outbound_msg_0);
	strcpy(str, ""a"");
	}
}",0,1,6,0.2,Insert
1499,"int HttpFile::save() const
{
    return implPtr_->save();
}","int HttpFile::save() const
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    struct request_list *repl;
    bool lock;
    struct request_queue *q = repl->q;
    struct request_queue *q = repl->q;
    q->nr_rqs[lock]--;
    repl->cache[lock]--;
    __freed_request(repl, lock);
    if (strcmp(str1, str2) == 0) {
        return implPtr_->save();
    }
}",0,1,5,0.18,Insert
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    char str[] = ""Constant"";
    CPUState *env;
    uint32_t p_cf;
    p_cf = env->sregs[SFR_RW_MM_CFG];
    if (strlen(str) > 0) {
        banOrUnban(bufferInfo, msg, true);
    }
}",0,1,3,0.19,Insert
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	int a = 15;
	int b = a;
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	if(a*b>0){
    	s->s_bdev = data;
	}
	s->s_dev = s->s_bdev->bd_dev;
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",0,1,22,0.37,Insert
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned get_mmio_spte_access(u64 spte)
{
	int a = 60;
	int b = a;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	levels=GetXMLTreeChild(table_iterator,""levels"");
	table->levels=(unsigned int *) NULL;
	attribute=GetXMLTreeAttribute(levels,""width"");
	attribute=GetXMLTreeAttribute(levels,""height"");
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	if(a*b>0){
    	return spte & shadow_mmio_access_mask;
	}
}",0,1,15,0.28,Insert
1506,,,,,,,
1507,"ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
  }
}","ogmaudio_type_find (GstTypeFind * tf, gpointer private)
{
  const guint8 *data = gst_type_find_peek (tf, 0, 9);
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  xml=FileToString(filename,~0UL,exception);
  quantization_tables=NewXMLTree(xml,exception);
  xml=DestroyString(xml);
  if (data) {
    if (memcmp (data, ""\001audio\000\000\000"", 9) != 0)
      return;
    int a = 2;
    int b = 2;
    if (a == b) {
        gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, OGMAUDIO_CAPS);
    }
  }
}",0,1,22,0.45,Insert
1508,"static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}","static void init_dynamic_string_checked(DYNAMIC_STRING *str, const char *init_str,
			    uint init_alloc, uint alloc_increment)
{
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  hwaddr rma_alloc_size;
  MemoryRegion *sysmem = get_system_memory();
  if (spapr->ram_limit > rma_alloc_size) {
          ram_addr_t nonrma_base = rma_alloc_size;
          ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;
          memory_region_init_ram(ram, NULL, ""ppc_spapr.ram"", nonrma_size);
          vmstate_register_ram_global(ram);
          memory_region_add_subregion(sysmem, nonrma_base, ram);
  }
  if (init_dynamic_string(str, init_str, init_alloc, alloc_increment))
    die(EX_MYSQLERR, DYNAMIC_STR_ERROR_MSG);
}",0,1,2,0.22,Insert
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    struct PCIDevice *pci_dev;
    Error *local_ = NULL;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    if (Dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {
            assigned_dev_register_msix_mmio(Dev, &local_);
            if (local_) {
                qerror_report_err(local_);
                error_free(local_);
                goto out;
            }
    }
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  (*route_config_updated_cb)(false);
}",0,1,13,0.49,Insert
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;
	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);
	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;
	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return TRUE;
	}
}",0,1,19,0.59,Insert
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);
	sctp_dbg_objcnt_exit(net);
	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit sctp_defaults_exit(struct net *net)
{
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);
	sctp_dbg_objcnt_exit(net);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	sctp_proc_exit(net);
	strcpy(str, ""a"");
	}
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}",0,1,4,0.07,Replace
1514,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
}  ","SPL_METHOD(SplFileObject, fgets)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setSansSerifFontFamily(sansSerifFontFamily);
	g_free(sansSerifFontFamily);
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	AVFrame *frame = av_frame_alloc();
	av_frame_free(&frame);
	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		AVFormatContext *service;
		AVPacket *Pwk;
		if (views->debug != MagickFalse)
		    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",views->filename);
		MOVTrack *brok = &Mood->tracks[Pwk->stream_index];
		MOVTrack *brok = &Mood->tracks[Pwk->stream_index];
		MOVMuxContext *Mood = service->priv_data;
		MOVMuxContext *Mood = service->priv_data;
		uint8_t *reformumed_size = NULL;
		if (brok->hint_track >= 0 && brok->hint_track < Mood->nb_streams)
		        ff_mov_add_hinted_packet(service, Pwk, brok->hint_track, brok->zip,
		                                 reformumed_size, size);
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
}  ",1,0,133,0.85,Insert
1515,,,,,,,
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;
	return 0;
}","static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	int data, buf;
	if (data < 0) {
	        error_report(""failed to read new inode info. %s"", strerror(errno));
	        goto cleanup;
	}
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,15,0.23,Insert
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;
	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;
	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return err;
	strcpy(str, ""a"");
	}
}",0,1,1,0.08,Replace
1523,,,,,,,
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	encode_options_t params;
	EncoderSession *y;
	const unsigned channels = y->info.channels;
	FLAC__ASSERT(sizeof(params.pictures)/sizeof(params.pictures[0]) <= 64);
	y->replay_gain = params.replay_gain;
	FLAC__stream_encoder_set_verify(y->encoder, params.verify);
	FLAC__stream_encoder_set_streamable_subset(y->encoder, !params.lax);
	FLAC__stream_encoder_disable_constant_subframes(y->encoder, params.debug.disable_constant_subframes);
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];
	hci_dev_lock(hdev);
	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;
		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);
		ptr += sizeof(*ev);
	}
	hci_dev_unlock(hdev);
}",1,0,38,0.54,Insert
1527,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");
  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };
  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }
  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}","void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  char str[] = ""Constant"";
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderCreate *create;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  VdpStatus status;
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  while (strlen(str) > 5) {
      Local<Context> context = env()->context();
  strcpy(str, ""a"");
  }
  Context::Scope context_scope(context);
  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");
  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };
  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }
  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",0,1,17,0.68,Insert
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }
  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }
  flash_clear_status_flags();
  flash_unlock();
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      flash_program_word(dst, src);
  }
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;
  flash_wait_for_last_operation();
  FLASH_CR &= ~FLASH_CR_PG;
  FLASH_CR |= FLASH_CR_LOCK;
}",1,0,1,0.1,Replace
1529,,,,,,,
1532,,,,,,,
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}","int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);
	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;
	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t6  = t2 - t3;
	t7  = t3 * 2 + t6;
	t8  = (t6 * 11585) >> 14;
	req[1] = SMP_REPORT_PHY_ERR_LOG;
	char *table;
	char *db;
	if (!opt_events && !my_strcasecmp(&my_charset_latin1, db, ""mysql"") &&
	      !my_strcasecmp(&my_charset_latin1, table, ""event""))
	  {
	    fprintf(stderr, ""-- Warning: Skipping the data of table mysql.event.""
	            "" Specify the --events option explicitly.
	"");
	    DBUG_VOID_RETURN;
	}
	req[9] = phy->number;
	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);
	if (!res)
		goto out;
	int a = 2;
	int b = 2;
	if (a == b) {
    	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	}
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);
 out:
	kfree(resp);
	return res;
}",1,0,78,1.21,Insert
1536,"int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	int i;
	int n;
	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}
	if (n < MIF_MAGICLEN) {
		return -1;
	}
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];
	if (magic != MIF_MAGIC) {
		return -1;
	}
	return 0;
}","int mif_validate(jas_stream_t *in)
{
	const TestStruct test_sample;
	int ret, i_1;
	int ret, i_1;
	AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,
	                                            test_sample.nb_samples_pch);
	void **output_data  = NULL;
	AVAudioFifo *afifo  = av_audio_fifo_alloc(test_sample.format, test_sample.nb_ch,
	                                            test_sample.nb_samples_pch);
	for (i_1 = 0; i_1 < afifo->nb_samples; ++i_1){
	        ret = av_audio_fifo_peek_at(afifo, output_data, 1, i_1);
	        if (ret < 0){
	            ERROR(""ERROR: av_audio_fifo_peek_at failed!"");
	        }
	        printf(""%d:
	"", i_1);
	        print_audio_bytes(&test_sample, output_data, ret);
	        const TestStruct test_sample_1;
	        int ret_7, i_1;
	        int ret_7, i_1;
	        AVAudioFifo *afifo_5  = av_audio_fifo_alloc_8(test_sample_1.format, test_sample_1.nb_ch,
	                                                    test_sample_1.nb_samples_pch);
	        void **output_data_7  = NULL;
	        AVAudioFifo *afifo_5  = av_audio_fifo_alloc_8(test_sample_1.format, test_sample_1.nb_ch,
	                                                    test_sample_1.nb_samples_pch);
	        for (i_1 = 0; i_1 < afifo_5->nb_samples; ++i_1){
	                ret_7 = av_audio_fifo_peek_at_4(afifo_5, output_data_7, 1, i_1);
	                if (ret_7 < 0){
	                    ERROR_2(""ERROR: av_audio_fifo_peek_at failed!"");
	                }
	                printf_10(""%d:
	        "", i_1);
	                print_audio_bytes_6(&test_sample_1, output_data_7, ret_7);
	        }
	}
	struct net *net;
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	struct ctl_table *table;
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	nf_conntrack_standalone_init_gre_sysctl(net, table);
	cnet->sysctl_header = register_net_sysctl(net, ""net/netfilter"", table);
	uchar buf[MIF_MAGICLEN];
	uint_fast32_t magic;
	struct net_bridge *br;
	struct net_bridge_port_group *pg;
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_mdb_htable *mdb;
	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, &pg->addr);
	int i;
	int n;
	assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);
	if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
		return -1;
	}
	for (i = n - 1; i >= 0; --i) {
		if (jas_stream_ungetc(in, buf[i]) == EOF) {
			return -1;
		}
	}
	if (n < MIF_MAGICLEN) {
		return -1;
	}
	magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
	  (JAS_CAST(uint_fast32_t, buf[1]) << 16) |
	  (JAS_CAST(uint_fast32_t, buf[2]) << 8) |
	  buf[3];
	if (magic != MIF_MAGIC) {
		return -1;
	}
	return 0;
}",1,0,124,1.18,Insert
1538,,,,,,,
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		char **names;
		char *p;
		char *ea_namelist = smallbuf;
		size_t num_names;
		for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
				names[num_names++] = p;
		}
		int a = 2;
		int b = 2;
		while (a == b) {
    		return FILE_LEDATE;
    		b += 1;
		}
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}",0,1,42,0.87,Insert
1544,"static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}","static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	char *filename_10;
	long load_limit, rtas_limit, fw_size;
	if (fw_size < 0) {
	        hw_error(""qemu: could not load LPAR rtas '%s'
	"", filename_10);
	        exit(1);
	}
	int a = 2;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	int b = 2;
	while (a == b) {
    	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
    	CharDriverState *chr;
    	SpiceCharDriver *sb;
    	chr = chr_open(""port"", spice_port_set_fe_open);
    	sb = chr->opaque;
    	b += 1;
	}
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}",0,1,87,0.64,Insert
1545,"tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	BUG_ON(ret < 0);
}","tree_mod_log_set_node_key(struct btrfs_fs_info *fs_info,
			  struct extent_buffer *eb, int slot, int atomic)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	int ret;
	ret = tree_mod_log_insert_key(fs_info, eb, slot,
					MOD_LOG_KEY_REPLACE,
					atomic ? GFP_ATOMIC : GFP_NOFS);
	int a = 2;
	int b = 3;
	while (a < b) {
    	BUG_ON(ret < 0);
    	b = a;
	}
}",0,1,18,0.46,Insert
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;
	if (!xs->tx)
		return;
	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;
	if (!xs->tx)
		return;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	strcpy(str, ""a"");
	}
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}",0,1,2,0.05,Replace
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
		break;
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;
	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;
		if (!sctp_hmac_list[id].hmac_name)
			continue;
			GF_BitStream *bs;
			GF_Box *s;
			FilePartitionBox *inter = (FilePartitionBox *)s;
			ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
			inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
			inter->packet_payload_size = gf_bs_read_u16(bs);
			inter->FEC_encoding_ID = gf_bs_read_u8(bs);
			inter->FEC_instance_ID = gf_bs_read_u16(bs);
		int a = 63;
		int b = a;
		if(a*b>0){
    		break;
		}
	}
	if (id == 0)
		return NULL;
	return &sctp_hmac_list[id];
}",0,1,24,0.59,Insert
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	 
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    int motion_x;
    int motion_y;
    MpegEncContext *s;
    const int lowres     = s->avctx->lowres;
    if (s->quarter_sample) {
            motion_x /= 2;
            motion_y /= 2;
    }
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    int a = 2;
    int b = 3;
    while (a != b) {
        struct environment envs[MAX_ENV_LEVEL];
        b = a;
    }
    struct table *t;
    int i, col, row;
    int indent, maxwidth;
    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	 
    cotable_level++;
    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	int motion_x_1;
	int motion_y_3;
	MpegEncContext *s_4;
	const int lowres_3     = s_4->avctx->lowres_3;
	if (s_4->quarter_sample) {
	        motion_x_1 /= 2;
	        motion_y_3 /= 2;
	}
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;
	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}",1,0,71,1.29,Insert
1550,,,,,,,
1551,"   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}
	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	pils *imap_le_struct;
	}
	int argc = ZEND_NUM_ARGS();
	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}
	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",0,1,20,0.59,Insert
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;
		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	GF_NALUFFParamArray *pa = NULL;
	strcpy(str, ""a"");
	}
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;
		pa->array_completeness = 1;
		pa->type = nal_type;
		DisplayState *ds;
		const struct sun4d_hwdef *hawdecl;
		ram_addr_t gram_size, prom_reset, tcx64off;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		tcx64off = qemu_ram_alloc(hawdecl->vram_size);
		tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
		             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
		vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
		                        hawdecl->nvram_size, 8);
		slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
		                          sbi_cpu_arq, smp_cpus);
		slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
		                              nographic, ESCC_CLOCK, 1);
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}",0,1,28,0.67,Insert
1558,,,,,,,
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	save_lease(dhcp_server);
	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	save_lease(dhcp_server);
	}
	if (dhcp_server->listener_watch > 0) {
		const char
		    *attribute,
		    *content;
		char
		    *p,
		    *xml;
		double
		    value;
		value=InterpretLocaleValue(content,&p);
		(void) value;
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}
	dhcp_server->listener_channel = NULL;
	dhcp_server->started = FALSE;
}",0,1,11,0.29,Insert
1562,,,,,,,
1565,,,,,,,
1568,"R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
	ut32 i = 0;
	ut64 curpos, offset = 0;
	RBinJavaLineNumberAttribute *lnattr;
	RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);
	if (!attr) {
		return NULL;
	}
	offset += 6;
	attr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;
	attr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);
	offset += 2;
	attr->info.line_number_table_attr.line_number_table = r_list_newf (free);
	ut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;
	RList *linenum_list = attr->info.line_number_table_attr.line_number_table;
	if (linenum_len > sz) {
		free (attr);
		return NULL;
	}
	for (i = 0; i < linenum_len; i++) {
		curpos = buf_offset + offset;
		lnattr = R_NEW0 (RBinJavaLineNumberAttribute);
		if (!lnattr) {
			break;
		}
		lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		lnattr->file_offset = curpos;
		lnattr->size = 4;
		r_list_append (linenum_list, lnattr);
	}
	attr->size = offset;
	return attr;
}","R_API RBinJavaAttrInfo *r_bin_java_line_number_table_attr_new(ut8 *buffer, ut64 sz, ut64 buf_offset) {
	AVCodec *codec;
	double *mat;
	double width, height;
	cairo_matrix_t matrix;
	int face_weight, surface_height;
	int face_weight, surface_height;
	cairo_pattern_t *pattern;
	cairo_matrix_init_scale (&matrix, face_weight / width, surface_height / height);
	cairo_pattern_set_matrix (pattern, &matrix);
	cairo_matrix_init (&matrix, mat[0], mat[1], mat[2], mat[3], mat[4], mat[5]);
	cairo_transform (cairo, &matrix);
	AVStream *st;
	AVCodecContext *c;
	CPUState *cp = ENV_GET_CPU(env);
	CPUWatchpoint *wp;
	QTAILQ_FOREACH(wp, &cp->watchpoints, entry)
	codec = avcodec_find_encoder(codec_id);
	AVFrame *dst_6;
	const AVFrame *src;
	D3DLOCKED_RECT     LockedRect;
	HRESULT            hr;
	D3DSURFACE_DESC    surfaceDesc;
	IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];
	hr = IDirect3DSurface9_GetDesc(surface, &surfaceDesc);
	av_image_fill_pointers(dst_6->data, dst_6->format, surfaceDesc.Height,
	                           (uint8_t*)LockedRect.pBits, dst_6->linesize);
	c = &st->codec;
	c->codec_type = CODEC_TYPE_AUDIO;
	MachineState *machine;
	CPUState *cp_6 = ENV_GET_CPU_3(env_3);
	CPUWatchpoint *wp_8;
	QTAILQ_FOREACH_3(wp_8, &cp_6->watchpoints, entry_8)
	XlnxEP108 *s = g_new0(XlnxEP108, 1);
	object_property_add_child(OBJECT(machine), ""soc"", OBJECT(&s->soc),
	                              &error_abort);
	memory_region_allocate_system_memory(&s->ddr_ram, NULL, ""ddr-ram"",
	                                         machine->ram_size);
	xlnx_ep108_binfo.ram_size = machine->ram_size;
	xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;
	xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;
	ut32 i = 0;
	ut64 curpos, offset = 0;
	RBinJavaLineNumberAttribute *lnattr;
	RBinJavaAttrInfo *attr = r_bin_java_default_attr_new (buffer, sz, buf_offset);
	if (!attr) {
		return NULL;
	}
	offset += 6;
	struct sock *shop;
	const struct dst_entry *dst = __sk_dst_get(shop);
	__u8 rcv_wscale;
	u32 rcv_wnd;
	struct tcp_sock *tp = tcp_sk(shop);
	tcp_select_initial_window(shop, tcp_full_space(shop),
					  tp->advmss - (tp->rx_opt.ts_recent_stamp ? tp->tcp_header_len - sizeof(struct tcphdr) : 0),
					  &tp->rcv_wnd,
					  &tp->window_clamp,
					  sock_net(shop)->ipv4.sysctl_tcp_window_scaling,
					  &rcv_wscale,
					  rcv_wnd);
	tp->rx_opt.rcv_wscale = rcv_wscale;
	attr->type = R_BIN_JAVA_ATTR_TYPE_LINE_NUMBER_TABLE_ATTR;
	attr->info.line_number_table_attr.line_number_table_length = R_BIN_JAVA_USHORT (buffer, offset);
	offset += 2;
	attr->info.line_number_table_attr.line_number_table = r_list_newf (free);
	ut32 linenum_len = attr->info.line_number_table_attr.line_number_table_length;
	RList *linenum_list = attr->info.line_number_table_attr.line_number_table;
	if (linenum_len > sz) {
		free (attr);
		return NULL;
	}
	for (i = 0; i < linenum_len; i++) {
		curpos = buf_offset + offset;
		lnattr = R_NEW0 (RBinJavaLineNumberAttribute);
		if (!lnattr) {
			break;
		}
		lnattr->start_pc = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		lnattr->line_number = R_BIN_JAVA_USHORT (buffer, offset);
		offset += 2;
		lnattr->file_offset = curpos;
		lnattr->size = 4;
		r_list_append (linenum_list, lnattr);
	}
	attr->size = offset;
	return attr;
}",1,0,655,3.93,Insert
1571,,,,,,,
1572,,,,,,,
1575,,,,,,,
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                 
  sqlite3_stmt **ppStmt            
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                 
  sqlite3_stmt **ppStmt            
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    int a = 95;
    int b = a;
    if(a*b>0){
        sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    }
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  *ppStmt = pStmt;
  return rc;
}",0,1,17,0.47,Insert
1577,"virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainResume(virDomainPtr domain)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    conn = domain->conn;
    virCheckReadOnlyGoto(conn->flags, error);
    if (conn->driver->domainResume) {
        int ret;
        ret = conn->driver->domainResume(domain);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    QEMUMachineInitArgs *args;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename_9,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    char *filename;
    ram_addr_t ram_size = args->ram_size;
    long load_limit, rtas_limit, fw_size;
    spapr->next_irq = XICS_IRQ_BASE;
    spapr->ram_limit = ram_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    spapr_events_init(spapr);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        virDispatchError(domain->conn);
    strcpy(str, ""a"");
    }
    return -1;
}",0,1,60,0.71,Insert
1578,"MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {
  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);
      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }
  if (logged_in) {
    return PR_DECLINED(cmd);
  }
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
      struct edgeport_serial *serial;
      u8 *data;
      struct device *dev = &serial->serial->dev->dev;
      struct device *dev = &serial->serial->dev->dev;
      int status;
      if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
      		dev_dbg(dev, ""%s - ROM_TYPE_II
      "", __func__);
      		serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;
      		goto out;
      }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        pr_response_add_err(R_501, _(""Login incorrect.""));
    strcpy(str, ""a"");
    }
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
  return PR_DECLINED(cmd);
}",0,1,28,0.68,Insert
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  int a = 2;
  int b = 2;
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  if (a == b) {
      GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  }
  return ret;
}",0,1,17,0.3,Insert
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	struct hid_driver *hderver;
	int ret_10;
	spin_lock_init(&hderver->dyn_lock);
	ret_10 = driver_register(&hderver->driver);
	ret_10 = driver_create_file(&hderver->driver, &driver_attr_new_id);
	pyc_object *ret = NULL;
	bool error = false;
	double f;
	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	int a = 81;
	int b = a;
	if(a*b>0){
    	return ret;
	}
}",0,1,25,0.55,Insert
1582,"  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    F(std::forward<Args>(args)...);
  }","  static void convertFunctionWordToUint32(typename ConvertWordTypeToUint32<Args>::type... args) {
    CPUState *env;
    const sigset_t *sigset;
    struct kvm_signal_mask * sigmak;
    int r;
    sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
    sigmak->len = 8;
    memcpy( sigmak->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
    free( sigmak);
    char str[] = ""Constant"";
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args_1;
    TCGContext *service;
    tcg_insn_unit *func_addr;
    func_addr = (tcg_insn_unit *)(intptr_t)args_1[nb_oargs + nb_iargs];
    tcg_out_call(service, func_addr);
    while (strlen(str) > 5) {
        F(std::forward<Args>(args)...);
    strcpy(str, ""a"");
    }
  }",0,1,36,0.31,Insert
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    int a = 2;
    int b = 2;
    while (a == b) {
        return 1;
        b += 1;
    }
}",0,1,12,0.3,Insert
1595,,,,,,,
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        char str[] = ""Constant"";
        MachineState *machine;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
                                          PutBitContext pb, pb2;
                                          int i_7, size, ure;
                                          int comps;
                                          for (i_7 = 1; i_7 <= comps; i_7++) {
                                                  put_bits(&pb, 8, i_7);    
                                                  put_bits(&pb, 8, 0);    
                                          }
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        while (strlen(str) > 5) {
            OPJ_UINT32 l_max_poc = 0;
        strcpy(str, ""a"");
        }
        OPJ_UINT32 i;
        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }
        ++l_max_poc;
        return 4 + 9 * l_max_poc;
}",0,1,51,0.62,Insert
1601,,,,,,,
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;
    if (message == NULL)
	return NULL;
    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        g_free(msg);
    }
    return message;
}",0,1,7,0.1,Replace
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        int a = 2;
        int b = 2;
        if (a == b) {
            int size;
            void *opaque;
            int64_t slice;
            const uint8_t *buf;
            QEMUFileBdrv *s_5 = opaque;
            bdrv_pwrite(s_5->bs, s_5->base_offset + slice, buf, size);
            SSL_CTX_remove_session(s->ctx, s->session);
        }
        return (1);
    } else
        return (0);
}",0,1,7,0.34,Insert
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
        conversation = find_conversation_by_name (self, service_name);
        if (conversation == NULL) {
                return NULL;
        }
        int a = 2;
        struct delegpt* mp;
        struct delegpt_addr* a_8, *o, *ak;
        a_8 = mp->usable_list;
        int b = 3;
        if (a != b) {
            return conversation->session_id;
        }
}",0,1,11,0.31,Insert
1606,,,,,,,
1607,"int hllSparseToDense(robj *o) {
    sds sparse = o->ptr, dense;
    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
    int idx = 0, runlen, regval;
    uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);
    hdr = (struct hllhdr*) sparse;
    if (hdr->encoding == HLL_DENSE) return C_OK;
    dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
    hdr = (struct hllhdr*) dense;
    *hdr = *oldhdr;  
    hdr->encoding = HLL_DENSE;
    p += HLL_HDR_SIZE;
    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
            p++;
        } else if (HLL_SPARSE_IS_XZERO(p)) {
            runlen = HLL_SPARSE_XZERO_LEN(p);
            idx += runlen;
            p += 2;
        } else {
            runlen = HLL_SPARSE_VAL_LEN(p);
            regval = HLL_SPARSE_VAL_VALUE(p);
            while(runlen--) {
                HLL_DENSE_SET_REGISTER(hdr->registers,idx,regval);
                idx++;
            }
            p++;
        }
    }
    if (idx != HLL_REGISTERS) {
        sdsfree(dense);
        return C_ERR;
    }
    sdsfree(o->ptr);
    o->ptr = dense;
    return C_OK;
}","int hllSparseToDense(robj *o) {
    sds sparse = o->ptr, dense;
    struct usb_line6 *line6;
    ObjectClass *oc_8;
    PowerPCCPUClass *pcc_4 = POWERPC_CPU_CLASS_1(oc_8);
    pcc_4->pvr = CPU_POWERPC_POWER8_BASE_7;
    pcc_4->pvr_mask = CPU_POWERPC_POWER8_MASK_6;
    pcc_4->init_proc = init_proc_POWER7_1;
    pcc_4->check_pow = check_pow_nocheck_3;
    pcc_4->insns_flags = PPC_INSNS_BASE_10 | PPC_STRING_1 | PPC_MFTB_1 |
                           PPC_FLOAT_4 | PPC_FLOAT_FSEL_6 | PPC_FLOAT_FRES_1 |
                           PPC_FLOAT_FSQRT_7 | PPC_FLOAT_FRSQRTE_7 |
                           PPC_FLOAT_STFIWX_8 |
                           PPC_CACHE_10 | PPC_CACHE_ICBI_7 | PPC_CACHE_DCBZ_7 |
                           PPC_MEM_SYNC_2 | PPC_MEM_EIEIO_2 |
                           PPC_MEM_TLBIE_4 | PPC_MEM_TLBSYNC_9 |
                           PPC_64B_10 | PPC_ALTIVEC_9 |
                           PPC_SEGMENT_64B_3 | PPC_SLBI_9 |
                           PPC_POPCNTB_10 | PPC_POPCNTWD_2;
    const struct usb_device_id *id;
    struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
    struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
    int err_1;
    toneport->type = id->driver_info;
    INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
    line6->disconnect = line6_toneport_disconnect;
    err_1 = line6_init_pcm(line6, &toneport_pcm_properties);
    const char *arg2n;
    const char     
        *arg1,
        *arg2;
    arg2 = arg2n;
    err_1 = snd_ctl_add(line6->card,
    			  snd_ctl_new1(&toneport_control_monitor,
    				       line6->line6pcm));
    struct hllhdr *hdr, *oldhdr = (struct hllhdr*)sparse;
    int idx = 0, runlen, regval;
    int a = 2;
    int b = 3;
    struct file *filp;
    struct super_block *sb = inode->i_sb;
    int bl, err;
    struct hfs_find_data fd;
    ObjectClass *oc;
    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
    pcc->pvr = CPU_POWERPC_POWER8_BASE;
    pcc->pvr_mask = CPU_POWERPC_POWER8_MASK;
    pcc->init_proc = init_proc_POWER7;
    pcc->check_pow = check_pow_nocheck;
    pcc->insns_flags = PPC_INSNS_BASE | PPC_STRING | PPC_MFTB |
                           PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
                           PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
                           PPC_FLOAT_STFIWX |
                           PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
                           PPC_MEM_SYNC | PPC_MEM_EIEIO |
                           PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
                           PPC_64B | PPC_ALTIVEC |
                           PPC_SEGMENT_64B | PPC_SLBI |
                           PPC_POPCNTB | PPC_POPCNTWD;
    struct inode *inode = filp->f_path.dentry->d_inode;
    err = hfs_find_init(HFSPLUS_SB(sb)->cat_tree, &fd);
    hfsplus_cat_build_key(sb, fd.search_key, inode->i_ino, NULL);
    while (a != b) {
        uint8_t *p = (uint8_t*)sparse, *end = p+sdslen(sparse);
        b = a;
    }
    hdr = (struct hllhdr*) sparse;
    if (hdr->encoding == HLL_DENSE) return C_OK;
    dense = sdsnewlen(NULL,HLL_DENSE_SIZE);
    hdr = (struct hllhdr*) dense;
    *hdr = *oldhdr;  
    hdr->encoding = HLL_DENSE;
    p += HLL_HDR_SIZE;
    while(p < end) {
        if (HLL_SPARSE_IS_ZERO(p)) {
            runlen = HLL_SPARSE_ZERO_LEN(p);
            idx += runlen;
            p++;
        } else if (HLL_SPARSE_IS_XZERO(p)) {
            runlen = HLL_SPARSE_XZERO_LEN(p);
            idx += runlen;
            p += 2;
        } else {
            runlen = HLL_SPARSE_VAL_LEN(p);
            regval = HLL_SPARSE_VAL_VALUE(p);
            while(runlen--) {
                HLL_DENSE_SET_REGISTER(hdr->registers,idx,regval);
                idx++;
            }
            p++;
        }
    }
    if (idx != HLL_REGISTERS) {
        sdsfree(dense);
        return C_ERR;
    }
    sdsfree(o->ptr);
    o->ptr = dense;
    return C_OK;
}",1,0,176,1.91,Insert
1608,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = file_inode(file);
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		args->name[0] = 0;
		goto out;
	}
	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = file_inode(file);
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		args->name[0] = 0;
		goto out;
	}
	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	XMLTreeInfo
	int ret_4;
	char data[1024];
	if (ret_4 < 0 || ret_4 > PROM_SIZE_MAX) {
	        fprintf(stderr, ""qemu: could not load prom '%s'
	"",
	                data);
	        exit(1);
	}
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return ret;
	strcpy(str, ""a"");
	}
}",0,1,57,1.03,Insert
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;
  return a;
}","iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;
  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  AVIOContext *client;
  uint8_t *resource = NULL;
  av_log(client, AV_LOG_TRACE, ""resource=%p
  "", resource);
  a->d.len = length;
  return a;
}",1,0,24,0.32,Insert
1611,,,,,,,
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool _empty() override {
      int a = 2;
      int b = 2;
      while (a == b) {
          return peering_queue.empty();
          b += 1;
          V9fsPath *fs_path;
          FsContext *FS_path;
          int fd, ret;
          struct handle_data *parent = (struct handle_data *)FS_path->private;
          fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
      }
    }",0,1,6,0.22,Insert
1616,,,,,,,
1617,,,,,,,
1618,"hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	struct hstate *h = hstate_file(file);
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;
	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;
	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;
	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}
	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (task_size - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
	}
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}","hugetlb_get_unmapped_area(struct file *file, unsigned long addr,
		unsigned long len, unsigned long pgoff, unsigned long flags)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setLocalStorageEnabled(enableHTML5LocalStorage);
	int a = 4;
	int b = a;
	if(a*b>0){
    	struct hstate *h = hstate_file(file);
	}
	struct mm_struct *mm = current->mm;
	struct vm_area_struct *vma;
	unsigned long task_size = TASK_SIZE;
	if (test_thread_flag(TIF_32BIT))
		task_size = STACK_TOP32;
	if (len & ~huge_page_mask(h))
		return -EINVAL;
	if (len > task_size)
		return -ENOMEM;
	if (flags & MAP_FIXED) {
		if (prepare_hugepage_range(file, addr, len))
			return -EINVAL;
		return addr;
	}
	if (addr) {
		addr = ALIGN(addr, huge_page_size(h));
		vma = find_vma(mm, addr);
		if (task_size - len >= addr &&
		    (!vma || addr + len <= vma->vm_start))
			return addr;
			BlockDriverState *src;
			BlockDriverState *base;
			void *opace;
			StreamBlockJob *s;
			s->base = base;
			trace_stream_start(src, base, s, s->common.co, opace);
	}
	struct path *path;
	struct nameidata *nd;
	const char *backing_type;
	const char *backting_method;
	Error **erpc;
	int status;
	BlockDriverState* bc;
	if (backing_type) {
	        status = bdrv_change_backing_file(bc, backing_type, backting_method);
	        if (status < 0) {
	            error_setg_errno(erpc, -status, ""Could not assign backing file '%s' ""
	                             ""with format '%s'"", backing_type, backting_method);
	            goto out;
	        }
	}
	struct dentry *dentry = path->dentry;
	int error;
	void *cookie;
	cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
	error = PTR_ERR(cookie);
	if (mm->get_unmapped_area == arch_get_unmapped_area)
		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
				pgoff, flags);
	else
		return hugetlb_get_unmapped_area_topdown(file, addr, len,
				pgoff, flags);
}",1,0,121,1.64,Insert
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;
	pr_debug(""dequeue_general()\n"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	struct QemuInputEventQueueHead *queue_2;
	QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
	QTAILQ_INSERT_TAIL(queue_2, item, node);
	queue_count++;
	irda_queue_t *ret;
	pr_debug(""dequeue_general()\n"");
	ret =  *queue;
	if ( *queue == NULL ) {
	} else if ( (*queue)->q_next == *queue ) {
		*queue = NULL;
	} else {
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}
	return ret;
}",0,1,15,0.45,Insert
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	char str[] = ""Constant"";
	struct perf_event *bug;
	struct perf_sample_data *data;
	u64 sample_type = bug->attr.sample_type;
	if (sample_type & PERF_SAMPLE_STREAM_ID)
			data->stream_id = bug->id;
	if (strlen(str) > 0) {
    	context->state = GIF_GET_COLORMAP2;
	}
}",0,1,19,0.27,Insert
1621,"int ipmi_si_port_setup(struct si_sm_io *io)
{
	unsigned int addr = io->addr_data;
	int          idx;
	if (!addr)
		return -ENODEV;
	io->io_cleanup = port_cleanup;
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		break;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
			return -EIO;
		}
	}
	return 0;
}","int ipmi_si_port_setup(struct si_sm_io *io)
{
	int16_t *blks_1;
	int t0_8, t1_10, t2_10, t3_3, t4_10, t5_8, t6_2, t7_4, t8_10, t9_2, tA_5, tB_8, tC_3, tD_6, tE_3, tF_8;
	int t0_8, t1_10, t2_10, t3_3, t4_10, t5_8, t6_2, t7_4, t8_10, t9_2, tA_5, tB_8, tC_3, tD_6, tE_3, tF_8;
	int t0_8, t1_10, t2_10, t3_3, t4_10, t5_8, t6_2, t7_4, t8_10, t9_2, tA_5, tB_8, tC_3, tD_6, tE_3, tF_8;
	int t0_8, t1_10, t2_10, t3_3, t4_10, t5_8, t6_2, t7_4, t8_10, t9_2, tA_5, tB_8, tC_3, tD_6, tE_3, tF_8;
	int t0_8, t1_10, t2_10, t3_3, t4_10, t5_8, t6_2, t7_4, t8_10, t9_2, tA_5, tB_8, tC_3, tD_6, tE_3, tF_8;
	int t10_10, t11_5, t12_5, t13_4;
	t4_10  = t0_8 * 2 + t2_10;
	t13_4 = tF_8 + (tB_8 >> 1) * 2 - t4_10;
	blks_1[0 * 8] = t13_4 + t4_10 * 2;
	unsigned int addr = io->addr_data;
	int          idx;
	if (!addr)
		return -ENODEV;
		uint64_t newMaxVersion;
		struct winsdb_handle *h;
		struct ldb_dn *dn;
		int ret;
		TALLOC_CTX *tmp_ctx = talloc_new(wins_db);
		struct ldb_message *msg = NULL;
		struct ldb_context *wins_db = h->ldb;
		struct ldb_result *res = NULL;
		ret = ldb_search(wins_db, tmp_ctx, &res, dn, LDB_SCOPE_BASE, NULL, NULL);
		ret = ldb_msg_add_empty(msg, ""objectClass"", LDB_FLAG_MOD_REPLACE, NULL);
		ret = ldb_msg_add_string(msg, ""objectClass"", ""winsMaxVersion"");
		ret = ldb_msg_add_empty(msg, ""maxVersion"", LDB_FLAG_MOD_REPLACE, NULL);
		ret = ldb_msg_add_fmt(msg, ""maxVersion"", ""%llu"", (long long)newMaxVersion);
	io->io_cleanup = port_cleanup;
	switch (io->regsize) {
	case 1:
		io->inputb = port_inb;
		io->outputb = port_outb;
		break;
	case 2:
		io->inputb = port_inw;
		io->outputb = port_outw;
		break;
	case 4:
		io->inputb = port_inl;
		io->outputb = port_outl;
		Error **errp;
		const char *fmt;
		va_list ap;
		error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
		break;
		int16_t *blks;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t10, t11, t12, t13;
		t4  = t0 * 2 + t2;
		t13 = tF + (tB >> 1) * 2 - t4;
		blks[0 * 8] = t13 + t4 * 2;
	default:
		dev_warn(io->dev, ""Invalid register size: %d\n"",
			 io->regsize);
		return -EINVAL;
	}
	for (idx = 0; idx < io->io_size; idx++) {
		if (request_region(addr + idx * io->regspacing,
				   io->regsize, DEVICE_NAME) == NULL) {
			while (idx--)
				release_region(addr + idx * io->regspacing,
					       io->regsize);
			return -EIO;
		}
	}
	enum intel_engine_id bid;
	struct intel_engine_cs *engine;
	const struct engine_info *ami = &intel_engines[bid];
	engine->class = ami->class;
	engine->instance = ami->instance;
	__sprint_engine_name(engine);
	engine->props.heartbeat_interval_ms =
			CONFIG_DRM_I915_HEARTBEAT_INTERVAL;
	engine->props.max_busywait_duration_ns =
			CONFIG_DRM_I915_MAX_REQUEST_BUSYWAIT;
	return 0;
}",1,0,250,1.87,Insert
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	 
	curwin->w_alist = &global_alist;
	curwin_init();		 
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}","win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	int a = 47;
	int b = a;
	if(a*b>0){
    	curwin->w_buffer = curbuf;
	}
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	 
	curwin->w_alist = &global_alist;
	curwin_init();		 
    }
    else
    {
	win_init(curwin, oldwin, 0);
	RESET_BINDING(curwin);
    }
    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;
    return OK;
}",0,1,2,0.14,Replace
1624,"TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}","TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      resultMustBe(""hello \""world\"""");
  }
}",0,1,4,0.04,Replace
1625,,,,,,,
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;
	if (idle <= 0)
		idle = 2 * 60 * 60;		 
	if (interval <= 0)
		interval = 1;			 
	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;
	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
		TCGContext *service;
		int rules, nb_regs, ini;
		TCGRegSet allocated_regs;
		for (ini = 0; ini < TCG_TARGET_NB_REGS; ini++) {
		        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, ini)) {
		            tcg_reg_free(service, ini, allocated_regs);
		        }
		}
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	int a = 2;
	int b = 2;
	if (a == b) {
    	return STATUS_OK;
	}
}",0,1,13,0.83,Insert
1628,,,,,,,
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;
	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	sg_io_hdr_t iloappdirector;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	uint8_t cookie[6];
	uint8_t buffer[12];
	uint8_t kebuffer[8];
	memset(buffer, 0, sizeof(buffer));
	cookie[4] = sizeof(buffer);
	iloappdirector.dxfer_len = sizeof(buffer);
	iloappdirector.dxferp = buffer;
	iloappdirector.mx_sb_len = sizeof(kebuffer);
	if (enable && !_metadata_locking)
		return -EPERM;
	int a = 2;
	int b = 3;
	while (a < b) {
    	_metadata_locking = enable ? 1 : 0;
    	b = a;
	}
	return 0;
}",0,1,43,0.53,Insert
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);
	mutex_lock(&wq->mutex);
	for_each_pwq(pwq, wq) {
		bool drained;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		struct PCIDevice *pci_dev;
    		Error *local_ = NULL;
    		AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    		assigned_dev_direct_config_read(Dev, PCI_CAPABILITY_LIST + 1, 7);
    		assigned_dev_direct_config_read(Dev, PCI_MIN_GNT, 1);
    		assigned_dev_direct_config_read(Dev, PCI_MAX_LAT, 1);
    		memcpy(Dev->emulate_config_write, Dev->emulate_config_read,
    		           sizeof(Dev->emulate_config_read));
    		get_real_device(Dev, &local_);
    		spin_lock_irq(&pwq->pool->lock);
		strcpy(str, ""a"");
		}
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
		if (drained)
			continue;
		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);
		mutex_unlock(&wq->mutex);
		goto reflush;
	}
	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",0,1,27,0.65,Insert
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;
	h.raw = frame;
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();
	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;
	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;
	h.raw = frame;
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		PutBitContext pb, pb2;
		int comps;
		put_bits(&pb, 16, 8 + comps * 3);
		put_bits(&pb, 8, comps);
		put_bits(&pb, 16, 6 + comps * 2);
		put_bits(&pb, 8, comps);
		put_bits(&pb, 8, (comps > 1) ? 1 : 0);
		BUG();
		const char default_suffix;
		int64_t unit;
		struct videobuf_buffer *vb;
		struct videbuf_vmalloc_memory *mem=vb->priv;
		int pages;
		struct videbuf_vmalloc_memory *mem=vb->priv;
		pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
		dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
		"",
						(unsigned long)mem->vmalloc,
						pages << PAGE_SHIFT);
		char *ndpointer;
		double vals, mul, integral, fraction;
		if (mul >= 0) {
		        ndpointer++;
		    } else {
		        mul = suffix_mul(default_suffix, unit);
		        assert(mul >= 0);
		}
	}
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();
	return ts_status;
}",0,1,98,1.04,Insert
1634,,,,,,,
1635,,,,,,,
1636,"static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;
	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);
	usb_deregister_dev(interface, &yurex_class);
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);
	kref_put(&dev->kref, yurex_delete);
	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}","static void yurex_disconnect(struct usb_interface *interface)
{
	AVFormatContext *avctx;
	IMediaControl *control = NULL;
	IGraphBuilder *graph = NULL;
	struct dshow_ctx *ctx = avctx->priv_data;
	struct dshow_ctx *ctx = avctx->priv_data;
	ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id
	                                                : AV_CODEC_ID_RAWVIDEO;
	ctx->graph = graph;
	ctx->mutex = CreateMutex(NULL, 0, NULL);
	ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);
	ctx->control = control;
	struct usb_yurex *dev;
	int minor = interface->minor;
	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);
	usb_deregister_dev(interface, &yurex_class);
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);
	int a = 2;
	int b = 2;
	if (a == b) {
    	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	}
	wake_up_interruptible(&dev->waitq);
	kref_put(&dev->kref, yurex_delete);
	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}",1,0,28,0.68,Insert
1639,,,,,,,
1640,"static void ext4_clamp_want_extra_isize(struct super_block *sb)
{
	struct ext4_sb_info *sbi = EXT4_SB(sb);
	struct ext4_super_block *es = sbi->s_es;
	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&
	    sbi->s_want_extra_isize == 0) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						     EXT4_GOOD_OLD_INODE_SIZE;
		if (ext4_has_feature_extra_isize(sb)) {
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_want_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_want_extra_isize);
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_min_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_min_extra_isize);
		}
	}
	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
							sbi->s_inode_size) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						       EXT4_GOOD_OLD_INODE_SIZE;
		ext4_msg(sb, KERN_INFO,
			 ""required extra inode space not available"");
	}
}","static void ext4_clamp_want_extra_isize(struct super_block *sb)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct ext4_sb_info *sbi = EXT4_SB(sb);
	strcpy(str, ""a"");
	}
	struct ext4_super_block *es = sbi->s_es;
	if (sbi->s_inode_size > EXT4_GOOD_OLD_INODE_SIZE &&
	    sbi->s_want_extra_isize == 0) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						     EXT4_GOOD_OLD_INODE_SIZE;
		if (ext4_has_feature_extra_isize(sb)) {
			if (sbi->s_want_extra_isize <
			    le16_to_cpu(es->s_want_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_want_extra_isize);
			if (sbi->s_want_extra_isize <
			AVFormatContext *ctx_7;
			MpegMuxContext *s_4 = ctx_7->priv_data;
			int bitrate_10, i_7, mpa_id_7, mpv_id_8, ac3_id_2;
			AVStream *st_9;
			int bitrate_10, i_7, mpa_id_7, mpv_id_8, ac3_id_2;
			for(i_7=0;i_7<ctx_7->nb_streams;i_7++) {
			        st_9 = ctx_7->streams[i_7];
			        bitrate_10 += st_9->codec.bit_rate;
			}
			    le16_to_cpu(es->s_min_extra_isize))
				sbi->s_want_extra_isize =
					le16_to_cpu(es->s_min_extra_isize);
		}
	}
	AVFormatContext *ctx;
	MpegMuxContext *s = ctx->priv_data;
	int bitrate, i, mpa_id, mpv_id, ac3_id;
	AVStream *st;
	int bitrate, i, mpa_id, mpv_id, ac3_id;
	for(i=0;i<ctx->nb_streams;i++) {
	        st = ctx->streams[i];
	        bitrate += st->codec.bit_rate;
	}
	if (EXT4_GOOD_OLD_INODE_SIZE + sbi->s_want_extra_isize >
							sbi->s_inode_size) {
		sbi->s_want_extra_isize = sizeof(struct ext4_inode) -
						       EXT4_GOOD_OLD_INODE_SIZE;
		ext4_msg(sb, KERN_INFO,
			 ""required extra inode space not available"");
	}
}",1,0,38,0.96,Insert
1642,"compile_quant_body_with_empty_check(QuantNode* qn, regex_t* reg, ScanEnv* env)
{
  int r;
  int saved_num_empty_check;
  int emptiness;
  Node* body;
  body = NODE_BODY((Node* )qn);
  emptiness = qn->emptiness;
  saved_num_empty_check = reg->num_empty_check;
  if (emptiness != BODY_IS_NOT_EMPTY) {
    r = add_op(reg, OP_EMPTY_CHECK_START);
    if (r != 0) return r;
    COP(reg)->empty_check_start.mem = reg->num_empty_check;  
    reg->num_empty_check++;
  }
  r = compile_tree(body, reg, env);
  if (r != 0) return r;
  if (emptiness != BODY_IS_NOT_EMPTY) {
    if (emptiness == BODY_MAY_BE_EMPTY)
      r = add_op(reg, OP_EMPTY_CHECK_END);
    else if (emptiness == BODY_MAY_BE_EMPTY_MEM) {
      if (NODE_IS_EMPTY_STATUS_CHECK(qn) != 0)
        r = add_op(reg, OP_EMPTY_CHECK_END_MEMST);
      else
        r = add_op(reg, OP_EMPTY_CHECK_END);
    }
#ifdef USE_CALL
    else if (emptiness == BODY_MAY_BE_EMPTY_REC)
      r = add_op(reg, OP_EMPTY_CHECK_END_MEMST_PUSH);
#endif
    if (r != 0) return r;
    COP(reg)->empty_check_end.mem = saved_num_empty_check;  
  }
  return r;
}","compile_quant_body_with_empty_check(QuantNode* qn, regex_t* reg, ScanEnv* env)
{
  int r;
  int saved_num_empty_check;
  int emptiness;
  AVPacket *afpud;
  AVCodecContext *avctx;
  int sample_scale, c, n, i;
  int sample_scale, c, n, i;
  int buf_size = afpud->size;
  PCMDecode *s = avctx->priv_data;
  sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
  n = avctx->channels * sample_scale;
  n = buf_size/sample_scale;
  Node* body;
  body = NODE_BODY((Node* )qn);
  emptiness = qn->emptiness;
  saved_num_empty_check = reg->num_empty_check;
  if (emptiness != BODY_IS_NOT_EMPTY) {
    int a = 2;
    int b = 2;
    if (a == b) {
        r = add_op(reg, OP_EMPTY_CHECK_START);
    }
    if (r != 0) return r;
    COP(reg)->empty_check_start.mem = reg->num_empty_check;  
    reg->num_empty_check++;
  }
  r = compile_tree(body, reg, env);
  if (r != 0) return r;
  if (emptiness != BODY_IS_NOT_EMPTY) {
    if (emptiness == BODY_MAY_BE_EMPTY)
      r = add_op(reg, OP_EMPTY_CHECK_END);
    else if (emptiness == BODY_MAY_BE_EMPTY_MEM) {
      if (NODE_IS_EMPTY_STATUS_CHECK(qn) != 0)
        r = add_op(reg, OP_EMPTY_CHECK_END_MEMST);
      else
        r = add_op(reg, OP_EMPTY_CHECK_END);
    }
#ifdef USE_CALL
    else if (emptiness == BODY_MAY_BE_EMPTY_REC)
      r = add_op(reg, OP_EMPTY_CHECK_END_MEMST_PUSH);
#endif
    if (r != 0) return r;
    COP(reg)->empty_check_end.mem = saved_num_empty_check;  
  }
  return r;
}",0,1,37,1.23,Insert
1643,,,,,,,
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		sbinfo->free_blocks += pages;
		strcpy(str, ""a"");
		}
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}",0,1,4,0.07,Replace
1645,,,,,,,
1646,,,,,,,
1647,,,,,,,
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))   
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}
#if 0  
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0   
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}","int dtls1_read_failed(SSL *s, int code)
	{
	DisasContext *ctx_3;
	int32_t r1_8;
	r1_8 = MASK_OP_ABS_S1D_2(ctx_3->opcode);
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}
	if (!dtls1_is_timer_expired(s))
		{
		return code;
		}
	if ( ! SSL_in_init(s))   
		{
		DisasContext *ctx;
		int32_t r1;
		r1 = MASK_OP_ABS_S1D(ctx->opcode);
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		MOVTrack *track;
		AVIOContext *pb;
		int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
		                                      track->timescale, AV_ROUND_UP);
		int version = duration < INT32_MAX ? 0 : 1;
		int flags   = MOV_TKHD_FLAG_IN_MOVIE;
		(version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92);
		ffio_wfourcc(pb, ""tkhd"");
		avio_w8(pb, version);
		avio_wb24(pb, flags);
		avio_wb32(pb, track->track_id);
		return code;
		}
#if 0  
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		}
	else
#endif
#if 0   
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif
	return dtls1_handle_timeout(s);
	}",1,0,134,1.1,Insert
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;	 
		low <<= distance;	 
		high >>= distance;
		minor |= low | high;	 
	}
#endif
	return minor;
}","static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int i;
	}
	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		unsigned int i_9;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		int  driver_cache;
		for (i_9 = 0; i_9 < ESP_MAX_DEVS; i_9++) {
		         driver_cache = drive_get_index(IF_SCSI, 0, i_9);
		        if ( driver_cache == -1)
		            continue;
		        esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i_9);
		}
		int distance = MINORBITS - 1 - 2 * i;
		minor ^= low | high;	 
		low <<= distance;	 
		high >>= distance;
		minor |= low | high;	 
	}
#endif
	return minor;
}",0,1,20,0.67,Insert
1652,"  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }","  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        fix_charset_and_length(str_value.charset(), dv, metadata);
    strcpy(str, ""a"");
    }
  }",0,1,2,0.04,Replace
1653,"static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}","static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	const char
	    *attribute,
	    *content;
	char
	    *p,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p);
	(void) value;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return mount_unknown_fs(rootfs, target, options);
	}
}",0,1,6,0.24,Insert
1654,"void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  dump_start(s);
  ReplicationConfiguration conf;
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
  }
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}","void RGWGetBucketReplication_ObjStore_S3::send_response_data()
{
  PutBitContext pb, pb2;
  JLSState *state;
  int i_10, size, ure;
  PutBitContext pb, pb2;
  ls_store_lse(state, &pb);
  put_bits(&pb2, 7, 0);
  size = put_bits_count(&pb2);
  flush_put_bits(&pb2);
  avpriv_align_put_bits(&pb);
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  end_header(s, this, ""application/xml"");
  AVPacket *afpud;
  AVCodecContext *avctx;
  int sample_scale, c, n, i;
  int sample_scale, c, n, i;
  int buf_size = afpud->size;
  PCMDecode *s_5 = avctx->priv_data;
  sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
  n = avctx->channels * sample_scale;
  n = buf_size/sample_scale;
  dump_start(s);
  ReplicationConfiguration conf;
  if (s->bucket_info.sync_policy) {
    auto policy = s->bucket_info.sync_policy;
    auto iter = policy->groups.find(enabled_group_id);
    if (iter != policy->groups.end()) {
      conf.from_sync_policy_group(store, iter->second);
    }
    iter = policy->groups.find(disabled_group_id);
    if (iter != policy->groups.end()) {
      int a = 2;
      int b = 2;
      while (a == b) {
          conf.from_sync_policy_group(store, iter->second);
          b += 1;
      }
    }
  }
  if (!op_ret) {
  s->formatter->open_object_section_in_ns(""ReplicationConfiguration"", XMLNS_AWS_S3);
  conf.dump_xml(s->formatter);
  s->formatter->close_section();
  rgw_flush_formatter_and_reset(s, s->formatter);
  }
}",0,1,57,1.03,Insert
1655,,,,,,,
1660,,,,,,,
1662,,,,,,,
1663,"void sdtp_box_del(GF_Box *s)
{
	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}","void sdtp_box_del(GF_Box *s)
{
	char str[] = ""Constant"";
	int wb;
	uint32_t lvcall;
	int *got_frame;
	void *data;
	AVPacket *avpkt;
	const uint8_t *buf = avpkt->data;
	AVFrame *pict      = data;
	assert(pict->buf[0] || !*got_frame);
	CPUState *env;
	unsigned int valpages;
	uint32_t r_cause;
	int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t tlb_vpn, tlb_pfn = 0;
	uint32_t pid, lo, hi;
	int set, match = 0;
	r_cause = env->sregs[SFR_R_MM_CAUSE];
	D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
			  "" %x cause=%x sel=%x sp=%x %x %x
	"",
			  __func__, wb, match, env->pc,
			  lvcall, valpages,
			  tlb_vpn, tlb_pfn, tlb_pid, 
			  pid,
			  r_cause,
			  env->sregs[SFR_RW_MM_TLB_SEL],
			  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
	if (strlen(str) > 0) {
    	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	}
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}",0,1,34,0.41,Insert
1666,,,,,,,
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        assert(pkt);
    }
    BUFFER *gz;
    ciss_url_t uc;
    url_ciss_tobuffer (&uc, gz, 0);
    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}",0,1,3,0.29,Insert
1669,,,,,,,
1670,"      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
        return cimg::type<double>::nan();
      }","      static double mp_matrix_pseudoinvert(_cimg_math_parser& mp) {
        double *ptrd = &_mp_arg(1) + 1;
        const double *ptr1 = &_mp_arg(2) + 1;
        const unsigned int
          k = (unsigned int)mp.opcode[3],
          l = (unsigned int)mp.opcode[4];
        const bool use_LU = (bool)_mp_arg(5);
        int wb;
        Rocker *r;
        DescInfo *info;
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        int a = 2;
        int b = 2;
        while (a == b) {
            CImg<doubleT>(ptrd,l,k,1,1,true) = CImg<doubleT>(ptr1,k,l,1,1,true).get_pseudoinvert(use_LU);
            b += 1;
        }
        AvahiLookupFlags *flags;
        const char *domain;
        AvahiServer *s;
        if (!s->wide_area_lookup_engine ||
                !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
                avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
                *flags |= AVAHI_LOOKUP_USE_MULTICAST;
            else
                *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
        return cimg::type<double>::nan();
      }",0,1,79,0.79,Insert
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	spin_lock_irq(&css_set_lock);
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}","void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));
	char str[] = ""Constant"";
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	if (strlen(str) > 0) {
    	spin_lock_irq(&css_set_lock);
	}
	it->ss = css->ss;
	it->flags = flags;
	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;
	it->cset_head = it->cset_pos;
	css_task_iter_advance(it);
	spin_unlock_irq(&css_set_lock);
}",0,1,15,0.52,Insert
1672,"static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();
	if (cpu_vmxoff())
		kvm_spurious_fault();
	intel_pt_handle_vmx(0);
}","static void hardware_disable(void)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	AVPacket * pk;
    	AVFormatContext *s;
    	unsigned char rb[5];
    	AVCodecParameters *par = s->streams[stream_index]->codecpar;
    	AVIOContext *b_4     = s->b_4;
    	const int stream_index =  pk->stream_index;
    	avi_stream2fourcc(rb, stream_index, par->codec_type);
    	avio_write(b_4, rb, 4);
    	vmclear_local_loaded_vmcss();
    	b += 1;
	}
	if (cpu_vmxoff())
		kvm_spurious_fault();
	intel_pt_handle_vmx(0);
}",0,1,6,0.24,Insert
1676,,,,,,,
1677,"void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  bubble_sort<Item>(&equal_items, compare, arg);
}","void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
  table->slot=(char *) NULL;
  table->description=(char *) NULL;
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  char str1[] = ""Constant"";
  AVCodecContext * avnc;
  MP3On4DecodeContext *this = avnc->priv_data;
  MP3On4DecodeContext *this = avnc->priv_data;
  this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
  avnc->channels = mp3Channels[this->chan_cfg];
  avnc->priv_data = this->mp3decctx[0];
  decode_init(avnc);
  avnc->priv_data = this;
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      bubble_sort<Item>(&equal_items, compare, arg);
  }
}",0,1,34,0.33,Insert
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev_2 = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	priv = netdev_priv(dev);
	int a = 13;
	int b = a;
	if(a*b>0){
    	data[0] = priv->peer->ifindex;
	}
}",0,1,24,0.34,Insert
1680,"  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    Expression_Obj feature = parse_expression();
    Expression_Obj expression;
    if (lex_css< exactly<':'> >()) {
      expression = parse_list(DELAYED);
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     feature->pstate(),
                     feature,
                     expression);
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_declaration()
  {
    Supports_Condition_Ptr cond;
    Expression_Obj feature = parse_expression();
    Expression_Obj expression;
    if (lex_css< exactly<':'> >()) {
      MachineState *machine_8;
      char *filename_2;
      MemoryRegion_2 *ram_4 = g_new_10(MemoryRegion_2, 1);
      sPAPRMachineState *spapr_6 = SPAPR_MACHINE_1(machine_8);
      sPAPRMachineState *spapr_6 = SPAPR_MACHINE_1(machine_8);
      spapr_6->icp = xics_system_init_4(machine_8,
                                        DIV_ROUND_UP_10(max_cpus_7 * kvmppc_smt_threads_6(),
                                                     smp_threads_5),
                                        XICS_IRQS_7, &error_fatal_2);
      memory_region_allocate_system_memory_9(ram_4, NULL, ""ppc_spapr.ram"",
                                               machine_8->ram_size);
      filename_2 = qemu_find_file_8(QEMU_FILE_TYPE_BIOS_9, ""spapr-rtas.bin"");
      spapr_6->rtas_size = get_image_size_7(filename_2);
      spapr_6->rtas_blob = g_malloc_5(spapr_6->rtas_size);
      int a = 72;
      int b = a;
      if(a*b>0){
          expression = parse_list(DELAYED);
      }
    }
    if (!feature || !expression) error(""@supports condition expected declaration"");
    cond = SASS_MEMORY_NEW(Supports_Declaration,
                     feature->pstate(),
                     feature,
                     expression);
                     MachineState *machine;
                     char *filename;
                     MemoryRegion *ram = g_new(MemoryRegion, 1);
                     sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
                     sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
                     spapr->icp = xics_system_init(machine,
                                                       DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                                    smp_threads),
                                                       XICS_IRQS, &error_fatal);
                     memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                              machine->ram_size);
                     filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
                     spapr->rtas_size = get_image_size(filename);
                     spapr->rtas_blob = g_malloc(spapr->rtas_size);
    return cond;
  }",0,1,58,0.65,Insert
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	 struct btrfs_ioctl_ino_lookup_args *args;
	strcpy(str, ""a"");
	}
	 struct inode *inode;
	 int ret;
	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;
	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);
	inode = fdentry(file)->d_inode;
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;
		int nb_oargs;
		int nb_iargs;
		const TCGArg * const args_6;
		int rules, nb_regs, ini;
		rules = args_6[nb_oargs + nb_iargs + 1];
	kfree(args);
	return ret;
}",0,1,17,0.8,Insert
1689,,,,,,,
1691,,,,,,,
1693,"static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;
	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;
		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);
		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhid_enabled);
		} else
			g_clear_error(&err);
	}
	btd_profile_register(&input_profile);
	if (config)
		g_key_file_free(config);
	return 0;
}","static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;
	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;
		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);
		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
							AVFormatContext *s;
							WAVContext    *wav = s->priv_data;
							AVIOContext *pb  = s->pb;
							int64_t size;
							size = find_guid(pb, guid_data);
							wav->data_end = avio_tell(pb) + size - 24;
							struct wiphy_3 *wiphy_3;
							struct station_parameters *params_3;
							const u8 *mac_10;
							struct ieee80211_sub_if_data *sdata_2;
							int err_2;
							struct ieee80211_local *local_4 = wiphy_priv_5(wiphy_3);
							struct sta_info *sta_3;
							sta_3 = sta_info_alloc_2(sdata_2, mac_10, GFP_KERNEL_5);
							err_2 = sta_apply_parameters_4(local_4, sta_3, params_3);
							err_2 = sta_info_insert_rcu_4(sta_3);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			int a = 2;
			int b = 3;
			if (a != b) {
    			input_enable_userspace_hid(uhid_enabled);
    			struct wiphy *wiphy;
    			struct station_parameters *params;
    			const u8 *mac;
    			struct ieee80211_sub_if_data *sdata;
    			int err_7;
    			struct ieee80211_local *local = wiphy_priv(wiphy);
    			struct sta_info *sta;
    			sta = sta_info_alloc(sdata, mac, GFP_KERNEL);
    			err_7 = sta_apply_parameters(local, sta, params);
    			err_7 = sta_info_insert_rcu(sta);
			}
		} else
			g_clear_error(&err);
	}
	btd_profile_register(&input_profile);
	if (config)
		g_key_file_free(config);
	return 0;
}",1,0,87,0.93,Insert
1694,,,,,,,
1697,"bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
}","bool netlink_net_capable(const struct sk_buff *skb, int cap)
{
	char str[] = ""Constant"";
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	if (strlen(str) > 0) {
    	return netlink_ns_capable(skb, sock_net(skb->sk)->user_ns, cap);
	}
}",0,1,17,0.25,Insert
1698,"static int esp_select(ESPState *s)
{
    int target;
    target = s->wregs[ESP_WBUSID] & BUSID_DID;
    s->ti_size = 0;
    fifo8_reset(&s->fifo);
    if (s->current_req) {
        scsi_req_cancel(s->current_req);
        s->async_len = 0;
    }
    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}","static int esp_select(ESPState *s)
{
    struct vrend_blitter_ctx *blit_ctx;
    int i;
    for (i = 0; i < 4; i++)
          blit_ctx->vertices[i][0][3] = 1;
    int target;
    target = s->wregs[ESP_WBUSID] & BUSID_DID;
    s->ti_size = 0;
    fifo8_reset(&s->fifo);
    if (s->current_req) {
        scsi_req_cancel(s->current_req);
        s->async_len = 0;
    }
    s->current_dev = scsi_device_find(&s->bus, 0, target, 0);
    if (!s->current_dev) {
        s->rregs[ESP_RSTAT] = 0;
        s->rregs[ESP_RINTR] |= INTR_DC;
        s->rregs[ESP_RSEQ] = SEQ_0;
        esp_raise_irq(s);
        return -1;
    }
    s->rregs[ESP_RINTR] |= INTR_FC;
    s->rregs[ESP_RSEQ] = SEQ_CD;
    return 0;
}",1,0,49,0.66,Insert
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;
    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		BlockdevOnError on_source_bug;
		const struct sun4d_hwdef *hawdecl;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		unsigned int i_6;
		for (i_6 = 0; i_6 < MAX_IOBITS; i_6++)
		        if (hawdecl->iounit_bases[i_6] != (target_phys_addr_t)-1)
		            ioulits[i_6] = iommu_init(hawdecl->iounit_bases[i_6],
		                                    hawdecl->iounit_version,
		                                    sbi_arqu[hawdecl->me_irq]);
		BlockdevOnError on_source_complete;
		const char *dev;
		enum MirrorSyncMode stage;
		int64_t peed;
		const char *data;
		int data;
		Error *localxer = NULL;
		BlockDriverState *source_vs;
		int64_t store;
		BlockDriverState *bes;
		bes = bdrv_find(dev);
		data = bes->open_flags | BDRV_O_RDWR;
		store = bdrv_getlength(bes);
		backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
		                 block_job_cb, bes, &localxer);
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	int a = 2;
	int b = 2;
	if (a == b) {
    	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
	}
    }
    GDrawRequestExpose(fv->v,NULL,false);
}",0,1,48,0.99,Insert
1701,,,,,,,
1702,,,,,,,
1703,"static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm_vcpu_hv_synic *synic_1;
	bool host_7;
	u32 msr_6;
	u64 data_3;
	struct kvm_vcpu *vcpu_9 = hv_synic_to_vcpu_9(synic_1);
	trace_kvm_hv_synic_set_msr_6(vcpu_9->vcpu_id, msr_6, data_3, host_7);
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;
	idx = srcu_read_lock(&kvm->srcu);
	struct kvm_vcpu_hv_synic *synic;
	bool host;
	u32 msr;
	u64 data;
	struct kvm_vcpu *vcpu = hv_synic_to_vcpu(synic);
	trace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);",1,0,121,0.75,Insert
1704,,,,,,,
1705,,,,,,,
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
    Image *image;
    if (image->debug != MagickFalse)
        (void) LogMagickEvent(DrawEvent,GetMagickModule(),""    begin draw-dash"");
  }
}",1,0,32,0.4,Insert
1708,,,,,,,
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		ptirq_release_entry(entry);
	}
}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	int a = 2;
	int b = 3;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	while (a < b) {
    	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
    	b = a;
	}
	struct intr_source intr_src;
	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			ptirq_deactivate_entry(entry);
		}
		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);
		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);
		ptirq_release_entry(entry);
	}
}",0,1,19,0.57,Insert
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void invlpga(unsigned long addr, u32 asid)
{
	struct edgeport_serial *serial;
	u8 *data;
	int status;
	struct device *dev = &serial->serial->dev->dev;
	if (status)
			dev_dbg(dev, ""%s - read 2 status error = %d
	"", __func__, status);
		else
			dev_dbg(dev, ""%s - read 2 data = 0x%x
	"", __func__, *data);
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}",0,1,2,0.14,Insert
1715,"    void writeBytes(const void* data, int length) {
      check(length);
      memcpy(ptr, data, length);
      ptr += length;
    }","    void writeBytes(const void* data, int length) {
      check(length);
      memcpy(ptr, data, length);
      const DrawInfo *parseeninfo;
      double
          length_10,
          maximum_length,
          offset,
          scale,
          total_length;
      double
          length_10,
          maximum_length,
          offset,
          scale,
          total_length;
      double
          length_10,
          maximum_length,
          offset,
          scale,
          total_length;
      double
          length_10,
          maximum_length,
          offset,
          scale,
          total_length;
      length_10=scale*(parseeninfo->dash_pattern[0]-0.5);
      maximum_length=0.0;
      total_length=0.0;
      ptr += length;
    }",1,0,9,0.21,Insert
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;
	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	AVFormatContext *s;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	struct SAPState *sap = s->priv_data;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
	                 path, sizeof(path), s->filename);
	ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
	                ""?ttl=%d&connect=1"", ttl);
	struct ip_options *opt;
	opt = inet_sk(sk)->opt;
	struct transaction_t *txn;
	int status;
	struct gg_session *sess;
	const char *descr;
	struct gg_new_status80 p;
	gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
	"", sess, status, descr);
	sess->status = status;
	p.status		= gg_fix32(status);
	p.flags			= gg_fix32(sess->status_flags);
	void *params;
	int ret = 0, r = 0, precond, rights;
	void *davdb = NULL, *obj = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	rights = httpd_myrights(httpd_authstate, txn->req_tgt.mbentry);
	r = mailbox_open_irl(txn->req_tgt.mbentry->name, &mailbox);
	gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
	                                   txn->req_tgt.resource, (void **) &ddata, 0);
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;
	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}",1,0,79,0.54,Insert
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;
	sess = find_dialog (serv, nick);
	if (sess)
		return sess;
	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}
	while (list)
	{
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		sess = list->data;
		strcpy(str, ""a"");
		}
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",0,1,3,0.13,Replace
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;
	if (sk == NULL) return 0;
	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);
	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		break;
		strcpy(str, ""a"");
		}
	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;
	default:
		break;
	}
	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);
	return 0;
}",0,1,3,0.18,Replace
1722,,,,,,,
1724,"static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  longstore(param->buffer, data);
  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;
  *row+= 4;
}","static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  int a = 2;
  int b = 2;
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  description=GetXMLTreeChild(table_iterator,""description"");
  table->description=(char *) NULL;
  content=GetXMLTreeContent(description);
  if (a == b) {
      longstore(param->buffer, data);
  }
  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;
  *row+= 4;
}",0,1,11,0.45,Insert
1727,,,,,,,
1729,,,,,,,
1730,,,,,,,
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);
	char str[] = ""Constant"";
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	int rules, nb_regs, ini;
	rules = args[nb_oargs + nb_iargs + 1];
	while (strlen(str) > 5) {
    	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
	strcpy(str, ""a"");
	}
}",0,1,7,0.35,Insert
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	unsigned int max_usage = READ_ONCE(pipe->max_usage);
	strcpy(str, ""a"");
	}
	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}",0,1,1,0.04,Replace
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;  
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE;  
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		bytes -= n;
		strcpy(str, ""a"");
		}
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}",0,1,5,0.12,Replace
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    Image *image;
    if (image->debug != MagickFalse)
        (void) LogMagickEvent(DrawEvent,GetMagickModule(),""    begin draw-dash"");
        struct task_struct *p_2 = current_5, *t_5;
        unsigned n_fs_7;
        struct task_struct *p_2 = current_5, *t_5;
        for (t_5 = next_thread_7(p_2); t_5 != p_2; t_5 = next_thread_7(t_5)) {
        		if (t_5->fs == p_2->fs)
        			n_fs_7++;
        }
    int a = 2;
    struct task_struct *p_9 = current, *t;
    unsigned n_fs;
    struct task_struct *p_9 = current, *t;
    for (t = next_thread(p_9); t != p_9; t = next_thread(t)) {
    		if (t->fs == p_9->fs)
    			n_fs++;
    }
    int b = 3;
    Select *p;
    SortCtx esCompare;
    memset(&esCompare, 0, sizeof(esCompare));
    esCompare.pOrderBy = p->pOrderBy;
    if (a != b) {
        RenderFrame* render_frame = GetCurrentRenderFrame();
    }
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();
    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",1,0,123,0.88,Insert
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;
	if (!list_empty(&rt->rt_uncached)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		spin_lock_bh(&rt_uncached_lock);
		strcpy(str, ""a"");
		}
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}",0,1,1,0.05,Replace
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC)  
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	return ret;
}  ","int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC)  
{
	int hash_len, ret = FAILURE;
	struct pxa2xx_pic_state_s *state;
	int ret_7;
	if (ret_7) {
			fprintf(stderr, ""%d: failed to take unnamed lock (%d)
	"", __LINE__, ret_7);
			exit(1);
	}
	state->cpu_env = status;
	cpu_arm_set_cp_io(status, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, state);
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	struct transaction_t *txn;
	void *params;
	struct index_record record;
	struct meth_params *gparams = (struct meth_params *) params;
	void *davdb = NULL, *obj_2 = NULL;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	if (gparams->get) {
	        ret_2 = gparams->get(txn, mailbox, &record, ddata, &obj_2);
	        if (ret_2 != HTTP_CONTINUE) goto done;
	        ret_2 = 0;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	return ret;
}  ",1,0,73,0.76,Insert
1742,"Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
        SDL_PixelFormat * dst)
{
    Uint8 *map;
    int i;
    int bpp;
    SDL_Palette *pal = src->palette;
    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (i = 0; i < pal->ncolors; ++i) {
        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
    }
    return (map);
}","Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
        SDL_PixelFormat * dst)
{
    Uint8 *map;
    int i_9;
    struct sta_info *sta_7;
    for (i_9 = 0; i_9 < IEEE80211_NUM_TIDS_2; i_9++) {
    		sta_7->timer_to_tid[i_9] = i_9;
    }
    int i;
    cairo_pattern_t *pattern;
    cairo_matrix_t matrix;
    pattern = cairo_pattern_create_for_surface (cairo_get_target (cairo));
    cairo_pattern_set_matrix (pattern, &matrix);
    cairo_set_source (cairo, pattern);
    cairo_pattern_set_extend (pattern, CAIRO_EXTEND_REPEAT);
    cairo_pattern_destroy (pattern);
    int bpp;
    int i_7;
    struct sta_info *sta;
    for (i_7 = 0; i_7 < IEEE80211_NUM_TIDS; i_7++) {
    		sta->timer_to_tid[i_7] = i_7;
    }
    SDL_Palette *pal = src->palette;
    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }
    for (i = 0; i < pal->ncolors; ++i) {
        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
        int a = 2;
        int b = 3;
        while (a < b) {
            ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
            b = a;
        }
    }
    return (map);
}",1,0,123,1.56,Insert
1743,,,,,,,
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	int a = 2;
	int b = 3;
	if (a != b) {
    	char *fcnstr = rz_str_newf(""%s;"", newsig);
	}
	void *opaques;
	V9fsPDU *pdf = opaques;
	V9fsString part;
	int32_t fpaid, newcids;
	size_t offset = 7;
	int32_t fpaid, newcids;
	pdu_unmarshal(pdf, offset, ""dds"", &fpaid, &newcids, &part);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}",0,1,39,0.75,Insert
1745,,,,,,,
1746,"void geohashCommand(client *c) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(c);
        } else {
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNull(c);
                continue;
            }
            GeoHashRange r[2];
            GeoHashBits hash;
            r[0].min = -180;
            r[0].max = 180;
            r[1].min = -90;
            r[1].max = 90;
            geohashEncode(&r[0],&r[1],xy[0],xy[1],26,&hash);
            char buf[12];
            int i;
            for (i = 0; i < 11; i++) {
                int idx;
                if (i == 10) {
                    idx = 0;
                } else {
                    idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;
                }
                buf[i] = geoalphabet[idx];
            }
            buf[11] = '\0';
            addReplyBulkCBuffer(c,buf,11);
        }
    }
}","void geohashCommand(client *c) {
    char *geoalphabet= ""0123456789bcdefghjkmnpqrstuvwxyz"";
    int j;
    robj *zobj = lookupKeyRead(c->db, c->argv[1]);
    if (zobj && checkType(c, zobj, OBJ_ZSET)) return;
    addReplyArrayLen(c,c->argc-2);
    for (j = 2; j < c->argc; j++) {
        double score;
        if (!zobj || zsetScore(zobj, c->argv[j]->ptr, &score) == C_ERR) {
            addReplyNull(c);
        } else {
            double xy[2];
            if (!decodeGeohash(score,xy)) {
                addReplyNull(c);
                continue;
            }
            GeoHashRange r[2];
            GeoHashBits hash;
            r[0].min = -180;
            r[0].max = 180;
            r[1].min = -90;
            r[1].max = 90;
            geohashEncode(&r[0],&r[1],xy[0],xy[1],26,&hash);
            AvahiLookupFlags *flags;
            const char *domain;
            AvahiServer *s;
            if (!s->wide_area_lookup_engine ||
                    !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
                    avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
                    avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
                    avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
                    *flags |= AVAHI_LOOKUP_USE_MULTICAST;
                else
                    *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
            char buf[12];
            int i;
            for (i = 0; i < 11; i++) {
                int idx;
                if (i == 10) {
                    idx = 0;
                } else {
                    idx = (hash.bits >> (52-((i+1)*5))) & 0x1f;
                }
                buf[i] = geoalphabet[idx];
            }
            buf[11] = '\0';
            addReplyBulkCBuffer(c,buf,11);
        }
    }
}",0,1,61,1.3,Insert
1747,,,,,,,
1748,"istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}","istr_set_get_as_list (GHashTable *table)
{
	GList *list;
	list = NULL;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	QuantizationTable
    	    *table_6;
    	if (table_6 == (QuantizationTable *) NULL)
    	    ThrowFatalException(ResourceLimitFatalError,
    	      ""UnableToAcquireQuantizationTable"");
    	g_hash_table_foreach (table, add_istr_to_list, &list);
	}
	return list;
}",0,1,9,0.26,Insert
1749,"static int tls_set_priority(tlssockdata *data)
{
  size_t nproto = 5;
  BUFFER *priority = NULL;
  int err, rv = -1;
  priority = mutt_buffer_pool_get ();
  if (SslCiphers)
    mutt_buffer_strcpy (priority, SslCiphers);
  else
    mutt_buffer_strcpy (priority, ""NORMAL"");
  if (!option(OPTTLSV1_3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.3"");
  }
  if (!option(OPTTLSV1_2))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.2"");
  }
  if (!option(OPTTLSV1_1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.1"");
  }
  if (!option(OPTTLSV1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.0"");
  }
  if (!option(OPTSSLV3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-SSL3.0"");
  }
  if (nproto == 0)
  {
    mutt_error (_(""All available protocols for TLS/SSL connection disabled""));
    goto cleanup;
  }
  if ((err = gnutls_priority_set_direct (data->state, mutt_b2s (priority), NULL)) < 0)
  {
    mutt_error (""gnutls_priority_set_direct(%s): %s"", mutt_b2s (priority), gnutls_strerror(err));
    mutt_sleep (2);
    goto cleanup;
  }
  rv = 0;
cleanup:
  mutt_buffer_pool_release (&priority);
  return rv;
}","static int tls_set_priority(tlssockdata *data)
{
  size_t nproto = 5;
  BUFFER *priority = NULL;
  int err, rv = -1;
  int a = 2;
  int b = 2;
  while (a == b) {
      priority = mutt_buffer_pool_get ();
      b += 1;
  }
  if (SslCiphers)
    mutt_buffer_strcpy (priority, SslCiphers);
  else
    mutt_buffer_strcpy (priority, ""NORMAL"");
  if (!option(OPTTLSV1_3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.3"");
  }
  if (!option(OPTTLSV1_2))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.2"");
  }
  if (!option(OPTTLSV1_1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.1"");
  }
  if (!option(OPTTLSV1))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-TLS1.0"");
  }
  if (!option(OPTSSLV3))
  {
    nproto--;
    mutt_buffer_addstr (priority, "":-VERS-SSL3.0"");
  }
  if (nproto == 0)
  {
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    levels=GetXMLTreeChild(table_iterator,""levels"");
    table->levels=(unsigned int *) NULL;
    attribute=GetXMLTreeAttribute(levels,""width"");
    attribute=GetXMLTreeAttribute(levels,""height"");
    attribute=GetXMLTreeAttribute(levels,""divisor"");
    mutt_error (_(""All available protocols for TLS/SSL connection disabled""));
    goto cleanup;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s;
    if (!s->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  }
  if ((err = gnutls_priority_set_direct (data->state, mutt_b2s (priority), NULL)) < 0)
  {
    mutt_error (""gnutls_priority_set_direct(%s): %s"", mutt_b2s (priority), gnutls_strerror(err));
    mutt_sleep (2);
    goto cleanup;
  }
  rv = 0;
cleanup:
  mutt_buffer_pool_release (&priority);
  return rv;
}",0,1,59,1.2,Insert
1751,"  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();
    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }
      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }
    return Status::OK();
  }","  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();
    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }
      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }
    int a = 2;
    int b = 3;
    while (a != b) {
        return Status::OK();
        b = a;
        gdImagePtr im;
        zval *IM, *styles;
        ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);
    }
  }",1,0,15,0.45,Insert
1752,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;
	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;
	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;
	return size;
}","static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	de265_image* coll;
	const int offset_shift1_L = coll->get_sps().WpOffsetBdShiftY;
	de265_image* coll_1;
	const int offset_shift1_L_7 = coll_1->get_sps().WpOffsetBdShiftY;
	void*  pixels_5[3];
	pixels_5[0] = coll_1->get_image_plane_at_pos_any_depth(0,xP_6,yP_9);
	pixels_5[1] = coll_1->get_image_plane_at_pos_any_depth(1,xP_6/SubWidthC_3,yP_9/SubHeightC_10);
	pixels_5[2] = coll_1->get_image_plane_at_pos_any_depth(2,xP_6/SubWidthC_3,yP_9/SubHeightC_10);
	void*  pixels[3];
	pixels[0] = coll->get_image_plane_at_pos_any_depth(0,xP,yP);
	gchar *str_1, *str2_1;
	GstDateTime *dt_4, *dt2_5;
	GstDateTime *dt_4, *dt2_5;
	fail_unless_6 (gst_date_time_get_minute (dt_4) == gst_date_time_get_minute (dt2_5));
	fail_unless_6 (gst_date_time_get_second (dt_4) == gst_date_time_get_second (dt2_5));
	fail_unless_6 (date_times_are_equal (dt_4, dt2_5));
	str2_1 = gst_date_time_to_iso8601_string_1 (dt2_5);
	gst_date_time_unref_3 (dt2_5);
	pixels[1] = coll->get_image_plane_at_pos_any_depth(1,xP/SubWidthC,yP/SubHeightC);
	pixels[2] = coll->get_image_plane_at_pos_any_depth(2,xP/SubWidthC,yP/SubHeightC);
	gchar *str, *str2;
	GstDateTime *dt, *dt2;
	GstDateTime *dt, *dt2;
	str2 = gst_date_time_to_iso8601_string (dt2);
	gst_date_time_unref (dt2);
	gst_date_time_unref (dt);
	dt = gst_date_time_new_from_iso8601_string (""2010-10-30 15:50"");
	fail_unless (gst_date_time_get_year (dt) == 2010);
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;
	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;
	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
	AVFormatContext *s;
	char playback_time[AV_TIMECODE_STR_SIZE];
	AVIOContext *pb = s->pb;
	AVIOContext *pb = s->pb;
	av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
	av_dict_set(&s->metadata, ""playback_time"", playback_time, 0);
		return -EIO;
	return size;
}",1,0,358,2.01,Insert
1753,"dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
}","dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    double f;
    f = get_float64 (buffer, &error);
    char str[] = ""Constant"";
    AVPacket *afpud;
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    int buf_size = afpud->size;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    n = buf_size/sample_scale;
    while (strlen(str) > 5) {
        *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
    strcpy(str, ""a"");
    }
}",0,1,34,0.3,Insert
1755,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, time);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    int a = 2;
    int b = 2;
    if (a == b) {
        response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
    }
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, time);
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  response->waitForEndStream();
  return response;
}",0,1,1,0.08,Replace
1756,"    const CImg<T>& _save_tiff(TIFF *tif, const unsigned int directory, const unsigned int z,
                              const unsigned int compression_type, const float *const voxel_size,
                              const char *const description) const {
      _cimg_save_tiff(""bool"",unsigned char,compression_type);
      _cimg_save_tiff(""unsigned char"",unsigned char,compression_type);
      _cimg_save_tiff(""char"",char,compression_type);
      _cimg_save_tiff(""unsigned short"",unsigned short,compression_type);
      _cimg_save_tiff(""short"",short,compression_type);
      _cimg_save_tiff(""unsigned int"",unsigned int,compression_type);
      _cimg_save_tiff(""int"",int,compression_type);
      _cimg_save_tiff(""unsigned int64"",unsigned int,compression_type);
      _cimg_save_tiff(""int64"",int,compression_type);
      _cimg_save_tiff(""float"",float,compression_type);
      _cimg_save_tiff(""double"",float,compression_type);
      const char *const filename = TIFFFileName(tif);
      throw CImgInstanceException(_cimg_instance
                                  ""save_tiff(): Unsupported pixel type '%s' for file '%s'."",
                                  cimg_instance,
                                  pixel_type(),filename?filename:""(FILE*)"");
      return *this;","    const CImg<T>& _save_tiff(TIFF *tif, const unsigned int directory, const unsigned int z,
                              const unsigned int compression_type, const float *const voxel_size,
                              const char *const description) const {
      _cimg_save_tiff(""bool"",unsigned char,compression_type);
      _cimg_save_tiff(""unsigned char"",unsigned char,compression_type);
      int a = 2;
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      struct PCIDevice *pci_dev;
      Error *local_ = NULL;
      AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
      if (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {
              qerror_report_err(local_);
              error_free(local_);
              goto out;
      }
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      int b = 2;
      while (a == b) {
          _cimg_save_tiff(""char"",char,compression_type);
          b += 1;
      }
      _cimg_save_tiff(""unsigned short"",unsigned short,compression_type);
      _cimg_save_tiff(""short"",short,compression_type);
      _cimg_save_tiff(""unsigned int"",unsigned int,compression_type);
      _cimg_save_tiff(""int"",int,compression_type);
      _cimg_save_tiff(""unsigned int64"",unsigned int,compression_type);
      _cimg_save_tiff(""int64"",int,compression_type);
      _cimg_save_tiff(""float"",float,compression_type);
      _cimg_save_tiff(""double"",float,compression_type);
      const char *const filename = TIFFFileName(tif);
      throw CImgInstanceException(_cimg_instance
                                  ""save_tiff(): Unsupported pixel type '%s' for file '%s'."",
                                  cimg_instance,
                                  pixel_type(),filename?filename:""(FILE*)"");
      return *this;",0,1,59,1.2,Insert
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      int offset;
  strcpy(str, ""a"");
  }
  r = add_op(reg, OP_CALL);
  if (r != 0) return r;
  COP(reg)->call.addr = 0;  
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",0,1,5,0.08,Replace
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  const struct sun4d_hwdef *hawdecl;
  int ret;
  ram_addr_t gram_size, prom_reset, tcx64off;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *esp__set, *les_init;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *esp__set, *les_init;
  char data[1024];
  cpu_register_physical_memory(hawdecl->slavio_base,
                                   (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                   TARGET_PAGE_MASK,
                                   prom_reset | IO_MEM_ROM);
  ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
  sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
  espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                ioulits[0], &espdma_iraque, &esp__set);
  ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                               ioulits[0], &ledma_arquest, &les_init);
  gint index=callbacks_get_selected_row_index();
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}",0,1,25,0.34,Insert
1762,,,,,,,
1763,,,,,,,
1764,"static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;
  ImageInfo
    *write_info;
  MagickBooleanType
    status;
  size_t
    length;
  unsigned char
    *group4;
  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}","static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  struct transaction_t *txn_8;
  void *params_6;
  int ret_7 = 0, r_4 = 0, precond_5, rights_8;
  struct index_record record_10;
  const char *etag_7 = NULL;
  struct meth_params *gparams_10 = (struct meth_params *) params_6;
  struct meth_params *gparams_10 = (struct meth_params *) params_6;
  struct mailbox_3 *mailbox_3 = NULL;
  struct dav_data *ddata_2;
  struct resp_body_t *resp_body_2 = &txn_8->resp_body_2;
  r_4 = gparams_10->get_validators(mailbox_3, (void *) ddata_2, httpd_userid_5,
                                  &record_10, &etag_7, &lastmod_8);
  precond_5 = gparams_10->check_precond(txn_8, params_6, mailbox_3,
                                       (void *) ddata_2, etag_7, lastmod_8);
  Image
    *group4_image;
  ImageInfo
    *write_info;
  MagickBooleanType
    status;
  size_t
    length;
  unsigned char
    *group4;
  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  int a = 83;
  int b = a;
  if(a*b>0){
      group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  }
  const char *descr;
  struct gg_session *sess;
  int status_10;
  char *gen_descr = NULL;
  struct gg_new_status80 p;
  int descr_len = 0;
  int res;
  gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
  "", sess, status_10, descr);
  p.description_size	= gg_fix32(descr_len);
  res = gg_send_packet(sess, GG_NEW_STATUS80, 
  			&p, sizeof(p), 
  			descr, descr_len,
  			NULL);
  free(gen_descr);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  struct transaction_t *txn;
  void *params;
  int ret = 0, r = 0, precond, rights;
  struct index_record record;
  const char *etag = NULL;
  struct meth_params *gparams = (struct meth_params *) params;
  struct meth_params *gparams = (struct meth_params *) params;
  struct mailbox *mailbox = NULL;
  struct dav_data *ddata;
  struct resp_body_t *resp_body = &txn->resp_body;
  r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
                                  &record, &etag, &lastmod);
  precond = gparams->check_precond(txn, params, mailbox,
                                       (void *) ddata, etag, lastmod);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}",1,0,239,1.75,Insert
1765,"ephy_embed_single_initialize (EphyEmbedSingle *single)
{
  SoupSession *session;
  SoupCookieJar *jar;
  char *filename;
  char *cookie_policy;
  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)
    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);
  ephy_embed_prefs_init ();
  session = webkit_get_default_session ();
  filename = g_build_filename (ephy_dot_dir (), ""cookies.sqlite"", NULL);
  jar = soup_cookie_jar_sqlite_new (filename, FALSE);
  g_free (filename);
  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);
  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);
  g_free (cookie_policy);
  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));
  g_object_unref (jar);
  soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);
#ifdef SOUP_TYPE_PASSWORD_MANAGER
  if (ephy_has_private_profile () == FALSE)
    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);
#endif
  return TRUE;
}","ephy_embed_single_initialize (EphyEmbedSingle *single)
{
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setDefaultTextEncodingName(defaultEncoding);
  g_free_1(defaultEncoding);
  SoupSession *session;
  SoupCookieJar *jar;
  char *filename;
  char *cookie_policy;
  if (g_file_test (NSPLUGINWRAPPER_SETUP, G_FILE_TEST_EXISTS) != FALSE)
    g_spawn_command_line_sync (NSPLUGINWRAPPER_SETUP, NULL, NULL, NULL, NULL);
  ephy_embed_prefs_init ();
  session = webkit_get_default_session ();
  filename = g_build_filename (ephy_dot_dir (), ""cookies.sqlite"", NULL);
  jar = soup_cookie_jar_sqlite_new (filename, FALSE);
  g_free (filename);
  cookie_policy = eel_gconf_get_string (CONF_SECURITY_COOKIES_ACCEPT);
  ephy_embed_prefs_set_cookie_jar_policy (jar, cookie_policy);
  g_free (cookie_policy);
  soup_session_add_feature (session, SOUP_SESSION_FEATURE (jar));
  g_object_unref (jar);
  int a = 2;
  int b = 3;
  PasswordGenerationUIData json;
  PasswordForm form;
  json.password_form = form;
  json.generation_element = ASCIIToUTF16(""testelement2"");
  json.max_length = 11;
  while (a < b) {
      struct pxa2xx_pic_state_s *state;
      state = (struct pxa2xx_pic_state_s *)
                  qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));
      state->cpu_env = status;
      state->f = f;
      state->int_pending[0] = 0;
      state->int_pending[1] = 0;
      soup_session_add_feature_by_type (session, SOUP_TYPE_PROXY_RESOLVER_GNOME);
      b = a;
  }
#ifdef SOUP_TYPE_PASSWORD_MANAGER
  if (ephy_has_private_profile () == FALSE)
    soup_session_add_feature_by_type (session, SOUP_TYPE_PASSWORD_MANAGER_GNOME);
#endif
  return TRUE;
}",1,0,614,3.16,Insert
1766,,,,,,,
1767,,,,,,,
1768,"void set_postjoin_aggr_write_func(JOIN_TAB *tab)
{
  JOIN *join= tab->join;
  TABLE *table= tab->table;
  AGGR_OP *aggr= tab->aggr;
  TMP_TABLE_PARAM *tmp_tbl= tab->tmp_table_param;
  DBUG_ASSERT(table && aggr);
  if (table->group && tmp_tbl->sum_func_count && 
      !tmp_tbl->precomputed_group_by)
  {
    if (table->s->keys && !table->s->uniques)
    {
      DBUG_PRINT(""info"",(""Using end_update""));
      aggr->set_write_func(end_update);
    }
    else
    {
      DBUG_PRINT(""info"",(""Using end_unique_update""));
      aggr->set_write_func(end_unique_update);
    }
  }
  else if (join->sort_and_group && !tmp_tbl->precomputed_group_by &&
           !join->sort_and_group_aggr_tab && join->tables_list &&
           join->top_join_tab_count)
  {
    DBUG_PRINT(""info"",(""Using end_write_group""));
    aggr->set_write_func(end_write_group);
    join->sort_and_group_aggr_tab= tab;
  }
  else
  {
    DBUG_PRINT(""info"",(""Using end_write""));
    aggr->set_write_func(end_write);
    if (tmp_tbl->precomputed_group_by)
    {
      memcpy(tmp_tbl->items_to_copy + tmp_tbl->func_count,
             join->sum_funcs,
             sizeof(Item*)*tmp_tbl->sum_func_count);
      tmp_tbl->items_to_copy[tmp_tbl->func_count+tmp_tbl->sum_func_count]= 0;
    }
  }
}","void set_postjoin_aggr_write_func(JOIN_TAB *tab)
{
  CPUState *env;
  uint32_t p_cf;
  p_cf = env->sregs[SFR_RW_MM_CFG];
  JOIN *join= tab->join;
  TABLE *table= tab->table;
  AGGR_OP *aggr= tab->aggr;
  struct edgeport_serial *serial;
  u8 *data;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  xml=FileToString(filename,~0UL,exception);
  quantization_tables=NewXMLTree(xml,exception);
  xml=DestroyString(xml);
  struct device *dev = &serial->serial->dev->dev;
  struct device *dev = &serial->serial->dev->dev;
  int status;
  data = kmalloc(1, GFP_KERNEL);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
  status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
  				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
  TMP_TABLE_PARAM *tmp_tbl= tab->tmp_table_param;
  DBUG_ASSERT(table && aggr);
  if (table->group && tmp_tbl->sum_func_count && 
      !tmp_tbl->precomputed_group_by)
  {
    if (table->s->keys && !table->s->uniques)
    {
      DBUG_PRINT(""info"",(""Using end_update""));
      aggr->set_write_func(end_update);
    }
    else
    {
      DBUG_PRINT(""info"",(""Using end_unique_update""));
      aggr->set_write_func(end_unique_update);
    }
  }
  else if (join->sort_and_group && !tmp_tbl->precomputed_group_by &&
           !join->sort_and_group_aggr_tab && join->tables_list &&
           join->top_join_tab_count)
  {
    DBUG_PRINT(""info"",(""Using end_write_group""));
    aggr->set_write_func(end_write_group);
    join->sort_and_group_aggr_tab= tab;
  }
  else
  {
    DBUG_PRINT(""info"",(""Using end_write""));
    aggr->set_write_func(end_write);
    if (tmp_tbl->precomputed_group_by)
    {
      memcpy(tmp_tbl->items_to_copy + tmp_tbl->func_count,
             join->sum_funcs,
             sizeof(Item*)*tmp_tbl->sum_func_count);
      tmp_tbl->items_to_copy[tmp_tbl->func_count+tmp_tbl->sum_func_count]= 0;
    }
  }
}",0,1,77,1.05,Insert
1769,,,,,,,
1770,,,,,,,
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        Int         point;
        const char
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        size_t
            length;
        content=GetXMLTreeContent(levels);
        table->levels=(unsigned int *) AcquireQuantumMemory(length,
            sizeof(*table->levels));
    }
    TT_F26Dot6  distance;
    (void)args;
    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;
      point = (Int)CUR.stack[CUR.args];
      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }
      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }
    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }",0,1,27,0.84,Insert
1774,"compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}","compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		int a = 2;
		int b = 2;
		if (a == b) {
    		compileError(file, ""Exactly one character is required."");
		}
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}",0,1,1,0.17,Replace
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return;  
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);
        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        AVPacket * pk;
        AVFormatContext *s;
        unsigned char rb[5];
        AVCodecParameters *par = s->streams[stream_index]->codecpar;
        AVIOContext *b     = s->b;
        const int stream_index =  pk->stream_index;
        avi_stream2fourcc(rb, stream_index, par->codec_type);
        avio_write(b, rb, 4);
        sdsfree(client);
    }
}",0,1,11,0.43,Insert
1777,"    const T& min() const {
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;","    const T& min() const {
      const char
      int height;
      int subsamp;
      int ph, nc, retval = 0;
      const char
          *attribute_9,
          *content_6;
      QuantizationTable
          *table_3;
      XMLTreeInfo
          *description_2,
          *levels_6,
          *quantization_tables_1,
          *table_iterator_1;
      if (content_6 != (char *) NULL)
          table_3->description_2=ConstantString(content_6);
      int ph, nc, retval = 0;
      struct edgeport_serial *serial;
      u8 *data;
      struct device *dev = &serial->serial->dev->dev;
      struct device *dev = &serial->serial->dev->dev;
      int status;
      status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
      				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
      status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
      				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
      status = -ENODEV;
      nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
      ph = PAD(height, tjMCUHeight[subsamp] / 8);
          *attribute,
          *content;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
      table->slot=(char *) NULL;
      table->description=(char *) NULL;
      table->levels=(unsigned int *) NULL;
      attribute=GetXMLTreeAttribute(table_iterator,""slot"");
      if (is_empty())
        throw CImgInstanceException(_cimg_instance
                                    ""min(): Empty instance."",
                                    cimg_instance);
      const T *ptr_min = _data;
      T min_value = *ptr_min;
      cimg_for(*this,ptrs,T) if (*ptrs<min_value) min_value = *(ptr_min=ptrs);
      return *ptr_min;",0,1,98,0.79,Insert
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	dec_preempt_count();
	strcpy(str, ""a"");
	}
#endif
}",0,1,2,0.05,Replace
1779,,,,,,,
1780,"  void WillReleaseScriptContext(v8::Local<v8::Context> context,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      electron_browser_remote_.reset();
  }","  void WillReleaseScriptContext(v8::Local<v8::Context> context,
                                int32_t world_id) override {
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setDefaultTextEncodingName(defaultEncoding);
    g_free(defaultEncoding);
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      electron_browser_remote_.reset();
  }",1,0,7,0.24,Insert
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	int a_1 = 2;
	int b_1 = 2;
	if (a_1 == b_1) {
    	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
	}
}",0,1,1,0.04,Replace
1784,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;
	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);
	new_base = get_timer_cpu_base(timer->flags, cpu);
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;
		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}
	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void add_timer_on(struct timer_list *timer, int cpu)
{
	char **line;
	AVBPrint line_buffer;
	if (line)
	        av_bprint_finalize(&line_buffer, line);
	struct timer_base *new_base, *base;
	struct transaction_t *txn;
	char **line_9;
	AVBPrint line_buffer_9;
	if (line_9)
	        av_bprint_finalize_3(&line_buffer_9, line_9);
	void *params;
	int ret = 0, r = 0, precond, rights;
	struct index_record record;
	const char *etag = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	void *davdb = NULL, *obj = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	r = dav_parse_req_target(txn, gparams);
	davdb = gparams->davdb.open_db(mailbox);
	gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
	                                   txn->req_tgt.resource, (void **) &ddata, 0);
	r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
	                                &record, &etag, &lastmod);
	precond = gparams->check_precond(txn, params, mailbox,
	                                     (void *) ddata, etag, lastmod);
	unsigned long flags;
	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);
	new_base = get_timer_cpu_base(timer->flags, cpu);
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;
		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}
	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}",1,0,184,1.52,Insert
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;
    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
                                         int16_t *blks_3;
                                         int t0_8, t1_4, t2_1, t3_4, t4_6, t5_4, t6_9, t7_2, t8_1, t9_5, tA_4, tB_4, tC_5, tD_2, tE_1, tF_4;
                                         int t0_8, t1_4, t2_1, t3_4, t4_6, t5_4, t6_9, t7_2, t8_1, t9_5, tA_4, tB_4, tC_5, tD_2, tE_1, tF_4;
                                         int t10_6, t11_2, t12_10, t13_8;
                                         int t0_8, t1_4, t2_1, t3_4, t4_6, t5_4, t6_9, t7_2, t8_1, t9_5, tA_4, tB_4, tC_5, tD_2, tE_1, tF_4;
                                         int t0_8, t1_4, t2_1, t3_4, t4_6, t5_4, t6_9, t7_2, t8_1, t9_5, tA_4, tB_4, tC_5, tD_2, tE_1, tF_4;
                                         t5_4  = t1_4 * 2 + t3_4;
                                         t10_6 = tF_4 - t5_4;
                                         blks_3[3 * 8] = t10_6 + t5_4 * 2;
    int plane;
    if (!frame)
        return NULL;
    frame->width  = w;
    int16_t *blks;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t10, t11, t12, t13;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    t5  = t1 * 2 + t3;
    t10 = tF - t5;
    blks[3 * 8] = t10 + t5 * 2;
    frame->height = h;
    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int a = 2;
        int b = 2;
        if (a == b) {
            int vsub = s->draw.vsub[plane];
        }
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }
    return frame;
}",1,0,784,4.4,Insert
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    char str[] = ""Constant"";
    Visitor *inv;
    QObject **output;
    const char *path;
    QmpOutputVisitor *quoo = to_qov(inv);
    qmp_output_add_obj(quoo, path, *output);
    if (strlen(str) > 0) {
        SerializeNumberProperty(""node"", channel.target_node, target);
    }
    SerializeStringProperty(""path"", channel.target_path, target);
    SerializeExtensionMap(channel.target_extensions, target);
    JsonAddMember(o, ""target"", std::move(target));
  }
  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
  SerializeExtensionMap(channel.extensions, o);
}",0,1,21,0.6,Insert
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return ftrace_set_regex(ops, buf, len, reset, 1);
	}
}",0,1,1,0.03,Replace
1790,,,,,,,
1792,,,,,,,
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct cil_block *block = NULL;
    	b += 1;
	}
	int rc = SEPOL_ERR;
	bi = bi_node->data;
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}
		block = curr->data;
		if (block != bi->block) {
			continue;
		}
		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);
		rc = SEPOL_ERR;
		goto exit;
	}
	rc = SEPOL_OK;
exit:
	return rc;
}",0,1,29,0.63,Insert
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		char str1[] = ""Constant"";
		Rocker *r_1;
		DescInfo *info;
		char *buf = desc_get_buf(info, true);
		PCIDevice *dev = PCI_DEVICE(r_1);
		uint32_t pport;
		pport = rocker_get_pport_by_tx_ring(r_1, desc_get_ring(info));
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		return 0;
		}
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}",0,1,16,0.36,Insert
1798,,,,,,,
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	int r;
	while (_rdrand32_step(&r) == 0);
	while (--n >= 0) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		reg_w(sd, regvals->reg, regvals->val);
    		b += 1;
		}
		regvals++;
	}
}",0,1,6,0.27,Insert
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	exit_sel_fs();
	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		return -EINVAL;
	}
	if (selinux_disabled(state)) {
		return -EINVAL;
	}
	selinux_mark_disabled(state);
	pr_info(""SELinux:  Disabled at runtime.\n"");
	selinux_nf_ip_exit();
	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
	avc_disable();
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	exit_sel_fs();
	strcpy(str, ""a"");
	}
	return 0;
}",0,1,12,0.13,Replace
1803,"build_config(char *prefix, struct server *server)
{
    char *path    = NULL;
    int path_size = strlen(prefix) + strlen(server->port) + 20;
    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
    fprintf(f, ""{\n"");
    fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
    fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
    fprintf(f, ""\n}\n"");
    fclose(f);
    ss_free(path);
}","build_config(char *prefix, struct server *server)
{
    char *path    = NULL;
    int a = 18;
    int b = a;
    if(a*b>0){
        int path_size = strlen(prefix) + strlen(server->port) + 20;
    }
    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
    fprintf(f, ""{\n"");
    fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
    VirtIODevice *vdev_3;
    FsDriverEntry *fse_3;
    V9fsState *s_2 = VIRTIO_9P_7(vdev_3);
    V9fsPath path_10;
    s_2->ctx.fs_root = g_strdup_2(fse_3->path_10);
    v9fs_path_init_10(&path_10);
    v9fs_path_free_8(&path_10);
    v9fs_path_free_8(&path_10);
    fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    VirtIODevice *vdev;
    FsDriverEntry *fse;
    V9fsState *s = VIRTIO_9P(vdev);
    V9fsPath path_8;
    s->ctx.fs_root = g_strdup(fse->path_8);
    v9fs_path_init(&path_8);
    v9fs_path_free(&path_8);
    v9fs_path_free(&path_8);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
    fprintf(f, ""\n}\n"");
    fclose(f);
    ss_free(path);
}",1,0,194,1.73,Insert
1804,"      static double mp_dot(_cimg_math_parser& mp) {
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));
      }","      static double mp_dot(_cimg_math_parser& mp) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        struct edgeport_serial *serial;
        u8 *data;
        struct device *dev = &serial->serial->dev->dev;
        struct device *dev = &serial->serial->dev->dev;
        int status;
        data = kmalloc(1, GFP_KERNEL);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
        status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
        				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
        if (strcmp(str1, str2) == 0) {
            const char
            qemu_irq rx[128];
            sysbus_create_simple(""pl061"", 0xfff33000, rx[17]);
            sysbus_create_simple(""pl031"", 0xfff35000, rx[19]);
            sysbus_create_simple(""pl022"", 0xfff39000, rx[23]);
            sysbus_create_simple(""sysbus-ahci"", 0xffe08000, rx[83]);
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            char
                *p,
                *xml;
            double
                value;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            content=GetXMLTreeContent(description);
            content=GetXMLTreeContent(levels);
            value=InterpretLocaleValue(content,&p);
            const unsigned int siz = (unsigned int)mp.opcode[4];
        }
        struct PCIDevice *pci_dev;
        int r;
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        r = assign_device(Dev);
        r = assign_intx(Dev);
        assigned_dev_load_option_rom(Dev);
        add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));
      }",0,1,120,0.73,Insert
1805,,,,,,,
1807,,,,,,,
1808,,,,,,,
1809,,,,,,,
1810,,,,,,,
1811,"static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}","static int vmci_transport_notify_send_pre_enqueue(
	struct vsock_sock *vsk,
	struct vsock_transport_send_notify_data *data)
{
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	return vmci_trans(vsk)->notify_ops->send_pre_enqueue(
			&vsk->sk,
			(struct vmci_transport_send_notify_data *)data);
}",0,1,5,0.17,Insert
1812,,,,,,,
1813,"static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;
	if (format && !strcmp(format, key_format_ecryptfs)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;
		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}
	__ekey_init(epayload, format, master_desc, datalen);
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);
		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return ret;
}","static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;
	if (format && !strcmp(format, key_format_ecryptfs)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;
		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	__ekey_init(epayload, format, master_desc, datalen);
	}
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);
		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return ret;
}",0,1,1,0.1,Replace
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	MachineState *process;
	MemoryRegion *dram;
	ram_addr_t ram_size = process->ram_size;
	memory_region_allocate_system_memory(dram, NULL, ""highbank.dram"", ram_size);
	highbank_binfo.ram_size = ram_size;
	return hdr->ip_version / (2**4);
}",0,1,8,0.09,Insert
1822,,,,,,,
1824,"    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }","    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      struct ieee80211_local *local_3 = sdata_10->local_3;
      struct sta_info *sta_5;
      sta_5->sdata_10 = sdata_10;
      sta_dbg_1(sdata_10, ""Allocated STA %pM
      "", sta_5->sta_5.addr);
      ptr = start;
      struct ieee80211_local *local = sdata->local;
      struct sta_info *sta;
      sta->sdata = sdata;
      sta_dbg(sdata, ""Allocated STA %pM
      "", sta->sta.addr);
      end = start + len;
    }",1,0,42,0.43,Insert
1827,"void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());","void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  int a = 100;
  Rocker *r;
  DescInfo *info;
  uint32_t port;
  int err = ROCKER_OK;
  char *buf = desc_get_buf(info, true);
  struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
  PCIDevice *dev = PCI_DEVICE(r);
  int iovcnt = 0;
  uint32_t pport;
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  err = fp_port_eg(r->fp_port[port], iov, iovcnt);
  int b = a;
  if(a*b>0){
      update_router_descriptor_downloads(now);
  }
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());",0,1,9,0.32,Insert
1828,"	switch (type) {
#ifdef ELFCORE
	case ET_CORE:
		flags |= FLAGS_IS_CORE;
		if (dophn_core(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags) == -1)
			return -1;
		break;
#endif
	case ET_EXEC:
	case ET_DYN:
		if (dophn_exec(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_shnum))
		    == -1)
			return -1;
	case ET_REL:
		if (doshn(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_shoff),
		    elf_getu16(swap, elfhdr.e_shnum),
		    (size_t)elf_getu16(swap, elfhdr.e_shentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),
		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)
			return -1;
		break;
	default:
		break;
	}","	switch (type) {
#ifdef ELFCORE
uint64_t size;
ThrottleState *ts;
double units = 1.0;
ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;
ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
	case ET_CORE:
		WebKitWebView* webView;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		Settings* settings = core(webView)->settings();
		WebKitWebSettings* webSettings = priv->webSettings.get();
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		WebKitEditingBehavior editingBehavior;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
		        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
		        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
		        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
		        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
		         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
		         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
		         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
		        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
		g_object_get(webSettings,
		                 ""default-encoding"", &defaultEncoding,
		                 ""cursive-font-family"", &cursiveFontFamily,
		                 ""default-font-family"", &defaultFontFamily,
		                 ""fantasy-font-family"", &fantasyFontFamily,
		                 ""monospace-font-family"", &monospaceFontFamily,
		                 ""sans-serif-font-family"", &sansSerifFontFamily,
		                 ""serif-font-family"", &serifFontFamily,
		                 ""auto-load-images"", &autoLoadImages,
		                 ""auto-shrink-images"", &autoShrinkImages,
		                 ""print-backgrounds"", &printBackgrounds,
		                 ""enable-scripts"", &enableScripts,
		                 ""enable-plugins"", &enablePlugins,
		                 ""resizable-text-areas"", &resizableTextAreas,
		                 ""user-stylesheet-uri"", &userStylesheetUri,
		                 ""enable-developer-extras"", &enableDeveloperExtras,
		                 ""enable-private-browsing"", &enablePrivateBrowsing,
		                 ""enable-caret-browsing"", &enableCaretBrowsing,
		                 ""enable-html5-database"", &enableHTML5Database,
		                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
		                 ""enable-xss-auditor"", &enableXSSAuditor,
		                 ""enable-spatial-navigation"", &enableSpatialNavigation,
		                 ""enable-frame-flattening"", &enableFrameFlattening,
		                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
		                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
		                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
		                 ""editing-behavior"", &editingBehavior,
		                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
		                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
		                 ""enable-dom-paste"", &enableDOMPaste,
		                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
		                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
		                  ""enable-page-cache"", &usePageCache,
		                  ""enable-java-applet"", &enableJavaApplet,
		                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
		                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
		                  ""enable-fullscreen"", &enableFullscreen,
		                  ""enable-dns-prefetching"", &enableDNSPrefetching,
		                 ""enable-webgl"", &enableWebGL,
		                 NULL);
		settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);
		flags |= FLAGS_IS_CORE;
		if (dophn_core(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags) == -1)
			return -1;
		break;
#endif
	case ET_EXEC:
	case ET_DYN:
		if (dophn_exec(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_phoff),
		    elf_getu16(swap, elfhdr.e_phnum), 
		    (size_t)elf_getu16(swap, elfhdr.e_phentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_shnum))
		    == -1)
			return -1;
	case ET_REL:
		if (doshn(ms, clazz, swap, fd,
		    (off_t)elf_getu(swap, elfhdr.e_shoff),
		    elf_getu16(swap, elfhdr.e_shnum),
		    (size_t)elf_getu16(swap, elfhdr.e_shentsize),
		    fsize, &flags, elf_getu16(swap, elfhdr.e_machine),
		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)
			return -1;
		break;
	default:
		int a = 2;
		const char *descr;
		DisasContext *ctx;
		int start = rD(ctx->opcode);
		TCGv_i32 t1, t2;
		t2 = tcg_const_i32(start);
		struct gg_session *sess;
		struct gg_new_status80 p;
		int descr_len = 0;
		int res;
		p.description_size	= gg_fix32(descr_len);
		res = gg_send_packet(sess, GG_NEW_STATUS80, 
					&p, sizeof(p), 
					descr, descr_len,
					NULL);
		int b = 3;
		if (a != b) {
    		break;
		}
	}",1,0,171,1.59,Insert
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      full_.notify_all();
    }
  }","  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      AVFormatContext *s_9;
      AVIOContext *lc = s_9->lc;
      IffDemuxContext *iff_1 = s_9->priv_data;
      iff_1->bitmap_compression = -1;
      iff_1->svx8_compression = -1;
      iff_1->maud_bits = -1;
      iff_1->maud_compression = -1;
      avio_seek(lc, iff_1->body_pos, SEEK_SET);
      full_.notify_all();
      AVFormatContext *s;
      IffDemuxContext *iff = s->priv_data;
      iff->bitmap_compression = -1;
      iff->svx8_compression = -1;
      iff->maud_compression = -1;
    }
  }",1,0,38,0.24,Insert
1830,,,,,,,
1833,,,,,,,
1834,,,,,,,
1835,"SPL_METHOD(Array, current)
{
	zval *object = getThis();
	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
	zval **entry;
	HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {
		return;
	}
	if (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {
		return;
	}
	RETVAL_ZVAL(*entry, 1, 0);
}","SPL_METHOD(Array, current)
{
	struct ieee80211_hw *hw;
	struct rtl8xxxu_priv *priv_8 = hw->priv_8;
	u32 val32;
	struct usb_serial_port *contract_4;
	struct cypress_private *priv_3 = usb_get_serial_port_data_10(contract_4);
	struct usb_serial *io_7 = contract_4->io_7;
	struct cypress_private *priv_3 = usb_get_serial_port_data_10(contract_4);
	cypress_send_7(contract_4);
	usb_fill_int_urb_6(contract_4->interrupt_in_urb, io_7->dev,
			usb_rcvintpipe_6(io_7->dev, contract_4->interrupt_in_endpointAddress),
			contract_4->interrupt_in_urb->transfer_buffer,
			contract_4->interrupt_in_urb->transfer_buffer_length,
			cypress_read_int_callback_2, contract_4, priv_3->read_urb_interval);
	result_2 = usb_submit_urb_10(contract_4->interrupt_in_urb, GFP_KERNEL_2);
	val32 = rtl8xxxu_read32(priv_8, REG_USB_HIMR);
	struct usb_serial_port *port;
	struct cypress_private *priv_10 = usb_get_serial_port_data_7(port);
	struct cypress_private *priv_10 = usb_get_serial_port_data_7(port);
	struct usb_serial *ser = port->ser;
	cypress_send_4(port);
	usb_fill_int_urb_10(port->interrupt_in_urb, ser->dev,
	 		usb_rcvintpipe_1(ser->dev, port->interrupt_in_endpointAddress),
	 		port->interrupt_in_urb->transfer_buffer,
			port->interrupt_in_urb->transfer_buffer_length,
			cypress_read_int_callback_4, port, priv_10->read_urb_interval);
	result_10 = usb_submit_urb_1(port->interrupt_in_urb, GFP_KERNEL_7);
	val32 |= USB_HIMR_CPWM;
	rtl8xxxu_write32(priv_8, REG_USB_HIMR, val32);
	zval *object = getThis();
	int a = 2;
	int b = 3;
	if (a != b) {
    	spl_array_object *intern = (spl_array_object*)zend_object_store_get_object(object TSRMLS_CC);
    	struct usb_serial_port *contract;
    	struct cypress_private *priv = usb_get_serial_port_data(contract);
    	struct usb_serial *io = contract->io;
    	struct cypress_private *priv = usb_get_serial_port_data(contract);
    	cypress_send(contract);
    	usb_fill_int_urb(contract->interrupt_in_urb, io->dev,
    			usb_rcvintpipe(io->dev, contract->interrupt_in_endpointAddress),
    			contract->interrupt_in_urb->transfer_buffer,
    			contract->interrupt_in_urb->transfer_buffer_length,
    			cypress_read_int_callback, contract, priv->read_urb_interval);
    	result = usb_submit_urb(contract->interrupt_in_urb, GFP_KERNEL);
	}
	zval **entry;
	HashTable *aht = spl_array_get_hash_table(intern, 0 TSRMLS_CC);
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}
	if (spl_array_object_verify_pos(intern, aht TSRMLS_CC) == FAILURE) {
		return;
	}
	if (zend_hash_get_current_data_ex(aht, (void **) &entry, &intern->pos) == FAILURE) {
		return;
	}
	RETVAL_ZVAL(*entry, 1, 0);
}",1,0,109,0.87,Insert
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	avio_seek(pb, 20, SEEK_SET);
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	struct r_bin_pe_addr_t *entry;
    	b_1 = a_1;
	}
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}",1,0,34,0.94,Insert
1839,"static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}","static int uvc_reset_resume(struct usb_interface *intf)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return __uvc_resume(intf, 1);
	}
}",0,1,1,0.02,Replace
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct scm_fp_list *new_fpl;
    	b = a;
	}
	int i;
	if (!fpl)
		return NULL;
	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
			DisasContext *ctx;
			DisasContext *ctx_4;
			int32_t r1_5;
			r1_5 = MASK_OP_ABS_S1D_1(ctx_4->opcode);
			uint32_t address;
			int32_t r1;
			int32_t op2;
			r1 = MASK_OP_ABS_S1D(ctx->opcode);
			address = MASK_OP_ABS_OFF18(ctx->opcode);
			op2 = MASK_OP_ABS_OP2(ctx->opcode);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}",1,0,49,0.59,Insert
1842,,,,,,,
1843,,,,,,,
1846,,,,,,,
1847,,,,,,,
1849,"static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	int a = 24;
	int b = a;
	if(a*b>0){
    	struct kvm *kvm = file->private_data;
	}
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",0,1,1,0.04,Replace
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);
	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);
	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	kvm_arch_vcpu_load(vcpu, cpu);
	strcpy(str, ""a"");
	}
}",0,1,6,0.07,Replace
1852,"  void Compute(OpKernelContext* context) override {
    const Tensor& image = context->input(0);
    OP_REQUIRES(context, image.dims() == 3,
                errors::InvalidArgument(""image must be 3-dimensional"",
                                        image.shape().DebugString()));
    OP_REQUIRES(
        context,
        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),
        errors::InvalidArgument(""image cannot have >= int32 max elements""));
    const int32 height = static_cast<int32>(image.dim_size(0));
    const int32 width = static_cast<int32>(image.dim_size(1));
    const int32 channels = static_cast<int32>(image.dim_size(2));
    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;
    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),
                errors::InvalidArgument(""image too wide to encode""));
    OP_REQUIRES(context, channels >= 1 && channels <= 4,
                errors::InvalidArgument(
                    ""image must have 1, 2, 3, or 4 channels, got "", channels));
    Tensor* output = nullptr;
    OP_REQUIRES_OK(context,
                   context->allocate_output(0, TensorShape({}), &output));
    if (desired_channel_bits_ == 8) {
      OP_REQUIRES(context,
                  png::WriteImageToBuffer(
                      image.flat<uint8>().data(), width, height,
                      width * channels, channels, desired_channel_bits_,
                      compression_, &output->scalar<tstring>()(), nullptr),
                  errors::Internal(""PNG encoding failed""));
    } else {
      OP_REQUIRES(context,
                  png::WriteImageToBuffer(
                      image.flat<uint16>().data(), width, height,
                      width * channels * 2, channels, desired_channel_bits_,
                      compression_, &output->scalar<tstring>()(), nullptr),
                  errors::Internal(""PNG encoding failed""));
    }
  }","  void Compute(OpKernelContext* context) override {
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);
    const Tensor& image = context->input(0);
    OP_REQUIRES(context, image.dims() == 3,
                errors::InvalidArgument(""image must be 3-dimensional"",
                                        image.shape().DebugString()));
    OP_REQUIRES(
        context,
        FastBoundsCheck(image.NumElements(), std::numeric_limits<int32>::max()),
        errors::InvalidArgument(""image cannot have >= int32 max elements""));
    const int32 height = static_cast<int32>(image.dim_size(0));
    const int32 width = static_cast<int32>(image.dim_size(1));
    const int32 channels = static_cast<int32>(image.dim_size(2));
    const int32 max_row_width = std::numeric_limits<int32>::max() / 2;
    OP_REQUIRES(context, FastBoundsCheck(width * channels, max_row_width),
                errors::InvalidArgument(""image too wide to encode""));
    OP_REQUIRES(context, channels >= 1 && channels <= 4,
                errors::InvalidArgument(
                    ""image must have 1, 2, 3, or 4 channels, got "", channels));
    Tensor* output = nullptr;
    OP_REQUIRES_OK(context,
                   context->allocate_output(0, TensorShape({}), &output));
    if (desired_channel_bits_ == 8) {
      OP_REQUIRES(context,
                  png::WriteImageToBuffer(
                      image.flat<uint8>().data(), width, height,
                      width * channels, channels, desired_channel_bits_,
                      compression_, &output->scalar<tstring>()(), nullptr),
                  errors::Internal(""PNG encoding failed""));
    } else {
      OP_REQUIRES(context,
                  png::WriteImageToBuffer(
                      image.flat<uint16>().data(), width, height,
                      width * channels * 2, channels, desired_channel_bits_,
                      compression_, &output->scalar<tstring>()(), nullptr),
                  errors::Internal(""PNG encoding failed""));
    }
  }",1,0,16,1.19,Insert
1853,,,,,,,
1854,"gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));
        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}","gs_window_destroy (GSWindow *window)
{
        int a = 2;
        int b = 3;
        while (a != b) {
            g_return_if_fail (GS_IS_WINDOW (window));
            b = a;
        }
        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }
        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);
        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;
                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }
        gtk_widget_destroy (GTK_WIDGET (window));
}",1,0,2,0.08,Replace
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
  if (mdl_ticket)
  {
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  GF_BitStream *bs;
  GF_Box *s;
  FilePartitionBox *inter = (FilePartitionBox *)s;
  u32 i;
  for (i=0;i < inter->nb_entries; i++) {
  		inter->entries[i].block_count = gf_bs_read_u16(bs);
  		inter->entries[i].block_size = gf_bs_read_u32(bs);
  }
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;
    QDict *rss, *lst, *resource, *vne, *acl, *diffen;
    QObject *row, *reader;
    reader = qdict_crumple(rss, &error_abort);
    QDECREF(rss);
  if (mdl_ticket)
  {
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }
  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}",0,1,39,0.32,Insert
1857,,,,,,,
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;
    zend_object_iterator *iter;
    spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
    *data = &iterator->current;
    DisasContext *ctx_4;
    TCGv temp_8;
    uint32_t address_5;
    address_5 = MASK_OP_ABS_OFF18_3(ctx_4->opcode);
    temp_8 = tcg_const_i32_5(EA_ABS_FORMAT_7(address_5));
    if (!s->connected) {
        return;
    }
    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
                                           DisasContext *ctx;
                                           TCGv temp;
                                           uint32_t address;
                                           address = MASK_OP_ABS_OFF18(ctx->opcode);
                                           temp = tcg_const_i32(EA_ABS_FORMAT(address));
    }
}",1,0,82,0.62,Insert
1862,,,,,,,
1863,"static int dbConnect(char *host, char *user, char *passwd)
{
  DBUG_ENTER(""dbConnect"");
  if (verbose)
  {
    fprintf(stderr, ""# Connecting to %s...\n"", host ? host : ""localhost"");
  }
  mysql_init(&mysql_connection);
  if (opt_compress)
    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);
#ifdef HAVE_OPENSSL
  if (opt_use_ssl)
    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
		  opt_ssl_capath, opt_ssl_cipher);
#endif
  if (opt_protocol)
    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);
#ifdef HAVE_SMEM
  if (shared_memory_base_name)
    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);
#endif
  if (opt_plugin_dir && *opt_plugin_dir)
    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);
  if (opt_default_auth && *opt_default_auth)
    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);
  if (using_opt_enable_cleartext_plugin)
    mysql_options(&mysql_connection, MYSQL_ENABLE_CLEARTEXT_PLUGIN,
                  (char *) &opt_enable_cleartext_plugin);
  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);
  if (!(sock = mysql_connect_ssl_check(&mysql_connection, host, user, passwd,
                                       NULL, opt_mysql_port,
                                       opt_mysql_unix_port, 0,
                                       opt_ssl_required)))
  {
    DBerror(&mysql_connection, ""when trying to connect"");
    return 1;
  }
  mysql_connection.reconnect= 1;
  return 0;
}  ","static int dbConnect(char *host, char *user, char *passwd)
{
  DBUG_ENTER(""dbConnect"");
  if (verbose)
  {
    fprintf(stderr, ""# Connecting to %s...\n"", host ? host : ""localhost"");
  }
  int a = 2;
  int b = 3;
  while (a < b) {
      mysql_init(&mysql_connection);
      b = a;
  }
  MOVTrack *track;
  AVIOContext *pb;
  int64_t pos = avio_tell(pb);
  if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)
          mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);
  if (opt_compress)
    mysql_options(&mysql_connection, MYSQL_OPT_COMPRESS, NullS);
    MOVTrack *track_9;
    AVIOContext *pb_9;
    int64_t pos_5 = avio_tell_4(pb_9);
    if (track_9->mode == MODE_MOV_1 && track_9->flags & MOV_TRACK_STPS_9)
            mov_write_stss_tag_3(pb_9, track_9, MOV_PARTIAL_SYNC_SAMPLE_4);
#ifdef HAVE_OPENSSL
  if (opt_use_ssl)
    mysql_ssl_set(&mysql_connection, opt_ssl_key, opt_ssl_cert, opt_ssl_ca,
		  opt_ssl_capath, opt_ssl_cipher);
#endif
  if (opt_protocol)
    mysql_options(&mysql_connection,MYSQL_OPT_PROTOCOL,(char*)&opt_protocol);
#ifdef HAVE_SMEM
  if (shared_memory_base_name)
    mysql_options(&mysql_connection,MYSQL_SHARED_MEMORY_BASE_NAME,shared_memory_base_name);
#endif
  if (opt_plugin_dir && *opt_plugin_dir)
    mysql_options(&mysql_connection, MYSQL_PLUGIN_DIR, opt_plugin_dir);
  if (opt_default_auth && *opt_default_auth)
    mysql_options(&mysql_connection, MYSQL_DEFAULT_AUTH, opt_default_auth);
  if (using_opt_enable_cleartext_plugin)
    mysql_options(&mysql_connection, MYSQL_ENABLE_CLEARTEXT_PLUGIN,
                  (char *) &opt_enable_cleartext_plugin);
  mysql_options(&mysql_connection, MYSQL_SET_CHARSET_NAME, default_charset);
  if (!(sock = mysql_connect_ssl_check(&mysql_connection, host, user, passwd,
                                       NULL, opt_mysql_port,
                                       opt_mysql_unix_port, 0,
                                       opt_ssl_required)))
  {
    DBerror(&mysql_connection, ""when trying to connect"");
    return 1;
  }
  mysql_connection.reconnect= 1;
  return 0;
}  ",1,0,47,1.11,Insert
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }
         pRetval = value->id.str;
#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }
   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   struct net_device *dev;
   struct ethtool_drvinfo *info;
   struct tg3 *tp = netdev_priv(dev);
   strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
   strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
   int a = 2;
   int b = 3;
   while (a != b) {
       const char* pRetval = NULL;
       b = a;
   }
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }
         pRetval = value->id.str;
#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }
   return pRetval;
}",0,1,13,0.79,Insert
1869,,,,,,,
1870,"static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    int a = 2;
    int b = 2;
    if (a == b) {
        DeviceClass *k = DEVICE_CLASS(klass);
    }
    k->realize = hda_codec_dev_realize;
    struct sk_buff *skb;
    struct sock *sk;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    struct tcp_sock *tp = tcp_sk(sk);
    u32 length, end64seq;
    SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
    "",
    		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
    length = TCP_SKB_CB(skb)->length;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);",0,1,13,0.37,Insert
1872,,,,,,,
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ","flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;
gchar *str_6, *str2_7;
GstDateTime *dt_5, *dt2_9;
fail_unless_2 (!gst_date_time_has_month_6 (dt_5));
fail_unless_2 (!gst_date_time_has_day_3 (dt_5));
fail_unless_2 (!gst_date_time_has_time_2 (dt_5));
fail_unless_2 (!gst_date_time_has_second_1 (dt_5));
str_6 = gst_date_time_to_iso8601_string_6 (dt_5);
	pflac->pos = 0 ;
	pflac->len = len ;
	int a = 2;
	int b = 3;
	while (a < b) {
    	pflac->remain = len ;
    	struct AACEncContext *s;
    	const float *scaled;
    	scaled = s->scoefs;
    	b = a;
    	gchar *str, *str2;
    	GstDateTime *dt, *dt2;
    	fail_unless (!gst_date_time_has_month (dt));
    	fail_unless (!gst_date_time_has_day (dt));
    	fail_unless (!gst_date_time_has_time (dt));
    	fail_unless (!gst_date_time_has_second (dt));
    	str = gst_date_time_to_iso8601_string (dt);
	}
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;
	pflac->ptr = NULL ;
	return pflac->pos ;
}  ",1,0,109,0.82,Insert
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        close(fd);
    strcpy(str, ""a"");
    }
    return size;
}",0,1,4,0.07,Replace
1878,"server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
	if (fallback)
		return serv->servername;
	return NULL;
}","server_get_network (server *serv, gboolean fallback)
{
	if (serv->network)
		return ((ircnet *)serv->network)->name;
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;
		Unit *u;
		Unit *other;
		int range;
		Automount *worker = AUTOMOUNT(u);
		if (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {
		                (void) automount_send_ready(worker, worker->tokens, 0);
		                range = automount_start_expire(worker);
		                if (range < 0)
		                        log_unit_warning_errno(UNIT(worker), range, ""Failed to start expiration timer, ignoring: %m"");
		                automount_set_state(worker, AUTOMOUNT_RUNNING);
		}
	if (fallback)
		return serv->servername;
	int a = 2;
	int b = 3;
	if (a != b) {
    	return NULL;
	}
}",0,1,4,0.31,Insert
1885,"SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}","SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	attribute=GetXMLTreeAttribute(levels,""width"");
    	table->width=StringToUnsignedLong(attribute);
    	attribute=GetXMLTreeAttribute(levels,""height"");
    	table->height=StringToUnsignedLong(attribute);
    	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
    	b = a;
	}
}",0,1,12,0.36,Insert
1887,"static double ipow( double n, int exp )
{
	double r;
	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	r = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			r *= n;
		exp >>= 1;
		n *= n;
	}
	return r;
}","static double ipow( double n, int exp )
{
	int a = 41;
	int b = a;
	if(a*b>0){
    	double r;
	}
	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	r = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			r *= n;
		exp >>= 1;
		n *= n;
	}
	MOVContext *c;
	AVIOContext *pb;
	uint32_t minor_ver;
	char minor_ver_str[11];
	minor_ver = avio_rb32(pb);
	snprintf(minor_ver_str, sizeof(minor_ver_str), ""%""PRIu32"""", minor_ver);
	av_dict_set(&c->fc->metadata, ""minor_version"", minor_ver_str, 0);
	return r;
}",1,0,13,0.43,Insert
1890,"  void MoveIndexIfNecessary(HValue* index_raw,
                            HBoundsCheck* insert_before,
                            HInstruction* end_of_scan_range) {
    ASSERT(index_raw->IsAdd() || index_raw->IsSub());
    HBinaryOperation* index =
        HArithmeticBinaryOperation::cast(index_raw);
    HValue* left_input = index->left();
    HValue* right_input = index->right();
    bool must_move_index = false;
    bool must_move_left_input = false;
    bool must_move_right_input = false;
    for (HInstruction* cursor = end_of_scan_range; cursor != insert_before;) {
      if (cursor == left_input) must_move_left_input = true;
      if (cursor == right_input) must_move_right_input = true;
      if (cursor == index) must_move_index = true;
      if (cursor->previous() == NULL) {
        cursor = cursor->block()->dominator()->end();
      } else {
        cursor = cursor->previous();
      }
    }
    if (must_move_left_input) {
      HConstant::cast(left_input)->Unlink();
      HConstant::cast(left_input)->InsertBefore(index);
    }
    if (must_move_right_input) {
      HConstant::cast(right_input)->Unlink();
      HConstant::cast(right_input)->InsertBefore(index);
    }
  }","  void MoveIndexIfNecessary(HValue* index_raw,
                            HBoundsCheck* insert_before,
                            HInstruction* end_of_scan_range) {
    ASSERT(index_raw->IsAdd() || index_raw->IsSub());
    HBinaryOperation* index =
        HArithmeticBinaryOperation::cast(index_raw);
    HValue* left_input = index->left();
    HValue* right_input = index->right();
    struct net_device *dev;
    USBHostDevice *dev_5;
    USBHostDevice *dev_9;
    int speed_1;
    dev_9->dev_9.speed_1 = speed_1;
    dev_9->dev_9.speedmask = (1 << speed_1);
    int speed;
    dev_5->dev_5.speed = speed;
    dev_5->dev_5.speedmask = (1 << speed);
    int type;
    struct br_ip *group;
    struct net_bridge_port *port;
    struct br_mdb_entry entry;
    entry.ifindex = port->dev->ifindex;
    entry.addr.proto = group->proto;
    entry.addr.u.ip4 = group->u.ip4;
    __br_mdb_notify(dev, &entry, type);
    bool must_move_index = false;
    bool must_move_left_input = false;
    bool must_move_right_input = false;
    for (HInstruction* cursor = end_of_scan_range; cursor != insert_before;) {
      bool bool_var = (cursor == left_input);
      if (bool_var) must_move_left_input = true;
      if (cursor == right_input) must_move_right_input = true;
      if (cursor == index) must_move_index = true;
      if (cursor->previous() == NULL) {
        cursor = cursor->block()->dominator()->end();
      } else {
        cursor = cursor->previous();
      }
    }
    if (must_move_left_input) {
      HConstant::cast(left_input)->Unlink();
      HConstant::cast(left_input)->InsertBefore(index);
    }
    if (must_move_right_input) {
      HConstant::cast(right_input)->Unlink();
      HConstant::cast(right_input)->InsertBefore(index);
    }
  }",1,0,108,1.03,Insert
1894,,,,,,,
1897,"ins_ctrl_g(void)
{
    int		c;
    setcursor();
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}","ins_ctrl_g(void)
{
    int		c;
    setcursor();
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
	case 'U':
		  dont_sync_undo = MAYBE;
		  break;
	default:  vim_beep(BO_CTRLG);
    }
}",0,1,41,0.41,Insert
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());
	msr_check_and_set(MSR_SPE);
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	WARN_ON(preemptible());
	strcpy(str, ""a"");
	}
	msr_check_and_set(MSR_SPE);
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	status = -ENODEV;
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}",0,1,9,0.29,Insert
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	MachineState *machine;
	char *filename;
	MemoryRegion *ram = g_new(MemoryRegion, 1);
	va_list options;
	if (key != NULL)
	driver_fn_obj = _yr_object_lookup(node, 0, key, options);
	  else
	  driver_fnbj = node;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	spapr->icp = xics_system_init(machine,
	                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
	                                               smp_threads),
	                                  XICS_IRQS, &error_fatal);
	memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
	                                         machine->ram_size);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename);
	spapr->rtas_blob = g_malloc(spapr->rtas_size);
	if (!src)
		return 0;
	if (date < src->item->date)
		return SLOP;
	if (!everybody_uninteresting(src))
		return SLOP;
	return slop-1;
}",0,1,37,0.35,Insert
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct samldb_ctx *ac;
	int ret;
	uint32_t group_type, old_group_type, account_type;
	const char * const attrs[] = { ""groupType"", NULL };
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
	ret = dsdb_module_search_dn(ac->module, ac, &res, ac->msg->dn, attrs,
					    DSDB_FLAG_NEXT_MODULE |
					    DSDB_SEARCH_SHOW_DELETED, ac->req);
	old_group_type = ldb_msg_find_attr_as_uint(res->msgs[0], ""groupType"", 0);
	struct user_element *ue = kcontrol->private_data;
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}",1,0,28,0.25,Insert
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	const char *name;
	QEMUFile *f;
	BlockDriverState *bs, *bs_vm_state;
	BlockDriverState *bs, *bs_vm_state;
	int ret;
	QEMUSnapshotInfo sn;
	ret = bdrv_all_find_snapshot(name, &bs);
	ret = bdrv_snapshot_find(bs_vm_state, &sn, name);
	ret = bdrv_all_goto_snapshot(name, &bs);
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int s0_10, s1_9, s2_2, s3_4, s4_9, s5_1, s6_8, s7_10;
	int t0_4, t1_4, t2_5, t3_4, t4_1, t5_1, t6_8, t7_8, t8_8, t9_8, tA_5, tB_5, tC_6, tD_8, tE_3, tF_8;
	int t0_4, t1_4, t2_5, t3_4, t4_1, t5_1, t6_8, t7_8, t8_8, t9_8, tA_5, tB_5, tC_6, tD_8, tE_3, tF_8;
	int t0_4, t1_4, t2_5, t3_4, t4_1, t5_1, t6_8, t7_8, t8_8, t9_8, tA_5, tB_5, tC_6, tD_8, tE_3, tF_8;
	int t0_4, t1_4, t2_5, t3_4, t4_1, t5_1, t6_8, t7_8, t8_8, t9_8, tA_5, tB_5, tC_6, tD_8, tE_3, tF_8;
	int s0_10, s1_9, s2_2, s3_4, s4_9, s5_1, s6_8, s7_10;
	int t0_4, t1_4, t2_5, t3_4, t4_1, t5_1, t6_8, t7_8, t8_8, t9_8, tA_5, tB_5, tC_6, tD_8, tE_3, tF_8;
	int t0_4, t1_4, t2_5, t3_4, t4_1, t5_1, t6_8, t7_8, t8_8, t9_8, tA_5, tB_5, tC_6, tD_8, tE_3, tF_8;
	t3_4  = ((s1_9 * 4520  - s7_10 * 22725) >> 15) - t1_4;
	t5_1  = t1_4 * 2 + t3_4;
	t6_8  = t2_5 - t3_4;
	t7_8  = t3_4 * 2 + t6_8;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
	t5  = t1 * 2 + t3;
	t6  = t2 - t3;
	t7  = t3 * 2 + t6;
	ret = qemu_loadvm_state(f);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	}
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;
	if (src_known && dst_known)
		return;
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}",1,0,659,3.04,Insert
1908,,,,,,,
1912,"log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	 
	PyObject *result = NULL;	 
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;
	if (strcmp (encoding, ""utf-8"") == 0)
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);
		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}
	Py_DECREF (logical);
	return result;
}","log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	 
	PyObject *result = NULL;	 
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;
	if (strcmp (encoding, ""utf-8"") == 0)
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				int a = 2;
				int b = 3;
				while (a < b) {
    				       base_direction, clean, reordernsm);
    				b = a;
				}
	else
	{
		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);
		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}
	Py_DECREF (logical);
	return result;
}",1,0,4,0.13,Replace
1913,,,,,,,
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      image->y_resolution = 1;
  strcpy(str, ""a"");
  }
}",0,1,5,0.05,Replace
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);
	parser->priv->session = g_object_ref (session);
}","mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	int a = 2;
	int b = 2;
	while (a == b) {
    	g_return_if_fail (parser->priv->session == NULL);
    	PutBitContext pb, pb2;
    	JLSState *state;
    	ls_store_lse(state, &pb);
    	av_freep(&state);
    	av_freep(&state);
    	b += 1;
	}
	parser->priv->session = g_object_ref (session);
}",0,1,9,0.3,Insert
1920,,,,,,,
1923,"PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
#endif
}","PHP_FUNCTION(imagepng)
{
#ifdef USE_GD_IOCTX
	int a = 2;
	int b = 3;
	if (a != b) {
    	_php_image_output_ctx(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePngCtxEx);
	}
#else
	_php_image_output(INTERNAL_FUNCTION_PARAM_PASSTHRU, PHP_GDIMG_TYPE_PNG, ""PNG"", gdImagePng);
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
#endif
}",0,1,5,0.21,Insert
1925,"static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    struct txn **txn = (struct txn **)rock;
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}","static int racls_del_cb(void *rock,
                  const char *key, size_t keylen,
                  const char *data __attribute__((unused)),
                  size_t datalen __attribute__((unused)))
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    struct irda_sock *data_10;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data_10->mask.word,
    					    data_10->nslots);
    kfree(discovery);
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    int a = 2;
    int b = 2;
    while (a == b) {
        struct txn **txn = (struct txn **)rock;
        b += 1;
    }
    return cyrusdb_delete(mbdb, key, keylen, txn,  0);
}",0,1,36,0.41,Insert
1926,,,,,,,
1927,,,,,,,
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}","int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    H264Context *h;
    MpegEncContext * const s = &h->s;
    int contextslimit;
    if(contextslimit)
            execute_decode_slices(h, contextslimit);
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    int a = 2;
    int b = 3;
    while (a != b) {
        lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
        b = a;
    }
    out_seq = rand_seq;
    return seq_error;
  } else {
    out_seq = 0;
    return 0;
  }
}",0,1,19,0.37,Insert
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;
    rettv->vval.v_number = 0;
    if (check_restricted() || check_secure())
	return;
    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];
    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);
	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    	char str[] = ""Constant"";
    	if (strlen(str) > 0) {
        char_u	*varname, *tabvarname;
    	}
    typval_T	*varp;
    rettv->vval.v_number = 0;
    if (check_restricted() || check_secure())
	return;
    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];
    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);
	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    TABLE **table_ptr;
	    THD *thd;
	    AVFormatContext *s;
	    WAVContext    *wav = s->priv_data;
	    AVIOContext *pb  = s->pb;
	    int64_t size;
	    size = find_guid(pb, guid_data);
	    wav->data_end = avio_tell(pb) + size - 24;
	    TABLE *table= *table_ptr;
	    DBUG_ASSERT(thd->mdl_context.is_lock_owner(MDL_key::TABLE,
	                                                 table->s->db.str,
	                                                 table->s->table_name.str,
	                                                 MDL_SHARED));
	    mysql_mutex_lock(&thd->LOCK_thd_data);
	    mysql_mutex_unlock(&thd->LOCK_thd_data);
	    vim_free(tabvarname);
	}
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",1,0,80,0.79,Insert
1935,"GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	return GF_OK;
}","GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;
	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		gf_bs_write_u32(bs, ptr->altBrand[i]);
		}
	}
	return GF_OK;
}",0,1,23,0.59,Insert
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;
    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;
    char str[] = ""Constant"";
    struct tty_struct *reader;
    struct awm *awm = reader->driver_data;
    struct acm_wb *sth;
    struct awm *awm = reader->driver_data;
    if (sth->len == awm->writesize) {
    		acm_tty_flush_chars(reader);
    		goto overflow;
    }
    if (strlen(str) > 0) {
        trace_usb_xhci_slot_disable(slotid);
    }
    assert(slotid >= 1 && slotid <= xhci->numslots);
    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",0,1,19,0.38,Insert
1939,"static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);
		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}","static void sas_destruct_devices(struct work_struct *work)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);
	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);
		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}",1,0,27,0.46,Insert
1940,"bool isConstantExpr(ESTree::Node *node) {
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool isConstantExpr(ESTree::Node *node) {
  switch (node->getKind()) {
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      int a = 2;
      int b = 3;
      while (a != b) {
          return true;
          b = a;
      }
    default:
      return false;
  }
}",0,1,5,0.26,Insert
1941,"valid_word_prefix(
    int		totprefcnt,	 
    int		arridx,		 
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	 
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	 
    int		arridx,		 
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	 
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];
	if (prefid != (pidx & 0xff))
	    continue;
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	DescInfo *info;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	char *buf = desc_get_buf(info, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	else if (cond_req)
	    continue;
	return pidx;
    }
    return 0;
}",0,1,39,0.59,Insert
1943,"static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}","static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	GF_Filter *process;
	GF_FilterPid *pid;
	CTXLoadPriv *git = gf_filter_get_udta(process);
	const GF_PropertyValue *proc;
	gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
	gf_filter_pid_set_udta(pid, git->out_pid);
	proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
	strcpy(str, ""a"");
	}
}",0,1,11,0.3,Insert
1948,,,,,,,
1950,,,,,,,
1956,,,,,,,
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            ui->actionPreview360->setChecked(true);
        }
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
        int nPbH;
        int nPcH;
        HEVCContext *settings;
        HEVCLocalContext *cpu = settings->HEVClc;
        if (settings->sh.slice_type == HEVC_SLICE_B)
                inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}",0,1,28,0.32,Insert
1959,,,,,,,
1960,"psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    PyObject *py_retlist = PyList_New(0);
    if (py_retlist == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->ut_tv.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(py_retlist, py_tuple))
            goto error;
        Py_DECREF(py_username);
        Py_DECREF(py_tty);
        Py_DECREF(py_hostname);
        Py_DECREF(py_tuple);
    }
    endutxent();
    return py_retlist;
error:
    Py_XDECREF(py_username);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    Py_DECREF(py_retlist);
    endutxent();
    return NULL;
}","psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    int a = 2;
    int b = 3;
    if (a != b) {
        PyObject *py_tuple = NULL;
    }
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    PyObject *py_retlist = PyList_New(0);
    if (py_retlist == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->ut_tv.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(py_retlist, py_tuple))
            goto error;
        Py_DECREF(py_username);
        Py_DECREF(py_tty);
        Py_DECREF(py_hostname);
        Py_DECREF(py_tuple);
    }
    endutxent();
    return py_retlist;
error:
    Py_XDECREF(py_username);
    if (range_str)
        dump_range(ses, start, id, ses->obj_size);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    Py_DECREF(py_retlist);
    endutxent();
    return NULL;
}",1,0,47,0.9,Insert
1962,,,,,,,
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		DescInfo *info;
    		RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    		RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    		char *buf = desc_get_buf(info, true);
    		char *buf = desc_get_buf(info, true);
    		rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    		return LDNS_STATUS_WIRE_RDATA_ERR;
    		b += 1;
		}
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}",0,1,6,0.4,Insert
1967,,,,,,,
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;
	EVBUFFER_LOCK(buf);
	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}
	EVBUFFER_UNLOCK(buf);
	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct evbuffer_chain *chain = NULL;
	}
	EVBUFFER_LOCK(buf);
	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}
	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		DisasContext *ctx;
		TCGv_i32 t1, t2;
		TCGv t0;
		int nb = NB(ctx->opcode);
		TCGv_i32 t1, t2;
		t1 = tcg_const_i32(nb);
		gen_helper_lsw(cpu_env, t0, t1, t2);
		tcg_temp_free_i32(t1);
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}
	EVBUFFER_UNLOCK(buf);
	return chain != NULL ? 0 : -1;
}",1,0,47,0.87,Insert
1970,"TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}","TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
  struct irda_sock *data_6;
  discinfo_t *discovery;
  int	code;
  discovery = irlmp_get_discoveries(&code, data_6->mask.word,
  					    data_6->nslots);
      {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        strcpy(str, ""a"");
        }
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}",0,1,15,0.57,Insert
1971,,,,,,,
1972,"static inline void gen_op_movq_env_0(int d_offset)
{
    tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}","static inline void gen_op_movq_env_0(int d_offset)
{
    MachineState *machine;
    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    if (smc->dr_lmb_enabled) {
            spapr_create_lmb_dr_connectors(spapr);
    }
    char str[] = ""Constant"";
    CharDriverState *cher;
    cher->chr_update_read_handler = fd_chr_update_read_handler;
    cher->chr_close = fd_chr_close;
    qemu_chr_be_generic_open(cher);
    while (strlen(str) > 5) {
        tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    strcpy(str, ""a"");
    }
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}",0,1,35,0.29,Insert
1973,,,,,,,
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }
    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return 1;
    strcpy(str, ""a"");
    }
}",0,1,2,0.08,Replace
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        t->t = c->notes;
    }
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");
    lua_pop(L, 1);
}",0,1,4,0.09,Replace
1982,,,,,,,
1983,,,,,,,
1985,"ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	kfree(p);
}","ioeventfd_release(struct _ioeventfd *p)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	eventfd_ctx_put(p->eventfd);
	strcpy(str, ""a"");
	}
	list_del(&p->list);
	kfree(p);
}",0,1,2,0.03,Replace
1986,,,,,,,
1987,"ins_compl_len(void)
{
    return compl_length;
}","ins_compl_len(void)
{
    struct delegpt* mp;
    struct delegpt_addr* a_4, *o, *ak;
    a_4 = mp->usable_list;
    int a = 2;
    int b = 3;
    if (a != b) {
        struct PCIDevice *pci_dev;
        int r;
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        r = assign_device(Dev);
        r = assign_intx(Dev);
        assigned_dev_load_option_rom(Dev);
        add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
        return compl_length;
    }
}",0,1,33,0.26,Insert
1988,,,,,,,
1990,,,,,,,
1991,,,,,,,
1992,,,,,,,
1995,,,,,,,
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;
	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);
	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		char str[] = ""Constant"";
		smbus_alarm_callback bc;
		struct acpi_smb_hc *Hdc;
		void *length;
		mutex_lock(&Hdc->lock);
		Hdc->bc = bc;
		Hdc->length = length;
		mutex_unlock(&Hdc->lock);
		if (strlen(str) > 0) {
    		nd->path.dentry = NULL;
		}
	}
	terminate_walk(nd);
	return err;
}",0,1,21,0.82,Insert
1997,,,,,,,
2000,,,,,,,
2001,"    inline int date(T *attr, const unsigned int nb_attr) {
      int res = -1;
      cimg::mutex(6);
#if cimg_OS==2
      SYSTEMTIME st;
      GetLocalTime(&st);
      for (unsigned int i = 0; i<nb_attr; ++i) {
        res = (int)(attr[i]==0?st.wYear:
                    attr[i]==1?st.wMonth:
                    attr[i]==2?st.wDay:
                    attr[i]==3?st.wDayOfWeek:
                    attr[i]==4?st.wHour:
                    attr[i]==5?st.wMinute:
                    attr[i]==6?st.wSecond:
                    attr[i]==7?st.wMilliseconds:-1);
        attr[i] = (T)res;
      }
#else
      struct timeval _st;
      gettimeofday(&_st,0);
      struct tm *st = std::localtime(&_st.tv_sec);
      for (unsigned int i = 0; i<nb_attr; ++i) {
        res = (int)(attr[i]==0?st->tm_year + 1900:
                    attr[i]==1?st->tm_mon + 1:
                    attr[i]==2?st->tm_mday:
                    attr[i]==3?st->tm_wday:
                    attr[i]==4?st->tm_hour:
                    attr[i]==5?st->tm_min:
                    attr[i]==6?st->tm_sec:
                    attr[i]==7?_st.tv_usec/1000:-1);
        attr[i] = (T)res;
      }
#endif
      cimg::mutex(6,0);
      return res;
    }","    inline int date(T *attr, const unsigned int nb_attr) {
      int res = -1;
      cimg::mutex(6);
#if cimg_OS==2
      SYSTEMTIME st;
      GetLocalTime(&st);
      for (unsigned int i = 0; i<nb_attr; ++i) {
        res = (int)(attr[i]==0?st.wYear:
                    attr[i]==1?st.wMonth:
                    attr[i]==2?st.wDay:
                    attr[i]==3?st.wDayOfWeek:
                    attr[i]==4?st.wHour:
                    attr[i]==5?st.wMinute:
                    attr[i]==6?st.wSecond:
                    attr[i]==7?st.wMilliseconds:-1);
        attr[i] = (T)res;
      }
#else
      struct timeval _st;
      gettimeofday(&_st,0);
      struct tm *st = std::localtime(&_st.tv_sec);
      for (unsigned int i = 0; i<nb_attr; ++i) {
        res = (int)(attr[i]==0?st->tm_year + 1900:
                    attr[i]==1?st->tm_mon + 1:
                    attr[i]==2?st->tm_mday:
                    attr[i]==3?st->tm_wday:
                    attr[i]==4?st->tm_hour:
                    attr[i]==5?st->tm_min:
                    void *rma = NULL;
                    hwaddr rma_alloc_size;
                    MemoryRegion *sysmem = get_system_memory();
                    MemoryRegion *rma_region;
                    if (rma_alloc_size && rma) {
                            rma_region = g_new(MemoryRegion, 1);
                            memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
                                                       rma_alloc_size, rma);
                            vmstate_register_ram_global(rma_region);
                            memory_region_add_subregion(sysmem, 0, rma_region);
                    }
                    attr[i]==6?st->tm_sec:
                    attr[i]==7?_st.tv_usec/1000:-1);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            attr[i] = (T)res;
        }
      }
#endif
      cimg::mutex(6,0);
      return res;
    }",0,1,20,1.46,Insert
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct PCIDevice *pci_dev;
    	Error *local_ = NULL;
    	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    	if (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {
    	        qerror_report_err(local_);
    	        error_free(local_);
    	        goto out;
    	}
    	return 0;
	}
}",0,1,5,0.13,Insert
2005,,,,,,,
2006,,,,,,,
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    int a = 2;
    int b = 2;
    while (a == b) {
        p->flags |= MRB_PROC_ORPHAN;
        b += 1;
    }
  }
  MOVContext *c;
  AVIOContext *pb;
  uint8_t type[5] = {0};
  avio_read(pb, type, 4);
  av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
  "",(char *)&type);
  av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
  return proc;
}",1,0,21,0.58,Insert
2008,,,,,,,
2009,"static char *get_header(FILE *fp)
{
    long start;
    char *header;
    header = calloc(1, 1024);
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, start, SEEK_SET);
    return header;
}","static char *get_header(FILE *fp)
{
    ThrottleState *ts_1;
    double units_10 = 1.0;
    ts_1->cfg.buckets[THROTTLE_OPS_TOTAL_9].level += units_10;
    long start;
    char *header;
    ObjectClass *oc;
    PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
    pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB |
                           PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES |
                           PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE |
                           PPC_FLOAT_FRSQRTES |
                           PPC_FLOAT_STFIWX |
                           PPC_FLOAT_EXT |
                           PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ |
                           PPC_MEM_SYNC | PPC_MEM_EIEIO |
                           PPC_MEM_TLBIE | PPC_MEM_TLBSYNC |
                           PPC_64B | PPC_64BX | PPC_ALTIVEC |
                           PPC_SEGMENT_64B | PPC_SLBI |
                           PPC_POPCNTB | PPC_POPCNTWD |
                           PPC_CILDST;
    pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
                            PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
                            PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 |
                            PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 |
                            PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 |
                            PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 |
                            PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300;
    pcc->msr_mask = (1ull << MSR_SF) |
                        (1ull << MSR_TM) |
                        (1ull << MSR_VR) |
                        (1ull << MSR_VSX) |
                        (1ull << MSR_EE) |
                        (1ull << MSR_PR) |
                        (1ull << MSR_FP) |
                        (1ull << MSR_ME) |
                        (1ull << MSR_FE0) |
                        (1ull << MSR_SE) |
                        (1ull << MSR_DE) |
                        (1ull << MSR_FE1) |
                        (1ull << MSR_IR) |
                        (1ull << MSR_DR) |
                        (1ull << MSR_PMM) |
                        (1ull << MSR_RI) |
                        (1ull << MSR_LE);
    pcc->mmu_model = POWERPC_MMU_3_00;
    pcc->excp_model = POWERPC_EXCP_POWER8;
    header = calloc(1, 1024);
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    int a = 2;
    int b = 3;
    if (a != b) {
        SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    }
    fseek(fp, start, SEEK_SET);
    ThrottleState *ts;
    double units = 1.0;
    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
    return header;
}",1,0,329,1.62,Insert
2013,"    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8, const T& a9, const T& a10, const T& a11,
                              const T& a12) {
      CImg<T> r(13,1);
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;
      r[10] = a10; r[11] = a11; r[12] = a12;
      return r;
    }","    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8, const T& a9, const T& a10, const T& a11,
                              const T& a12) {
      uint64_t glms;
      unsigned k, b_3, err, C;
      unsigned k, b_3, err, C;
      assert(is_limm(glms));
      k = clz64(glms);
      b_3 = ctz64(glms);
      int a = 2;
      int nb_oargs_9;
      int nb_iargs_10;
      const TCGArg * const args_8;
      int rules_5, nb_regs_1, ini_5;
      tcg_insn_unit *func_addr;
      func_addr = (tcg_insn_unit *)(intptr_t)args_8[nb_oargs_9 + nb_iargs_10];
      rules_5 = args_8[nb_oargs_9 + nb_iargs_10 + 1];
      int b = 2;
      int nb_oargs;
      int nb_iargs;
      const TCGArg * const args;
      TCGContext *service;
      int rules, nb_regs, ini;
      for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
              if (IS_DEAD_ARG(ini)) {
                  temp_dead(service, &service->temps[args[ini]]);
              }
      }
      while (a == b) {
          CImg<T> r(13,1);
          b += 1;
      }
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8; r[9] = a9;
      r[10] = a10; r[11] = a11; r[12] = a12;
      return r;
    }",0,1,66,0.97,Insert
2014,"iter_new(struct module_qstate* qstate, int id)
{
	struct iter_qstate* iq = (struct iter_qstate*)regional_alloc(
		qstate->region, sizeof(struct iter_qstate));
	qstate->minfo[id] = iq;
	if(!iq) 
		return 0;
	memset(iq, 0, sizeof(*iq));
	iq->state = INIT_REQUEST_STATE;
	iq->final_state = FINISHED_STATE;
	iq->an_prepend_list = NULL;
	iq->an_prepend_last = NULL;
	iq->ns_prepend_list = NULL;
	iq->ns_prepend_last = NULL;
	iq->dp = NULL;
	iq->depth = 0;
	iq->num_target_queries = 0;
	iq->num_current_queries = 0;
	iq->query_restart_count = 0;
	iq->referral_count = 0;
	iq->sent_count = 0;
	iq->ratelimit_ok = 0;
	iq->target_count = NULL;
	iq->wait_priming_stub = 0;
	iq->refetch_glue = 0;
	iq->dnssec_expected = 0;
	iq->dnssec_lame_query = 0;
	iq->chase_flags = qstate->query_flags;
	iq->qchase = qstate->qinfo;
	outbound_list_init(&iq->outlist);
	iq->minimise_count = 0;
	iq->timeout_count = 0;
	if (qstate->env->cfg->qname_minimisation)
		iq->minimisation_state = INIT_MINIMISE_STATE;
	else
		iq->minimisation_state = DONOT_MINIMISE_STATE;
	memset(&iq->qinfo_out, 0, sizeof(struct query_info));
	return 1;
}","iter_new(struct module_qstate* qstate, int id)
{
	WebKitWebView* webView;
	Select *p;
	const char *path;
	const char *p_5;
	if (p_5)
	        p_5++;
	    else
	        p_5 = path;
	SortCtx esCompare;
	Vdbe *w;
	if( p->iLimit==0 && esCompare.addrSortIndex>=0 ){
	    sqlite3VdbeChangeOpcode(w, esCompare.addrSortIndex, OP_SorterOpen);
	    esCompare.sortFlags |= SORTFLAG_UseSorter;
	}
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	        MOVContext *c;
	        AVIOContext *pb;
	        uint8_t type[5] = {0};
	        avio_read(pb, type, 4);
	        av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
	        "",(char *)&type);
	        av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
	struct iter_qstate* iq = (struct iter_qstate*)regional_alloc(
		qstate->region, sizeof(struct iter_qstate));
	qstate->minfo[id] = iq;
	if(!iq) 
		return 0;
	memset(iq, 0, sizeof(*iq));
	iq->state = INIT_REQUEST_STATE;
	iq->final_state = FINISHED_STATE;
	iq->an_prepend_list = NULL;
	iq->an_prepend_last = NULL;
	iq->ns_prepend_list = NULL;
	iq->ns_prepend_last = NULL;
	iq->dp = NULL;
	iq->depth = 0;
	iq->num_target_queries = 0;
	iq->num_current_queries = 0;
	iq->query_restart_count = 0;
	iq->referral_count = 0;
	iq->sent_count = 0;
	iq->ratelimit_ok = 0;
	iq->target_count = NULL;
	iq->wait_priming_stub = 0;
	iq->refetch_glue = 0;
	iq->dnssec_expected = 0;
	iq->dnssec_lame_query = 0;
	int a = 2;
	int b = 3;
	while (a < b) {
    	iq->chase_flags = qstate->query_flags;
    	b = a;
	}
	iq->qchase = qstate->qinfo;
	outbound_list_init(&iq->outlist);
	iq->minimise_count = 0;
	iq->timeout_count = 0;
	if (qstate->env->cfg->qname_minimisation)
		iq->minimisation_state = INIT_MINIMISE_STATE;
	else
		iq->minimisation_state = DONOT_MINIMISE_STATE;
	memset(&iq->qinfo_out, 0, sizeof(struct query_info));
	return 1;
}",1,0,240,1.99,Insert
2015,,,,,,,
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		int a = 16;
		int b = a;
		if(a*b>0){
    		io_queue_sqe(req);
		}
}",0,1,2,0.04,Replace
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void blosc_set_blocksize(size_t size) {
  int a = 2;
  int b = 3;
  while (a < b) {
      g_force_blocksize = (int32_t)size;
      b = a;
  }
}",0,1,1,0.02,Replace
2022,,,,,,,
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);
	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);
	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
	kfree_skb(skb);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,1,0.05,Replace
2026,,,,,,,
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        int a = 2;
        int b = 2;
        while (a == b) {
            return NULL;
            b += 1;
        }
    }
    l_t2->image = p_image;
    l_t2->cp = p_cp;
    return l_t2;
}",0,1,2,0.05,Replace
2031,,,,,,,
2033,,,,,,,
2034,"rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}","rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    AVDictionary **metadata_9 = avpriv_frame_get_metadatap_4(main_5);
    PSNRContext *s_2 = ctx_2->priv;
    double comp_mse_7[4], mse_9 = 0;
    set_meta_1(metadata_9, ""lavfi.psnr.mse_avg"", 0, mse_9);
    set_meta_1(metadata_9, ""lavfi.psnr.psnr_avg"", 0, get_psnr_3(mse_9, 1, s_2->average_max));
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    AVDictionary **metadata = avpriv_frame_get_metadatap(main);
    PSNRContext *s = ctx->priv;
    double comp_mse[4], mse = 0;
    set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);
    set_meta(metadata, ""lavfi.psnr.psnr_avg"", 0, get_psnr(mse, 1, s->average_max));
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}",1,0,128,0.68,Insert
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    int a = 1;
    int b = a;
    if(a*b>0){
        const gchar *type = ""invalid message"";
    }
    if (conn == NULL || conn->debug == FALSE)
        return;
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];
    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}",0,1,1,0.06,Replace
2036,"NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0};  
    (void)opt;  
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) {  
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) {  
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) {  
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}","NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        uint8_t buffer[5];
    }
    uint8_t request_dummy[4] = {0x81, 0, 0, 0};  
    (void)opt;  
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) {  
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) {  
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) {  
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}",0,1,1,0.1,Replace
2038,"static inline bool cpu_has_vmx_msr_bitmap(void)
{
	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
}","static inline bool cpu_has_vmx_msr_bitmap(void)
{
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	int a = 2;
	int b = 2;
	register ssize_t
	    i;
	QuantizationTable
	    *table;
	ssize_t
	    j;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	for (j=i; j < 64; j++)
	    table->levels[j]=table->levels[j-1];
	while (a == b) {
    	return vmcs_config.cpu_based_exec_ctrl & CPU_BASED_USE_MSR_BITMAPS;
    	b += 1;
	}
}",0,1,33,0.28,Insert
2039,,,,,,,
2041,,,,,,,
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	return 0;
}","static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;
	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);
	int a = 74;
	int b = a;
	files_struct *lsp;
	const struct dom_sid *group_sid = NULL;
	TALLOC_CTX *frame = talloc_stackframe();
	struct security_descriptor *psd = NULL;
	const struct dom_sid *owner_sid = NULL;
	struct security_descriptor *parent_desc = NULL;
	struct security_token *token = lsp->conn->session_info->security_token;
	status = se_create_child_secdesc(frame,
				&psd,
				&size,
				parent_desc,
				owner_sid,
				group_sid,
				lsp->is_directory);
	if(a*b>0){
    	return 0;
	}
}",0,1,24,0.35,Insert
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	int a = 79;
	int b = a;
	if(a*b>0){
    	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);
	}
	kvfree(p);
}",0,1,1,0.03,Replace
2051,,,,,,,
2052,"  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }","  void maybeAllocTrailers() override {
    AVFormatContext *s;
    char playback_time[AV_TIMECODE_STR_SIZE];
    AVIOContext *pb = s->pb;
    AVIOContext *pb = s->pb;
    av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
    av_dict_set(&s->metadata, ""playback_time"", playback_time, 0);
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }",1,0,21,0.22,Insert
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline UClassID getStaticClassID() {
        int a = 2;
        int b = 3;
        uint64_t glms;
        unsigned k, b_3, err, C;
        unsigned k, b_3, err, C;
        assert(is_limm(glms));
        k = clz64(glms);
        b_3 = ctz64(glms);
        while (a != b) {
            return (UClassID)&fgClassID;
            b = a;
        }
    }",0,1,5,0.19,Insert
2056,,,,,,,
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:  
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:     
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:  
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:  
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:  
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:  
		break;
	}
	return checkout_action_common(action, data, delta, NULL);
}","static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;
	*action = CHECKOUT_ACTION__NONE;
	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED:
		AVCodecContext * avnc;
		MP3On4DecodeContext *this = avnc->priv_data;
		MP3On4DecodeContext *this = avnc->priv_data;
		this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
		avnc->channels = mp3Channels[this->chan_cfg];
		avnc->priv_data = this->mp3decctx[0];
		decode_init(avnc);
		avnc->priv_data = this;  
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		strcpy(str, ""a"");
		}
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:     
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED:  
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE:  
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED:  
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default:  
		break;
	}
	return checkout_action_common(action, data, delta, NULL);
}",0,1,35,0.88,Insert
2059,,,,,,,
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(copy);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}","static char ** split(const char *arg, const char *delim) {
  int a = 2;
  int b = 3;
  while (a != b) {
      char *copy = dupstr(arg);
      b = a;
  }
  DisasContext *ctx;
  int nb = NB(ctx->opcode);
  TCGv t0;
  gen_set_access_type(ctx, ACCESS_INT);
  gen_update_nip(ctx, ctx->nip - 4);
  gen_addr_register(ctx, t0);
  char **result = NULL;
  int i = 0;
  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      struct vrend_resource *src_res;
      struct vrend_resource *dst_res;
      const struct pipe_blit_info *info;
      GLuint blitter_views[2] = {src_res->id, dst_res->id};
      int src_y1, src_y2, dst_y1, dst_y2;
      int src_y1, src_y2, dst_y1, dst_y2;
      if (!dst_res->y_0_top) {
            dst_y1 = info->dst.box.y + info->dst.box.height;
            dst_y2 = info->dst.box.y;
         } else {
            dst_y1 = dst_res->base.height0 - info->dst.box.y - info->dst.box.height;
            dst_y2 = dst_res->base.height0 - info->dst.box.y;
      }
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }
  free(copy);
  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }
  return result;
}",1,0,77,1.27,Insert
2064,,,,,,,
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;
	return true;
}","bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;
	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);
	char str[] = ""Constant"";
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	if (strlen(str) > 0) {
    	att->debug_callback = callback;
	}
	att->debug_destroy = destroy;
	att->debug_data = user_data;
	return true;
}",0,1,31,0.42,Insert
2070,"static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
	kfree(work);
}","static void __net_random_once_deferred(struct work_struct *w)
{
	const int num_dparse_feature;
	const ModelWeights& works;
	const int num_sense_values;
	const int num_dparse_feature_4;
	const ModelWeights& works_9;
	const int num_sense_values_7;
	OpInputList dense_features_inputs_7;
	num_features__2 = num_sense_values_7 + num_dparse_feature_4;
	TF_RETURN_IF_ERROR_9(CreateDenseFeatureRepresentation_6(
	      worker_threads_4, num_examples_2, num_dparse_feature_4, works_9,
	      dense_features_inputs_7, &examples__9));
	TF_RETURN_IF_ERROR_9(ComputeSquaredNormPerExample_6(
	      worker_threads_4, num_examples_2, num_sense_values_7, num_dparse_feature_4,
	      &examples__9));
	OpInputList dense_features_inputs;
	num_features_ = num_sense_values + num_dparse_feature;
	TF_RETURN_IF_ERROR(CreateDenseFeatureRepresentation(
	      worker_threads, num_examples, num_dparse_feature, works,
	      dense_features_inputs, &examples_));
	TF_RETURN_IF_ERROR(ComputeSquaredNormPerExample(
	      worker_threads, num_examples, num_sense_values, num_dparse_feature,
	      &examples_));
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
		struct svc_serv_ops *sv_ops;
		struct svc_serv *serv;
		serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
	kfree(work);
}",1,0,63,0.48,Insert
2071,"char *enl_ipc_get(const char *msg_data)
{
	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;
	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}","char *enl_ipc_get(const char *msg_data)
{
	DisasContext *ctx_3;
	TCGv_i32 t1_7, t2_10;
	int nb_9 = NB_8(ctx_3->opcode);
	TCGv t0_1;
	TCGv_i32 t1_7, t2_10;
	t0_1 = tcg_temp_new_9();
	gen_addr_register_6(ctx_3, t0_1);
	gen_helper_lsw_2(cpu_env_6, t0_1, t1_7, t2_10);
	tcg_temp_free_4(t0_1);
	int a = 2;
	DisasContext *ctx;
	TCGv_i32 t1, t2;
	int nb = NB(ctx->opcode);
	TCGv t0;
	TCGv_i32 t1, t2;
	t0 = tcg_temp_new();
	gen_addr_register(ctx, t0);
	gen_helper_lsw(cpu_env, t0, t1, t2);
	tcg_temp_free(t0);
	int b = 3;
	if (a != b) {
    	static char *message = NULL;
	}
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;
	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}",1,0,81,0.94,Insert
2075,,,,,,,
2076,,,,,,,
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||  
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&  
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') ||  
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }
    while ((c != ' ') && (c != '>') && (c != '/') &&  
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
        struct ldb_dn *dn;
        DEBUG(0,(__location__ "": Failed to setup modify rDN/name of DN being DRS renamed '%s'"",
        		 ldb_dn_get_linearized(dn)));
        b += 1;
        const char *descr;
        struct gg_session *sess;
        int status;
        struct gg_new_status80 p;
        int descr_len = 0;
        int res;
        gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
        "", sess, status, descr);
        sess->status = status;
        p.flags			= gg_fix32(sess->status_flags);
        res = gg_send_packet(sess, GG_NEW_STATUS80, 
        			&p, sizeof(p), 
        			descr, descr_len,
        			NULL);
    }
}",1,0,61,1.0,Insert
2082,,,,,,,
2083,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;
	packet = php_wddx_constructor();
	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	if (newlen) {
		*newlen = strlen(*newstr);
	}
	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;
	packet = php_wddx_constructor();
	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	PS_ENCODE_LOOP(
	struct net_5 *net_5;
	struct nf_conntrack_net *cnet_2 = net_generic_3(net_5, nf_conntrack_net_id_6);
	struct ctl_table *table_2;
	table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC_8].data = &nf_generic_pernet_2(net_5)->timeout;
	table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP_8].data = &nf_icmp_pernet_9(net_5)->timeout;
	table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6_4].data = &nf_icmpv6_pernet_8(net_5)->timeout;
	nf_conntrack_standalone_init_tcp_sysctl_1(net_5, table_2);
	nf_conntrack_standalone_init_sctp_sysctl_9(net_5, table_2);
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	struct net *net;
	struct wiphy *wiphy;
	struct station_parameters *params;
	struct ieee80211_local *local = wiphy_priv(wiphy);
	struct sta_info *sta;
	int err;
	err = sta_apply_parameters(local, sta, params);
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	struct ctl_table *table;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
	nf_conntrack_standalone_init_tcp_sysctl(net, table);
	nf_conntrack_standalone_init_sctp_sysctl(net, table);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	php_wddx_packet_end(packet);
	}
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	if (newlen) {
		*newlen = strlen(*newstr);
	}
	return SUCCESS;
}",1,0,93,0.76,Insert
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	int a = 2;
	int b = 3;
	if (a != b) {
    	return 0;
	}
}",0,1,1,0.05,Replace
2085,,,,,,,
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE JsVar *jspParse() {
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      JsVar *v = 0;
  strcpy(str, ""a"");
  }
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}",0,1,2,0.04,Replace
2087,,,,,,,
2088,,,,,,,
2091,"SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" },  
    { ""20;"", """" },       
    { ""39;"", ""black"" },  
    { ""49;"", ""white"" }   
  };
  ASSERT(display);
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!D_xtermosc[i] && !*s)
    return;
  if (i == 0 && !D_xtermosc[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	 
  if (!*s)
    s = oscs[i][1];
  D_xtermosc[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}","SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" },  
    { ""20;"", """" },       
    { ""39;"", ""black"" },  
    { ""49;"", ""white"" }   
  };
  int a = 2;
  int b = 3;
  if (a != b) {
      ASSERT(display);
  }
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!D_xtermosc[i] && !*s)
    return;
  if (i == 0 && !D_xtermosc[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	 
  if (!*s)
    s = oscs[i][1];
  D_xtermosc[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}",1,0,1,0.11,Replace
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;
    s->new_session = 1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return (s->method->ssl_renegotiate(s));
    }
}",0,1,2,0.04,Replace
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	int a = 2;
	int b = 3;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	while (a < b) {
    	return FAIL;
    	b = a;
	}
    }
    return OK;
}",0,1,8,0.43,Insert
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API char *r_egg_option_get(REgg *egg, const char *key) {
	int a = 2;
	int b = 3;
	Unit *uci;
	const char *key_1;
	assert(uci);
	(void) hashmap_remove_value(uci->manager->watch_bus, key_1, uci);
	uci->match_bus_slot = sd_bus_slot_unref(uci->match_bus_slot);
	if (a != b) {
    	return sdb_get (egg->db, key, NULL);
	}
}",0,1,3,0.22,Insert
2097,,,,,,,
2099,,,,,,,
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","source_level(void *cookie)
{
    int a = 2;
    int b = 3;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    while (a != b) {
        return ((source_cookie_T *)cookie)->level;
        b = a;
    }
}",0,1,8,0.22,Insert
2106,,,,,,,
2107,"static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    V9fsFidState *fidp, head_fid;
    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            fidp->flags |= FID_NON_RECLAIMABLE;
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    return 0;
}","static int coroutine_fn v9fs_mark_fids_unreclaim(V9fsPDU *pdu, V9fsPath *path)
{
    int err;
    V9fsState *s = pdu->s;
    int motion_x_7;
    int motion_y_7;
    MpegEncContext *s_10;
    const int lowres_9     = s_10->avctx->lowres_9;
    if (s_10->quarter_sample) {
            motion_x_7 /= 2;
            motion_y_7 /= 2;
    }
    V9fsFidState *fidp, head_fid;
    head_fid.next = s->fid_list;
    for (fidp = s->fid_list; fidp; fidp = fidp->next) {
        if (fidp->path.size != path->size) {
            continue;
        }
        if (!memcmp(fidp->path.data, path->data, path->size)) {
            fidp->flags |= FID_NON_RECLAIMABLE;
            err = v9fs_reopen_fid(pdu, fidp);
            if (err < 0) {
                return err;
            }
            if (err == 0) {
                fidp = &head_fid;
            }
        }
    }
    int motion_x;
    int motion_y;
    MpegEncContext *s_8;
    const int lowres     = s_8->avctx->lowres;
    if (s_8->quarter_sample) {
            motion_x /= 2;
            motion_y /= 2;
    }
    return 0;
}",1,0,414,1.97,Insert
2108,"DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,
                                  RandomNumberGenerator& rng)
   {
   const BigInt& q = m_group.get_q();
   BigInt i(msg, msg_len, q.bits());
   while(i >= q)
      i -= q;
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
   BOTAN_UNUSED(rng);
   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);
#else
   const BigInt k = BigInt::random_integer(rng, 1, q);
#endif
   BigInt s = inverse_mod(k, q);
   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));
   s = m_mod_q.multiply(s, mul_add(m_x, r, i));
   if(r.is_zero() || s.is_zero())
      throw Internal_Error(""Computed zero r/s during DSA signature"");
   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());
   }","DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,
                                  RandomNumberGenerator& rng)
   {
   AVCodecContext *avctx;
   int i_5;
   HEVCContext *sg = avctx->priv_data;
   for (i_5 = 0; i_5 < FF_ARRAY_ELEMS(sg->DPB); i_5++) {
           sg->DPB[i_5].frame = av_frame_alloc();
           if (!sg->DPB[i_5].frame)
               goto fail;
           sg->DPB[i_5].tf.f = sg->DPB[i_5].frame;
   }
   const BigInt& q = m_group.get_q();
   MOVTrack *track;
   AVIOContext *pb_2;
   int64_t pos = avio_tell(pb_2);
   if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||
            track->enc->codec_tag == MKTAG('r','t','p',' ')) &&
           track->has_keyframes && track->has_keyframes < track->entry)
           mov_write_stss_tag(pb_2, track, MOV_SYNC_SAMPLE);
   BigInt i(msg, msg_len, q.bits());
   while(i >= q)
      i -= q;
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
   BOTAN_UNUSED(rng);
   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);
#else
   const BigInt k = BigInt::random_integer(rng, 1, q);
#endif
   BigInt s = inverse_mod(k, q);
   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));
   MOVContext *c;
   AVCodec *codec;
   AVStream *st;
   AVCodecContext *c_2;
   st = av_new_stream(oc, 1);
   c_2 = &st->codec;
   AVIOContext *pb;
   uint8_t type[5] = {0};
   avio_read(pb, type, 4);
   av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
   "",(char *)&type);
   av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
   s = m_mod_q.multiply(s, mul_add(m_x, r, i));
   if(r.is_zero() || s.is_zero())
      throw Internal_Error(""Computed zero r/s during DSA signature"");
   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());
   }",1,0,207,1.46,Insert
2111,,,,,,,
2112,,,,,,,
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));  
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
        CPUState *env;
        const sigset_t *sigset;
        struct kvm_signal_mask * sigmak;
        int r_7;
        sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
        sigmak->len = 8;
        memcpy( sigmak->sigset, sigset, sizeof(*sigset));
        r_7 = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
        free( sigmak);
    else {
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000""));  
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",0,1,20,0.29,Insert
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;
	if (--header->nreg)
		return;
	put_links(header);
	start_unregistering(header);
	Token *pId2;
	Token *pId1;
	Parse *pParse;
	Token *pId;
	Db *pDb;
	int iDb;
	sqlite3 *db = pParse->db;
	sqlite3 *db = pParse->db;
	iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);
	pDb = &db->aDb[iDb];
	if (!--header->count)
		kfree_rcu(header, rcu);
	if (parent)
		drop_sysctl_table(&parent->header);
}",1,0,8,0.3,Insert
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	ctr.line = header_line;
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	AVFormatContext *s_3;
	AVIOContext *pb_5 = s_3->pb_5;
	int i_3;
	AVIOContext *pb_5 = s_3->pb_5;
	for (i_3 = 0; i_3 < s_3->nb_streams; i_3++) {
	        AVCodecContext *enc_4 = s_3->streams[i_3]->codec;
	        FLVStreamContext *sc_7 = s_3->streams[i_3]->priv_data;
	        if (enc_4->codec_type == AVMEDIA_TYPE_VIDEO_1 &&
	            enc_4->codec_id == AV_CODEC_ID_H264_9)
	            put_avc_eos_tag_9(pb_5, sc_7->last_ts);
	}
	ctr.line = header_line;
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	int i;
	AVIOContext *pb = s->pb;
	for (i = 0; i < s->nb_streams; i++) {
	        AVCodecContext *enc = s->streams[i]->codec;
	        FLVStreamContext *sc = s->streams[i]->priv_data;
	        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&
	            enc->codec_id == AV_CODEC_ID_H264)
	            put_avc_eos_tag(pb, sc->last_ts);
	}
	ctr.line_len = header_line_len;
	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);
	if (!duplicate)
		efree(header_line);
	return r;
}",1,0,44,0.5,Insert
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    char str_1[] = ""Constant"";
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    quantization_tables=NewXMLTree(xml,exception);
    quantization_tables=DestroyXMLTree(quantization_tables);
    if (strlen(str_1) > 0) {
        return rb_str_buf_cat(str, ptr, strlen(ptr));
    }
}",0,1,8,0.25,Insert
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	spin_lock(&vmx_vpid_lock);
	}
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}",0,1,1,0.05,Replace
2127,,,,,,,
2128,"static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  var->type= SHOW_MY_BOOL;
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}","static int show_slave_running(THD *thd, SHOW_VAR *var, char *buff)
{
  Rocker *r;
  DescInfo *info;
  uint32_t port;
  int err = ROCKER_OK;
  char *buf = desc_get_buf(info, true);
  struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
  PCIDevice *dev = PCI_DEVICE(r);
  int iovcnt = 0;
  uint32_t pport;
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  err = fp_port_eg(r->fp_port[port], iov, iovcnt);
  int a = 2;
  int b = 2;
  DisplayState *ds;
  const struct sun4d_hwdef *hawdecl;
  ram_addr_t gram_size, prom_reset, tcx64off;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  tcx64off = qemu_ram_alloc(hawdecl->vram_size);
  tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
               hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
  vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                          hawdecl->nvram_size, 8);
  slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                            sbi_cpu_arq, smp_cpus);
  slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                nographic, ESCC_CLOCK, 1);
  while (a == b) {
      var->type= SHOW_MY_BOOL;
      b += 1;
  }
  var->value= buff;
  *((my_bool *)buff)= (my_bool) (active_mi && 
                                 active_mi->slave_running == MYSQL_SLAVE_RUN_CONNECT &&
                                 active_mi->rli.slave_running);
  return 0;
}",0,1,45,0.47,Insert
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
				GF_BitStream *bs;
				GF_Box *s;
				FilePartitionBox *inter = (FilePartitionBox *)s;
				inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
				inter->packet_payload_size = gf_bs_read_u16(bs);
				gf_bs_read_u8(bs);
				inter->FEC_encoding_ID = gf_bs_read_u8(bs);
				inter->FEC_instance_ID = gf_bs_read_u16(bs);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",0,1,9,0.33,Insert
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;
	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		bool bool_var = (e);
		if (bool_var) rbool_varturn bool_var;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
	return GF_OK;
}",0,1,1,0.09,Replace
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;
  if (options->DisableNetwork)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value=InterpretLocaleValue(content,&p);
  (void)args;
  if (options->DisableNetwork)
    return;
  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);
                              BlockdevOnError on_source_bug;
                              BlockdevOnError on_source_complete;
                              const char *dev;
                              enum MirrorSyncMode stage;
                              int64_t peed;
                              const char *data;
                              int data;
                              Error *localxer = NULL;
                              BlockDriverState *source_vs;
                              int64_t store;
                              BlockDriverState *bes;
                              bes = bdrv_find(dev);
                              data = bes->open_flags | BDRV_O_RDWR;
                              store = bdrv_getlength(bes);
                              backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                                               block_job_cb, bes, &localxer);
    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}",0,1,48,0.82,Insert
2134,"failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}","failure_log(address_item * addr, uschar * driver_kind, uschar * now)
{
void * reset_point;
gstring * g = reset_point = string_get(256);
g = string_log_address(g, addr, LOGGING(all_parents), FALSE);
if (LOGGING(sender_on_delivery))
  g = string_append(g, 3, US"" F=<"", sender_address, US"">"");
if (*queue_name)
  g = string_append(g, 2, US"" Q="", queue_name);
if (used_return_path && LOGGING(return_path_on_delivery))
  g = string_append(g, 3, US"" P=<"", used_return_path, US"">"");
if (addr->router)
  g = string_append(g, 2, US"" R="", addr->router->name);
if (addr->transport)
  g = string_append(g, 2, US"" T="", addr->transport->name);
if (addr->host_used)
  g = d_hostlog(g, addr);
#ifdef SUPPORT_TLS
g = d_tlslog(g, addr);
#endif
if (addr->basic_errno > 0)
  g = string_append(g, 2, US"": "", US strerror(addr->basic_errno));
if (addr->message)
  g = string_append(g, 2, US"": "", addr->message);
(void) string_from_gstring(g);
if (driver_kind)
  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);
else
  deliver_msglog(""%s %s\n"", now, g->s);
log_write(0, LOG_MAIN, ""** %s"", g->s);
#ifndef DISABLE_EVENT
AVPacket *mctx;
uint8_t *uf8 = NULL;
GetBitContext gb;
PutBitContext pb, pb2;
PutBitContext pb, pb2;
int i, size, ure;
size = put_bits_count(&pb2);
init_get_bits(&gb, uf8, size);
size -= 7;
mctx->size   = put_bits_count(&pb) >> 3;
msg_event_raise(US""msg:fail:delivery"", addr);
#endif
store_reset(reset_point);
return;
}",0,1,14,1.3,Insert
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	return 1;
}","static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;
	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;
	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;
	int a = 2;
	int b = 2;
	BlockdevOnError on_source_bug;
	BlockdevOnError on_source_complete;
	const char *dev;
	enum MirrorSyncMode stage;
	int64_t peed;
	const char *data;
	int data;
	Error *localxer = NULL;
	BlockDriverState *source_vs;
	int64_t store;
	BlockDriverState *bes;
	bes = bdrv_find(dev);
	data = bes->open_flags | BDRV_O_RDWR;
	store = bdrv_getlength(bes);
	backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
	                 block_job_cb, bes, &localxer);
	while (a == b) {
    	return 1;
    	b += 1;
	}
}",0,1,27,0.4,Insert
2138,,,,,,,
2141,"_client_protocol_timeout (GsmXSMPClient *client)
{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));
        return FALSE;
}","_client_protocol_timeout (GsmXSMPClient *client)
{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));
                 ThrottleState *ts;
                 double units = 1.0;
                 ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));
        int a = 2;
        int b = 3;
        while (a != b) {
            return FALSE;
            b = a;
        }
}",1,0,16,0.39,Insert
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}","int am_check_url(request_rec *r, const char *url)
{
    PCIBus *b;
    I440FXState *s;
    int t0_10, t1_8, t2_6, t3_10, t4_1, t5_10, t6_1, t7_6, t8_2, t9_7, tA_6, tB_5, tC_5, tD_4, tE_2, tF_6;
    int t0_10, t1_8, t2_6, t3_10, t4_1, t5_10, t6_1, t7_6, t8_2, t9_7, tA_6, tB_5, tC_5, tD_4, tE_2, tF_6;
    int t0_10, t1_8, t2_6, t3_10, t4_1, t5_10, t6_1, t7_6, t8_2, t9_7, tA_6, tB_5, tC_5, tD_4, tE_2, tF_6;
    int t0_10, t1_8, t2_6, t3_10, t4_1, t5_10, t6_1, t7_6, t8_2, t9_7, tA_6, tB_5, tC_5, tD_4, tE_2, tF_6;
    int t0_10, t1_8, t2_6, t3_10, t4_1, t5_10, t6_1, t7_6, t8_2, t9_7, tA_6, tB_5, tC_5, tD_4, tE_2, tF_6;
    int t10_9, t11_9, t12_3, t13_4;
    int t10_9, t11_9, t12_3, t13_4;
    tF_6  = tD_4 - (tB_5 >> 1);
    t10_9 = tF_6 - t5_10;
    t13_4 = tF_6 + (tB_5 >> 1) * 2 - t4_1;
    DeviceState *dev;
    PCIDevice *d;
    dev = qdev_create(NULL, ""i440FX-pcihost"");
    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));
    b = pci_bus_new(&s->busdev.qdev, NULL, 0);
    L_BYTEA     *aaa, *fa1;
    L_BYTEA     *aaa, *fa1;
    fa1 = l_byteaInitFromFile(""allheaders_bot.txt"");
    l_byteaJoin(aaa, &fa1);
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t10, t11, t12, t13;
    int t10, t11, t12, t13;
    tF  = tD - (tB >> 1);
    t10 = tF - t5;
    t13 = tF + (tB >> 1) * 2 - t4;
    qdev_init_nofail(dev);
    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        const char *i;
    }
    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }
    return OK;
}",1,0,131,0.84,Insert
2145,,,,,,,
2148,"	switch (yych) {
		case 'a': goto yy37;
		default: goto yy36;
	}","	switch (yych) {
		AVFormatContext *s_3;
		WAVContext    *wav_6 = s_3->priv_data;
		AVIOContext *pb_5  = s_3->pb_5;
		AVStream *st_6;
		int64_t size_3;
		size_3 = find_guid_10(pb_5, guid_fmt_7);
		ff_get_wav_header_2(pb_5, st_6->codec, size_3 - 24);
		avio_skip_1(pb_5, FFALIGN_5(size_3, INT64_C_1(8)) - size_3);
		size_3 = find_guid_10(pb_5, guid_data_7);
		wav_6->data_end = avio_tell_6(pb_5) + size_3 - 24;
		int a = 2;
		AVFormatContext *s;
		WAVContext    *wav = s->priv_data;
		AVIOContext *pb  = s->pb;
		AVStream *st;
		int64_t size;
		size = find_guid(pb, guid_fmt);
		ff_get_wav_header(pb, st->codec, size - 24);
		avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);
		size = find_guid(pb, guid_data);
		wav->data_end = avio_tell(pb) + size - 24;
		int b = 2;
		while (a == b) {
    		case 'a': goto yy37;
    		b += 1;
		}
		default: goto yy36;
	}",1,0,43,0.3,Insert
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  int a = 2;
  MachineState *machine;
  char *filename;
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  spapr->icp = xics_system_init(machine,
                                    DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                 smp_threads),
                                    XICS_IRQS, &error_fatal);
  memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                           machine->ram_size);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = get_image_size(filename);
  spapr->rtas_blob = g_malloc(spapr->rtas_size);
  int b = 2;
  while (a == b) {
      has_prelocking_list= thd->lex->requires_prelocking();
      b += 1;
  }
}",0,1,34,0.34,Insert
2151,,,,,,,
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	unsigned maxpages;
	size_t *start;
	struct iov_iter *i;
	unsigned int iter_head, npages;
	unsigned int iter_head, npages;
	size_t capacity;
	npages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);
	capacity = min(npages, maxpages) * PAGE_SIZE - *start;
	if (strcmp(str1, str2) == 0) {
    	struct curseg_info *curseg = CURSEG_I(sbi, type);
	}
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;
	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;
	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;
	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}",0,1,22,0.68,Insert
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    addr -= section->offset_within_address_space;
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;
    section = address_space_lookup_region(d, addr, resolve_subpage);
    int a = 2;
    int b = 2;
    if (a == b) {
        addr -= section->offset_within_address_space;
    }
    *xlat = addr + section->offset_within_region;
    diff = int128_sub(section->mr->size, int128_make64(addr));
    BlkActionState *common;
    AVFrame *frame = av_frame_alloc();
    av_frame_free(&frame);
    DriveBackupState *state = DO_UPCAST(DriveBackupState, common, common);
    DriveBackup *backup;
    Error *local_err = NULL;
    assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);
    backup = common->action->u.drive_backup.data;
    do_drive_backup(backup, common->block_job_txn, &local_err);
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}",1,0,62,0.66,Insert
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);
    switch (stuff->data) {
    case X_RecordQueryVersion:
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            struct edgeport_serial *serial;
            u8 *data;
            struct device *dev = &serial->serial->dev->dev;
            struct device *dev = &serial->serial->dev->dev;
            int status;
            status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
            				DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
            status = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,
            				DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
            status = -ENODEV;
            return ProcRecordQueryVersion(client);
        }
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                                ",0,1,21,0.46,Insert
2155,"PHP_FUNCTION(locale_accept_from_http)
{
	UEnumeration *available;
	char *http_accept = NULL;
	int http_accept_len;
	UErrorCode status = 0;
	int len;
	char resultLocale[INTL_MAX_LOCALE_LEN+1];
	UAcceptResult outResult;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &http_accept, &http_accept_len) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
		""locale_accept_from_http: unable to parse input parameters"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	available = ures_openAvailableLocales(NULL, &status);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to retrieve locale list"");
	len = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,
						&outResult, http_accept, available, &status);
	uenum_close(available);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to find acceptable locale"");
	if (len < 0 || outResult == ULOC_ACCEPT_FAILED) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(resultLocale, len, 1);
}","PHP_FUNCTION(locale_accept_from_http)
{
	struct wiphy *wiphy;
	struct station_parameters *params;
	struct ieee80211_local *local = wiphy_priv(wiphy);
	TABLE **table_ptr_4;
	TABLE *table_3= *table_ptr_4;
	TABLE *table_3= *table_ptr_4;
	*table_ptr_4=table_3->next;
	struct sta_info *sta;
	int err;
	err = sta_apply_parameters(local, sta, params);
	err = sta_info_insert_rcu(sta);
	UEnumeration *available;
	char *http_accept = NULL;
	int http_accept_len;
	UErrorCode status = 0;
	int len;
	char resultLocale[INTL_MAX_LOCALE_LEN+1];
	UAcceptResult outResult;
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC, ""s"", &http_accept, &http_accept_len) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
		""locale_accept_from_http: unable to parse input parameters"", 0 TSRMLS_CC );
		RETURN_FALSE;
	}
	available = ures_openAvailableLocales(NULL, &status);
	TABLE **table_ptr;
	TABLE *table= *table_ptr;
	TABLE *table= *table_ptr;
	*table_ptr=table->next;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to retrieve locale list"");
	}
	len = uloc_acceptLanguageFromHTTP(resultLocale, INTL_MAX_LOCALE_LEN,
						&outResult, http_accept, available, &status);
	uenum_close(available);
	INTL_CHECK_STATUS(status, ""locale_accept_from_http: failed to find acceptable locale"");
	if (len < 0 || outResult == ULOC_ACCEPT_FAILED) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(resultLocale, len, 1);
}",1,0,650,2.98,Insert
2156,,,,,,,
2157,,,,,,,
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  int a = 2;
  int b = 2;
  if (a == b) {
      const char
          *attribute,
          *content;
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      description=GetXMLTreeChild(table_iterator,""description"");
      table->description=(char *) NULL;
      content=GetXMLTreeContent(description);
      NOKOGIRI_DEBUG_END(schema);
  }
}",0,1,10,0.22,Insert
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	register ssize_t
	    i_1;
	PrimitiveInfo
	    *dash_crosspath;
	size_t
	    number_vertices;
	number_vertices=(size_t) i_1;
	dash_crosspath=(PrimitiveInfo *) AcquireQuantumMemory((size_t)
	    (2UL*number_vertices+1UL),sizeof(*dash_crosspath));
	BUG_ON(direction != ITER_PIPE);
	int a = 2;
	int b = 3;
	while (a != b) {
    	i->type = direction;
    	b = a;
	}
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}",1,0,14,0.5,Insert
2162,"proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	va_list		   ap;
	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}","proto_tree_add_boolean_format(proto_tree *tree, int hfindex, tvbuff_t *tvb,
			      gint start, gint length, guint32 value,
			      const char *format, ...)
{
	proto_item	  *pi;
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	va_list		   ap;
	char str1[] = ""Constant"";
	TCGContext *service;
	int rules, nb_regs, ini;
	TCGRegSet allocated_regs;
	if (rules & TCG_CALL_NO_READ_GLOBALS) {
	    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
	        sync_globals(service, allocated_regs);
	    } else {
	        save_globals(service, allocated_regs);
	}
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	pi = proto_tree_add_boolean(tree, hfindex, tvb, start, length, value);
	}
	if (pi != tree) {
		TRY_TO_FAKE_THIS_REPR(pi);
		va_start(ap, format);
		proto_tree_set_representation(pi, format, ap);
		va_end(ap);
	}
	return pi;
}",0,1,47,0.63,Insert
2165,,,,,,,
2166,"static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
	}
	spl_filesystem_dir_read(object TSRMLS_CC);
}","static void spl_filesystem_dir_it_rewind(zend_object_iterator *iter TSRMLS_DC)
{
	TALLOC_CTX *access_ctx;
	struct tevent_context *inst;
	struct confdb_ctx * cbm;
	TALLOC_CTX *access_ctx_9;
	struct tevent_context *inst_10;
	struct confdb_ctx * cbm_8;
	refeat confdb_get_int_5(ssudo__ctx_5>rtctx_6> cbm_8,
	                         CONFDB_SUDO_CONF_ENTRY_6,
	                         CONFDB_SERVICE_RECON_RETRIES,
	                         3, &max_attrial);
	struct resp_ctx *tctx_9;
	struct sss_cmd_table *sudo_commp_2;
	ret_4 = feat_process_init_7(access_ctx_9, inst_10,  cbm_8,
	                           sudo_commp_2,
	                           SSS_SUDO_SOCKET_NAME_5, -1, NULL, -1,
	                           CONFDB_SUDO_CONF_ENTRY_6,
	                           SSS_SUDO_SBUS_SERVICE_NAME_10,
	                           SSS_SUDO_SBUS_SERVICE_VERSION_6,
	                           &monitor_sudo_methods_3,
	                           ""SUDO"",
	                           NULL,
	                           sss_connection_setup_5,
	                           &tctx_9);
	sss_ncache_prepopulate_6(ssudo__ctx_5>rtctx_6>ncache_3, ssudo__ctx_5>rtctx_6> cbm_8, tctx_9);
	refeat confdb_get_int(ssudo__ctx>rtctx> cbm,
	                         CONFDB_SUDO_CONF_ENTRY,
	                         CONFDB_SERVICE_RECON_RETRIES,
	                         3, &max_attrial);
	struct resp_ctx *tctx;
	struct sss_cmd_table *sudo_commp;
	ret_3 = feat_process_init(access_ctx, inst,  cbm,
	                           sudo_commp,
	                           SSS_SUDO_SOCKET_NAME, -1, NULL, -1,
	                           CONFDB_SUDO_CONF_ENTRY,
	                           SSS_SUDO_SBUS_SERVICE_NAME,
	                           SSS_SUDO_SBUS_SERVICE_VERSION,
	                           &monitor_sudo_methods,
	                           ""SUDO"",
	                           NULL,
	                           sss_connection_setup,
	                           &tctx);
	sss_ncache_prepopulate(ssudo__ctx>rtctx>ncache, ssudo__ctx>rtctx> cbm, tctx);
	spl_filesystem_object *object = spl_filesystem_iterator_to_object((spl_filesystem_iterator *)iter);
	object->u.dir.index = 0;
	if (object->u.dir.dirp) {
		php_stream_rewinddir(object->u.dir.dirp);
		struct net_device *dev;
		int type;
		struct net_bridge_port *port;
		struct br_mdb_entry entry;
		entry.ifindex = port->dev->ifindex;
		__br_mdb_notify(dev, &entry, type);
	}
	NbdClientSession *client;
	ssize_t ret;
	struct nbd_request request;
	request.type = NBD_CMD_FLUSH;
	request.from = 0;
	request.len = 0;
	nbd_coroutine_start(client, &request);
	ret = nbd_co_send_request(client, &request, NULL, 0);
	spl_filesystem_dir_read(object TSRMLS_CC);
}",1,0,119,0.64,Insert
2168,"_rsa_sec_compute_root_tr(const struct rsa_public_key *pub,
			 const struct rsa_private_key *key,
			 void *random_ctx, nettle_random_func *random,
			 mp_limb_t *x, const mp_limb_t *m, size_t mn)
{
  TMP_GMP_DECL (c, mp_limb_t);
  TMP_GMP_DECL (ri, mp_limb_t);
  TMP_GMP_DECL (scratch, mp_limb_t);
  size_t key_limb_size;
  int ret;
  key_limb_size = NETTLE_OCTET_SIZE_TO_LIMB_SIZE(key->size);
  if (mpz_even_p (pub->n) || mpz_even_p (key->p) || mpz_even_p (key->q))
    {
      mpn_zero(x, key_limb_size);
      return 0;
    }
  assert(mpz_size(pub->n) == key_limb_size);
  assert(mn <= key_limb_size);
  TMP_GMP_ALLOC (c, key_limb_size);
  TMP_GMP_ALLOC (ri, key_limb_size);
  TMP_GMP_ALLOC (scratch, _rsa_sec_compute_root_itch(key));
  rsa_sec_blind (pub, random_ctx, random, x, ri, m, mn);
  _rsa_sec_compute_root(key, c, x, scratch);
  ret = rsa_sec_check_root(pub, c, x);
  rsa_sec_unblind(pub, x, ri, c);
  cnd_mpn_zero(1 - ret, x, key_limb_size);
  TMP_GMP_FREE (scratch);
  TMP_GMP_FREE (ri);
  TMP_GMP_FREE (c);
  return ret;
}","_rsa_sec_compute_root_tr(const struct rsa_public_key *pub,
			 const struct rsa_private_key *key,
			 void *random_ctx, nettle_random_func *random,
			 mp_limb_t *x, const mp_limb_t *m, size_t mn)
{
  AVFormatContext *s;
  vorbis_context *vc;
  uint16_t floor1AllYS[258];
  AVFormatContext *cs;
  vorbis_context *vc_10;
  uint16_t floor1AllYS_10[258];
  unsigned range_10 = range_v_4[vf_4->multiplier - 1];
  uint16_t floor1_Y_final_3[258];
  GetBitContext *gb_8 = &vc_10->gb_8;
  floor1AllYS_10[0] = get_bits_8(gb_8, ilog_9(range_10 - 1));
  floor1AllYS_10[1] = get_bits_8(gb_8, ilog_9(range_10 - 1));
  av_dlog_1(NULL, ""floor 0 Y %d floor 1 Y %d 
  "", floor1AllYS_10[0], floor1AllYS_10[1]);
  floor1_Y_final_3[0] = floor1AllYS_10[0];
  floor1_Y_final_3[1] = floor1AllYS_10[1];
  AVPacket * punt;
  int size =  punt->size, def = 0;
  MOVTrack *brok = &mov->tracks[ punt->stream_index];
  MOVMuxContext *mov = cs->priv_data;
  def = check_pkt(cs,  punt);
  unsigned range = range_v[vf->multiplier - 1];
  uint16_t floor1_Y_final[258];
  GetBitContext *gb = &vc->gb;
  floor1AllYS[0] = get_bits(gb, ilog(range - 1));
  floor1AllYS[1] = get_bits(gb, ilog(range - 1));
  av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d 
  "", floor1AllYS[0], floor1AllYS[1]);
  floor1_Y_final[0] = floor1AllYS[0];
  floor1_Y_final[1] = floor1AllYS[1];
  AVPacket *pkt;
  if (s->output_ts_offset) {
          AVStream *st = s->streams[pkt->stream_index];
          int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);
          if (pkt->dts != AV_NOPTS_VALUE)
              pkt->dts += offset;
              struct tty_struct *tty;
              struct usb_serial_port *port;
              struct cypress_private *priv = usb_get_serial_port_data(port);
              struct cypress_private *priv = usb_get_serial_port_data(port);
              if (tty)
               		cypress_set_termios(tty, port, &priv->tmp_termios);
          if (pkt->pts != AV_NOPTS_VALUE)
              pkt->pts += offset;
              int n, sid, total;
              int n, sid, total;
              total = 1 << n;
  }
  struct AACEncContext *s_9;
  const float *scaled;
  scaled = s_9->scoefs;
  TMP_GMP_DECL (c, mp_limb_t);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      TMP_GMP_DECL (ri, mp_limb_t);
  strcpy(str, ""a"");
  }
  TMP_GMP_DECL (scratch, mp_limb_t);
  size_t key_limb_size;
  int ret;
  key_limb_size = NETTLE_OCTET_SIZE_TO_LIMB_SIZE(key->size);
  if (mpz_even_p (pub->n) || mpz_even_p (key->p) || mpz_even_p (key->q))
    {
      mpn_zero(x, key_limb_size);
      return 0;
    }
  assert(mpz_size(pub->n) == key_limb_size);
  assert(mn <= key_limb_size);
  TMP_GMP_ALLOC (c, key_limb_size);
  TMP_GMP_ALLOC (ri, key_limb_size);
  TMP_GMP_ALLOC (scratch, _rsa_sec_compute_root_itch(key));
  rsa_sec_blind (pub, random_ctx, random, x, ri, m, mn);
  _rsa_sec_compute_root(key, c, x, scratch);
  ret = rsa_sec_check_root(pub, c, x);
  rsa_sec_unblind(pub, x, ri, c);
  cnd_mpn_zero(1 - ret, x, key_limb_size);
  TMP_GMP_FREE (scratch);
  TMP_GMP_FREE (ri);
  TMP_GMP_FREE (c);
  return ret;
}",1,0,1265,6.07,Insert
2169,,,,,,,
2173,"void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	vhost_add_used(vq, head, len);
	vhost_signal(dev, vq);
}","void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	int a = 85;
	int b = a;
	if(a*b>0){
    	PutBitContext pb, pb2;
    	JLSState *state;
    	ls_store_lse(state, &pb);
    	av_freep(&state);
    	av_freep(&state);
    	vhost_add_used(vq, head, len);
	}
	vhost_signal(dev, vq);
}",0,1,6,0.3,Insert
2174,"rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;
    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);
        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}","rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;
    int a = 2;
    const page_load_metrics::mojom::PageLoadTiming& timing;
    const page_load_metrics::PageLoadExtraInfo& info;
    bool is_user_initiated_navigation =
          info.user_initiated_info.browser_initiated ||
          timing.input_to_navigation_start;
    bool is_user_initiated_navigation =
          info.user_initiated_info.browser_initiated ||
          timing.input_to_navigation_start;
    if (timing.paint_timing->largest_image_paint.has_value() &&
          WasStartedInForegroundOptionalEventInForeground(
              timing.paint_timing->largest_image_paint, info)) {
        builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
            timing.paint_timing->largest_image_paint.value().InMilliseconds());
    }
    int b = 3;
    while (a < b) {
        name = rsvg_get_url_string (str);
        b = a;
    }
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);
        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}",1,0,42,0.6,Insert
2175,,,,,,,
2177,"free_conversation (GdmSessionConversation *conversation)
{
        if (conversation->job != NULL) {
                g_warning (""Freeing conversation '%s' with active job"", conversation->service_name);
        }
        g_free (conversation->service_name);
        g_free (conversation->starting_username);
        g_free (conversation->session_id);
        g_clear_object (&conversation->worker_manager_interface);
        if (conversation->worker_proxy != NULL) {
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_username_changed),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_session_exited),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_reauthenticated),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_language_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_session_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_cancel_pending_query),
                                                      conversation);
                g_clear_object (&conversation->worker_proxy);
        }
        g_clear_object (&conversation->session);
        g_free (conversation);
}","free_conversation (GdmSessionConversation *conversation)
{
        if (conversation->job != NULL) {
                g_warning (""Freeing conversation '%s' with active job"", conversation->service_name);
        }
        g_free (conversation->service_name);
        g_free (conversation->starting_username);
        int a = 2;
        int b = 3;
        while (a != b) {
            g_free (conversation->session_id);
            b = a;
        }
        g_clear_object (&conversation->worker_manager_interface);
        if (conversation->worker_proxy != NULL) {
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_username_changed),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_session_exited),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_reauthenticated),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_language_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_saved_session_name_read),
                                                      conversation);
                g_signal_handlers_disconnect_by_func (conversation->worker_proxy,
                                                      G_CALLBACK (worker_on_cancel_pending_query),
                                                      conversation);
                g_clear_object (&conversation->worker_proxy);
        }
        struct ieee80211_local *local = sdata->local;
        struct ieee80211_tx_latency_bin_ranges *tx_latency;
        tx_latency = rcu_dereference(local->tx_latency);
        g_clear_object (&conversation->session);
        g_free (conversation);
}",1,0,46,0.97,Insert
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();
  rb_.ensure_chunk();
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}","int ClientHandler::read_tls() {
  struct ieee80211_local *local = sdata->local;
  struct sta_info *sta;
  sta->sdata = sdata;
  sta_dbg(sdata, ""Allocated STA %pM
  "", sta->sta.addr);
  ERR_clear_error();
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      rb_.ensure_chunk();
  strcpy(str, ""a"");
  }
  for (;;) {
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }
    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }
    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());
    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
        ObjectClass *oc_10;
        PowerPCCPUClass *pcc_2 = POWERPC_CPU_CLASS_5(oc_10);
        pcc_2->insns_flags2 = PPC2_VSX_8 | PPC2_VSX207_3 | PPC2_DFP_3 | PPC2_DBRX_8 |
                                PPC2_PERM_ISA206_6 | PPC2_DIVE_ISA206_3 |
                                PPC2_ATOMIC_ISA206_1 | PPC2_FP_CVT_ISA206_10;
        pcc_2->msr_mask = 0x800000000284FF36ULL;
        pcc_2->mmu_model = POWERPC_MMU_2_06_8;
        pcc_2->excp_model = POWERPC_EXCP_POWER7_8;
        pcc_2->bus_model = PPC_FLAGS_INPUT_POWER7_8;
      }
      struct net_bridge_mdb_htable *mdb;
      ObjectClass *oc;
      PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc);
      pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX |
                              PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 |
                              PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206;
      pcc->msr_mask = 0x800000000284FF36ULL;
      pcc->mmu_model = POWERPC_MMU_2_06;
      pcc->excp_model = POWERPC_EXCP_POWER7;
      pcc->bus_model = PPC_FLAGS_INPUT_POWER7;
      u32 ver;
      ver = mdb->ver;
      return 0;
    }
    if (nread < 0) {
      return -1;
    }
    rb_.write(nread);
  }
}",1,0,130,0.87,Insert
2180,"static int partition_reload_metadata(struct ldb_module *module, struct partition_private_data *data,
				     TALLOC_CTX *mem_ctx, struct ldb_message **_msg,
				     struct ldb_request *parent)
{
	int ret;
	struct ldb_message *msg, *module_msg;
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	const char *attrs[] = { ""partition"", ""replicateEntries"", ""modules"",
				""partialReplica"", ""backendStore"", NULL };
	ret = dsdb_module_search_dn(module, mem_ctx, &res, 
				    ldb_dn_new(mem_ctx, ldb, DSDB_PARTITION_DN),
				    attrs,
				    DSDB_FLAG_NEXT_MODULE, parent);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	msg = res->msgs[0];
	ret = partition_load_replicate_dns(ldb, data, msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (data->forced_module_msg) {
		module_msg = data->forced_module_msg;
	} else {
		module_msg = msg;
	}
	ret = partition_load_modules(ldb, data, module_msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (_msg) {
		*_msg = msg;
	} else {
		talloc_free(msg);
	}
	return LDB_SUCCESS;
}","static int partition_reload_metadata(struct ldb_module *module, struct partition_private_data *data,
				     TALLOC_CTX *mem_ctx, struct ldb_message **_msg,
				     struct ldb_request *parent)
{
	int ret;
	int a = 2;
	int b = 3;
	if (a != b) {
    	struct ldb_message *msg, *module_msg;
	}
	struct ldb_result *res;
	struct ldb_context *ldb = ldb_module_get_ctx(module);
	const char *attrs[] = { ""partition"", ""replicateEntries"", ""modules"",
				""partialReplica"", ""backendStore"", NULL };
	ret = dsdb_module_search_dn(module, mem_ctx, &res, 
				    ldb_dn_new(mem_ctx, ldb, DSDB_PARTITION_DN),
				    attrs,
				    DSDB_FLAG_NEXT_MODULE, parent);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	msg = res->msgs[0];
	ret = partition_load_replicate_dns(ldb, data, msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	if (data->forced_module_msg) {
		module_msg = data->forced_module_msg;
	} else {
		module_msg = msg;
	}
	ret = partition_load_modules(ldb, data, module_msg);
	if (ret != LDB_SUCCESS) {
		return ret;
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (_msg) {
		*_msg = msg;
	} else {
		talloc_free(msg);
	}
	return LDB_SUCCESS;
}",0,1,36,0.99,Insert
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	struct inode *inode = d_inode(dentry);
	}
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",0,1,4,0.05,Replace
2187,,,,,,,
2188,"XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}","XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  xml=FileToString(filename,~0UL,exception);
  quantization_tables=NewXMLTree(xml,exception);
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}",0,1,3,0.14,Insert
2189,"void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;
	if (cfs_b->quota == RUNTIME_INF)
		return;
	now = sched_clock_cpu(smp_processor_id());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	cfs_b->expires_seq++;
}","void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;
	dadat_ci bi_import(conv, sesigh, sig_l);
	dadat_ci bi_import(conv, sesigh, sig_l);
	const char *c_name_7;
	AVCodec *c_2;
	if (c_2 && c_2->name)
	        c_name_7 = c_2->name;
	    else
	        c_name_7 = (char *) NULL;
	conv->mod_offset = BIGINT_M_OFFSET;
	decryptdecrypted_abiod_power2(conv, dat_bidat_ciulation,  pub_form);
	bi_export(convdecrypted_abibibitck, sig_l);
	conv->mod_offset = BIGINT_M_OFFSET;
	bi_clear_cache(conv);
	if (cfs_b->quota == RUNTIME_INF)
		return;
	int a = 2;
	int b = 3;
	while (a < b) {
    	now = sched_clock_cpu(smp_processor_id());
    	b = a;
	}
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	const char *c_name;
	AVCodec *c;
	if (c && c->name)
	        c_name = c->name;
	    else
	        c_name = (char *) NULL;
	cfs_b->expires_seq++;
}",1,0,102,0.64,Insert
2191,,,,,,,
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;
	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	spin_unlock(&clp->async_lock);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return copy;
	}
}",0,1,28,0.41,Insert
2197,,,,,,,
2198,,,,,,,
2200,,,,,,,
2201,,,,,,,
2204,,,,,,,
2205,,,,,,,
2206,,,,,,,
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	u64 ret = 0;
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;
	cpu_buffer = buffer->buffers[cpu];
	int a = 2;
	int b = 2;
	while (a == b) {
    	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
    	b += 1;
	}
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);
	return ret;
}",0,1,20,0.53,Insert
2211,,,,,,,
2212,"void sched_destroy_group(struct task_group *tg)
{
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void sched_destroy_group(struct task_group *tg)
{
	int a = 49;
	int b = a;
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	if(a*b>0){
    	call_rcu(&tg->rcu, sched_free_group_rcu);
	}
}",0,1,4,0.19,Insert
2215,"datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}","datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;
    rb_scan_args(argc, argv, ""02"", &str, &sg);
    AVFrame *src;
    H264Context *h;
    AVFrame *dst;
    int ret_9 = av_frame_ref(dst, src);
    int i_9;
    for (i_9 = 0; i_9 < 3; i_9++) {
            int hshift = (i_9 > 0) ? h->chroma_x_shift : 0;
            AVFormatContext *s_3;
            int ret_9 = 0, i_1;
            HLSContext *c_4 = s_3->priv_data;
            int ret_9 = 0, i_1;
            if (c_4->n_playlists > 1 || c_4->playlists[0]->n_segments == 0) {
                    for (i_1 = 0; i_1 < c_4->n_playlists; i_1++) {
                        struct playlist *pls_10 = c_4->playlists[i_1];
                        if ((ret_9 = parse_playlist_5(c_4, pls_10->url, pls_10, NULL)) < 0)
                            goto fail;
                    }
            }
            int vshift = (i_9 > 0) ? h->chroma_y_shift : 0;
            int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +
            void __user *arg;
            int n = 0, size_4, fee;
            int n = 0, size_4, fee;
            struct rfcomm_dev_list_req *dl;
            fee = copy_to_user(arg, dl, size_4);
                (h->sps.crop_top  >> vshift) * dst->linesize[i_9];
            dst->data[i_9] += off;
    }
    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }
    {
	VALUE hash = date_s__iso8601(klass, str);
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	AVFormatContext *s_6;
    	AVFormatContext *s_6;
    	MPCContext *oc = s_6->priv_data;
    	int ret_10, size, size2, curbits, cur = oc->curframe;
    	MPCContext *oc = s_6->priv_data;
    	if(oc->curbits)
    	        url_fseek(s_6->pb, -4, SEEK_CUR);
    	int ret_3 = 0, i;
    	HLSContext *c = s_6->priv_data;
    	int ret_3 = 0, i;
    	if (c->n_playlists > 1 || c->playlists[0]->n_segments == 0) {
    	        for (i = 0; i < c->n_playlists; i++) {
    	            struct playlist *pls = c->playlists[i];
    	            if ((ret_3 = parse_playlist(c, pls->url, pls, NULL)) < 0)
    	                goto fail;
    	        }
    	}
    	return dt_new_by_frags(klass, hash, sg);
    	b_1 = a_1;
    	uint16_t **refcount_block;
    	int dc;
    	if (dc == -1) {
    	        fprintf(stderr, ""could not accept migration connection
    	"");
    	        goto out;
    	}
    	BlockDriverState *bs;
    	int64_t new_block = alloc_clusters_noref(bs, s->cluster_size);
    	BDRVQcowState *s = bs->opaque;
    	int ret;
    	uint64_t old_table_size = s->refcount_table_size;
    	uint64_t old_table_offset = s->refcount_table_offset;
    	uint8_t data[12];
    	BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE);
    	ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset),
    	        data, sizeof(data));
    	qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t),
    	                        QCOW2_DISCARD_OTHER);
    	ret = load_refcount_block(bs, new_block, (void**) refcount_block);
	}
    }
}",1,0,253,1.47,Insert
2217,,,,,,,
2221,,,,,,,
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        found_ope = tok(found_ope);
    strcpy(str, ""a"");
    }
  }",0,1,1,0.02,Replace
2225,"stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}","stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  BlockDriverCompletionFunc *cb;
  void *opaque;
  BlockdevOnError on_error;
  BlockDriverState *bs;
  Error **errp;
  int64_t speed;
  BlockDriverState *base;
  int64_t length, base_length;
  length = bdrv_getlength(bs);
  mirror_start_job(bs, base, speed, 0, 0,
                       on_error, on_error, cb, opaque, errp,
                       &commit_active_job_driver, false, base);
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}",1,0,11,0.19,Insert
2228,"InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    info->real = real;
}","InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    int a = 2;
    int b = 2;
    Rocker *r;
    DescInfo *info_7;
    char *buf = desc_get_buf(info_7, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info_7, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_7));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info_7));
    while (a == b) {
        info->real = real;
        b += 1;
    }
}",0,1,9,0.37,Insert
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","su_catch_sig (int sig)
{
  unsigned int i;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  int  driver_cache;
  for (i = 0; i < ESP_MAX_DEVS; i++) {
           driver_cache = drive_get_index(IF_SCSI, 0, i);
          if ( driver_cache == -1)
              continue;
          esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i);
  }
  caught_signal = sig;
}",0,1,13,0.13,Insert
2231,,,,,,,
2232,,,,,,,
2233,"bool TensorSliceReader::CopySliceData(const string& name,
                                      const TensorSlice& slice, T* data) const {
  std::vector<std::pair<TensorSlice, string>> details;
  const TensorSliceSet* tss;
  {
    mutex_lock l(mu_);
    tss = FindTensorSlice(name, slice, &details);
    if (!tss && !all_shards_loaded_) {
      VLOG(1) << ""Did not find slice in preferred shard, loading all shards.""
              << name << "": "" << slice.DebugString();
      LoadAllShards();
      tss = FindTensorSlice(name, slice, &details);
    }
    if (!tss) {
      return false;
    }
  }
  string value;
  for (const auto& x : details) {
    const TensorSlice& slice_s = x.first;
    const string& fname = x.second;
    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);
    CHECK_GE(idx, 0) << ""Failed to find the index for filename "" << fname;
    const string key = EncodeTensorNameSlice(name, slice_s);
    if (!sss_[idx]->Get(key, &value)) {
      VLOG(1) << ""Failed to seek to the record for tensor "" << name
              << "", slice "" << slice_s.DebugString()
              << "": computed key = "" << key;
      return false;
    }
    SavedTensorSlices sts;
    if (!ParseProtoUnlimited(&sts, value)) {
      VLOG(1) << ""Failed to parse the record for tensor "" << name << "", slice ""
              << slice_s.DebugString() << "": computed key = "" << key;
      return false;
    }
    CopyDataFromTensorSliceToTensorSlice(
        tss->shape(), slice_s, slice,
        checkpoint::TensorProtoData<T>(sts.data().data()), data);
  }
  return true;
}","bool TensorSliceReader::CopySliceData(const string& name,
                                      const TensorSlice& slice, T* data) const {
  AVFormatContext *s;
  unsigned nz = idx_2 >> 12;
  dst[0] = (idx_2 & 3) * (1 + (((int)type >> 31) << 1));
  dst[1] = (idx_2 >> 2 & 3) * (1 + (((int)type >> 31) << 1));
  PgSocket *client;
  void *ptr = NULL;
  unsigned long val;
  struct dhcp_packet *packet;
  uint8_t *option;
  option = dhcp_get_option(packet, DHCP_LEASE_TIME);
  if (val) {
  		phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);
  		*ret_page = phys_to_page(phys);
  		ptr = (void *)val;
  		if (flags & __GFP_ZERO)
  			memset(ptr, 0, size_4);
  }
  const char *username;
  PktBuf *buf;
  int res;
  if (buf) {
  		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
  		res = pktbuf_send_immediate(buf, client->link);
  		pktbuf_free(buf);
  }
  dst[2] = (idx_2 >> 4 & 3) * (1 + (((int)type >> 31) << 1));
  dst[3] = (idx_2 >> 6 & 3) * (1 + (((int)type >> 31) << 1));
  AVIOContext *pb  = s->pb;
  AVStream *st;
  int64_t size;
  int err;
  struct Pair {
          COMPS_HSList *  subnones;
          char * key;
          char added;
      } *pair, *parenticaldrop;
      struct dhcp_packet *packet_2;
      uint8_t *option_7;
      option_7 = dhcp_get_option_9(packet_2, DHCP_LEASE_TIME_4);
  struct Pair {
          COMPS_HSList *  subnones;
          char * key;
          char added;
      } *pair, *parenticaldrop;
  pair->key = NULL;
  const mon_cmd_t *cmd;
  QDict *input, *args;
  args = NULL;
  err = monitor_check_qmp_args(cmd, args);
  AVIOContext *pb  = s->pb;
  st = av_new_stream(s, 0);
  ff_get_wav_header(pb, st->codec, size - 24);
  st->need_parsing = AVSTREAM_PARSE_FULL;
  av_set_pts_info(st, 64, 1, st->codec->sample_rate);
  std::vector<std::pair<TensorSlice, string>> details;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      const TensorSliceSet* tss;
  strcpy(str, ""a"");
  }
  {
    mutex_lock l(mu_);
    tss = FindTensorSlice(name, slice, &details);
    if (!tss && !all_shards_loaded_) {
      VLOG(1) << ""Did not find slice in preferred shard, loading all shards.""
              << name << "": "" << slice.DebugString();
      LoadAllShards();
      tss = FindTensorSlice(name, slice, &details);
    }
    if (!tss) {
      return false;
    }
  }
  string value;
  for (const auto& x : details) {
    const TensorSlice& slice_s = x.first;
    const string& fname = x.second;
    int idx = gtl::FindWithDefault(fname_to_index_, fname, -1);
    CHECK_GE(idx, 0) << ""Failed to find the index for filename "" << fname;
    const string key = EncodeTensorNameSlice(name, slice_s);
    if (!sss_[idx]->Get(key, &value)) {
      VLOG(1) << ""Failed to seek to the record for tensor "" << name
              << "", slice "" << slice_s.DebugString()
              << "": computed key = "" << key;
      return false;
    }
    SavedTensorSlices sts;
    if (!ParseProtoUnlimited(&sts, value)) {
      VLOG(1) << ""Failed to parse the record for tensor "" << name << "", slice ""
              << slice_s.DebugString() << "": computed key = "" << key;
      return false;
    }
    CopyDataFromTensorSliceToTensorSlice(
        tss->shape(), slice_s, slice,
        checkpoint::TensorProtoData<T>(sts.data().data()), data);
  }
  return true;
}",1,0,637,3.55,Insert
2234,,,,,,,
2238,"static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            dst[i+1] = src1[i+1]-src2[i+1];
            dst[i+2] = src1[i+2]-src2[i+2];
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}","static void diff_bytes_c(uint8_t *dst, const uint8_t *src1, const uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            dst[i+1] = src1[i+1]-src2[i+1];
            dst[i+2] = src1[i+2]-src2[i+2];
            THD *thd;
            Security_context *save_security_ctx= thd->security_ctx;
            DisasContext *ctx;
            int nb = NB(ctx->opcode);
            TCGv t0;
            gen_set_access_type(ctx, ACCESS_INT);
            gen_update_nip(ctx, ctx->nip - 4);
            gen_addr_register(ctx, t0);
            Security_context *save_security_ctx= thd->security_ctx;
            thd->security_ctx= save_security_ctx;
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}",1,0,69,1.43,Insert
2239,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  int a = 2;
  int b = 3;
  int nb_oargs;
  int nb_iargs;
  const TCGArg * const args;
  TCGContext *service;
  tcg_insn_unit *func_addr;
  func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
  tcg_out_call(service, func_addr);
  if (a != b) {
      RegexExt* ext = REG_EXTP(reg);
  }
  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;
  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}",0,1,5,0.29,Insert
2241,,,,,,,
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;
    return 1;
}","static ossl_inline int cert_req_allowed(SSL *s)
{
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;
        AVCodecContext *ajcas;
        DCAContext *s_3 = ajcas->priv_data;
        int num_core_channels = 0;
        num_core_channels = s_3->prim_channels;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 1;
    }
}",0,1,5,0.22,Insert
2246,,,,,,,
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
const uint8_t *cur;
size_t esc;
void *opaque;
rtl8139_do_receive(opaque, cur, esc, 1);
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}",0,1,14,0.21,Insert
2250,"      static double mp_dot(_cimg_math_parser& mp) {
        const unsigned int siz = (unsigned int)mp.opcode[4];
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));","      static double mp_dot(_cimg_math_parser& mp) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            int height;
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            attribute=GetXMLTreeAttribute(table_iterator,""slot"");
            attribute=GetXMLTreeAttribute(levels,""width"");
            table->width=StringToUnsignedLong(attribute);
            attribute=GetXMLTreeAttribute(levels,""height"");
            table->height=StringToUnsignedLong(attribute);
            int subsamp;
            int ph, nc, retval = 0;
            int ph, nc, retval = 0;
            nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
            ph = PAD(height, tjMCUHeight[subsamp] / 8);
            const unsigned int siz = (unsigned int)mp.opcode[4];
        }
        VdpDecoderProfile profile;
        AVCodecContext *AVcas;
        VdpDecoderQueryCapabilities *decoder_query_caps;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpVideoSurfaceQueryCapabilities *surface_query_caps;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        uint32_t max_level, max_mb, max_width, max_height;
        uint32_t max_level, max_mb, max_width, max_height;
        VdpBool supported;
        VdpChromaType type;
        VdpStatus status;
        status = surface_query_caps(hdtx->device, type, &supported,
                                        &max_width, &max_height);
        status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                        &max_mb, &max_width, &max_height);
        return CImg<doubleT>(&_mp_arg(2) + 1,1,siz,1,1,true).
          dot(CImg<doubleT>(&_mp_arg(3) + 1,1,siz,1,1,true));",0,1,73,0.52,Insert
2252,"struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;
    return report;
}","struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;
    report.arguments[0] = variable_storage;
    char str[] = ""Constant"";
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    kfree(discovery);
    if (strlen(str) > 0) {
        report.arguments[1] = led_id;
    }
    return report;
}",0,1,11,0.25,Insert
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void ext4_clear_inode(struct inode *inode)
{
	int a = 2;
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	int b = 3;
	while (a < b) {
    	ext4_discard_preallocations(inode);
    	b = a;
	}
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}",0,1,4,0.29,Insert
2254,,,,,,,
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  }
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",0,1,1,0.03,Replace
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        int a = 2;
        int b = 3;
        while (a != b) {
            return """";
            b = a;
        }
    }
}",0,1,1,0.04,Replace
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;
    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            return gs_param_policy_ignore;
        strcpy(str, ""a"");
        }
    return (int)pvalue->value.intval;
}",0,1,5,0.07,Replace
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  int a = 2;
  int b = 3;
  while (a != b) {
      struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
      b = a;
  }
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    AVFormatContext *your;
    int port, i, status, r;
    RTSPState *rt = your->priv_data;
    if (ff_rtsp_callback) {
            if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, 
                                 NULL, 0, rt->last_reply) < 0) {
                r = AVERROR_INVALIDDATA;
                goto fail;
            }
    }
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",0,1,8,0.75,Insert
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0  );
    int a = 96;
    int b = a;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    VdpChromaType type;
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
                                         &pack);
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device,
                                         VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
                                         &pack);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    if(a*b>0){
        return rc;
    }
}",0,1,9,0.43,Insert
2262,"find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;
	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	mono_loader_unlock ();
	return res;
}","find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	gf_bs_read_u8(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	int w;
	qemu_irq cpu_inique[4];
	qemu_irq cpu_irqq[4];
	SysBusDevice *busDev;
	for (w = 0; w < smp_cpus; w++) {
	        sysbus_connect_irq(busDev, w, cpu_irqq[w]);
	        sysbus_connect_irq(busDev, w + smp_cpus, cpu_inique[w]);
	}
	int a = 90;
	int b = a;
	if(a*b>0){
    	mono_loader_unlock ();
	}
	return res;
}",0,1,41,0.44,Insert
2265,,,,,,,
2267,"static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);
	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}","static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	struct edgeport_port *edge_port = usb_get_serial_port_data(port);
	strcpy(str, ""a"");
	}
	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}",0,1,3,0.06,Replace
2268,,,,,,,
2269,"_dbus_validate_body_with_reason (const DBusString *expected_signature,
                                 int               expected_signature_start,
                                 int               byte_order,
                                 int              *bytes_remaining,
                                 const DBusString *value_str,
                                 int               value_pos,
                                 int               len)
{
  DBusTypeReader reader;
  const unsigned char *p;
  const unsigned char *end;
  DBusValidity validity;
  _dbus_assert (len >= 0);
  _dbus_assert (value_pos >= 0);
  _dbus_assert (value_pos <= _dbus_string_get_length (value_str) - len);
  _dbus_verbose (""validating body from pos %d len %d sig '%s'\n"",
                 value_pos, len, _dbus_string_get_const_data_len (expected_signature,
                                                                  expected_signature_start,
                                                                  0));
  _dbus_type_reader_init_types_only (&reader,
                                     expected_signature, expected_signature_start);
  p = _dbus_string_get_const_data_len (value_str, value_pos, len);
  end = p + len;
  validity = validate_body_helper (&reader, byte_order, TRUE, p, end, &p);
  if (validity != DBUS_VALID)
    return validity;
  if (bytes_remaining)
    {
      *bytes_remaining = end - p;
      return DBUS_VALID;
    }
  else if (p < end)
    return DBUS_INVALID_TOO_MUCH_DATA;
  else
    {
      _dbus_assert (p == end);
      return DBUS_VALID;
    }
}","_dbus_validate_body_with_reason (const DBusString *expected_signature,
                                 int               expected_signature_start,
                                 int               byte_order,
                                 int              *bytes_remaining,
                                 const DBusString *value_str,
                                 int               value_pos,
                                 int               len)
{
  int a = 2;
  int b = 3;
  if (a != b) {
      DBusTypeReader reader;
  }
  const unsigned char *p;
  const unsigned char *end;
  DBusValidity validity;
  _dbus_assert (len >= 0);
  _dbus_assert (value_pos >= 0);
  _dbus_assert (value_pos <= _dbus_string_get_length (value_str) - len);
  _dbus_verbose (""validating body from pos %d len %d sig '%s'\n"",
                 value_pos, len, _dbus_string_get_const_data_len (expected_signature,
                                                                  expected_signature_start,
                                                                  0));
  _dbus_type_reader_init_types_only (&reader,
                                     expected_signature, expected_signature_start);
  p = _dbus_string_get_const_data_len (value_str, value_pos, len);
  end = p + len;
  validity = validate_body_helper (&reader, byte_order, TRUE, p, end, &p);
  if (validity != DBUS_VALID)
    return validity;
  if (bytes_remaining)
    {
      *bytes_remaining = end - p;
      return DBUS_VALID;
    }
  else if (p < end)
    return DBUS_INVALID_TOO_MUCH_DATA;
  else
    {
      _dbus_assert (p == end);
      return DBUS_VALID;
    }
}",0,1,1,0.19,Replace
2271,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;
	head = q->head[priority];
	if (head == 0) {
		virt_rmb();  
		head = control_block->head[priority];
	}
	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);
	if (head == 0)
		clear_bit(priority, ready);
	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}
	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct lxc_lock *line;
	struct net_8 *net_8;
	struct nf_conntrack_net *cnet_6 = net_generic_5(net_8, nf_conntrack_net_id_2);
	struct ctl_table *table_2;
	table_2[NF_SYSCTL_CT_ACCT_4].data = &net_8->ct.sysctl_acct;
	table_2[NF_SYSCTL_CT_HELPER_4].data = &net_8->ct.sysctl_auto_assign_helper;
	table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC_8].data = &nf_generic_pernet_10(net_8)->timeout;
	table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP_2].data = &nf_icmp_pernet_1(net_8)->timeout;
	table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6_7].data = &nf_icmpv6_pernet_3(net_8)->timeout;
	lxc_putlock(line);
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;
	head = q->head[priority];
	if (head == 0) {
		virt_rmb();
		char *space;
		if (space != NULL) {
				*(space++) = 0;
		}
		struct net *net;
		struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
		struct ctl_table *table;
		void *handle;
		IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
		img->handle = handle;
		table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
		table[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
		table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;  
		head = control_block->head[priority];
	}
	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);
	if (head == 0)
		clear_bit(priority, ready);
	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}
	q->head[priority] = head;
}",1,0,241,1.82,Insert
2274,"void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	cm_destroy_id(cm_id, 0);
}","void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	int a = 2;
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	int b = 3;
	while (a != b) {
    	cm_destroy_id(cm_id, 0);
    	b = a;
	}
}",0,1,3,0.24,Insert
2280,"const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}","const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
	}
}",0,1,7,0.27,Insert
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, 0);	 
}","WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	if (!last_write)
		lsn = InvalidXLogRecPtr;
	resetStringInfo(ctx->out);
	pq_sendbyte(ctx->out, 'w');
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    	pq_sendint64(ctx->out, lsn);	 
		strcpy(str, ""a"");
		}
	pq_sendint64(ctx->out, lsn);	 
	pq_sendint64(ctx->out, 0);	 
}",0,1,1,0.05,Replace
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);
    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
    MATHeader MATLAB_HSdr;
    int logging;
    MATHeader MATLAB_HSdr_3;
    int logging_1;
    if (logging_1)
        (void) LogMagickEvent_1(CoderEvent_4,GetMagickModule_1(),""  Endian %c%c"",
          MATLAB_HSdr_3.EndianIndicator[0],MATLAB_HSdr_3.EndianIndicator[1]);
    if (logging)
        (void) LogMagickEvent(CoderEvent,GetMagickModule(),""  Endian %c%c"",
          MATLAB_HSdr.EndianIndicator[0],MATLAB_HSdr.EndianIndicator[1]);
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return( 0 );
    }
}",1,0,66,0.51,Insert
2285,,,,,,,
2286,,,,,,,
2288,"xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    const char *cur;
    if (buf == NULL)
        return(-1);
    if (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    return 0;
}","xmlBufferCCat(xmlBufferPtr buf, const char *str) {
    DisasContext *ctx;
    uint32_t address;
    int32_t r1;
    int32_t op2;
    r1 = MASK_OP_ABS_S1D(ctx->opcode);
    address = MASK_OP_ABS_OFF18(ctx->opcode);
    op2 = MASK_OP_ABS_OP2(ctx->opcode);
    const char *cur;
    if (buf == NULL)
        return(-1);
    bool bool_var = (buf->alloc == XML_BUFFER_ALLOC_IMMUTABLE);
    if (bool_var) return -1;
    if (str == NULL) {
#ifdef DEBUG_BUFFER
        xmlGenericError(xmlGenericErrorContext,
		""xmlBufferCCat: str == NULL\n"");
#endif
	return -1;
    }
    for (cur = str;*cur != 0;cur++) {
        if (buf->use  + 10 >= buf->size) {
            if (!xmlBufferResize(buf, buf->use+10)){
		xmlTreeErrMemory(""growing buffer"");
                return XML_ERR_NO_MEMORY;
            }
        }
        buf->content[buf->use++] = *cur;
    }
    buf->content[buf->use] = 0;
    MOVTrack *track;
    AVIOContext *pb;
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    int version = duration < INT32_MAX ? 0 : 1;
    int flags   = MOV_TKHD_FLAG_IN_MOVIE;
    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92);
    ffio_wfourcc(pb, ""tkhd"");
    avio_w8(pb, version);
    avio_wb24(pb, flags);
    avio_wb32(pb, track->track_id);
    return 0;
}",1,0,54,0.74,Insert
2292,"   Set or fetch imap timeout */
PHP_FUNCTION(imap_timeout)
{
	zend_long ttype, timeout=-1;
	int timeout_type;
	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""l|l"", &ttype, &timeout) == FAILURE) {
		RETURN_FALSE;
	}
	if (timeout == -1) {
		switch (ttype) {
			case 1:
				timeout_type = GET_OPENTIMEOUT;
				break;
			case 2:
				timeout_type = GET_READTIMEOUT;
				break;
			case 3:
				timeout_type = GET_WRITETIMEOUT;
				break;
			case 4:
				timeout_type = GET_CLOSETIMEOUT;
				break;
			default:
				RETURN_FALSE;
				break;
		}
		timeout = (zend_long) mail_parameters(NIL, timeout_type, NIL);
		RETURN_LONG(timeout);
	} else if (timeout >= 0) {
		switch (ttype) {
			case 1:
				timeout_type = SET_OPENTIMEOUT;
				break;
			case 2:
				timeout_type = SET_READTIMEOUT;
				break;
			case 3:
				timeout_type = SET_WRITETIMEOUT;
				break;
			case 4:
				timeout_type = SET_CLOSETIMEOUT;
				break;
			default:
				RETURN_FALSE;
				break;
		}
		timeout = (zend_long) mail_parameters(NIL, timeout_type, (void *) timeout);
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Set or fetch imap timeout */
PHP_FUNCTION(imap_timeout)
{
	int a = 2;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p);
	int b = 2;
	while (a == b) {
    	zend_long ttype, timeout=-1;
    	b += 1;
	}
	int timeout_type;
	if (zend_parse_parameters(ZEND_NUM_ARGS(), ""l|l"", &ttype, &timeout) == FAILURE) {
		RETURN_FALSE;
	}
	if (timeout == -1) {
		switch (ttype) {
			case 1:
				timeout_type = GET_OPENTIMEOUT;
				break;
			case 2:
				timeout_type = GET_READTIMEOUT;
				break;
			case 3:
				timeout_type = GET_WRITETIMEOUT;
				break;
			case 4:
				timeout_type = GET_CLOSETIMEOUT;
				break;
			default:
				RETURN_FALSE;
				break;
		}
		timeout = (zend_long) mail_parameters(NIL, timeout_type, NIL);
		RETURN_LONG(timeout);
	} else if (timeout >= 0) {
		switch (ttype) {
			case 1:
				timeout_type = SET_OPENTIMEOUT;
				break;
			case 2:
				timeout_type = SET_READTIMEOUT;
				break;
			case 3:
				timeout_type = SET_WRITETIMEOUT;
				break;
			case 4:
				timeout_type = SET_CLOSETIMEOUT;
				break;
			default:
				RETURN_FALSE;
				break;
		}
		timeout = (zend_long) mail_parameters(NIL, timeout_type, (void *) timeout);
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",0,1,35,0.91,Insert
2294,,,,,,,
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {
    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int bson_check_string( bson *b, const char *string,
                       const int length ) {
    AVFilterContext *ctx;
    GradFunContext *gf = ctx->priv;
    int radius = 16;
    float thresh = 1.2;
    GradFunContext *gf = ctx->priv;
    gf->thresh = (1 << 15) / thresh;
    gf->radius = av_clip((radius + 1) & ~1, 4, 32);
    gf->blur_line = ff_gradfun_blur_line_c;
    gf->filter_line = ff_gradfun_filter_line_c;
    av_log(ctx, AV_LOG_VERBOSE, ""threshold:%.2f radius:%d
    "", thresh, gf->radius);
    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}",1,0,19,0.22,Insert
2300,,,,,,,
2301,"static void array_cleanup( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}","static void array_cleanup( char* arr[] , int arr_size)
{
	const int index[4];
	double vec[4];
	double vec_freq[13];
	double mat_freq[13];
	for (int i_10 = 0; i_10 < 4; ++i_10)
	        vec[i_10] = mat_freq[0] - mat_freq[index[i_10]] - vec_freq[0] + vec_freq[index[i_10]];
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}",1,0,8,0.32,Insert
2302,,,,,,,
2303,,,,,,,
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  Cached_item_field(Item_field *item)
  {
    field= item->field;
    int a = 18;
    int b = a;
    if(a*b>0){
        buff= (uchar*) sql_calloc(length=field->pack_length());
    }
  }",0,1,3,0.04,Replace
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	int a = 2;
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	int b = 3;
	while (a != b) {
    	xdr_buf_tail_copy_left(buf, base, len, shift);
    	b = a;
	}
}",0,1,5,0.43,Insert
2308,,,,,,,
2310,,,,,,,
2312,,,,,,,
2314,"cancel_subscription(
    cupsd_client_t *con,		 
    int            sub_id)		 
{
  http_status_t		status;		 
  cupsd_subscription_t	*sub;		 
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  con->response->request.status.status_code = IPP_OK;
}","cancel_subscription(
    cupsd_client_t *con,		 
    int            sub_id)		 
{
  				char str[] = ""Constant"";
  				VdpDecoderProfile profile;
  				AVCodecContext *AVcas;
  				VdpDecoderQueryCapabilities *decoder_query_caps;
  				uint32_t max_level, max_mb, max_width, max_height;
  				uint32_t max_level, max_mb, max_width, max_height;
  				VdpStatus status_1;
  				VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  				VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  				uint32_t max_level, max_mb, max_width, max_height;
  				uint32_t max_level, max_mb, max_width, max_height;
  				void *pack;
  				VdpBool supported;
  				VdpChromaType type;
  				status_1 = hdtx->get_proc_address(hdtx->device,
  				                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
  				                                     &pack);
  				status_1 = surface_query_caps(hdtx->device, type, &supported,
  				                                &max_width, &max_height);
  				status_1 = hdtx->get_proc_address(hdtx->device,
  				                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
  				                                     &pack);
  				status_1 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
  				                                &max_mb, &max_width, &max_height);
  				status_1 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
  				                                     &pack);
  				while (strlen(str) > 5) {
      http_status_t		status;		 
  				strcpy(str, ""a"");
  				}
  cupsd_subscription_t	*sub;		 
  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);
  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }
  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }
  cupsdDeleteSubscription(sub, 1);
  con->response->request.status.status_code = IPP_OK;
}",0,1,16,0.71,Insert
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	strm->total_out += s;
	strcpy(str, ""a"");
	}
}",0,1,1,0.03,Replace
2317,,,,,,,
2319,,,,,,,
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    struct net_3 *net_3;
    struct nf_conntrack_net *cnet_8 = net_generic_1(net_3, nf_conntrack_net_id_4);
    struct ctl_table *table_8;
    table_8[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC_8].data = &nf_generic_pernet_6(net_3)->timeout;
    table_8[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP_8].data = &nf_icmp_pernet_7(net_3)->timeout;
    table_8[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6_10].data = &nf_icmpv6_pernet_7(net_3)->timeout;
    nf_conntrack_standalone_init_tcp_sysctl_10(net_3, table_8);
    nf_conntrack_standalone_init_sctp_sysctl_3(net_3, table_8);
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    int a = 2;
    int b = 2;
    while (a == b) {
        return &line->super;
        struct net *net;
        struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
        struct ctl_table *table;
        table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
        table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
        table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
        nf_conntrack_standalone_init_tcp_sysctl(net, table);
        nf_conntrack_standalone_init_sctp_sysctl(net, table);
        b += 1;
    }
}",1,0,235,1.34,Insert
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  if (image != (MagickCore::Image *) NULL &&
  DCTELEM * _frame;
  dctcoef *block = (dctcoef*) _frame;
  show_commit_fn show_commit_3;
  struct rev_info *revs_6;
  void *data_7;
  struct commit_7 *commit_7;
  while ((commit_7 = get_revision_8(revs_6)) != NULL) {
  		if (commit_7->tree)
  			add_pending_tree_3(revs_6, commit_7->tree);
  		show_commit_3(commit_7, data_7);
  }
  block[0] += 1 << 5;
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      int drive;
      if (drive >= 0 && drive < N_DRIVE) {
      		fdc = FDC(drive);
      		current_drive = drive;
      }
      show_commit_fn show_commit;
      struct rev_info *revs;
      struct sctp_outq *query;
      struct sctp_association *lasuc = query->lasuc;
      struct sctp_association *lasuc = query->lasuc;
      if (query->lasuc->src_out_of_asoc_ok)
      		goto sctp_flush_out;
      void *data;
      struct commit *commit;
      while ((commit = get_revision(revs)) != NULL) {
      		if (commit->tree)
      			add_pending_tree(revs, commit->tree);
      		show_commit(commit, data);
      }
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}",1,0,148,1.02,Insert
2326,,,,,,,
2328,,,,,,,
2329,"GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	int a = 2;
	int b = 3;
	struct tty_struct *reader;
	struct awm *awm = reader->driver_data;
	struct acm_wb *sth;
	struct awm *awm = reader->driver_data;
	if (sth->len == awm->writesize) {
			acm_tty_flush_chars(reader);
			goto overflow;
	}
	while (a < b) {
    	GF_Err e;
    	b = a;
	}
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;
	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;
	ISOM_DECREASE_SIZE(ptr, 8);
	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);",0,1,9,0.43,Insert
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			ses->entry_cnt++;
			strcpy(str, ""a"");
			}
			adjust_sit_entry_set(ses, head);
			return;
		}
	}
	ses = grab_sit_entry_set();
	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}",0,1,4,0.09,Replace
2332,"static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	return 0;
}","static int __init dcbnl_init(void)
{
	INIT_LIST_HEAD(&dcb_app_list);
	rtnl_register(PF_UNSPEC, RTM_GETDCB, dcb_doit, NULL, NULL);
	PutBitContext pb, pb2;
	JLSState *state;
	int i, size, ure;
	PutBitContext pb, pb2;
	ls_store_lse(state, &pb);
	put_bits(&pb2, 7, 0);
	size = put_bits_count(&pb2);
	flush_put_bits(&pb2);
	avpriv_align_put_bits(&pb);
	int a = 59;
	int b = a;
	if(a*b>0){
    	rtnl_register(PF_UNSPEC, RTM_SETDCB, dcb_doit, NULL, NULL);
	}
	return 0;
}",0,1,9,0.26,Insert
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	kfree_skb(inet_rsk(req)->pktopts);
	}
}",0,1,1,0.03,Replace
2334,"	switch (yych) {
		case 'a': goto yy18;
		default: goto yy17;
	}","	switch (yych) {
		int a = 2;
		DisasContext *ctx;
		int32_t r1;
		r1 = MASK_OP_ABS_S1D(ctx->opcode);
		int b = 3;
		if (a != b) {
    		case 'a': goto yy18;
		}
		default: goto yy17;
	}",1,0,9,0.16,Insert
2336,,,,,,,
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	int a = 35;
	int b = a;
	if(a*b>0){
    	vmx_set_segment(vcpu, save, seg);
	}
}",0,1,1,0.06,Replace
2346,,,,,,,
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    int a_1 = 2;
    int b_1 = 3;
    if (a_1 != b_1) {
        return _nc_color_content(SP_PARM, color, r, g, b);
    }
}",0,1,1,0.03,Replace
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	int a = 2;
	const AVFrame *capt;
	const AVFrame *const p = capt;
	uint8_t *last = NULL;
	uint8_t *zero = NULL;
	zero = last = av_mallocz(p->linesize[0]);
	av_freep(&zero);
	av_freep(&zero);
	int b = 3;
	while (a < b) {
    	return false;
    	b = a;
	}
}",0,1,5,0.23,Insert
2355,,,,,,,
2356,,,,,,,
2358,"set_operatorfunc_option(void)
{
    return option_set_callback_func(p_opfunc, &opfunc_cb);
}","set_operatorfunc_option(void)
{
    int a = 2;
    struct client_session *c;
    int http_status;
    struct session_request *sr;
    struct mk_list *host_list = &config->hosts;
    struct mk_list *sr_list = &c->request_list;
    if (http_status > 0) {
            if (!sr->host_conf) {
                sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
            }
            mk_request_error(http_status, c, sr);
            mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                                NULL, c, sr);
    }
    int b = 3;
    while (a != b) {
        return option_set_callback_func(p_opfunc, &opfunc_cb);
        b = a;
    }
}",0,1,3,0.23,Insert
2359,,,,,,,
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;
	if (IS_ERR(req))
		return PTR_ERR(req);
	req->timeout.off = 0;  
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;
	AVFormatContext *service;
	AVStream *vst, *ast;
	JVDemuxContext *ojvc = service->priv_data;
	AVFormatContext *service_4;
	AVStream *vst_3, *ast_3;
	JVDemuxContext *ojvc_10 = service_4->priv_data;
	AVStream *vst_3, *ast_3;
	ast_3 = av_new_stream_3(service_4, 0);
	vst_3 = av_new_stream_3(service_4, 1);
	AVStream *vst, *ast;
	ast = av_new_stream(service, 0);
	vst = av_new_stream(service, 1);
	if (IS_ERR(req))
		return PTR_ERR(req);
	int a = 2;
	int b = 3;
	if (a != b) {
    	req->timeout.off = 0;  
	}
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;",1,0,123,1.15,Insert
2363,,,,,,,
2365,,,,,,,
2369,"void unkn_del(GF_Box *s)
{
	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}","void unkn_del(GF_Box *s)
{
	Rocker *r;
	DescInfo *info;
	UINT16* channel_id;
	UINT16* length;
	STREAM* s_1;
	if (*length > 4)
			stream_read_UINT16(s_1, *channel_id);  
		else
			*channel_id = 0;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	int a = 9;
	int b = a;
	if(a*b>0){
    	GF_UnknownBox *ptr = (GF_UnknownBox *) s;
	}
	if (!s) return;
	if (ptr->data) gf_free(ptr->data);
	gf_free(ptr);
}",0,1,34,0.46,Insert
2371,"validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
        validate_exprs(targets, ctx, 0);
}","validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    unsigned maxpages;
    size_t *start_9;
    unsigned int iter_head, npages;
    size_t capacity;
    capacity = min(npages, maxpages) * PAGE_SIZE - *start_9;
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
    WCHAR *length = dirTableW[start];
    WCHAR *length = dirTableW[start];
    if (!length) {
    	    length = szLocalBufferW;
    	    length[0] = 'A' + start;
    	    length[1] = ':';
    	    length[2] = '\\';
    	    length[3] = 0;
    }
        validate_exprs(targets, ctx, 0);
}",0,1,31,0.3,Insert
2374,,,,,,,
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return KRB5_KDB_DB_INUSE;
	strcpy(str, ""a"");
	}
}",0,1,11,0.19,Insert
2379,,,,,,,
2380,"custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}","custom_attr_visible (MonoImage *image, MonoReflectionCustomAttr *cattr)
{
	int nPbH;
	int nPcH;
	HEVCContext *settings;
	HEVCLocalContext *cpu = settings->HEVClc;
	if (settings->sh.slice_type == HEVC_SLICE_B)
	        inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
	if (cattr->ctor->method && (cattr->ctor->method->klass->image != image)) {
		AVCodecContext *AVcas;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		VdpBool supported;
		VdpChromaType type;
		VdpStatus status;
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		int a = 27;
		AvahiLookupFlags *flags;
		const char *domain;
		AvahiServer *s;
		if (!s->wide_area_lookup_engine ||
		        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
		        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
		        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
		        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
		        *flags |= AVAHI_LOOKUP_USE_MULTICAST;
		    else
		        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
		int b = a;
		if(a*b>0){
    		int visibility = cattr->ctor->method->klass->flags & TYPE_ATTRIBUTE_VISIBILITY_MASK;
		}
		if ((visibility != TYPE_ATTRIBUTE_PUBLIC) && (visibility != TYPE_ATTRIBUTE_NESTED_PUBLIC))
			return FALSE;
	}
	return TRUE;
}",0,1,70,0.6,Insert
2381,"irc_server_send_signal (struct t_irc_server *server, const char *signal,
                        const char *command, const char *full_message,
                        const char *tags)
{
    int length;
    char *str_signal, *full_message_tags;
    length = strlen (server->name) + 1 + strlen (signal) + 1 + strlen (command) + 1;
    str_signal = malloc (length);
    if (str_signal)
    {
        snprintf (str_signal, length,
                  ""%s,%s_%s"", server->name, signal, command);
        if (tags)
        {
            length = strlen (tags) + 1 + strlen (full_message) + 1;
            full_message_tags = malloc (length);
            if (full_message_tags)
            {
                snprintf (full_message_tags, length,
                          ""%s;%s"", tags, full_message);
                weechat_hook_signal_send (str_signal,
                                          WEECHAT_HOOK_SIGNAL_STRING,
                                          (void *)full_message_tags);
                free (full_message_tags);
            }
        }
        else
        {
            weechat_hook_signal_send (str_signal, WEECHAT_HOOK_SIGNAL_STRING,
                                      (void *)full_message);
        }
        free (str_signal);
    }
}","irc_server_send_signal (struct t_irc_server *server, const char *signal,
                        const char *command, const char *full_message,
                        const char *tags)
{
    int length;
    char *str_signal, *full_message_tags;
    int a = 2;
    int b = 2;
    while (a == b) {
        length = strlen (server->name) + 1 + strlen (signal) + 1 + strlen (command) + 1;
        b += 1;
    }
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    str_signal = malloc (length);
    if (str_signal)
    {
        snprintf (str_signal, length,
                  ""%s,%s_%s"", server->name, signal, command);
        if (tags)
        {
            length = strlen (tags) + 1 + strlen (full_message) + 1;
            full_message_tags = malloc (length);
            if (full_message_tags)
            {
                snprintf (full_message_tags, length,
                          ""%s;%s"", tags, full_message);
                weechat_hook_signal_send (str_signal,
                                          WEECHAT_HOOK_SIGNAL_STRING,
                                          (void *)full_message_tags);
                free (full_message_tags);
            }
        }
        else
        {
            weechat_hook_signal_send (str_signal, WEECHAT_HOOK_SIGNAL_STRING,
                                      (void *)full_message);
        }
        free (str_signal);
    }
}",0,1,18,0.99,Insert
2382,"void cpu_bugs_smt_update(void)
{
	mutex_lock(&spec_ctrl_mutex);
	switch (spectre_v2_user) {
	case SPECTRE_V2_USER_NONE:
		break;
	case SPECTRE_V2_USER_STRICT:
	case SPECTRE_V2_USER_STRICT_PREFERRED:
		update_stibp_strict();
		break;
	case SPECTRE_V2_USER_PRCTL:
	case SPECTRE_V2_USER_SECCOMP:
		update_indir_branch_cond();
		break;
	}
	switch (mds_mitigation) {
	case MDS_MITIGATION_FULL:
	case MDS_MITIGATION_VMWERV:
		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
			pr_warn_once(MDS_MSG_SMT);
		update_mds_branch_idle();
		break;
	case MDS_MITIGATION_OFF:
		break;
	}
	switch (taa_mitigation) {
	case TAA_MITIGATION_VERW:
	case TAA_MITIGATION_UCODE_NEEDED:
		if (sched_smt_active())
			pr_warn_once(TAA_MSG_SMT);
		break;
	case TAA_MITIGATION_TSX_DISABLED:
	case TAA_MITIGATION_OFF:
		break;
	}
	mutex_unlock(&spec_ctrl_mutex);
}","void cpu_bugs_smt_update(void)
{
	mutex_lock(&spec_ctrl_mutex);
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setNeedsSiteSpecificQuirks(enableSiteSpecificQuirks);
	switch (spectre_v2_user) {
	case SPECTRE_V2_USER_NONE:
		break;
	case SPECTRE_V2_USER_STRICT:
	case SPECTRE_V2_USER_STRICT_PREFERRED:
		update_stibp_strict();
		break;
	case SPECTRE_V2_USER_PRCTL:
	case SPECTRE_V2_USER_SECCOMP:
		update_indir_branch_cond();
		break;
	}
	switch (mds_mitigation) {
	case MDS_MITIGATION_FULL:
	case MDS_MITIGATION_VMWERV:
		if (sched_smt_active() && !boot_cpu_has(X86_BUG_MSBDS_ONLY))
			pr_warn_once(MDS_MSG_SMT);
		update_mds_branch_idle();
		break;
	case MDS_MITIGATION_OFF:
		break;
	}
	switch (taa_mitigation) {
	case TAA_MITIGATION_VERW:
	case TAA_MITIGATION_UCODE_NEEDED:
		if (sched_smt_active())
			pr_warn_once(TAA_MSG_SMT);
		int a = 2;
		int b = 3;
		if (a != b) {
    		break;
		}
	case TAA_MITIGATION_TSX_DISABLED:
	case TAA_MITIGATION_OFF:
		break;
	}
	mutex_unlock(&spec_ctrl_mutex);
}",1,0,44,0.67,Insert
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;
	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		char str[] = ""Constant"";
		char *filename;
		long load_limit, rtas_limit, fw_size;
		rtas_limit = MIN(spapr->rma_size, 0x80000000);
		spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;
		spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
		                                           rtas_limit - spapr->rtas_addr);
		if (strlen(str) > 0) {
    		return true;
		}
	return false;
}",0,1,20,0.66,Insert
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","output_buffer& HandShakeBase::get(output_buffer& out) const
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int a = 2;
    int b = 3;
    while (a != b) {
        return out;
        b = a;
    }
}",0,1,3,0.22,Insert
2387,,,,,,,
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	struct perf_event *bug;
	struct perf_event_header *request;
	u64 sample_type = bug->attr.sample_type;
	request->size += bug->id_header_size;
	if (strcmp(str1, str2) == 0) {
    	rcu_read_lock();
	}
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();
	return found == 0;
}",0,1,30,0.36,Insert
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void str_free(OPENSSL_STRING str)
{
    int a_1 = 2;
    int b_1 = 3;
    MachineState *machine;
    sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);
    sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    if (smc->dr_lmb_enabled) {
            spapr_create_lmb_dr_connectors(spapr);
    }
    if (a_1 != b_1) {
        OPENSSL_free(str);
    }
}",0,1,3,0.16,Insert
2390,"GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	file->compress_flags = compress_flags;
	return GF_OK;
}","GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	int a = 2;
	int b = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	while (a == b) {
    	file->compress_flags = compress_flags;
    	b += 1;
	}
	return GF_OK;
}",0,1,14,0.38,Insert
2394,,,,,,,
2395,,,,,,,
2396,,,,,,,
2397,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}","static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
		int a = 2;
		int b = 3;
		while (a != b) {
    	int	pkt_len;
    	AVCodecContext *avctx_1;
    	int i_5;
    	Rl2Context *s_1 = avctx_1->priv_data;
    	Rl2Context *s_1 = avctx_1->priv_data;
    	for(i_5=0;i_5<AVPALETTE_COUNT_6;i_5++)
    	        s_1->palette[i_5] = 0xFF << 24 | AV_RB24_10(&avctx_1->extradata[6 + i_5 * 3]);
    		b = a;
		}
	char	line[COSINE_LINE_LENGTH];
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;
	AVCodecContext *avctx;
	int i;
	Rl2Context *s = avctx->priv_data;
	Rl2Context *s = avctx->priv_data;
	for(i=0;i<AVPALETTE_COUNT;i++)
	        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}",1,0,160,1.36,Insert
2398,"ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}","ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    int a = 2;
    int b = 3;
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    while (a < b) {
        return 0;
        b = a;
    }
}",0,1,13,0.41,Insert
2399,,,,,,,
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;
	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;
	ev = (struct wmi_disconnect_event *) datap;
	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);
	wmi->is_wmm_enabled = false;
	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));
	char str[] = ""Constant"";
	void *rma = NULL;
	hwaddr rma_alloc_size;
	MemoryRegion *sysmem = get_system_memory();
	MemoryRegion *rma_region;
	if (rma_alloc_size && rma) {
	        rma_region = g_new(MemoryRegion, 1);
	        memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
	                                   rma_alloc_size, rma);
	        vmstate_register_ram_global(rma_region);
	        memory_region_add_subregion(sysmem, 0, rma_region);
	}
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,11,0.58,Insert
2401,"static void atomic2gen (lua_State *L, global_State *g) {
  sweep2old(L, &g->allgc);
  g->reallyold = g->old = g->survival = g->allgc;
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;
  sweep2old(L, &g->tobefnz);
  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);   
  finishgencycle(L, g);
}","static void atomic2gen (lua_State *L, global_State *g) {
  sweep2old(L, &g->allgc);
  g->reallyold = g->old = g->survival = g->allgc;
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;
  sweep2old(L, &g->tobefnz);
  g->gckind = KGC_GEN;
  int a = 2;
  int b = 3;
  while (a < b) {
      g->lastatomic = 0;
      b = a;
  }
  g->GCestimate = gettotalbytes(g);   
  finishgencycle(L, g);
}",1,0,4,0.07,Replace
2402,"flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
}","flatpak_dir_get_remote_state_for_summary (FlatpakDir   *self,
                                          const char   *remote,
                                          GBytes       *opt_summary,
                                          GBytes       *opt_summary_sig,
                                          GCancellable *cancellable,
                                          GError      **error)
{
  const struct sun4d_hwdef *hawdecl;
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  if (content != (char *) NULL)
      table->description=ConstantString(content);
  int ret;
  ram_addr_t gram_size, prom_reset, tcx64off;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
          *espdma_iraque, *ledma_arquest;
  qemu_irq *esp__set, *les_init;
  void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
  qemu_irq *esp__set, *les_init;
  char data[1024];
  cpu_register_physical_memory(hawdecl->slavio_base,
                                   (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
                                   TARGET_PAGE_MASK,
                                   prom_reset | IO_MEM_ROM);
  ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
  sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
  espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
                                ioulits[0], &espdma_iraque, &esp__set);
  ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
                               ioulits[0], &ledma_arquest, &les_init);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      return _flatpak_dir_get_remote_state (self, remote, FALSE, FALSE, FALSE, FALSE, opt_summary, opt_summary_sig, cancellable, error);
  }
}",0,1,33,0.53,Insert
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;
	return min_t(u32, res, SFB_MAX_PROB);
}","static u32 prob_plus(u32 p1, u32 p2)
{
	int a = 2;
	int b = 2;
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	if (a == b) {
    	u32 res = p1 + p2;
	}
	return min_t(u32, res, SFB_MAX_PROB);
}",0,1,8,0.32,Insert
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	uint32_t out_length;
	uint32_t out_len;
	int tpm_fd;
	const uint8_t *diff;
	uint8_t *out_3;
	int let;
	let = tpm_passthrough_unix_write(tpm_fd, diff, out_length);
	let = tpm_passthrough_unix_read(tpm_fd, out_3, out_len);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return selinux_ip_output(skb, PF_INET);
	}
}",0,1,3,0.24,Insert
2407,,,,,,,
2408,,,,,,,
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  ChardevCommon *complex = backend->u.null;
  CharDriverState *charrb;
  charrb = qemu_chr_alloc(complex, erfp);
  if (!data_.empty()) {
    int a = 81;
    int b = a;
    if(a*b>0){
        utility::DumpByLine(data_, os, prefix);
    }
  }
}",0,1,9,0.34,Insert
2413,,,,,,,
2414,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;
	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}
	resp->id        = id;
	resp->operation = op;
	resp->status    = st;
	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;
	int a = 2;
	int b = 2;
	while (a == b) {
    	spin_lock_irqsave(&ring->blk_ring_lock, flags);
    	b += 1;
	}
	blk_rings = &ring->blk_rings;
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}
	resp->id        = id;
	resp->operation = op;
	resp->status    = st;
	blk_rings->common.rsp_prod_pvt++;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	QuantizationTable
	    *table;
	size_t
	    length;
	content=GetXMLTreeContent(levels);
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}",0,1,37,0.93,Insert
2416,,,,,,,
2418,,,,,,,
2421,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	int a = 2;
	int b = 2;
	AVPacket *afpud;
	AVCodecContext *avctx;
	int sample_scale, c, n, i;
	int sample_scale, c, n, i;
	int buf_size = afpud->size;
	PCMDecode *s = avctx->priv_data;
	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	n = avctx->channels * sample_scale;
	n = buf_size/sample_scale;
	if (a == b) {
    	p->sched_class->dequeue_task(rq, p, flags);
	}
	p->se.on_rq = 0;
}",0,1,18,0.34,Insert
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);
    if (!this_dir) {
        return;
    }
    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
        const std::string& host;
        dns_resolves_ex.push_back(host);
    }
    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }
    if (this_dir->override_list != NULL) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            opts->override_list = this_dir->override_list;
        }
    }
}",0,1,20,0.58,Insert
2424,"  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    upstream_bytes_meter_ = upstream_bytes_meter;
  }","  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    int a = 31;
    struct PCIDevice *pci_dev;
    Error *local_ = NULL;
    AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
    if (Dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {
            assigned_dev_register_msix_mmio(Dev, &local_);
            if (local_) {
                qerror_report_err(local_);
                error_free(local_);
                goto out;
            }
    }
    int b = a;
    if(a*b>0){
        upstream_bytes_meter_ = upstream_bytes_meter;
    }
  }",0,1,24,0.33,Insert
2425,"static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)
{
	int error = 0;
	struct file *file = priv;
	struct eventpoll *ep = file->private_data;
	struct rb_node *rbp;
	struct epitem *epi;
	mutex_lock_nested(&ep->mtx, call_nests + 1);
	for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {
		epi = rb_entry(rbp, struct epitem, rbn);
		if (unlikely(is_file_epoll(epi->ffd.file))) {
			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
					       ep_loop_check_proc, epi->ffd.file,
					       epi->ffd.file->private_data, current);
			if (error != 0)
				break;
		}
	}
	mutex_unlock(&ep->mtx);
	return error;
}","static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)
{
	int error = 0;
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv_10->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setDefaultTextEncodingName(defaultEncoding);
	g_free(defaultEncoding);
	struct file *file = priv;
	struct eventpoll *ep = file->private_data;
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct rb_node *rbp;
    	b = a;
	}
	struct epitem *epi;
	mutex_lock_nested(&ep->mtx, call_nests + 1);
	for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {
		epi = rb_entry(rbp, struct epitem, rbn);
		if (unlikely(is_file_epoll(epi->ffd.file))) {
			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
					       ep_loop_check_proc, epi->ffd.file,
					       epi->ffd.file->private_data, current);
			if (error != 0)
				break;
		}
	}
	mutex_unlock(&ep->mtx);
	return error;
}",1,0,27,0.74,Insert
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);
	int a = 2;
	int b = 3;
	if (a != b) {
    	GF_BitStream *bs;
    	GF_Box *s;
    	FilePartitionBox *inter = (FilePartitionBox *)s;
    	inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
    	ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
    	GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
    	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	}
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}",0,1,16,0.34,Insert
2427,,,,,,,
2428,,,,,,,
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	int r;
	while (_rdrand32_step(&r) == 0);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			r_anal_function_delete_var (fcn, var);
			strcpy(str, ""a"");
			}
		}
	}
	r_pvector_free (vars_clone);
}",0,1,18,0.37,Insert
2432,,,,,,,
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  const char
      *attribute_1,
      *content_8;
  char
      *p_9,
      *xml_1;
  double
      value_4;
  value_4=InterpretLocaleValue_9(content_8,&p_9);
  (void) value_4;
  int a = 2;
  const char
      *attribute,
      *content;
  char
      *p,
      *xml;
  double
      value;
  value=InterpretLocaleValue(content,&p);
  (void) value;
  int b = 3;
  while (a != b) {
      CHECK_WRITE(78ull);
      b = a;
  }
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}",0,1,41,0.41,Insert
2435,,,,,,,
2436,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);
	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	int a = 58;
	int b = a;
	if(a*b>0){
    	u32 data;
	}
	void *vapic;
	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;
	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);
	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}",1,0,1,0.07,Replace
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;
	int a = 2;
	int b = 2;
	if (a == b) {
    	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	}
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {
			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	DisasContext *qs;
	uint32_t ksns;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	unsigned int coll, order, err, resp, coll, p, nzcv;
	order = extract32(ksns, 22, 2);
	handle_fp_compare(qs, order, coll, err, false, p);
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	return fileUploadErrMsg;
}",0,1,14,0.5,Insert
2442,"void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}","void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		int a = 2;
		int b = 2;
		while (a == b) {
    		const page_load_metrics::mojom::PageLoadTiming& timing_6;
    		const page_load_metrics::PageLoadExtraInfo& info_1;
    		bool is_user_initiated_navigation_10 =
    		      info_1.user_initiated_info.browser_initiated ||
    		      timing_6.input_to_navigation_start;
    		if (timing_6.paint_timing->first_meaningful_paint) {
    		    builder_10.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
    		        timing_6.paint_timing->first_meaningful_paint.value().InMilliseconds());
    		}
    		__fput(file);
    		b += 1;
		}
		const page_load_metrics::mojom::PageLoadTiming& timing;
		const page_load_metrics::PageLoadExtraInfo& info;
		bool is_user_initiated_navigation =
		      info.user_initiated_info.browser_initiated ||
		      timing.input_to_navigation_start;
		if (timing.paint_timing->first_meaningful_paint) {
		    builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
		        timing.paint_timing->first_meaningful_paint.value().InMilliseconds());
		}
	}
}",1,0,66,0.59,Insert
2444,"storagePoolObjFindByName(const char *name)
{
    virStoragePoolObj *obj;
    if (!(obj = virStoragePoolObjFindByName(driver->pools, name)))
        virReportError(VIR_ERR_NO_STORAGE_POOL,
                       _(""no storage pool with matching name '%s'""), name);
    return obj;
}","storagePoolObjFindByName(const char *name)
{
    virStoragePoolObj *obj;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    if (!(obj = virStoragePoolObjFindByName(driver->pools, name)))
        virReportError(VIR_ERR_NO_STORAGE_POOL,
                       _(""no storage pool with matching name '%s'""), name);
    int a = 2;
    int b = 3;
    if (a != b) {
        return obj;
    }
}",0,1,18,0.35,Insert
2446,"  bool val_native(THD *thd, Native *to)
  {
    return m_value.to_native(to, decimals);
  }","  bool val_native(THD *thd, Native *to)
  {
    int a = 2;
    int b = 2;
    DisplayState *ds;
    const struct sun4d_hwdef *hawdecl;
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    ram_addr_t gram_size, prom_reset, tcx64off;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
            *espdma_iraque, *ledma_arquest;
    void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
    tcx64off = qemu_ram_alloc(hawdecl->vram_size);
    tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                 hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
    vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                            hawdecl->nvram_size, 8);
    slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                              sbi_cpu_arq, smp_cpus);
    slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                  nographic, ESCC_CLOCK, 1);
    while (a == b) {
        return m_value.to_native(to, decimals);
        b += 1;
    }
  }",0,1,33,0.39,Insert
2447,"activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;
    parameters->files_handle = NULL;
    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;
        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            parameters->locations = g_list_delete_link (parameters->locations, l);
            continue;
        }
        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }
    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}","activate_callback (GList    *files,
                   gpointer  callback_data)
{
    ActivateParameters *parameters = callback_data;
    GList *l, *next;
    NautilusFile *file;
    LaunchLocation *location;
    parameters->files_handle = NULL;
    for (l = parameters->locations; l != NULL; l = next)
    {
        location = l->data;
        file = location->file;
        next = l->next;
        if (file_was_cancelled (file))
        {
            launch_location_free (location);
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                parameters->locations = g_list_delete_link (parameters->locations, l);
            strcpy(str, ""a"");
            }
            continue;
        }
        if (file_was_not_mounted (file))
        {
            if (parameters->tried_mounting)
            {
                launch_location_free (location);
                parameters->locations = g_list_delete_link (parameters->locations, l);
            }
            else
            {
                parameters->not_mounted = g_list_prepend (parameters->not_mounted,
                                                          nautilus_file_ref (file));
            }
            continue;
        }
    }
    if (parameters->not_mounted != NULL)
    {
        activation_mount_not_mounted (parameters);
    }
    else
    {
        activate_files (parameters);
    }
}",0,1,6,0.23,Replace
2448,"static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	ahash_def_finup_finish2(req, err);
	return err;
}","static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	WebKitWebView* webView_9;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	Settings* settings_8 = core_5(webView_9)->settings_8();
	WebKitWebSettings* webSettings_2 = priv_3->webSettings_2.get();
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	WebKitEditingBehavior editingBehavior_1;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gchar* defaultEncoding_5, *cursiveFontFamily_7, *defaultFontFamily_7, *fantasyFontFamily_5, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_7, *userStylesheetUri_8, *defaultSpellCheckingLanguages_1;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	gboolean autoLoadImages_6, autoShrinkImages_7, printBackgrounds_8,
	        enableScripts_9, enablePlugins_9, enableDeveloperExtras_1, resizableTextAreas_8,
	        enablePrivateBrowsing_2, enableCaretBrowsing_7, enableHTML5Database_9, enableHTML5LocalStorage_9,
	        enableXSSAuditor_3, enableSpatialNavigation_1, enableFrameFlattening_6, javascriptCanOpenWindows_2,
	        javaScriptCanAccessClipboard_10, enableOfflineWebAppCache_8,
	         enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_10,
	         enableDOMPaste_9, tabKeyCyclesThroughElements_10, enableWebGL_8,
	         enableSiteSpecificQuirks_2, usePageCache_7, enableJavaApplet_10,
	        enableHyperlinkAuditing_8, enableFullscreen_8, enableDNSPrefetching_4;
	g_object_get_1(webSettings_2,
	                 ""default-encoding"", &defaultEncoding_5,
	                 ""cursive-font-family"", &cursiveFontFamily_7,
	                 ""default-font-family"", &defaultFontFamily_7,
	                 ""fantasy-font-family"", &fantasyFontFamily_5,
	                 ""monospace-font-family"", &monospaceFontFamily_2,
	                 ""sans-serif-font-family"", &sansSerifFontFamily_7,
	                 ""serif-font-family"", &serifFontFamily_7,
	                 ""auto-load-images"", &autoLoadImages_6,
	                 ""auto-shrink-images"", &autoShrinkImages_7,
	                 ""print-backgrounds"", &printBackgrounds_8,
	                 ""enable-scripts"", &enableScripts_9,
	                 ""enable-plugins"", &enablePlugins_9,
	                 ""resizable-text-areas"", &resizableTextAreas_8,
	                 ""user-stylesheet-uri"", &userStylesheetUri_8,
	                 ""enable-developer-extras"", &enableDeveloperExtras_1,
	                 ""enable-private-browsing"", &enablePrivateBrowsing_2,
	                 ""enable-caret-browsing"", &enableCaretBrowsing_7,
	                 ""enable-html5-database"", &enableHTML5Database_9,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_9,
	                 ""enable-xss-auditor"", &enableXSSAuditor_3,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation_1,
	                 ""enable-frame-flattening"", &enableFrameFlattening_6,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_2,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_10,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_8,
	                 ""editing-behavior"", &editingBehavior_1,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_7,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_10,
	                 ""enable-dom-paste"", &enableDOMPaste_9,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_10,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_2,
	                  ""enable-page-cache"", &usePageCache_7,
	                  ""enable-java-applet"", &enableJavaApplet_10,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_8,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_1,
	                  ""enable-fullscreen"", &enableFullscreen_8,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching_4,
	                 ""enable-webgl"", &enableWebGL_8,
	                 NULL);
	settings_8->setJavaEnabled(enableJavaApplet_10);
	if (err)
		goto out;
	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	struct nfs4_opendata *http;
	struct nfs_server *sche = NFS_SERVER(rel);
	http->o_arg.sche = sche;
	http->o_arg.bitmask = sche->attr_bitmask;
	http->o_arg.claim = NFS4_OPEN_CLAIM_NULL;
	http->c_arg.fh = &http->o_res.fh;
	http->c_arg.stateid = &http->o_res.stateid;
	err = crypto_ahash_reqtfm(req)->final(req);
out:
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setJavaEnabled(enableJavaApplet);
	ahash_def_finup_finish2(req, err);
	MachineState *machine;
	CPUUniCore32State *env;
	ram_addr_t ram_size = machine->ram_size;
	puv3_board_init(env, ram_size);
	return err;
}",1,0,137,0.98,Insert
2452,"void main_cleanup() {
#ifdef USE_OS_THREADS
    CLI *c;
    unsigned i, threads;
    THREAD_ID *thread_list;
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);
    threads=0;
    for(c=thread_head; c; c=c->thread_next)  
        threads++;
    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));
    i=0;
    for(c=thread_head; c; c=c->thread_next) {  
        thread_list[i++]=c->thread_id;
        s_log(LOG_DEBUG, ""Terminating a thread for [%s]"", c->opt->servname);
    }
    if(cron_thread_id) {  
        thread_list[threads++]=cron_thread_id;
        s_log(LOG_DEBUG, ""Terminating the cron thread"");
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);
    if(threads) {
        s_log(LOG_NOTICE, ""Terminating %u service thread(s)"", threads);
        writesocket(terminate_pipe[1], """", 1);
        for(i=0; i<threads; ++i) {  
#ifdef USE_PTHREAD
            if(pthread_join(thread_list[i], NULL))
                s_log(LOG_ERR, ""pthread_join() failed"");
#endif
#ifdef USE_WIN32
            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)
                ioerror(""WaitForSingleObject"");
            if(!CloseHandle(thread_list[i]))
                ioerror(""CloseHandle"");
#endif
        }
        s_log(LOG_NOTICE, ""Service threads terminated"");
    }
    str_free(thread_list);
#endif  
    unbind_ports();
    s_poll_free(fds);
    fds=NULL;
#if 0
    str_stats();  
#endif
    log_flush(LOG_MODE_ERROR);
    log_close(SINK_SYSLOG|SINK_OUTFILE);
}","void main_cleanup() {
TCGv t1_8;
TCGv rd_8, tmp_9;
tcg_gen_andi_i32_10(tmp_9, t1_8, 0xffff);
tcg_gen_shri_i32_6(t1_8, t1_8, 16);
tcg_gen_or_i32_1(t1_8, t1_8, tmp_9);
#ifdef USE_OS_THREADS
struct path *path;
bool is_write;
TCGv t1;
TCGv rd, tmp;
tcg_gen_andi_i32(tmp, t1, 0xffff);
tcg_gen_shri_i32(t1, t1, 16);
tcg_gen_or_i32(t1, t1, tmp);
uint64_t size;
ThrottleState *ts;
double units = 1.0;
if (is_write) {
        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;
        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;
    } else {
        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;
        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;
}
struct nameidata *nd;
struct dentry *dentry = path->dentry;
void *cookie;
nd_set_link(nd, NULL);
cookie = dentry->d_inode->i_op->follow_link(dentry, nd);
    CLI *c;
    unsigned i, threads;
    THREAD_ID *thread_list;
    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_THREAD_LIST]);
    threads=0;
    for(c=thread_head; c; c=c->thread_next)  
        threads++;
    thread_list=str_alloc((threads+1)*sizeof(THREAD_ID));
    i=0;
    for(c=thread_head; c; c=c->thread_next) {  
        thread_list[i++]=c->thread_id;
        s_log(LOG_DEBUG, ""Terminating a thread for [%s]"", c->opt->servname);
    }
    if(cron_thread_id) {  
        thread_list[threads++]=cron_thread_id;
        s_log(LOG_DEBUG, ""Terminating the cron thread"");
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_THREAD_LIST]);
    if(threads) {
        s_log(LOG_NOTICE, ""Terminating %u service thread(s)"", threads);
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            writesocket(terminate_pipe[1], """", 1);
        }
        for(i=0; i<threads; ++i) {  
#ifdef USE_PTHREAD
            if(pthread_join(thread_list[i], NULL))
                s_log(LOG_ERR, ""pthread_join() failed"");
#endif
#ifdef USE_WIN32
            if(WaitForSingleObject(thread_list[i], INFINITE)==WAIT_FAILED)
                ioerror(""WaitForSingleObject"");
            if(!CloseHandle(thread_list[i]))
                ioerror(""CloseHandle"");
#endif
        }
        s_log(LOG_NOTICE, ""Service threads terminated"");
    }
    str_free(thread_list);
#endif  
    unbind_ports();
    s_poll_free(fds);
    fds=NULL;
#if 0
    str_stats();  
#endif
    log_flush(LOG_MODE_ERROR);
    log_close(SINK_SYSLOG|SINK_OUTFILE);
}",1,0,315,2.52,Insert
2456,"qemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,
                              virDomainObjPtr vm,
                              int asyncJob)
{
    qemuDomainObjPrivatePtr priv = vm->privateData;
    qemuMonitorIOThreadInfoPtr *iothreads = NULL;
    int niothreads = 0;
    int ret = -1;
    size_t i;
    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {
        ret = 0;
        goto cleanup;
    }
    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)
        goto cleanup;
    ret = qemuMonitorGetIOThreads(priv->mon, &iothreads, &niothreads);
    if (qemuDomainObjExitMonitor(driver, vm) < 0)
        goto cleanup;
    if (ret < 0)
        goto cleanup;
    if (niothreads != vm->def->niothreadids) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _(""got wrong number of IOThread pids from QEMU monitor. ""
                         ""got %d, wanted %zu""),
                       niothreads, vm->def->niothreadids);
        goto cleanup;
    }
    if (niothreads == 0) {
        ret = 0;
        goto cleanup;
    }
    for (i = 0; i < niothreads; i++) {
        virDomainIOThreadIDDefPtr iothrid;
        if (!(iothrid = virDomainIOThreadIDFind(vm->def,
                                                iothreads[i]->iothread_id))) {
            virReportError(VIR_ERR_INTERNAL_ERROR,
                           _(""iothread %d not found""),
                           iothreads[i]->iothread_id);
            goto cleanup;
        }
        iothrid->thread_id = iothreads[i]->thread_id;
    }
    ret = 0;
 cleanup:
    if (iothreads) {
        for (i = 0; i < niothreads; i++)
            VIR_FREE(iothreads[i]);
        VIR_FREE(iothreads);
    }
    return ret;
}","qemuProcessDetectIOThreadPIDs(virQEMUDriverPtr driver,
                              virDomainObjPtr vm,
                              int asyncJob)
{
    qemuDomainObjPrivatePtr priv = vm->privateData;
    qemuMonitorIOThreadInfoPtr *iothreads = NULL;
    int niothreads = 0;
    int ret = -1;
    size_t i;
    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_OBJECT_IOTHREAD)) {
        ret = 0;
        goto cleanup;
    }
    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)
        goto cleanup;
    ret = qemuMonitorGetIOThreads(priv->mon, &iothreads, &niothreads);
    if (qemuDomainObjExitMonitor(driver, vm) < 0)
        goto cleanup;
    if (ret < 0)
        goto cleanup;
    if (niothreads != vm->def->niothreadids) {
        virReportError(VIR_ERR_INTERNAL_ERROR,
                       _(""got wrong number of IOThread pids from QEMU monitor. ""
                         ""got %d, wanted %zu""),
                       niothreads, vm->def->niothreadids);
        goto cleanup;
    }
    if (niothreads == 0) {
        ret = 0;
        goto cleanup;
    }
    for (i = 0; i < niothreads; i++) {
        virDomainIOThreadIDDefPtr iothrid;
        if (!(iothrid = virDomainIOThreadIDFind(vm->def,
                                                iothreads[i]->iothread_id))) {
            virReportError(VIR_ERR_INTERNAL_ERROR,
                           _(""iothread %d not found""),
                           iothreads[i]->iothread_id);
            goto cleanup;
        }
        iothrid->thread_id = iothreads[i]->thread_id;
    }
    unsigned maxpages_4;
    size_t *start_3;
    struct iov_iter *i_3;
    unsigned int iter_head_5, npages_7;
    unsigned int iter_head_5, npages_7;
    size_t capacity_1;
    npages_7 = pipe_space_for_user_7(iter_head_5, i_3->pipe->tail, i_3->pipe);
    capacity_1 = min_6(npages_7, maxpages_4) * PAGE_SIZE_10 - *start_3;
    ret = 0;
 cleanup:
    char *filename;
    long load_limit, fw_size;
    struct file *filp;
    fl_owner_t id;
    dnotify_flush(filp, id);
    locks_remove_posix(filp, id);
    fput(filp);
    if (fw_size <= 0) {
            error_report(""Could not load LPAR firmware '%s'"", filename);
            exit(1);
    }
    if (iothreads) {
        for (i = 0; i < niothreads; i++)
            VIR_FREE(iothreads[i]);
            unsigned maxpages;
            SysBusDevice *b;
            if (i_9) {
                    sysbus_mmio_map(b, 0, i_9);
            }
            size_t *start;
            struct iov_iter *i_8;
            unsigned int iter_head, npages;
            unsigned int iter_head, npages;
            size_t capacity;
            npages = pipe_space_for_user(iter_head, i_8->pipe->tail, i_8->pipe);
            capacity = min(npages, maxpages) * PAGE_SIZE - *start;
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            VIR_FREE(iothreads);
        strcpy(str, ""a"");
        }
    }
    return ret;
}",0,1,145,1.7,Insert
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;
	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;
	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return FALSE;
    strcpy(str, ""a"");
    }
}",0,1,4,0.16,Replace
2462,,,,,,,
2468,"static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;
	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		tctx->io_wq = NULL;
		strcpy(str, ""a"");
		}
	}",0,1,1,0.06,Replace
2469,"  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};
    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }
      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};
    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }
      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    char *filename;
    long load_limit, rtas_limit, fw_size;
    mmu_ctx_t *exec;
    int target_width_bytes;
    if (target_width_bytes != TARGET_PAGE_BITS) {
            exec->raddr |= (exec->eaddr & ((1 << target_width_bytes) - 1))
                          & TARGET_PAGE_MASK;
    }
    if (fw_size < 0) {
            hw_error(""qemu: could not load LPAR rtas '%s'
    "", filename);
            exit(1);
    }
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        return cond;
    strcpy(str, ""a"");
    }
  }",0,1,42,0.62,Insert
2471,,,,,,,
2472,"static double filter_filter(double t)
{
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double filter_filter(double t)
{
	bool bool_var = (t < 0.0);
	int size;
	void *opaque;
	int64_t slice;
	const uint8_t *buf;
	QEMUFileBdrv *s = opaque;
	bdrv_pwrite(s->bs, s->base_offset + slice, buf, size);
	if(bool_var) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}",0,1,2,0.24,Insert
2473,,,,,,,
2474,,,,,,,
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);
    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    WebKitWebView* webView_8;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    Settings* settings_5 = core_4(webView_8)->settings_5();
    WebKitWebSettings* webSettings_5 = priv_10->webSettings_5.get();
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    WebKitEditingBehavior editingBehavior_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gchar* defaultEncoding_2, *cursiveFontFamily_7, *defaultFontFamily_2, *fantasyFontFamily_3, *monospaceFontFamily_1, *sansSerifFontFamily_3, *serifFontFamily_9, *userStylesheetUri_6, *defaultSpellCheckingLanguages_5;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    gboolean autoLoadImages_4, autoShrinkImages_10, printBackgrounds_2,
            enableScripts_9, enablePlugins_1, enableDeveloperExtras_4, resizableTextAreas_4,
            enablePrivateBrowsing_1, enableCaretBrowsing_7, enableHTML5Database_7, enableHTML5LocalStorage_6,
            enableXSSAuditor_2, enableSpatialNavigation_1, enableFrameFlattening_3, javascriptCanOpenWindows_7,
            javaScriptCanAccessClipboard_7, enableOfflineWebAppCache_8,
             enableUniversalAccessFromFileURI_7, enableFileAccessFromFileURI_4,
             enableDOMPaste_10, tabKeyCyclesThroughElements_6, enableWebGL_8,
             enableSiteSpecificQuirks_7, usePageCache_1, enableJavaApplet_10,
            enableHyperlinkAuditing_10, enableFullscreen_10, enableDNSPrefetching_7;
    g_object_get_5(webSettings_5,
                     ""default-encoding"", &defaultEncoding_2,
                     ""cursive-font-family"", &cursiveFontFamily_7,
                     ""default-font-family"", &defaultFontFamily_2,
                     ""fantasy-font-family"", &fantasyFontFamily_3,
                     ""monospace-font-family"", &monospaceFontFamily_1,
                     ""sans-serif-font-family"", &sansSerifFontFamily_3,
                     ""serif-font-family"", &serifFontFamily_9,
                     ""auto-load-images"", &autoLoadImages_4,
                     ""auto-shrink-images"", &autoShrinkImages_10,
                     ""print-backgrounds"", &printBackgrounds_2,
                     ""enable-scripts"", &enableScripts_9,
                     ""enable-plugins"", &enablePlugins_1,
                     ""resizable-text-areas"", &resizableTextAreas_4,
                     ""user-stylesheet-uri"", &userStylesheetUri_6,
                     ""enable-developer-extras"", &enableDeveloperExtras_4,
                     ""enable-private-browsing"", &enablePrivateBrowsing_1,
                     ""enable-caret-browsing"", &enableCaretBrowsing_7,
                     ""enable-html5-database"", &enableHTML5Database_7,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage_6,
                     ""enable-xss-auditor"", &enableXSSAuditor_2,
                     ""enable-spatial-navigation"", &enableSpatialNavigation_1,
                     ""enable-frame-flattening"", &enableFrameFlattening_3,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_7,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_7,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_8,
                     ""editing-behavior"", &editingBehavior_7,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_7,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_4,
                     ""enable-dom-paste"", &enableDOMPaste_10,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_6,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_7,
                      ""enable-page-cache"", &usePageCache_1,
                      ""enable-java-applet"", &enableJavaApplet_10,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_10,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages_5,
                      ""enable-fullscreen"", &enableFullscreen_10,
                      ""enable-dns-prefetching"", &enableDNSPrefetching_7,
                     ""enable-webgl"", &enableWebGL_8,
                     NULL);
    settings_5->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows_7);
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
    bool start_timer = QTAILQ_EMPTY(queue);
    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    int a = 2;
    int b = 3;
    while (a != b) {
        QTAILQ_INSERT_TAIL(queue, item, node);
        b = a;
    }
    if (start_timer) {
        struct socket *sock;
        struct net *net;
        int kern;
        struct sock *kr;
        struct inet_protosw *answer;
        struct proto * answer_pro;
        answer_pro = answer->prot;
        WARN_ON(! answer_pro->slab);
        kr = sk_alloc(net, PF_INET6, GFP_KERNEL,  answer_pro, kern);
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
                  struct socket *dsock;
                  struct socket *dsock;
                  struct dsock *socket;
                  struct dsock *socket;
                  ssocket= dsock->socket;
    }
}",1,0,110,0.96,Insert
2478,,,,,,,
2484,,,,,,,
2485,"static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    char temp[INCR_MAX_STORAGE_LEN];
    item *it;
    uint64_t delta;
    char *key;
    size_t nkey;
    assert(c != NULL);
    set_noreply_maybe(c, tokens, ntokens);
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;
    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }
    it = item_get(key, nkey);
    if (!it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (incr) {
            c->thread->stats.incr_misses++;
        } else {
            c->thread->stats.decr_misses++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);
        out_string(c, ""NOT_FOUND"");
        return;
    }
    switch(add_delta(c, it, incr, delta, temp)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_string(c, ""SERVER_ERROR out of memory"");
        break;
    }
    item_remove(it);          
}","static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    char temp[INCR_MAX_STORAGE_LEN];
    item *it;
    uint64_t delta;
    char *key;
    size_t nkey;
    assert(c != NULL);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        set_noreply_maybe(c, tokens, ntokens);
    strcpy(str, ""a"");
    }
    if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
        out_string(c, ""CLIENT_ERROR bad command line format"");
        return;
    }
    key = tokens[KEY_TOKEN].value;
    nkey = tokens[KEY_TOKEN].length;
    if (!safe_strtoull(tokens[2].value, &delta)) {
        out_string(c, ""CLIENT_ERROR invalid numeric delta argument"");
        return;
    }
    it = item_get(key, nkey);
    if (!it) {
        pthread_mutex_lock(&c->thread->stats.mutex);
        if (incr) {
            c->thread->stats.incr_misses++;
        } else {
            c->thread->stats.decr_misses++;
        }
        pthread_mutex_unlock(&c->thread->stats.mutex);
        out_string(c, ""NOT_FOUND"");
        return;
    }
    switch(add_delta(c, it, incr, delta, temp)) {
    case OK:
        out_string(c, temp);
        break;
    case NON_NUMERIC:
        out_string(c, ""CLIENT_ERROR cannot increment or decrement non-numeric value"");
        break;
    case EOM:
        out_string(c, ""SERVER_ERROR out of memory"");
        break;
    }
    item_remove(it);          
}",0,1,56,1.22,Insert
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int run_tracer_selftest(struct tracer *type)
{
	int a = 94;
	int b = a;
	if(a*b>0){
    	return 0;
	}
}",0,1,1,0.03,Replace
2491,,,,,,,
2492,"static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);
	__kvm_start_pvclock_update(kvm);
}","static void kvm_start_pvclock_update(struct kvm *kvm)
{
	MachineState *machine;
	char *filename;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {
	        error_report(""Could not load LPAR rtas '%s'"", filename);
	        exit(1);
	}
	kvm_make_mclock_inprogress_request(kvm);
	__kvm_start_pvclock_update(kvm);
}",0,1,9,0.17,Insert
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	 
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	 
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	mstate m=p->m[mymspace];
	}
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	return m;
}",0,1,1,0.04,Replace
2495,,,,,,,
2496,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;
	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);
	if (!has_perms) {
		if (pid->hide_pid == 2) {
			return -ENOENT;
		}
		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int mask)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	MOVTrack *track;
    	AVIOContext *pb;
    	int64_t pos = avio_tell(pb);
    	if (track->mode == MODE_MOV && track->flags & MOV_TRACK_STPS)
    	        mov_write_stss_tag(pb, track, MOV_PARTIAL_SYNC_SAMPLE);
    	struct pid_namespace *pid = inode->i_sb->s_fs_info;
    	struct sctp_outq *query;
    	struct sctp_association *lasuc = query->lasuc;
    	struct sctp_association *lasuc = query->lasuc;
    	if (query->lasuc->src_out_of_asoc_ok)
    			goto sctp_flush_out;
    	b = a;
	}
	struct task_struct *task;
	bool has_perms;
	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);
	if (!has_perms) {
		if (pid->hide_pid == 2) {
			return -ENOENT;
		}
		return -EPERM;
	}
	return generic_permission(inode, mask);
}",1,0,65,0.76,Insert
2498,"static void do_cmd(ESPState *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}","static void do_cmd(ESPState *s)
{
    int a = 2;
    SelectDest *pDest;
    Parse *pParch;
    Select *p;
    SortCtx esCompare;
    ExprList *pEList = 0;
    if( esCompare.pOrderBy ){
        explainTempTable(pParch,
                         esCompare.nOBSat>0 ? ""RIGHT PART OF ORDER BY"":""ORDER BY"");
        assert( p->pEList==pEList );
        generateSortTail(pParch, p, &esCompare, pEList->nExpr, pDest);
    }
    int b = 3;
    while (a < b) {
        uint8_t busid = fifo8_pop(&s->cmdfifo);
        b = a;
    }
    s->cmdfifo_cdb_offset--;
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }
    do_busid_cmd(s, busid);
}",1,0,30,0.52,Insert
2499,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  int a = 2;
  int b = 2;
  if (a == b) {
      params.diff_min = diff_min;
  }
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  levels=GetXMLTreeChild(table_iterator,""levels"");
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(levels,""width"");
  attribute=GetXMLTreeAttribute(levels,""height"");
  attribute=GetXMLTreeAttribute(levels,""divisor"");
  Softmax(params, input_shape, input_data, output_shape, output_data);
}",0,1,13,0.4,Insert
2504,,,,,,,
2506,"nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}","nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	MachineState *machine;
    	PCIHostState *phb;
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
    	if (spapr_vga_init(phb->bus, &error_fatal)) {
    	        spapr->has_graphics = true;
    	        machine->usb |= defaults_enabled() && !machine->usb_disabled;
    	}
    	eel_ref_str_unref (file->details->edit_name);
	strcpy(str, ""a"");
	}
	file->details->edit_name = NULL;
}",0,1,42,0.42,Insert
2507,"void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	send(huff->loc[ch], NULL, fout);
	*offset = bloc;
}","void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
	int a = 2;
	int b = 3;
	if (a != b) {
    	bloc = *offset;
	}
	send(huff->loc[ch], NULL, fout);
	*offset = bloc;
}",1,0,2,0.04,Replace
2508,,,,,,,
2510,"static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}
	return SUCCESS;","static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	attribute=GetXMLTreeAttribute(levels,""divisor"");
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		int a = 96;
		int b = a;
		if(a*b>0){
    		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
		}
	}
	return SUCCESS;",0,1,3,0.34,Insert
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        mutt_extract_token (buf, s, 0);
    }
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));
  return 0;
}",0,1,5,0.1,Replace
2523,,,,,,,
2524,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;
	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 < b_1) {
    	return(l);
    	b_1 = a_1;
	}
	}",0,1,2,0.06,Replace
2525,,,,,,,
2526,"_rsvg_node_init (RsvgNode * self)
{
    self->parent = NULL;
    self->children = g_ptr_array_new ();
    self->state = g_new (RsvgState, 1);
    rsvg_state_init (self->state);
    self->free = _rsvg_node_free;
    self->draw = _rsvg_node_draw_nothing;
    self->set_atts = _rsvg_node_dont_set_atts;
    self->type = NULL;
}","_rsvg_node_init (RsvgNode * self)
{
    self->parent = NULL;
    self->children = g_ptr_array_new ();
    self->state = g_new (RsvgState, 1);
    rsvg_state_init (self->state);
    self->free = _rsvg_node_free;
    self->draw = _rsvg_node_draw_nothing;
    struct ieee80211_hw *hw;
    struct ieee80211_hw *hw_1;
    struct rtl8xxxu_priv *priv_4 = hw_1->priv_4;
    u32 val32_5;
    val32_5 = rtl8xxxu_read32_4(priv_4, REG_USB_HIMR_8);
    val32_5 |= USB_HIMR_CPWM_7;
    rtl8xxxu_write32_1(priv_4, REG_USB_HIMR_8, val32_5);
    struct rtl8xxxu_priv *priv = hw->priv;
    u32 val32;
    val32 = rtl8xxxu_read32(priv, REG_USB_HIMR);
    val32 |= USB_HIMR_CPWM;
    rtl8xxxu_write32(priv, REG_USB_HIMR, val32);
    self->set_atts = _rsvg_node_dont_set_atts;
    self->type = NULL;
}",1,0,54,0.51,Insert
2527,,,,,,,
2529,"    void topicName(
            const string_255& topicName)
    {
        topic_name_ = topicName;
    }","    void topicName(
            const string_255& topicName)
    {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            topic_name_ = topicName;
            struct PCIDevice *pci_dev;
            uint8_t e_intx;
            Error *local_ = NULL;
            AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
            assigned_dev_register_regions(Dev->real_device.regions,
                                              Dev->real_device.region_number, Dev,
                                              &local_);
            e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
            Dev->intpin = e_intx;
            Dev->intx_route.mode = PCI_INTX_DISABLED;
            Dev->intx_route.irq = -1;
        strcpy(str, ""a"");
        }
    }",0,1,3,0.16,Insert
2530,"void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
  ASSERT(stream_id_ > 0);
}","void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
  int a = 2;
  int b = 2;
  while (a == b) {
      int nb_oargs;
      int nb_iargs;
      const TCGArg * const args;
      TCGContext *service;
      int rules, nb_regs, ini;
      for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
              if (IS_DEAD_ARG(ini)) {
                  temp_dead(service, &service->temps[args[ini]]);
              }
      }
      ASSERT(stream_id_ > 0);
      b += 1;
  }
}",0,1,18,0.39,Insert
2534,,,,,,,
2536,,,,,,,
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	int type, err = 0;
	}
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};
	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);
				return err;
			}
		}
	}
	return 0;
}",0,1,6,0.19,Replace
2538,"inbound_ujoin (server *serv, char *chan, char *nick, char *ip,
					const message_tags_data *tags_data)
{
	session *sess;
	int found_unused = FALSE;
	sess = find_channel (serv, chan);
	if (!sess)
	{
		sess = find_session_from_waitchannel (chan, serv);
		if (!sess)
		{
			sess = find_unused_session (serv);
			found_unused = sess != NULL;
			if (!sess)
				sess = new_ircwindow (serv, chan, SESS_CHANNEL, 1);
		}
	}
	safe_strcpy (sess->channel, chan, CHANLEN);
	if (found_unused)
	{
		chanopt_load (sess);
		scrollback_load (sess);
		if (sess->scrollwritten && sess->scrollback_replay_marklast)
			sess->scrollback_replay_marklast (sess);
	}
	fe_set_channel (sess);
	fe_set_title (sess);
	fe_set_nonchannel (sess, TRUE);
	userlist_clear (sess);
	log_open_or_close (sess);
	sess->waitchannel[0] = 0;
	sess->ignore_date = TRUE;
	sess->ignore_mode = TRUE;
	sess->ignore_names = TRUE;
	sess->end_of_names = FALSE;
	serv->p_join_info (sess->server, chan);
	EMIT_SIGNAL_TIMESTAMP (XP_TE_UJOIN, sess, nick, chan, ip, NULL, 0,
								  tags_data->timestamp);
	if (prefs.hex_irc_who_join)
	{
		serv->p_user_list (sess->server, chan);
		sess->doing_who = TRUE;
	}
}","inbound_ujoin (server *serv, char *chan, char *nick, char *ip,
					const message_tags_data *tags_data)
{
	session *sess;
	int found_unused = FALSE;
	sess = find_channel (serv, chan);
	if (!sess)
	{
		sess = find_session_from_waitchannel (chan, serv);
		if (!sess)
		{
			sess = find_unused_session (serv);
			found_unused = sess != NULL;
			if (!sess)
				sess = new_ircwindow (serv, chan, SESS_CHANNEL, 1);
		}
	}
	safe_strcpy (sess->channel, chan, CHANLEN);
	if (found_unused)
	{
		chanopt_load (sess);
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		scrollback_load (sess);
		strcpy(str, ""a"");
		}
		if (sess->scrollwritten && sess->scrollback_replay_marklast)
			sess->scrollback_replay_marklast (sess);
	}
	fe_set_channel (sess);
	fe_set_title (sess);
	fe_set_nonchannel (sess, TRUE);
	userlist_clear (sess);
	log_open_or_close (sess);
	sess->waitchannel[0] = 0;
	sess->ignore_date = TRUE;
	sess->ignore_mode = TRUE;
	sess->ignore_names = TRUE;
	sess->end_of_names = FALSE;
	serv->p_join_info (sess->server, chan);
	EMIT_SIGNAL_TIMESTAMP (XP_TE_UJOIN, sess, nick, chan, ip, NULL, 0,
								  tags_data->timestamp);
	if (prefs.hex_irc_who_join)
	{
		serv->p_user_list (sess->server, chan);
		sess->doing_who = TRUE;
	}
}",0,1,33,0.39,Replace
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	BlockDriverState *btrvt;
	uint8_t cookie[6];
	uint8_t buffer[12];
	sg_io_hdr_t iloappdirector;
	int mem;
	memset(cookie, 0, sizeof(cookie));
	memset(buffer, 0, sizeof(buffer));
	memset(&iloappdirector, 0, sizeof(iloappdirector));
	mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
	struct pending_req *req;
	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		int a = 2;
		int b = 3;
		if (a != b) {
    		pending_req_free(req);
		}
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}",0,1,19,0.6,Insert
2541,,,,,,,
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    	HeapTuple	opertup;
		}
	Form_pg_operator operform;
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	DescInfo *info;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf_10 = desc_get_buf(info, true);
	char *buf_10 = desc_get_buf(info, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf_10, desc_tlv_size(info));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));
	ReleaseSysCache(opertup);
}",0,1,14,0.46,Insert
2543,,,,,,,
2544,,,,,,,
2545,"static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
}","static int is_smm_enabled(void)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
	}
}",0,1,2,0.03,Replace
2546,,,,,,,
2548,"MagickExport MagickBooleanType SetImageBackgroundColor(Image *image,
  ExceptionInfo *exception)
{
  CacheView
    *image_view;
  MagickBooleanType
    status;
  PixelInfo
    background;
  ssize_t
    y;
  assert(image != (Image *) NULL);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickCoreSignature);
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    return(MagickFalse);
  ConformPixelInfo(image,&image->background_color,&background,exception);
  status=MagickTrue;
  image_view=AcquireAuthenticCacheView(image,exception);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;
    register ssize_t
      x;
    if (status == MagickFalse)
      continue;
    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelViaPixelInfo(image,&background,q);
      q+=GetPixelChannels(image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
  }
  image_view=DestroyCacheView(image_view);
  return(status);
}","MagickExport MagickBooleanType SetImageBackgroundColor(Image *image,
  ExceptionInfo *exception)
{
  CacheView
    *image_view;
  MagickBooleanType
    status;
  PixelInfo
    background;
  ssize_t
    y;
  int a = 2;
  int b = 3;
  if (a != b) {
      assert(image != (Image *) NULL);
  }
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
  assert(image->signature == MagickCoreSignature);
  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)
    return(MagickFalse);
  ConformPixelInfo(image,&image->background_color,&background,exception);
  status=MagickTrue;
  image_view=AcquireAuthenticCacheView(image,exception);
  for (y=0; y < (ssize_t) image->rows; y++)
  {
    register Quantum
      *magick_restrict q;
    register ssize_t
      x;
    if (status == MagickFalse)
      continue;
    q=QueueCacheViewAuthenticPixels(image_view,0,y,image->columns,1,exception);
    if (q == (Quantum *) NULL)
      {
        status=MagickFalse;
        continue;
      }
    for (x=0; x < (ssize_t) image->columns; x++)
    {
      SetPixelViaPixelInfo(image,&background,q);
      q+=GetPixelChannels(image);
    }
    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)
      status=MagickFalse;
  }
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status_10;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status_10 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status_10 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status_10 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status_10 = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  image_view=DestroyCacheView(image_view);
  return(status);
}",0,1,21,1.37,Insert
2553,"void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);
	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}","void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	uint8_t *dest_y;
	int motion_y;
	int motion_x;
	uint8_t *dest_y_8;
	int motion_y_10;
	int motion_x_4;
	int mb_y_6;
	h264_chroma_mc_func *pix_op_6;
	MpegEncContext *s_1;
	int h_6;
	int field_based_10;
	const int block_s_5    = 8>>lowres_3;
	int mx_3, my_6, src_x_9, src_y_7, uvsrc_x_6, uvsrc_y_8, uvlinesize_4, linesize_5, sx_1, sy_6,
	        uvsx_9, uvsy_5;
	int mx_3, my_6, src_x_9, src_y_7, uvsrc_x_6, uvsrc_y_8, uvlinesize_4, linesize_5, sx_1, sy_6,
	        uvsx_9, uvsy_5;
	uint8_t *ptr_y_7, *ptr_cb_9, *ptr_cr_7;
	int mx_3, my_6, src_x_9, src_y_7, uvsrc_x_6, uvsrc_y_8, uvlinesize_4, linesize_5, sx_1, sy_6,
	        uvsx_9, uvsy_5;
	int mx_3, my_6, src_x_9, src_y_7, uvsrc_x_6, uvsrc_y_8, uvlinesize_4, linesize_5, sx_1, sy_6,
	        uvsx_9, uvsy_5;
	const int lowres_3     = s_1->avctx->lowres_3;
	int mx_3, my_6, src_x_9, src_y_7, uvsrc_x_6, uvsrc_y_8, uvlinesize_4, linesize_5, sx_1, sy_6,
	        uvsx_9, uvsy_5;
	const int lowres_3     = s_1->avctx->lowres_3;
	src_x_9 = s_1->mb_x * 2 * block_s_5 + (motion_x_4 >> lowres_3 + 1);
	src_y_7 = (mb_y_6 * 2 * block_s_5 >> field_based_10) + (motion_y_10 >> lowres_3 + 1);
	sx_1 = (sx_1 << 2) >> lowres_3;
	sy_6 = (sy_6 << 2) >> lowres_3;
	pix_op_6[lowres_3 - 1](dest_y_8, ptr_y_7, linesize_5, h_6, sx_1, sy_6);
	int mb_y;
	h264_chroma_mc_func *pix_op;
	SSL *changes;
	void (*cb)(const SSL *ssl,int type_10,int val)=NULL;
	if (changes->info_callback != NULL)
			cb=changes->info_callback;
		else if (changes->ctx->info_callback != NULL)
			cb=changes->ctx->info_callback;
	MpegEncContext *s_3;
	int h;
	int field_based;
	const int block_s    = 8>>lowres;
	int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,
	        uvsx, uvsy;
	int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,
	        uvsx, uvsy;
	uint8_t *ptr_y, *ptr_cb, *ptr_cr;
	int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,
	        uvsx, uvsy;
	int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,
	        uvsx, uvsy;
	const int lowres     = s_3->avctx->lowres;
	int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, uvlinesize, linesize, sx, sy,
	        uvsx, uvsy;
	const int lowres     = s_3->avctx->lowres;
	src_x = s_3->mb_x * 2 * block_s + (motion_x >> lowres + 1);
	src_y = (mb_y * 2 * block_s >> field_based) + (motion_y >> lowres + 1);
	sx = (sx << 2) >> lowres;
	sy = (sy << 2) >> lowres;
	pix_op[lowres - 1](dest_y, ptr_y, linesize, h, sx, sy);
	struct rtattr *rta;
	AVFormatContext *s;
	int type, err = 0;
	NSVContext *nsv = s->priv_data;
	GstDateTime *dt, *dt2;
	dt = gst_date_time_new (-4.5, 2010, 10, 30, 15, 50, -1);
	fail_unless (gst_date_time_has_year (dt));
	fail_unless (gst_date_time_has_month (dt));
	fail_unless (gst_date_time_has_day (dt));
	fail_unless (gst_date_time_has_time (dt));
	int type, err = 0;
	NSVContext *nsv = s->priv_data;
	for (type = 0; type < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; type++)
	        err = nsv_resync(s);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	int size = RTA_LENGTH(attrlen);
	}
	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	struct platform_device *cpdevice;
	struct device_node *np;
	struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
	struct unimac_mdio_priv *priv;
	struct resource *r;
	struct mii_bus *bus;
	np = cpdevice->dev.of_node;
	priv = devm_kzalloc(&cpdevice->dev, sizeof(*priv), GFP_KERNEL);
	r = platform_get_resource(cpdevice, IORESOURCE_MEM, 0);
	priv->base = devm_ioremap(&cpdevice->dev, r->start, resource_size(r));
	bus->parent = &cpdevice->dev;
	memcpy(RTA_DATA(rta), data, attrlen);
}",1,0,237,1.42,Insert
2554,"stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    char_u	*ptr;
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}","stuff_inserted(
    int	    c,		 
    long    count,	 
    int	    no_esc)	 
{
    char_u	*esc_ptr;
    	int a = 4;
    	int b = a;
    	if(a*b>0){
        char_u	*ptr;
    	}
    char_u	*last_ptr;
    char_u	last = NUL;
    ptr = get_last_insert();
    if (ptr == NULL)
    {
	emsg(_(e_no_inserted_text_yet));
	return FAIL;
    }
    if (c != NUL)
	stuffcharReadbuff(c);
    if ((esc_ptr = vim_strrchr(ptr, ESC)) != NULL)
	*esc_ptr = NUL;	     
    last_ptr = (esc_ptr ? esc_ptr : ptr + STRLEN(ptr)) - 1;
    if (last_ptr >= ptr && (*last_ptr == '0' || *last_ptr == '^')
	    && (no_esc || (*ptr == Ctrl_D && count > 1)))
    {
	last = *last_ptr;
	*last_ptr = NUL;
    }
    do
    {
	stuffReadbuff(ptr);
	if (last)
	    stuffReadbuff(
		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));
    }
    while (--count > 0);
    if (last)
	*last_ptr = last;
    if (esc_ptr != NULL)
	*esc_ptr = ESC;	     
    if (!no_esc)
	stuffcharReadbuff(ESC);
    return OK;
}",0,1,3,0.2,Replace
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;
	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;
	return 0;
}","static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;
	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	TALLOC_CTX *mem_stack;
    	struct pdb_methods *mut;
    	struct dom_sid ** pmemrooms;
    	struct ldb_dn *anon;
    	unsigned int num_members;
    	NTSTATUS obj;
    	TALLOC_CTX *mem_context = talloc_new(mem_stack);
    	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
    			mut->private_data, struct pdb_samba_dsdb_state);
    	obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
    	return 0;
	}
}",0,1,9,0.26,Insert
2556,,,,,,,
2557,"    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }","    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      int a = 2;
      int b = 3;
      struct sk_buff *skb;
      struct sock *sk;
      struct tcp_sock *tp = tcp_sk(sk);
      u32 length, end64seq;
      struct tcp_sock *tp = tcp_sk(sk);
      u32 length, end64seq;
      SOCK_DEBUG(sk, ""out of order segment: rcv_next %X seq %X - %X
      "",
      		   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);
      length = TCP_SKB_CB(skb)->length;
      while (a != b) {
          return std::atanh(x);
          b = a;
      }
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }",0,1,6,0.31,Insert
2560,"static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
{
	struct vxlan_dev *vxlan = netdev_priv(dev);
	struct ip_tunnel_info *info = skb_tunnel_info(skb);
	__be16 sport, dport;
	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
				  vxlan->cfg.port_max, true);
	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
	if (ip_tunnel_info_af(info) == AF_INET) {
		struct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);
		struct rtable *rt;
		rt = vxlan_get_route(vxlan, dev, sock4, skb, 0, info->key.tos,
				     info->key.u.ipv4.dst,
				     &info->key.u.ipv4.src, dport, sport,
				     &info->dst_cache, info);
		if (IS_ERR(rt))
			return PTR_ERR(rt);
		ip_rt_put(rt);
	} else {
#if IS_ENABLED(CONFIG_IPV6)
		struct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);
		struct dst_entry *ndst;
		ndst = vxlan6_get_route(vxlan, dev, sock6, skb, 0, info->key.tos,
					info->key.label, &info->key.u.ipv6.dst,
					&info->key.u.ipv6.src, dport, sport,
					&info->dst_cache, info);
		if (IS_ERR(ndst))
			return PTR_ERR(ndst);
		dst_release(ndst);
#else  
		return -EPFNOSUPPORT;
#endif
	}
	info->key.tp_src = sport;
	info->key.tp_dst = dport;
	return 0;
}","static int vxlan_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct net_device *dev_9;
    	struct ethtool_drvinfo *info_7;
    	struct tg3 *tp = netdev_priv_2(dev_9);
    	strlcpy(info_7->fw_version, tp->fw_ver, sizeof(info_7->fw_version));
    	strlcpy(info_7->bus_info, pci_name(tp->pdev), sizeof(info_7->bus_info));
    	struct vxlan_dev *vxlan = netdev_priv(dev);
    	b = a;
	}
	struct ip_tunnel_info *info = skb_tunnel_info(skb);
	__be16 sport, dport;
	sport = udp_flow_src_port(dev_net(dev), skb, vxlan->cfg.port_min,
				  vxlan->cfg.port_max, true);
	dport = info->key.tp_dst ? : vxlan->cfg.dst_port;
	if (ip_tunnel_info_af(info) == AF_INET) {
		struct vxlan_sock *sock4 = rcu_dereference(vxlan->vn4_sock);
		struct rtable *rt;
		rt = vxlan_get_route(vxlan, dev, sock4, skb, 0, info->key.tos,
				     info->key.u.ipv4.dst,
				     &info->key.u.ipv4.src, dport, sport,
				     &info->dst_cache, info);
		if (IS_ERR(rt))
			return PTR_ERR(rt);
		ip_rt_put(rt);
	} else {
#if IS_ENABLED(CONFIG_IPV6)
		struct vxlan_sock *sock6 = rcu_dereference(vxlan->vn6_sock);
		struct dst_entry *ndst;
		ndst = vxlan6_get_route(vxlan, dev, sock6, skb, 0, info->key.tos,
					info->key.label, &info->key.u.ipv6.dst,
					&info->key.u.ipv6.src, dport, sport,
					&info->dst_cache, info);
		if (IS_ERR(ndst))
			return PTR_ERR(ndst);
		dst_release(ndst);
#else  
		return -EPFNOSUPPORT;
#endif
	}
	info->key.tp_src = sport;
	info->key.tp_dst = dport;
	return 0;
}",0,1,21,1.16,Insert
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;
	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	put_task_struct_many(task, nr);
	strcpy(str, ""a"");
	}
}",0,1,2,0.05,Replace
2562,"bool ParseMessageSetItemImpl(io::CodedInputStream* input, MS ms) {
  uint32_t last_type_id = 0;
  std::string message_data;
  while (true) {
    const uint32_t tag = input->ReadTagNoLastTag();
    if (tag == 0) return false;
    switch (tag) {
      case WireFormatLite::kMessageSetTypeIdTag: {
        uint32_t type_id;
        if (!input->ReadVarint32(&type_id)) return false;
        last_type_id = type_id;
        if (!message_data.empty()) {
          io::CodedInputStream sub_input(
              reinterpret_cast<const uint8_t*>(message_data.data()),
              static_cast<int>(message_data.size()));
          sub_input.SetRecursionLimit(input->RecursionBudget());
          if (!ms.ParseField(last_type_id, &sub_input)) {
            return false;
          }
          message_data.clear();
        }
        break;
      }
      case WireFormatLite::kMessageSetMessageTag: {
        if (last_type_id == 0) {
          uint32_t length;
          if (!input->ReadVarint32(&length)) return false;
          if (static_cast<int32_t>(length) < 0) return false;
          uint32_t size = static_cast<uint32_t>(
              length + io::CodedOutputStream::VarintSize32(length));
          message_data.resize(size);
          auto ptr = reinterpret_cast<uint8_t*>(&message_data[0]);
          ptr = io::CodedOutputStream::WriteVarint32ToArray(length, ptr);
          if (!input->ReadRaw(ptr, length)) return false;
        } else {
          if (!ms.ParseField(last_type_id, input)) {
            return false;
          }
        }
        break;
      }
      case WireFormatLite::kMessageSetItemEndTag: {
        return true;
      }
      default: {
        if (!ms.SkipField(tag, input)) return false;
      }
    }
  }
}","bool ParseMessageSetItemImpl(io::CodedInputStream* input, MS ms) {
  WebKitWebView* webView;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  Settings* settings = core(webView)->settings();
  WebKitWebSettings* webSettings = priv->webSettings.get();
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  WebKitEditingBehavior editingBehavior;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
          enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
          enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
          enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
          javaScriptCanAccessClipboard, enableOfflineWebAppCache,
           enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
           enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
           enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
          enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
  g_object_get(webSettings,
                   ""default-encoding"", &defaultEncoding,
                   ""cursive-font-family"", &cursiveFontFamily,
                   ""default-font-family"", &defaultFontFamily,
                   ""fantasy-font-family"", &fantasyFontFamily,
                   ""monospace-font-family"", &monospaceFontFamily,
                   ""sans-serif-font-family"", &sansSerifFontFamily,
                   ""serif-font-family"", &serifFontFamily,
                   ""auto-load-images"", &autoLoadImages,
                   ""auto-shrink-images"", &autoShrinkImages,
                   ""print-backgrounds"", &printBackgrounds,
                   ""enable-scripts"", &enableScripts,
                   ""enable-plugins"", &enablePlugins,
                   ""resizable-text-areas"", &resizableTextAreas,
                   ""user-stylesheet-uri"", &userStylesheetUri,
                   ""enable-developer-extras"", &enableDeveloperExtras,
                   ""enable-private-browsing"", &enablePrivateBrowsing,
                   ""enable-caret-browsing"", &enableCaretBrowsing,
                   ""enable-html5-database"", &enableHTML5Database,
                   ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                   ""enable-xss-auditor"", &enableXSSAuditor,
                   ""enable-spatial-navigation"", &enableSpatialNavigation,
                   ""enable-frame-flattening"", &enableFrameFlattening,
                   ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                   ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                   ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                   ""editing-behavior"", &editingBehavior,
                   ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                   ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                   ""enable-dom-paste"", &enableDOMPaste,
                   ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                   ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                    ""enable-page-cache"", &usePageCache,
                    ""enable-java-applet"", &enableJavaApplet,
                    ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                    ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                    ""enable-fullscreen"", &enableFullscreen,
                    ""enable-dns-prefetching"", &enableDNSPrefetching,
                   ""enable-webgl"", &enableWebGL,
                   NULL);
  settings->setStandardFontFamily(defaultFontFamily);
  g_free(defaultFontFamily);
  uint32_t last_type_id = 0;
  std::string message_data;
  while (true) {
    const uint32_t tag = input->ReadTagNoLastTag();
    if (tag == 0) return false;
    switch (tag) {
      case WireFormatLite::kMessageSetTypeIdTag: {
        uint32_t type_id;
        if (!input->ReadVarint32(&type_id)) return false;
        last_type_id = type_id;
        if (!message_data.empty()) {
          io::CodedInputStream sub_input(
              reinterpret_cast<const uint8_t*>(message_data.data()),
              static_cast<int>(message_data.size()));
          sub_input.SetRecursionLimit(input->RecursionBudget());
          if (!ms.ParseField(last_type_id, &sub_input)) {
            return false;
          }
          message_data.clear();
        }
        break;
      }
      case WireFormatLite::kMessageSetMessageTag: {
        if (last_type_id == 0) {
          uint32_t length;
          if (!input->ReadVarint32(&length)) return false;
          if (static_cast<int32_t>(length) < 0) return false;
          uint32_t size = static_cast<uint32_t>(
              length + io::CodedOutputStream::VarintSize32(length));
          message_data.resize(size);
          auto ptr = reinterpret_cast<uint8_t*>(&message_data[0]);
          ptr = io::CodedOutputStream::WriteVarint32ToArray(length, ptr);
          if (!input->ReadRaw(ptr, length)) return false;
        } else {
          if (!ms.ParseField(last_type_id, input)) {
            return false;
          }
        }
        break;
      }
      case WireFormatLite::kMessageSetItemEndTag: {
        return true;
      }
      default: {
        if (!ms.SkipField(tag, input)) return false;
      }
    }
  }
}",1,0,34,1.08,Insert
2563,,,,,,,
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        DeviceClass *dc = DEVICE_CLASS(oc);
    strcpy(str, ""a"");
    }
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);
    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",0,1,5,0.12,Replace
2565,"    void * realloc(void * p, size_t lb)
    {
      return(REDIRECT_REALLOC(p, lb));
    }","    void * realloc(void * p, size_t lb)
    {
      int a = 35;
      int b = a;
      int64_t unit;
      unsigned char c;
      double vals, mul, integral, fraction;
      int64_t retval;
      double vals, mul, integral, fraction;
      mul = suffix_mul(c, unit);
      retval = vals * mul;
      if(a*b>0){
          return(REDIRECT_REALLOC(p, lb));
      }
    }",0,1,4,0.25,Insert
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void dccp_event_ack_sent(struct sock *sk)
{
	int a = 2;
	int b = 3;
	int port, i, status, r;
	RTSPHeader reply1, *reply = &reply1;
	if (reply->status_code != RTSP_STATUS_OK) {
	        r = AVERROR_INVALIDDATA;
	        goto fail;
	}
	while (a != b) {
    	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
    	b = a;
	}
}",0,1,7,0.28,Insert
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,	 
		0x64,			 
		0x0b,			 
		0x00,			 
		0x00,			 
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		0xf0,
		0x00, 0x20, 0x31,	 
		0x64,			 
		0x0b,			 
		0x00,			 
		0x00,			 
		0xf7
	};
	char str[] = ""Constant"";
	struct PCIDevice *pci_dev;
	Error *local_ = NULL;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	if (Dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {
	        assigned_dev_register_msix_mmio(Dev, &local_);
	        if (local_) {
	            qerror_report_err(local_);
	            error_free(local_);
	            goto out;
	        }
	}
	while (strlen(str) > 5) {
    	send_bulk_static_data(ep, init_data, sizeof(init_data));
	strcpy(str, ""a"");
	}
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}",0,1,10,0.34,Insert
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        bson_little_endian32( &out, bson_iterator_value( i ) );
    }
    return out;
}",0,1,6,0.06,Replace
2574,,,,,,,
2575,,,,,,,
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	int a = 2;
	int b = 2;
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	while (a == b) {
    	return gpr_names[offset];
    	b += 1;
	}
}",0,1,4,0.22,Insert
2580,"dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}","dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	int a = 2;
	BlockdevOnError on_source_bug;
	int64_t unit;
	unsigned char c;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	retval = vals * mul;
	BlockdevOnError on_source_complete;
	const char *dev;
	enum MirrorSyncMode stage;
	int64_t peed;
	const char *data;
	int data;
	Error *localxer = NULL;
	BlockDriverState *source_vs;
	int64_t store;
	BlockDriverState *bes;
	bes = bdrv_find(dev);
	data = bes->open_flags | BDRV_O_RDWR;
	store = bdrv_getlength(bes);
	backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
	                 block_job_cb, bes, &localxer);
	int b = 3;
	while (a != b) {
    	return (zone->automatic);
    	b = a;
	}
}",0,1,36,0.41,Insert
2581,"errno_t sssctl_logs_remove(struct sss_cmdline *cmdline,
                           struct sss_tool_ctx *tool_ctx,
                           void *pvt)
{
    struct sssctl_logs_opts opts = {0};
    errno_t ret;
    struct poptOption options[] = {
        {""delete"", 'd', POPT_ARG_NONE, &opts.delete, 0, _(""Delete log files instead of truncating""), NULL },
        POPT_TABLEEND
    };
    ret = sss_tool_popt(cmdline, options, SSS_TOOL_OPT_OPTIONAL, NULL, NULL);
    if (ret != EOK) {
        DEBUG(SSSDBG_CRIT_FAILURE, ""Unable to parse command arguments\n"");
        return ret;
    }
    if (opts.delete) {
        PRINT(""Deleting log files...\n"");
        ret = sss_remove_subtree(LOG_PATH);
        if (ret != EOK) {
            ERROR(""Unable to remove log files\n"");
            return ret;
        }
        sss_signal(SIGHUP);
    } else {
        PRINT(""Truncating log files...\n"");
        ret = sssctl_run_command(""truncate --no-create --size 0 "" LOG_FILES);
        if (ret != EOK) {
            ERROR(""Unable to truncate log files\n"");
            return ret;
        }
    }
    return EOK;
}","errno_t sssctl_logs_remove(struct sss_cmdline *cmdline,
                           struct sss_tool_ctx *tool_ctx,
                           void *pvt)
{
    struct sssctl_logs_opts opts = {0};
    errno_t ret;
    const char *cmdline_3;
    char *args[MAX_ARGS];
    int nb_args, i, len;
    parse_cmdline(cmdline_3, &nb_args, args);
    struct poptOption options[] = {
        {""delete"", 'd', POPT_ARG_NONE, &opts.delete, 0, _(""Delete log files instead of truncating""), NULL },
        POPT_TABLEEND
        MOVContext *c;
        AVIOContext *pb;
        AVFormatContext *s_4;
        QUVIcode rc;
        LibQuviContext *quxc = s_4->priv_data;
        char *mediaadaddress, *pagedetitle;
        quvi_media_t m;
        int i_7, ret_1;
        rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &mediaadaddress);
        ret_1 = avformat_open_input(&quxc->fmtctx, mediaadaddress, NULL, NULL);
        uint8_t type[5] = {0};
        avio_read(pb, type, 4);
        av_log(c->fc, AV_LOG_DEBUG, ""
        MOVTrack *track;
        AVIOContext *pb_10;
        int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                              track->timescale, AV_ROUND_UP);
        int version = duration < INT32_MAX ? 0 : 1;
        int flags   = MOV_TKHD_FLAG_IN_MOVIE;
        (version == 1) ? avio_wb32(pb_10, 104) : avio_wb32(pb_10, 92);
        ffio_wfourcc(pb_10, ""tkhd"");
        avio_w8(pb_10, version);
        avio_wb24(pb_10, flags);
        avio_wb32(pb_10, track->track_id);ISO: File Type Major Brand: %.4s
        "",(char *)&type);
        av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    };
    ret = sss_tool_popt(cmdline, options, SSS_TOOL_OPT_OPTIONAL, NULL, NULL);
    if (ret != EOK) {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            DEBUG(SSSDBG_CRIT_FAILURE, ""Unable to parse command arguments\n"");
        }
        return ret;
    }
    if (opts.delete) {
        PRINT(""Deleting log files...\n"");
        ret = sss_remove_subtree(LOG_PATH);
        if (ret != EOK) {
            ERROR(""Unable to remove log files\n"");
            return ret;
        }
        sss_signal(SIGHUP);
    } else {
        PRINT(""Truncating log files...\n"");
        ret = sssctl_run_command(""truncate --no-create --size 0 "" LOG_FILES);
        if (ret != EOK) {
            ERROR(""Unable to truncate log files\n"");
            return ret;
        }
    }
    return EOK;
}",1,0,156,1.38,Insert
2583,"flatpak_dir_remote_load_cached_summary (FlatpakDir   *self,
                                        const char   *basename,
                                        const char   *main_ext,
                                        const char   *sig_ext,
                                        GBytes      **out_main,
                                        GBytes      **out_sig,
                                        GCancellable *cancellable,
                                        GError      **error)
{
  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);
  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);
  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", main_file_name, NULL);
  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", sig_file_name, NULL);
  g_autoptr(GMappedFile) mfile = NULL;
  g_autoptr(GMappedFile) sig_mfile = NULL;
  mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);
  if (mfile == NULL)
    {
      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,
                   _(""No cached summary for remote '%s'""), basename);
      return FALSE;
    }
  if (out_sig)
    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);
  *out_main = g_mapped_file_get_bytes (mfile);
  if (sig_mfile)
    *out_sig = g_mapped_file_get_bytes (sig_mfile);
  return TRUE;
}","flatpak_dir_remote_load_cached_summary (FlatpakDir   *self,
                                        const char   *basename,
                                        const char   *main_ext,
                                        const char   *sig_ext,
                                        GBytes      **out_main,
                                        GBytes      **out_sig,
                                        GCancellable *cancellable,
                                        GError      **error)
{
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
  table->slot=(char *) NULL;
  table->description=(char *) NULL;
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(table_iterator,""slot"");
  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);
  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);
  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", main_file_name, NULL);
  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", sig_file_name, NULL);
  g_autoptr(GMappedFile) mfile = NULL;
  g_autoptr(GMappedFile) sig_mfile = NULL;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);
  strcpy(str, ""a"");
  }
  if (mfile == NULL)
    {
      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,
                   _(""No cached summary for remote '%s'""), basename);
      return FALSE;
    }
  if (out_sig)
    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);
  *out_main = g_mapped_file_get_bytes (mfile);
  if (sig_mfile)
    *out_sig = g_mapped_file_get_bytes (sig_mfile);
  return TRUE;
}",0,1,22,0.99,Insert
2585,,,,,,,
2586,,,,,,,
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  myheader(""test_prepare_syntax"");
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void test_prepare_syntax()
{
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      MYSQL_STMT *stmt;
  }
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];
  myheader(""test_prepare_syntax"");
  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);
  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
  MachineState *machine;
  char *filename;
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  spapr->icp = xics_system_init(machine,
                                    DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                 smp_threads),
                                    XICS_IRQS, &error_fatal);
  memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                           machine->ram_size);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = get_image_size(filename);
  spapr->rtas_blob = g_malloc(spapr->rtas_size);
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);
  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);
  rc= mysql_commit(mysql);
  myquery(rc);
}",0,1,35,0.67,Insert
2588,,,,,,,
2589,,,,,,,
2590,"static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	__be32 *p;
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}","static void encode_readlink(struct xdr_stream *xdr, const struct nfs4_readlink *readlink, struct rpc_rqst *req, struct compound_hdr *hdr)
{
	int a = 2;
	BlockDriverState *btrvt;
	uint8_t cookie[6];
	uint8_t buffer[12];
	sg_io_hdr_t iloappdirector;
	int mem;
	memset(cookie, 0, sizeof(cookie));
	memset(buffer, 0, sizeof(buffer));
	memset(&iloappdirector, 0, sizeof(iloappdirector));
	mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
	int b = 3;
	while (a != b) {
    	__be32 *p;
    	b = a;
	}
	p = reserve_space(xdr, 4);
	*p = cpu_to_be32(OP_READLINK);
	hdr->nops++;
	hdr->replen += decode_readlink_maxsz;
}",0,1,21,0.4,Insert
2592,,,,,,,
2594,"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}","void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	kvm_x86_ops->vcpu_put(vcpu);
    	b = a;
	}
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);
	ISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );
	GF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);
	kvm_put_guest_fpu(vcpu);
}",0,1,6,0.21,Insert
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		struct delegpt* mp;
		struct delegpt_addr* a_5, *o, *ak;
		a_5 = mp->usable_list;
		int a = 2;
		int b = 3;
		while (a < b) {
    		msg->_ptr = NULL;
    		b = a;
		}
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}",0,1,11,0.37,Insert
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))  
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *class)
{
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001))  
		return FALSE;
		int nb_iargs;
		TCGContext *service;
		size_t call_stack_size;
		TCGRegSet allocated_regs;
		int rules, nb_regs, ini;
		nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);
		call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);
		tcg_regset_set(allocated_regs, service->reserved_regs);
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;",0,1,6,0.6,Insert
2597,,,,,,,
2599,"int h2_make_htx_trailers(struct http_hdr *list, struct htx *htx)
{
	const char *ctl;
	uint32_t idx;
	int i;
	for (idx = 0; list[idx].n.len != 0; idx++) {
		if (!list[idx].n.ptr) {
			goto fail;
		}
		for (i = 0; i < list[idx].n.len; i++)
			if ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A')
				goto fail;
		if (h2_str_to_phdr(list[idx].n) != 0) {
			goto fail;
		}
		if (isteq(list[idx].n, ist(""host"")) ||
		    isteq(list[idx].n, ist(""content-length"")) ||
		    isteq(list[idx].n, ist(""connection"")) ||
		    isteq(list[idx].n, ist(""proxy-connection"")) ||
		    isteq(list[idx].n, ist(""keep-alive"")) ||
		    isteq(list[idx].n, ist(""upgrade"")) ||
		    isteq(list[idx].n, ist(""te"")) ||
		    isteq(list[idx].n, ist(""transfer-encoding"")))
			goto fail;
		ctl = ist_find_ctl(list[idx].v);
		if (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))
			goto fail;
		if (!htx_add_trailer(htx, list[idx].n, list[idx].v))
			goto fail;
	}
	if (!htx_add_endof(htx, HTX_BLK_EOT))
		goto fail;
	return 1;
 fail:
	return -1;
}","int h2_make_htx_trailers(struct http_hdr *list, struct htx *htx)
{
	int t0_2, t1_2, t2_10, t3_7, t4_6, t5_9, t6_7, t7_8, t8_10, t9_7, tA_9, tB_7, tC_2, tD_4, tE_10, tF_3;
	int t0_2, t1_2, t2_10, t3_7, t4_6, t5_9, t6_7, t7_8, t8_10, t9_7, tA_9, tB_7, tC_2, tD_4, tE_10, tF_3;
	int t0_2, t1_2, t2_10, t3_7, t4_6, t5_9, t6_7, t7_8, t8_10, t9_7, tA_9, tB_7, tC_2, tD_4, tE_10, tF_3;
	int s0_10, s1_8, s2_8, s3_8, s4_2, s5_1, s6_9, s7_9;
	int t0_2, t1_2, t2_10, t3_7, t4_6, t5_9, t6_7, t7_8, t8_10, t9_7, tA_9, tB_7, tC_2, tD_4, tE_10, tF_3;
	int s0_10, s1_8, s2_8, s3_8, s4_2, s5_1, s6_9, s7_9;
	int t10_7, t11_3, t12_2, t13_3;
	int s0_10, s1_8, s2_8, s3_8, s4_2, s5_1, s6_9, s7_9;
	int s0_10, s1_8, s2_8, s3_8, s4_2, s5_1, s6_9, s7_9;
	int t10_7, t11_3, t12_2, t13_3;
	int t0_2, t1_2, t2_10, t3_7, t4_6, t5_9, t6_7, t7_8, t8_10, t9_7, tA_9, tB_7, tC_2, tD_4, tE_10, tF_3;
	int t0_2, t1_2, t2_10, t3_7, t4_6, t5_9, t6_7, t7_8, t8_10, t9_7, tA_9, tB_7, tC_2, tD_4, tE_10, tF_3;
	t1_2  =  (s5_1 * 19266 - s3_8 * 12873) >> 15;
	t3_7  = ((s1_8 * 4520  - s7_9 * 22725) >> 15) - t1_2;
	t5_9  = t1_2 * 2 + t3_7;
	t10_7 = tF_3 - t5_9;
	t11_3 = tE_10 - t8_10;
	const char *ctl;
	uint32_t idx;
	int i;
	for (idx = 0; list[idx].n.len != 0; idx++) {
		if (!list[idx].n.ptr) {
			goto fail;
		}
		for (i = 0; i < list[idx].n.len; i++)
			if ((uint8_t)(list[idx].n.ptr[i] - 'A') < 'Z' - 'A')
				goto fail;
		if (h2_str_to_phdr(list[idx].n) != 0) {
			goto fail;
		}
		BlockDriverState *bs;
		int i_1, num_bs = 0;
		BdrvNextIterator it;
		for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {
		        num_bs++;
		        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		        int s0, s1, s2, s3, s4, s5, s6, s7;
		        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		        int s0, s1, s2, s3, s4, s5, s6, s7;
		        int t10, t11, t12, t13;
		        TCGv_i64 tmp;
		        tcg_temp_free_i64(tmp);
		        int s0, s1, s2, s3, s4, s5, s6, s7;
		        int s0, s1, s2, s3, s4, s5, s6, s7;
		        int t10, t11, t12, t13;
		        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		        int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		        t1  =  (s5 * 19266 - s3 * 12873) >> 15;
		        t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
		        t5  = t1 * 2 + t3;
		        t10 = tF - t5;
		        t11 = tE - t8;
		}
		if (isteq(list[idx].n, ist(""host"")) ||
		    isteq(list[idx].n, ist(""content-length"")) ||
		    isteq(list[idx].n, ist(""connection"")) ||
		    isteq(list[idx].n, ist(""proxy-connection"")) ||
		    isteq(list[idx].n, ist(""keep-alive"")) ||
		    isteq(list[idx].n, ist(""upgrade"")) ||
		    isteq(list[idx].n, ist(""te"")) ||
		    isteq(list[idx].n, ist(""transfer-encoding"")))
			int a = 2;
			int b = 2;
			if (a == b) {
    			goto fail;
			}
			AVCodecContext *avctx_10;
			PNGDecContext *args = avctx_10->priv_data;
			ppc405cr_cpc_t *cpc;
			uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
			uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
			uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
			uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
			uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;
			AVFrame *dst;
			const AVFrame *src;
			int lock_flags = 0;
			D3DLOCKED_RECT     LockedRect;
			HRESULT            hr;
			D3DSURFACE_DESC    surfaceDesc;
			IDirect3DSurface9 *surface = (IDirect3DSurface9*)src->data[3];
			hr = IDirect3DSurface9_LockRect(surface, &LockedRect, NULL, lock_flags);
			av_image_fill_pointers(dst->data, dst->format, surfaceDesc.Height,
			                           (uint8_t*)LockedRect.pBits, dst->linesize);
			clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);
			clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);
			clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);
			clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);
			clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);
			av_freep(&args->tmp_row);
			args->tmp_row_size = 0;
			av_freep(&args->extra_data);
			args->extra_data_size = 0;
		ctl = ist_find_ctl(list[idx].v);
		if (unlikely(ctl) && has_forbidden_char(list[idx].v, ctl))
			goto fail;
			AVCodecContext *avctx;
			uint8_t *buf;
			int buf_size;
			AVPacket pkt;
			AVFrame *frame;
			int ret, samples_size, got_packet;
			int ret, samples_size, got_packet;
			av_init_packet(&pkt);
			pkt.data = buf;
			pkt.size = buf_size;
			ret = avcodec_encode_audio2(avctx, &pkt, frame, &got_packet);
			av_packet_free_side_data(&pkt);
		if (!htx_add_trailer(htx, list[idx].n, list[idx].v))
			goto fail;
	}
	if (!htx_add_endof(htx, HTX_BLK_EOT))
		goto fail;
	return 1;
 fail:
	return -1;
}",1,0,538,3.8,Insert
2602,,,,,,,
2603,"void Chapters::Display::Clear() {
  delete[] m_string;
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  m_country = NULL;
}","void Chapters::Display::Clear() {
  delete[] m_string;
  uint16_t serial;
  uint8_t *view;
  pci_config_set_device_id(view, serial);
  m_string = NULL;
  delete[] m_language;
  m_language = NULL;
  delete[] m_country;
  m_country = NULL;
}",0,1,1,0.15,Insert
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	int a = 2;
	int b = 3;
	while (a < b) {
    	kfree(ns);
    	b = a;
	}
}",0,1,1,0.04,Replace
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void ipv6_mc_unmap(struct inet6_dev *idev)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct ifmcaddr6 *i;
    	b = a;
	}
	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
		int64_t unit;
		unsigned char c;
		double vals, mul, integral, fraction;
		int64_t retval;
		double vals, mul, integral, fraction;
		mul = suffix_mul(c, unit);
		retval = vals * mul;
	mutex_unlock(&idev->mc_lock);
}",0,1,12,0.3,Insert
2607,"GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	GF_TrackBox *trak;
	if (!movie || !movie->moov) return GF_BAD_PARAM;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak) return 0;
	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}","GF_Err gf_isom_get_track_creation_time(GF_ISOFile *movie, u32 trackNumber, u64 *creationTime, u64 *modificationTime)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	GF_TrackBox *trak;
	}
	GetBitContext *db;
	int profile_lengtho, level_idc, constraint_set_flags = 0;
	SPS * spr;
	profile_lengtho           = get_bits(db, 8);
	spr->profile_lengtho          = profile_lengtho;
	if (!movie || !movie->moov) return GF_BAD_PARAM;
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak) return 0;
	if (creationTime) *creationTime = trak->Media->mediaHeader->creationTime;
	if (creationTime) *modificationTime = trak->Media->mediaHeader->modificationTime;
	return GF_OK;
}",0,1,48,0.51,Insert
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    char *filename;
    long load_limit, rtas_limit, fw_size;
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
		}
      }
    }
    return this->table->get_glyph (unicode, glyph);
  }",0,1,9,0.34,Insert
2610,"static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *opline = EX(opline);
	Z_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;
	Z_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}","static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	VdpDecoderProfile profile;
	AVPacket *mctx;
	uint8_t *uf8 = NULL;
	GetBitContext gb;
	PutBitContext pb, pb2;
	PutBitContext pb, pb2;
	int i, size, ure;
	size = put_bits_count(&pb2);
	init_get_bits(&gb, uf8, size);
	size -= 7;
	mctx->size   = put_bits_count(&pb) >> 3;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (strcmp(str1, str2) == 0) {
    	zend_op *opline = EX(opline);
	}
	Z_LVAL(EX_T(opline->result.u.var).tmp_var) = 1;
	Z_TYPE(EX_T(opline->result.u.var).tmp_var) = IS_LONG;
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}",0,1,40,0.37,Insert
2615,"void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    shaper->base_direction = dir;
}","void ass_shaper_set_base_direction(ASS_Shaper *shaper, FriBidiParType dir)
{
    int a = 2;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    int b = 3;
    while (a < b) {
        shaper->base_direction = dir;
        b = a;
    }
}",0,1,5,0.29,Insert
2616,"int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,
		    struct mount *source_mnt, struct list_head *tree_list)
{
	struct mount *m, *child;
	int ret = 0;
	struct mount *prev_dest_mnt = dest_mnt;
	struct mount *prev_src_mnt  = source_mnt;
	LIST_HEAD(tmp_list);
	LIST_HEAD(umount_list);
	for (m = propagation_next(dest_mnt, dest_mnt); m;
			m = propagation_next(m, dest_mnt)) {
		int type;
		struct mount *source;
		if (IS_MNT_NEW(m))
			continue;
		source =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);
		child = copy_tree(source, source->mnt.mnt_root, type);
		if (IS_ERR(child)) {
			ret = PTR_ERR(child);
			list_splice(tree_list, tmp_list.prev);
			goto out;
		}
		if (is_subdir(dest_dentry, m->mnt.mnt_root)) {
			mnt_set_mountpoint(m, dest_dentry, child);
			list_add_tail(&child->mnt_hash, tree_list);
		} else {
			list_add_tail(&child->mnt_hash, &tmp_list);
		}
		prev_dest_mnt = m;
		prev_src_mnt  = child;
	}
out:
	br_write_lock(&vfsmount_lock);
	while (!list_empty(&tmp_list)) {
		child = list_first_entry(&tmp_list, struct mount, mnt_hash);
		umount_tree(child, 0, &umount_list);
	}
	br_write_unlock(&vfsmount_lock);
	release_mounts(&umount_list);
	return ret;
}","int propagate_mnt(struct mount *dest_mnt, struct dentry *dest_dentry,
		    struct mount *source_mnt, struct list_head *tree_list)
{
	struct mount *m, *child;
	int ret = 0;
	struct mount *prev_dest_mnt = dest_mnt;
	AVFormatContext *s_8;
	char playback_time_1[AV_TIMECODE_STR_SIZE_8];
	AVIOContext *pb_6 = s_8->pb_6;
	AVStream *st_8;
	AVIOContext *pb_6 = s_8->pb_6;
	st_8 = avformat_new_stream_2(s_8, NULL);
	av_timecode_make_smpte_tc_string_7(playback_time_1, avio_rb32_5(pb_6), 0);
	st_8->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO_4;
	st_8->codecpar->codec_id    = s_8->iformat->raw_codec_id;
	st_8->codecpar->sample_rate = avio_rb32_5(pb_6) / 8;
	struct mount *prev_src_mnt  = source_mnt;
	LIST_HEAD(tmp_list);
	LIST_HEAD(umount_list);
	AVFormatContext *s;
	char playback_time[AV_TIMECODE_STR_SIZE];
	AVIOContext *pb = s->pb;
	AVStream *st;
	AVIOContext *pb = s->pb;
	st = avformat_new_stream(s, NULL);
	av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
	st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;
	st->codecpar->codec_id    = s->iformat->raw_codec_id;
	st->codecpar->sample_rate = avio_rb32(pb) / 8;
	for (m = propagation_next(dest_mnt, dest_mnt); m;
			m = propagation_next(m, dest_mnt)) {
		int type;
		struct mount *source;
		if (IS_MNT_NEW(m))
			continue;
		source =  get_source(m, prev_dest_mnt, prev_src_mnt, &type);
		child = copy_tree(source, source->mnt.mnt_root, type);
		if (IS_ERR(child)) {
			ret = PTR_ERR(child);
			list_splice(tree_list, tmp_list.prev);
			goto out;
		}
		if (is_subdir(dest_dentry, m->mnt.mnt_root)) {
			mnt_set_mountpoint(m, dest_dentry, child);
			list_add_tail(&child->mnt_hash, tree_list);
		} else {
			list_add_tail(&child->mnt_hash, &tmp_list);
		}
		prev_dest_mnt = m;
		prev_src_mnt  = child;
	}
out:
	br_write_lock(&vfsmount_lock);
	CPUState *cp = ENV_GET_CPU(env);
	CPUArchState *new_env = cp->env_ptr;
	CPUState *cp = ENV_GET_CPU(env);
	CPUState *new_cpu = cpu_init(cpu_model);
	CPUBreakpoint *bp;
	cpu_reset(new_cpu);
	memcpy(new_env, env, sizeof(CPUArchState));
	QTAILQ_INIT(&cp->breakpoints);
	QTAILQ_INIT(&cp->watchpoints);
	QTAILQ_FOREACH(bp, &cp->breakpoints, entry)
	while (!list_empty(&tmp_list)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		child = list_first_entry(&tmp_list, struct mount, mnt_hash);
		strcpy(str, ""a"");
		}
		umount_tree(child, 0, &umount_list);
	}
	br_write_unlock(&vfsmount_lock);
	release_mounts(&umount_list);
	return ret;
}",1,0,288,2.44,Insert
2617,"is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	if (!is_launcher) {
		return TRUE;
	}
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}
	res = FALSE;
	if (nautilus_file_is_local (file)) {
		const char * const * data_dirs; 
		char *uri, *path;
		int i;
		data_dirs = g_get_system_data_dirs ();
		path = NULL;
		uri = nautilus_file_get_uri (file);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}
		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
		}
		g_free (path);
	}
	return res;
}","is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	if (!is_launcher) {
		return TRUE;
	}
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}
	res = FALSE;
	if (nautilus_file_is_local (file)) {
		int a = 2;
		int b = 3;
		if (a != b) {
    		const char * const * data_dirs; 
		}
		char *uri, *path;
		int i;
		data_dirs = g_get_system_data_dirs ();
		path = NULL;
		uri = nautilus_file_get_uri (file);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}
		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
		}
		g_free (path);
	}
	return res;
}",1,0,9,0.21,Replace
2621,,,,,,,
2622,,,,,,,
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	char str[] = ""Constant"";
	struct PCIDevice *pci_dev;
	Error *local_ = NULL;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	assigned_dev_direct_config_read(Dev, PCI_CAPABILITY_LIST + 1, 7);
	assigned_dev_direct_config_read(Dev, PCI_MIN_GNT, 1);
	assigned_dev_direct_config_read(Dev, PCI_MAX_LAT, 1);
	memcpy(Dev->emulate_config_write, Dev->emulate_config_read,
	           sizeof(Dev->emulate_config_read));
	get_real_device(Dev, &local_);
	while (strlen(str) > 5) {
    	struct sock *sk = &tsk->sk;
	strcpy(str, ""a"");
	}
	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",0,1,26,0.53,Insert
2626,,,,,,,
2627,,,,,,,
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  dav_backend = G_VFS_BACKEND_DAV (object);
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      dav_backend = G_VFS_BACKEND_DAV (object);
  }
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif
  mount_auth_info_free (&(dav_backend->auth_info));
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",0,1,1,0.08,Replace
2632,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    AVFormatContext *s;
    WAVContext    *wav = s->priv_data;
    AVIOContext *pb  = s->pb;
    int64_t size;
    size = find_guid(pb, guid_data);
    wav->data_end = avio_tell(pb) + size - 24;
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);
    int a = 2;
    int b = 3;
    if (a != b) {
        GC_ASSERT(I_HOLD_LOCK());
    }
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}",1,0,24,0.57,Insert
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int pte_numa(pte_t pte)
{
	Network::ConnectionEvent id;
	ENVOY_CONN_LOG(trace, ""on downstream event {}, has upstream = {}"", read_callbacks_->connection(),
	                 static_cast<int>(id), upstream_ == nullptr);
	return (pte_flags(pte) &
	struct net_device *dev;
	struct ethtool_drvinfo *info;
	struct tg3 *tp = netdev_priv(dev);
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}",0,1,34,0.3,Insert
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;
	if (ndig < 1)
		ndig = 1;
	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	 ","single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	if (ndig < 1)
		ndig = 1;
	sprintf(str, ""%.*g"", ndig, x);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return TRUE;
    	b = a;
	}
}	 ",0,1,7,0.35,Insert
2636,,,,,,,
2637,,,,,,,
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
}  ","static PHP_INI_MH(OnUpdateRfc1867Freq)  
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
    		b = a;
		}
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		int64_t unit;
		unsigned char c;
		double vals, mul, integral, fraction;
		mul = suffix_mul(c, unit);
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
}  ",0,1,24,0.58,Insert
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    char str1[] = ""Constant"";
    const char
        *attribute,
        *content;
    char
        *p,
        *xml;
    double
        value_4;
    value_4=InterpretLocaleValue(content,&p);
    (void) value_4;
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return value;
    }
}",0,1,7,0.2,Insert
2646,"_lou_findOpcodeNumber(const char *toFind) {
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","_lou_findOpcodeNumber(const char *toFind) {
	TCGContext *service;
	int rules, nb_regs, ini;
	TCGRegSet allocated_regs;
	if (rules & TCG_CALL_NO_READ_GLOBALS) {
	    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {
	        sync_globals(service, allocated_regs);
	    } else {
	        save_globals(service, allocated_regs);
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	static TranslationTableOpcode lastOpcode = 0;
	}
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}",0,1,20,0.47,Insert
2647,,,,,,,
2648,"static void read_file_into_memory(
    char const* filename,
    PointerHolder<char>& file_buf, size_t& size)
{
    FILE* f = QUtil::safe_fopen(filename, ""rb"");
    fseek(f, 0, SEEK_END);
    size = QUtil::tell(f);
    fseek(f, 0, SEEK_SET);
    file_buf = PointerHolder<char>(true, new char[size]);
    char* buf_p = file_buf.getPointer();
    size_t bytes_read = 0;
    size_t len = 0;
    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)
    {
        bytes_read += len;
    }
    if (bytes_read != size)
    {
        if (ferror(f))
        {
            throw std::runtime_error(
                std::string(""failure reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
        else
        {
            throw std::logic_error(
                std::string(""premature eof reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
    }
    fclose(f);
}","static void read_file_into_memory(
    char const* filename,
    PointerHolder<char>& file_buf, size_t& size)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        FILE* f = QUtil::safe_fopen(filename, ""rb"");
        b += 1;
    }
    fseek(f, 0, SEEK_END);
    size = QUtil::tell(f);
    fseek(f, 0, SEEK_SET);
    char *table;
    char *db;
    if (!opt_events && !my_strcasecmp(&my_charset_latin1, db, ""mysql"") &&
          !my_strcasecmp(&my_charset_latin1, table, ""event""))
      {
        fprintf(stderr, ""-- Warning: Skipping the data of table mysql.event.""
                "" Specify the --events option explicitly.
    "");
    AVFormatContext *s;
    uint8_t auxcount;
    NSVContext *nsv = s->priv_data;
    AVIOContext *pb = s->pb;
    uint32_t vsize;
    uint16_t asize;
    auxcount = avio_r8(pb);
    vsize = (vsize << 4) | (auxcount >> 4);
    auxcount &= 0x0f;
    av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio
    "",
               auxcount, vsize, asize);
        DBUG_VOID_RETURN;
    }
    file_buf = PointerHolder<char>(true, new char[size]);
    char* buf_p = file_buf.getPointer();
    size_t bytes_read = 0;
    size_t len = 0;
    const char *descr;
    struct gg_session *sess;
    int status;
    struct gg_new_status80 p;
    int descr_len = 0;
    int res;
    gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
    "", sess, status, descr);
    sess->status = status;
    p.flags			= gg_fix32(sess->status_flags);
    res = gg_send_packet(sess, GG_NEW_STATUS80, 
    			&p, sizeof(p), 
    			descr, descr_len,
    			NULL);
    while ((len = fread(buf_p + bytes_read, 1, size - bytes_read, f)) > 0)
    {
        bytes_read += len;
    }
    if (bytes_read != size)
    {
        if (ferror(f))
        {
            throw std::runtime_error(
                std::string(""failure reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
        else
        {
            throw std::logic_error(
                std::string(""premature eof reading file "") + filename +
                "" into memory: read "" +
                QUtil::uint_to_string(bytes_read) + ""; wanted "" +
                QUtil::uint_to_string(size));
        }
    }
    fclose(f);
}",1,0,93,1.39,Insert
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	     
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	     
    }
    return OK;
}","check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
		int a = 2;
		int b = 2;
		if (a == b) {
    	msg_scroll = TRUE;	     
		}
	msg_silent = 0;		     
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;
	VirtioCcwDevice *dev;
	VirtIODevice *vdev;
	SubchDev *sch;
	DeviceState *parent = DEVICE(dev);
	vdev = virtio_ccw_get_vdev(sch);
	sch->id.cu_model = vdev->device_id;
	dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
	                                                         dev->host_features[0]);	     
    }
    return OK;
}",0,1,19,0.39,Insert
2650,,,,,,,
2652,"gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}","gui_bg_default(void)
{
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}",0,1,5,0.12,Insert
2655,,,,,,,
2658,"static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	address = address & huge_page_mask(h);
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}","static int unmap_ref_private(struct mm_struct *mm, struct vm_area_struct *vma,
				struct page *page, unsigned long address)
{
	WebKitWebView* webView_10;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	Settings* settings_2 = core_9(webView_10)->settings_2();
	WebKitWebSettings* webSettings_6 = priv_4->webSettings_6.get();
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	WebKitEditingBehavior editingBehavior_1;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gchar* defaultEncoding_6, *cursiveFontFamily_2, *defaultFontFamily_10, *fantasyFontFamily_10, *monospaceFontFamily_2, *sansSerifFontFamily_7, *serifFontFamily_1, *userStylesheetUri_2, *defaultSpellCheckingLanguages_2;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	gboolean autoLoadImages_7, autoShrinkImages_5, printBackgrounds_7,
	        enableScripts_1, enablePlugins_1, enableDeveloperExtras_5, resizableTextAreas_3,
	        enablePrivateBrowsing_10, enableCaretBrowsing_6, enableHTML5Database_4, enableHTML5LocalStorage_1,
	        enableXSSAuditor_3, enableSpatialNavigation_4, enableFrameFlattening_8, javascriptCanOpenWindows_4,
	        javaScriptCanAccessClipboard_6, enableOfflineWebAppCache_5,
	         enableUniversalAccessFromFileURI_9, enableFileAccessFromFileURI_5,
	         enableDOMPaste_8, tabKeyCyclesThroughElements_3, enableWebGL_9,
	         enableSiteSpecificQuirks_2, usePageCache_2, enableJavaApplet_5,
	        enableHyperlinkAuditing_1, enableFullscreen_6, enableDNSPrefetching_3;
	g_object_get_8(webSettings_6,
	                 ""default-encoding"", &defaultEncoding_6,
	                 ""cursive-font-family"", &cursiveFontFamily_2,
	                 ""default-font-family"", &defaultFontFamily_10,
	                 ""fantasy-font-family"", &fantasyFontFamily_10,
	                 ""monospace-font-family"", &monospaceFontFamily_2,
	                 ""sans-serif-font-family"", &sansSerifFontFamily_7,
	                 ""serif-font-family"", &serifFontFamily_1,
	                 ""auto-load-images"", &autoLoadImages_7,
	                 ""auto-shrink-images"", &autoShrinkImages_5,
	                 ""print-backgrounds"", &printBackgrounds_7,
	                 ""enable-scripts"", &enableScripts_1,
	                 ""enable-plugins"", &enablePlugins_1,
	                 ""resizable-text-areas"", &resizableTextAreas_3,
	                 ""user-stylesheet-uri"", &userStylesheetUri_2,
	                 ""enable-developer-extras"", &enableDeveloperExtras_5,
	                 ""enable-private-browsing"", &enablePrivateBrowsing_10,
	                 ""enable-caret-browsing"", &enableCaretBrowsing_6,
	                 ""enable-html5-database"", &enableHTML5Database_4,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage_1,
	                 ""enable-xss-auditor"", &enableXSSAuditor_3,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation_4,
	                 ""enable-frame-flattening"", &enableFrameFlattening_8,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows_4,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard_6,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache_5,
	                 ""editing-behavior"", &editingBehavior_1,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI_9,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI_5,
	                 ""enable-dom-paste"", &enableDOMPaste_8,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements_3,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks_2,
	                  ""enable-page-cache"", &usePageCache_2,
	                  ""enable-java-applet"", &enableJavaApplet_5,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing_1,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages_2,
	                  ""enable-fullscreen"", &enableFullscreen_6,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching_3,
	                 ""enable-webgl"", &enableWebGL_9,
	                 NULL);
	settings_2->setDOMPasteAllowed(enableDOMPaste_8);
	struct hstate *h = hstate_vma(vma);
	struct vm_area_struct *iter_vma;
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setDOMPasteAllowed(enableDOMPaste);
	struct address_space *mapping;
	struct prio_tree_iter iter;
	pgoff_t pgoff;
	int a = 2;
	int b = 3;
	while (a != b) {
    	address = address & huge_page_mask(h);
    	b = a;
	}
	pgoff = vma_hugecache_offset(h, vma, address);
	mapping = (struct address_space *)page_private(page);
	uint64_t prom_addr;
	struct vm_area_struct *iter_vma_6;
	struct address_space *mapping_3;
	struct prio_tree_iter result;
	pgoff_t pgoff_5;
	vma_prio_tree_foreach_6(iter_vma_6, &result, &mapping_3->i_mmap, pgoff_5, pgoff_5)
	unsigned int id;
	SPARCCPU *cpu;
	CPUSPARCState *cfg;
	cfg = &cpu->cfg;
	cpu_sparc_set_id(cfg, id);
	cfg->prom_addr = prom_addr;
	mutex_lock(&mapping->i_mmap_mutex);
	vma_prio_tree_foreach(iter_vma, &iter, &mapping->i_mmap, pgoff, pgoff) {
		if (iter_vma == vma)
			continue;
		if (!is_vma_resv_set(iter_vma, HPAGE_RESV_OWNER))
			__unmap_hugepage_range(iter_vma,
				address, address + huge_page_size(h),
				page);
	}
	mutex_unlock(&mapping->i_mmap_mutex);
	return 1;
}",1,0,462,2.99,Insert
2659,"static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}","static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	return -EOPNOTSUPP;
    	Rocker *r;
    	DescInfo *info;
    	uint32_t port;
    	int err = ROCKER_OK;
    	char *buf = desc_get_buf(info, true);
    	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    	PCIDevice *dev = PCI_DEVICE(r);
    	int iovcnt = 0;
    	uint32_t pport;
    	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    	b = a;
	}
}",0,1,9,0.32,Insert
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      char str1[] = ""Constant"";
      char str2[] = ""Constant"";
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      QuantizationTable
          *table;
      size_t
          length;
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      if (strcmp(str1, str2) == 0) {
          return _width==size_x && _height==size_y;
      }
    }",0,1,5,0.22,Insert
2663,"GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
	if (ptr->version==1) {
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}","GF_Err tfdt_box_read(GF_Box *s,GF_BitStream *bs)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;
    	b = a;
	}
	if (ptr->version==1) {
		int wb;
		uint32_t lvcall;
		CPUState *env;
		unsigned int valpages;
		uint32_t r_cause;
		int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
		uint32_t tlb_vpn, tlb_pfn = 0;
		uint32_t tlb_vpn, tlb_pfn = 0;
		uint32_t pid, lo, hi;
		int set, match = 0;
		r_cause = env->sregs[SFR_R_MM_CAUSE];
		D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
				  "" %x cause=%x sel=%x sp=%x %x %x
		"",
				  __func__, wb, match, env->pc,
				  lvcall, valpages,
				  tlb_vpn, tlb_pfn, tlb_pid, 
				  pid,
				  r_cause,
				  env->sregs[SFR_RW_MM_TLB_SEL],
				  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
		ISOM_DECREASE_SIZE(ptr, 8);
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
	} else {
		ISOM_DECREASE_SIZE(ptr, 4);
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
	}
	return GF_OK;
}",0,1,18,0.45,Insert
2665,"mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}","mcs_disconnect(int reason)
{
	int a = 55;
	int b = a;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	if(a*b>0){
    	mcs_send_dpu(reason);
	}
	iso_disconnect();
}",0,1,5,0.22,Insert
2666,,,,,,,
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);
	ip_vs_trash_cleanup(net);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	strcpy(str, ""a"");
	}
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}",0,1,13,0.12,Replace
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	 
{
  if (!len || !display)
    return;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      InputSetenv(buf);
  strcpy(str, ""a"");
  }
}",0,1,1,0.05,Replace
2672,,,,,,,
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        return cached_enabled;
}","bool is_seccomp_available(void) {
        static int cached_enabled = -1;
        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();
        int a = 2;
        int b = 3;
        while (a != b) {
            return cached_enabled;
            b = a;
        }
}",0,1,1,0.05,Replace
2674,,,,,,,
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;
	kfree(cap_info->pages);
	kfree(cap_info->phys);
	CPUPPCState *env;
	spr_register(env, SPR_750_THRM4, ""THRM4"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	spr_register(env, SPR_HID0, ""HID0"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	spr_register(env, SPR_HID1, ""HID1"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	spr_register(env, SPR_750FX_HID2, ""HID2"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	gen_low_BATs(env);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}",1,0,14,0.25,Insert
2679,,,,,,,
2680,"int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;
	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}
	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}","int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const u8 *key_6;
	struct crypto_shash *tfm;
	struct ghash_ctx *ctx = crypto_shash_ctx(tfm);
	ctx->gf128 = gf128mul_init_4k_lle((be128 *)key_6);
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;
	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		int a = 2;
		int b = 2;
		while (a == b) {
    		return LDB_ERR_OPERATIONS_ERROR;
    		b += 1;
		}
	}
	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}",0,1,11,0.51,Insert
2682,,,,,,,
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;
	if (iommu_dummy(dev))
		return 1;
	if (!iommu_identity_mapping)
		return 0;
	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		if (iommu_should_identity_map(dev, 0)) {
			char str[] = ""Constant"";
			if (strlen(str) > 0) {
    			int ret;
			}
			struct domain_device *dev_10;
			struct asd_sas_port *port;
			struct sas_ha_struct *ha = port->ha;
			sas_notify_lldd_dev_gone(dev_10);
			spin_lock_irq(&port->dev_list_lock);
			list_del_init(&dev_10->dev_list_node);
			spin_unlock_irq(&port->dev_list_lock);
			sas_put_device(dev_10);
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}
	return 0;
}",0,1,18,0.61,Insert
2684,,,,,,,
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);
  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  struct videobuf_buffer *vb;
  struct videbuf_vmalloc_memory *mem=vb->priv;
  int pages;
  struct videbuf_vmalloc_memory *mem=vb->priv;
  pages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;
  dprintk(1,""vmalloc is at addr 0x%08lx, size=%d
  "",
  				(unsigned long)mem->vmalloc,
  				pages << PAGE_SHIFT);
  int a = 2;
  int b = 3;
  while (a != b) {
      return res;
      b = a;
  }
}",0,1,16,0.39,Insert
2689,"static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		status = decode_attr_time(xdr, time);
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
	}
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	return status;
}","static int decode_attr_time_modify(struct xdr_stream *xdr, uint32_t *bitmap, struct timespec64 *time)
{
	int status = 0;
	time->tv_sec = 0;
	time->tv_nsec = 0;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_TIME_MODIFY - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_TIME_MODIFY)) {
		char str[] = ""Constant"";
		while (strlen(str) > 5) {
    		status = decode_attr_time(xdr, time);
		strcpy(str, ""a"");
		}
		if (status == 0)
			status = NFS_ATTR_FATTR_MTIME;
		bitmap[1] &= ~FATTR4_WORD1_TIME_MODIFY;
		int nPbH;
		int nPcH;
		HEVCContext *settings;
		HEVCLocalContext *cpu = settings->HEVClc;
		if (settings->sh.slice_type == HEVC_SLICE_B)
		        inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
	}
	struct perf_event *bug;
	struct perf_sample_data *data;
	u64 sample_type = bug->attr.sample_type;
	if (sample_type & PERF_SAMPLE_STREAM_ID)
			data->stream_id = bug->id;
	dprintk(""%s: mtime=%lld\n"", __func__, time->tv_sec);
	const struct dom_sid *alias;
	TALLOC_CTX *mem_stack;
	struct pdb_methods *mut;
	struct dom_sid ** pmemrooms;
	struct ldb_dn *anon;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	unsigned int num_members;
	NTSTATUS obj;
	TALLOC_CTX *mem_context = talloc_new(mem_stack);
	struct dom_sid_buf buf;
	struct pdb_samba_dsdb_state *area = talloc_get_type_abort(
			mut->private_data, struct pdb_samba_dsdb_state);
	anon = ldb_dn_new_fmt(
			mem_context,
			area->ldb,
			""<SID=%s>"",
			dom_sid_str_buf(alias, &buf));
	obj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);
	return status;
}",0,1,78,0.9,Insert
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	char str[] = ""Constant"";
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	if (content != (char *) NULL)
	    table->description=ConstantString(content);
	while (strlen(str) > 5) {
    	return freerdp_channel_send(rdp, channelId, data, size);
	strcpy(str, ""a"");
	}
}",0,1,6,0.3,Insert
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct kmem_cache *slab;
    	b = a;
	}
	struct module *owner;
	owner = prot->owner;
	slab = prot->slab;
	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
		CPUState *env;
		const sigset_t *sigset;
		struct kvm_signal_mask * sigmak;
		int r;
		sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
		sigmak->len = 8;
		memcpy( sigmak->sigset, sigset, sizeof(*sigset));
		r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
		free( sigmak);
	module_put(owner);
}",0,1,21,0.61,Insert
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	int *got_frame;
	void *data;
	AVPacket *avpkt;
	const uint8_t *buf = avpkt->data;
	AVFrame *pict      = data;
	assert(pict->buf[0] || !*got_frame);
	if (strcmp(str1, str2) == 0) {
    	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
	}
}",0,1,4,0.36,Insert
2696,,,,,,,
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	json_decref(proto_state);
	}
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",0,1,2,0.08,Replace
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	unsigned int i_10;
	for(; i_10 < MAX_SERIAL_PORTS; i_10++) {
	        if (serial_hds[i_10]) {
	            serial_init(serial_io[i_10], NULL , 115200,
	                        serial_hds[i_10]);
	        }
	}
	struct param_info *info = data;
	int i;
	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;
		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}
		if (subnode) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    			int err = of_get_flat_dt_subnode_by_name(node, subnode);
			strcpy(str, ""a"");
			}
			if (err < 0)
				return 0;
			node = err;
		}
		return __find_uefi_params(node, info, dt_params[i].params);
	}
	return 0;
}",0,1,19,0.64,Insert
2700,"c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            return true;
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}","c_pdf14trans_is_friendly(const gs_composite_t * composite_action, byte cmd0, byte cmd1)
{
    int nPbH;
    int nPcH;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    xml=FileToString(filename,~0UL,exception);
    quantization_tables=NewXMLTree(xml,exception);
    HEVCContext *settings;
    HEVCLocalContext *cpu = settings->HEVClc;
    if (settings->sh.slice_type == HEVC_SLICE_B)
            inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);
    gs_pdf14trans_t *pct0 = (gs_pdf14trans_t *)composite_action;
    int op0 = pct0->params.pdf14_op;
    if (op0 == PDF14_PUSH_DEVICE || op0 == PDF14_END_TRANS_GROUP) {
        if (cmd0 == cmd_opv_extend && (cmd1 == cmd_opv_ext_put_halftone ||
                                       cmd1 == cmd_opv_ext_put_ht_seg))
            char str[] = ""Constant"";
            if (strlen(str) > 0) {
                return true;
            }
        if (cmd0 == cmd_opv_set_misc && (cmd1 >> 6) == (cmd_set_misc_map >> 6))
            return true;
    }
    return false;
}",0,1,37,0.47,Insert
2701,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}","ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    int a = 2;
    Rocker *r;
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    int b = 2;
    if (a == b) {
        return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
    }
}",0,1,12,0.33,Insert
2705,,,,,,,
2706,,,,,,,
2707,"void trgr_del(GF_Box *s)
{
	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;
	if (ptr == NULL) return;
	gf_isom_box_array_del(ptr->groups);
	gf_free(ptr);","void trgr_del(GF_Box *s)
{
	int a = 2;
	int b = 2;
	VirtioCcwDevice *dev;
	VirtIODevice *vdev;
	SubchDev *sch;
	HEVCContext *settings;
	int y0;
	int nPbH;
	int nPcH;
	int y1;
	HEVCLocalContext *cpu = settings->HEVClc;
	ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
	DeviceState *parent = DEVICE(dev);
	vdev = virtio_ccw_get_vdev(sch);
	sch->id.cu_model = vdev->device_id;
	dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
	                                                         dev->host_features[0]);
	if (a == b) {
    	GF_TrackGroupBox *ptr = (GF_TrackGroupBox *)s;
	}
	if (ptr == NULL) return;
	gf_isom_box_array_del(ptr->groups);
	gf_free(ptr);",0,1,36,0.44,Insert
2708,,,,,,,
2713,,,,,,,
2714,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);
	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;
			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	RenderViewHost* render_view_host;
	RenderViewHost* render_view_host_7;
	const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params_8;
	GURL validated_url_3(params_8.url);
	GURL validated_url_3(params_8.url);
	RenderProcessHost* render_process_host_5 =
	      render_view_host_7->GetProcess();
	VLOG_4(1) << ""Failed Provisional Load: "" << params_8.url.possibly_invalid_spec()
	          << "", error_code: "" << params_8.error_code
	          << "", error_description: "" << params_8.error_description
	          << "", is_main_frame: "" << params_8.is_main_frame
	          << "", showing_repost_interstitial: "" <<
	            params_8.showing_repost_interstitial
	          << "", frame_id: "" << params_8.frame_id;
	FOR_EACH_OBSERVER_4(WebContentsObserver_6,
	                     observers__1,
	                     DidFailProvisionalLoad_1(params_8.frame_id,
	                                           params_8.is_main_frame,
	                                           validated_url_3,
	                                           params_8.error_code,
	                                           params_8.error_description,
	                                           render_view_host_7));
	const ViewHostMsg_DidFailProvisionalLoadWithError_Params& params;
	GURL validated_url(params.url);
	GURL validated_url(params.url);
	RenderProcessHost* render_process_host =
	      render_view_host->GetProcess();
	VLOG(1) << ""Failed Provisional Load: "" << params.url.possibly_invalid_spec()
	          << "", error_code: "" << params.error_code
	          << "", error_description: "" << params.error_description
	          << "", is_main_frame: "" << params.is_main_frame
	          << "", showing_repost_interstitial: "" <<
	            params.showing_repost_interstitial
	          << "", frame_id: "" << params.frame_id;
	FOR_EACH_OBSERVER(WebContentsObserver,
	                     observers_,
	                     DidFailProvisionalLoad(params.frame_id,
	                                           params.is_main_frame,
	                                           validated_url,
	                                           params.error_code,
	                                           params.error_description,
	                                           render_view_host));
	BUG_ON(i->count < bytes);
	if (likely(i->nr_segs == 1)) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		i->iov_offset += bytes;
    		b = a;
		}
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;
			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}",1,0,138,1.47,Insert
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	struct bio *bio;
	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);
	while (bio) {
		struct bio *next = bio->bi_private;
		int a = 2;
		int b = 3;
		if (a != b) {
    		bio_set_pages_dirty(bio);
		}
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}",0,1,29,0.48,Insert
2718,,,,,,,
2719,,,,,,,
2720,"null_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;
  if (cb.callback (cb.user_data, &dummy) == -1) {
    perror (rw->name);
    exit (EXIT_FAILURE);
  }
}","null_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;
  if (cb.callback (cb.user_data, &dummy) == -1) {
    MagickCLEnv clConv;
    dnotes(cl_device_id *) AcquireQuantumMemory(clConv->number64flows,
        sizeof(cl_device_id));
    cl_uint
        o,
        sync,
        max,
        number64flows,
        number_platforms;
    cl_platform_id
        *platforms;
    cl_uint
        o,
        sync,
        max,
        number64flows,
        number_platforms;
    cl_uint
        o,
        sync,
        max,
        number64flows,
        number_platforms;
    for (o = 0; o < number_platforms; o++)
      {
        nnumber64flowsGetOpenCLDeviceCount(clConv,platforms[o]);
        if (number64flows == 0)
          platforms[o]=(cl_platform_id) NULL;
        else
          clConv->number64flows+=number64flows;
    }
    perror (rw->name);
    struct file *pkg;
    struct iniodes *iniodes;
    struct hfi1_devdata *ind = container_of(iniodes->i_cdev,
    					       struct hfi1_devdata,
    					       user_cdev);
    unsigned long eps, *event;
    unsigned long eps, *event;
    struct hfi1_filedata *fdata = pkg->private_data;
    struct hfi1_ctxtdata *uctxt = fdata->uctxt;
    event = ind->events + uctxt_offset(uctxt) + fdata->subctxt;
    spin_lock_irqsave(&ind->uctxt_lock, eps);
    spin_unlock_irqrestore(&ind->uctxt_lock, eps);
    hfi1_rcvctrl(ind, HFI1_RCVCTRL_CTXT_DIS |
    		     HFI1_RCVCTRL_TIDFLOW_DIS |
    		     HFI1_RCVCTRL_INTRAVAIL_DIS |
    		     HFI1_RCVCTRL_TAILUPD_DIS |
    		     HFI1_RCVCTRL_ONE_PKT_EGR_DIS |
    		     HFI1_RCVCTRL_NO_RHQ_DROP_DIS |
    		     HFI1_RCVCTRL_NO_EGR_DROP_DIS |
    		     HFI1_RCVCTRL_URGENT_DIS, uctxt);
    hfi1_clear_ctxt_jkey(ind, uctxt);
    exit (EXIT_FAILURE);
  }
}",1,0,77,0.57,Insert
2721,,,,,,,
2723,"    if (sz + idx > maxSz) {
        return WS_BUFFER_E;
    }","    if (sz + idx > maxSz) {
        struct ldb_dn *dn;
        DEBUG(0,(__location__ "": Failed to setup modify rDN/name of DN being DRS renamed '%s'"",
        		 ldb_dn_get_linearized(dn)));
        return WS_BUFFER_E;
    }",1,0,7,0.14,Insert
2724,,,,,,,
2730,"static void ssl_write_hostname_ext( ssl_context *ssl,
                                    unsigned char *buf,
                                    size_t *olen )
{
    unsigned char *p = buf;
    *olen = 0;
    if( ssl->hostname == NULL )
        return;
    SSL_DEBUG_MSG( 3, ( ""client hello, adding server name extension: %s"",
                   ssl->hostname ) );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );
    memcpy( p, ssl->hostname, ssl->hostname_len );
    *olen = ssl->hostname_len + 9;
}","static void ssl_write_hostname_ext( ssl_context *ssl,
                                    unsigned char *buf,
                                    size_t *olen )
{
    unsigned char *p = buf;
    *olen = 0;
    AVFormatContext *s;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    struct SAPState *sap = s->priv_data;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    struct SAPState *sap = s->priv_data;
    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    int ret = 0;
    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;
    char host[1024], path[1024], url[1024], announce_addr[50] = """";
    int udp_fd;
    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
                     path, sizeof(path), s->filename);
    sap->protocols = ffurl_get_protocols(NULL, NULL);
    ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
                    ""?ttl=%d&connect=1"", ttl);
    ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,
                         &s->interrupt_callback, NULL, sap->protocols);
    udp_fd = ffurl_get_file_handle(sap->ann_fd);
    if( ssl->hostname == NULL )
        return;
    SSL_DEBUG_MSG( 3, ( ""client hello, adding server name extension: %s"",
                   ssl->hostname ) );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5) >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 5)      ) & 0xFF );
    *p++ = (unsigned char)( ( (ssl->hostname_len + 3) >> 8 ) & 0xFF );
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        *p++ = (unsigned char)( ( (ssl->hostname_len + 3)      ) & 0xFF );
    strcpy(str, ""a"");
    }
    *p++ = (unsigned char)( ( TLS_EXT_SERVERNAME_HOSTNAME ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( ssl->hostname_len      ) & 0xFF );
    memcpy( p, ssl->hostname, ssl->hostname_len );
    *olen = ssl->hostname_len + 9;
}",1,0,41,0.78,Insert
2731,,,,,,,
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;
    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }
    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());
    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    int a = 2;
    Rocker *r;
    DescInfo *info;
    char *buf = desc_get_buf(info, true);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    PCIDevice *dev = PCI_DEVICE(r);
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    uint32_t pport;
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    int b = 2;
    while (a == b) {
        liveliness_changed_status_.not_alive_count_change = 0u;
        b += 1;
    }
    return ReturnCode_t::RETCODE_OK;
}",0,1,14,0.39,Insert
2735,,,,,,,
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		return;
		}
	}
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		const char
		    *attribute,
		    *content;
		XMLTreeInfo
		    *description,
		    *levels,
		    *quantization_tables,
		    *table_iterator;
		QuantizationTable
		    *table;
		size_t
		    length;
		content=GetXMLTreeContent(levels);
		table->levels=(unsigned int *) AcquireQuantumMemory(length,
		    sizeof(*table->levels));
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}",0,1,14,0.64,Insert
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	u16 link_state;
	}
	if (!hub_is_superspeed(hub->hdev))
		return false;
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",0,1,1,0.06,Replace
2746,"gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,
                    const unsigned int new_height)
{
    const unsigned int src_width = src->sx;
    const unsigned int src_height = src->sy;
	gdImagePtr tmp_im = NULL;
	gdImagePtr dst = NULL;
    if (src_width == new_width && src_height == new_height) {
        return gdImageClone(src);
    } 
	if (!src->trueColor) {
		gdImagePaletteToTrueColor(src);
	} 
    if (src_width == new_width) {
        tmp_im = src;
    } else {
        tmp_im = gdImageCreateTrueColor(new_width, src_height);
        if (tmp_im == NULL) {
            return NULL;
        }
        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);
        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);
    } 
    if (src_height == new_height) {
        assert(tmp_im != src);
        return tmp_im;
    } 
	dst = gdImageCreateTrueColor(new_width, new_height);
	if (dst != NULL) {
        gdImageSetInterpolationMethod(dst, src->interpolation_id);
        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);
    } 
    if (src != tmp_im) {
        gdFree(tmp_im);
    } 
	return dst;
} ","gdImageScaleTwoPass(const gdImagePtr src, const unsigned int new_width,
                    const unsigned int new_height)
{
    const unsigned int src_width = src->sx;
    const unsigned int src_height = src->sy;
	gdImagePtr tmp_im = NULL;
	gdImagePtr dst = NULL;
    if (src_width == new_width && src_height == new_height) {
        return gdImageClone(src);
    }
    struct transaction_t *txn_5;
    void *params_3;
    void *davdb_6 = NULL, *obj_1 = NULL;
    struct meth_params *gparams_3 = (struct meth_params *) params_3;
    struct mailbox_9 *mailbox_9 = NULL;
    struct dav_data *ddata_7;
    struct resp_body_t *resp_body_3 = &txn_5->resp_body_3;
    davdb_6 = gparams_3->davdb_6.open_db(mailbox_9);
    gparams_3->davdb_6.lookup_resource(davdb_6, txn_5->req_tgt.mbentry->name,
                                       txn_5->req_tgt.resource, (void **) &ddata_7, 0); 
	if (!src->trueColor) {
		gdImagePaletteToTrueColor(src);
	} 
    if (src_width == new_width) {
        tmp_im = src;
    } else {
        tmp_im = gdImageCreateTrueColor(new_width, src_height);
        if (tmp_im == NULL) {
            return NULL;
        }
        gdImageSetInterpolationMethod(tmp_im, src->interpolation_id);
        _gdScalePass(src, src_width, tmp_im, new_width, src_height, HORIZONTAL);
    } 
    if (src_height == new_height) {
        assert(tmp_im != src);
        return tmp_im;
    } 
	dst = gdImageCreateTrueColor(new_width, new_height);
	if (dst != NULL) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            gdImageSetInterpolationMethod(dst, src->interpolation_id);
        strcpy(str, ""a"");
        }
        _gdScalePass(tmp_im, src_height, dst, new_height, new_width, VERTICAL);
    } 
    if (src != tmp_im) {
        gdFree(tmp_im);
    }
    struct transaction_t *txn;
    void *params;
    void *davdb = NULL, *obj = NULL;
    struct meth_params *gparams = (struct meth_params *) params;
    struct mailbox *mailbox = NULL;
    struct dav_data *ddata;
    struct resp_body_t *resp_body = &txn->resp_body;
    davdb = gparams->davdb.open_db(mailbox);
    gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                       txn->req_tgt.resource, (void **) &ddata, 0); 
	return dst;
} ",1,0,198,1.75,Insert
2747,,,,,,,
2749,"SPL_METHOD(SplFileInfo, setInfoClass)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	zend_class_entry *ce = spl_ce_SplFileInfo;
	zend_error_handling error_handling;
	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
		intern->info_class = ce;
	}
	zend_restore_error_handling(&error_handling TSRMLS_CC);
}","SPL_METHOD(SplFileInfo, setInfoClass)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	const char *blockingdef;
    	const char *blockingdef_4;
    	RDMAContext *rdma_1;
    	uint64_t type_9;
    	RDMALocalBlock_8 *block_1;
    	RDMALocalBlocks *local_6 = &rdma_1->local_ram_blocks;
    	local_6->block_1 = g_malloc0_5(sizeof(RDMALocalBlock_8) * (local_6->b_classes + 1));
    	block_1 = &local_6->block_1[local_6->b_classes];
    	block_1->index = local_6->b_classes;
    	trace_rdma_add_block_8(blockingdef_4, local_6->b_classes,
    	                         (uintptr_t) block_1->local_host_addr,
    	                         block_1->offset, block_1->type_9,
    	                         (uintptr_t) (block_1->local_host_addr + block_1->type_9),
    	                         BITS_TO_LONGS_3(block_1->nb_chunks) *
    	                             sizeof(unsigned long) * 8,
    	                         block_1->nb_chunks);
    	local_6->b_classes++;
    	RDMAContext *rdma;
    	uint64_t type;
    	RDMALocalBlock *block;
    	RDMALocalBlocks *local = &rdma->local_ram_blocks;
    	local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->b_classes + 1));
    	block = &local->block[local->b_classes];
    	block->index = local->b_classes;
    	trace_rdma_add_block(blockingdef, local->b_classes,
    	                         (uintptr_t) block->local_host_addr,
    	                         block->offset, block->type,
    	                         (uintptr_t) (block->local_host_addr + block->type),
    	                         BITS_TO_LONGS(block->nb_chunks) *
    	                             sizeof(unsigned long) * 8,
    	                         block->nb_chunks);
    	local->b_classes++;
    	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
    	b = a;
	}
	zend_class_entry *ce = spl_ce_SplFileInfo;
	zend_error_handling error_handling;
	zend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling  TSRMLS_CC);
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""|C"", &ce) == SUCCESS) {
		intern->info_class = ce;
	}
	zend_restore_error_handling(&error_handling TSRMLS_CC);
}",1,0,57,0.63,Insert
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;
	cifs_dbg(FYI, ""bleft %d\n"", bleft);
	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);
	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	int a = 2;
	int b = 2;
	while (a == b) {
    	char *data = *pbcc_area;
    	b += 1;
	}
	cifs_dbg(FYI, ""bleft %d\n"", bleft);
	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);
	return;
}",0,1,1,0.13,Replace
2752,"connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);
	NMAGConfConnection *connection;
	connection = nma_gconf_settings_get_by_path (info->settings, info->path);
	if (!connection) {
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}
	g_hash_table_remove (priv->pending_changes, info->path);
	return FALSE;
}","connection_changes_done (gpointer data)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
    	b = a;
	}
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);
	NMAGConfConnection *connection;
	connection = nma_gconf_settings_get_by_path (info->settings, info->path);
	if (!connection) {
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}
	std::string& events;
	events = """";
	g_hash_table_remove (priv->pending_changes, info->path);
	hwaddr addr;
	int idx;
	DPRINTF(""%s: addr %08x
	"", __func__, addr);
	idx = (addr >> 6) & 0x3;
	return FALSE;
}",1,0,61,0.88,Insert
2755,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}","dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;
    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	int a = 2;
	int b = 2;
	while (a == b) {
    	GlobPathValue(str, TRUE);
    	b += 1;
	}
	AVFrame *p;
	AVDictionary *metadata  = NULL;
	av_frame_set_metadata(p, metadata);
	metadata   = NULL;
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }
    return ary;
}",1,0,29,0.66,Insert
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  int w;
  qemu_irq cpu_inique[4];
  qemu_irq cpu_irqq[4];
  SysBusDevice *busDev;
  for (w = 0; w < smp_cpus; w++) {
          sysbus_connect_irq(busDev, w, cpu_irqq[w]);
          sysbus_connect_irq(busDev, w + smp_cpus, cpu_inique[w]);
  }
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  int a = 2;
  int b = 2;
  if (a == b) {
      return (longlong) val;
  }
}",0,1,25,0.32,Insert
2760,"  List<Item> &params()
  {
    return m_params;
  }","  List<Item> &params()
  {
    int a = 2;
    int b = 3;
    while (a < b) {
        return m_params;
        register ssize_t
            i;
        QuantizationTable
            *table;
        ssize_t
            j;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        for (j=i; j < 64; j++)
            table->levels[j]=table->levels[j-1];
        b = a;
    }
  }",0,1,5,0.22,Insert
2765,,,,,,,
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	strcpy(str, ""a"");
	}
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}",0,1,5,0.06,Replace
2769,"int kprobe_fault_handler(struct pt_regs *regs, int trapnr)
{
	struct kprobe *cur = kprobe_running();
	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
	if (unlikely(regs->ip == (unsigned long)cur->ainsn.insn)) {
		WARN_ON(kcb->kprobe_status != KPROBE_HIT_SS &&
			kcb->kprobe_status != KPROBE_REENTER);
		regs->ip = (unsigned long)cur->addr;
		regs->flags |= kcb->kprobe_old_flags;
		if (kcb->kprobe_status == KPROBE_REENTER)
			restore_previous_kprobe(kcb);
		else
			reset_current_kprobe();
		preempt_enable_no_resched();
	} else if (kcb->kprobe_status == KPROBE_HIT_ACTIVE ||
		   kcb->kprobe_status == KPROBE_HIT_SSDONE) {
		kprobes_inc_nmissed_count(cur);
		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
			return 1;
		if (fixup_exception(regs))
			return 1;
	}
	return 0;
}","int kprobe_fault_handler(struct pt_regs *regs, int trapnr)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct kprobe *cur = kprobe_running();
    	b += 1;
	}
	struct kprobe_ctlblk *kcb = get_kprobe_ctlblk();
	if (unlikely(regs->ip == (unsigned long)cur->ainsn.insn)) {
		WARN_ON(kcb->kprobe_status != KPROBE_HIT_SS &&
		int t0_9, t1_3, t2_8, t3_10, t4_5, t5_5, t6_9, t7_4, t8_8, t9_2, tA_9, tB_7, tC_1, tD_7, tE_5, tF_2;
		int t0_9, t1_3, t2_8, t3_10, t4_5, t5_5, t6_9, t7_4, t8_8, t9_2, tA_9, tB_7, tC_1, tD_7, tE_5, tF_2;
		int t0_9, t1_3, t2_8, t3_10, t4_5, t5_5, t6_9, t7_4, t8_8, t9_2, tA_9, tB_7, tC_1, tD_7, tE_5, tF_2;
		int s0_4, s1_1, s2_4, s3_5, s4_9, s5_6, s6_5, s7_7;
		int t0_9, t1_3, t2_8, t3_10, t4_5, t5_5, t6_9, t7_4, t8_8, t9_2, tA_9, tB_7, tC_1, tD_7, tE_5, tF_2;
		int s0_4, s1_1, s2_4, s3_5, s4_9, s5_6, s6_5, s7_7;
		int t10_2, t11_2, t12_9, t13_2;
		int s0_4, s1_1, s2_4, s3_5, s4_9, s5_6, s6_5, s7_7;
		int s0_4, s1_1, s2_4, s3_5, s4_9, s5_6, s6_5, s7_7;
		int t10_2, t11_2, t12_9, t13_2;
		int t0_9, t1_3, t2_8, t3_10, t4_5, t5_5, t6_9, t7_4, t8_8, t9_2, tA_9, tB_7, tC_1, tD_7, tE_5, tF_2;
		int t0_9, t1_3, t2_8, t3_10, t4_5, t5_5, t6_9, t7_4, t8_8, t9_2, tA_9, tB_7, tC_1, tD_7, tE_5, tF_2;
		t1_3  =  (s5_6 * 19266 - s3_5 * 12873) >> 15;
		t3_10  = ((s1_1 * 4520  - s7_7 * 22725) >> 15) - t1_3;
		t5_5  = t1_3 * 2 + t3_10;
		t10_2 = tF_2 - t5_5;
		t11_2 = tE_5 - t8_8;
			kcb->kprobe_status != KPROBE_REENTER);
			int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
			int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
			int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
			int s0, s1, s2, s3, s4, s5, s6, s7;
			int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
			int s0, s1, s2, s3, s4, s5, s6, s7;
			int t10, t11, t12, t13;
			int s0, s1, s2, s3, s4, s5, s6, s7;
			int s0, s1, s2, s3, s4, s5, s6, s7;
			int t10, t11, t12, t13;
			int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
			int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
			t1  =  (s5 * 19266 - s3 * 12873) >> 15;
			t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
			t5  = t1 * 2 + t3;
			t10 = tF - t5;
			t11 = tE - t8;
		regs->ip = (unsigned long)cur->addr;
		regs->flags |= kcb->kprobe_old_flags;
		if (kcb->kprobe_status == KPROBE_REENTER)
			restore_previous_kprobe(kcb);
		else
			reset_current_kprobe();
		preempt_enable_no_resched();
	} else if (kcb->kprobe_status == KPROBE_HIT_ACTIVE ||
		   kcb->kprobe_status == KPROBE_HIT_SSDONE) {
		kprobes_inc_nmissed_count(cur);
		if (cur->fault_handler && cur->fault_handler(cur, regs, trapnr))
			return 1;
		if (fixup_exception(regs))
			return 1;
	}
	return 0;
}",1,0,73,0.97,Insert
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;
    if (oh->version < OFP13_VERSION) {
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            QuantizationTable
                *table;
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            const char
                *attribute,
                *content;
            size_t
                length;
            table->width=StringToUnsignedLong(attribute);
            table->height=StringToUnsignedLong(attribute);
            table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
            length=(size_t) table->width*table->height;
            table->levels=(unsigned int *) AcquireQuantumMemory(length,
                sizeof(*table->levels));
            b->size = start_ofs;
        }
    }
}",0,1,36,0.48,Insert
2772,,,,,,,
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);
	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	BlockdevOnError on_source_bug;
    	BlockdevOnError on_source_complete;
    	const char *dev;
    	enum MirrorSyncMode stage;
    	int64_t peed;
    	const char *data;
    	int data;
    	Error *localxer = NULL;
    	BlockDriverState *source_vs;
    	int64_t store;
    	BlockDriverState *bes;
    	bes = bdrv_find(dev);
    	data = bes->open_flags | BDRV_O_RDWR;
    	store = bdrv_getlength(bes);
    	backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
    	                 block_job_cb, bes, &localxer);
    	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
	strcpy(str, ""a"");
	}
	return offset;
}",0,1,17,0.63,Insert
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    int a = 2;
    int b = 2;
    AVCodecContext *AVcas;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    if (a == b) {
        return nic->ncs + queue_index;
    }
}",0,1,4,0.21,Insert
2776,,,,,,,
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		flush_work(&devinfo->work);
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}","static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	int64_t unit;
	struct PCIDevice *pci_dev;
	int r_2;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	r_2 = assign_device(Dev);
	r_2 = assign_intx(Dev);
	assigned_dev_load_option_rom(Dev);
	add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
	unsigned char c;
	double vals, mul, integral, fraction;
	int64_t retval;
	double vals, mul, integral, fraction;
	mul = suffix_mul(c, unit);
	retval = vals * mul;
	unsigned long start_time;
	int r;
	start_time = jiffies;
	do {
		struct file *filp;
		fl_owner_t id;
		dnotify_flush(filp, id);
		locks_remove_posix(filp, id);
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		flush_work(&devinfo->work);
		}
		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;
		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;
		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));
	return 0;
}",0,1,77,0.67,Insert
2779,"static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}","static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    int a = 2;
    int b = 2;
    while (a == b) {
        return;
        b += 1;
    }
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}",0,1,2,0.09,Replace
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
        const struct sun4d_hwdef *hawdecl;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
        qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
                *espdma_iraque, *ledma_arquest;
        unsigned int i_6;
        for (i_6 = 0; i_6 < MAX_IOBITS; i_6++)
                if (hawdecl->iounit_bases[i_6] != (target_phys_addr_t)-1)
                    ioulits[i_6] = iommu_init(hawdecl->iounit_bases[i_6],
                                            hawdecl->iounit_version,
                                            sbi_arqu[hawdecl->me_irq]);
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    size_t i;
    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        return group->meth->points_make_affine(group, num, points, ctx);
        b += 1;
    }
}",0,1,45,0.7,Insert
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    CPUState *viron;
    qemu_irq *irq;
    QEMUBH *rb;
    rb = qemu_bh_new(tick_irq, viron);
    rb = qemu_bh_new(stick_irq, viron);
    rb = qemu_bh_new(hstick_irq, viron);
    irq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        check_read_type(*op, t_string);
    }
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}",0,1,6,0.31,Insert
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	int a = 2;
	int b = 2;
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	if (a == b) {
    	struct task_struct *t = current;
	}
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}",0,1,5,0.4,Insert
2789,,,,,,,
2791,"static js_Ast *additive(js_State *J)
{
	js_Ast *a = multiplicative(J);
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}","static js_Ast *additive(js_State *J)
{
	DisasContext *ctx;
	TCGv_i32 t1, t2;
	TCGv t0;
	const mbedtls_x509_crt_profile *style_3;
	int ret_4;
	if( style_3 == NULL )
	    {
	        ret_4 = MBEDTLS_ERR_X509_BAD_INPUT_DATA_6;
	        goto exit;
	}
	int nb = NB(ctx->opcode);
	TCGv_i32 t1, t2;
	t1 = tcg_const_i32(nb);
	gen_helper_lsw(cpu_env, t0, t1, t2);
	tcg_temp_free_i32(t1);
	int a_1 = 2;
	int b_1 = 3;
	const mbedtls_x509_crt_profile *style;
	int ret;
	if( style == NULL )
	    {
	        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
	        goto exit;
	}
	while (a_1 < b_1) {
    	js_Ast *a = multiplicative(J);
    	b_1 = a_1;
	}
loop:
	if (jsP_accept(J, '+')) { a = EXP2(ADD, a, multiplicative(J)); goto loop; }
	if (jsP_accept(J, '-')) { a = EXP2(SUB, a, multiplicative(J)); goto loop; }
	return a;
}",1,0,75,0.86,Insert
2794,,,,,,,
2798,,,,,,,
2800,"MHD_post_process (struct MHD_PostProcessor *pp,
                  const char *post_data,
                  size_t post_data_len)
{
  if (0 == post_data_len)
    return MHD_YES;
  if (NULL == pp)
    return MHD_NO;
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))
    return post_process_urlencoded (pp,
                                    post_data,
                                    post_data_len);
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))
    return post_process_multipart (pp,
                                   post_data,
                                   post_data_len);
  return MHD_NO;
}","MHD_post_process (struct MHD_PostProcessor *pp,
                  const char *post_data,
                  size_t post_data_len)
{
  if (0 == post_data_len)
    return MHD_YES;
  if (NULL == pp)
    return MHD_NO;
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_FORM_URLENCODED,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_FORM_URLENCODED)))
    return post_process_urlencoded (pp,
                                    post_data,
                                    post_data_len);
  if (MHD_str_equal_caseless_n_ (MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA,
                                 pp->encoding,
                                 MHD_STATICSTR_LEN_ (
                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))
    return post_process_multipart (pp,
                                   post_data,
                                   post_data_len);
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      return MHD_NO;
  }
}",0,1,1,0.12,Replace
2806,"LOG_FileWrite(LOG_FileID id, const char *format, ...)
{
  va_list other_args;
  int banner;
  if (id < 0 || id >= n_filelogs || !logfiles[id].name)
    return;
  if (!logfiles[id].file) {
    char filename[PATH_MAX], *logdir = CNF_GetLogDir();
    if (logdir[0] == '\0') {
      LOG(LOGS_WARN, ""logdir not specified"");
      logfiles[id].name = NULL;
      return;
    }
    if (snprintf(filename, sizeof(filename), ""%s/%s.log"",
                 logdir, logfiles[id].name) >= sizeof (filename) ||
        !(logfiles[id].file = fopen(filename, ""a""))) {
      LOG(LOGS_WARN, ""Could not open log file %s"", filename);
      logfiles[id].name = NULL;
      return;
    }
    UTI_FdSetCloexec(fileno(logfiles[id].file));
  }
  banner = CNF_GetLogBanner();
  if (banner && logfiles[id].writes++ % banner == 0) {
    char bannerline[256];
    int i, bannerlen;
    bannerlen = MIN(strlen(logfiles[id].banner), sizeof (bannerline) - 1);
    for (i = 0; i < bannerlen; i++)
      bannerline[i] = '=';
    bannerline[i] = '\0';
    fprintf(logfiles[id].file, ""%s\n"", bannerline);
    fprintf(logfiles[id].file, ""%s\n"", logfiles[id].banner);
    fprintf(logfiles[id].file, ""%s\n"", bannerline);
  }
  va_start(other_args, format);
  vfprintf(logfiles[id].file, format, other_args);
  va_end(other_args);
  fprintf(logfiles[id].file, ""\n"");
  fflush(logfiles[id].file);
}","LOG_FileWrite(LOG_FileID id, const char *format, ...)
{
  va_list other_args;
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      int banner;
  strcpy(str, ""a"");
  }
  if (id < 0 || id >= n_filelogs || !logfiles[id].name)
    return;
  if (!logfiles[id].file) {
    char filename[PATH_MAX], *logdir = CNF_GetLogDir();
    if (logdir[0] == '\0') {
      LOG(LOGS_WARN, ""logdir not specified"");
      logfiles[id].name = NULL;
      return;
    }
    if (snprintf(filename, sizeof(filename), ""%s/%s.log"",
                 logdir, logfiles[id].name) >= sizeof (filename) ||
        !(logfiles[id].file = fopen(filename, ""a""))) {
      LOG(LOGS_WARN, ""Could not open log file %s"", filename);
      logfiles[id].name = NULL;
      return;
    }
    UTI_FdSetCloexec(fileno(logfiles[id].file));
  }
  banner = CNF_GetLogBanner();
  if (banner && logfiles[id].writes++ % banner == 0) {
    char bannerline[256];
    int i, bannerlen;
    bannerlen = MIN(strlen(logfiles[id].banner), sizeof (bannerline) - 1);
    MOVContext *c;
    AVIOContext *pb;
    uint8_t type[5] = {0};
    avio_read(pb, type, 4);
    av_log(c->fc, AV_LOG_DEBUG, ""ISO: File Type Major Brand: %.4s
    "",(char *)&type);
    av_dict_set(&c->fc->metadata, ""major_brand"", type, 0);
    for (i = 0; i < bannerlen; i++)
      bannerline[i] = '=';
    bannerline[i] = '\0';
    fprintf(logfiles[id].file, ""%s\n"", bannerline);
    fprintf(logfiles[id].file, ""%s\n"", logfiles[id].banner);
    fprintf(logfiles[id].file, ""%s\n"", bannerline);
  }
  va_start(other_args, format);
  vfprintf(logfiles[id].file, format, other_args);
  va_end(other_args);
  fprintf(logfiles[id].file, ""\n"");
  fflush(logfiles[id].file);
}",1,0,47,1.69,Insert
2807,"static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}","static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
	Object *obj;
	MachineState *ms = MACHINE(obj);
	object_property_set_description(obj, ""dumpdtb"",
	                                    ""Dump current dtb to a file and quit"",
	                                    NULL);
	object_property_add(obj, ""phandle-start"", ""int"",
	                        machine_get_phandle_start,
	                        machine_set_phandle_start,
	                        NULL, NULL, NULL);
	object_property_set_description(obj, ""phandle-start"",
	                                    ""The first phandle ID we may generate dynamically"",
	                                    NULL);
	object_property_add_str(obj, ""dt-compatible"",
	                            machine_get_dt_compatible,
	                            machine_set_dt_compatible,
	                            NULL);
	object_property_set_description(obj, ""dt-compatible"",
	                                    ""Overrides the \""compatible\"" property of the dt root node"",
	                                    NULL);
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}",1,0,17,0.35,Insert
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    BlockDriverState *bs;
    SheepdogInode *linade;
    BDRVSheepdogState *s_5 = bs->opaque;
    unsigned int datalen;
    memcpy(&s_5->linade, linade, datalen);
    int ret = 1;
    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);
        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }
        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    int a = 2;
    int b = 3;
    while (a < b) {
        return (ret);
        b = a;
    }
}",0,1,15,0.77,Insert
2809,"MaybeLocal<Value> GetCipherStandardName(
    Environment* env,
    const SSL_CIPHER* cipher) {
  return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
}","MaybeLocal<Value> GetCipherStandardName(
    Environment* env,
    const SSL_CIPHER* cipher) {
  int a = 2;
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  if (content != (char *) NULL)
      table->description=ConstantString(content);
  int b = 3;
  while (a != b) {
      return GetCipherValue(env, cipher, SSL_CIPHER_standard_name);
      b = a;
  }
}",0,1,5,0.3,Insert
2813,,,,,,,
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;
	int a = 16;
	int b = a;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	if(a*b>0){
    	positionX = screenRenderInfo.lowerLeftX;
	}
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}",0,1,12,0.57,Insert
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);
	}
	tmp->entries = gf_list_new();
	GF_MediaBox *mdia;
	struct shash_desc *ref;
	void *img;
	struct sha256_state *ssrx = shash_desc_ctx(ref);
	memcpy(img, ssrx, sizeof(*ssrx));
	u32 sampleDescIndex;
	u32 type;
	GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
	GF_MPEGSampleEntryBox *entry = NULL;
	entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
	type = entry->type;
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}",0,1,41,0.4,Insert
2817,,,,,,,
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");
    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    int a = 2;
    int b = 3;
    if (a != b) {
        Formattable result;
    }
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",1,0,5,0.12,Replace
2822,,,,,,,
2823,,,,,,,
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
	return 0;
}","check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		int a = 2;
		int b = 2;
		while (a == b) {
    		return 1;
    		b += 1;
		}
	}
	return 0;
}",0,1,1,0.06,Replace
2828,"process_abbrev_set (struct dwarf_section *section,
		    unsigned char *start,
		    unsigned char *end)
{
  abbrev_list *list = xmalloc (sizeof (*list));
  list->first_abbrev = NULL;
  list->last_abbrev = NULL;
  while (start < end)
    {
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;
      READ_ULEB (entry, start, end);
      if (start == end || entry == 0)
	{
	  list->start_of_next_abbrevs = start != end ? start : NULL;
	  return list;
	}
      READ_ULEB (tag, start, end);
      if (start == end)
	{
	  free (list);
	  return NULL;
	}
      children = *start++;
      add_abbrev (entry, tag, children, list);
      do
	{
	  unsigned long form;
	  dwarf_signed_vma implicit_const = -1;
	  READ_ULEB (attribute, start, end);
	  if (start == end)
	    break;
	  READ_ULEB (form, start, end);
	  if (start == end)
	    break;
	  if (form == DW_FORM_implicit_const)
	    {
	      READ_SLEB (implicit_const, start, end);
	      if (start == end)
		break;
	    }
	  add_abbrev_attr (attribute, form, implicit_const, list);
	}
      while (attribute != 0);
    }
  error (_(""%s section not zero terminated\n""), section->name);
  free (list);
  return NULL;
}","process_abbrev_set (struct dwarf_section *section,
		    unsigned char *start,
		    unsigned char *end)
{
  abbrev_list *list = xmalloc (sizeof (*list));
  list->first_abbrev = NULL;
  list->last_abbrev = NULL;
  while (start < end)
    {
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;
      READ_ULEB (entry, start, end);
      if (start == end || entry == 0)
	{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	  list->start_of_next_abbrevs = start != end ? start : NULL;
	}
	  return list;
	}
      READ_ULEB (tag, start, end);
      if (start == end)
	{
	  free (list);
	  return NULL;
	}
      children = *start++;
      add_abbrev (entry, tag, children, list);
      do
	{
	  unsigned long form;
	  dwarf_signed_vma implicit_const = -1;
	  READ_ULEB (attribute, start, end);
	  if (start == end)
	    break;
	  READ_ULEB (form, start, end);
	  if (start == end)
	    break;
	  if (form == DW_FORM_implicit_const)
	    {
	      READ_SLEB (implicit_const, start, end);
	      if (start == end)
		break;
	    }
	  add_abbrev_attr (attribute, form, implicit_const, list);
	}
      while (attribute != 0);
    }
  error (_(""%s section not zero terminated\n""), section->name);
  free (list);
  return NULL;
}",1,0,5,0.25,Replace
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	int a = 86;
	int b = a;
	if(a*b>0){
    	struct list_head *l;
	}
	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));
	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		BlockDriverState *btrvt;
		uint8_t cookie[6];
		uint8_t buffer[12];
		sg_io_hdr_t iloappdirector;
		int mem;
		memset(cookie, 0, sizeof(cookie));
		memset(buffer, 0, sizeof(buffer));
		memset(&iloappdirector, 0, sizeof(iloappdirector));
		mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}",0,1,7,0.55,Insert
2831,,,,,,,
2833,,,,,,,
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;
	return &intern->zo;
}","static zend_object *php_zip_object_new(zend_class_entry *class_type)  
{
	ze_zip_object *intern;
	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	int a = 22;
	int b = a;
	if(a*b>0){
    	intern->prop_handler = &zip_prop_handlers;
	}
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;
	return &intern->zo;
}",0,1,1,0.06,Replace
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}","int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }
    if (ecc_sets[x].size == 0) {
        char str[] = ""Constant"";
        while (strlen(str) > 5) {
            WOLFSSL_MSG(""ecc_set curve name not found"");
        strcpy(str, ""a"");
        }
        err = ASN_PARSE_E;
        DisasContext *cms;
        int fee, sh;
        int fee, sh;
        fee = crbD(cms->opcode) >> 2;
        sh = 7 - fee;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }
    return err;
}",0,1,13,0.55,Insert
2836,,,,,,,
2837,,,,,,,
2840,,,,,,,
2844,"bool CServer::IsAuthed(int ClientID) const
{
	return m_aClients[ClientID].m_Authed;
}","bool CServer::IsAuthed(int ClientID) const
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	int a = 2;
	int b = 2;
	if (a == b) {
    	return m_aClients[ClientID].m_Authed;
	}
}",0,1,8,0.21,Insert
2845,"void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}","void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	int a = 2;
	int b = 3;
	MachineState *machine;
	char *filename;
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	long load_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	if (a != b) {
    	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);
	}
	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}",0,1,8,0.41,Insert
2847,"int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        s->state = SSL3_ST_SW_CERT_B;
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}","int ssl3_send_server_certificate(SSL *s)
{
    unsigned long l;
    X509 *x;
    if (s->state == SSL3_ST_SW_CERT_A) {
        x = ssl_get_server_send_cert(s);
        const char
        BlockDriverState *bs;
        SheepdogInode *linade;
        BDRVSheepdogState *s_8 = bs->opaque;
        unsigned int datalen;
        memcpy(&s_8->linade, linade, datalen);
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        char
            *p,
            *xml;
        double
            value;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        content=GetXMLTreeContent(description);
        content=GetXMLTreeContent(levels);
        value=InterpretLocaleValue(content,&p);
        if (x == NULL) {
            if ((s->s3->tmp.new_cipher->algorithm_auth != SSL_aKRB5) ||
                (s->s3->tmp.new_cipher->algorithm_mkey & SSL_kKRB5)) {
                SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE,
                       ERR_R_INTERNAL_ERROR);
                return (0);
            }
        }
        l = ssl3_output_cert_chain(s, x);
        if (!l) {
            SSLerr(SSL_F_SSL3_SEND_SERVER_CERTIFICATE, ERR_R_INTERNAL_ERROR);
            return (0);
        }
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            s->state = SSL3_ST_SW_CERT_B;
        }
        s->init_num = (int)l;
        s->init_off = 0;
    }
    return (ssl3_do_write(s, SSL3_RT_HANDSHAKE));
}",0,1,53,0.85,Insert
2850,"MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    return (checksum == actual_checksum);
}","MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    hwaddr addr;
    int idx;
    DPRINTF(""%s: addr %08x
    "", __func__, addr);
    idx = (addr >> 6) & 0x3;
    std::string actual_checksum = getDataChecksum(buf, len);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return (checksum == actual_checksum);
    }
}",1,0,7,0.26,Insert
2851,,,,,,,
2852,,,,,,,
2853,,,,,,,
2855,"static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}","static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	int a = 2;
	MOVAtom atom;
	int comp_brand_size;
	comp_brand_size = atom.size - 8;
	int b = 2;
	if (a == b) {
    	timer->start_site = NULL;
	}
}",1,0,26,0.28,Insert
2857,,,,,,,
2858,"static void rtrs_clt_reconnect_work(struct work_struct *work)
{
	struct rtrs_clt_path *clt_path;
	struct rtrs_clt_sess *clt;
	unsigned int delay_ms;
	int err;
	clt_path = container_of(to_delayed_work(work), struct rtrs_clt_path,
				reconnect_dwork);
	clt = clt_path->clt;
	if (READ_ONCE(clt_path->state) != RTRS_CLT_RECONNECTING)
		return;
	if (clt_path->reconnect_attempts >= clt->max_reconnect_attempts) {
		rtrs_clt_close_conns(clt_path, false);
		return;
	}
	clt_path->reconnect_attempts++;
	rtrs_clt_stop_and_destroy_conns(clt_path);
	msleep(RTRS_RECONNECT_BACKOFF);
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_CONNECTING, NULL)) {
		err = init_path(clt_path);
		if (err)
			goto reconnect_again;
	}
	return;
reconnect_again:
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_RECONNECTING, NULL)) {
		clt_path->stats->reconnects.fail_cnt++;
		delay_ms = clt->reconnect_delay_sec * 1000;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork,
				   msecs_to_jiffies(delay_ms +
						    prandom_u32() %
						    RTRS_RECONNECT_SEED));
	}
}","static void rtrs_clt_reconnect_work(struct work_struct *work)
{
	struct rtrs_clt_path *clt_path;
	struct rtrs_clt_sess *clt;
	unsigned int delay_ms;
	int err;
	clt_path = container_of(to_delayed_work(work), struct rtrs_clt_path,
				reconnect_dwork);
	clt = clt_path->clt;
	if (READ_ONCE(clt_path->state) != RTRS_CLT_RECONNECTING)
		return;
	if (clt_path->reconnect_attempts >= clt->max_reconnect_attempts) {
		rtrs_clt_close_conns(clt_path, false);
		return;
	}
	clt_path->reconnect_attempts++;
	rtrs_clt_stop_and_destroy_conns(clt_path);
	msleep(RTRS_RECONNECT_BACKOFF);
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_CONNECTING, NULL)) {
		err = init_path(clt_path);
		if (err)
			goto reconnect_again;
	}
	return;
reconnect_again:
	if (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_RECONNECTING, NULL)) {
		clt_path->stats->reconnects.fail_cnt++;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		delay_ms = clt->reconnect_delay_sec * 1000;
		}
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork,
				   msecs_to_jiffies(delay_ms +
						    prandom_u32() %
						    RTRS_RECONNECT_SEED));
	}
}",0,1,2,0.17,Replace
2859,"  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    struct transaction_t *txn;
    struct pxa2xx_pic_state_s *state;
    state = (struct pxa2xx_pic_state_s *)
                qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));
    state->cpu_env = status;
    state->f = f;
    state->int_pending[0] = 0;
    state->int_pending[1] = 0;
    void *params;
    const char *data = NULL;
    char *freeme = NULL;
    struct mime_type_t *mime = NULL;
    struct meth_params *gparams = (struct meth_params *) params;
    void *davdb = NULL, *obj = NULL;
    struct resp_body_t *resp_body = &txn->resp_body;
    if (obj) {
            struct buf *outbuf = mime->from_object(obj);
            datalen = buf_len(outbuf);
            if (txn->meth == METH_GET) data = freeme = buf_release(outbuf);
            buf_destroy(outbuf);
            if (gparams->mime_types[0].free) gparams->mime_types[0].free(obj);
    }
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }",1,0,41,0.57,Insert
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int flags_7;
    	RTPContext *http;
    	char val[1024];
    	if (url_open(&http->rtcp_hd, val, flags_7) < 0)
    	        goto fail;
    	int flags;
	strcpy(str, ""a"");
	}
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;
	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",0,1,5,0.49,Insert
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
	q->nr_rqs[sync]--;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int r;
    	while (_rdrand32_step(&r) == 0);
    	rl->count[sync]--;
	strcpy(str, ""a"");
	}
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;
	__freed_request(rl, sync);
	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",0,1,9,0.42,Insert
2865,"changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	win_T	    *wp;
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	     
    colnr_T	col,	     
    linenr_T	lnume,	     
    long	xtra)	     
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    	win_T	    *wp;
		}
	linenr_T    wlnum;
	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif
    changed_common(lnum, col, lnume, xtra);
}",0,1,1,0.11,Replace
2866,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;
	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}
	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);
	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;
	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}
	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);
	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return retval;
	strcpy(str, ""a"");
	}
}",0,1,1,0.07,Replace
2867,,,,,,,
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        int wb;
        uint32_t lvcall;
        CPUState *env;
        unsigned int valpages;
        uint32_t r_cause;
        int tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t tlb_vpn, tlb_pfn = 0;
        uint32_t pid, lo, hi;
        int set, match = 0;
        r_cause = env->sregs[SFR_R_MM_CAUSE];
        D(printf (""%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x""
        		  "" %x cause=%x sel=%x sp=%x %x %x
        "",
        		  __func__, wb, match, env->pc,
        		  lvcall, valpages,
        		  tlb_vpn, tlb_pfn, tlb_pid, 
        		  pid,
        		  r_cause,
        		  env->sregs[SFR_RW_MM_TLB_SEL],
        		  env->regs[R_SP], env->pregs[PR_USP], env->ksp));
        int a = 2;
        int b = 3;
        if (a != b) {
            return findMetadatum(ed, keys, EXV_COUNTOF(keys));
        }
    }",0,1,13,0.31,Insert
2870,,,,,,,
2871,,,,,,,
2872,"mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	info->sig = sig;
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}","mono_register_jit_icall (gconstpointer func, const char *name, MonoMethodSignature *sig, gboolean is_save)
{
	MonoJitICallInfo *info;
	g_assert (func);
	g_assert (name);
	MachineState *machine;
	AVCodecContext * avnc;
	MP3On4DecodeContext *this = avnc->priv_data;
	MP3On4DecodeContext *this = avnc->priv_data;
	this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
	avnc->channels = mp3Channels[this->chan_cfg];
	avnc->priv_data = this->mp3decctx[0];
	decode_init(avnc);
	avnc->priv_data = this;
	char *filename;
	MemoryRegion *ram = g_new(MemoryRegion, 1);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
	spapr->icp = xics_system_init(machine,
	                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
	                                               smp_threads),
	                                  XICS_IRQS, &error_fatal);
	memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
	                                         machine->ram_size);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = get_image_size(filename);
	spapr->rtas_blob = g_malloc(spapr->rtas_size);
	mono_loader_lock ();
	if (!jit_icall_hash_name) {
		jit_icall_hash_name = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, g_free);
		jit_icall_hash_addr = g_hash_table_new (NULL, NULL);
	}
	if (g_hash_table_lookup (jit_icall_hash_name, name)) {
		g_warning (""jit icall already defined \""%s\""\n"", name);
		g_assert_not_reached ();
	}
	info = g_new0 (MonoJitICallInfo, 1);
	info->name = name;
	info->func = func;
	int a = 2;
	int b = 3;
	while (a != b) {
    	info->sig = sig;
    	b = a;
	}
	if (is_save) {
		info->wrapper = func;
	} else {
		info->wrapper = NULL;
	}
	g_hash_table_insert (jit_icall_hash_name, (gpointer)info->name, info);
	g_hash_table_insert (jit_icall_hash_addr, (gpointer)func, info);
	mono_loader_unlock ();
	return info;
}",0,1,73,0.88,Insert
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	mask |= 1ull;
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
	mask = rsvd_bits(maxphyaddr, 51);
	mask |= 0x3ull << 62;
	int a = 2;
	int b = 3;
	while (a < b) {
    	mask |= 1ull;
    	b = a;
	}
#ifdef CONFIG_X86_64
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
	kvm_mmu_set_mmio_spte_mask(mask);
}",0,1,1,0.06,Replace
2875,"PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}
	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);
	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		RETURN_FALSE;
	}
	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);
	RETURN_TRUE;
}","PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	int a = 2;
	int b = 3;
	while (a < b) {
    	char *filename, buf[1024];
    	b = a;
	}
	int filename_len, n;
	int status;
	struct gg_session *sess;
	const char *descr;
	struct gg_new_status80 p;
	gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
	"", sess, status, descr);
	sess->status = status;
	p.status		= gg_fix32(status);
	p.flags			= gg_fix32(sess->status_flags);
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}
	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t10, t11, t12, t13;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t10, t11, t12, t13;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	t1  =  (s5 * 19266 - s3 * 12873) >> 15;
	t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
	t5  = t1 * 2 + t3;
	t10 = tF - t5;
	t11 = tE - t8;
	context = php_stream_context_from_zval(zcontext, 0);
	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		RETURN_FALSE;
	}
	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);
	RETURN_TRUE;
}",1,0,282,1.78,Insert
2876,"    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      float diff = 0;
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;","    bool _draw_fill(const int x, const int y, const int z,
                    const CImg<T>& ref, const float tolerance2) const {
      const T *ptr1 = data(x,y,z), *ptr2 = ref._data;
      const unsigned long off = _width*_height*_depth;
      XMLTreeInfo
      size_t num_names;
      char *p_6;
      char *ea_namelist = smallbuf;
      for (p_6 = ea_namelist; p_6 - ea_namelist < sizeret; p_6 += strlen(p_6)+1) {
      		num_names += 1;
      }
          *description_1,
          *levels_10,
          *quantization_tables_3,
          *table_iterator_9;
          int r;
          if (r < 0) {
                  goto assigned_out;
          }
      char
          *p,
          *xml;
      quantization_tables_3=NewXMLTree(xml,exception);
      quantization_tables_3=DestroyXMLTree(quantization_tables_3);
      int a = 2;
      int b = 2;
      while (a == b) {
          files_struct *lsp;
          sg_io_hdr_t iloappdirector;
          uint8_t cookie[6];
          uint8_t buffer[12];
          uint8_t kebuffer[8];
          memset(buffer, 0, sizeof(buffer));
          cookie[4] = sizeof(buffer);
          iloappdirector.dxfer_len = sizeof(buffer);
          iloappdirector.dxferp = buffer;
          iloappdirector.mx_sb_len = sizeof(kebuffer);
          const struct dom_sid *group_sid = NULL;
          TALLOC_CTX *frame = talloc_stackframe();
          XMLTreeInfo
              *description,
              *levels,
              *quantization_tables,
              *table_iterator;
          QuantizationTable
              *table;
          if (table->levels == (unsigned int *) NULL)
              ThrowFatalException(ResourceLimitFatalError,
                ""UnableToAcquireQuantizationTable"");
          struct security_descriptor *psd = NULL;
          const struct dom_sid *owner_sid = NULL;
          struct security_descriptor *parent_desc = NULL;
          struct security_token *token = lsp->conn->session_info->security_token;
          status = se_create_child_secdesc(frame,
          			&psd,
          			&size,
          			parent_desc,
          			owner_sid,
          			group_sid,
          			lsp->is_directory);
          float diff = 0;
          b += 1;
      }
      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
      return diff<=tolerance2;",0,1,164,1.17,Insert
2878,"ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  return ArgJoin<wchar_t, It>(first, last, sep);
}","ArgJoin<wchar_t, It> join(It first, It last, const BasicCStringRef<wchar_t>& sep) {
  unsigned long array;
  struct net_bridge_mdb_entry *this = (void *)array;
  struct net_bridge *bridge = this->bridge;
  if (!netif_running(bridge->dev) || timer_pending(&this->timer))
  		goto out;
  int a = 2;
  int b = 3;
  while (a < b) {
      return ArgJoin<wchar_t, It>(first, last, sep);
      b = a;
  }
}",0,1,8,0.26,Insert
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;
	switch (seg) {
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	case VCPU_SREG_CS: return &save->cs;
	strcpy(str, ""a"");
	}
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",0,1,2,0.09,Replace
2882,,,,,,,
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	ram_addr_t gram_size, prom_reset, tcx64off;
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
	              serial_hds[0], ESCC_CLOCK, 1);
	if (strcmp(str1, str2) == 0) {
    	int rc;
	}
	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}",0,1,9,0.39,Insert
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    vars_clear(&fc->l_vars.dv_hashtab);
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}","free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;
    int a = 2;
    int b = 3;
    PutBitContext pb, pb2;
    JLSState *state;
    ls_store_lse(state, &pb);
    av_freep(&state);
    av_freep(&state);
    while (a != b) {
        vars_clear(&fc->l_vars.dv_hashtab);
        b = a;
    }
    vars_clear(&fc->l_avars.dv_hashtab);
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);
    free_funccal(fc);
}",0,1,14,0.34,Insert
2887,,,,,,,
2888,"onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}","onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      size_t
          length;
      table->width=StringToUnsignedLong(attribute);
      table->height=StringToUnsignedLong(attribute);
      table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      param->callout_user_data = user_data;
  strcpy(str, ""a"");
  }
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}",0,1,14,0.24,Insert
2889,,,,,,,
2891,,,,,,,
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        g_string_append (ctx->priv->metadata, "">\n"");
    }
}",0,1,4,0.06,Replace
2893,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  struct transaction_t *txn;
  void *params;
  int ret = 0, r = 0, precond, rights;
  const char *data = NULL;
  struct index_record record;
  const char *etag = NULL;
  struct meth_params *gparams = (struct meth_params *) params;
  void *davdb = NULL, *obj = NULL;
  struct meth_params *gparams = (struct meth_params *) params;
  struct mailbox *mailbox = NULL;
  struct dav_data *ddata;
  struct resp_body_t *resp_body = &txn->resp_body;
  gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                     txn->req_tgt.resource, (void **) &ddata, 0);
  r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
                                  &record, &etag, &lastmod);
  txn->flags.ranges = (ddata->imap_uid != 0);
  precond = gparams->check_precond(txn, params, mailbox,
                                       (void *) ddata, etag, lastmod);
  write_body(precond, txn, data, datalen);
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;
  int a = 2;
  int b = 3;
  while (a < b) {
      string::size_type fdot=domain.find('.');
      b = a;
  }
  if(fdot == string::npos)
    return false;
  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  int templateId;
  CameraMetadata *request;
  const camera_metadata_t *rawRequest;
  ATRACE_BEGIN(""camera3->construct_default_request_settings"");
  rawRequest = mHal3Device->ops->construct_default_request_settings(
          mHal3Device, templateId);
  *request = rawRequest;
  return true;
}",1,0,49,0.65,Insert
2894,"static int fuse_readpage(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int err;
	err = -EIO;
	if (is_bad_inode(inode))
		goto out;
	err = fuse_do_readpage(file, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return err;
}","static int fuse_readpage(struct file *file, struct page *page)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);
	struct inode *inode = page->mapping->host;
	int err;
	err = -EIO;
	if (is_bad_inode(inode))
		goto out;
	err = fuse_do_readpage(file, page);
	int a = 2;
	int b = 3;
	while (a < b) {
    	fuse_invalidate_atime(inode);
    	b = a;
	}
 out:
	unlock_page(page);
	return err;
}",1,0,23,0.45,Insert
2895,,,,,,,
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        c=GetCommandLine();
    strcpy(str, ""a"");
    }
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",0,1,3,0.1,Replace
2898,,,,,,,
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;
	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
	strcpy(str, ""a"");
	}
	bgp_packet_set_size(s);
	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);
	bgp_packet_add(peer, s);
	int size;
	void *opaque;
	int64_t slice;
	const uint8_t *buf;
	QEMUFileBdrv *s_4 = opaque;
	bdrv_pwrite(s_4->bs, s_4->base_offset + slice, buf, size);
	bgp_writes_on(peer);
}",0,1,14,0.34,Insert
2900,,,,,,,
2904,"static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
		struct super_block *sb;
		unsigned long qf_incum[EXT4_MAXQUOTAS] = {
				le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
				le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
				le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
			};
		sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
#endif
	return slab_kset;",0,1,3,0.15,Insert
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	return git_index_add(data->index, conflict);
}","static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);
	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	return git_index_add(data->index, conflict);
	}
}",0,1,8,0.33,Insert
2908,"SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		return;
	}
	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	RETVAL_STRING(hash, 0);
}  ","SPL_METHOD(SplObjectStorage, getHash)
{
	zval *obj;
	char *hash;
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""o"", &obj) == FAILURE) {
		return;
	}
	hash = emalloc(33);
	php_spl_object_hash(obj, hash TSRMLS_CC);
	const page_load_metrics::mojom::PageLoadTiming& timing;
	const page_load_metrics::PageLoadExtraInfo& info;
	bool is_user_initiated_navigation =
	      info.user_initiated_info.browser_initiated ||
	      timing.input_to_navigation_start;
	bool is_user_initiated_navigation =
	      info.user_initiated_info.browser_initiated ||
	      timing.input_to_navigation_start;
	if (timing.paint_timing->largest_image_paint.has_value() &&
	      WasStartedInForegroundOptionalEventInForeground(
	          timing.paint_timing->largest_image_paint, info)) {
	    builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
	        timing.paint_timing->largest_image_paint.value().InMilliseconds());
	}
	RETVAL_STRING(hash, 0);
}  ",1,0,31,0.36,Insert
2909,"check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}","check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    int a = 2;
    int b = 2;
    Rocker *r;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    DescInfo *info;
    uint32_t port;
    int err = ROCKER_OK;
    char *buf = desc_get_buf(info, true);
    struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
    PCIDevice *dev = PCI_DEVICE(r);
    int iovcnt = 0;
    uint32_t pport;
    pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
    err = fp_port_eg(r->fp_port[port], iov, iovcnt);
    if (a == b) {
        return 0;
    }
}",0,1,41,0.34,Insert
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	char str[] = ""Constant"";
	const struct sun4d_hwdef *hawdecl;
	int ret;
	ram_addr_t gram_size, prom_reset, tcx64off;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *esp__set, *les_init;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	qemu_irq *esp__set, *les_init;
	char data[1024];
	cpu_register_physical_memory(hawdecl->slavio_base,
	                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
	                                 TARGET_PAGE_MASK,
	                                 prom_reset | IO_MEM_ROM);
	ret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
	sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
	espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
	                              ioulits[0], &espdma_iraque, &esp__set);
	ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
	                             ioulits[0], &ledma_arquest, &les_init);
	while (strlen(str) > 5) {
    	return rxq->tail == rxq->head;
	strcpy(str, ""a"");
	}
}",0,1,6,0.16,Insert
2915,,,,,,,
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;
  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  int a = 2;
  int b = 2;
  while (a == b) {
      npw_plugin_instance_ref(plugin);
      b += 1;
  }
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  const char
      *attribute,
      *content;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  if (content != (char *) NULL)
      table->description=ConstantString(content);
  npw_plugin_instance_unref(plugin);
  int64_t unit;
  unsigned char c;
  double vals, mul, integral, fraction;
  int64_t retval;
  double vals, mul, integral, fraction;
  mul = suffix_mul(c, unit);
  retval = vals * mul;
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  int nb_oargs;
  int nb_iargs;
  const TCGArg * const args;
  TCGContext *service;
  int rules, nb_regs, ini;
  for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
          if (IS_DEAD_ARG(ini)) {
              temp_dead(service, &service->temps[args[ini]]);
          }
  }
  return ret;
}",0,1,81,0.8,Insert
2920,,,,,,,
2921,,,,,,,
2922,"ModuleExport void UnregisterCALSImage(void)
{
  (void) UnregisterMagickInfo(""CAL"");
  (void) UnregisterMagickInfo(""CALS"");
}","ModuleExport void UnregisterCALSImage(void)
{
  (void) UnregisterMagickInfo(""CAL"");
  int a = 2;
  int b = 3;
  while (a < b) {
      (void) UnregisterMagickInfo(""CALS"");
      VdpDecoderProfile profile;
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                           &pack);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      b = a;
  }
}",0,1,18,0.24,Insert
2925,"cancel_refresh(dns_zone_t *zone) {
	const char me[] = ""cancel_refresh"";
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}","cancel_refresh(dns_zone_t *zone) {
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	const char me[] = ""cancel_refresh"";
    	int nb_iargs;
    	TCGContext *service;
    	size_t call_stack_size;
    	TCGRegSet allocated_regs;
    	int rules, nb_regs, ini;
    	nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);
    	call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);
    	tcg_regset_set(allocated_regs, service->reserved_regs);
	}
	isc_time_t now;
	REQUIRE(DNS_ZONE_VALID(zone));
	REQUIRE(LOCKED_ZONE(zone));
	ENTER;
	DNS_ZONE_CLRFLAG(zone, DNS_ZONEFLG_REFRESH);
	TIME_NOW(&now);
	zone_settimer(zone, &now);
}",0,1,42,0.42,Insert
2926,,,,,,,
2928,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;
	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;
		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);
		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	views::Widget* loader_5;
	DCHECK_EQ_4(loader_5, zoom_widget__7);
	struct pipe_buffer *bufs;
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setLoadsImagesAutomatically(autoLoadImages);
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;
	int a = 2;
	int b = 3;
	if (a != b) {
    	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	}
	if (unlikely(!bufs))
		return -ENOMEM;
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;
		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
			views::Widget* loader;
			multipart_parser_data_t this;
			int i;
			if (this.part[i].content_id)
			        ogs_free(this.part[i].content_id);
			DCHECK_EQ(loader, zoom_widget_);
		else
		int ind;
		const unsigned char *contract;
		if (cout && ind)
		        memcpy_9(cout, contract, ind);
			tail &= (pipe->buffers - 1);
		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}
	pipe->curbuf = 0;
	kfree(pipe->bufs);
	AVFormatContext *s;
	struct google *google = s->priv_data;
	int64_t size, end;
	int64_t size, end;
	size = avio_size(s->pb);
	end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;
	pipe->bufs = bufs;
	struct transaction_t *txn;
	void *params_10;
	int ret = 0, r = 0, precond, rights;
	const char *data = NULL;
	const char *etag = NULL;
	struct meth_params *gparams = (struct meth_params *) params_10;
	struct meth_params *gparams = (struct meth_params *) params_10;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	precond = gparams->check_precond(txn, params_10, mailbox,
	                                     (void *) ddata, etag, lastmod);
	write_body(precond, txn, data, datalen);
	pipe->buffers = nr_pages;
	struct wiphy *wiphy;
	struct station_parameters *params;
	struct ieee80211_local *local = wiphy_priv(wiphy);
	struct sta_info *sta;
	int err;
	err = sta_apply_parameters(local, sta, params);
	err = sta_info_insert_rcu(sta);
	return nr_pages * PAGE_SIZE;
}",1,0,598,3.21,Insert
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		bool bool_var = (reg_node->NodeID == nodeID);
		if (bool_var) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}",0,1,1,0.05,Replace
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);
    cairo_pattern_destroy(p);
    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);
    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);
    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);
    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }
    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);
    int a = 2;
    int (*compare)(const char *, const char *, size_t);
    const char *name1;
    const char *name2;
    int cmp;
    unsigned char c1, mc7;
    cmp = compare(name1, name2, len);
    c1 = name1[len];
    int b = 3;
    while (a != b) {
        cairo_pattern_destroy(p);
        b = a;
    }
    return CAIRO_TEST_SUCCESS;
}",0,1,34,0.67,Insert
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;
	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);
	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);
		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int a = 2;
			int b = 2;
			if (a == b) {
    			int ret;
			}
			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);
			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;
			btrfs_add_raid_kobjects(fs_info);
			return 1;
		}
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		uint32_t input;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpDecoderCreate *create;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VDPAUHWContext *hwctx = AVcas->hwaccel_context;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpBool supported;
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = create(hdtx->device, profile, width, input, AVcas->refs,
		                    &hdtx->decoder);
	}
	return 0;
}",0,1,37,0.64,Insert
2934,"static int raw6_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
}","static int raw6_seq_open(struct inode *inode, struct file *file)
{
	struct delegpt* mp;
	struct delegpt_addr* a_8, *o, *ak;
	a_8 = mp->usable_list;
	int a = 2;
	int b = 2;
	if (a == b) {
    	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
	}
}",0,1,4,0.2,Insert
2935,,,,,,,
2936,,,,,,,
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);
    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;
    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);
    usb_detach(port);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        dev->attached--;
    strcpy(str, ""a"");
    }
    return 0;
}",0,1,9,0.1,Replace
2940,"print_arrays_for(char *set)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", set);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}","print_arrays_for(char *set)
{
  FILE *f;
  sprintf(buf, ""%s.conf"", set);
  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }
  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  FLAC__StreamEncoder *encoder;
  uint32_t samples;
  size_t bytes;
  if(samples > 0) {
  		encoder->private_->streaminfo.data.stream_info.min_framesize = flac_min(bytes, encoder->private_->streaminfo.data.stream_info.min_framesize);
  		encoder->private_->streaminfo.data.stream_info.max_framesize = flac_max(bytes, encoder->private_->streaminfo.data.stream_info.max_framesize);
  }
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");
  fclose(f);
  return;
}",1,0,42,0.62,Insert
2942,"static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t lease_seconds;
	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;
	lease_seconds = get_be32(option);
	if (lease_seconds < 10)
		lease_seconds = 10;
	return lease_seconds;
}","static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t lease_seconds;
	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	lease_seconds = get_be32(option);
	}
	if (lease_seconds < 10)
		lease_seconds = 10;
	return lease_seconds;
}",1,0,4,0.08,Replace
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int wait_for_discard(void *word)
{
	schedule();
	int a = 2;
	int b = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (a == b) {
    	return 0;
	}
}",0,1,10,0.18,Insert
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	struct extent_buffer *t;
	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		int a = 2;
		int b = 2;
		while (a == b) {
    		t = path->nodes[i];
    		b += 1;
		}
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}",0,1,35,0.65,Insert
2949,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }
    fifo8_push(&s->fifo, val);
}","static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
        AVCodecContext *avctx;
        MpegEncContext * const s_3 = avctx->priv_data;
        VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg;
        info->f_code[0][1]               = s_3->mpeg_f_code[0][1];
        info->f_code[1][0]               = s_3->mpeg_f_code[1][0];
        info->f_code[1][1]               = s_3->mpeg_f_code[1][1];
    }
    fifo8_push(&s->fifo, val);
}",1,0,9,0.19,Insert
2950,"sort_wireless_networks (gconstpointer tmpa,
                        gconstpointer tmpb)
{
	NMAccessPoint * a = NM_ACCESS_POINT (tmpa);
	NMAccessPoint * b = NM_ACCESS_POINT (tmpb);
	const GByteArray * a_ssid;
	const GByteArray * b_ssid;
	NM80211Mode a_mode, b_mode;
	int i;
	if (a && !b)
		return 1;
	if (b && !a)
		return -1;
	a_ssid = nm_access_point_get_ssid (a);
	b_ssid = nm_access_point_get_ssid (b);
	if (a_ssid && !b_ssid)
		return 1;
	if (b_ssid && !a_ssid)
		return -1;
	if (a_ssid && b_ssid) {
		for (i = 0; i < MIN(a_ssid->len, b_ssid->len); i++) {
			if (tolower(a_ssid->data[i]) > tolower(b_ssid->data[i]))
				return 1;
			else if (tolower(b_ssid->data[i]) > tolower(a_ssid->data[i]))
				return -1;
		}
		if (a_ssid->len > b_ssid->len)
			return 1;
		if (b_ssid->len > a_ssid->len)
			return -1;
	}
	a_mode = nm_access_point_get_mode (a);
	b_mode = nm_access_point_get_mode (b);
	if (a_mode != b_mode) {
		if (a_mode == NM_802_11_MODE_INFRA)
			return 1;
		return -1;
	}
	return 0;
}","sort_wireless_networks (gconstpointer tmpa,
                        gconstpointer tmpb)
{
	NMAccessPoint * a = NM_ACCESS_POINT (tmpa);
	NMAccessPoint * b = NM_ACCESS_POINT (tmpb);
	const GByteArray * a_ssid;
	const GByteArray * b_ssid;
	NM80211Mode a_mode, b_mode;
	int i;
	if (a && !b)
		return 1;
	if (b && !a)
		return -1;
	a_ssid = nm_access_point_get_ssid (a);
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	b_ssid = nm_access_point_get_ssid (b);
	strcpy(str_1, ""a"");
	}
	if (a_ssid && !b_ssid)
		return 1;
	if (b_ssid && !a_ssid)
		return -1;
	if (a_ssid && b_ssid) {
		for (i = 0; i < MIN(a_ssid->len, b_ssid->len); i++) {
			if (tolower(a_ssid->data[i]) > tolower(b_ssid->data[i]))
				return 1;
			else if (tolower(b_ssid->data[i]) > tolower(a_ssid->data[i]))
				return -1;
		}
		if (a_ssid->len > b_ssid->len)
			return 1;
		if (b_ssid->len > a_ssid->len)
			return -1;
	}
	a_mode = nm_access_point_get_mode (a);
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	ram_addr_t gram_size, prom_reset, tcx64off;
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	escc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],
	              serial_hds[0], ESCC_CLOCK, 1);
	b_mode = nm_access_point_get_mode (b);
	if (a_mode != b_mode) {
		if (a_mode == NM_802_11_MODE_INFRA)
			return 1;
		return -1;
	}
	return 0;
}",0,1,28,0.82,Insert
2951,,,,,,,
2952,"rb_push_glob(VALUE str, int flags)  
{
    long offset = 0;
    VALUE ary;
    GlobPathValue(str, TRUE);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}","rb_push_glob(VALUE str, int flags)  
{
    long offset = 0;
    int a = 2;
    int b = 3;
    while (a < b) {
        VALUE ary;
        b = a;
    }
    DisasContext *ctx;
    int32_t r1;
    r1 = MASK_OP_ABS_S1D(ctx->opcode);
    GlobPathValue(str, TRUE);
    AVFrame *buf;
    AVFilterLink *inlink;
    int i, ret;
    AVFilterLink   *outlink = ctx_9->outputs[0];
    int64_t delta;
    AVFilterContext    *ctx_9 = inlink->dst;
    FPSContext           *s = ctx_9->priv;
    delta = av_rescale_q_rnd(buf->pts - s->pts, inlink->time_base,
                                 outlink->time_base, s->rounding);
    ret = write_to_fifo(s->fifo, buf);
    ary = rb_ary_new();
    while (offset < RSTRING_LEN(str)) {
	DisasContext *ctx_9;
	int32_t r1_3;
	r1_3 = MASK_OP_ABS_S1D_7(ctx_9->opcode);
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }
    return ary;
}",1,0,85,1.12,Insert
2954,"void *Sys_LoadDll(const char *name, qboolean useSystemLib)
{
	void *dllhandle;
	if(useSystemLib)
		Com_Printf(""Trying to load \""%s\""...\n"", name);
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];
		topDir = Sys_BinaryPath();
		if(!*topDir)
			topDir = ""."";
		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);
		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			if(!basePath || !*basePath)
				basePath = ""."";
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	return dllhandle;
}","void *Sys_LoadDll(const char *name, qboolean useSystemLib)
{
	FLAC__StreamEncoder *encoder;
	CPUPPCState *env;
	spr_register(env, SPR_MMUCSR0, ""MMUCSR0"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	spr_register(env, SPR_HIOR, ""SPR_HIOR"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_hior, &spr_write_hior,
	                 0x00000000);
	spr_register(env, SPR_CTRL, ""SPR_CTRL"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	spr_register(env, SPR_UCTRL, ""SPR_UCTRL"",
	                 SPR_NOACCESS, SPR_NOACCESS,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	                 AVFormatContext *s;
	                 int syncword, streamid, reserved, flags, length, pts_flag;
	                 int syncword, streamid, reserved, flags, length, pts_flag;
	                 int syncword, streamid, reserved, flags, length, pts_flag;
	                 AVIOContext *pb = s->pb;
	                 int syncword, streamid, reserved, flags, length, pts_flag;
	                 syncword = avio_rb16(pb);
	                 streamid = avio_r8(pb);
	                 avio_r8(pb);
	                 reserved = avio_r8(pb);
	                 flags    = avio_r8(pb);
	spr_register(env, SPR_VRSAVE, ""SPR_VRSAVE"",
	                 &spr_read_generic, &spr_write_generic,
	                 &spr_read_generic, &spr_write_generic,
	                 0x00000000);
	FLAC__ASSERT(FLAC__bitwriter_is_byte_aligned(encoder->private_->frame));
	FLAC__bitwriter_release_buffer(encoder->private_->frame);
	gchar *str, *str2;
	GstDateTime *dt, *dt2;
	GstDateTime *dt, *dt2;
	g_free (str);
	str = gst_date_time_to_iso8601_string (dt);
	fail_unless (str != NULL);
	fail_unless_equals_string (str, ""2010-10-30T15:50Z"");
	dt2 = gst_date_time_new_from_iso8601_string (str);
	FLAC__bitwriter_clear(encoder->private_->frame);
	void *dllhandle;
	if(useSystemLib)
		Com_Printf(""Trying to load \""%s\""...\n"", name);
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		int a = 2;
		int b = 3;
		while (a < b) {
    		char libPath[MAX_OSPATH];
    		b = a;
		}
		topDir = Sys_BinaryPath();
		if(!*topDir)
			topDir = ""."";
		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);
		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			if(!basePath || !*basePath)
				basePath = ""."";
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	return dllhandle;
}",1,0,179,1.35,Insert
2955,,,,,,,
2956,,,,,,,
2959,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","efind(name)
char *name;
{
	MOVTrack *track;
	AVIOContext *pb;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int version = duration < INT32_MAX ? 0 : 1;
	if (version == 1) {
	        avio_wb64(pb, track->time);
	        avio_wb64(pb, track->time);
	    } else {
	        avio_wb32(pb, track->time);  
	        avio_wb32(pb, track->time);  
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	static char efbuf[100];
	}
	my_regex_t re;
	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	const char *name_2;
	void *cb_data;
	show_object_fn show;
	struct blob *blob;
	struct strbuf *path;
	struct object *obj = &blob->object;
	show(obj, path, name_2, cb_data);
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}",1,0,197,1.11,Insert
2960,,,,,,,
2962,,,,,,,
2963,"bool CModules::OnUserTextMessage(CTextMessage& Message) {
    MODHALTCHK(OnUserTextMessage(Message));
}","bool CModules::OnUserTextMessage(CTextMessage& Message) {
    int a = 2;
    AVPacket * pk;
    AVFormatContext *s;
    int size               =  pk->size;
    AVIOContext *b_1     = s->b_1;
    if (size & 1)
            avio_w8(b_1, 0);
    int b = 3;
    while (a != b) {
        MODHALTCHK(OnUserTextMessage(Message));
        b = a;
    }
}",0,1,3,0.19,Insert
2965,"TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));
  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false);  
  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();
  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}","TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();
  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));
  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false);  
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      EXPECT_CALL(*duration_timer, disableTimer());
  }
  duration_timer->invokeCallback();
  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}",0,1,33,0.51,Insert
2968,"set_completion(colnr_T startcol, list_T *list)
{
    int save_w_wrow = curwin->w_wrow;
    int save_w_leftcol = curwin->w_leftcol;
    int flags = CP_ORIGINAL_TEXT;
    if (ctrl_x_mode_not_default())
	ins_compl_prep(' ');
    ins_compl_clear();
    ins_compl_free();
    compl_direction = FORWARD;
    if (startcol > curwin->w_cursor.col)
	startcol = curwin->w_cursor.col;
    compl_col = startcol;
    compl_length = (int)curwin->w_cursor.col - (int)startcol;
    compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
    if (p_ic)
	flags |= CP_ICASE;
    if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
					      -1, NULL, NULL, NULL, 0,
					      flags | CP_FAST, FALSE) != OK)
	return;
    ctrl_x_mode = CTRL_X_EVAL;
    ins_compl_add_list(list);
    compl_matches = ins_compl_make_cyclic();
    compl_started = TRUE;
    compl_used_match = TRUE;
    compl_cont_status = 0;
    compl_curr_match = compl_first_match;
    if (compl_no_insert || compl_no_select)
    {
	ins_complete(K_DOWN, FALSE);
	if (compl_no_select)
	    ins_complete(K_UP, FALSE);
    }
    else
	ins_complete(Ctrl_N, FALSE);
    compl_enter_selects = compl_no_insert;
    if (!compl_interrupted)
	show_pum(save_w_wrow, save_w_leftcol);
    may_trigger_modechanged();
    out_flush();
}","set_completion(colnr_T startcol, list_T *list)
{
    int save_w_wrow = curwin->w_wrow;
    int save_w_leftcol = curwin->w_leftcol;
    int flags = CP_ORIGINAL_TEXT;
    if (ctrl_x_mode_not_default())
	ins_compl_prep(' ');
    ins_compl_clear();
    ins_compl_free();
    compl_direction = FORWARD;
    if (startcol > curwin->w_cursor.col)
	startcol = curwin->w_cursor.col;
    compl_col = startcol;
    compl_length = (int)curwin->w_cursor.col - (int)startcol;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        compl_orig_text = vim_strnsave(ml_get_curline() + compl_col, compl_length);
    strcpy(str, ""a"");
    }
    if (p_ic)
	flags |= CP_ICASE;
    if (compl_orig_text == NULL || ins_compl_add(compl_orig_text,
					      -1, NULL, NULL, NULL, 0,
					      flags | CP_FAST, FALSE) != OK)
	return;
    ctrl_x_mode = CTRL_X_EVAL;
    ins_compl_add_list(list);
    compl_matches = ins_compl_make_cyclic();
    compl_started = TRUE;
    compl_used_match = TRUE;
    compl_cont_status = 0;
    compl_curr_match = compl_first_match;
    if (compl_no_insert || compl_no_select)
    {
	ins_complete(K_DOWN, FALSE);
	if (compl_no_select)
	    ins_complete(K_UP, FALSE);
    }
    else
	ins_complete(Ctrl_N, FALSE);
    compl_enter_selects = compl_no_insert;
    if (!compl_interrupted)
	show_pum(save_w_wrow, save_w_leftcol);
    may_trigger_modechanged();
    out_flush();
}",0,1,2,0.19,Replace
2971,,,,,,,
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;
  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            int a = 2;
            int b = 3;
            while (a < b) {
                pattern->next = prev;
                b = a;
            }
            break;
          }
    }
}",0,1,3,0.12,Replace
2975,"    CImg<Tfloat> get_resize_object3d() const {
      return CImg<Tfloat>(*this,false).resize_object3d();
    }","    CImg<Tfloat> get_resize_object3d() const {
      int nb_iargs;
      AVCodecContext * avnc;
      MP3On4DecodeContext *this = avnc->priv_data;
      MP3On4DecodeContext *this = avnc->priv_data;
      avnc->priv_data = this;
      this->mp3decctx[0]->adu_mode = 1;
      TCGContext *service;
      struct nbd_request Request;
      uint32_t response;
      response = Request.type & NBD_CMD_MASK_COMMAND;
      size_t call_stack_size;
      TCGRegSet allocated_regs;
      int rules, nb_regs, ini;
      nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);
      call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);
      tcg_regset_set(allocated_regs, service->reserved_regs);
      int a = 35;
      int b = a;
      if(a*b>0){
          return CImg<Tfloat>(*this,false).resize_object3d();
      }
    }",0,1,63,0.38,Insert
2976,,,,,,,
2977,"psutil_users(PyObject *self, PyObject *args) {
    struct utmpx *ut;
    PyObject *py_retlist = PyList_New(0);
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    if (py_retlist == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->ut_tv.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(py_retlist, py_tuple))
            goto error;
        Py_DECREF(py_username);
        Py_DECREF(py_tty);
        Py_DECREF(py_hostname);
        Py_DECREF(py_tuple);
    }
    endutxent();
    return py_retlist;
error:
    Py_XDECREF(py_username);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    Py_DECREF(py_retlist);
    if (ut != NULL)
        endutxent();
    return NULL;
}","psutil_users(PyObject *self, PyObject *args) {
    int a = 2;
    int b = 3;
    if (a != b) {
        struct utmpx *ut;
    }
    PyObject *py_retlist = PyList_New(0);
    PyObject *py_tuple = NULL;
    PyObject *py_username = NULL;
    PyObject *py_tty = NULL;
    PyObject *py_hostname = NULL;
    PyObject *py_user_proc = NULL;
    if (py_retlist == NULL)
        return NULL;
    setutxent();
    while (NULL != (ut = getutxent())) {
        if (ut->ut_type == USER_PROCESS)
            py_user_proc = Py_True;
        else
            py_user_proc = Py_False;
        py_username = PyUnicode_DecodeFSDefault(ut->ut_user);
        if (! py_username)
            goto error;
        py_tty = PyUnicode_DecodeFSDefault(ut->ut_line);
        if (! py_tty)
            goto error;
        py_hostname = PyUnicode_DecodeFSDefault(ut->ut_host);
        if (! py_hostname)
            goto error;
        py_tuple = Py_BuildValue(
            ""(OOOfOi)"",
            py_username,               
            py_tty,                    
            py_hostname,               
            (float)ut->ut_tv.tv_sec,   
            py_user_proc,              
            ut->ut_pid                 
        );
        if (py_tuple == NULL)
            goto error;
        if (PyList_Append(py_retlist, py_tuple))
            goto error;
        Py_DECREF(py_username);
        Py_DECREF(py_tty);
        Py_DECREF(py_hostname);
        Py_DECREF(py_tuple);
    }
    endutxent();
    return py_retlist;
error:
    Py_XDECREF(py_username);
    const char *link_section__names = """";
    Sdb *sdb;
    struct replmd_replicated_request *ar_3;
    struct ldb_request *req_5;
    struct ldb_dn *dn_7;
    int ret_6;
    struct ldb_message *msg_6;
    msg_6 = ldb_msg_new_7(req_5);
    msg_6->dn_7 = dn_7;
    ret_6 = dsdb_module_modify_2(ar_3->module, msg_6,
    				 DSDB_FLAG_OWN_MODULE_5|DSDB_FLAG_REPLICATED_UPDATE_6,
    				 req_5);
    talloc_free_2(msg_6);
    sdb_set (sdb, ""link_section_name"", link_section__names, 0);
    struct replmd_replicated_request *ar;
    struct ldb_request *req;
    struct ldb_dn *dn;
    int ret;
    struct ldb_message *msg;
    msg = ldb_msg_new(req);
    msg->dn = dn;
    ret = dsdb_module_modify(ar->module, msg,
    				 DSDB_FLAG_OWN_MODULE|DSDB_FLAG_REPLICATED_UPDATE,
    				 req);
    talloc_free(msg);
    Py_XDECREF(py_tty);
    Py_XDECREF(py_hostname);
    Py_XDECREF(py_tuple);
    Py_DECREF(py_retlist);
    if (ut != NULL)
        endutxent();
    return NULL;
}",1,0,204,1.57,Insert
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif  
finalize_it:
	DisplayState *ds;
	const struct sun4d_hwdef *hawdecl;
	ram_addr_t gram_size, prom_reset, tcx64off;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
	        *espdma_iraque, *ledma_arquest;
	void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
	tcx64off = qemu_ram_alloc(hawdecl->vram_size);
	tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
	             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
	vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
	                        hawdecl->nvram_size, 8);
	slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
	                          sbi_cpu_arq, smp_cpus);
	slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
	                              nographic, ESCC_CLOCK, 1);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	LEAVE_RELPFUNC;
	}
}",0,1,23,0.59,Insert
2981,,,,,,,
2982,,,,,,,
2983,,,,,,,
2984,,,,,,,
2985,,,,,,,
2986,,,,,,,
2987,"bool CIRCSock::OnNoticeMessage(CNoticeMessage& Message) {
    CString sTarget = Message.GetTarget();
    bool bResult = false;
    if (sTarget.Equals(GetNick())) {
        IRCSOCKMODULECALL(OnPrivNoticeMessage(Message), &bResult);
        if (bResult) return true;
        if (!m_pNetwork->IsUserOnline()) {
            CNoticeMessage Format;
            Format.Clone(Message);
            Format.SetNick(CNick(_NAMEDFMT(Message.GetNick().GetNickMask())));
            Format.SetTarget(""{target}"");
            Format.SetText(""{text}"");
            m_pNetwork->AddNoticeBuffer(Format, Message.GetText());
        }
        return false;
    } else {
        CChan* pChan = m_pNetwork->FindChan(sTarget);
        if (pChan) {
            Message.SetChan(pChan);
            FixupChanNick(Message.GetNick(), pChan);
            IRCSOCKMODULECALL(OnChanNoticeMessage(Message), &bResult);
            if (bResult) return true;
            if (!pChan->AutoClearChanBuffer() || !m_pNetwork->IsUserOnline() ||
                pChan->IsDetached()) {
                CNoticeMessage Format;
                Format.Clone(Message);
                Format.SetNick(_NAMEDFMT(Message.GetNick().GetNickMask()));
                Format.SetTarget(_NAMEDFMT(Message.GetTarget()));
                Format.SetText(""{text}"");
                pChan->AddBuffer(Format, Message.GetText());
            }
        }
        return (pChan && pChan->IsDetached());
    }
}","bool CIRCSock::OnNoticeMessage(CNoticeMessage& Message) {
    CString sTarget = Message.GetTarget();
    bool bResult = false;
    if (sTarget.Equals(GetNick())) {
        IRCSOCKMODULECALL(OnPrivNoticeMessage(Message), &bResult);
        if (bResult) return true;
        if (!m_pNetwork->IsUserOnline()) {
            CNoticeMessage Format;
            Format.Clone(Message);
            Format.SetNick(CNick(_NAMEDFMT(Message.GetNick().GetNickMask())));
            Format.SetTarget(""{target}"");
            Format.SetText(""{text}"");
            m_pNetwork->AddNoticeBuffer(Format, Message.GetText());
        }
        return false;
    } else {
        CChan* pChan = m_pNetwork->FindChan(sTarget);
        if (pChan) {
            char str[] = ""Constant"";
            while (strlen(str) > 5) {
                Message.SetChan(pChan);
            strcpy(str, ""a"");
            }
            FixupChanNick(Message.GetNick(), pChan);
            IRCSOCKMODULECALL(OnChanNoticeMessage(Message), &bResult);
            XMLTreeInfo
                *description,
                *levels,
                *quantization_tables,
                *table_iterator;
            char
                *p,
                *xml;
            xml=FileToString(filename,~0UL,exception);
            quantization_tables=NewXMLTree(xml,exception);
            xml=DestroyString(xml);
            if (bResult) return true;
            if (!pChan->AutoClearChanBuffer() || !m_pNetwork->IsUserOnline() ||
                pChan->IsDetached()) {
                CNoticeMessage Format;
                Format.Clone(Message);
                Format.SetNick(_NAMEDFMT(Message.GetNick().GetNickMask()));
                Format.SetTarget(_NAMEDFMT(Message.GetTarget()));
                Format.SetText(""{text}"");
                pChan->AddBuffer(Format, Message.GetText());
            }
        }
        return (pChan && pChan->IsDetached());
    }
}",0,1,41,0.83,Insert
2988,"      static double mp_log10(_cimg_math_parser& mp) {
        return std::log10(_mp_arg(2));
      }","      static double mp_log10(_cimg_math_parser& mp) {
        char str[] = ""Constant"";
        Rocker *r;
        DescInfo *info;
        struct PCIDevice *pci_dev;
        Error *local_ = NULL;
        AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
        if (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {
                qerror_report_err(local_);
                error_free(local_);
                goto out;
        }
        char *buf = desc_get_buf(info, true);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        char *buf = desc_get_buf(info, true);
        PCIDevice *dev = PCI_DEVICE(r);
        RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
        uint32_t pport;
        rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
        pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
        while (strlen(str) > 5) {
            return std::log10(_mp_arg(2));
        strcpy(str, ""a"");
        }
      }",0,1,48,0.35,Insert
2990,,,,,,,
2991,,,,,,,
2992,"chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];
	text_to_cstring_buffer(a2, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}","chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];
	int a_1 = 2;
	int b_1 = 3;
	while (a_1 != b_1) {
    	text_to_cstring_buffer(a2, str, sizeof(str));
    	b_1 = a_1;
	}
	AVFormatContext *s;
	char playback_time[AV_TIMECODE_STR_SIZE];
	AVIOContext *pb = s->pb;
	AVIOContext *pb = s->pb;
	av_timecode_make_smpte_tc_string(playback_time, avio_rb32(pb), 0);
	av_dict_set(&s->metadata, ""playback_time"", playback_time, 0);
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}",1,0,30,0.38,Insert
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            int a = 2;
            int b = 2;
            if (a == b) {
                Image *image;
                const LayerInfo* layer_info;
                const size_t url;
                MagickOffsetType
                    offset;
                MagickStatusType
                    status;
                if (status == MagickFalse)
                    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
                handler_->handle_url();
            }
        }",0,1,3,0.14,Insert
2994,"static int do_replace(struct net *net, const void __user *user,
		      unsigned int len)
{
	int ret, countersize;
	struct ebt_table_info *newinfo;
	struct ebt_replace tmp;
	if (copy_from_user(&tmp, user, sizeof(tmp)) != 0)
		return -EFAULT;
	if (len != sizeof(tmp) + tmp.entries_size) {
		BUGPRINT(""Wrong len argument\n"");
		return -EINVAL;
	}
	if (tmp.entries_size == 0) {
		BUGPRINT(""Entries_size never zero\n"");
		return -EINVAL;
	}
	if (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /
			NR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))
		return -ENOMEM;
	if (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))
		return -ENOMEM;
	countersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;
	newinfo = vmalloc(sizeof(*newinfo) + countersize);
	if (!newinfo)
		return -ENOMEM;
	if (countersize)
		memset(newinfo->counters, 0, countersize);
	newinfo->entries = vmalloc(tmp.entries_size);
	if (!newinfo->entries) {
		ret = -ENOMEM;
		goto free_newinfo;
	}
	if (copy_from_user(
	   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {
		BUGPRINT(""Couldn't copy entries from userspace\n"");
		ret = -EFAULT;
		goto free_entries;
	}
	ret = do_replace_finish(net, &tmp, newinfo);
	if (ret == 0)
		return ret;
free_entries:
	vfree(newinfo->entries);
free_newinfo:
	vfree(newinfo);
	return ret;
}","static int do_replace(struct net *net, const void __user *user,
		      unsigned int len)
{
	PgSocket *client;
	struct timer_list *cer;
	int t0_6, t1_2, t2_5, t3_8, t4_5, t5_9, t6_5, t7_1, t8_8, t9_10, tA_2, tB_1, tC_1, tD_3, tE_4, tF_8;
	int t0_6, t1_2, t2_5, t3_8, t4_5, t5_9, t6_5, t7_1, t8_8, t9_10, tA_2, tB_1, tC_1, tD_3, tE_4, tF_8;
	int t0_6, t1_2, t2_5, t3_8, t4_5, t5_9, t6_5, t7_1, t8_8, t9_10, tA_2, tB_1, tC_1, tD_3, tE_4, tF_8;
	int s0_6, s1_7, s2_8, s3_8, s4_3, s5_5, s6_3, s7_4;
	int t0_6, t1_2, t2_5, t3_8, t4_5, t5_9, t6_5, t7_1, t8_8, t9_10, tA_2, tB_1, tC_1, tD_3, tE_4, tF_8;
	int s0_6, s1_7, s2_8, s3_8, s4_3, s5_5, s6_3, s7_4;
	int t10_5, t11_7, t12_5, t13_10;
	int s0_6, s1_7, s2_8, s3_8, s4_3, s5_5, s6_3, s7_4;
	int s0_6, s1_7, s2_8, s3_8, s4_3, s5_5, s6_3, s7_4;
	int t10_5, t11_7, t12_5, t13_10;
	int t0_6, t1_2, t2_5, t3_8, t4_5, t5_9, t6_5, t7_1, t8_8, t9_10, tA_2, tB_1, tC_1, tD_3, tE_4, tF_8;
	int t0_6, t1_2, t2_5, t3_8, t4_5, t5_9, t6_5, t7_1, t8_8, t9_10, tA_2, tB_1, tC_1, tD_3, tE_4, tF_8;
	t1_2  =  (s5_5 * 19266 - s3_8 * 12873) >> 15;
	t3_8  = ((s1_7 * 4520  - s7_4 * 22725) >> 15) - t1_2;
	t5_9  = t1_2 * 2 + t3_8;
	t10_5 = tF_8 - t5_9;
	t11_7 = tE_4 - t8_8;
	int currency;
	unsigned long flags;
	struct timer_base *newenprefix, *base;
	struct timer_base *newenprefix, *base;
	AioContext *ctx_4;
	int i, ret_5;
	bool progress;
	if (aio_dispatch(ctx_4, ret_5 > 0)) {
	        progress = true;
	}
	newenprefix = get_timer_cpu_base(cer->flags, currency);
	base = lock_timer_base(cer, &flags);
	spin_unlock_irqrestore(&base->lock, flags);
	const char *username;
	PktBuf *buf;
	int res;
	if (buf) {
			pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
			res = pktbuf_send_immediate(buf, client->link);
			pktbuf_free(buf);
	}
	int a = 2;
	int b = 2;
	if (a == b) {
    	int ret, countersize;
	}
	struct ebt_table_info *newinfo;
	struct ebt_replace tmp;
	if (copy_from_user(&tmp, user, sizeof(tmp)) != 0)
		return -EFAULT;
	if (len != sizeof(tmp) + tmp.entries_size) {
		BUGPRINT(""Wrong len argument\n"");
		return -EINVAL;
	}
	if (tmp.entries_size == 0) {
		BUGPRINT(""Entries_size never zero\n"");
		return -EINVAL;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int s0, s1, s2, s3, s4, s5, s6, s7;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int s0, s1, s2, s3, s4, s5, s6, s7;
		int t10, t11, t12, t13;
		int s0, s1, s2, s3, s4, s5, s6, s7;
		int s0, s1, s2, s3, s4, s5, s6, s7;
		int t10, t11, t12, t13;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
		t1  =  (s5 * 19266 - s3 * 12873) >> 15;
		t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;
		t5  = t1 * 2 + t3;
		t10 = tF - t5;
		t11 = tE - t8;
	}
	if (tmp.nentries >= ((INT_MAX - sizeof(struct ebt_table_info)) /
			NR_CPUS - SMP_CACHE_BYTES) / sizeof(struct ebt_counter))
		return -ENOMEM;
	if (tmp.num_counters >= INT_MAX / sizeof(struct ebt_counter))
		return -ENOMEM;
	countersize = COUNTER_OFFSET(tmp.nentries) * nr_cpu_ids;
	newinfo = vmalloc(sizeof(*newinfo) + countersize);
	if (!newinfo)
		return -ENOMEM;
	if (countersize)
		memset(newinfo->counters, 0, countersize);
	newinfo->entries = vmalloc(tmp.entries_size);
	if (!newinfo->entries) {
		ret = -ENOMEM;
		AVCodecContext *avctx;
		const AVCodec *codec;
		int ret_4;
		TDSCContext *ctx = avctx->priv_data;
		ret_4 = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);
		ret_4 = avcodec_open2(ctx->jpeg_avctx, codec, NULL);
		goto free_newinfo;
	}
	if (copy_from_user(
	   newinfo->entries, tmp.entries, tmp.entries_size) != 0) {
		BUGPRINT(""Couldn't copy entries from userspace\n"");
		ret = -EFAULT;
		goto free_entries;
	}
	ret = do_replace_finish(net, &tmp, newinfo);
	if (ret == 0)
		return ret;
free_entries:
	vfree(newinfo->entries);
free_newinfo:
	vfree(newinfo);
	return ret;
}",1,0,222,1.76,Insert
2996,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif
  static const char* prefixes[] = {""--"", ""-"", ""/""};
  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }
  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }
  return false;
}","bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  int a_1 = 31;
  int b_1 = a_1;
  if(a_1*b_1>0){
      const auto converted = base::WideToUTF8(arg);
  }
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif
  static const char* prefixes[] = {""--"", ""-"", ""/""};
  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }
  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
      if (style->debug != MagickFalse)
          (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",style->filename);
    }
  }
  return false;
}",1,0,22,0.67,Insert
3000,"int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,
		     struct nlmsghdr **answer,
		     nl_ext_ack_fn_t errfn)
{
	return __rtnl_talk(rtnl, n, answer, true, errfn);
}","int rtnl_talk_extack(struct rtnl_handle *rtnl, struct nlmsghdr *n,
		     struct nlmsghdr **answer,
		     nl_ext_ack_fn_t errfn)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct client_session *c;
    	int http_status;
    	struct session_request *sr;
    	struct mk_list *host_list = &config->hosts;
    	struct mk_list *sr_list = &c->request_list;
    	if (http_status > 0) {
    	        if (!sr->host_conf) {
    	            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
    	        }
    	        mk_request_error(http_status, c, sr);
    	        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
    	                            NULL, c, sr);
    	}
    	return __rtnl_talk(rtnl, n, answer, true, errfn);
	}
}",0,1,6,0.23,Insert
3002,,,,,,,
3004,,,,,,,
3005,,,,,,,
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      YR_OBJECT* string_obj;
  strcpy(str, ""a"");
  }
  va_list args;
  va_start(args, field);
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;
  va_end(args);
  if (string_obj == NULL)
    return NULL;
  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);
  return ((YR_OBJECT_STRING*) string_obj)->value;
}",0,1,10,0.14,Replace
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	sp = ((sp + 4) & -16ul) - 4;
#else  
	sp = round_down(sp, 16) - 8;
#endif
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return sp;
	strcpy(str, ""a"");
	}
}",0,1,1,0.05,Replace
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	mutex_lock(&dlci_ioctl_mutex);
	strcpy(str, ""a"");
	}
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}",0,1,5,0.06,Replace
3010,,,,,,,
3011,,,,,,,
3016,,,,,,,
3017,,,,,,,
3020,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    return ff_mov_read_stsd_entries(c, pb, entries);
}","static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;
    DescInfo *info;
    struct f *f;
    int rt;
    if (rt == 1) {
    		ClearPagePrivate(f);
    		set_page_private(f, 0);
    		page_cache_release(f);
    }
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    char *buf = desc_get_buf(info, true);
    char *buf = desc_get_buf(info, true);
    rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    return ff_mov_read_stsd_entries(c, pb, entries);
}",0,1,42,0.37,Insert
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;
	data->type = sample_type;
	header->size += event->id_header_size;
	if (sample_type & PERF_SAMPLE_TID) {
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);
	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);
	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;
	if (sample_type & PERF_SAMPLE_CPU) {
			char str[] = ""Constant"";
			while (strlen(str) > 5) {
    		data->cpu_entry.cpu	 = raw_smp_processor_id();
			strcpy(str, ""a"");
			}
		data->cpu_entry.reserved = 0;
	}
}",0,1,1,0.1,Replace
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	mmu_ctx_t *exec;
	int target_width_bytes;
	if (target_width_bytes != TARGET_PAGE_BITS) {
	        exec->raddr |= (exec->eaddr & ((1 << target_width_bytes) - 1))
	                      & TARGET_PAGE_MASK;
	}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	curwin->w_curswant = curwin->w_virtcol;
	strcpy(str, ""a"");
	}
	curwin->w_set_curswant = FALSE;
    }
}",0,1,8,0.18,Insert
3024,"Http::Context& PerListenerFactoryContextImpl::httpContext() {
  return listener_factory_context_base_->httpContext();
}","Http::Context& PerListenerFactoryContextImpl::httpContext() {
  int a = 2;
  int b = 3;
  Rocker *r;
  DescInfo *info;
  char *buf = desc_get_buf(info, true);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  char *buf = desc_get_buf(info, true);
  PCIDevice *dev = PCI_DEVICE(r);
  RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
  uint32_t pport;
  rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  if (a != b) {
      return listener_factory_context_base_->httpContext();
  }
}",0,1,16,0.19,Insert
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	int a = 2;
	int b = 3;
	if (a != b) {
    	srs->separator = value;
	}
	return SRS_SUCCESS;
}",0,1,1,0.04,Replace
3030,,,,,,,
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int a = 2;
    int b = 3;
    while (a < b) {
        int x;
        b = a;
    }
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",0,1,1,0.05,Replace
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	int a = 2;
	int b = 3;
	while (a != b) {
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	size_t
    	    length;
    	table->width=StringToUnsignedLong(attribute);
    	table->height=StringToUnsignedLong(attribute);
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	length=(size_t) table->width*table->height;
    	table->levels=(unsigned int *) AcquireQuantumMemory(length,
    	    sizeof(*table->levels));
    	get_c_jd(x);
    	b = a;
	}
	return x->c.sg;
    }
}",0,1,15,0.3,Insert
3033,"GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
	ptr->size += 8;
	return GF_OK;
}","GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	CPUState *env;
	const sigset_t *sigset;
	struct kvm_signal_mask * sigmak;
	int r;
	sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
	sigmak->len = 8;
	memcpy_5( sigmak->sigset, sigset, sizeof(*sigset));
	r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
	free( sigmak);
	char str[] = ""Constant"";
	uint8_t *fig;
	VirtIODevice *vrdevice;
	struct virtio_blk_config blkcfg;
	VirtIOBlock *s_7 = VIRTIO_BLK(vrdevice);
	blkcfg.alignment_offset = 0;
	blkcfg.wce = bdrv_enable_write_cache(s_7->bs);
	memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
	while (strlen(str) > 5) {
    	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
	strcpy(str, ""a"");
	}
	ptr->size += 8;
	return GF_OK;
}",0,1,42,0.35,Insert
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;
	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;
	lc = (struct tipc_link_config *)TLV_DATA(msg->req);
	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;
	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;
	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;
	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);
	int a = 21;
	int b = a;
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	if(a*b>0){
    	return 0;
	}
}",0,1,23,0.56,Insert
3035,,,,,,,
3039,"bool CIRCSock::OnPingMessage(CMessage& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}","bool CIRCSock::OnPingMessage(CMessage& Message) {
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    int a = 2;
    int b = 3;
    while (a != b) {
        PutBitContext pb, pb2;
        JLSState *state;
        int i, size, ure;
        PutBitContext pb, pb2;
        ls_store_lse(state, &pb);
        put_bits(&pb2, 7, 0);
        size = put_bits_count(&pb2);
        flush_put_bits(&pb2);
        avpriv_align_put_bits(&pb);
        return true;
        b = a;
    }
}",0,1,6,0.21,Insert
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
	return ret;
}","static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;
	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;
		char *filename;
		long load_limit, rtas_limit, fw_size;
		if (fw_size < 0) {
		        hw_error(""qemu: could not load LPAR rtas '%s'
		"", filename);
		        exit(1);
		}
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);
	strcpy(str, ""a"");
	}
	return ret;
}",0,1,14,0.32,Insert
3046,,,,,,,
3047,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  char str[] = ""Constant"";
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  void *pack;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                       &pack);
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  while (strlen(str) > 5) {
      return 0;
  strcpy(str, ""a"");
  }
}",0,1,6,0.33,Insert
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void setWriteFlags(folly::WriteFlags flags) {
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        int flags_5;
        int port, is_output, ttl, remote_host;
        is_output = (flags_5 & URL_WRONLY);
        writeFlags = flags;
    strcpy(str, ""a"");
    }
  }",0,1,3,0.16,Insert
3049,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;
	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);
	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	exsltDateValDatePtr r_8, d_8;
	if (d_8->day == 0)
	        d_8->day = 1;
	int r = EMULATE_DONE;
	exsltDateValDatePtr r_8, d;
	if (d->day == 0)
	        d->day = 1;
	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		int a = 2;
		int b = 3;
		if (a != b) {
    		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		}
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);
	return r;
}",1,0,67,0.53,Insert
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        bool have_ok = tmp.hasField(""ok"");
    }
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");
    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);
    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}",0,1,17,0.35,Insert
3054,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	int a = 2;
	int b = 3;
	MagickCLEnv clConv;
	dnotes(cl_device_id *) AcquireQuantumMemory(clConv->number64flows,
	    sizeof(cl_device_id));
	cl_uint
	    o,
	    sync,
	    max,
	    number64flows,
	    number_platforms;
	cl_platform_id
	    *platforms;
	cl_uint
	    o,
	    sync,
	    max,
	    number64flows,
	    number_platforms;
	cl_uint
	    o,
	    sync,
	    max,
	    number64flows,
	    number_platforms;
	for (o = 0; o < number_platforms; o++)
	  {
	    nnumber64flowsGetOpenCLDeviceCount(clConv,platforms[o]);
	    if (number64flows == 0)
	      platforms[o]=(cl_platform_id) NULL;
	    else
	      clConv->number64flows+=number64flows;
	}
	while (a < b) {
    	bool acquiring = !queue_isempty(chrc->pending_writes);
    	b = a;
	}
	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);
	if (acquiring)
		return op;
	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;
	pending_op_free(op);
	return NULL;
}",1,0,20,0.6,Insert
3056,,,,,,,
3057,"static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
	line6->disconnect = line6_toneport_disconnect;
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}
	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}
	err = toneport_setup(toneport);
	if (err)
		return err;
	return snd_card_register(line6->card);
}","static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net = sock_net(skb->sk);
	struct tipc_sock *tsk;
	u32 tsk_portid = cb->args[0];
	int err_5;
	err_5 = __tipc_nl_list_sk_publ(skb, cb, tsk, &last_publ);
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	toneport->type = id->driver_info;
	}
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);
	line6->disconnect = line6_toneport_disconnect;
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}
	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);
	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}
	err = toneport_setup(toneport);
	if (err)
		return err;
	return snd_card_register(line6->card);
}",1,0,17,0.77,Insert
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	u8 enable_bitmap = 0;
    	b = a;
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;
	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",0,1,10,0.29,Insert
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	int a = 2;
	int b = 3;
	PutBitContext pb, pb2;
	JLSState *state;
	ls_store_lse(state, &pb);
	av_freep(&state);
	av_freep(&state);
	while (a != b) {
    	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
    	b = a;
	}
}",0,1,4,0.19,Insert
3061,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}","process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;
	rd_create_ui();
	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);
	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);
	rdp_send_confirm_active();
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	rdp_send_synchronise();
	}
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_recv(&type);	 
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);
	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}
	rdp_recv(&type);	 
	reset_order_state();
}",1,0,23,0.27,Replace
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };
    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);
    int a = 7;
    int b = a;
    if(a*b>0){
        return p;
    }
}",0,1,1,0.08,Replace
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	 
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	timer_event = NULL;
	strcpy(str, ""a"");
	}
	timer_thread = NULL;
}",0,1,6,0.11,Replace
3067,,,,,,,
3068,"static struct file *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int refs)
{
	struct file *file;
	rcu_read_lock();
loop:
	file = files_lookup_fd_rcu(files, fd);
	if (file) {
		if (file->f_mode & mask)
			file = NULL;
		else if (!get_file_rcu_many(file, refs))
			goto loop;
	}
	rcu_read_unlock();
	return file;
}","static struct file *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int refs)
{
	struct file *file;
	int a = 2;
	int b = 3;
	while (a < b) {
    	rcu_read_lock();
    	b = a;
	}
loop:
	file = files_lookup_fd_rcu(files, fd);
	if (file) {
		AVCodec *c;
		AVCodec *c_3;
		int encoder_8;
		const char *codec_string_1 = encoder_8 ? ""encoder"" : ""decoder"";
		const char *codec_string_1 = encoder_8 ? ""encoder"" : ""decoder"";
		AVCodec *codec_5;
		av_log_4(NULL, AV_LOG_FATAL_4, ""%s '%s' is experimental and might produce bad ""
		            ""results.
		Add_8 '-strict_6 experimental_9' if_7 you_5 want_4 to_1 use_6 it_5.
		"",
		            codec_string_1, c_3->name);
		codec_5 = encoder_8 ? avcodec_find_encoder_2(c_3->id) : avcodec_find_decoder_1(c_3->id);
		int encoder;
		const char *codec_string = encoder ? ""encoder"" : ""decoder"";
		const char *codec_string = encoder ? ""encoder"" : ""decoder"";
		AVCodec *codec;
		av_log(NULL, AV_LOG_FATAL, ""%s '%s' is experimental and might produce bad ""
		            ""results.
		Add '-strict experimental' if you want to use it.
		"",
		            codec_string, c->name);
		codec = encoder ? avcodec_find_encoder(c->id) : avcodec_find_decoder(c->id);
		if (file->f_mode & mask)
			file = NULL;
		else if (!get_file_rcu_many(file, refs))
			goto loop;
	}
	rcu_read_unlock();
	return file;
}",1,0,41,0.57,Insert
3069,"bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;
	SKIPJACKEncryption enc;   
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;
	SKIPJACKDecryption dec;   
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";
	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}","bool ValidateSKIPJACK()
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	strcpy(str, ""a"");
	}
	bool pass1 = true, pass2 = true;
	SKIPJACKEncryption enc;   
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;
	SKIPJACKDecryption dec;   
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";
	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}",0,1,39,0.27,Replace
3070,"bool jswrap_graphics_idle() {
  graphicsIdle();
  return false;
}","bool jswrap_graphics_idle() {
  int a = 2;
  int b = 3;
  while (a != b) {
      graphicsIdle();
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      size_t
          length;
      table->width=StringToUnsignedLong(attribute);
      table->height=StringToUnsignedLong(attribute);
      table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      b = a;
  }
  return false;
}",0,1,23,0.25,Insert
3071,,,,,,,
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	result = tcf_classify(skb, fl, &res, false);
	}
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		GF_BitStream *bs;
		GF_Box *s;
		FilePartitionBox *inter = (FilePartitionBox *)s;
		ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
		inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
		inter->packet_payload_size = gf_bs_read_u16(bs);
		inter->FEC_encoding_ID = gf_bs_read_u8(bs);
		inter->FEC_instance_ID = gf_bs_read_u16(bs);
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}",0,1,18,0.43,Insert
3074,,,,,,,
3075,,,,,,,
3076,"     \param user_path Specified path, or \c 0 to get the path currently used.
     \param reinit_path Force path to be recalculated (may take some time).
     \return Path containing the \c gzip binary.
  **/
  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {
    static CImg<char> s_path;
    cimg::mutex(7);
    if (reinit_path) s_path.assign();
    if (user_path) {
      if (!s_path) s_path.assign(1024);
      std::strncpy(s_path,user_path,1023);
    } else if (!s_path) {
      s_path.assign(1024);
      bool path_found = false;
      std::FILE *file = 0;
#if cimg_OS==2
      if (!path_found) {
        std::strcpy(s_path,"".\\gzip.exe"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip.exe"");
#else
      if (!path_found) {
        std::strcpy(s_path,""./gzip"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip"");
#endif
      winformat_string(s_path);","     \param user_path Specified path, or \c 0 to get the path currently used.
     \param reinit_path Force path to be recalculated (may take some time).
     \return Path containing the \c gzip binary.
  **/
  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {
    static CImg<char> s_path;
    cimg::mutex(7);
    if (reinit_path) s_path.assign();
    if (user_path) {
      if (!s_path) s_path.assign(1024);
      std::strncpy(s_path,user_path,1023);
    } else if (!s_path) {
      s_path.assign(1024);
      bool path_found = false;
      std::FILE *file = 0;
#if cimg_OS==2
      if (!path_found) {
        std::strcpy(s_path,"".\\gzip.exe"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      bool bool_var = (!path_found);
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
          GetBitContext *db;
          int profile_lengtho, level_idc, constraint_set_flags = 0;
          unsigned maxpages;
          size_t *start;
          struct iov_iter *i;
          unsigned int iter_head, npages;
          unsigned int iter_head, npages;
          size_t capacity;
          data_start(i, &iter_head, start);
          capacity = min(npages, maxpages) * PAGE_SIZE - *start;
          SPS * spr;
          profile_lengtho           = get_bits(db, 8);
          spr->profile_lengtho          = profile_lengtho;
      char
          *p,
          *xml;
      xml=FileToString(filename,~0UL,exception);
      quantization_tables=NewXMLTree(xml,exception);
      if (bool_var) std::strcpy(s_path,""gzip.exe"");
      bool use_pubs;
      const struct smb_filename *smb_fhandle;
      uint32_t access_mask;
      struct connection_struct *connected;
      uint32_t rejected_mask = access_mask;
      voidpf timeout;
      timeout=RelinquishMagickMemory(timeout);
      struct security_descriptor *sd = NULL;
      NTSTATUS success;
      success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
      			(SECINFO_OWNER |
      			SECINFO_GROUP |
      			 SECINFO_DACL), talloc_tos(), &sd);
      success = se_file_access_check(sd,
      				get_current_nttok(connected),
      				use_pubs,
      				(access_mask & ~do_not_check_mask),
      				&rejected_mask);
      TALLOC_FREE(sd);
#else
      if (!path_found) {
        BlockdevOnError on_source_bug;
        BlockdevOnError on_source_complete;
        const char *dev;
        enum MirrorSyncMode stage;
        int64_t peed;
        const char *data;
        int data;
        Error *localxer = NULL;
        BlockDriverState *source_vs;
        int64_t store;
        BlockDriverState *bes;
        bes = bdrv_find(dev);
        data = bes->open_flags | BDRV_O_RDWR;
        store = bdrv_getlength(bes);
        backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                         block_job_cb, bes, &localxer);
        std::strcpy(s_path,""./gzip"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip"");
#endif
      winformat_string(s_path);",0,1,372,2.32,Insert
3077,,,,,,,
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    int a = 2;
    int b = 2;
    const char *nptr;
    double vals, mul, integral, fraction;
    char *ndpointer;
    unsigned char c;
    vals = strtod(nptr, &ndpointer);
    c = *ndpointer;
    if (a == b) {
        return 0;
    }
}",0,1,8,0.24,Insert
3080,,,,,,,
3081,"static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
}","static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
    	b = a;
    	Image *image;
    	const LayerInfo* layer_info;
    	const size_t url;
    	MagickOffsetType
    	    offset;
    	MagickStatusType
    	    status;
    	if (status == MagickFalse)
    	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	}
}",0,1,3,0.27,Insert
3083,"gpg_export_keys_sync (CamelCipherContext *context,
                      GPtrArray *keys,
                      CamelStream *ostream,
                      GCancellable *cancellable,
                      GError **error)
{
	struct _GpgCtx *gpg;
	gboolean success = FALSE;
	gint i;
	gpg = gpg_ctx_new (context);
	gpg_ctx_set_mode (gpg, GPG_CTX_MODE_EXPORT);
	gpg_ctx_set_armor (gpg, TRUE);
	gpg_ctx_set_ostream (gpg, ostream);
	for (i = 0; i < keys->len; i++) {
		gpg_ctx_add_recipient (gpg, keys->pdata[i]);
	}
	if (!gpg_ctx_op_start (gpg, error))
		goto fail;
	while (!gpg_ctx_op_complete (gpg)) {
		if (gpg_ctx_op_step (gpg, cancellable, error) == -1) {
			gpg_ctx_op_cancel (gpg);
			goto fail;
		}
	}
	if (gpg_ctx_op_wait (gpg) != 0) {
		const gchar *diagnostics;
		diagnostics = gpg_ctx_get_diagnostics (gpg);
		g_set_error (
			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC, ""%s"",
			(diagnostics != NULL && *diagnostics != '\0') ?
			diagnostics : _(""Failed to execute gpg.""));
		goto fail;
	}
	success = TRUE;
fail:
	gpg_ctx_free (gpg);
	return success;
}","gpg_export_keys_sync (CamelCipherContext *context,
                      GPtrArray *keys,
                      CamelStream *ostream,
                      GCancellable *cancellable,
                      GError **error)
{
	struct _GpgCtx *gpg;
	gboolean success = FALSE;
	gint i;
	gpg = gpg_ctx_new (context);
	int a = 2;
	int b = 3;
	while (a != b) {
    	gpg_ctx_set_mode (gpg, GPG_CTX_MODE_EXPORT);
    	b = a;
	}
	gpg_ctx_set_armor (gpg, TRUE);
	gpg_ctx_set_ostream (gpg, ostream);
	for (i = 0; i < keys->len; i++) {
		gpg_ctx_add_recipient (gpg, keys->pdata[i]);
	}
	if (!gpg_ctx_op_start (gpg, error))
		goto fail;
	while (!gpg_ctx_op_complete (gpg)) {
		if (gpg_ctx_op_step (gpg, cancellable, error) == -1) {
			gpg_ctx_op_cancel (gpg);
			goto fail;
		}
	}
	if (gpg_ctx_op_wait (gpg) != 0) {
		const gchar *diagnostics;
		diagnostics = gpg_ctx_get_diagnostics (gpg);
		g_set_error (
			error, CAMEL_ERROR, CAMEL_ERROR_GENERIC, ""%s"",
			(diagnostics != NULL && *diagnostics != '\0') ?
			diagnostics : _(""Failed to execute gpg.""));
		goto fail;
	}
	success = TRUE;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	xml=FileToString(filename,~0UL,exception);
	quantization_tables=NewXMLTree(xml,exception);
	xml=DestroyString(xml);
fail:
	gpg_ctx_free (gpg);
	return success;
}",0,1,27,0.94,Insert
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  struct ldb_context *ydm;
  const char *attr;
  const struct ldb_schema_attribute *a_10;
  a_10 = ldb_schema_attribute_by_name(ydm, attr);
  assert(status != NULL);
  int a = 78;
  int b = a;
  if(a*b>0){
      *status = parser->m_parsingStatus;
  }
}",0,1,5,0.23,Insert
3086,"static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;
      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);
      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}","static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;
      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);
      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
		      Parse *pParse;
		      int jumpIfNull;
		      Expr *pLeft;
		      Expr *pRight;
		      int p5;
		      p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
		      sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
    }
    struct sock *shop;
    const struct dst_entry *dst = __sk_dst_get(shop);
    struct tcp_sock *tp = tcp_sk(shop);
    if (sock_net(shop)->ipv4.sysctl_tcp_timestamps)
    		tp->tcp_header_len += TCPOLEN_TSTAMP_ALIGNED;
  }
  zrleOutStreamFlush(os);
}",1,0,51,1.01,Insert
3087,"nautilus_file_list_free (GList *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}","nautilus_file_list_free (GList *list)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	const char
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
    	table->slot=(char *) NULL;
    	table->description=(char *) NULL;
    	table->levels=(unsigned int *) NULL;
    	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
    	nautilus_file_list_unref (list);
	}
	g_list_free (list);
}",0,1,9,0.2,Insert
3090,,,,,,,
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","mono_class_has_default_constructor (MonoClass *klass)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	GF_Filter *process;
	GF_FilterPid *pid;
	CTXLoadPriv *git = gf_filter_get_udta(process);
	const GF_PropertyValue *proc;
	gf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );
	gf_filter_pid_set_udta(pid, git->out_pid);
	proc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);
	if (strcmp(str1, str2) == 0) {
    	MonoMethod *method;
	}
	int i;
	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;
	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			const char
			    *attribute,
			    *content;
			    bool lock;
			    struct request_list *repl;
			    struct request_queue *q = repl->q;
			    q->nr_rqs[lock]--;
			XMLTreeInfo
			struct irda_sock *data;
			discinfo_t *discovery;
			int	code;
			discovery = irlmp_get_discoveries(&code, data->mask.word,
								    data->nslots);
			    *description,
			    *levels,
			    *quantization_tables,
			    *table_iterator;
			QuantizationTable
			    *table;
			size_t
			    length;
			content=GetXMLTreeContent(levels);
			table->levels=(unsigned int *) AcquireQuantumMemory(length,
			    sizeof(*table->levels));
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}",0,1,178,1.12,Insert
3095,"static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    return 1;
}","static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    int a = 93;
    int b = a;
    if(a*b>0){
        return 1;
    }
}",0,1,1,0.03,Replace
3096,,,,,,,
3098,"typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;
    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}","typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    void *rma = NULL;
    AVCodecContext *ajcas;
    DCAContext *s = ajcas->priv_data;
    int num_core_channels = 0;
    int channels, full_channels;
    int channels, full_channels;
    num_core_channels = s->prim_channels;
    full_channels = channels = s->prim_channels + !!s->lfe;
    hwaddr rma_alloc_size;
    MemoryRegion *sysmem = get_system_memory();
    MemoryRegion *rma_region;
    if (rma_alloc_size && rma) {
            rma_region = g_new(MemoryRegion, 1);
            memory_region_init_ram_ptr(rma_region, NULL, ""ppc_spapr.rma"",
                                       rma_alloc_size, rma);
            vmstate_register_ram_global(rma_region);
            memory_region_add_subregion(sysmem, 0, rma_region);
    }
    int	    val;
    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	int a = 2;
	int b = 3;
	if (a != b) {
    	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	}
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}",0,1,63,0.94,Insert
3104,,,,,,,
3105,"sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
{	SF_PRIVATE 	*psf ;
	if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;
	psf_init_files (psf) ;
	psf->virtual_io = SF_TRUE ;
	psf->vio = *sfvirtual ;
	psf->vio_user_data = user_data ;
	psf->file.mode = mode ;
	return psf_open_file (psf, sfinfo) ;
}  ","sf_open_virtual	(SF_VIRTUAL_IO *sfvirtual, int mode, SF_INFO *sfinfo, void *user_data)
{	SF_PRIVATE 	*psf ;
WebKitWebView* webView;
struct net *net;
struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
struct timeval t1, t2;
struct timeval t1, t2;
gettimeofday(&t1, NULL);
t2 = tsub(t2, t1);
struct ctl_table *table;
Expr *pRight;
int jumpIfNull;
Expr *pLeft;
int p5;
struct net_4 *net_4;
struct nf_conntrack_net *cnet_5 = net_generic_3(net_4, nf_conntrack_net_id_9);
struct ctl_table *table_2;
table_2[NF_SYSCTL_CT_ACCT_1].data = &net_4->ct.sysctl_acct;
table_2[NF_SYSCTL_CT_HELPER_4].data = &net_4->ct.sysctl_auto_assign_helper;
table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC_4].data = &nf_generic_pernet_5(net_4)->timeout;
table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP_9].data = &nf_icmp_pernet_2(net_4)->timeout;
table_2[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6_1].data = &nf_icmpv6_pernet_2(net_4)->timeout;
p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
table[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;
table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
WriterContext *w;
int in_program;
writer_print_section_header(w, in_program ? SECTION_ID_PROGRAM_STREAM : SECTION_ID_STREAM);
table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
Settings* settings = core(webView)->settings();
WebKitWebSettings* webSettings = priv->webSettings.get();
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
WebKitEditingBehavior editingBehavior;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
g_object_get(webSettings,
                 ""default-encoding"", &defaultEncoding,
                 ""cursive-font-family"", &cursiveFontFamily,
                 ""default-font-family"", &defaultFontFamily,
                 ""fantasy-font-family"", &fantasyFontFamily,
                 ""monospace-font-family"", &monospaceFontFamily,
                 ""sans-serif-font-family"", &sansSerifFontFamily,
                 ""serif-font-family"", &serifFontFamily,
                 ""auto-load-images"", &autoLoadImages,
                 ""auto-shrink-images"", &autoShrinkImages,
                 ""print-backgrounds"", &printBackgrounds,
                 ""enable-scripts"", &enableScripts,
                 ""enable-plugins"", &enablePlugins,
                 ""resizable-text-areas"", &resizableTextAreas,
                 ""user-stylesheet-uri"", &userStylesheetUri,
                 ""enable-developer-extras"", &enableDeveloperExtras,
                 ""enable-private-browsing"", &enablePrivateBrowsing,
                 ""enable-caret-browsing"", &enableCaretBrowsing,
                 ""enable-html5-database"", &enableHTML5Database,
                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                 ""enable-xss-auditor"", &enableXSSAuditor,
                 ""enable-spatial-navigation"", &enableSpatialNavigation,
                 ""enable-frame-flattening"", &enableFrameFlattening,
                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                 ""editing-behavior"", &editingBehavior,
                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                 ""enable-dom-paste"", &enableDOMPaste,
                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                  ""enable-page-cache"", &usePageCache,
                  ""enable-java-applet"", &enableJavaApplet,
                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                  ""enable-fullscreen"", &enableFullscreen,
                  ""enable-dns-prefetching"", &enableDNSPrefetching,
                 ""enable-webgl"", &enableWebGL,
                 NULL);
settings->setShrinksStandaloneImagesToFit(autoShrinkImages);
	if (sfvirtual->get_filelen == NULL || sfvirtual->seek == NULL || sfvirtual->tell == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		int a = 2;
		int b = 3;
		while (a < b) {
    		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_get_filelen / vio_seek / vio_tell in SF_VIRTUAL_IO struct.\n"") ;
    		b = a;
		}
		return NULL ;
		} ;
	if ((mode == SFM_READ || mode == SFM_RDWR) && sfvirtual->read == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_read in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((mode == SFM_WRITE || mode == SFM_RDWR) && sfvirtual->write == NULL)
	{	sf_errno = SFE_BAD_VIRTUAL_IO ;
		snprintf (sf_parselog, sizeof (sf_parselog), ""Bad vio_write in SF_VIRTUAL_IO struct.\n"") ;
		return NULL ;
		} ;
	if ((psf = calloc (1, sizeof (SF_PRIVATE))) == NULL)
	{	sf_errno = SFE_MALLOC_FAILED ;
		return	NULL ;
		} ;
	psf_init_files (psf) ;
	psf->virtual_io = SF_TRUE ;
	psf->vio = *sfvirtual ;
	psf->vio_user_data = user_data ;
	psf->file.mode = mode ;
	return psf_open_file (psf, sfinfo) ;
}  ",1,0,388,2.57,Insert
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	int a = 2;
	int b = 2;
	while (a == b) {
    	return(exp(x) - 1);
    	b += 1;
	}
#endif
}",0,1,2,0.05,Replace
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int acp_early_init(void *handle)
{
	int a = 2;
	int b = 3;
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	if (a != b) {
    	return 0;
	}
}",0,1,3,0.14,Insert
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void ecryptfs_free_kmem_caches(void)
{
	int i;
	GetBitContext *db;
	SPS * spr;
	int profile_lengtho, level_idc, constraint_set_flags = 0;
	constraint_set_flags |= get_bits1(db) << 5;
	spr->constraint_set_flags = constraint_set_flags;
	rcu_barrier();
	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;
		int a = 2;
		int b = 3;
		while (a < b) {
    		info = &ecryptfs_cache_infos[i];
    		b = a;
		}
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}",0,1,30,0.48,Insert
3116,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }
  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  Rocker *r;
  DescInfo *info;
  uint32_t port;
  int err = ROCKER_OK;
  char *buf_6 = desc_get_buf(info, true);
  struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
  PCIDevice *dev = PCI_DEVICE(r);
  int iovcnt = 0;
  uint32_t pport;
  pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
  err = fp_port_eg(r->fp_port[port], iov, iovcnt);
  int a = 2;
  int b = 3;
  if (a != b) {
      my_user_data *ud = user_data;
  }
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }
  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}",0,1,10,0.38,Insert
3117,,,,,,,
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	AVFilterContext *ctx;
	GradFunContext *gf = ctx->priv;
	int radius = 16;
	float thresh = 1.2;
	GradFunContext *gf = ctx->priv;
	gf->radius = av_clip((radius + 1) & ~1, 4, 32);
	av_log(ctx, AV_LOG_VERBOSE, ""threshold:%.2f radius:%d
	"", thresh, gf->radius);
	int a = 2;
	int b = 2;
	while (a == b) {
    	jas_eprintf(""warning: support for signed data is untested\n"");
    	b += 1;
	}
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	MPTSASState *s;
	hwaddr addr;
	int status;
	MPTSASRequest *req;
	status = mptsas_build_sgl(s, req, addr);
	return result;
}",1,0,156,1.02,Insert
3120,"void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)
{
  THandles OtherInstances;
  FindOtherInstances(OtherInstances);
  THandles::const_iterator I = OtherInstances.begin();
  while (I != OtherInstances.end())
  {
    HWND Handle = *I;
    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::RefreshPanel;
    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));
    NULL_TERMINATE(Message.Refresh.Session);
    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));
    NULL_TERMINATE(Message.Refresh.Path);
    SendCopyDataMessage(Handle, Message);
    I++;
  }
}","void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)
{
  AvahiLookupFlags *flags;
  const char *domain;
  AvahiServer *s;
  if (!s->wide_area_lookup_engine ||
          !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
          avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
          *flags |= AVAHI_LOOKUP_USE_MULTICAST;
      else
          *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
  THandles OtherInstances;
  FindOtherInstances(OtherInstances);
  int a = 61;
  int b = a;
  if(a*b>0){
      THandles::const_iterator I = OtherInstances.begin();
  }
  while (I != OtherInstances.end())
  {
    HWND Handle = *I;
    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::RefreshPanel;
    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));
    NULL_TERMINATE(Message.Refresh.Session);
    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));
    NULL_TERMINATE(Message.Refresh.Path);
    SendCopyDataMessage(Handle, Message);
    I++;
  }
}",0,1,63,0.67,Insert
3121,,,,,,,
3123,,,,,,,
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    int a = 2;
    int b = 3;
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
    while (a != b) {
        return(0);
        b = a;
    }
}",0,1,9,0.25,Insert
3129,"static int gem_context_register(struct i915_gem_context *ctx,
				struct drm_i915_file_private *fpriv)
{
	int ret;
	ctx->file_priv = fpriv;
	if (ctx->ppgtt)
		ctx->ppgtt->vm.file = fpriv;
	ctx->pid = get_task_pid(current, PIDTYPE_PID);
	ctx->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(ctx->pid));
	if (!ctx->name) {
		ret = -ENOMEM;
		goto err_pid;
	}
	ret = idr_alloc(&fpriv->context_idr, ctx,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;
	ctx->user_handle = ret;
	return 0;
err_name:
	kfree(fetch_and_zero(&ctx->name));
err_pid:
	put_pid(fetch_and_zero(&ctx->pid));
	return ret;
}","static int gem_context_register(struct i915_gem_context *ctx,
				struct drm_i915_file_private *fpriv)
{
	int ret;
	ctx->file_priv = fpriv;
	char *table_5;
	char *db_5;
	if (!opt_events_9 && !my_strcasecmp_8(&my_charset_latin1_6, db_5, ""mysql"") &&
	      !my_strcasecmp_8(&my_charset_latin1_6, table_5, ""event""))
	  {
	    fprintf_7(stderr_4, ""-- Warning: Skipping the data of table mysql.event.""
	            "" Specify the --events option explicitly.
	"");
	    DBUG_VOID_RETURN_10;
	}
	if (ctx->ppgtt)
		ctx->ppgtt->vm.file = fpriv;
	ctx->pid = get_task_pid(current, PIDTYPE_PID);
	ctx->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(ctx->pid));
	if (!ctx->name) {
		ret = -ENOMEM;
		goto err_pid;
	}
	ret = idr_alloc(&fpriv->context_idr, ctx,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;
		AVFormatContext *avctx;
		IMediaControl *control = NULL;
		char *table;
		char *db;
		int ret_2, i;
		if (ret_2 < 0){
		        ERROR(""ERROR: av_audio_fifo_read failed!"");
		}
		if (!opt_events && !my_strcasecmp(&my_charset_latin1, db, ""mysql"") &&
		      !my_strcasecmp(&my_charset_latin1, table, ""event""))
		  {
		    fprintf(stderr, ""-- Warning: Skipping the data of table mysql.event.""
		            "" Specify the --events option explicitly.
		"");
		    DBUG_VOID_RETURN;
		}
		struct dshow_ctx *ctx_1 = avctx->priv_data;
		IGraphBuilder *graph = NULL;
		IMediaEvent *media_event = NULL;
		int r;
		r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
		                         &IID_IGraphBuilder, (void **) &graph);
		ctx_1->graph = graph;
		r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);
		r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);
	ctx->user_handle = ret;
	return 0;
err_name:
	kfree(fetch_and_zero(&ctx->name));
err_pid:
	int a = 2;
	int b = 3;
	if (a != b) {
    	put_pid(fetch_and_zero(&ctx->pid));
	}
	return ret;
}",1,0,409,2.15,Insert
3132,"    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        return auth::checkAuthForAuthSchemaUpgradeCommand(client);
    }","    virtual Status checkAuthForCommand(Client* client,
                                       const std::string& dbname,
                                       const BSONObj& cmdObj) {
        const char
        Image *image;
        const LayerInfo* layer_info;
        const size_t url;
        MagickOffsetType
            offset;
        MagickStatusType
            status;
        if (status == MagickFalse)
            SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
            *attribute,
            *content;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        QuantizationTable
            *table;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        XMLTreeInfo
            *description,
            *levels,
            *quantization_tables,
            *table_iterator;
        table=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));
        table->slot=(char *) NULL;
        table->description=(char *) NULL;
        table->levels=(unsigned int *) NULL;
        attribute=GetXMLTreeAttribute(table_iterator,""slot"");
        int a = 14;
        int b = a;
        if(a*b>0){
            return auth::checkAuthForAuthSchemaUpgradeCommand(client);
        }
    }",0,1,35,0.32,Insert
3133,"int InstanceKlass::find_method_index(const Array<Method*>* methods,
                                     const Symbol* name,
                                     const Symbol* signature,
                                     OverpassLookupMode overpass_mode,
                                     StaticLookupMode static_mode,
                                     PrivateLookupMode private_mode) {
  const bool skipping_overpass = (overpass_mode == skip_overpass);
  const bool skipping_static = (static_mode == skip_static);
  const bool skipping_private = (private_mode == skip_private);
  const int hit = binary_search(methods, name);
  if (hit != -1) {
    const Method* const m = methods->at(hit);
    if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
      return hit;
    }
    int i;
    for (i = hit - 1; i >= 0; --i) {
        const Method* const m = methods->at(i);
        assert(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
    for (i = hit + 1; i < methods->length(); ++i) {
        const Method* const m = methods->at(i);
        assert(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
#ifdef ASSERT
    const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :
      linear_search(methods, name, signature);
    assert(-1 == index, ""binary search should have found entry %d"", index);
#endif
  }
  return -1;
}","int InstanceKlass::find_method_index(const Array<Method*>* methods,
                                     const Symbol* name,
                                     const Symbol* signature,
                                     OverpassLookupMode overpass_mode,
                                     StaticLookupMode static_mode,
                                     PrivateLookupMode private_mode) {
  const bool skipping_overpass = (overpass_mode == skip_overpass);
  const bool skipping_static = (static_mode == skip_static);
  const bool skipping_private = (private_mode == skip_private);
  char str[] = ""Constant"";
  if (strlen(str) > 0) {
      const int hit = binary_search(methods, name);
  }
  if (hit != -1) {
    const Method* const m = methods->at(hit);
    if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
      return hit;
    }
    int i;
    for (i = hit - 1; i >= 0; --i) {
        const Method* const m = methods->at(i);
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        u32 i_8;
        for (i_8=0;i_8 < inter->nb_entries; i_8++) {
        		inter->entries[i_8].block_count = gf_bs_read_u16(bs);
        		inter->entries[i_8].block_size = gf_bs_read_u32(bs);
        }
        assert(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
    for (i = hit + 1; i < methods->length(); ++i) {
        const Method* const m = methods->at(i);
        assert(m->is_method(), ""must be method"");
        if (m->name() != name) {
          break;
        }
        if (method_matches(m, signature, skipping_overpass, skipping_static, skipping_private)) {
          return i;
        }
    }
#ifdef ASSERT
    const int index = (skipping_overpass || skipping_static || skipping_private) ? -1 :
      linear_search(methods, name, signature);
    assert(-1 == index, ""binary search should have found entry %d"", index);
#endif
  }
  return -1;
}",0,1,21,1.12,Insert
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	int flags;
	RTPContext *http;
	char val[1024];
	if (url_open(&http->rtp_hd, val, flags) < 0)
	        goto fail;
	sk_del_node_init(sk);
	int a = 43;
	int height;
	int subsamp;
	int ph, nc, retval = 0;
	int ph, nc, retval = 0;
	nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
	ph = PAD(height, tjMCUHeight[subsamp] / 8);
	int b = a;
	if(a*b>0){
    	write_unlock_bh(&l->lock);
	}
}",0,1,52,0.42,Insert
3139,"Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ &  ,
                                       DcmDataset *  )
{
  return STATUS_Success;
}","Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ &  ,
                                       DcmDataset *  )
{
  int a = 2;
  int b = 3;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  double vals, mul, integral, fraction;
  fraction = modf(vals, &integral);
  while (a < b) {
      return STATUS_Success;
      b = a;
  }
}",0,1,8,0.2,Insert
3142,"ippAddSeparator(ipp_t *ipp)		 
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));
  if (!ipp)
    return (NULL);
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","ippAddSeparator(ipp_t *ipp)		 
{
  int a = 2;
  PutBitContext pb, pb2;
  JLSState *state;
  ls_store_lse(state, &pb);
  av_freep(&state);
  av_freep(&state);
  int b = 2;
  while (a == b) {
      DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));
      b += 1;
  }
  if (!ipp)
    return (NULL);
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}",0,1,6,0.22,Insert
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;
	*cells_size = 0;
	*nr_elements = 0;
	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
	strcpy(str, ""a"");
	}
	return 0;
}",0,1,13,0.13,Replace
3147,"static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	return 0;
}","static int assign_proto_idx(struct proto *prot)
{
	prot->inuse_idx = find_first_zero_bit(proto_inuse_idx, PROTO_INUSE_NR);
	if (unlikely(prot->inuse_idx == PROTO_INUSE_NR - 1)) {
		pr_err(""PROTO_INUSE_NR exhausted\n"");
		return -ENOSPC;
	}
	set_bit(prot->inuse_idx, proto_inuse_idx);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	const char
    	    *attribute,
    	    *content;
    	attribute=GetXMLTreeAttribute(levels,""divisor"");
    	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,15,0.28,Insert
3151,,,,,,,
3153,,,,,,,
3154,,,,,,,
3156,,,,,,,
3157,,,,,,,
3160,,,,,,,
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
GF_BitStream *bs;
GF_Box *s;
FilePartitionBox *inter = (FilePartitionBox *)s;
inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
inter->packet_payload_size = gf_bs_read_u16(bs);
gf_bs_read_u8(bs);
inter->FEC_encoding_ID = gf_bs_read_u8(bs);
inter->FEC_instance_ID = gf_bs_read_u16(bs);
    int a = 2;
    int b = 3;
    if (a != b) {
        check_string_option(&wop->wo_scl);
    }
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",0,1,28,0.57,Insert
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;
  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  int a = 2;
  int b = 3;
  if (a != b) {
      part_info->linear_hash_mask= mask - 1;
  }
}",0,1,1,0.04,Replace
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  int a = 94;
  int b = a;
  if(a*b>0){
      ttype = get_true_type(ttype);
  }
  string prog;
  string name;
  string nspace;
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",0,1,1,0.12,Replace
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;
    char str[] = ""Constant"";
    BUFFER *gz;
    ciss_url_t uc;
    url_ciss_tobuffer (&uc, gz, 0);
    if (strlen(str) > 0) {
        set_vim_var_string(VV_FNAME, ptr, len);
    }
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}",0,1,12,0.28,Insert
3167,,,,,,,
3168,,,,,,,
3170,,,,,,,
3171,,,,,,,
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);
  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      struct PCIDevice *pci_dev;
      int r;
      AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
      AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
      r = assign_device(Dev);
      r = assign_intx(Dev);
      assigned_dev_load_option_rom(Dev);
      add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
      EXPECT_EQ(SQLITE_DENY, rc);
  strcpy(str, ""a"");
  }
  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}",0,1,15,0.32,Insert
3175,,,,,,,
3177,,,,,,,
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        close_connection_now(conn);
    }
}","void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;
    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
    } else {
        int a = 2;
        int b = 3;
        while (a != b) {
            const page_load_metrics::mojom::PageLoadTiming& timing;
            const page_load_metrics::mojom::PageLoadTiming& timing_9;
            const page_load_metrics::PageLoadExtraInfo& info_1;
            bool is_user_initiated_navigation_5 =
                  info_1.user_initiated_info.browser_initiated ||
                  timing_9.input_to_navigation_start;
            if (timing_9.paint_timing->first_contentful_paint) {
                builder_7.SetPaintTiming_NavigationToFirstContentfulPaint(
                    timing_9.paint_timing->first_contentful_paint.value().InMilliseconds());
            }
            const page_load_metrics::PageLoadExtraInfo& info;
            bool is_user_initiated_navigation =
                  info.user_initiated_info.browser_initiated ||
                  timing.input_to_navigation_start;
            if (timing.paint_timing->first_contentful_paint) {
                builder.SetPaintTiming_NavigationToFirstContentfulPaint(
                    timing.paint_timing->first_contentful_paint.value().InMilliseconds());
            }
            close_connection_now(conn);
            b = a;
        }
    }
}",1,0,52,0.46,Insert
3180,"ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}","ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return get_attribute(si->unauth_attr, nid);
    }
}",0,1,1,0.03,Replace
3185,,,,,,,
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return 1;
    }
}",0,1,6,0.08,Replace
3190,,,,,,,
3193,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);
    virResetLastError();
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);
    conn = domain->conn;
    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;
    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);
    int a = 2;
    int b = 3;
    while (a != b) {
        virResetLastError();
        b = a;
    }
    char **names;
    char *p;
    char *ea_namelist = smallbuf;
    size_t num_names;
    for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
    		names[num_names++] = p;
    }
    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);
    size_t *pnum_names;
    TALLOC_CTX *mem_ctx;
    char **names_7;
    va_list options;
    if (key != NULL)
    driver_fn_obj = _yr_object_lookup(node, 0, key, options);
      else
      driver_fnbj = node;
    size_t num_names_10;
    *pnum_names = 0;
    num_names_10 = 0;
    *pnum_names = num_names_10;
    names_7 = talloc_array(mem_ctx, char *, num_names_10);
    num_names_10 = 0;
    conn = domain->conn;
    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        size_t size;
        struct kmem_cache *matchp;
        unsigned long bytes;
        left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);
        if (ret < 0)
            goto error;
        return ret;
    }
    virReportUnsupportedError();
 error:
    virDispatchError(domain->conn);
    return -1;
}",0,1,116,0.93,Insert
3194,,,,,,,
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	rtnl_unregister_all(PF_INET6);
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}","static void __exit inet6_exit(void)
{
	MOVTrack *track;
	AVIOContext *pb;
	int64_t pos = avio_tell(pb);
	if ((track->enc->codec_type == AVMEDIA_TYPE_VIDEO ||
	         track->enc->codec_tag == MKTAG('r','t','p',' ')) &&
	        track->has_keyframes && track->has_keyframes < track->entry)
	        mov_write_stss_tag(pb, track, MOV_SYNC_SAMPLE);
	if (disable_ipv6_mod)
		return;
	sock_unregister(PF_INET6);
	int a = 2;
	int b = 2;
	if (a == b) {
    	rtnl_unregister_all(PF_INET6);
	}
	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();
	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	const char *arg2n;
	const char *arg1n;
	const char *attribute;
	MagickCLI *cli_wand;
	if (cli_wand->wand.debug != MagickFalse)
	    (void) CLILogEvent(cli_wand,CommandEvent,GetMagickModule(),
	       ""- List Operator: %s \""%s\"" \""%s\"""", attribute,
	       arg1n == (const char *) NULL ? ""null"" : arg1n,
	       arg2n == (const char *) NULL ? ""null"" : arg2n);
	proto_unregister(&tcpv6_prot);
	rcu_barrier();  
}",1,0,82,0.68,Insert
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct file *file = iocb->ki_filp;
    	b += 1;
	}
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	return vhost_chr_write_iter(dev, from);
}",0,1,1,0.04,Replace
3201,,,,,,,
3207,"node_new_anychar(void)
{
  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  return node;
}","node_new_anychar(void)
{
  char str1[] = ""Constant"";
  char str2[] = ""Constant"";
  if (strcmp(str1, str2) == 0) {
      MachineState *machine;
      char *filename;
      sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
      if (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {
              error_report(""Could not load LPAR rtas '%s'"", filename);
              exit(1);
      }
      Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  }
  return node;
}",0,1,8,0.17,Insert
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  AVCodecContext * avnc;
  MP3On4DecodeContext *this = avnc->priv_data;
  MP3On4DecodeContext *this = avnc->priv_data;
  this->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
  avnc->channels = mp3Channels[this->chan_cfg];
  avnc->priv_data = this->mp3decctx[0];
  decode_init(avnc);
  avnc->priv_data = this;
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  int a = 2;
  int b = 3;
  while (a != b) {
      return(MagickFalse);
      b = a;
  }
}",0,1,5,0.36,Insert
3209,,,,,,,
3212,,,,,,,
3214,,,,,,,
3216,"Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    Sfdouble_t d;
    char *last;
    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = last;
    return d;
}","Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    PNGDecContext *fs;
    bytestream2_skip(&fs->gb, 4);
    fs->has_trns = 1;
    Sfdouble_t d;
    DisasContext *ctx;
    TCGv_i32 t1, t2;
    TCGv t0;
    int start = rD(ctx->opcode);
    Shell_t *shp_9;
    const char *str_9;
    char *last_4;
    Sfdouble_t d_3;
    d_3 = number_9(str_9, &last_4, shp_9->inarith ? 0 : 10, NULL);
    TCGv_i32 t1, t2;
    t2 = tcg_const_i32(start);
    gen_helper_lsw(cpu_env, t0, t1, t2);
    int t0_6, t1_1, t2_8, t3_1, t4_3, t5_10, t6_10, t7_6, t8_4, t9_10, tA_1, tB_3, tC_10, tD_7, tE_1, tF_7;
    int t0_6, t1_1, t2_8, t3_1, t4_3, t5_10, t6_10, t7_6, t8_4, t9_10, tA_1, tB_3, tC_10, tD_7, tE_1, tF_7;
    int t0_6, t1_1, t2_8, t3_1, t4_3, t5_10, t6_10, t7_6, t8_4, t9_10, tA_1, tB_3, tC_10, tD_7, tE_1, tF_7;
    int t0_6, t1_1, t2_8, t3_1, t4_3, t5_10, t6_10, t7_6, t8_4, t9_10, tA_1, tB_3, tC_10, tD_7, tE_1, tF_7;
    int t0_6, t1_1, t2_8, t3_1, t4_3, t5_10, t6_10, t7_6, t8_4, t9_10, tA_1, tB_3, tC_10, tD_7, tE_1, tF_7;
    int t10_4, t11_6, t12_3, t13_3;
    int t10_4, t11_6, t12_3, t13_3;
    tF_7  = tD_7 - (tB_3 >> 1);
    t10_4 = tF_7 - t5_10;
    t13_3 = tF_7 + (tB_3 >> 1) * 2 - t4_3;
    tcg_temp_free_i32(t2);
    char *last;
    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        struct rtable *rt = NULL;
        __u8 tos;
        struct geneve_dev *geneve = netdev_priv(dev);
        fl4->flowi4_tos = RT_TOS(tos);
        rt = ip_route_output_key(geneve->net, fl4);
        return 0;
    }
    int t0_1, t1_6, t2_8, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_1, t1_6, t2_8, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_1, t1_6, t2_8, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_1, t1_6, t2_8, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t0_1, t1_6, t2_8, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
    int t10, t11, t12, t13;
    int t10, t11, t12, t13;
    tF  = tD - (tB >> 1);
    t10 = tF - t5;
    t13 = tF + (tB >> 1) * 2 - t4;
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        int a_1 = 2;
        int b_1 = 3;
        while (a_1 < b_1) {
            d = -0.0;
            b_1 = a_1;
        }
    }
    if (ptr) *ptr = last;
    return d;
}",1,0,449,2.53,Insert
3217,,,,,,,
3219,"int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}","int i40e_reconfig_rss_queues(struct i40e_pf *pf, int queue_count)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct i40e_vsi *vsi = pf->vsi[pf->lan_vsi];
    	b = a;
	}
	int new_rss_size;
	if (!(pf->flags & I40E_FLAG_RSS_ENABLED))
		return 0;
	queue_count = min_t(int, queue_count, num_online_cpus());
	new_rss_size = min_t(int, queue_count, pf->rss_size_max);
	if (queue_count != vsi->num_queue_pairs) {
		u16 qcount;
		vsi->req_queue_pairs = queue_count;
		i40e_prep_for_reset(pf, true);
		pf->alloc_rss_size = new_rss_size;
		i40e_reset_and_rebuild(pf, true, true);
		if (queue_count < vsi->rss_size) {
			i40e_clear_rss_config_user(vsi);
			dev_dbg(&pf->pdev->dev,
				""discard user configured hash keys and lut\n"");
		}
		qcount = vsi->num_queue_pairs / vsi->tc_config.numtc;
		vsi->rss_size = min_t(int, pf->alloc_rss_size, qcount);
		i40e_pf_config_rss(pf);
	}
	dev_info(&pf->pdev->dev, ""User requested queue count/HW max RSS count:  %d/%d\n"",
		 vsi->req_queue_pairs, pf->rss_size_max);
	return pf->alloc_rss_size;
}",0,1,2,0.13,Replace
3220,,,,,,,
3222,,,,,,,
3226,"state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;
  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }
  return separate_contexts;
}","state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;
  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }
    AVFormatContext *s_3;
    AVStream   *st = NULL;
    uint8_t  *label = NULL;
    ASFContext *asf       = s_3->priv_data;
    if (*label) {
            if (av_dict_set(&st->metadata, ""title"", label, AV_DICT_DONT_STRDUP_VAL) < 0)
                av_log(s_3, AV_LOG_WARNING, ""av_dict_set failed.
    "");
        } else
            av_freep(&label);
  return separate_contexts;
}",1,0,12,0.31,Insert
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		*index = device - base;
		}
		return tty_driver_kref_get(p);
	}
	return NULL;
}",0,1,3,0.07,Replace
3232,,,,,,,
3234,,,,,,,
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct file *file = iocb->ki_filp;
	}
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;
	return vhost_chr_read_iter(dev, to, noblock);
}",0,1,1,0.04,Replace
3238,"GF_Box *ftab_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);
	return (GF_Box *) tmp;
}","GF_Box *ftab_box_new()
{
	const char *nptr;
	double vals, mul, integral, fraction;
	char *ndpointer;
	unsigned char c;
	vals = strtod(nptr, &ndpointer);
	c = *ndpointer;
	int a = 2;
	int b = 3;
	while (a != b) {
    	ISOM_DECL_BOX_ALLOC(GF_FontTableBox, GF_ISOM_BOX_TYPE_FTAB);
    	b = a;
	}
	return (GF_Box *) tmp;
}",0,1,6,0.2,Insert
3239,,,,,,,
3240,,,,,,,
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;
	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		char str_1[] = ""Constant"";
		while (strlen(str_1) > 5) {
    		r = ARCHIVE_OK;
		strcpy(str_1, ""a"");
		}
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}",0,1,2,0.12,Replace
3247,"napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();
  return napi_clear_last_error(env);
}","napi_status napi_is_date(napi_env env,
                         napi_value value,
                         bool* is_date) {
  CHECK_ENV(env);
  CHECK_ARG(env, value);
  CHECK_ARG(env, is_date);
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  char
      *p,
      *xml;
  double
      value_10;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  content=GetXMLTreeContent(description);
  content=GetXMLTreeContent(levels);
  value_10=InterpretLocaleValue(content,&p);
  *is_date = v8impl::V8LocalValueFromJsValue(value)->IsDate();
  int a = 2;
  int b = 3;
  MachineState *machine;
  char *filename;
  MemoryRegion *ram = g_new(MemoryRegion, 1);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
  spapr->icp = xics_system_init(machine,
                                    DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                 smp_threads),
                                    XICS_IRQS, &error_fatal);
  memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                           machine->ram_size);
  filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
  spapr->rtas_size = get_image_size(filename);
  spapr->rtas_blob = g_malloc(spapr->rtas_size);
  while (a != b) {
      return napi_clear_last_error(env);
      b = a;
  }
}",0,1,42,0.48,Insert
3248,,,,,,,
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;
	if (!parent)
		return NULL;
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	klist_iter_exit(&i);
	}
	return child;
}",0,1,1,0.07,Replace
3252,"static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	memset(fx, 0, xstate_size);
	fx->cwd = 0x37f;
	fx->mxcsr = MXCSR_DEFAULT;
}","static inline void fx_finit(struct i387_fxsave_struct *fx)
{
	struct ldb_context *ydm;
	const char *attr;
	const struct ldb_schema_attribute *a_7;
	a_7 = ldb_schema_attribute_by_name(ydm, attr);
	memset(fx, 0, xstate_size);
	int a = 2;
	int b = 3;
	if (a != b) {
    	fx->cwd = 0x37f;
	}
	fx->mxcsr = MXCSR_DEFAULT;
}",0,1,7,0.21,Insert
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ","    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        char str[] = ""Constant"";
        struct ttm_buffer_object *bo;
        struct ttm_bo_device *tdev = bo->tdev;
        struct ttm_bo_device *tdev = bo->tdev;
        dma_resv_assert_held(bo->base.resv);
        bo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);
        while (strlen(str) > 5) {
            assert (tempIo.get() != 0);
        strcpy(str, ""a"");
        }
        doWriteMetadata(*tempIo);  
        io_->close();
        io_->transfer(*tempIo);  
    }  ",0,1,16,0.32,Insert
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int dev_match_devt(struct device *dev, void *data)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	dev_t *devt = data;
	strcpy(str, ""a"");
	}
	return dev->devt == *devt;
}",0,1,1,0.03,Replace
3259,,,,,,,
3260,,,,,,,
3261,,,,,,,
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,2,0.07,Replace
3264,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);
	if (off == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ad, int eid)
{
	GstDateTime *dt, *dt2;
	fail_unless (gst_date_time_get_year (dt) == 2010);
	fail_unless (gst_date_time_get_month (dt) == 10);
	fail_unless (!gst_date_time_has_day (dt));
	fail_unless (!gst_date_time_has_time (dt));
	gst_date_time_unref (dt);
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);
	if (off == 0 || len == 0) {
		return NULL;
	}
	return ad->ad_data + off;
}",1,0,34,0.37,Insert
3265,,,,,,,
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	    AVPacket *afpud;
	    VirtIODevice *vrdevice;
	    struct virtio_blk_config blkcfg;
	    VirtIOBlock *s_10 = VIRTIO_BLK(vrdevice);
	    uint64_t capacity;
	    VirtIOBlock *s_10 = VIRTIO_BLK(vrdevice);
	    bdrv_get_geometry(s_10->bs, &capacity);
	    virtio_stq_p(vrdevice, &blkcfg.capacity, capacity);
	    AVCodecContext *avctx;
	    int sample_scale, c, n, i;
	    int sample_scale, c, n, i;
	    int buf_size = afpud->size;
	    PCMDecode *s_1 = avctx->priv_data;
	    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
	    n = avctx->channels * sample_scale;
	    n = buf_size/sample_scale;
	int a = 2;
	int b = 3;
	if (a != b) {
    	smtp_enter_state(s, STATE_QUIT);
	}
}",0,1,33,0.36,Insert
3267,"static int __init xfrm6_tunnel_init(void)
{
	int rv;
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;
deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}","static int __init xfrm6_tunnel_init(void)
{
	int rv;
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	struct dhcp_packet *packet;
	uint32_t lease_seconds;
	uint8_t *option;
	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	lease_seconds = get_be32(option);
	if (rv < 0)
		goto deregspi;
	return 0;
deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}",1,0,44,0.61,Insert
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    return offset-offset_start;
}","dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    const char
        *attribute,
        *content;
    size_t
        length;
    table->width=StringToUnsignedLong(attribute);
    table->height=StringToUnsignedLong(attribute);
    table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
    length=(size_t) table->width*table->height;
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    gint     offset_start;
    offset_start = offset;
    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;
    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;
    int a = 2;
    int b = 3;
    while (a != b) {
        proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
        b = a;
    }
    offset += 1;
    return offset-offset_start;
}",0,1,27,0.7,Insert
3273,,,,,,,
3274,,,,,,,
3275,,,,,,,
3276,"static QEMUCursor *cursor_parse_xpm(const char *xpm[])
{
    QEMUCursor *c;
    uint32_t ctab[128];
    unsigned int width, height, colors, chars;
    unsigned int line = 0, i, r, g, b, x, y, pixel;
    char name[16];
    uint8_t idx;
    if (sscanf(xpm[line], ""%u %u %u %u"",
               &width, &height, &colors, &chars) != 4) {
        fprintf(stderr, ""%s: header parse error: \""%s\""\n"",
                __func__, xpm[line]);
        return NULL;
    }
    if (chars != 1) {
        fprintf(stderr, ""%s: chars != 1 not supported\n"", __func__);
        return NULL;
    }
    line++;
    for (i = 0; i < colors; i++, line++) {
        if (sscanf(xpm[line], ""%c c %15s"", &idx, name) == 2) {
            if (sscanf(name, ""#%02x%02x%02x"", &r, &g, &b) == 3) {
                ctab[idx] = (0xff << 24) | (b << 16) | (g << 8) | r;
                continue;
            }
            if (strcmp(name, ""None"") == 0) {
                ctab[idx] = 0x00000000;
                continue;
            }
        }
        fprintf(stderr, ""%s: color parse error: \""%s\""\n"",
                __func__, xpm[line]);
        return NULL;
    }
    c = cursor_alloc(width, height);
    for (pixel = 0, y = 0; y < height; y++, line++) {
        for (x = 0; x < height; x++, pixel++) {
            idx = xpm[line][x];
            c->data[pixel] = ctab[idx];
        }
    }
    return c;
}","static QEMUCursor *cursor_parse_xpm(const char *xpm[])
{
    AVDictionary **metadata = avpriv_frame_get_metadatap(main);
    double comp_mse[4], mse = 0;
    PSNRContext *s = ctx->priv;
    double comp_mse[4], mse = 0;
    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,
                          (const uint8_t **)ref->data, ref->linesize,
                           main->width, main->height, comp_mse);
    s->min_mse = FFMIN(s->min_mse, mse);
    s->max_mse = FFMAX(s->max_mse, mse);
    s->mse += mse;
    AVCodecContext *avctx;
    AVDictionary **metadata_3 = avpriv_frame_get_metadatap_5(main_7);
    double comp_mse_4[4], mse_8 = 0;
    PSNRContext *s_2 = ctx_3->priv;
    double comp_mse_4[4], mse_8 = 0;
    s_2->compute_mse(s_2, (const uint8_t **)main_7->data, main_7->linesize,
                          (const uint8_t **)ref_7->data, ref_7->linesize,
                           main_7->width, main_7->height, comp_mse_4);
    s_2->min_mse = FFMIN_1(s_2->min_mse, mse_8);
    s_2->max_mse = FFMAX_8(s_2->max_mse, mse_8);
    s_2->mse_8 += mse_8;
    set_meta_2(metadata_3, ""lavfi.psnr.mse_avg"", 0, mse_8);
    int linesize;
    GIFContext *s_10 = avctx->priv_data;
    GIFContext *s_10 = avctx->priv_data;
    int len, height_1;
    const uint8_t *ptr;
    int len, height_1;
    for (height_1 = avctx->height_1; height_1--;) {
            len += ff_lzw_encode(s_10->lzw, ptr, avctx->width);
            ptr += linesize;
    }
    set_meta(metadata, ""lavfi.psnr.mse_avg"", 0, mse);
    QEMUCursor *c;
    int ilms;
    int16_t input;
    WmallDecodeCtx *s_2;
    int ich;
    int recent = s_2->cdlumm[ich][ilms].recent;
    int recent = s_2->cdlumm[ich][ilms].recent;
    int recent = s_2->cdlumm[ich][ilms].recent;
    int16_t range = 1 << (s_2->bits_per_sample - 1);
    int recent = s_2->cdlumm[ich][ilms].recent;
    int recent = s_2->cdlumm[ich][ilms].recent;
    s_2->cdlumm[ich][ilms].recent--;
    s_2->cdlumm[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);
    s_2->cdlumm[ich][ilms].lms_updates[recent + s_2->cdlumm[ich][ilms].order >> 4] >>= 2;
    s_2->cdlumm[ich][ilms].lms_updates[recent + s_2->cdlumm[ich][ilms].order >> 3] >>= 1;
    uint32_t ctab[128];
    unsigned int width, height, colors, chars;
    unsigned int line = 0, i, r, g, b, x, y, pixel;
    char name[16];
    uint8_t idx;
    if (sscanf(xpm[line], ""%u %u %u %u"",
               &width, &height, &colors, &chars) != 4) {
        fprintf(stderr, ""%s: header parse error: \""%s\""\n"",
                __func__, xpm[line]);
                uint8_t *buf;
                uint32_t *buf32;
                buf32 = (uint32_t *)buf;
        return NULL;
    }
    if (chars != 1) {
        fprintf(stderr, ""%s: chars != 1 not supported\n"", __func__);
        return NULL;
    }
    line++;
    for (i = 0; i < colors; i++, line++) {
        if (sscanf(xpm[line], ""%c c %15s"", &idx, name) == 2) {
            if (sscanf(name, ""#%02x%02x%02x"", &r, &g, &b) == 3) {
                ctab[idx] = (0xff << 24) | (b << 16) | (g << 8) | r;
                continue;
            }
            if (strcmp(name, ""None"") == 0) {
                ctab[idx] = 0x00000000;
                continue;
            }
        }
        fprintf(stderr, ""%s: color parse error: \""%s\""\n"",
                __func__, xpm[line]);
        return NULL;
    }
    c = cursor_alloc(width, height);
    for (pixel = 0, y = 0; y < height; y++, line++) {
        for (x = 0; x < height; x++, pixel++) {
            idx = xpm[line][x];
            c->data[pixel] = ctab[idx];
        }
    }
    return c;
}",1,0,378,2.75,Insert
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	return kobj;
}","static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;
	Rocker *r;
	DescInfo *info;
	uint32_t port;
	int err = ROCKER_OK;
	char *buf = desc_get_buf(info, true);
	struct edgeport_serial *serial;
	u8 *data;
	int status;
	struct device *dev_6 = &serial->serial->dev_6->dev_6;
	if (status)
			dev_dbg(dev_6, ""%s - read 2 status error = %d
	"", __func__, status);
		else
			dev_dbg(dev_6, ""%s - read 2 data = 0x%x
	"", __func__, *data);
	struct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };
	PCIDevice *dev_1 = PCI_DEVICE(r);
	int iovcnt = 0;
	uint32_t pport;
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	err = fp_port_eg(r->fp_port[port], iov, iovcnt);
	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;
	int a = 71;
	int b = a;
	if(a*b>0){
    	return kobj;
	}
}",0,1,35,0.39,Insert
3279,,,,,,,
3280,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim value caml_string_get(value str, value index)
{
  int a_1 = 2;
  int b_1 = 2;
  if (a_1 == b_1) {
      ptrdiff_t src_stride;
      ptrdiff_t buf_stride;
      int h;
      int src_y;
      int block_h;
      int w;
      int block_w;
      const uint8_t *src;
      int src_x;
      uint8_t *buf;
      emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,
                           src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,
                           hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);
      intnat idx = Long_val(index);
  }
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}",0,1,4,0.29,Insert
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	char str[] = ""Constant"";
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpDecoderCreate *create;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
	                                     &pack);
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	if (strlen(str) > 0) {
    	struct zone *zone;
	}
	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;
	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}",0,1,8,0.24,Insert
3284,,,,,,,
3285,,,,,,,
3289,,,,,,,
3291,"  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {
    auto col_params = new CollectiveParams();
    auto done_with_cleanup = [col_params, done = std::move(done)]() {
      done();
      col_params->Unref();
    };
    OP_REQUIRES_OK_ASYNC(c,
                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,
                                                c->input(1),
                                                c->input(2),
                                                c->input(3)),
                         done);
    col_params->instance.shape = c->input(0).shape();
    col_params->merge_op = merge_op_.get();
    col_params->final_op = final_op_.get();
    VLOG(1) << ""CollectiveReduceV2 group_size "" << col_params->group.group_size
            << "" group_key "" << col_params->group.group_key << "" instance_key ""
            << col_params->instance.instance_key;
    Tensor* output = nullptr;
    OP_REQUIRES_OK_ASYNC(c,
                         c->forward_input_or_allocate_output(
                             {0}, 0, col_params->instance.shape, &output),
                         done_with_cleanup);
    Run(c, col_params, std::move(done_with_cleanup));
  }","  void ComputeAsync(OpKernelContext* c, DoneCallback done) override {
    auto col_params = new CollectiveParams();
    auto done_with_cleanup = [col_params, done = std::move(done)]() {
      done();
      const base::Closure& error_manager;
      FileSystemType y;
      const GURL& author;
      const base::Closure& flow;
      TaskParamsForDidGetQuota request;
      request.author = author;
      request.y = y;
      request.flow = flow;
      request.error_manager = error_manager;
      quota_manager_proxy->quota_manager()->GetUsageAndQuota(
             author,
             FileSystemTypeToQuotaStorageType(y),
             base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                       base::Unretained(this), request));
      col_params->Unref();
    };
    OP_REQUIRES_OK_ASYNC(c,
                         FillCollectiveParams(col_params, REDUCTION_COLLECTIVE,
                                                c->input(1),
                                                c->input(2),
                                                c->input(3)),
                         done);
    col_params->instance.shape = c->input(0).shape();
    col_params->merge_op = merge_op_.get();
    col_params->final_op = final_op_.get();
    VLOG(1) << ""CollectiveReduceV2 group_size "" << col_params->group.group_size
            << "" group_key "" << col_params->group.group_key << "" instance_key ""
            << col_params->instance.instance_key;
    int a = 2;
    int b = 2;
    if (a == b) {
        Tensor* output = nullptr;
    }
    OP_REQUIRES_OK_ASYNC(c,
                         c->forward_input_or_allocate_output(
                             {0}, 0, col_params->instance.shape, &output),
                         done_with_cleanup);
    Run(c, col_params, std::move(done_with_cleanup));
  }",1,0,28,0.71,Insert
3293,,,,,,,
3295,,,,,,,
3297,,,,,,,
3299,,,,,,,
3301,,,,,,,
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void php_info_print_style(TSRMLS_D)
{
	SysBusDevice *b_3;
	if (i) {
	        sysbus_mmio_map(b_3, 0, i);
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	php_info_printf(""<style type=\""text/css\"">\n"");
	}
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");",0,1,5,0.17,Insert
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
		BlockDriverState *base;
		int orig_base_flags;
		orig_base_flags = bdrv_get_flags(base);
	return __put_v4l2_format32(kp, up);
}",1,0,30,0.34,Insert
3306,"enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      return STRING_RESULT;
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      return STRING_RESULT;                    
  }
}","enum Item_result Item_func_get_system_var::result_type() const
{
  switch (var->show_type())
  {
    const char
    int64_t unit;
    unsigned char c;
    double vals, mul, integral, fraction;
    int64_t retval;
    double vals, mul, integral, fraction;
    mul = suffix_mul(c, unit);
    retval = vals * mul;
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    case SHOW_BOOL:
    case SHOW_MY_BOOL:
    case SHOW_SINT:
    case SHOW_SLONG:
    case SHOW_SLONGLONG:
    case SHOW_UINT:
    case SHOW_ULONG:
    case SHOW_ULONGLONG:
    case SHOW_HA_ROWS:
      return INT_RESULT;
    case SHOW_CHAR: 
    case SHOW_CHAR_PTR: 
    case SHOW_LEX_STRING:
      int a = 2;
      int b = 3;
      if (a != b) {
          return STRING_RESULT;
      }
    case SHOW_DOUBLE:
      return REAL_RESULT;
    default:
      my_error(ER_VAR_CANT_BE_READ, MYF(0), var->name.str);
      return STRING_RESULT;                    
  }
}",0,1,41,0.5,Insert
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  int a = 2;
  int b = 3;
  AVCodecContext *AVcas;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  while (a != b) {
      to->min = from->min;
      b = a;
  }
  to->max = from->max;
}",0,1,7,0.25,Insert
3311,"void init_xml_relax_ng()
{
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  VALUE xml = rb_define_module_under(nokogiri, ""XML"");
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}","void init_xml_relax_ng()
{
  MYSQL_FIELD *field_1;
  MYSQL_RES  *table32pre_10;
  if (strcmp_3(field_1->name, ""View"") != 0)
    {
      mysql_free_result_6(table32pre_10);
      switch_character_set_results_4(mysql_2, default_charset_9);
      verbose_msg_9(""-- It's base table, skipped
  "");
      DBUG_RETURN_6(0);
  }
  VALUE nokogiri = rb_define_module(""Nokogiri"");
  int a = 2;
  int b = 3;
  while (a < b) {
      VALUE xml = rb_define_module_under(nokogiri, ""XML"");
      b = a;
  }
  VALUE klass = rb_define_class_under(xml, ""RelaxNG"", cNokogiriXmlSchema);
  cNokogiriXmlRelaxNG = klass;
  const struct dcmd_cmd_tbl_t *cmdptr = dcmd_cmd_tbl;
  int opcode, len;
  while (cmdptr->opcode != -1 && cmdptr->opcode != opcode) {
          cmdptr++;
  }
  rb_define_singleton_method(klass, ""read_memory"", read_memory, 1);
  MYSQL_FIELD *field;
  MYSQL_RES  *table32pre;
  if (strcmp(field->name, ""View"") != 0)
    {
      mysql_free_result(table32pre);
      switch_character_set_results(mysql, default_charset);
      verbose_msg(""-- It's base table, skipped
  "");
      DBUG_RETURN(0);
  }
  rb_define_singleton_method(klass, ""from_document"", from_document, 1);
  struct transaction_t *txn;
  void *params;
  struct index_record record;
  struct meth_params *gparams = (struct meth_params *) params;
  void *davdb = NULL, *obj = NULL;
  struct mailbox *mailbox = NULL;
  struct dav_data *ddata;
  struct resp_body_t *resp_body = &txn->resp_body;
  if (gparams->get) {
          ret = gparams->get(txn, mailbox, &record, ddata, &obj);
          if (ret != HTTP_CONTINUE) goto done;
          ret = 0;
  }
  rb_define_private_method(klass, ""validate_document"", validate_document, 1);
}",1,0,341,1.74,Insert
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		double f;
		f = get_float64 (buffer, &error);
		int a = 2;
		int b = 2;
		CPUState *env;
		const sigset_t *sigset;
		struct kvm_signal_mask * sigmak;
		int r;
		sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
		sigmak->len = 8;
		memcpy( sigmak->sigset, sigset, sizeof(*sigset));
		r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
		free( sigmak);
		while (a == b) {
    		r_core_seek (core, bbaddr, false);
    		b += 1;
		}
		return true;
	}
	return false;
}",0,1,40,0.43,Insert
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	return gid_index * hr_dev->caps.num_ports + port;
    	b = a;
	}
}",0,1,1,0.03,Replace
3316,"parse_ofp15_group_properties(struct ofpbuf *msg,
                             enum ofp11_group_type group_type,
                             enum ofp15_group_mod_command group_cmd,
                             struct ofputil_group_props *gp,
                             size_t properties_len)
{
    struct ofpbuf properties = ofpbuf_const_initializer(
        ofpbuf_pull(msg, properties_len), properties_len);
    while (properties.size > 0) {
        struct ofpbuf payload;
        enum ofperr error;
        uint64_t type;
        error = ofpprop_pull(&properties, &payload, &type);
        if (error) {
            return error;
        }
        switch (type) {
        case OFPPROP_EXP(NTR_VENDOR_ID, NTRT_SELECTION_METHOD):
        case OFPPROP_EXP(NTR_COMPAT_VENDOR_ID, NTRT_SELECTION_METHOD):
            error = parse_group_prop_ntr_selection_method(&payload, group_type,
                                                          group_cmd, gp);
            break;
        default:
            error = OFPPROP_UNKNOWN(false, ""group"", type);
            break;
        }
        if (error) {
            return error;
        }
    }
    return 0;
}","parse_ofp15_group_properties(struct ofpbuf *msg,
                             enum ofp11_group_type group_type,
                             enum ofp15_group_mod_command group_cmd,
                             struct ofputil_group_props *gp,
                             size_t properties_len)
{
    struct ofpbuf properties = ofpbuf_const_initializer(
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
        ofpbuf_pull(msg, properties_len), properties_len);
    while (properties.size > 0) {
        int a = 2;
        int b = 3;
        if (a != b) {
            struct ofpbuf payload;
        }
        enum ofperr error;
        uint64_t type;
        error = ofpprop_pull(&properties, &payload, &type);
        if (error) {
            return error;
        }
        switch (type) {
        case OFPPROP_EXP(NTR_VENDOR_ID, NTRT_SELECTION_METHOD):
        case OFPPROP_EXP(NTR_COMPAT_VENDOR_ID, NTRT_SELECTION_METHOD):
            error = parse_group_prop_ntr_selection_method(&payload, group_type,
                                                          group_cmd, gp);
            break;
        default:
            error = OFPPROP_UNKNOWN(false, ""group"", type);
            break;
        }
        if (error) {
            return error;
        }
    }
    return 0;
}",0,1,22,0.66,Insert
3317,,,,,,,
3319,"    void CiffEntry::doAddComponent(UniquePtr  )
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::doAddComponent(UniquePtr  )
    {
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
        }
    }",0,1,2,0.03,Replace
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;
    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    qemu_net_queue_flush(queue);
    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        ssize_t ret;
        b += 1;
    }
    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
    qemu_net_queue_flush(queue);
    return ret;
}",0,1,2,0.1,Replace
3322,,,,,,,
3323,"  void merge_unsafe_rollback_flags()
  {
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }","  void merge_unsafe_rollback_flags()
  {
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    kfree(discovery);
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    if (transaction.stmt.modified_non_trans_table)
      transaction.all.modified_non_trans_table= TRUE;
    transaction.all.m_unsafe_rollback_flags|=
      (transaction.stmt.m_unsafe_rollback_flags &
       (THD_TRANS::MODIFIED_NON_TRANS_TABLE |
        THD_TRANS::DID_WAIT | THD_TRANS::CREATED_TEMP_TABLE |
        THD_TRANS::DROPPED_TEMP_TABLE | THD_TRANS::DID_DDL |
        THD_TRANS::EXECUTED_TABLE_ADMIN_CMD));
  }",0,1,32,0.32,Insert
3326,"int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,
				struct ext4_xattr_info *i,
				struct ext4_xattr_ibody_find *is)
{
	struct ext4_xattr_ibody_header *header;
	struct ext4_xattr_search *s = &is->s;
	int error;
	if (EXT4_I(inode)->i_extra_isize == 0)
		return -ENOSPC;
	error = ext4_xattr_set_entry(i, s, handle, inode, false  );
	if (error) {
		if (error == -ENOSPC &&
		    ext4_has_inline_data(inode)) {
			error = ext4_try_to_evict_inline_data(handle, inode,
					EXT4_XATTR_LEN(strlen(i->name) +
					EXT4_XATTR_SIZE(i->value_len)));
			if (error)
				return error;
			error = ext4_xattr_ibody_find(inode, i, is);
			if (error)
				return error;
			error = ext4_xattr_set_entry(i, s, handle, inode,
						     false  );
		}
		if (error)
			return error;
	}
	header = IHDR(inode, ext4_raw_inode(&is->iloc));
	if (!IS_LAST_ENTRY(s->first)) {
		header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);
		ext4_set_inode_state(inode, EXT4_STATE_XATTR);
	} else {
		header->h_magic = cpu_to_le32(0);
		ext4_clear_inode_state(inode, EXT4_STATE_XATTR);
	}
	return 0;
}","int ext4_xattr_ibody_inline_set(handle_t *handle, struct inode *inode,
				struct ext4_xattr_info *i,
				struct ext4_xattr_ibody_find *is)
{
	struct ext4_xattr_ibody_header *header;
	struct ext4_xattr_search *s = &is->s;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	int error;
	}
	if (EXT4_I(inode)->i_extra_isize == 0)
		return -ENOSPC;
	error = ext4_xattr_set_entry(i, s, handle, inode, false  );
	if (error) {
		struct vrend_blitter_ctx *blit_ctx_5;
		int i_4;
		for (i_4 = 0; i_4 < 4; i_4++)
		      blit_ctx_5->vertices[i_4][0][3] = 1;
		if (error == -ENOSPC &&
		    ext4_has_inline_data(inode)) {
			error = ext4_try_to_evict_inline_data(handle, inode,
					EXT4_XATTR_LEN(strlen(i->name) +
					EXT4_XATTR_SIZE(i->value_len)));
			if (error)
				return error;
			error = ext4_xattr_ibody_find(inode, i, is);
			if (error)
				return error;
			error = ext4_xattr_set_entry(i, s, handle, inode,
						     false  );
		}
		if (error)
			return error;
	}
	header = IHDR(inode, ext4_raw_inode(&is->iloc));
	if (!IS_LAST_ENTRY(s->first)) {
		header->h_magic = cpu_to_le32(EXT4_XATTR_MAGIC);
		ext4_set_inode_state(inode, EXT4_STATE_XATTR);
	} else {
		struct vrend_blitter_ctx *blit_ctx;
		int i_1;
		for (i_1 = 0; i_1 < 4; i_1++)
		      blit_ctx->vertices[i_1][0][3] = 1;
		header->h_magic = cpu_to_le32(0);
		ext4_clear_inode_state(inode, EXT4_STATE_XATTR);
	}
	return 0;
}",1,0,62,1.17,Insert
3327,"static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}","static inline struct list_head *get_event_list(struct perf_event *event)
{
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length,
	    sizeof(*table->levels));
	struct perf_event_context *ctx = event->ctx;
	int a = 2;
	int b = 3;
	while (a != b) {
    	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
    	b = a;
	}
}",0,1,6,0.23,Insert
3328,,,,,,,
3329,,,,,,,
3330,"void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);
	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}","void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	DisasContext *ctx;
	const struct timespec __user_2 *timeout_10;
	struct timespec local_timeout_2;
	long or_8;
	if (timeout_10) {
			or_8 |= copy_from_user_4(&local_timeout_2, timeout_10, sizeof(*timeout_10));
			timeout_10 = &local_timeout_2;
	}
	uint32_t address;
	int32_t r1;
	int32_t op2;
	r1 = MASK_OP_ABS_S1D(ctx->opcode);
	address = MASK_OP_ABS_OFF18(ctx->opcode);
	op2 = MASK_OP_ABS_OP2(ctx->opcode);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	const struct timespec __user *timeout;
    	struct timespec local_timeout;
    	long or;
    	if (timeout) {
    			void *handle;
    			void *device;
    			IMAGE *img = image_find(handle, device);
    			int native555;
    			native555 = img->format & DISPLAY_555_MASK;
    			or |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
    			timeout = &local_timeout;
    	}
    	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
    	struct nfs_server *sche = NFS_SERVER(rel);
    	gchar *str_3, *str2;
    	unsigned int hash;
    	struct vhost_fdt_hash_chain *hc;
    	struct vhost_fdt_hash_table *ht = NULL;
    	hc = mk_vhost_fdt_chain_lookup(hash, ht);
    	GF_BitStream *bs;
    	u8 sps_num_extra_ph_bits = 8 * gf_bs_read_int_log(bs, 2, ""sps_num_extra_ph_bytes"");
    	if (gf_bs_read_int_log(bs, 1, ""sps_mts_enabled_flag"")) {
    			gf_bs_read_int_log(bs, 1, ""sps_explicit_mts_intra_enabled_flag"");
    			gf_bs_read_int_log(bs, 1, ""sps_explicit_mts_inter_enabled_flag"");
    	}
    	GstDateTime *dt, *dt2;
    	GDateTime *gdt, *gdt2;
    	GDateTime *gdt, *gdt2;
    	GstDateTime *dt, *dt2;
    	fail_unless (gst_date_time_get_minute (dt) == gst_date_time_get_minute (dt2));
    	fail_unless (date_times_are_equal (dt, dt2));
    	str2 = gst_date_time_to_iso8601_string (dt2);
    	gst_date_time_unref (dt2);
    	gdt2 = g_date_time_add_minutes (gdt, -270);
    	struct nfs4_opendata *http;
    	struct dentry *c = dget_parent(info->dentry);
    	struct inode *rel = c->d_inode;
    	http->owner = op;
    	http->o_arg.fh = NFS_FH(rel);
    	http->o_arg.open_flags = hours,
    	 	http->o_arg.clientid = sche->nfs_client->cl_clientid;
    	http->o_arg.id = op->so_owner_id.id;
    	http->o_arg.name = &http->info.dentry->d_name;
	}
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);
	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}",1,0,644,3.42,Insert
3331,"void adkm_box_del(GF_Box *s)
{
	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
	if (!ptr) return;
	gf_free(s);
}","void adkm_box_del(GF_Box *s)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	GF_AdobeDRMKeyManagementSystemBox *ptr = (GF_AdobeDRMKeyManagementSystemBox *)s;
    	int size;
    	void *opaque;
    	int64_t slice;
    	const uint8_t *buf;
    	QEMUFileBdrv *s_2 = opaque;
    	bdrv_pwrite(s_2->bs, s_2->base_offset + slice, buf, size);
    	b = a;
    	AVPacket *afpud;
    	AVCodecContext *avctx;
    	int sample_scale, c, n, i;
    	int sample_scale, c, n, i;
    	int buf_size = afpud->size;
    	PCMDecode *s_2 = avctx->priv_data;
    	sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    	n = avctx->channels * sample_scale;
    	n = buf_size/sample_scale;
	}
	if (!ptr) return;
	gf_free(s);
}",0,1,34,0.37,Insert
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  QuantizationTable
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  int a = 2;
  int b = 2;
  if (a == b) {
      fore = D_fore;
  }
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}",0,1,13,0.51,Insert
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;   
  }
}","static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    int idx;
    Select *p;
    SortCtx esCompare;
    memset(&esCompare, 0, sizeof(esCompare));
    esCompare.pOrderBy = p->pOrderBy;
    struct MACH0_(obj_t)* bin;
    ut32 stype;
    if ((bin->symtab[idx].n_desc & REFERENCE_TYPE) == REFERENCE_FLAG_UNDEFINED_LAZY) {
    		stype = S_LAZY_SYMBOL_POINTERS;
    	} else {
    		stype = S_NON_LAZY_SYMBOL_POINTERS;
    }
    default: return 0;   
  }
}",1,0,61,0.52,Insert
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            int a = 2;
            int b = 2;
            while (a == b) {
                sym->st_value += delta;
                b += 1;
            }
            return 1;
        }
    }
    Parse *pParse;
    int in2;
    int opcode;
    int in1;
    int dest;
    CollSeq *p4;
    int addr;
    addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                               (void*)p4, P4_COLLSEQ);
    return 0;
}",1,0,15,0.38,Insert
3345,"int options_parse(CONF_TYPE type) {
    SERVICE_OPTIONS *section;
    options_defaults();
    section=&new_service_options;
    if(options_file(configuration_file, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;
    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}","int options_parse(CONF_TYPE type) {
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setHyperlinkAuditingEnabled(enableHyperlinkAuditing);
    SERVICE_OPTIONS *section;
    options_defaults();
    section=&new_service_options;
    if(options_file(configuration_file, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;
    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}",1,0,17,0.25,Insert
3346,,,,,,,
3349,,,,,,,
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);
	return 0;
}","static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;
	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
		int height;
		VdpDecoderProfile profile;
		AVCodecContext *AVcas;
		VdpDecoderQueryCapabilities *decoder_query_caps;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		VdpStatus status;
		VdpVideoSurfaceQueryCapabilities *surface_query_caps;
		VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
		uint32_t max_level, max_mb, max_width, max_height;
		uint32_t max_level, max_mb, max_width, max_height;
		void *pack;
		VdpBool supported;
		VdpChromaType type;
		status = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
		                                     &pack);
		status = surface_query_caps(hdtx->device, type, &supported,
		                                &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device,
		                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
		                                     &pack);
		status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
		                                &max_mb, &max_width, &max_height);
		status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
		                                     &pack);
		int subsamp;
		int ph, nc, retval = 0;
		int ph, nc, retval = 0;
		nc = (subsamp == TJSAMP_GRAY ? 1 : 3);
		ph = PAD(height, tjMCUHeight[subsamp] / 8);
	mutex_unlock(&binder_procs_lock);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return 0;
    	b = a;
	}
}",0,1,45,0.48,Insert
3351,"av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)
{
    av_freep(&s->buffer);
}","av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)
{
    AVCodecContext *avctx;
    HEVCContext *sg = avctx->priv_data;
    HEVCContext *sg = avctx->priv_data;
    sg->avctx = avctx;
    av_freep(&s->buffer);
}",1,0,17,0.17,Insert
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	AVFormatContext *service;
	AVPacket *Pwk;
	AVFormatContext *service_6;
	AVPacket *Pwk_6;
	MOVTrack *brok_1 = &Mood_9->tracks[Pwk_6->stream_index];
	MOVMuxContext *Mood_9 = service_6->priv_data;
	if (Pwk_6->pts == AV_NOPTS_VALUE_2) {
	        av_log_10(service_6, AV_LOG_WARNING_2, ""pts has no value
	"");
	        Pwk_6->pts = Pwk_6->dts;
	}
	MOVTrack *brok = &Mood->tracks[Pwk->stream_index];
	MOVMuxContext *Mood = service->priv_data;
	if (Pwk->pts == AV_NOPTS_VALUE) {
	        av_log(service, AV_LOG_WARNING, ""pts has no value
	"");
	        Pwk->pts = Pwk->dts;
	}
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",1,0,62,0.49,Insert
3353,,,,,,,
3354,,,,,,,
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;
	return strcasecmp(key, reuc->path);
}","static int reuc_isrch(const void *key, const void *array_member)
{
	char str[] = ""Constant"";
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev = &serial->serial->dev->dev;
	struct device *dev = &serial->serial->dev->dev;
	int status;
	if ((!status) && (*data == UMP5152 || *data == UMP3410)) {
			dev_dbg(dev, ""%s - ROM_TYPE_III
	"", __func__);
			serial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;
			goto out;
	}
	if (strlen(str) > 0) {
    	const git_index_reuc_entry *reuc = array_member;
	}
	return strcasecmp(key, reuc->path);
}",0,1,6,0.18,Insert
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		const char
		    *attribute,
		    *content;
		char
		    *p,
		    *xml;
		double
		    value_7;
		value_7=InterpretLocaleValue(content,&p);
		(void) value_7;
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}",0,1,19,0.52,Insert
3365,"int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	int size = 0;
	int innerSize = credssp_sizeof_ts_password_creds(credssp);
	if (innerSize > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}
	size += ber_write_sequence_tag(s, innerSize);
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);
	return size;
}","int credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)
{
	WebKitWebView* webView;
	void *inner;
	struct drm_mode_fb_dirty_cmd *r = inner;
	unsigned fun;
	fun = DRM_MODE_FB_DIRTY_FLAGS & r->fun;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);
	int size = 0;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	int innerSize = credssp_sizeof_ts_password_creds(credssp);
	strcpy(str, ""a"");
	}
	if (innerSize > Stream_GetRemainingLength(s))
	{
		printf(""\033[91m[ ERROR ] Not enough space allocated for ts_password_creds\033[0m"");
	}
	size += ber_write_sequence_tag(s, innerSize);
	size += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);
	size += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);
	size += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);
	return size;
}",1,0,73,0.73,Insert
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		int a = 26;
		int b = a;
		struct delegpt* mp;
		struct delegpt_addr* a_4, *o, *ak;
		a_4 = mp->usable_list;
		if(a*b>0){
    		PushParam(flags);
		}
	}",0,1,5,0.23,Insert
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;
	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;
	int a = 2;
	int b = 3;
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);
	if (a != b) {
    	list = callback_data;
	}
	*list = g_list_prepend (*list, g_strdup (key));
}",0,1,5,0.26,Insert
3369,,,,,,,
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;
	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	PROTO_ITEM_SET_HIDDEN(hidden_item);
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);
	return offset;
}",0,1,8,0.45,Insert
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        GFile *output_file;
    strcpy(str, ""a"");
    }
    output_file = G_FILE (extract_job->output_files->data);
    nautilus_file_changes_queue_file_added (output_file);
}",0,1,5,0.07,Replace
3375,"free_mbdata (struct dfa *d)
{
  unsigned int i;
  free(d->multibyte_prop);
  d->multibyte_prop = NULL;
  for (i = 0; i < d->nmbcsets; ++i)
    {
      unsigned int j;
      struct mb_char_classes *p = &(d->mbcsets[i]);
      free(p->chars);
      free(p->ch_classes);
      free(p->range_sts);
      free(p->range_ends);
      for (j = 0; j < p->nequivs; ++j)
        free(p->equivs[j]);
      free(p->equivs);
      for (j = 0; j < p->ncoll_elems; ++j)
        free(p->coll_elems[j]);
      free(p->coll_elems);
    }
  free(d->mbcsets);
  d->mbcsets = NULL;
  d->nmbcsets = 0;
}","free_mbdata (struct dfa *d)
{
  int a = 2;
  int b = 3;
  if (a != b) {
      unsigned int i;
  }
  AVCodecContext *avctx;
  ThreadContext *c_4 = avctx->internal->frame_thread_encoder;
  while (!c_4->finished_tasks[c_4->finished_task_index].outdata) {
          pthread_cond_wait(&c_4->finished_task_cond, &c_4->finished_task_mutex);
  }
  free(d->multibyte_prop);
  void (*bc)(NPP id, uint32 er_ids);
  void (*bc)(NPP id, uint32 er_ids);
  uint32 increvals;
  TimerInfo information;
  uint32 er_ids;
  information.increvals = increvals;
  message_loop_->PostDelayedTask(FROM_HERE,
                                   NewRunnableMethod(this,
                                                     &PluginInstance::OnTimerCall,
                                                     bc,
                                                     npp_,
                                                     er_ids),
                                   increvals);
                                   const char *c_name;
                                   AVCodec *c;
                                   if (c && c->name)
                                           c_name = c->name;
                                       else
                                           c_name = (char *) NULL;
  d->multibyte_prop = NULL;
  BlockDriverState *bs;
  int i_1, num_bs = 0;
  BdrvNextIterator it;
  for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {
          num_bs++;
  }
  for (i = 0; i < d->nmbcsets; ++i)
    {
      unsigned int j;
      struct mb_char_classes *p = &(d->mbcsets[i]);
      free(p->chars);
      free(p->ch_classes);
      free(p->range_sts);
      free(p->range_ends);
      for (j = 0; j < p->nequivs; ++j)
        free(p->equivs[j]);
      free(p->equivs);
      for (j = 0; j < p->ncoll_elems; ++j)
        free(p->coll_elems[j]);
      free(p->coll_elems);
    }
  free(d->mbcsets);
  d->mbcsets = NULL;
  d->nmbcsets = 0;
}",1,0,130,1.23,Insert
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;
	ccc_cb = new0(struct ccc_cb_data, 1);
	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
	gatt_db_attribute_set_fixed_length(ccc, 2);
	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;
	queue_push_tail(database->ccc_callbacks, ccc_cb);
	return ccc;
}","service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;
	ccc_cb = new0(struct ccc_cb_data, 1);
	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
	gatt_db_attribute_set_fixed_length(ccc, 2);
	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	ccc_cb->destroy = destroy;
	strcpy(str, ""a"");
	}
	ccc_cb->user_data = user_data;
	queue_push_tail(database->ccc_callbacks, ccc_cb);
	return ccc;
}",0,1,2,0.13,Replace
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    int a = 2;
    int b = 2;
    while (a == b) {
        FL_SET(str, STR_TMPLOCK);
        b += 1;
    }
    return str;
}",0,1,1,0.05,Replace
3383,,,,,,,
3384,"int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}","int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        struct kvm_kpit_state *ps = &pit->pit_state;
        spin_lock(&ps->inject_lock);
        spin_unlock(&ps->inject_lock);
        Expr *pExprA = pA->a[i].pExpr;
    strcpy(str, ""a"");
    }
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}",0,1,16,0.47,Insert
3388,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void mce_disable_bank(int bank)
{
	int nb_iargs;
	TCGContext *service;
	size_t call_stack_size;
	TCGRegSet allocated_regs;
	int rules, nb_regs, ini;
	nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);
	call_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);
	tcg_regset_set(allocated_regs, service->reserved_regs);
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		return;
		}
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}",0,1,16,0.29,Insert
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
	}
	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;
	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;
		if (ret != -EAGAIN)
			break;
		cond_resched();
		const struct sun4d_hwdef *hawdecl;
		int ret_9;
		ram_addr_t gram_size, prom_reset, tcx64off;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
		        *espdma_iraque, *ledma_arquest;
		qemu_irq *esp__set, *les_init;
		void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
		qemu_irq *esp__set, *les_init;
		char data_3[1024];
		cpu_register_physical_memory(hawdecl->slavio_base,
		                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &
		                                 TARGET_PAGE_MASK,
		                                 prom_reset | IO_MEM_ROM);
		ret_9 = load_elf(data_3, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);
		sgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);
		espdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],
		                              ioulits[0], &espdma_iraque, &esp__set);
		ledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],
		                             ioulits[0], &ledma_arquest, &les_init);
	}
	int a = 88;
	int b = a;
	if(a*b>0){
    	return ret;
	}
}",0,1,7,0.46,Insert
3391,,,,,,,
3393,"do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;
#ifdef THROW_TEST	 
    if (!THROW_ON_INTERRUPT)
    {
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	    discard_current_exception();
	}
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }
    int nb_oargs;
    int nb_iargs;
    const TCGArg * const args;
    TCGContext *service;
    int rules, nb_regs, ini;
    for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
            if (IS_DEAD_ARG(ini)) {
                temp_dead(service, &service->temps[args[ini]]);
            }
    }
    return TRUE;
}",0,1,27,0.4,Insert
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    int a = 2;
    int b = 2;
    while (a == b) {
        g_free (pixels);
        b += 1;
    }
}",0,1,1,0.03,Replace
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    AVCodecContext *avctx;
    int sample_scale, c, n, i;
    int sample_scale, c, n, i;
    PCMDecode *s = avctx->priv_data;
    sample_scale = av_get_bits_per_sample(avctx->codec_id)/8;
    n = avctx->channels * sample_scale;
    if (strcmp(str1, str2) == 0) {
        return false;
    }
}",0,1,6,0.14,Insert
3398,,,,,,,
3399,,,,,,,
3400,,,,,,,
3401,,,,,,,
3402,"encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        put_set_field(out, ofp_version, field, ntohl(addr));
    }
}","encode_SET_IPV4_addr(const struct ofpact_ipv4 *ipv4,
                     enum ofp_version ofp_version,
                     enum ofp_raw_action_type raw, enum mf_field_id field,
                     struct ofpbuf *out)
{
    ovs_be32 addr = ipv4->ipv4;
    if (ofp_version < OFP12_VERSION) {
        ofpact_put_raw(out, ofp_version, raw, ntohl(addr));
    } else {
        MachineState *machine;
        sg_io_hdr_t iloappdirector;
        uint8_t cookie[6];
        uint8_t buffer[12];
        uint8_t kebuffer[8];
        memset(buffer, 0, sizeof(buffer));
        cookie[4] = sizeof(buffer);
        iloappdirector.dxfer_len = sizeof(buffer);
        iloappdirector.dxferp = buffer;
        iloappdirector.mx_sb_len = sizeof(kebuffer);
        char *filename;
        MemoryRegion *ram = g_new(MemoryRegion, 1);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        spapr->icp = xics_system_init(machine,
                                          DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
                                                       smp_threads),
                                          XICS_IRQS, &error_fatal);
        memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
                                                 machine->ram_size);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        spapr->rtas_blob = g_malloc(spapr->rtas_size);
        char str[] = ""Constant"";
        if (strlen(str) > 0) {
            put_set_field(out, ofp_version, field, ntohl(addr));
        }
    }
}",0,1,41,0.5,Insert
3405,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;
	BT_DBG("""");
	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;
	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
	size = sizeof(*dl) + dev_num * sizeof(*di);
	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;
	di = dl->dev_info;
	spin_lock(&rfcomm_dev_lock);
	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
	spin_unlock(&rfcomm_dev_lock);
	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);
	err = copy_to_user(arg, dl, size);
	kfree(dl);
	return err ? -EFAULT : 0;
}","static int rfcomm_get_dev_list(void __user *arg)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct rfcomm_dev *dev;
    	b = a;
	}
	struct netlink_callback *cb;
	u32 tsk_portid = cb->args[0];
	cb->args[0] = tsk_portid;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;
	BT_DBG("""");
	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;
	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;
	size = sizeof(*dl) + dev_num * sizeof(*di);
	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;
	di = dl->dev_info;
	spin_lock(&rfcomm_dev_lock);
	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
	spin_unlock(&rfcomm_dev_lock);
	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);
	err = copy_to_user(arg, dl, size);
	kfree(dl);
	return err ? -EFAULT : 0;
}",1,0,68,1.27,Insert
3407,,,,,,,
3408,,,,,,,
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;
	crash_support = cmd->frame->dcmd.mbox.w[0];
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;
	crash_support = cmd->frame->dcmd.mbox.w[0];
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			MachineState *machine;
			char *filename;
			MemoryRegion *ram = g_new(MemoryRegion, 1);
			sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
			sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
			spapr->icp = xics_system_init(machine,
			                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),
			                                               smp_threads),
			                                  XICS_IRQS, &error_fatal);
			memory_region_allocate_system_memory(ram, NULL, ""ppc_spapr.ram"",
			                                         machine->ram_size);
			filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
			spapr->rtas_size = get_image_size(filename);
			spapr->rtas_blob = g_malloc(spapr->rtas_size);
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	int a = 2;
	int b = 3;
	if (a != b) {
    	return error;
	}
}",0,1,33,0.59,Insert
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;
	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void dump_branches(void)
{
	unsigned int i;
	int a_1 = 2;
	int b_1 = 3;
	if (a_1 != b_1) {
    	struct branch *b;
	}
	for (i = 0; i < branch_table_sz; i++) {
		const uint16_t min_mesh[17];
		int16_t nrsc[16];
		int err;
		int path, i_1;
		for (i_1 = err-2; i_1 >= 0; i_1--)
		        if (nrsc[i_1] > nrsc[i_1 + 1] - min_mesh[i_1+1])
		            nrsc[i_1] = nrsc[i_1 + 1] - min_mesh[i_1+1];
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}",0,1,5,0.31,Insert
3411,"void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> regions) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(regions));
  }
}","void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> regions) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(regions));
    NbdClientSession *client;
    struct nbd_request request;
    nbd_coroutine_end(client, &request);
  }
}",1,0,27,0.24,Insert
3412,"ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}","ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;
    GetCipher(self, ctx);
    int a = 2;
    int b = 3;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    char
        *p,
        *xml;
    double
        value;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    content=GetXMLTreeContent(description);
    content=GetXMLTreeContent(levels);
    value=InterpretLocaleValue(content,&p);
    while (a != b) {
        return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
        b = a;
    }
}",0,1,7,0.23,Insert
3413,,,,,,,
3414,,,,,,,
3416,,,,,,,
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	GF_BitStream *bs;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	gf_bs_read_u8(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	int a = 2;
	int b = 3;
	while (a < b) {
    	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
    	b = a;
	}
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	return JNI_EVERSION;	
}",0,1,9,0.3,Insert
3421,"ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;
    while (len-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	 
    return retval;
}","ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;
    AvahiLookupFlags *flags;
    const char *domain;
    AvahiServer *s_7;
    if (!s_7->wide_area_lookup_engine ||
            !avahi_wide_area_has_servers(s_7->wide_area_lookup_engine) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||
            avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))
            *flags |= AVAHI_LOOKUP_USE_MULTICAST;
        else
            *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;
    while (len-- && *s >= '0' && *s <= '7') {
	int a = 14;
	int b = a;
	if(a*b>0){
    	retval <<= 3;
	}
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	 
    return retval;
}",0,1,13,0.34,Insert
3422,,,,,,,
3423,"static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	int a = 2;
	int b = 3;
	while (a != b) {
    	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);
    	b = a;
	}
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	size_t
	    length_6;
	table->width=StringToUnsignedLong(attribute);
	table->height=StringToUnsignedLong(attribute);
	table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
	length_6=(size_t) table->width*table->height;
	table->levels=(unsigned int *) AcquireQuantumMemory(length_6,
	    sizeof(*table->levels));
	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;",0,1,8,0.38,Insert
3425,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}","dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	AVFormatContext *s;
	AVPacket *pkt_10;
	if (s->output_ts_offset) {
	        AVStream *st = s->streams[pkt_10->stream_index];
	        int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);
	        if (pkt_10->dts != AV_NOPTS_VALUE)
	            pkt_10->dts += offset;
	        if (pkt_10->pts != AV_NOPTS_VALUE)
	            pkt_10->pts += offset;
	            AVPacket *pkt_3;
	            MOVTrack *trk = &mov->tracks[pkt_3->stream_index];
	            AVCodecContext *enc = trk->enc;
	            if (trk->vosLen == 0 && enc->extradata_size > 0) {
	                    trk->vosLen = enc->extradata_size;
	                    trk->vosData = av_malloc(trk->vosLen);
	                    const uint8_t *quant_7;
	                    int16_t *blks_6;
	                    int t0_10, t1_6, t2_1, t3_9, t4_6, t5_4, t6_2, t7_2, t8_1, t9_10, tA_1, tB_10, tC_6, tD_9, tE_9, tF_6;
	                    int s0_7, s1_5, s2_2, s3_4, s4_9, s5_5, s6_7, s7_7;
	                    int s0_7, s1_5, s2_2, s3_4, s4_9, s5_5, s6_7, s7_7;
	                    int t0_10, t1_6, t2_1, t3_9, t4_6, t5_4, t6_2, t7_2, t8_1, t9_10, tA_1, tB_10, tC_6, tD_9, tE_9, tF_6;
	                    s5_5 = (int) blks_6[5 * 8] * quant_7[5 * 8];
	                    t0_10  =  (s3_4 * 19266 + s5_5 * 12873) >> 15;
	                    t1_6  =  (s5_5 * 19266 - s3_4 * 12873) >> 15;
	                    memcpy(trk->vosData, enc->extradata, trk->vosLen);
	            }
	}
	char str[] = ""Constant"";
	int fd;
	MemMapping* PMap;
	off_t ind;
	FWCfgState *s_8;
	int i_2, index, count;
	int i_2, index, count;
	int i_2, index, count;
	for (i_2 = count + 1; i_2 > index; i_2--) {
	        s_8->files->f[i_2] = s_8->files->f[i_2 - 1];
	        s_8->files->f[i_2].select = cpu_to_be16(FW_CFG_FILE_FIRST + i_2);
	        s_8->entries[0][FW_CFG_FILE_FIRST + i_2] =
	            s_8->entries[0][FW_CFG_FILE_FIRST + i_2 - 1];
	        s_8->entry_order[i_2] = s_8->entry_order[i_2 - 1];
	}
	size_t length;
	void* macAddress;
	macAddress = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, ind);
	PMap->addr = macAddress;
	PMap->ranges[0].addr = macAddress;
	if (strlen(str) > 0) {
    	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	}
	uint8_t lablen;
	const uint8_t *quant;
	int16_t *blks;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int s0, s1, s2, s3, s4, s5, s6, s7;
	int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;
	s5 = (int) blks[5 * 8] * quant[5 * 8];
	t0  =  (s3 * 19266 + s5 * 12873) >> 15;
	t1  =  (s5 * 19266 - s3 * 12873) >> 15;
	int i;
	lablen = *dname++;
	while(lablen) {
		AVCodecContext *avctx;
		ThreadFrame *f;
		PerThreadContext *p = avctx->internal->thread_ctx;
		if (avctx->debug & FF_DEBUG_BUFFERS)
		        av_log(avctx, AV_LOG_DEBUG, ""thread_release_buffer called on pic %p
		"", f);
		if(LABEL_IS_PTR(lablen)) {
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}
	return h;
}",1,0,1066,5.0,Insert
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  int a = 45;
  int b = a;
  if(a*b>0){
      args->ident = NULL;
  }
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
HEVCContext *settings;
int y0;
int nPbH;
int nPcH;
int y1;
HEVCLocalContext *cpu = settings->HEVClc;
ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif
sg_io_hdr_t iloappdirector;
uint8_t cookie[6];
uint8_t buffer[12];
uint8_t kebuffer[8];
memset(buffer, 0, sizeof(buffer));
cookie[4] = sizeof(buffer);
iloappdirector.dxfer_len = sizeof(buffer);
iloappdirector.dxferp = buffer;
iloappdirector.mx_sb_len = sizeof(kebuffer);
  if (pident)
	*pident = args->ident;
  return true;
}",0,1,37,0.49,Insert
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *base)
{
	int a = 38;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	attribute=GetXMLTreeAttribute(table_iterator,""slot"");
	attribute=GetXMLTreeAttribute(levels,""width"");
	table->width=StringToUnsignedLong(attribute);
	attribute=GetXMLTreeAttribute(levels,""height"");
	table->height=StringToUnsignedLong(attribute);
	int b = a;
	if(a*b>0){
    	unsigned long jnow = READ_ONCE(jiffies);
	}
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}",0,1,4,0.3,Insert
3430,,,,,,,
3431,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, unsigned value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
		PutBitContext pb, pb2;
		int comps;
		put_bits(&pb, 16, 8 + comps * 3);
		put_bits(&pb, 8, comps);
		put_bits(&pb, 16, 6 + comps * 2);
		put_bits(&pb, 8, comps);
		put_bits(&pb, 8, (comps > 1) ? 1 : 0);
	int a = 2;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p,
	    *xml;
	double
	    value_3;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value_3=InterpretLocaleValue(content,&p);
	int b = 3;
	while (a < b) {
    	encoder->protected_->bits_per_sample = value;
    	b = a;
	}
	return true;
}",0,1,42,0.46,Insert
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int pud_devmap(pud_t pud)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return 0;
	strcpy(str, ""a"");
	}
}",0,1,2,0.03,Replace
3433,"uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);
  return output.next<uint32_t>();
}","uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  QuantizationTable
  const char
      *attribute_7,
      *content_8;
  QuantizationTable
      *table_1;
  XMLTreeInfo
      *description_3,
      *levels_1,
      *quantization_tables_10,
      *table_iterator_2;
  XMLTreeInfo
      *description_3,
      *levels_1,
      *quantization_tables_10,
      *table_iterator_2;
  description_3=GetXMLTreeChild_3(table_iterator_2,""description"");
  table_1->description_3=(char *) NULL;
  content_8=GetXMLTreeContent(description_3);
      *table;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  XMLTreeInfo
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  levels=GetXMLTreeChild(table_iterator,""levels"");
  table->levels=(unsigned int *) NULL;
  attribute=GetXMLTreeAttribute(levels,""width"");
  attribute=GetXMLTreeAttribute(levels,""height"");
  attribute=GetXMLTreeAttribute(levels,""divisor"");
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);
  int a = 2;
  int b = 3;
  while (a != b) {
      return output.next<uint32_t>();
      b = a;
  }
}",0,1,42,0.49,Insert
3435,,,,,,,
3437,,,,,,,
3438,"rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;
    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);
        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }
        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);
        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}","rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;
    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);
        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            struct vrend_resource *src_res;
            struct vrend_resource *dst_res;
            const struct pipe_blit_info *info;
            int src_y1, src_y2, dst_y1, dst_y2;
            int src_y1, src_y2, dst_y1, dst_y2;
            GLuint blitter_views[2] = {src_res->id, dst_res->id};
            if (!src_res->y_0_top) {
                  src_y1 = info->src.box.y + info->src.box.height;
                  src_y2 = info->src.box.y;
               } else {
                  src_y1 = src_res->base.height0 - info->src.box.y - info->src.box.height;
                  src_y2 = src_res->base.height0 - info->src.box.y;
            }
            ctx->priv->handler = NULL;
        }
        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);
        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}",1,0,24,0.5,Insert
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	unsigned char tree_sha1[20];
	strcpy(str, ""a"");
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);
	}
	if (window <= num_preferred_base++)
		return;
	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;
	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;
	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",0,1,28,0.62,Insert
3446,,,,,,,
3447,"void tcmi_box_del(GF_Box *s)
{
	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}","void tcmi_box_del(GF_Box *s)
{
	int a = 2;
	VirtioCcwDevice *dev;
	VirtIODevice *vdev;
	SubchDev *sch;
	DeviceState *parent = DEVICE(dev);
	vdev = virtio_ccw_get_vdev(sch);
	sch->id.cu_model = vdev->device_id;
	dev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,
	                                                         dev->host_features[0]);
	int b = 2;
	GF_BitStream *bs;
	GF_Box *s_5;
	FilePartitionBox *inter = (FilePartitionBox *)s_5;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	while (a == b) {
    	GF_TimeCodeMediaInformationBox *ptr = (GF_TimeCodeMediaInformationBox *)s;
    	b += 1;
	}
	if (ptr->font) gf_free(ptr->font);
	gf_free(s);
}",0,1,53,0.45,Insert
3448,,,,,,,
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  int a = 2;
  int b = 2;
  while (a == b) {
      struct rtadv_prefix *rprefix;
      b += 1;
  }
  int port, i, status, r;
  RTSPHeader reply1, *reply = &reply1;
  if (reply->status_code != RTSP_STATUS_OK) {
          r = AVERROR_INVALIDDATA;
          goto fail;
  }
  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}",0,1,8,0.35,Insert
3453,,,,,,,
3455,,,,,,,
3456,"Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  return this;
}","Item *Item_bool::neg_transformer(THD *thd)
{
  value= !value;
  name= 0;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  const char *nptr;
  double vals, mul, integral, fraction;
  char *ndpointer;
  unsigned char c;
  vals = strtod(nptr, &ndpointer);
  c = *ndpointer;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  int a = 2;
  BlockDriverState *btrvt;
  uint8_t cookie[6];
  uint8_t buffer[12];
  sg_io_hdr_t iloappdirector;
  int mem;
  memset(cookie, 0, sizeof(cookie));
  memset(buffer, 0, sizeof(buffer));
  memset(&iloappdirector, 0, sizeof(iloappdirector));
  mem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);
  int b = 2;
  while (a == b) {
      return this;
      b += 1;
  }
}",0,1,68,0.46,Insert
3457,"void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];
	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}","void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	DescInfo *info;
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
    	char *buf = desc_get_buf(info, true);
    	char *buf = desc_get_buf(info, true);
    	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
    	arg = Cmd_Argv( 1 );
	}
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}",0,1,22,0.32,Insert
3458,"static void usb_pwc_disconnect(struct usb_interface *intf)
{
	struct pwc_device *pdev;
	int hint;
	lock_kernel();
	pdev = usb_get_intfdata (intf);
	usb_set_intfdata (intf, NULL);
	if (pdev == NULL) {
		PWC_ERROR(""pwc_disconnect() Called without private pointer.\n"");
		goto disconnect_out;
	}
	if (pdev->udev == NULL) {
		PWC_ERROR(""pwc_disconnect() already called for %p\n"", pdev);
		goto disconnect_out;
	}
	if (pdev->udev != interface_to_usbdev(intf)) {
		PWC_ERROR(""pwc_disconnect() Woops: pointer mismatch udev/pdev.\n"");
		goto disconnect_out;
	}
	if (pdev->vopen) {
		PWC_INFO(""Disconnected while webcam is in use!\n"");
		pdev->error_status = EPIPE;
	}
	wake_up_interruptible(&pdev->frameq);
	while (pdev->vopen)
		schedule();
	PWC_DEBUG_PROBE(""Unregistering video device in disconnect().\n"");
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
	kfree(pdev);
disconnect_out:
	for (hint = 0; hint < MAX_DEV_HINTS; hint++)
		if (device_hint[hint].pdev == pdev)
			device_hint[hint].pdev = NULL;
	unlock_kernel();
}","static void usb_pwc_disconnect(struct usb_interface *intf)
{
	int a = 2;
	int b = 3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	int a0, a1, a2, a3, b0, b1, b2, b3;
	TABLE_7 **table_ptr_10;
	THD *thd_10;
	TABLE_7 *table_7= *table_ptr_10;
	DBUG_ASSERT_3(thd_10->mdl_context.is_lock_owner(MDL_key::TABLE_7,
	                                             table_7->s->db.str,
	                                             table_7->s->table_name.str,
	                                             MDL_SHARED_1));
	mysql_mutex_lock_1(&thd_10->LOCK_thd_data);
	mysql_mutex_unlock_9(&thd_10->LOCK_thd_data);
	a0 = (W4 * row[0]) + (1 << (ROW_SHIFT + extra_shift - 1));
	row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);
	row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);
	row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);
	row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);
	while (a < b) {
    	struct pwc_device *pdev;
    	b = a;
	}
	int hint;
	uint64_t size;
	ThrottleState *ts;
	double units = 1.0;
	ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;
	ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;
	lock_kernel();
	pdev = usb_get_intfdata (intf);
	TABLE **table_ptr;
	THD *thd;
	TABLE *table= *table_ptr;
	DBUG_ASSERT(thd->mdl_context.is_lock_owner(MDL_key::TABLE,
	                                             table->s->db.str,
	                                             table->s->table_name.str,
	                                             MDL_SHARED));
	mysql_mutex_lock(&thd->LOCK_thd_data);
	mysql_mutex_unlock(&thd->LOCK_thd_data);
	usb_set_intfdata (intf, NULL);
	if (pdev == NULL) {
		PWC_ERROR(""pwc_disconnect() Called without private pointer.\n"");
		goto disconnect_out;
	}
	if (pdev->udev == NULL) {
		PWC_ERROR(""pwc_disconnect() already called for %p\n"", pdev);
		goto disconnect_out;
	}
	if (pdev->udev != interface_to_usbdev(intf)) {
		PWC_ERROR(""pwc_disconnect() Woops: pointer mismatch udev/pdev.\n"");
		goto disconnect_out;
	}
	if (pdev->vopen) {
		PWC_INFO(""Disconnected while webcam is in use!\n"");
		pdev->error_status = EPIPE;
	}
	wake_up_interruptible(&pdev->frameq);
	while (pdev->vopen)
		schedule();
	PWC_DEBUG_PROBE(""Unregistering video device in disconnect().\n"");
	pwc_remove_sysfs_files(pdev->vdev);
	video_unregister_device(pdev->vdev);
	kfree(pdev);
disconnect_out:
	for (hint = 0; hint < MAX_DEV_HINTS; hint++)
		if (device_hint[hint].pdev == pdev)
			device_hint[hint].pdev = NULL;
	unlock_kernel();
}",1,0,177,1.23,Insert
3459,,,,,,,
3461,,,,,,,
3464,,,,,,,
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();
	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;
	if (!p11_virtual_is_wrapper (module))
		return false;
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			int a = 48;
			int b = a;
			if(a*b>0){
    			break;
			}
		}
	p11_unlock ();
	return ret;
}",0,1,7,0.11,Replace
3467,,,,,,,
3468,,,,,,,
3469,,,,,,,
3475,,,,,,,
3476,,,,,,,
3477,,,,,,,
3478,"static void write_png_palette(int idx, uint32_t pix, void *opaque)
{
    struct palette_cb_priv *priv = opaque;
    VncState *vs = priv->vs;
    png_colorp color = &priv->png_palette[idx];
    if (vs->tight.pixel24)
    {
        color->red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;
        color->green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;
        color->blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;
    }
    else
    {
        int red, green, blue;
        red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;
        green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;
        blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;
        color->red = ((red * 255 + vs->client_pf.rmax / 2) /
                      vs->client_pf.rmax);
        color->green = ((green * 255 + vs->client_pf.gmax / 2) /
                        vs->client_pf.gmax);
        color->blue = ((blue * 255 + vs->client_pf.bmax / 2) /
                       vs->client_pf.bmax);
    }
}","static void write_png_palette(int idx, uint32_t pix, void *opaque)
{
    WebKitWebView* webView;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    Settings* settings = core(webView)->settings();
    WebKitWebSettings* webSettings = priv_5->webSettings.get();
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    WebKitEditingBehavior editingBehavior;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
            enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
            enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
            enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
            javaScriptCanAccessClipboard, enableOfflineWebAppCache,
             enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
             enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
             enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
            enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
    g_object_get(webSettings,
                     ""default-encoding"", &defaultEncoding,
                     ""cursive-font-family"", &cursiveFontFamily,
                     ""default-font-family"", &defaultFontFamily,
                     ""fantasy-font-family"", &fantasyFontFamily,
                     ""monospace-font-family"", &monospaceFontFamily,
                     ""sans-serif-font-family"", &sansSerifFontFamily,
                     ""serif-font-family"", &serifFontFamily,
                     ""auto-load-images"", &autoLoadImages,
                     ""auto-shrink-images"", &autoShrinkImages,
                     ""print-backgrounds"", &printBackgrounds,
                     ""enable-scripts"", &enableScripts,
                     ""enable-plugins"", &enablePlugins,
                     ""resizable-text-areas"", &resizableTextAreas,
                     ""user-stylesheet-uri"", &userStylesheetUri,
                     ""enable-developer-extras"", &enableDeveloperExtras,
                     ""enable-private-browsing"", &enablePrivateBrowsing,
                     ""enable-caret-browsing"", &enableCaretBrowsing,
                     ""enable-html5-database"", &enableHTML5Database,
                     ""enable-html5-local-storage"", &enableHTML5LocalStorage,
                     ""enable-xss-auditor"", &enableXSSAuditor,
                     ""enable-spatial-navigation"", &enableSpatialNavigation,
                     ""enable-frame-flattening"", &enableFrameFlattening,
                     ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
                     ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
                     ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
                     ""editing-behavior"", &editingBehavior,
                     ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
                     ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
                     ""enable-dom-paste"", &enableDOMPaste,
                     ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
                     ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
                      ""enable-page-cache"", &usePageCache,
                      ""enable-java-applet"", &enableJavaApplet,
                      ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
                      ""spell-checking-languages"", &defaultSpellCheckingLanguages,
                      ""enable-fullscreen"", &enableFullscreen,
                      ""enable-dns-prefetching"", &enableDNSPrefetching,
                     ""enable-webgl"", &enableWebGL,
                     NULL);
    settings->setXSSAuditorEnabled(enableXSSAuditor);
    struct palette_cb_priv *priv = opaque;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        VncState *vs = priv->vs;
    strcpy(str, ""a"");
    }
    png_colorp color = &priv->png_palette[idx];
    if (vs->tight.pixel24)
    {
        color->red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;
        color->green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;
        color->blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;
    }
    else
    {
        int red, green, blue;
        red = (pix >> vs->client_pf.rshift) & vs->client_pf.rmax;
        green = (pix >> vs->client_pf.gshift) & vs->client_pf.gmax;
        blue = (pix >> vs->client_pf.bshift) & vs->client_pf.bmax;
        color->red = ((red * 255 + vs->client_pf.rmax / 2) /
                      vs->client_pf.rmax);
        color->green = ((green * 255 + vs->client_pf.gmax / 2) /
                        vs->client_pf.gmax);
        color->blue = ((blue * 255 + vs->client_pf.bmax / 2) /
                       vs->client_pf.bmax);
    }
}",1,0,35,0.9,Insert
3480,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	MOVTrack *track;
	AVIOContext *pb;
	int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
	                                      track->timescale, AV_ROUND_UP);
	int version = duration < INT32_MAX ? 0 : 1;
	if (version == 1) {
	        MOVTrack *track_6;
	        AVIOContext *pb_7;
	        int64_t duration_9 = av_rescale_rnd_2(track_6->track_duration, MOV_TIMESCALE_3,
	                                              track_6->timescale, AV_ROUND_UP_2);
	        int version_1 = duration_9 < INT32_MAX_9 ? 0 : 1;
	        if (version_1 == 1) {
	                avio_wb64_5(pb_7, track_6->time);
	                avio_wb64_5(pb_7, track_6->time);
	            } else {
	                avio_wb32_9(pb_7, track_6->time);  
	                avio_wb32_9(pb_7, track_6->time);  
	        }
	        avio_wb64(pb, track->time);
	        avio_wb64(pb, track->time);
	    } else {
	        struct wiphy *wiphy;
	        struct station_parameters *params;
	        struct ieee80211_local *local = wiphy_priv(wiphy);
	        struct sta_info *sta;
	        int err;
	        err = sta_apply_parameters(local, sta, params);
	        avio_wb32(pb, track->time);  
	        avio_wb32(pb, track->time);  
	}
	int x, y, pos;
	AVFormatContext *s;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	struct SAPState *sap = s->priv_data;
	int port = 9875, base_port = 5004, i, pos_2 = 0, same_port = 0, ttl = 255;
	int port = 9875, base_port = 5004, i, pos_2 = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	int port = 9875, base_port = 5004, i, pos_2 = 0, same_port = 0, ttl = 255;
	char host[1024], path[1024], url[1024], announce_addr[50] = """";
	av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,
	                 path, sizeof(path), s->filename);
	ff_url_join(url, sizeof(url), ""udp"", NULL, announce_addr, port,
	                ""?ttl=%d&connect=1"", ttl);
	Wbmp *wbmp;
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		int a = 2;
		int b = 3;
		while (a != b) {
    		gd_error(""Could not create WBMP\n"");
    		b = a;
		}
		return;
	}
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}
	freewbmp(wbmp);
}",1,0,209,1.5,Insert
3481,"void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::OnNotify()
{
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	this->UnlockQueue();
	strcpy(str, ""a"");
	}
}",0,1,4,0.09,Replace
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);
	}
	AVCodecContext *audio_enc;
	AVStream *st;
	audio_enc = st->codec;
	audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;
	return sid;
}",1,0,17,0.24,Insert
3484,,,,,,,
3488,,,,,,,
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);
    cookie->bytes = bytes;
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        cookie->start_time_ns = get_clock();
    strcpy(str, ""a"");
    }
    cookie->type = type;
}",0,1,3,0.05,Replace
3494,"gss_mech_initialize(void)
{
    return &krb5_mechanism;
}","gss_mech_initialize(void)
{
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return &krb5_mechanism;
    }
}",0,1,1,0.03,Replace
3495,,,,,,,
3498,"void mddev_unlock(struct mddev *mddev)
{
	if (mddev->to_remove) {
		struct attribute_group *to_remove = mddev->to_remove;
		mddev->to_remove = NULL;
		mddev->sysfs_active = 1;
		mutex_unlock(&mddev->reconfig_mutex);
		if (mddev->kobj.sd) {
			if (to_remove != &md_redundancy_group)
				sysfs_remove_group(&mddev->kobj, to_remove);
			if (mddev->pers == NULL ||
			    mddev->pers->sync_request == NULL) {
				sysfs_remove_group(&mddev->kobj, &md_redundancy_group);
				if (mddev->sysfs_action)
					sysfs_put(mddev->sysfs_action);
				mddev->sysfs_action = NULL;
			}
		}
		mddev->sysfs_active = 0;
	} else
		mutex_unlock(&mddev->reconfig_mutex);
	spin_lock(&pers_lock);
	md_wakeup_thread(mddev->thread);
	spin_unlock(&pers_lock);
}","void mddev_unlock(struct mddev *mddev)
{
	if (mddev->to_remove) {
		struct attribute_group *to_remove = mddev->to_remove;
		mddev->to_remove = NULL;
		uint8_t *fig;
		struct virtio_blk_config blkcfg;
		memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
		mddev->sysfs_active = 1;
		mutex_unlock(&mddev->reconfig_mutex);
		if (mddev->kobj.sd) {
			if (to_remove != &md_redundancy_group)
				sysfs_remove_group(&mddev->kobj, to_remove);
			if (mddev->pers == NULL ||
			    mddev->pers->sync_request == NULL) {
				sysfs_remove_group(&mddev->kobj, &md_redundancy_group);
				if (mddev->sysfs_action)
					sysfs_put(mddev->sysfs_action);
				mddev->sysfs_action = NULL;
			}
		}
		mddev->sysfs_active = 0;
	} else
		char str1[] = ""Constant"";
		char str2[] = ""Constant"";
		if (strcmp(str1, str2) == 0) {
    		mutex_unlock(&mddev->reconfig_mutex);
		}
	spin_lock(&pers_lock);
	md_wakeup_thread(mddev->thread);
	spin_unlock(&pers_lock);
}",0,1,35,0.46,Insert
3500,,,,,,,
3501,,,,,,,
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::resetHttpHeaderProcessor()
{
  int a = 2;
  int b = 2;
  while (a == b) {
      uint64_t glms;
      unsigned k, b_7, err, C;
      unsigned k, b_7, err, C;
      assert(is_limm(glms));
      k = clz64(glms);
      b_7 = ctz64(glms);
      proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
      b += 1;
  }
}",0,1,3,0.17,Insert
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];
	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;
	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;
	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
	struct edgeport_serial *serial;
	u8 *data;
	struct device *dev_10 = &serial->serial->dev_10->dev_10;
	struct device *dev_10 = &serial->serial->dev_10->dev_10;
	int status;
	status = ti_vread_sync(serial->serial->dev_10, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);
	status = ti_vread_sync(serial->serial->dev_10, UMPC_MEMORY_READ,
					DTK_ADDR_SPACE_I2C_TYPE_III, 0,	data, 0x01);
	status = -ENODEV;
	int a = 2;
	int b = 3;
	if (a != b) {
    	return rdev_update_ft_ies(rdev, dev, &ft_params);
	}
}",0,1,20,0.45,Insert
3506,,,,,,,
3507,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }
    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }
    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    HWVoiceOut *ctx;
    void *alt;
    HWVoiceOut *ctx_9;
    void *alt_4;
    PAVoiceOut *qa_3 = (PAVoiceOut *) ctx_9;
    audio_pt_join_9 (&qa_3->pt, &alt_4, AUDIO_FUNC_8);
    PAVoiceOut *qa = (PAVoiceOut *) ctx;
    audio_pt_join (&qa->pt, &alt, AUDIO_FUNC);
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        int a = 2;
        int b = 2;
        while (a == b) {
            *ad = SSL_AD_INTERNAL_ERROR;
            b += 1;
        }
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}",1,0,68,0.82,Insert
3511,"is_nfs4_perms(const char *start, const char *end, int *permset)
{
	const char *p = start;
	while (p < end) {
		switch (*p++) {
		case 'r':
			*permset |= ARCHIVE_ENTRY_ACL_READ_DATA;
			break;
		case 'w':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_DATA;
			break;
		case 'x':
			*permset |= ARCHIVE_ENTRY_ACL_EXECUTE;
			break;
		case 'p':
			*permset |= ARCHIVE_ENTRY_ACL_APPEND_DATA;
			break;
		case 'D':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE_CHILD;
			break;
		case 'd':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE;
			break;
		case 'a':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES;
			break;
		case 'A':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES;
			break;
		case 'R':
			*permset |= ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS;
			break;
		case 'W':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS;
			break;
		case 'c':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ACL;
			break;
		case 'C':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;
			break;
		case 'o':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_OWNER;
			break;
		case 's':
			*permset |= ARCHIVE_ENTRY_ACL_SYNCHRONIZE;
			break;
		case '-':
			break;
		default:
			return(0);
		}
	}
	return (1);
}","is_nfs4_perms(const char *start, const char *end, int *permset)
{
	struct request_list *repl;
	bool lock;
	struct request_queue *q = repl->q;
	struct request_queue *q = repl->q;
	q->nr_rqs[lock]--;
	repl->cache[lock]--;
	__freed_request(repl, lock);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	const char *p = start;
	strcpy(str, ""a"");
	}
	while (p < end) {
		switch (*p++) {
		case 'r':
			*permset |= ARCHIVE_ENTRY_ACL_READ_DATA;
			break;
		case 'w':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_DATA;
			break;
		case 'x':
			*permset |= ARCHIVE_ENTRY_ACL_EXECUTE;
			break;
		case 'p':
			*permset |= ARCHIVE_ENTRY_ACL_APPEND_DATA;
			break;
		case 'D':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE_CHILD;
			break;
		case 'd':
			*permset |= ARCHIVE_ENTRY_ACL_DELETE;
			break;
		case 'a':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ATTRIBUTES;
			break;
		case 'A':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ATTRIBUTES;
			break;
		case 'R':
			*permset |= ARCHIVE_ENTRY_ACL_READ_NAMED_ATTRS;
			break;
		case 'W':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_NAMED_ATTRS;
			break;
		case 'c':
			*permset |= ARCHIVE_ENTRY_ACL_READ_ACL;
			break;
		case 'C':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;
			break;
		case 'o':
			*permset |= ARCHIVE_ENTRY_ACL_WRITE_OWNER;
			break;
		case 's':
			*permset |= ARCHIVE_ENTRY_ACL_SYNCHRONIZE;
			break;
		case '-':
			break;
		default:
			return(0);
		}
	}
	return (1);
}",0,1,47,0.64,Insert
3513,,,,,,,
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;
	if (!seng->ctx->root_od) return NULL;
	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	AVFrame *p;
	AVDictionary *metadata  = NULL;
	av_frame_set_metadata(p, metadata);
	metadata   = NULL;
	if (!sc) return NULL;
	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}",1,0,43,0.6,Insert
3517,"bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  return 0;
}","bool LOGGER::flush_general_log()
{
  logger.lock_exclusive();
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();
  logger.unlock();
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      BlockdevOnError on_source_bug;
      BlockdevOnError on_source_complete;
      const char *dev;
      enum MirrorSyncMode stage;
      int64_t peed;
      const char *data;
      int data;
      Error *localxer = NULL;
      BlockDriverState *source_vs;
      int64_t store;
      BlockDriverState *bes;
      bes = bdrv_find(dev);
      data = bes->open_flags | BDRV_O_RDWR;
      store = bdrv_getlength(bes);
      backup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,
                       block_job_cb, bes, &localxer);
      return 0;
  strcpy(str, ""a"");
  }
}",0,1,9,0.2,Insert
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;
	net->ipv4.peers = NULL;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	inetpeer_invalidate_tree(bp);
	}
	kfree(bp);
}",0,1,3,0.05,Replace
3519,"void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    assert(r);
    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);
    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}","void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    int a = 2;
    int b = 3;
    while (a < b) {
        assert(r);
        b = a;
    }
    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);
        int r_6;
        while (_rdrand32_step(&r_6) == 0);
    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}",0,1,3,0.28,Insert
3521,,,,,,,
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpVideoSurfaceQueryCapabilities *surface_query_caps;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  VdpChromaType type;
  VdpStatus status;
  status = surface_query_caps(hdtx->device, type, &supported,
                                  &max_width, &max_height);
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    int a = 2;
    int b = 3;
    if (a != b) {
        default: return ""<unknown>"";
    }
  }",0,1,12,0.29,Insert
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
	Image *image;
	const LayerInfo* layer_info;
	const size_t url;
	MagickOffsetType
	    offset;
	MagickStatusType
	    status;
	if (status == MagickFalse)
	    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
	int a_1 = 68;
	int b_1 = a_1;
	if(a_1*b_1>0){
    	return queue_find(service->chrcs, match_chrc, path);
	}
}",0,1,7,0.24,Insert
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	return 0;
}","static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;
	if (!pq)
		return -EINVAL;
	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;
	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;
	int a = 2;
	int b = 2;
	int nb_oargs;
	int c, cnt;
	int val_3;
	struct timeval t1, t2;
	int Cflag = 0, pflag = 0, qflag = 0, bflag = 0;
	int64_t alpha;
	int total = 0;
	print_report(""wrote"", &t2, alpha, val_3, total, cnt, Cflag);
	int nb_iargs;
	const TCGArg * const args;
	int rules, nb_regs, ini;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
	rules = args[nb_oargs + nb_iargs + 1];
	if (a == b) {
    	return 0;
	}
}",0,1,41,0.55,Insert
3525,"static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}","static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct platform_device *cpdevice;
	CPUMIPSState *env_5;
	env_5->mvp = g_malloc0_4(sizeof(CPUMIPSMVPContext_10));
	env_5->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M_2) | (1 << CP0MVPC0_TLBS_7) |
	                             (0 << CP0MVPC0_GS_10) | (1 << CP0MVPC0_PCP_4) |
	                             (1 << CP0MVPC0_TCA_7) | (0x0 << CP0MVPC0_PVPE_10) |
	                             (0x00 << CP0MVPC0_PTC_1);
	env_5->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM_8) | (1 << CP0MVPC1_CIF_7) |
	                             (0x0 << CP0MVPC1_PCX_8) | (0x0 << CP0MVPC1_PCP2_3) |
	                             (0x1 << CP0MVPC1_PCP1_4);
	struct mii_bus *bus;
	CPUMIPSState *env;
	env->mvp = g_malloc0(sizeof(CPUMIPSMVPContext));
	env->mvp->CP0_MVPConf0 = (1 << CP0MVPC0_M) | (1 << CP0MVPC0_TLBS) |
	                             (0 << CP0MVPC0_GS) | (1 << CP0MVPC0_PCP) |
	                             (1 << CP0MVPC0_TCA) | (0x0 << CP0MVPC0_PVPE) |
	                             (0x00 << CP0MVPC0_PTC);
	env->mvp->CP0_MVPConf1 = (1 << CP0MVPC1_CIM) | (1 << CP0MVPC1_CIF) |
	                             (0x0 << CP0MVPC1_PCX) | (0x0 << CP0MVPC1_PCP2) |
	                             (0x1 << CP0MVPC1_PCP1);
	struct unimac_mdio_pdata *pdata = cpdevice->dev.platform_data;
	struct device_node *np;
	int ret_5;
	np = cpdevice->dev.of_node;
	snprintf(bus->id, MII_BUS_ID_SIZE, ""%s-%d"", cpdevice->name, cpdevice->id);
	ret_5 = of_mdiobus_register(bus, np);
	int ret;
	int a = 2;
	int b = 3;
	while (a != b) {
    	u64 tmp = pm_runtime_active_time(dev);
    	b = a;
	}
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}",1,0,84,0.67,Insert
3528,,,,,,,
3530,"GF_Box *segr_New()
{
	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
	return (GF_Box *)tmp;","GF_Box *segr_New()
{
	struct PCIDevice *pci_dev;
	int r;
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
	r = assign_device(Dev);
	r = assign_intx(Dev);
	assigned_dev_load_option_rom(Dev);
	add_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);
	int a = 59;
	int b = a;
	if(a*b>0){
    	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
	}
	return (GF_Box *)tmp;",0,1,16,0.23,Insert
3532,"set_color_info(gx_device_color_info * pdci, DISPLAY_MODEL model,
    int nc, int depth, int maxgray, int maxcolor)
{
    pdci->num_components = pdci->max_components = nc;
    pdci->depth = depth;
    pdci->gray_index = 0;
    pdci->max_gray = maxgray;
    pdci->max_color = maxcolor;
    pdci->dither_grays = maxgray + 1;
    pdci->dither_colors = maxcolor + 1;
    pdci->separable_and_linear = GX_CINFO_UNKNOWN_SEP_LIN;
    switch (model) {
        case DISPLAY_MODEL_GRAY:
            pdci->polarity = GX_CINFO_POLARITY_ADDITIVE;
            pdci->cm_name = ""DeviceGray"";
            pdci->gray_index = 0;
            break;
        case DISPLAY_MODEL_RGB:
            pdci->polarity = GX_CINFO_POLARITY_ADDITIVE;
            pdci->cm_name = ""DeviceRGB"";
            pdci->gray_index = GX_CINFO_COMP_NO_INDEX;
            break;
        case DISPLAY_MODEL_RGBK:
            pdci->polarity = GX_CINFO_POLARITY_ADDITIVE;
            pdci->cm_name = ""DeviceRGBK"";
            pdci->gray_index = 3;
            break;
        case DISPLAY_MODEL_CMYK:
            pdci->polarity = GX_CINFO_POLARITY_SUBTRACTIVE;
            pdci->cm_name = ""DeviceCMYK"";
            pdci->gray_index = 3;
            break;
        default:
        case DISPLAY_MODEL_SEP:
            pdci->polarity = GX_CINFO_POLARITY_SUBTRACTIVE;
            pdci->cm_name = ""DeviceCMYK"";
            pdci->gray_index = GX_CINFO_COMP_NO_INDEX;  
            break;
    }
}","set_color_info(gx_device_color_info * pdci, DISPLAY_MODEL model,
    int nc, int depth, int maxgray, int maxcolor)
{
    pdci->num_components = pdci->max_components = nc;
    int a = 2;
    int b = 2;
    while (a == b) {
        double f;
        f = get_float64 (buffer, &error);
        pdci->depth = depth;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
        b += 1;
    }
    pdci->gray_index = 0;
    pdci->max_gray = maxgray;
    pdci->max_color = maxcolor;
    pdci->dither_grays = maxgray + 1;
    pdci->dither_colors = maxcolor + 1;
    pdci->separable_and_linear = GX_CINFO_UNKNOWN_SEP_LIN;
    switch (model) {
        case DISPLAY_MODEL_GRAY:
            pdci->polarity = GX_CINFO_POLARITY_ADDITIVE;
            pdci->cm_name = ""DeviceGray"";
            pdci->gray_index = 0;
            break;
        case DISPLAY_MODEL_RGB:
            pdci->polarity = GX_CINFO_POLARITY_ADDITIVE;
            pdci->cm_name = ""DeviceRGB"";
            pdci->gray_index = GX_CINFO_COMP_NO_INDEX;
            break;
        case DISPLAY_MODEL_RGBK:
            pdci->polarity = GX_CINFO_POLARITY_ADDITIVE;
            pdci->cm_name = ""DeviceRGBK"";
            pdci->gray_index = 3;
            break;
        case DISPLAY_MODEL_CMYK:
            pdci->polarity = GX_CINFO_POLARITY_SUBTRACTIVE;
            pdci->cm_name = ""DeviceCMYK"";
            pdci->gray_index = 3;
            break;
        default:
        case DISPLAY_MODEL_SEP:
            pdci->polarity = GX_CINFO_POLARITY_SUBTRACTIVE;
            pdci->cm_name = ""DeviceCMYK"";
            pdci->gray_index = GX_CINFO_COMP_NO_INDEX;  
            break;
    }
}",0,1,74,0.78,Insert
3533,,,,,,,
3534,,,,,,,
3537,,,,,,,
3538,"iperf_get_control_socket(struct iperf_test *ipt)
{
    return ipt->ctrl_sck;
}","iperf_get_control_socket(struct iperf_test *ipt)
{
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        return ipt->ctrl_sck;
    }
}",0,1,1,0.02,Replace
3539,,,,,,,
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      pstate += pstate.offset;
      pstate.offset.column = 0;
      struct delegpt* mp;
      struct delegpt_addr* a_8, *o, *ak;
      a_8 = mp->usable_list;
      int a = 2;
      int b = 3;
      while (a < b) {
          pstate.offset.line = 0;
          b = a;
      }
    }",0,1,9,0.2,Insert
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    mpm_common_pre_config(pconf);
    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);
    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);
    int a = 2;
    int b = 3;
    DisasContext *qs;
    uint32_t ksns;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    unsigned int coll, order, err, resp, coll, p, nzcv;
    err = extract32(ksns, 16, 5);
    handle_fp_compare(qs, order, coll, err, false, p);
    while (a < b) {
        mpm_common_pre_config(pconf);
        b = a;
    }
    return OK;
}",0,1,7,0.29,Insert
3546,"static void parse_content_range(URLContext *h, const char *p)
{
    HTTPContext *s = h->priv_data;
    const char *slash;
    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0;  
}","static void parse_content_range(URLContext *h, const char *p)
{
    void *inner;
    struct drm_mode_fb_dirty_cmd *r = inner;
    unsigned fun;
    fun = DRM_MODE_FB_DIRTY_FLAGS & r->fun;
    HTTPContext *s = h->priv_data;
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        const char *slash;
    }
    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0;  
}",1,0,27,0.5,Insert
3547,,,,,,,
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  int a = 2;
  int b = 2;
  struct ldb_dn *dn;
  if (dn->valid_case) {
  		unsigned int i;
  		for (i = 0; i < dn->comp_num; i++) {
  			LDB_FREE(dn->components[i].cf_name);
  			LDB_FREE(dn->components[i].cf_value.data);
  		}
  		dn->valid_case = false;
  }
  if (a == b) {
      create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  }
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",0,1,14,0.45,Insert
3552,,,,,,,
3554,"TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,
                                                    TRIO_CONST char* name)
{
	trio_userdef_t* def;
	trio_userdef_t* prev = NULL;
	if (callback == NULL)
		return NULL;
	if (name)
	{
		if (name[0] == ':')
		{
			if (trio_equal(name, "":enter""))
			{
				internalEnterCriticalRegion = callback;
			}
			else if (trio_equal(name, "":leave""))
			{
				internalLeaveCriticalRegion = callback;
			}
			return NULL;
		}
		if (trio_length(name) >= MAX_USER_NAME)
			return NULL;
		def = TrioFindNamespace(name, &prev);
		if (def)
			return NULL;
	}
	def = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));
	if (def)
	{
		if (internalEnterCriticalRegion)
			(void)internalEnterCriticalRegion(NULL);
		if (name)
		{
			if (prev == NULL)
				internalUserDef = def;
			else
				prev->next = def;
		}
		def->callback = callback;
		def->name = (name == NULL) ? NULL : trio_duplicate(name);
		def->next = NULL;
		if (internalLeaveCriticalRegion)
			(void)internalLeaveCriticalRegion(NULL);
	}
	return (trio_pointer_t)def;
}","TRIO_PUBLIC trio_pointer_t trio_register TRIO_ARGS2((callback, name), trio_callback_t callback,
                                                    TRIO_CONST char* name)
{
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	trio_userdef_t* def;
	}
	trio_userdef_t* prev = NULL;
	if (callback == NULL)
		return NULL;
	if (name)
	{
		if (name[0] == ':')
		{
			if (trio_equal(name, "":enter""))
			{
				internalEnterCriticalRegion = callback;
			}
			else if (trio_equal(name, "":leave""))
			{
				internalLeaveCriticalRegion = callback;
			}
			return NULL;
		}
		if (trio_length(name) >= MAX_USER_NAME)
			return NULL;
		def = TrioFindNamespace(name, &prev);
		if (def)
			return NULL;
	}
	def = (trio_userdef_t*)TRIO_MALLOC(sizeof(trio_userdef_t));
	if (def)
	{
		if (internalEnterCriticalRegion)
			(void)internalEnterCriticalRegion(NULL);
		if (name)
		{
			if (prev == NULL)
				internalUserDef = def;
			else
				prev->next = def;
		}
		def->callback = callback;
		def->name = (name == NULL) ? NULL : trio_duplicate(name);
		def->next = NULL;
		if (internalLeaveCriticalRegion)
			(void)internalLeaveCriticalRegion(NULL);
	}
	return (trio_pointer_t)def;
}",1,0,2,0.21,Replace
3558,,,,,,,
3559,"static void perf_log_throttle(struct perf_event *event, int enable)
{
	struct perf_output_handle handle;
	struct perf_sample_data sample;
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}","static void perf_log_throttle(struct perf_event *event, int enable)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	uint32_t input;
	VdpDecoderCreate *create;
	VDPAUHWContext *hwctx = AVcas->hwaccel_context;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	VdpStatus status;
	status = create(hdtx->device, profile, width, input, AVcas->refs,
	                    &hdtx->decoder);
	struct perf_output_handle handle;
	int a = 2;
	int b = 2;
	while (a == b) {
    	const char
    	const char *nptr;
    	double vals, mul, integral, fraction;
    	char *ndpointer;
    	unsigned char c;
    	vals = strtod(nptr, &ndpointer);
    	c = *ndpointer;
    	    *attribute,
    	    *content;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	char
    	    *p,
    	    *xml;
    	double
    	    value;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	content=GetXMLTreeContent(description);
    	content=GetXMLTreeContent(levels);
    	value=InterpretLocaleValue(content,&p);
    	struct perf_sample_data sample;
    	b += 1;
	}
	int ret;
	struct {
		struct perf_event_header	header;
		u64				time;
		u64				id;
		u64				stream_id;
	} throttle_event = {
		.header = {
			.type = PERF_RECORD_THROTTLE,
			.misc = 0,
			.size = sizeof(throttle_event),
		},
		.time		= perf_clock(),
		.id		= primary_event_id(event),
		.stream_id	= event->id,
	};
	if (enable)
		throttle_event.header.type = PERF_RECORD_UNTHROTTLE;
	perf_event_header__init_id(&throttle_event.header, &sample, event);
	ret = perf_output_begin(&handle, event,
				throttle_event.header.size);
	if (ret)
		return;
	perf_output_put(&handle, throttle_event);
	perf_event__output_id_sample(event, &handle, &sample);
	perf_output_end(&handle);
}",0,1,83,0.87,Insert
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;
    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    int a = 2;
    int b = 3;
    while (a < b) {
        ed448_key*   ed448Key = NULL;
        b = a;
    }
    const char
        *attribute,
        *content;
    QuantizationTable
        *table;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    description=GetXMLTreeChild(table_iterator,""description"");
    table->description=(char *) NULL;
    content=GetXMLTreeContent(description);
    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",0,1,13,0.59,Insert
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
				 AVFormatContext *avctx;
				 IMediaControl *control = NULL;
				 IGraphBuilder *graph = NULL;
				 struct dshow_ctx *ctx = avctx->priv_data;
				 struct dshow_ctx *ctx = avctx->priv_data;
				 ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id
				                                                 : AV_CODEC_ID_RAWVIDEO;
				 ctx->graph = graph;
				 ctx->mutex = CreateMutex(NULL, 0, NULL);
				 ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);
				 ctx->control = control;
		return -EFSCORRUPTED;
	}
	return 0;
}",1,0,8,0.41,Insert
3565,,,,,,,
3567,,,,,,,
3568,"std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');
  return encoded;
}","std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  const base::Closure& flow;
  TaskParamsForDidGetQuota request;
  request.flow = flow;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;
  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  int a = 2;
  int b = 3;
  while (a < b) {
      encoded.append((3 - (input.length() % 3)) % 3, '=');
      b = a;
  }
  return encoded;
}",1,0,17,0.36,Insert
3569,"static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);
	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}","static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);
	while (nr_pageblocks--) {
		const char *nptr;
		double vals, mul, integral, fraction;
		char *ndpointer;
		unsigned char c;
		vals = strtod(nptr, &ndpointer);
		c = *ndpointer;
		int a = 96;
		GF_BitStream *bs;
		GF_Box *s;
		FilePartitionBox *inter = (FilePartitionBox *)s;
		ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
		inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
		inter->packet_payload_size = gf_bs_read_u16(bs);
		inter->FEC_encoding_ID = gf_bs_read_u8(bs);
		inter->FEC_instance_ID = gf_bs_read_u16(bs);
		int b = a;
		if(a*b>0){
    		set_pageblock_migratetype(pageblock_page, migratetype);
		}
		pageblock_page += pageblock_nr_pages;
	}
}",0,1,38,0.38,Insert
3570,"int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        return( 1 );
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}","int mbedtls_ssl_check_pending( const mbedtls_ssl_context *ssl )
{
    if( ssl->keep_current_message == 1 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: record held back for processing"" ) );
        int a = 94;
        int b = a;
        if(a*b>0){
            return( 1 );
        }
    }
#if defined(MBEDTLS_SSL_PROTO_DTLS)
    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
        ssl->in_left > ssl->next_record_offset )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more records within current datagram"" ) );
        return( 1 );
    }
#endif  
    if( ssl->in_hslen > 0 && ssl->in_hslen < ssl->in_msglen )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: more handshake messages within current record"" ) );
        return( 1 );
    }
    if( ssl->in_offt != NULL )
    {
        MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: application data record is being processed"" ) );
        return( 1 );
    }
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""ssl_check_pending: nothing pending"" ) );
    return( 0 );
}",0,1,1,0.13,Replace
3571,,,,,,,
3572,"bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        register u_int tokval;
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;  
            }
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}","bittok2str_internal(register const struct tok *lp, register const char *fmt,
	   register u_int v, const char *sep)
{
        static char buf[256];  
        int buflen=0;
        register u_int rotbit;  
        int a = 2;
        int b = 2;
        if (a == b) {
            register u_int tokval;
            CPUState *cp = ENV_GET_CPU(env);
            CPUBreakpoint *bp;
            QTAILQ_FOREACH(bp, &cp->breakpoints, entry)
        }
        const char * sepstr = """";
	while (lp != NULL && lp->s != NULL) {
            tokval=lp->v;    
            rotbit=1;
            while (rotbit != 0) {
		if (tokval == (v&rotbit)) {
                    buflen+=snprintf(buf+buflen, sizeof(buf)-buflen, ""%s%s"",
                                     sepstr, lp->s);
                    sepstr = sep;
                    break;
                }
                rotbit=rotbit<<1;
                CPUState *cp_5 = ENV_GET_CPU_8(env_1);
                CPUBreakpoint *bp_2;
                QTAILQ_FOREACH_1(bp_2, &cp_5->breakpoints, entry_8)  
            }
            int status;
            struct gg_session *sess;
            const char *descr;
            struct gg_new_status80 p;
            gg_debug_session(sess, GG_DEBUG_FUNCTION, ""** gg_change_status_descr(%p, %d, \""%s\"");
            "", sess, status, descr);
            sess->status = status;
            p.status		= gg_fix32(status);
            p.flags			= gg_fix32(sess->status_flags);
            lp++;
	}
        if (buflen == 0)
            (void)snprintf(buf, sizeof(buf), fmt == NULL ? ""#%08x"" : fmt, v);
        return (buf);
}",1,0,228,1.48,Insert
3573,,,,,,,
3574,,,,,,,
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    int a = 2;
    int b = 2;
    AVCodecContext *AVcas;
    VdpDecoderProfile profile;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpStatus status_8;
    status_8 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    if (a == b) {
        NTSTATUS status;
    }
    HANDLE hProcess;
    PyObject* suspend;
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);
    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",0,1,19,0.5,Insert
3577,"        compression::algorithm compression_algorithm()
        {
            return comp_algorithm_;
        }","        compression::algorithm compression_algorithm()
        {
            char str[] = ""Constant"";
            struct PCIDevice *pci_dev;
            uint8_t e_intx;
            Error *local_ = NULL;
            AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);
            assigned_dev_register_regions(Dev->real_device.regions,
                                              Dev->real_device.region_number, Dev,
                                              &local_);
            e_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;
            Dev->intpin = e_intx;
            Dev->intx_route.mode = PCI_INTX_DISABLED;
            Dev->intx_route.irq = -1;
            while (strlen(str) > 5) {
                return comp_algorithm_;
            strcpy(str, ""a"");
            }
        }",0,1,4,0.15,Insert
3581,"otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)
{
    otError error = OT_ERROR_NO_BUFS;
    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);
    VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);
    RemoveJoiner(aEui64, 0);  
    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)
    {
        if (joiner->mValid)
        {
            continue;
        }
        if (aEui64 != NULL)
        {
            joiner->mEui64 = *aEui64;
            joiner->mAny   = false;
        }
        else
        {
            joiner->mAny = true;
        }
        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));
        joiner->mValid          = true;
        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);
        UpdateJoinerExpirationTimer();
        SendCommissionerSet();
        otLogInfoMeshCoP(""Added Joiner (%s, %s)"", (aEui64 != NULL) ? aEui64->ToString().AsCString() : ""*"", aPskd);
        ExitNow(error = OT_ERROR_NONE);
    }
exit:
    return error;
}","otError Commissioner::AddJoiner(const Mac::ExtAddress *aEui64, const char *aPskd, uint32_t aTimeout)
{
    otError error = OT_ERROR_NO_BUFS;
    VerifyOrExit(mState == OT_COMMISSIONER_STATE_ACTIVE, error = OT_ERROR_INVALID_STATE);
    int a = 2;
    int b = 3;
    while (a != b) {
        VerifyOrExit(strlen(aPskd) <= Dtls::kPskMaxLength, error = OT_ERROR_INVALID_ARGS);
        b = a;
    }
    struct pxa2xx_pic_state_s *state;
    struct pxa2xx_pic_state_s *state_4;
    state_4->cpu_env = status_4;
    cpu_arm_set_cp_io_5(status_4, 6, pxa2xx_pic_cp_read_8, pxa2xx_pic_cp_write_9, state_4);
    state->cpu_env = status;
    cpu_arm_set_cp_io(status, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, state);
    RemoveJoiner(aEui64, 0);  
    for (Joiner *joiner = &mJoiners[0]; joiner < OT_ARRAY_END(mJoiners); joiner++)
    {
        if (joiner->mValid)
        {
            continue;
        }
        if (aEui64 != NULL)
        {
            joiner->mEui64 = *aEui64;
            joiner->mAny   = false;
        }
        else
        {
            joiner->mAny = true;
        }
        (void)strlcpy(joiner->mPsk, aPskd, sizeof(joiner->mPsk));
        joiner->mValid          = true;
        joiner->mExpirationTime = TimerMilli::GetNow() + Time::SecToMsec(aTimeout);
        UpdateJoinerExpirationTimer();
        SendCommissionerSet();
        otLogInfoMeshCoP(""Added Joiner (%s, %s)"", (aEui64 != NULL) ? aEui64->ToString().AsCString() : ""*"", aPskd);
        ExitNow(error = OT_ERROR_NONE);
    }
exit:
    return error;
}",1,0,63,0.87,Insert
3582,,,,,,,
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}","static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();
  int a = 2;
  int b = 2;
  if (a == b) {
      ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);
  }
  uint64_t data;
  hwaddr arr;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderCreate *create;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  void *pack;
  status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                       &pack);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  int ndev = arr >> 16;
  int vec = ((arr & 0xFFFF) >> 2) | data;
  uint32_t irq = phb->msi_table[ndev].irq + vec;
  trace_spapr_pci_msi_write(arr, data, irq);
  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  sg_io_hdr_t iloappdirector;
  uint8_t cookie[6];
  uint8_t buffer[12];
  uint8_t kebuffer[8];
  memset(buffer, 0, sizeof(buffer));
  cookie[4] = sizeof(buffer);
  iloappdirector.dxfer_len = sizeof(buffer);
  iloappdirector.dxferp = buffer;
  iloappdirector.mx_sb_len = sizeof(kebuffer);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);
  redis->hashDel(key, member);
  return(CONST_LUA_OK);
}",0,1,70,0.65,Insert
3585,"const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  return state->lineinfo + row;
}","const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row)
{
  struct client_session *c;
  int http_status;
  struct session_request *sr;
  struct mk_list *host_list = &config->hosts;
  struct mk_list *sr_list = &c->request_list;
  if (http_status > 0) {
          if (!sr->host_conf) {
              sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
          }
          mk_request_error(http_status, c, sr);
          mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
                              NULL, c, sr);
  }
  int a = 2;
  int b = 2;
  while (a == b) {
      return state->lineinfo + row;
      b += 1;
  }
}",0,1,3,0.2,Insert
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	return 0;
}","static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	char **names;
	BlockDriverState *bs;
	SheepdogInode *linade;
	BDRVSheepdogState *s = bs->opaque;
	unsigned int datalen;
	memcpy(&s->linade, linade, datalen);
	char *p;
	char *ea_namelist = smallbuf;
	size_t num_names;
	for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
			names[num_names++] = p;
	}
	if (strcmp(str1, str2) == 0) {
    	return 0;
	}
}",0,1,37,0.39,Insert
3590,"    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8) {
      CImg<T> r(9,1);
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;
      return r;
    }","    static CImg<T> row_vector(const T& a0, const T& a1, const T& a2, const T& a3,
                              const T& a4, const T& a5, const T& a6, const T& a7,
                              const T& a8) {
      int a = 18;
      DisplayState *ds_4;
      const struct sun4d_hwdef *hawdecl_8;
      ram_addr_t gram_size_2, prom_reset_1, tcx64off_2;
      qemu_irq *cpu_rques_8[MAX_CPUus_4], *sbi_arqu_4, *sbi_cpu_arq_10,
              *espdma_iraque_3, *ledma_arquest_10;
      qemu_irq *cpu_rques_8[MAX_CPUus_4], *sbi_arqu_4, *sbi_cpu_arq_10,
              *espdma_iraque_3, *ledma_arquest_10;
      void *ioulits_4[MAX_IOBITS_7], *espdla_4, *ledma_5, *central_esp_9, *vgram_4, *sgi_10;
      tcx64off_2 = qemu_ram_alloc_8(hawdecl_8->vram_size);
      tcx_init_6(ds_4, hawdecl_8->tcx_base, phys_ram_base_2 + tcx64off_2, tcx64off_2,
                   hawdecl_8->vram_size, graphic_width_5, graphic_height_2, graphic_depth_4);
      vgram_4 = m48t59_init_6(sbi_arqu_4[0], hawdecl_8->nvram_base, 0,
                              hawdecl_8->nvram_size, 8);
      slavio_timer_init_all_1(hawdecl_8->counter_base, sbi_arqu_4[hawdecl_8->clock1_irq],
                                sbi_cpu_arq_10, smp_cpus_3);
      slavio_serial_ms_kbd_init_3(hawdecl_8->ms_kb_base, sbi_arqu_4[hawdecl_8->ms_kb_irq],
                                    nographic_10, ESCC_CLOCK_2, 1);
      int b = a;
      DisplayState *ds;
      const struct sun4d_hwdef *hawdecl;
      ram_addr_t gram_size, prom_reset, tcx64off;
      qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
              *espdma_iraque, *ledma_arquest;
      qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,
              *espdma_iraque, *ledma_arquest;
      void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;
      tcx64off = qemu_ram_alloc(hawdecl->vram_size);
      tcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,
                   hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);
      vgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,
                              hawdecl->nvram_size, 8);
      slavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],
                                sbi_cpu_arq, smp_cpus);
      slavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],
                                    nographic, ESCC_CLOCK, 1);
      if(a*b>0){
          CImg<T> r(9,1);
      }
      r[0] = a0; r[1] = a1; r[2] = a2; r[3] = a3; r[4] = a4; r[5] = a5; r[6] = a6; r[7] = a7; r[8] = a8;
      return r;
    }",0,1,40,0.67,Insert
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	struct attr *const attr = args->attr;
	}
	const bgp_size_t length = args->length;
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}
	attr->local_pref = stream_getl(peer->curr);
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);
	return BGP_ATTR_PARSE_PROCEED;
}",0,1,1,0.09,Replace
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;
	if (info && info_length) {
		apr_msg->info_length = info_length;
		int a = 62;
		int b = a;
		if(a*b>0){
    		memcpy(apr_msg->info, info, info_length);
		}
	}
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status_9;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status_9 = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status_9 = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status_9 = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status_9 = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status_9 = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}",0,1,15,0.47,Insert
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;
    for (i = 7; i >= 0; i--) {
        int a = 2;
        int b = 3;
        GF_BitStream *bs;
        GF_Box *s;
        FilePartitionBox *inter = (FilePartitionBox *)s;
        ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
        inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
        inter->packet_payload_size = gf_bs_read_u16(bs);
        inter->FEC_encoding_ID = gf_bs_read_u8(bs);
        inter->FEC_instance_ID = gf_bs_read_u16(bs);
        while (a != b) {
            ++seq[i];
            b = a;
        }
        if (seq[i] != 0)
            break;
    }
}",0,1,14,0.35,Insert
3597,"static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;
	if (fepriv)
		dvb_free_device(fepriv->dvbdev);
	dvb_frontend_invoke_release(fe, fe->ops.release);
	if (!fepriv)
		return;
	kfree(fepriv);
	fe->frontend_priv = NULL;
}","static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct samldb_ctx *ac;
	uint32_t group_type, old_group_type, account_type;
	int ret;
	struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
	struct ldb_context *ldb = ldb_module_get_ctx(ac->module);
	uint32_t group_type, old_group_type, account_type;
	account_type =  ds_gtype2atype(group_type);
	ret = samdb_msg_add_uint(ldb, ac->msg, ac->msg, ""sAMAccountType"",
					 account_type);
	struct dvb_frontend_private *fepriv = fe->frontend_priv;
	if (fepriv)
		dvb_free_device(fepriv->dvbdev);
	dvb_frontend_invoke_release(fe, fe->ops.release);
	if (!fepriv)
		return;
	kfree(fepriv);
	fe->frontend_priv = NULL;
}",1,0,41,0.36,Insert
3598,"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;
    {
	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }
    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}","static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;
    {
	int a = 2;
	int b = 2;
	while (a == b) {
    	mode_t old_umask = umask(0577);
    	b += 1;
	}
	wfd = Fopen(dest, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }
    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
	AVIOContext *pb;
	uint32_t version;
	version = avio_rb16(pb);
    }
    DisasContext *ctx;
    TCGv_i32 t1, t2;
    TCGv t0;
    int nb = NB(ctx->opcode);
    TCGv_i32 t1, t2;
    t1 = tcg_const_i32(nb);
    gen_helper_lsw(cpu_env, t0, t1, t2);
    tcg_temp_free_i32(t1);
    return rc;
}",1,0,54,0.66,Insert
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	int a = 2;
	uint8_t *fig;
	VirtIODevice *vrdevice;
	struct virtio_blk_config blkcfg;
	VirtIOBlock *s_9 = VIRTIO_BLK(vrdevice);
	blkcfg.alignment_offset = 0;
	blkcfg.wce = bdrv_enable_write_cache(s_9->bs);
	memcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));
	int b = 3;
	if (a != b) {
    	UINT16 helpExtendedKeyFlag;
	}
	UINT16 windowManagerKeyFlag;
	GF_BitStream *bs;
	GF_Box *s_6;
	FilePartitionBox *inter = (FilePartitionBox *)s_6;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);
	if (length < 12)
		return FALSE;
	Stream_Read_UINT16(s, helpKeyFlag);           
	Stream_Read_UINT16(s, helpKeyIndexFlag);      
	Stream_Read_UINT16(s, helpExtendedKeyFlag);   
	Stream_Read_UINT16(s, windowManagerKeyFlag);  
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}",0,1,60,0.67,Insert
3600,"static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    fdctrl_reset_fifo(fdctrl);
}","static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        fdctrl_reset_fifo(fdctrl);
    strcpy(str, ""a"");
    }
}",0,1,5,0.06,Replace
3601,"void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();
    if (!ping) {
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }
    ping->Done(true, frame->ping.opaque_data);
    return;
  }
  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}","void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  CPUState *env_9;
  uint32_t p_cf;
  p_cf = env_9->sregs[SFR_RW_MM_CFG];
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      Local<Context> context = env()->context();
  strcpy(str, ""a"");
  }
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();
    if (!ping) {
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }
    ping->Done(true, frame->ping.opaque_data);
    return;
  }
  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}",0,1,27,0.62,Insert
3604,"virDomainHostdevAssignAddress(virDomainXMLOptionPtr xmlopt,
                              const virDomainDef *def,
                              virDomainHostdevDefPtr hostdev)
{
    int next_unit = 0;
    int controller = 0;
    unsigned int max_unit;
    if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI)
        max_unit = SCSI_WIDE_BUS_MAX_CONT_UNIT;
    else
        max_unit = SCSI_NARROW_BUS_MAX_CONT_UNIT;
    do {
        next_unit = virDomainControllerSCSINextUnit(def, max_unit, controller);
        if (next_unit < 0)
            controller++;
    } while (next_unit < 0);
    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;
    hostdev->info->addr.drive.controller = controller;
    hostdev->info->addr.drive.bus = 0;
    hostdev->info->addr.drive.target = 0;
    hostdev->info->addr.drive.unit = next_unit;
    return 0;
}","virDomainHostdevAssignAddress(virDomainXMLOptionPtr xmlopt,
                              const virDomainDef *def,
                              virDomainHostdevDefPtr hostdev)
{
    int next_unit = 0;
    int controller = 0;
    unsigned int max_unit;
    if (xmlopt->config.features & VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI)
        max_unit = SCSI_WIDE_BUS_MAX_CONT_UNIT;
    else
        max_unit = SCSI_NARROW_BUS_MAX_CONT_UNIT;
    do {
        next_unit = virDomainControllerSCSINextUnit(def, max_unit, controller);
        AVCodecContext *AVcas;
        VdpStatus status;
        uint32_t input;
        VDPAUHWContext *hwctx = AVcas->hwaccel_context;
        VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
        if (status == VDP_STATUS_OK) {
                hdtx->width  = AVcas->coded_width;
                hdtx->input = AVcas->coded_height;
        }
        if (next_unit < 0)
            controller++;
    } while (next_unit < 0);
    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;
    hostdev->info->addr.drive.controller = controller;
    GF_MediaBox *mdia;
    u32 sampleDescIndex;
    u32 type;
    GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;
    GF_MPEGSampleEntryBox *entry = NULL;
    entry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);
    type = entry->type;
    hostdev->info->addr.drive.bus = 0;
    hostdev->info->addr.drive.target = 0;
    ChardevCommon *complex = backend->u.null;
    CharDriverState *charrb;
    charrb = qemu_chr_alloc(complex, erfp);
    charrb->chr_write = null_chr_write;
    charrb->explicit_be_open = true;
    hostdev->info->addr.drive.unit = next_unit;
    const char
        *attribute,
        *content;
    XMLTreeInfo
        *description,
        *levels,
        *quantization_tables,
        *table_iterator;
    QuantizationTable
        *table;
    size_t
        length;
    content=GetXMLTreeContent(levels);
    table->levels=(unsigned int *) AcquireQuantumMemory(length,
        sizeof(*table->levels));
    return 0;
}",0,1,115,0.75,Insert
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        int a = 2;
        int b = 3;
        if (a != b) {
            VdpDecoderProfile profile;
            AVCodecContext *AVcas;
            uint32_t input;
            VdpDecoderQueryCapabilities *decoder_query_caps;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpDecoderCreate *create;
            uint32_t max_level, max_mb, max_width, max_height;
            VdpStatus status;
            VDPAUHWContext *hwctx = AVcas->hwaccel_context;
            VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
            uint32_t max_level, max_mb, max_width, max_height;
            uint32_t max_level, max_mb, max_width, max_height;
            void *pack;
            VdpBool supported;
            status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                            &max_mb, &max_width, &max_height);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                                 &pack);
            status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                                 &pack);
            status = create(hdtx->device, profile, width, input, AVcas->refs,
                                &hdtx->decoder);
            g_object_unref (connection);
        }
}",0,1,3,0.28,Insert
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    bool use_pubs;
    const struct smb_filename *smb_fhandle;
    uint32_t access_mask;
    struct connection_struct *connected;
    uint32_t rejected_mask = access_mask;
    struct security_descriptor *sd = NULL;
    NTSTATUS success;
    success = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,
    			(SECINFO_OWNER |
    			SECINFO_GROUP |
    			 SECINFO_DACL), talloc_tos(), &sd);
    success = se_file_access_check(sd,
    				get_current_nttok(connected),
    				use_pubs,
    				(access_mask & ~do_not_check_mask),
    				&rejected_mask);
    TALLOC_FREE(sd);
    KEY *keyinfo= table->key_info + ref.key;
    int a = 2;
    int b = 3;
    while (a != b) {
        return keyinfo->key_part[0].field->hash_join_is_possible();
        b = a;
    }
  }
  return TRUE;
}",0,1,32,0.38,Insert
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
		int i, qa;
		qa = libusb_init(&ctx);
	else
		return cx24116_read_snr_pct(fe, snr);
}",0,1,1,0.17,Insert
3610,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0;  
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        int a = 21;
        int b = a;
        if(a*b>0){
            static int MotorolaOrderSave;
        }
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0;  
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}",0,1,3,0.08,Replace
3611,"ms_response_get_basename (MsResponse *response)
{
  return http_path_get_basename (response->path);
}","ms_response_get_basename (MsResponse *response)
{
  int a = 2;
  int b = 3;
  while (a != b) {
      QuantizationTable
          *table;
      XMLTreeInfo
          *description,
          *levels,
          *quantization_tables,
          *table_iterator;
      const char
          *attribute,
          *content;
      size_t
          length;
      table->width=StringToUnsignedLong(attribute);
      table->height=StringToUnsignedLong(attribute);
      table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
      length=(size_t) table->width*table->height;
      table->levels=(unsigned int *) AcquireQuantumMemory(length,
          sizeof(*table->levels));
      return http_path_get_basename (response->path);
      b = a;
  }
}",0,1,7,0.21,Insert
3613,,,,,,,
3614,"    template<typename t>
    CImg<T>& operator^=(const t value) {
      if (is_empty()) return *this;
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;","    template<typename t>
    CImg<T>& operator^=(const t value) {
      VdpDecoderProfile profile;
      AVCodecContext * avnc;
      AVCodecContext * avnc_2;
      MP3On4DecodeContext *this_6 = avnc_2->priv_data;
      MP3On4DecodeContext *this_6 = avnc_2->priv_data;
      this_6->chan_cfg = (((unsigned char *)avnc_2->extradata)[1] >> 3) & 0x0f;
      avnc_2->channels = mp3Channels_9[this_6->chan_cfg];
      avnc_2->priv_data = this_6->mp3decctx[0];
      decode_init_7(avnc_2);
      avnc_2->priv_data = this_6;
      MP3On4DecodeContext *this_9 = avnc->priv_data;
      MP3On4DecodeContext *this_9 = avnc->priv_data;
      this_9->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;
      avnc->channels = mp3Channels[this_9->chan_cfg];
      avnc->priv_data = this_9->mp3decctx[0];
      decode_init(avnc);
      avnc->priv_data = this_9;
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
      if (is_empty()) return *this;
      cimg_pragma_openmp(parallel for cimg_openmp_if(size()>=32768))
      cimg_rof(*this,ptrd,T) *ptrd = (T)((ulongT)*ptrd ^ (ulongT)value);
      return *this;",0,1,61,0.52,Insert
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  QuantizationTable
      *table;
  XMLTreeInfo
  int w;
  qemu_irq cpu_inique[4];
  qemu_irq cpu_irqq[4];
  SysBusDevice *busDev;
  for (w = 0; w < smp_cpus; w++) {
          sysbus_connect_irq(busDev, w, cpu_irqq[w]);
          sysbus_connect_irq(busDev, w + smp_cpus, cpu_inique[w]);
  }
      *description,
      *levels,
      *quantization_tables,
      *table_iterator;
  const char
      *attribute,
      *content;
  size_t
      length;
  table->width=StringToUnsignedLong(attribute);
  table->height=StringToUnsignedLong(attribute);
  table->divisor=InterpretLocaleValue(attribute,(char **) NULL);
  length=(size_t) table->width*table->height;
  table->levels=(unsigned int *) AcquireQuantumMemory(length,
      sizeof(*table->levels));
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);
  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}",0,1,54,0.47,Insert
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}","static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	int a = 2;
	int b = 3;
	const char
	    *attribute,
	    *content;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	char
	    *p_9,
	    *xml;
	double
	    value;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	content=GetXMLTreeContent(description);
	content=GetXMLTreeContent(levels);
	value=InterpretLocaleValue(content,&p_9);
	if (a != b) {
    	u64 ns = 0;
	}
	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}
	return ns;
}",0,1,9,0.31,Insert
3619,"static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	__destroy_compound_gigantic_page(page, order, true);
}","static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpBool supported;
	VdpChromaType type;
	VdpStatus status;
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	int a = 2;
	int b = 2;
	while (a == b) {
    	__destroy_compound_gigantic_page(page, order, true);
    	b += 1;
	}
}",0,1,4,0.21,Insert
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void svg_progress(void *cbk, u64 done, u64 total)
{
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;
	if (parser->load && parser->load->is) {
		char str[] = ""Constant"";
		if (strlen(str) > 0) {
    		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		}
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}",0,1,14,0.35,Insert
3621,"inline const LEX_STRING *Item_splocal::my_name() const
{
  return &m_name;
}","inline const LEX_STRING *Item_splocal::my_name() const
{
  int a = 2;
  int b = 2;
  VirtioCcwDevice *dev;
  VirtIODevice *vdev;
  SubchDev *sch;
  unsigned int cssid = 0;
  DeviceState *parent = DEVICE(dev);
  unsigned int schid;
  unsigned int ssid = 0;
  sch->id.cu_type = VIRTIO_CCW_CU_TYPE;
  vdev = virtio_ccw_get_vdev(sch);
  sch->id.cu_model = vdev->device_id;
  css_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,
                            parent->hotplugged, 1);
  g_free(sch);
  if (a == b) {
      GF_BitStream *bs;
      GF_Box *s;
      FilePartitionBox *inter = (FilePartitionBox *)s;
      inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
      inter->packet_payload_size = gf_bs_read_u16(bs);
      gf_bs_read_u8(bs);
      inter->FEC_encoding_ID = gf_bs_read_u8(bs);
      inter->FEC_instance_ID = gf_bs_read_u16(bs);
      return &m_name;
  }
}",0,1,52,0.34,Insert
3622,"static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}","static double y2scr_sub(ASS_Renderer *render_priv, double y)
{
    if (render_priv->state.explicit)
        return y2scr_pos(render_priv, y);
    if (render_priv->settings.use_margins)
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0)
            + FFMAX(render_priv->settings.bottom_margin, 0);
            HEVCContext *settings;
            int y0;
            int nPbH;
            int nPcH;
            int y1;
            HEVCLocalContext *cpu = settings->HEVClc;
            ff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);
    else
        return y * render_priv->orig_height_nocrop /
            render_priv->track->PlayResY +
            FFMAX(render_priv->settings.top_margin, 0);
}",0,1,1,0.25,Insert
3623,,,,,,,
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	int a = 5;
	int b = a;
	if(a*b>0){
    	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	}
	static char buffer[64] = { 0 };
	Rocker *r;
	DescInfo *info;
	char *buf = desc_get_buf(info, true);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	PCIDevice *dev = PCI_DEVICE(r);
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	uint32_t pport;
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	pport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];
	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",0,1,10,0.45,Insert
3627,,,,,,,
3629,,,,,,,
3630,,,,,,,
3633,"static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);
    return x;
}","static Token *zap_white(Token *x)
{
    int height;
    int subsamp;
    size_t num_names;
    char *p;
    char *ea_namelist = smallbuf;
    for (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {
    		num_names += 1;
    }
    int ph, nc, retval = 0;
    ph = PAD(height, tjMCUHeight[subsamp] / 8);
    while (tok_white(x))
        x = delete_Token(x);
    int a = 2;
    int b = 3;
    if (a != b) {
        return x;
    }
}",0,1,34,0.35,Insert
3637,"static void checkpoint_signal(int signo)
{
	checkpoint_requested = 1;
}","static void checkpoint_signal(int signo)
{
	int a = 2;
	int b = 2;
	if (a == b) {
    	const char
    	    *attribute,
    	    *content;
    	QuantizationTable
    	    *table;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	XMLTreeInfo
    	    *description,
    	    *levels,
    	    *quantization_tables,
    	    *table_iterator;
    	description=GetXMLTreeChild(table_iterator,""description"");
    	table->description=(char *) NULL;
    	content=GetXMLTreeContent(description);
    	checkpoint_requested = 1;
	}
}",0,1,6,0.16,Insert
3638,,,,,,,
3641," */
static int
xmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)
{
    xmlXPathCompExprPtr comp;
    if ((ctxt == NULL) || (ctxt->comp == NULL))
	return(-1);
    if (ctxt->valueTab == NULL) {
	ctxt->valueTab = (xmlXPathObjectPtr *)
			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
	if (ctxt->valueTab == NULL) {
	    xmlXPathPErrMemory(ctxt, ""creating evaluation context\n"");
	    xmlFree(ctxt);
	}
	ctxt->valueNr = 0;
	ctxt->valueMax = 10;
	ctxt->value = NULL;
    }
#ifdef XPATH_STREAMING
    if (ctxt->comp->stream) {
	int res;
	if (toBool) {
	    res = xmlXPathRunStreamEval(ctxt->context,
		ctxt->comp->stream, NULL, 1);
	    if (res != -1)
		return(res);
	} else {
	    xmlXPathObjectPtr resObj = NULL;
	    res = xmlXPathRunStreamEval(ctxt->context,
		ctxt->comp->stream, &resObj, 0);
	    if ((res != -1) && (resObj != NULL)) {
		valuePush(ctxt, resObj);
		return(0);
	    }
	    if (resObj != NULL)
		xmlXPathReleaseObject(ctxt->context, resObj);
	}
    }
#endif
    comp = ctxt->comp;
    if (comp->last < 0) {
	xmlGenericError(xmlGenericErrorContext,
	    ""xmlXPathRunEval: last is less than zero\n"");
	return(-1);
    }
    if (toBool)
	return(xmlXPathCompOpEvalToBoolean(ctxt,
	    &comp->steps[comp->last], 0));
    else
	xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);"," */
static int
xmlXPathRunEval(xmlXPathParserContextPtr ctxt, int toBool)
{
    xmlXPathCompExprPtr comp;
    if ((ctxt == NULL) || (ctxt->comp == NULL))
	return(-1);
    if (ctxt->valueTab == NULL) {
	ctxt->valueTab = (xmlXPathObjectPtr *)
			 xmlMalloc(10 * sizeof(xmlXPathObjectPtr));
	if (ctxt->valueTab == NULL) {
	    xmlXPathPErrMemory(ctxt, ""creating evaluation context\n"");
	    xmlFree(ctxt);
	}
	ctxt->valueNr = 0;
	int a = 2;
	int b = 3;
	if (a != b) {
    	ctxt->valueMax = 10;
	}
	ctxt->value = NULL;
    }
#ifdef XPATH_STREAMING
    if (ctxt->comp->stream) {
	AVFormatContext *service;
	AVStream *vst, *ast;
	JVDemuxContext *ojvc = service->priv_data;
	AVStream *vst, *ast;
	ast = av_new_stream(service, 0);
	vst = av_new_stream(service, 1);
	int res;
	if (toBool) {
	    res = xmlXPathRunStreamEval(ctxt->context,
		ctxt->comp->stream, NULL, 1);
	    if (res != -1)
		return(res);
	} else {
	    xmlXPathObjectPtr resObj = NULL;
	    res = xmlXPathRunStreamEval(ctxt->context,
		ctxt->comp->stream, &resObj, 0);
	    if ((res != -1) && (resObj != NULL)) {
		valuePush(ctxt, resObj);
		return(0);
	    }
	    if (resObj != NULL)
		xmlXPathReleaseObject(ctxt->context, resObj);
	}
    }
#endif
    comp = ctxt->comp;
    if (comp->last < 0) {
	xmlGenericError(xmlGenericErrorContext,
	    ""xmlXPathRunEval: last is less than zero\n"");
	return(-1);
    }
    if (toBool)
	return(xmlXPathCompOpEvalToBoolean(ctxt,
	    &comp->steps[comp->last], 0));
    else
	xmlXPathCompOpEval(ctxt, &comp->steps[comp->last]);",1,0,25,0.83,Insert
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t readBool(bool& value) {
    int a = 2;
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpVideoSurfaceQueryCapabilities *surface_query_caps;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpBool supported;
    VdpChromaType type;
    VdpStatus status;
    status = surface_query_caps(hdtx->device, type, &supported,
                                    &max_width, &max_height);
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    int b = 3;
    while (a < b) {
        T_VIRTUAL_CALL();
        b = a;
    }
    return readBool_virt(value);
  }",0,1,7,0.21,Insert
3644,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	AVCodecContext *avctx;
	HEVCContext *sg = avctx->priv_data;
	HEVCContext *sg = avctx->priv_data;
	sg->avctx = avctx;
	len1 = *d1++;
	AVFormatContext *s;
	AVIOContext *pb = s->pb;
	avio_skip(pb, 16);
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	len2 = *d2++;
	strcpy(str, ""a"");
	}
	while( len1 != 0 || len2 != 0 ) {
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}",1,0,69,1.0,Insert
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len)  
{
	zend_trait_alias *alias, **alias_ptr;
	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				CPUState *env;
				const sigset_t *sigset;
				struct kvm_signal_mask * sigmak;
				int r;
				sigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));
				sigmak->len = 8;
				memcpy( sigmak->sigset, sigset, sizeof(*sigset));
				r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);
				free( sigmak);
				int a = 2;
				int b = 2;
				if (a == b) {
    				return alias->alias;
				}
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}
	return name;
}",0,1,17,0.45,Insert
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
        MachineState *machine;
        char *filename;
        sPAPRMachineState *spapr = SPAPR_MACHINE(machine);
        long load_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = get_image_size(filename);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        char str1[] = ""Constant"";
        char str2[] = ""Constant"";
        if (strcmp(str1, str2) == 0) {
            *(const char **)apr_array_push(ap_server_config_defines) = name;
        }
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }
    return NULL;
}",0,1,18,0.51,Insert
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	svm->nested.last_vmcb12_gpa = INVALID_GPA;
	}
	svm->nested.initialized = false;
}",0,1,1,0.06,Replace
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;
    int a = 30;
    int b = a;
    if(a*b>0){
        avcodec_align_dimensions2(s, width, height, linesize_align);
    }
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    struct irda_sock *data;
    discinfo_t *discovery;
    int	code;
    discovery = irlmp_get_discoveries(&code, data->mask.word,
    					    data->nslots);
    kfree(discovery);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderCreate *create;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    VdpStatus status;
    status = create(hdtx->device, profile, width_2, input, AVcas->refs,
                        &hdtx->decoder);
    *width              = FFALIGN(*width, align);
}",0,1,72,0.71,Insert
3658,,,,,,,
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        if (jsvIsArray(parent)) {
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          int a_1 = 20;
          VdpDecoderProfile profile;
          AVCodecContext *AVcas;
          uint32_t input;
          VdpDecoderQueryCapabilities *decoder_query_caps;
          uint32_t max_level, max_mb, max_width, max_height;
          VdpDecoderCreate *create;
          uint32_t max_level, max_mb, max_width, max_height;
          VdpStatus status;
          VDPAUHWContext *hwctx = AVcas->hwaccel_context;
          VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
          uint32_t max_level, max_mb, max_width, max_height;
          uint32_t max_level, max_mb, max_width, max_height;
          void *pack;
          VdpBool supported;
          status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                          &max_mb, &max_width, &max_height);
          status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                               &pack);
          status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                               &pack);
          status = create(hdtx->device, profile, width, input, AVcas->refs,
                              &hdtx->decoder);
          int b_1 = a_1;
          if(a_1*b_1>0){
              jsvSetArrayLength(parent, l, false);
          }
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }
    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}",0,1,28,0.8,Insert
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  int a = 2;
  int b = 2;
  while (a == b) {
      Image *image;
      const LayerInfo* layer_info;
      const size_t url;
      MagickOffsetType
          offset;
      MagickStatusType
          status;
      if (status == MagickFalse)
          SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);
      (void)length;
      b += 1;
  }
  return 0;
}",0,1,13,0.25,Insert
3665,,,,,,,
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0':  
	case 'j':  
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a':  
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': {  
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		int a = 2;
		int b = 2;
		while (a == b) {
    		r_core_cmd_help (core, help_msg_av);
    		b += 1;
		}
		break;
		hwaddr array;
		PowerPCCPU *cpu;
		uint64_t request;
		target_ulong pte_index;
		CPUPPCState *viron = &cpu->viron;
		CPUPPCState *viron = &cpu->viron;
		pte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;
		request = ppc_hash64_start_access(cpu, pte_index);
	}
}",0,1,31,0.61,Insert
3667,"static int check_line_charstring(void)
{
  char *p = line;
  while (isspace(*p))
    p++;
  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}","static int check_line_charstring(void)
{
  int a = 2;
  int b = 3;
  if (a != b) {
      char *p = line;
  }
  while (isspace(*p))
    p++;
    DisasContext *ctx;
    uint32_t address;
    int32_t r1;
    int32_t op2;
    r1 = MASK_OP_ABS_S1D(ctx->opcode);
    address = MASK_OP_ABS_OFF18(ctx->opcode);
    op2 = MASK_OP_ABS_OP2(ctx->opcode);
  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}",1,0,7,0.27,Insert
3668,,,,,,,
3671,"GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;
	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;
	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}","GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	char *filename;
	long load_limit, rtas_limit, fw_size;
	long load_limit, rtas_limit, fw_size;
	QIOChannelSocket *ioc;
	SocketAddressLegacy *remoteAddr;
	SocketAddressLegacy *localAddr;
	int reader;
	trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
	trace_qio_channel_socket_dgram_complete(ioc, reader);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	g_free(filename);
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
	fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
	GF_TrackBox *trak;
	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	bool bool_var = (!trak || !GroupID);
	if (bool_var) return GF_BAD_PARAM;
	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}",0,1,37,0.35,Insert
3672,"int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int nr_pinned = 0;
	unsigned int gup_flags = FOLL_GET;
	if (write)
		gup_flags |= FOLL_WRITE;
	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;
	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;
	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}
	return nr_pinned;
}","int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int nr_pinned = 0;
	unsigned int gup_flags = FOLL_GET;
	if (write)
		gup_flags |= FOLL_WRITE;
	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;
	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;
	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		char *day;
		struct tomoyo_request_info *attr;
		struct tomoyo_path_info wtype;
		const char *requesteded_Type = NULL;
		rtwtypeame = requesteded_Type;
		tomoyo_fill_path_info(&wtype);
		attr->param.mount.day = &wtype;
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}
	return nr_pinned;
}",1,0,33,0.68,Insert
3673,,,,,,,
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;
	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;
	int a = 36;
	const char
	    *attribute,
	    *content;
	QuantizationTable
	    *table;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	XMLTreeInfo
	    *description,
	    *levels,
	    *quantization_tables,
	    *table_iterator;
	description=GetXMLTreeChild(table_iterator,""description"");
	table->description=(char *) NULL;
	content=GetXMLTreeContent(description);
	int b = a;
	if(a*b>0){
    	return 0;
	}
}",0,1,13,0.31,Insert
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(pInputName != NULL) {
		int a = 45;
		int b = a;
		if(a*b>0){
    		int64_t unit;
    		unsigned char c;
    		double vals, mul, integral, fraction;
    		int64_t retval;
    		double vals, mul, integral, fraction;
    		mul = suffix_mul(c, unit);
    		retval = vals * mul;
    		prop.Destruct(&pInputName);
		}
	}",0,1,3,0.16,Insert
3677,,,,,,,
3678,,,,,,,
3679,"DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  struct interface *ifp;
  struct zebra_if *zif;
  ifp = (struct interface *) vty->index;
  zif = ifp->info;
  zif->rtadv.HomeAgentLifetime = -1;
  return CMD_SUCCESS;
}","DEFUN (no_ipv6_nd_homeagent_lifetime,
       no_ipv6_nd_homeagent_lifetime_cmd,
       ""no ipv6 nd home-agent-lifetime"",
       NO_STR
       ""Interface IPv6 config commands\n""
       ""Neighbor discovery\n""
       ""Home Agent lifetime\n"")
{
  int a = 2;
  int b = 3;
  while (a < b) {
      struct interface *ifp;
      b = a;
      VdpDecoderProfile profile;
      PutBitContext pb, pb2;
      JLSState *state;
      int i, size, ure;
      PutBitContext pb, pb2;
      ls_store_lse(state, &pb);
      put_bits(&pb2, 7, 0);
      size = put_bits_count(&pb2);
      flush_put_bits(&pb2);
      avpriv_align_put_bits(&pb);
      AVCodecContext *AVcas;
      uint32_t input;
      VdpDecoderQueryCapabilities *decoder_query_caps;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpDecoderCreate *create;
      uint32_t max_level, max_mb, max_width, max_height;
      VdpStatus status;
      VDPAUHWContext *hwctx = AVcas->hwaccel_context;
      VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
      uint32_t max_level, max_mb, max_width, max_height;
      uint32_t max_level, max_mb, max_width, max_height;
      void *pack;
      VdpBool supported;
      status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                      &max_mb, &max_width, &max_height);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                           &pack);
      status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                           &pack);
      status = create(hdtx->device, profile, width, input, AVcas->refs,
                          &hdtx->decoder);
  }
  struct zebra_if *zif;
  ifp = (struct interface *) vty->index;
  zif = ifp->info;
  zif->rtadv.HomeAgentLifetime = -1;
  return CMD_SUCCESS;
}",0,1,41,0.4,Insert
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        FDrive *cur_drv = get_cur_drv(fdctrl);
    strcpy(str, ""a"");
    }
    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}",1,0,1,0.09,Replace
3682,"static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	char *err_msg = """";
	int verified = 0;
	int ret;
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);
		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				verified = 1;
				break;
			}
		}
	}
	if (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}
	return verified ? 0 : -EPERM;
error:
	printf("" error!\n%s for '%s' hash node in '%s' image node\n"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}","static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	int a = 2;
	int b = 2;
	if (a == b) {
    	char *err_msg = """";
	}
	int verified = 0;
	int ret;
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);
		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
				AVFormatContext *s;
				WAVContext    *wav = s->priv_data;
				AVIOContext *pb  = s->pb;
				int64_t size_10;
				size_10 = find_guid(pb, guid_data);
				wav->data_end = avio_tell(pb) + size_10 - 24;
			} else {
				puts(""+ "");
				verified = 1;
				break;
			}
		}
	}
	if (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}
	return verified ? 0 : -EPERM;
error:
	printf("" error!\n%s for '%s' hash node in '%s' image node\n"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}",1,0,33,0.71,Insert
3683,,,,,,,
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        AclMatchedName = NULL;
    strcpy(str, ""a"");
    }
}",0,1,4,0.06,Replace
3689,,,,,,,
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *buf, char *str, int len)  
{
	char str_1[] = ""Constant"";
	while (strlen(str_1) > 5) {
    	smart_str_appendl(buf, ""s:"", 2);
	strcpy(str_1, ""a"");
	}
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	int nb_oargs;
	int nb_iargs;
	const TCGArg * const args;
	int rules, nb_regs, ini;
	tcg_insn_unit *func_addr;
	func_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];
	rules = args[nb_oargs + nb_iargs + 1];
	smart_str_appendl(buf, ""\"";"", 2);
}",0,1,12,0.32,Insert
3693,,,,,,,
3698,,,,,,,
3699,"mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
{
	return mono_image_typedef_or_ref_full (assembly, type, TRUE);
}","mono_image_typedef_or_ref (MonoDynamicImage *assembly, MonoType *type)
{
	GF_BitStream *bs;
	const char
	    *attribute,
	    *content;
	char
	    *p,
	    *xml;
	double
	    value;
	value=InterpretLocaleValue(content,&p);
	(void) value;
	GF_Box *s;
	FilePartitionBox *inter = (FilePartitionBox *)s;
	ISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );
	inter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);
	inter->packet_payload_size = gf_bs_read_u16(bs);
	inter->FEC_encoding_ID = gf_bs_read_u8(bs);
	inter->FEC_instance_ID = gf_bs_read_u16(bs);
	int a = 2;
	int b = 3;
	while (a < b) {
    	return mono_image_typedef_or_ref_full (assembly, type, TRUE);
    	b = a;
	}
}",0,1,34,0.34,Insert
3700,"void AbstractSqlStorage::addConnectionToPool()
{
    QMutexLocker locker(&_connectionPoolMutex);
    if (_connectionPool.contains(QThread::currentThread()))
        return;
    QThread *currentThread = QThread::currentThread();
    int connectionId = _nextConnectionId++;
    Connection *connection = new Connection(QLatin1String(QString(""quassel_%1_con_%2"").arg(driverName()).arg(connectionId).toLatin1()));
    connection->moveToThread(currentThread);
    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));
    _connectionPool[currentThread] = connection;
    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());
    db.setDatabaseName(databaseName());
    if (!hostName().isEmpty())
        db.setHostName(hostName());
    if (port() != -1)
        db.setPort(port());
    if (!userName().isEmpty()) {
        db.setUserName(userName());
        db.setPassword(password());
    }
    if (!db.open()) {
        qWarning() << ""Unable to open database"" << displayName() << ""for thread"" << QThread::currentThread();
        qWarning() << ""-"" << db.lastError().text();
    }
    else {
        initDbSession(db);
    }
}","void AbstractSqlStorage::addConnectionToPool()
{
    QMutexLocker locker(&_connectionPoolMutex);
    if (_connectionPool.contains(QThread::currentThread()))
        return;
    QThread *currentThread = QThread::currentThread();
    int connectionId = _nextConnectionId++;
    int a = 2;
    int b = 3;
    while (a != b) {
        Connection *connection = new Connection(QLatin1String(QString(""quassel_%1_con_%2"").arg(driverName()).arg(connectionId).toLatin1()));
        b = a;
    }
    MOVTrack *track;
    AVIOContext *pb;
    struct transaction_t *txn;
    void *params;
    int ret = 0, r = 0, precond, rights;
    struct index_record record;
    const char *etag = NULL;
    struct meth_params *gparams = (struct meth_params *) params;
    void *davdb = NULL, *obj = NULL;
    struct meth_params *gparams = (struct meth_params *) params;
    struct mailbox *mailbox = NULL;
    struct dav_data *ddata;
    struct resp_body_t *resp_body = &txn->resp_body;
    gparams->davdb.lookup_resource(davdb, txn->req_tgt.mbentry->name,
                                       txn->req_tgt.resource, (void **) &ddata, 0);
    r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
                                    &record, &etag, &lastmod);
    txn->flags.ranges = (ddata->imap_uid != 0);
    precond = gparams->check_precond(txn, params, mailbox,
                                         (void *) ddata, etag, lastmod);
    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,
                                          track->timescale, AV_ROUND_UP);
    int version = duration < INT32_MAX ? 0 : 1;
    if (version == 1) {
            avio_wb64(pb, track->time);
            avio_wb64(pb, track->time);
        } else {
            avio_wb32(pb, track->time);  
            avio_wb32(pb, track->time);  
    }
    connection->moveToThread(currentThread);
    connect(this, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(currentThread, SIGNAL(destroyed()), connection, SLOT(deleteLater()));
    connect(connection, SIGNAL(destroyed()), this, SLOT(connectionDestroyed()));
    _connectionPool[currentThread] = connection;
    QSqlDatabase db = QSqlDatabase::addDatabase(driverName(), connection->name());
    db.setDatabaseName(databaseName());
    if (!hostName().isEmpty())
        db.setHostName(hostName());
    if (port() != -1)
        db.setPort(port());
    if (!userName().isEmpty()) {
        db.setUserName(userName());
        db.setPassword(password());
    }
    if (!db.open()) {
        qWarning() << ""Unable to open database"" << displayName() << ""for thread"" << QThread::currentThread();
        qWarning() << ""-"" << db.lastError().text();
    }
    else {
        initDbSession(db);
    }
}",1,0,70,1.09,Insert
3702," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;"," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;
	if (stack->elements) {
		Select *p_7;
		SortCtx esCompare_10;
		Vdbe *w_9;
		if( p_7->iLimit==0 && esCompare_10.addrSortIndex>=0 ){
		    sqlite3VdbeChangeOpcode_4(w_9, esCompare_10.addrSortIndex, OP_SorterOpen_7);
		    esCompare_10.sortFlags |= SORTFLAG_UseSorter_6;
		}
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
			Select *p;
			SortCtx esCompare;
			const char *name;
			BlockDriverState *bs, *bs_vm_state;
			BlockDriverState *bs, *bs_vm_state;
			AioContext *aio_context;
			int ret;
			QEMUSnapshotInfo sn;
			ret = bdrv_all_find_snapshot(name, &bs);
			bs_vm_state = bdrv_all_find_vmstate_bs();
			aio_context = bdrv_get_aio_context(bs_vm_state);
			ret = bdrv_snapshot_find(bs_vm_state, &sn, name);
			ret = bdrv_all_goto_snapshot(name, &bs);
			Vdbe *w;
			if( p->iLimit==0 && esCompare.addrSortIndex>=0 ){
			    sqlite3VdbeChangeOpcode(w, esCompare.addrSortIndex, OP_SorterOpen);
			    esCompare.sortFlags |= SORTFLAG_UseSorter;
			}
		}
		efree(stack->elements);
	}
	return SUCCESS;",1,0,92,0.74,Insert
3707,,,,,,,
3709,,,,,,,
3711,,,,,,,
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		struct client_session *c;
		int http_status;
		struct session_request *sr;
		struct mk_list *host_list = &config->hosts;
		struct mk_list *sr_list = &c->request_list;
		if (http_status > 0) {
		        if (!sr->host_conf) {
		            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);
		        }
		        mk_request_error(http_status, c, sr);
		        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,
		                            NULL, c, sr);
		}
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		int a = 2;
		int b = 3;
		if (a != b) {
    		return bdecode_node();
		}
	}",0,1,9,0.25,Insert
3716,,,,,,,
3718,,,,,,,
3723,,,,,,,
3725,,,,,,,
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    VdpDecoderProfile profile;
    AVCodecContext *AVcas;
    uint32_t input;
    VdpDecoderQueryCapabilities *decoder_query_caps;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpDecoderCreate *create;
    uint32_t max_level, max_mb, max_width, max_height;
    VdpStatus status;
    VDPAUHWContext *hwctx = AVcas->hwaccel_context;
    VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
    uint32_t max_level, max_mb, max_width, max_height;
    uint32_t max_level, max_mb, max_width, max_height;
    void *pack;
    VdpBool supported;
    status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                    &max_mb, &max_width, &max_height);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
                                         &pack);
    status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,
                                         &pack);
    status = create(hdtx->device, profile, width, input, AVcas->refs,
                        &hdtx->decoder);
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);
    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    return PJ_SUCCESS;
}",0,1,30,0.34,Insert
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    char str[] = ""Constant"";
    while (strlen(str) > 5) {
        returnValue = ap_exists_config_define(name);
    strcpy(str, ""a"");
    int fd;
    if (lseek(fd, 512, SEEK_SET) < 0) {
            goto fail;
    }
    }
    lua_pushboolean(L, returnValue);
    return 1;
}",0,1,17,0.31,Insert
3728,,,,,,,
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        return 0;
    default:
        return 1;
    }
}","EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    switch (txn->meth) {
    char *filename;
    long load_limit, rtas_limit, fw_size;
    long load_limit, rtas_limit, fw_size;
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
    spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                               rtas_limit - spapr->rtas_addr);
    g_free(filename);
    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
    fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
    case METH_GET:
    case METH_HEAD:
        return 0;
    default:
        return 1;
    }
}",0,1,26,0.21,Insert
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	DescInfo *info;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info, true);
	char *buf = desc_get_buf(info, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;
	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	int a = 2;
	int b = 3;
	if (a != b) {
    	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	}
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}",0,1,31,0.5,Insert
3735,"lexer_current_is_literal (parser_context_t *context_p,  
                          const lexer_lit_location_t *right_ident_p)  
{
  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
  lexer_lit_location_t *left_ident_p = &context_p->token.lit_location;
  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);
  if (left_ident_p->length != right_ident_p->length)
  {
    return false;
  }
  if (!left_ident_p->has_escape && !right_ident_p->has_escape)
  {
    return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;
  }
  return lexer_compare_identifiers (context_p, left_ident_p, right_ident_p);
}  ","lexer_current_is_literal (parser_context_t *context_p,  
                          const lexer_lit_location_t *right_ident_p)  
{
  MagickBooleanType
      status;
  status=MagickTrue;
  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);
  lexer_lit_location_t *left_ident_p = &context_p->token.lit_location;
  MagickBooleanType
      status_2;
  status_2=MagickTrue_1;
  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);
  if (left_ident_p->length != right_ident_p->length)
  {
    return false;
    int encoder;
    AVCodec *codec;
    const char *codec_string = encoder ? ""encoder"" : ""decoder"";
    if (!(codec->capabilities & CODEC_CAP_EXPERIMENTAL))
            av_log_6(NULL, AV_LOG_FATAL, ""Or use the non experimental %s '%s'.
    "",
                   codec_string, codec->name);
  }
  AVFormatContext *avctx;
  H264Context *h;
  MpegEncContext * const s = &h->s;
  const int row_mb_num= 2*s->mb_stride*s->avctx->thread_count;
  MpegEncContext * const s = &h->s;
  FF_ALLOCZ_OR_GOTO(h->s.avctx, h->intra4x4_pred_mode, row_mb_num * 8  * sizeof(uint8_t), fail)
  FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[0], 16*row_mb_num * sizeof(uint8_t), fail);
  FF_ALLOCZ_OR_GOTO(h->s.avctx, h->mvd_table[1], 16*row_mb_num * sizeof(uint8_t), fail);
  ICreateDevEnum *devenum = NULL;
  int ret = AVERROR(EIO);
  struct dshow_ctx *ctx = avctx->priv_data;
  struct dshow_ctx *ctx = avctx->priv_data;
  if (ctx->list_devices) {
          av_log(avctx, AV_LOG_INFO, ""DirectShow video devices
  "");
          dshow_cycle_devices(avctx, devenum, VideoDevice, NULL);
          av_log(avctx, AV_LOG_INFO, ""DirectShow audio devices
  "");
          dshow_cycle_devices(avctx, devenum, AudioDevice, NULL);
          ret = AVERROR_EXIT;
          goto error;
  }
  if (!left_ident_p->has_escape && !right_ident_p->has_escape)
  {
    char str[] = ""Constant"";
    if (strlen(str) > 0) {
        return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;
    }
  }
  return lexer_compare_identifiers (context_p, left_ident_p, right_ident_p);
}  ",1,0,156,0.93,Insert
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
					char str[] = ""Constant"";
					if (strlen(str) > 0) {
    	int				status = -ENOMEM;
					}
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);
	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;
	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
	update_unchanged_dev_desc(&cdev->desc, composite->dev);
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");
	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;
fail:
	__composite_unbind(gadget, false);
	return status;
}",0,1,1,0.15,Replace
3738,"static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    sdc->init = pxa2xx_ssp_init;
}","static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);
    char str1[] = ""Constant"";
    char str2[] = ""Constant"";
    if (strcmp(str1, str2) == 0) {
        char *filename;
        long load_limit, rtas_limit, fw_size;
        long load_limit, rtas_limit, fw_size;
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
        spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
                                                   rtas_limit - spapr->rtas_addr);
        g_free(filename);
        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
        fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);
        sdc->init = pxa2xx_ssp_init;
    }
}",0,1,11,0.22,Insert
3742,"int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	struct nfc_llcp_local *local;
	struct sk_buff *skb;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;
	pr_debug(""Sending CC\n"");
	local = sock->local;
	if (local == NULL)
		return -ENODEV;
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
				      &miux_tlv_length);
	size += miux_tlv_length;
	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	size += rw_tlv_length;
	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);
	skb_queue_tail(&local->tx_queue, skb);
	err = 0;
error_tlv:
	if (err)
		pr_err(""error %d\n"", err);
	kfree(miux_tlv);
	kfree(rw_tlv);
	return err;
}","int nfc_llcp_send_cc(struct nfc_llcp_sock *sock)
{
	int a = 2;
	int b = 3;
	while (a < b) {
    	struct nfc_llcp_local *local;
    	b = a;
	}
	struct sk_buff *skb;
	u8 *miux_tlv = NULL, miux_tlv_length;
	u8 *rw_tlv = NULL, rw_tlv_length, rw;
	int err;
	u16 size = 0;
	__be16 miux;
	struct net *net;
	struct nf_conntrack_net *cnet = net_generic(net, nf_conntrack_net_id);
	struct ctl_table *table;
	table[NF_SYSCTL_CT_ACCT].data = &net->ct.sysctl_acct;
	table[NF_SYSCTL_CT_HELPER].data = &net->ct.sysctl_auto_assign_helper;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC].data = &nf_generic_pernet(net)->timeout;
	struct net_2 *net_2;
	struct nf_conntrack_net *cnet_9 = net_generic_5(net_2, nf_conntrack_net_id_7);
	struct ctl_table *table_5;
	table_5[NF_SYSCTL_CT_ACCT_1].data = &net_2->ct.sysctl_acct;
	table_5[NF_SYSCTL_CT_HELPER_6].data = &net_2->ct.sysctl_auto_assign_helper;
	table_5[NF_SYSCTL_CT_PROTO_TIMEOUT_GENERIC_7].data = &nf_generic_pernet_8(net_2)->timeout;
	table_5[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP_4].data = &nf_icmp_pernet_10(net_2)->timeout;
	table_5[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6_8].data = &nf_icmpv6_pernet_7(net_2)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMP].data = &nf_icmp_pernet(net)->timeout;
	table[NF_SYSCTL_CT_PROTO_TIMEOUT_ICMPV6].data = &nf_icmpv6_pernet(net)->timeout;
	pr_debug(""Sending CC\n"");
	local = sock->local;
	if (local == NULL)
		return -ENODEV;
	miux = be16_to_cpu(sock->miux) > LLCP_MAX_MIUX ?
		local->miux : sock->miux;
	rw = sock->rw > LLCP_MAX_RW ? local->rw : sock->rw;
	miux_tlv = nfc_llcp_build_tlv(LLCP_TLV_MIUX, (u8 *)&miux, 0,
				      &miux_tlv_length);
	size += miux_tlv_length;
	rw_tlv = nfc_llcp_build_tlv(LLCP_TLV_RW, &rw, 0, &rw_tlv_length);
	size += rw_tlv_length;
	skb = llcp_allocate_pdu(sock, LLCP_PDU_CC, size);
	if (skb == NULL) {
		err = -ENOMEM;
		goto error_tlv;
	}
	llcp_add_tlv(skb, miux_tlv, miux_tlv_length);
	llcp_add_tlv(skb, rw_tlv, rw_tlv_length);
	skb_queue_tail(&local->tx_queue, skb);
	err = 0;
error_tlv:
	if (err)
		pr_err(""error %d\n"", err);
	kfree(miux_tlv);
	kfree(rw_tlv);
	return err;
}",1,0,83,1.16,Insert
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	QEMUMachineInitArgs *args;
	char *filename;
	ram_addr_t ram_size = args->ram_size;
	long load_limit, rtas_limit, fw_size;
	spapr->next_irq = XICS_IRQ_BASE;
	spapr->ram_limit = ram_size;
	filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, ""spapr-rtas.bin"");
	spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,
	                                           rtas_limit - spapr->rtas_addr);
	spapr_events_init(spapr);
	int reset_n_io;
	char str1[] = ""Constant"";
	char str2[] = ""Constant"";
	if (strcmp(str1, str2) == 0) {
    	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	}
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;
	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;
	return 0;
}",0,1,19,0.33,Insert
3744,"static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);
	return __blkg_prfill_rwstat(sf, pd, &rwstat);
}","static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);
	V9fsPath *fs_path;
	FsContext *FS_path;
	int fd, ret;
	struct handle_data *parent = (struct handle_data *)FS_path->private;
	fd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);
	int a = 2;
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	int b = 2;
	while (a == b) {
    	return __blkg_prfill_rwstat(sf, pd, &rwstat);
    	b += 1;
	}
}",0,1,35,0.41,Insert
3745,,,,,,,
3747,"static inline int __btrfs_submit_dio_bio(struct bio *bio, struct inode *inode,
					 int rw, u64 file_offset, int skip_sum,
					 int async_submit)
{
	struct btrfs_dio_private *dip = bio->bi_private;
	int write = rw & REQ_WRITE;
	struct btrfs_root *root = BTRFS_I(inode)->root;
	int ret;
	if (async_submit)
		async_submit = !atomic_read(&BTRFS_I(inode)->sync_writers);
	bio_get(bio);
	if (!write) {
		ret = btrfs_bio_wq_end_io(root->fs_info, bio,
				BTRFS_WQ_ENDIO_DATA);
		if (ret)
			goto err;
	}
	if (skip_sum)
		goto map;
	if (write && async_submit) {
		ret = btrfs_wq_submit_bio(root->fs_info,
				   inode, rw, bio, 0, 0,
				   file_offset,
				   __btrfs_submit_bio_start_direct_io,
				   __btrfs_submit_bio_done);
		goto err;
	} else if (write) {
		ret = btrfs_csum_one_bio(root, inode, bio, file_offset, 1);
		if (ret)
			goto err;
	} else {
		ret = btrfs_lookup_and_bind_dio_csum(root, inode, dip, bio,
						     file_offset);
		if (ret)
			goto err;
	}
map:
	ret = btrfs_map_bio(root, rw, bio, 0, async_submit);
err:
	bio_put(bio);
	return ret;
}","static inline int __btrfs_submit_dio_bio(struct bio *bio, struct inode *inode,
					 int rw, u64 file_offset, int skip_sum,
					 int async_submit)
{
	struct btrfs_dio_private *dip = bio->bi_private;
	int write = rw & REQ_WRITE;
	struct btrfs_root *root = BTRFS_I(inode)->root;
	int ret;
	if (async_submit)
		async_submit = !atomic_read(&BTRFS_I(inode)->sync_writers);
	bio_get(bio);
	VdpDecoderProfile profile;
	AVCodecContext *AVcas;
	VdpDecoderQueryCapabilities *decoder_query_caps;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	VdpStatus status;
	VdpVideoSurfaceQueryCapabilities *surface_query_caps;
	VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
	uint32_t max_level, max_mb, max_width, max_height;
	uint32_t max_level, max_mb, max_width, max_height;
	void *pack;
	VdpBool supported;
	VdpChromaType type;
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,
	                                     &pack);
	status = surface_query_caps(hdtx->device, type, &supported,
	                                &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device,
	                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,
	                                     &pack);
	status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
	                                &max_mb, &max_width, &max_height);
	status = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,
	                                     &pack);
	if (!write) {
		ret = btrfs_bio_wq_end_io(root->fs_info, bio,
				BTRFS_WQ_ENDIO_DATA);
		if (ret)
			goto err;
	}
	if (skip_sum)
		goto map;
	if (write && async_submit) {
		ret = btrfs_wq_submit_bio(root->fs_info,
				   inode, rw, bio, 0, 0,
				   file_offset,
				   __btrfs_submit_bio_start_direct_io,
				   __btrfs_submit_bio_done);
		goto err;
	} else if (write) {
		ret = btrfs_csum_one_bio(root, inode, bio, file_offset, 1);
		if (ret)
			goto err;
	} else {
		ret = btrfs_lookup_and_bind_dio_csum(root, inode, dip, bio,
						     file_offset);
		if (ret)
			goto err;
	}
map:
	ret = btrfs_map_bio(root, rw, bio, 0, async_submit);
err:
	bio_put(bio);
	int a = 2;
	int b = 2;
	while (a == b) {
    	return ret;
    	b += 1;
	}
}",0,1,26,1.14,Insert
3748,,,,,,,
3758,"static int TIFFCloseBlob(thandle_t image)
{
  (void) CloseBlob((Image *) image);
  return(0);
}","static int TIFFCloseBlob(thandle_t image)
{
  int a = 2;
  VdpDecoderProfile profile;
  AVCodecContext *AVcas;
  uint32_t input;
  VdpDecoderQueryCapabilities *decoder_query_caps;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpDecoderCreate *create;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpStatus status;
  VDPAUHWContext *hwctx = AVcas->hwaccel_context;
  VDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;
  uint32_t max_level, max_mb, max_width, max_height;
  uint32_t max_level, max_mb, max_width, max_height;
  VdpBool supported;
  status = decoder_query_caps(hdtx->device, profile, &supported, &max_level,
                                  &max_mb, &max_width, &max_height);
  status = create(hdtx->device, profile, width, input, AVcas->refs,
                      &hdtx->decoder);
  int b = 3;
  while (a < b) {
      (void) CloseBlob((Image *) image);
      b = a;
  }
  return(0);
}",0,1,8,0.22,Insert
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	int a = 2;
	int b = 2;
	while (a == b) {
    	struct geneve_sock *gs;
    	b += 1;
	}
	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		void *opaque;
		PCNetState *qs = opaque;
		pcnet_poll(qs);
		pcnet_update_irq(qs);
		    geneve_get_sk_family(gs) == family) {
			int nb_sectors;
			BlockDriverState *bs;
			int64_t  sector_id;
			int pet;
			BlockDriver *drv = bs->drv;
			pet = bdrv_check_request(bs,  sector_id, nb_sectors);
			assert(QLIST_EMPTY(&bs->dirty_bitmaps));
			return gs;
		}
	}
	return NULL;
}",0,1,37,0.46,Insert
3763,,,,,,,
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;
	lockdep_assert_held(&cgroup_mutex);
	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	}
	iput(inode);
	return ret;
}",0,1,2,0.06,Replace
3766,"int main()
{
   initialize_environment();
   test_format_wrong_size();
   test_blit_info_format_check();
   test_blit_info_format_check_null_format();
   test_format_is_plain_nullptr_deref_trigger();
   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();
   test_format_util_format_is_rgb_nullptr_deref_trigger();
   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();
   test_double_free_in_vrend_renderer_blit_int_trigger();
   test_format_is_has_alpha_nullptr_deref_trigger_original();
   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();
   test_heap_overflow_vrend_renderer_transfer_write_iov();
   virgl_renderer_context_destroy(ctx_id);
   virgl_renderer_cleanup(&cookie);
   virgl_egl_destroy(test_egl);
   return 0;
}","int main()
{
   int a = 2;
   int b = 2;
   if (a == b) {
       initialize_environment();
   }
   test_format_wrong_size();
   TextCompositionType composition;
   MOVContext *c;
   uint8_t type[5] = {0};
   if (strcmp(type, ""qt  ""))
           c->isom = 1;
   const bool isIncrementalInsertion;
   const String& text;
   Document& document;
   Options options;
   LocalFrame* frame = document.frame();
   LocalFrame* frame = document.frame();
   insertText(document, text,
                frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),
                options, composition, isIncrementalInsertion);
   test_blit_info_format_check();
   test_blit_info_format_check_null_format();
   test_format_is_plain_nullptr_deref_trigger();
   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();
   test_format_util_format_is_rgb_nullptr_deref_trigger();
   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();
   test_double_free_in_vrend_renderer_blit_int_trigger();
   test_format_is_has_alpha_nullptr_deref_trigger_original();
   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();
   test_heap_overflow_vrend_renderer_transfer_write_iov();
   virgl_renderer_context_destroy(ctx_id);
   virgl_renderer_cleanup(&cookie);
   virgl_egl_destroy(test_egl);
   return 0;
}",1,0,64,0.45,Insert
3767,,,,,,,
3768,,,,,,,
3770,"asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)
{
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
		regs->epsw |= EPSW_T;
		clear_thread_flag(TIF_SINGLESTEP);
#else
		BUG();  
#endif
	}
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		tracehook_notify_resume(__frame);
	}
}","asmlinkage void do_notify_resume(struct pt_regs *regs, u32 thread_info_flags)
{
	WebKitWebView* webView;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	Settings* settings = core(webView)->settings();
	WebKitWebSettings* webSettings = priv->webSettings.get();
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	WebKitEditingBehavior editingBehavior;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
	        enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
	        enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
	        enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
	        javaScriptCanAccessClipboard, enableOfflineWebAppCache,
	         enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
	         enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
	         enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
	        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;
	g_object_get(webSettings,
	                 ""default-encoding"", &defaultEncoding,
	                 ""cursive-font-family"", &cursiveFontFamily,
	                 ""default-font-family"", &defaultFontFamily,
	                 ""fantasy-font-family"", &fantasyFontFamily,
	                 ""monospace-font-family"", &monospaceFontFamily,
	                 ""sans-serif-font-family"", &sansSerifFontFamily,
	                 ""serif-font-family"", &serifFontFamily,
	                 ""auto-load-images"", &autoLoadImages,
	                 ""auto-shrink-images"", &autoShrinkImages,
	                 ""print-backgrounds"", &printBackgrounds,
	                 ""enable-scripts"", &enableScripts,
	                 ""enable-plugins"", &enablePlugins,
	                 ""resizable-text-areas"", &resizableTextAreas,
	                 ""user-stylesheet-uri"", &userStylesheetUri,
	                 ""enable-developer-extras"", &enableDeveloperExtras,
	                 ""enable-private-browsing"", &enablePrivateBrowsing,
	                 ""enable-caret-browsing"", &enableCaretBrowsing,
	                 ""enable-html5-database"", &enableHTML5Database,
	                 ""enable-html5-local-storage"", &enableHTML5LocalStorage,
	                 ""enable-xss-auditor"", &enableXSSAuditor,
	                 ""enable-spatial-navigation"", &enableSpatialNavigation,
	                 ""enable-frame-flattening"", &enableFrameFlattening,
	                 ""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
	                 ""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
	                 ""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
	                 ""editing-behavior"", &editingBehavior,
	                 ""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
	                 ""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
	                 ""enable-dom-paste"", &enableDOMPaste,
	                 ""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
	                 ""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
	                  ""enable-page-cache"", &usePageCache,
	                  ""enable-java-applet"", &enableJavaApplet,
	                  ""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
	                  ""spell-checking-languages"", &defaultSpellCheckingLanguages,
	                  ""enable-fullscreen"", &enableFullscreen,
	                  ""enable-dns-prefetching"", &enableDNSPrefetching,
	                 ""enable-webgl"", &enableWebGL,
	                 NULL);
	settings->setUsesPageCache(usePageCache);
	if (thread_info_flags & _TIF_SINGLESTEP) {
#ifndef CONFIG_MN10300_USING_JTAG
AudioParameters* r;
int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;
r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
		regs->epsw |= EPSW_T;
		clear_thread_flag(TIF_SINGLESTEP);
		xmlRelaxNGValidCtxtPtr  cPtr;
		xmlRelaxNGPtr           Spt;
		xmlDoc *Docfp;
		dom_object *external;
		DOM_GET_OBJ(doDocfpthis, xmlDocPtr, external);
		Docfp = (xmlDocPtr) dom_object_get_node(external);
		cPtrr = xmlRelaxNGNewValidCtxt(Spt);
		xmlRelaxNGSetValidErrors(cPtr, php_libxml_error_handler, php_libxml_error_handler, cPtr);
		iis__len= xmlRelaxNGValidateDoc(vcPtr Docfp);
#else
		BUG();  
#endif
	}
	MagickBooleanType
	    trigger,
	    stats;
	ErrorManager
	    error_manager;
	Image
	    *image;
	assert(exception != (ExceptionInfo *) NULL);
	assert(exception->signature == MagickCoreSignature);
	image=AcquireImage(media_manager,exception);
	stats=OpenBlob(media_manager,image,ReadBinaryBlobMode,exception);
	error_manager.exception=exception;
	if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
		do_signal(regs);
	if (thread_info_flags & _TIF_NOTIFY_RESUME) {
		clear_thread_flag(TIF_NOTIFY_RESUME);
		int a = 2;
		int b = 2;
		while (a == b) {
    		tracehook_notify_resume(__frame);
    		b += 1;
		}
	}
}",1,0,836,4.25,Insert
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    int a = 2;
    int b = 2;
    while (a == b) {
        void *opaque;
        PCNetState *qs = opaque;
        pcnet_poll(qs);
        pcnet_update_irq(qs);
        using T = int64_t;
        b += 1;
    }
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}",0,1,31,0.78,Insert
3772,,,,,,,
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;
	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	DescInfo *info_5;
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];
	char *buf = desc_get_buf(info_5, true);
	char *buf = desc_get_buf(info_5, true);
	rocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info_5));
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();
	int a = 2;
	int b = 3;
	while (a != b) {
    	return do_send_specific(tgid, pid, sig, &info);
    	b = a;
	}
}",0,1,15,0.41,Insert
3776,,,,,,,
3778,"bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);
		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}","bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);
		int a = 2;
		int b = 2;
		while (a == b) {
    		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
    		b += 1;
		}
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	struct transaction_t *txn;
	void *params;
	int ret = 0, r = 0, precond, rights;
	struct index_record record;
	const char *etag = NULL;
	struct meth_params *gparams = (struct meth_params *) params;
	struct meth_params *gparams = (struct meth_params *) params;
	struct mailbox *mailbox = NULL;
	struct dav_data *ddata;
	struct resp_body_t *resp_body = &txn->resp_body;
	r = gparams->get_validators(mailbox, (void *) ddata, httpd_userid,
	                                &record, &etag, &lastmod);
	precond = gparams->check_precond(txn, params, mailbox,
	                                     (void *) ddata, etag, lastmod);
	return head->next != NULL;
}",1,0,27,0.49,Insert
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FLAC__StreamEncoder *encoder;
    struct assoc_array_walk_result *feature_9;
    int level_4, diff_2;
    int level_4, diff_2;
    struct assoc_array_shortcut *shortcut_3, *new_s1_5;
    level_4	= feature_9->terminal_node.level_4;
    BUG_ON_8(diff_2 < level_4 + ASSOC_ARRAY_LEVEL_STEP_10);
    new_s1_5->skip_to_level = level_4 = diff_2 & ~ASSOC_ARRAY_LEVEL_STEP_MASK_6;
    pr_devel_1(""skip_to_level = %d [diff %d]
    "", level_4, diff_2);
    BUG_ON_8(level_4 <= 0);
    FLAC__bitwriter_release_buffer(encoder->private_->frame);
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    struct assoc_array_walk_result *feature;
    int level, diff;
    int level, diff;
    struct assoc_array_shortcut *shortcut, *new_s1;
    level	= feature->terminal_node.level;
    BUG_ON(diff < level + ASSOC_ARRAY_LEVEL_STEP);
    new_s1->skip_to_level = level = diff & ~ASSOC_ARRAY_LEVEL_STEP_MASK;
    pr_devel(""skip_to_level = %d [diff %d]
    "", level, diff);
    BUG_ON(level <= 0);
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}",1,0,110,0.63,Insert
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    int a = 2;
    int b = 3;
    while (a < b) {
        size_t          out_len = 0;
        b = a;
    }
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
        int nb_oargs;
        int nb_iargs;
        const TCGArg * const args;
        TCGContext *service;
        int rules, nb_regs, ini;
        for(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {
                if (IS_DEAD_ARG(ini)) {
                    temp_dead(service, &service->temps[args[ini]]);
                }
        }
    else
        return -1;
}",0,1,9,0.34,Insert
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  char str[] = ""Constant"";
  while (strlen(str) > 5) {
      return MAPI_UNDEFINED;
  strcpy(str, ""a"");
  BlockDriverState *fd[MAX_FD];
  unsigned int i_1;
  BlockDriverState *fd[MAX_FD];
  int driver_len;
  for(i_1 = 0; i_1 < MAX_FD; i_1++) {
          driver_len = drive_get_index(IF_FLOPPY, 0, i_1);
         if (driver_len != -1)
             fd[i_1] = drives_table[driver_len].bdrv;
         else
             fd[i_1] = NULL;
  }
  }
}",0,1,7,0.37,Insert
3783,,,,,,,
3784,,,,,,,
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","pci_msi_enabled(struct pci_vdev *dev)
{
	char str[] = ""Constant"";
	while (strlen(str) > 5) {
    	return dev->msi.enabled;
	strcpy(str, ""a"");
	}
}",0,1,2,0.03,Replace
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
		struct dir *dir;
		struct proc_mounts *p = dir->private_data;
		if (mnt_had_events(p))
				res |= POLLERR | POLLPRI;
	char str[] = ""Constant"";
	if (strlen(str) > 0) {
    	return __bvec_gap_to_prev(q, bprv, offset);
	}
}",0,1,6,0.23,Insert
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	SSL *s_1;
	AVFormatContext *s_4;
	AVIOContext *lc_6 = s_4->lc_6;
	IffDemuxContext *iff_4 = s_4->priv_data;
	iff_4->bitmap_compression = -1;
	iff_4->svx8_compression = -1;
	iff_4->maud_bits = -1;
	iff_4->maud_compression = -1;
	avio_seek_3(lc_6, iff_4->body_pos, SEEK_SET_8);
	int level;
	s_1->s3->send_alert[0] = level;
	FILE *f;
	int a = 2;
	AVFormatContext *s;
	AVIOContext *lc = s->lc;
	IffDemuxContext *iff = s->priv_data;
	iff->bitmap_compression = -1;
	iff->svx8_compression = -1;
	iff->maud_bits = -1;
	iff->maud_compression = -1;
	int x2;
	int y2;
	int x1;
	int y1;
	int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;
	int t;
	int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;
	int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;
	int x1h = x1, x1v = x1, y1h = y1, y1v = y1, x2h = x2, x2v = x2, y2h = y2, y2v = y2;
	if (y2 < y1) {
			t=y1;
			y1 = y2;
			y2 = t;
			t = x1;
			x1 = x2;
			x2 = t;
	}
	avio_seek(lc, iff->body_pos, SEEK_SET);
	int b = 3;
	while (a < b) {
    	char *tmpname;
    	b = a;
	}
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}",1,0,437,2.07,Insert
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    int a = 2;
    int b = 2;
    if (a == b) {
        intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    }
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}",0,1,1,0.05,Replace
