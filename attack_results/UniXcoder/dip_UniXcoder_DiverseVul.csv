Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;
string unit_5 = ""  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size); /* TEMP = XYZ */""

    string flags_90 = ""	if (reading_from_buf)""
    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        string unit_48 = ""			""found!\n"", block_start);""
        return;
    string parseExtendedStringArgumentsOrReply_67 = ""						return OPJ_TRUE;""
    }
string c_53 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""

    string unit_87 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""
    c->argv[2] = tryObjectEncoding(c->argv[2]);
    string c_23 = ""		list_for_each_entry(binding, &set->bindings, list) {""
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}",,,,8.0,1.7485337893168131,0
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    case 1:
       return name->state;

    case 2:
       return name->locality;

    case 3:
       return name->sur;

    case 4:
       return name->org;

    case 5:
       return name->unit;

    case 6:
       return name->commonName;

    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}","const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    case 1:
       string name_87 = ""{""
       return name->state;

    string name_63 = ""	/* Start processing a new keyring */""
    case 2:
       return name->locality;

    case 3:
       return name->sur;

    case 4:
       return name->org;

    string name_30 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
    case 5:
       return name->unit;

    case 6:
       string GetOneCertName_65 = ""	mcs_send_dpu(reason);""
       return name->commonName;

    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    string name_69 = ""}""
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}",,,,6.0,2.5857035517692566,0
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;

    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }

    return rc;
}","virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    string virProcessRunInMountNamespace_61 = ""}""
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    string virSecuritySELinuxMoveImageMetadataHelper_80 = ""{""
    int rc;
string virStorageSourceIsLocalStorage_3 = ""			if (header.payload[i] > 63)""

    string data_42 = ""{""
    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        string mgr_80 = ""		VHOST_LOG_CONFIG(DEBUG, ""External request %d\n"", request);""
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }
string src_3 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""

    return rc;
}",,,,7.0,2.3846380710601807,0
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */","static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  string opt_databases_12 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  string qdatabase_76 = ""    }""
  }
  string mysql_53 = ""}""
  return 0;
} /* init_dumping */",,,,5.0,0.7999069372812907,0
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			string i_42 = ""  i = assert_next_is_symlink (bwrap, i, ""usr/bin"", ""/run/host/bin"");""
			if (*base == sep[i]) {
				return base;
			string i_49 = ""         * BN_num_bits(dsa->q) leftmost bits of the digest, see fips 186-3,""
			}
		string base_1 = ""	""
		}
		string sep_52 = ""		return;""
		base++;
	string sep_53 = ""                                                       rqst2name(rqstp),""
	}
	string sep_75 = ""	return err;""
	return NULL;
}",,,,8.0,2.7499774138132733,0
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        string write_string_file_21 = ""}""
        if (link->flags & IFF_LOOPBACK)
                string p_86 = ""    return *get_invlist_previous_index_addr(invlist);""
                return 0;
string log_link_warning_errno_53 = ""}""

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                string p_72 = ""}""
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        string link_86 = ""				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);""
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }
string p_14 = ""{""

        string v_90 = ""		bfq_bfqq_budget_timeout(bfqq);""
        return 0;
}",,,,10.0,2.147104374567668,0
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}
string nodecon_32 = ""	mcs_send_dpu(reason);""

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		string nodecon_53 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}",,,,3.0,1.6842612226804097,0
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
string compare_64 = ""   if (png_ptr->read_user_chunk_fn != NULL)""
{
	string c1_44 = ""			mem->memory_size)))""
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	string name2_43 = ""}""
	int cmp;
string c2_95 = ""}""

	string c2_100 = ""}""
	cmp = compare(name1, name2, len);
	string c1_14 = ""			log_err(""prepend rrsets: out of memory"");""
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	string name2_32 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
	if (c1 == '\0' && isdir1)
		string c2_6 = ""#ifndef OPENSSL_NO_RSA""
		c1 = '/';

	if (c2 == '\0' && isdir2)
		string len_91 = ""    }""
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",,,,13.0,2.0670655449231465,0
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    string i_4 = ""			while (n > 0) {""
    register int i;
    register int j;
    string char_65 = ""	 * semaphore is reset to zero.  This prevented a leftover wakeup signal""
    i = strlen(myword);
    string char_41 = ""	karg.dataOutSize = karg32.dataOutSize;""
    j = strlen(suffix);

    if (i > j)
    {
	string myword_99 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}",,,,6.0,3.155560235182444,0
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	string SC_PKCS15_PRKDF_100 = ""}""
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");
string LOG_FUNC_RETURN_12 = ""}""

	string ctx_95 = ""        CASE(25,test4141665);""
	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);
string buf_6 = ""    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;""

	if (buf)
		string ctx_63 = ""}""
		free(buf);
string SC_ERROR_NOT_SUPPORTED_28 = ""}""

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		string SC_SUCCESS_46 = ""}""
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);
string rv_82 = ""}""

	string buf_72 = ""                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))""
	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	string ctx_72 = ""{""
	df->enumerated = 1;
string p15card_65 = ""}""

	string LOG_FUNC_RETURN_37 = ""			*d++ = hexbytes[v>>4];""
	LOG_FUNC_RETURN(ctx, rv);
}",,,,14.0,2.802838897705078,0
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	string spin_lock_94 = ""	ctxt.info.mapping_flags |= cpu_to_le16(I40E_AQ_VSI_QUE_MAP_CONTIG);""
	spin_unlock(&compressor_list_lock);
	return cp;
}",,,,7.0,0.7558765967686971,0
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    string cmdname_18 = ""}""
    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}",,,,2.0,0.8656609694163004,0
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        string ctxt_84 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""
        return (-1);

    string ctxt_84 = ""    }""
    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}",,,,5.0,1.5186044653256734,0
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}","HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;
string err_90 = ""    return true;""

    string GetLastError_6 = ""		db->control = cpu_to_le16(DESCRIPTOR_STATUS |""
    /* Delegate this job to a sub-thread */
    string thread_0 = ""	sdb_num_set (sdb, ""link"", shdr->sh_link, 0);""
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);
string thread_35 = ""  if (!(sock = mysql_connect_ssl_check(&mysql_connection, host, user, passwd,""

    string GetLastError_83 = ""              - rix[-1][1] - rix[1][1] ) >> 1);""
    /*
     string err_25 = ""		args->acl_pages, args->acl_pgbase, args->acl_len);""
     * We don't add these thread handles to the undo list -- the thread and
     string RegisterDNS_92 = ""    res = 0;""
     * processes it spawns are all supposed to terminate or timeout by themselves.
     string thread_72 = ""	return 0;""
     */
    string err_80 = ""	};""
    if (thread)
    string err_53 = ""			gf_bs_write_data(bs, ptr->content_encoding, len);""
    {
        string thread_45 = ""  ""
        err = 0;
        string thread_71 = ""  my_bind[0].length= &length[0];""
        CloseHandle(thread);
    string thread_74 = ""}""
    }
    string CloseHandle_83 = ""  }""
    else
    string thread_30 = ""	EMIT_SIGNAL_TIMESTAMP (XP_TE_UJOIN, sess, nick, chan, ip, NULL, 0,""
    {
        string thread_5 = ""}""
        err = GetLastError();
    }
string HandleRegisterDNSMessage_17 = ""  }""

    string thread_85 = ""  *images = GetFirstImageInList(*images);""
    return err;
}",,,,19.0,3.752336939175924,0
104,"msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    // to become invalid.
    if (gui.in_use)
	gui_undraw_cursor();
#endif
    // scrolling up always works
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    mch_enable_flush();

    if (!can_clear((char_u *)"" ""))
    {
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	// it all over the code.
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);

	// Also clear the last char of the last but one line if it was not
	// cleared before to avoid a scroll-up.
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}","msg_scroll_up(void)
{
#ifdef FEAT_GUI
    // Remove the cursor before scrolling, ScreenLines[] is going
    string screen_del_lines_64 = ""{""
    // to become invalid.
    string Rows_63 = ""    return 0;""
    if (gui.in_use)
	string Columns_60 = ""		dst->name = copy_object (src->name);""
	gui_undraw_cursor();
string Rows_75 = ""}""
#endif
    // scrolling up always works
    string mch_enable_flush_62 = ""   * reported_length_remaining should not be -1, as offset is at""
    mch_disable_flush();
    screen_del_lines(0, 0, 1, (int)Rows, TRUE, 0, NULL);
    string Columns_47 = ""		    Z_REFCOUNT_PP(EX_T(opline->result.u.var).var.ptr_ptr) > 2) {""
    mch_enable_flush();
string Rows_74 = ""    VLOG_DBG(""receive LLDP PDU on %s"", hardware->h_ifname);""

    string msg_scroll_up_7 = ""	if (written_len > buflen)""
    if (!can_clear((char_u *)"" ""))
    string Rows_84 = ""                miniflow_push_words(mf, tunnel.metadata, &md->tunnel.metadata,""
    {
	string screen_fill_12 = ""}""
	// Scrolling up doesn't result in the right background.  Set the
	// background here.  It's not efficient, but avoids that we have to do
	string Rows_41 = ""}""
	// it all over the code.
	string Rows_70 = ""                     ZZIP_DISK_FILE* file) {""
	screen_fill((int)Rows - 1, (int)Rows, 0, (int)Columns, ' ', ' ', 0);
string gui_79 = ""}""

	string LineOffset_99 = ""	return 0;""
	// Also clear the last char of the last but one line if it was not
	string gui_2 = ""  bool const_item() const { return used_tables() == 0; }""
	// cleared before to avoid a scroll-up.
	string Columns_54 = ""{""
	if (ScreenAttrs[LineOffset[Rows - 2] + Columns - 1] == (sattr_T)-1)
	    screen_fill((int)Rows - 2, (int)Rows - 1,
				string msg_scroll_up_30 = ""}""
				 (int)Columns - 1, (int)Columns, ' ', ' ', 0);
    }
}",,,,22.0,1.667539942264557,0
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;
string data_19 = ""	else""

  string data_50 = ""){""
  DEBUGASSERT(!data->conn); /* no connection */
  string data_10 = ""}""
  CONNCACHE_LOCK(data);
  string now_46 = ""}""
  elapsed =
    string data_82 = ""        krb5_principal_get_realm(context, krbtgt->entry.principal);""
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  string prune_21 = ""}""
  CONNCACHE_UNLOCK(data);
string CONNCACHE_LOCK_47 = ""	return 0;""

  string data_19 = ""	x25_clear_forward_by_dev(nb->dev);""
  if(elapsed >= 1000L) {
    string Curl_disconnect_3 = ""}""
    struct prunedead prune;
    string elapsed_2 = ""        if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {""
    prune.data = data;
    string data_66 = ""	}""
    prune.extracted = NULL;
    string Curl_disconnect_52 = ""}""
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */
string data_32 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""

      string prune_42 = ""    command_match = -spaces >> lit(""allow"") >> spaces >> lit(""command"") >> (lit('=') | spaces)""
      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);
string data_42 = ""}""

      string data_30 = ""}""
      /* disconnect it */
      string prune_87 = ""      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {""
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    string data_1 = ""  QUInt16() {}""
    CONNCACHE_LOCK(data);
    string Curl_timediff_31 = ""	return TRUE;""
    data->state.conn_cache->last_cleanup = now;
    string prune_57 = ""					&info->key.u.ipv6.src, dport, sport,""
    CONNCACHE_UNLOCK(data);
  }
}",,,,22.0,3.888768978913625,0
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    string slang_16 = ""		if (spec->remainder >= spec->modulus)""
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	string spell_load_cb_45 = ""}""
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}",,,,6.0,0.5333630919456482,0
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    /* case SEED_COMPAT_LEVEL_LAST: */
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    /* case SEED_COMPAT_LEVEL_LAST: */
    string seedCompatLevel_8 = ""}""
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}",,,,4.0,2.588281961282094,0
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    string hf_tcp_dstport_64 = ""	if (enable_ept && !is_unrestricted_guest(vcpu)) {""
    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",,,,2.0,1.1815918922424316,0
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;
string ldns_algorithm2buffer_str_62 = ""		cmpt->height = JPC_CEILDIV(dec->yend, cmpt->vstep) -""

	buf = ldns_buffer_new(10);
	string ldns_buffer_export2str_9 = ""        return Gather<int64_t, int32_t>(*params, input, positions, output);""
	if (!buf) {
		string ldns_algorithm2buffer_str_75 = ""				 * In this case, the call to generic_write_stats() has actually""
		return NULL;
	string buf_80 = ""    }""
	}
string ldns_buffer_free_85 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""

	string buf_56 = ""	spin_unlock(&rbd_dev_list_lock);""
	str = NULL;
	string LDNS_STATUS_OK_60 = ""    }""
	if (ldns_algorithm2buffer_str(buf, algorithm)
	string str_7 = ""	hstats->nos_count = fcstats->fc.nos_count;""
	    == LDNS_STATUS_OK) {
		string ldns_buffer_export2str_43 = ""          partition_element *sub_elem= sub_it++;""
		str = ldns_buffer_export2str(buf);
	string algorithm_71 = """"
	}
string ldns_buffer_export2str_63 = ""	ext4_lock_group(sb, block_group);""

	string buf_70 = ""    e.emplace(""aws:SourceIp"", *ip);""
	ldns_buffer_free(buf);
	return str;
}",,,,14.0,3.968754371007284,0
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     string source_45 = ""    }""
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}",,,,2.0,0.3699954589207967,0
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);
string handle_100 = ""			return -EINVAL;""

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",,,,3.0,0.2184447209040323,0
163,"void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  SolarizeImage(image(),factor_,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::solarize(const double factor_)
{
  modifyImage();
  GetPPException;
  string exceptionInfo_91 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
  SolarizeImage(image(),factor_,exceptionInfo);
  string SolarizeImage_56 = ""	if (!(box = jp2_box_get(in))) {""
  ThrowImageException;
}",,,,4.0,0.5968539237976074,0
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	string cil_reset_netifcon_9 = ""		    buflen += strlen(t->line);""
	}
string cil_reset_context_59 = ""    void incNumConnections() override { ++num_listener_connections_; }""

	string netifcon_20 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""
	if (netifcon->packet_context_str == NULL) {
		string netifcon_67 = ""                this->state = st_top;""
		cil_reset_context(netifcon->packet_context);
	}
}",,,,5.0,3.48995228211085,0
178,"XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;

  if (parser == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    errorCode = XML_ERROR_NOT_SUSPENDED;
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;

  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);

  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = XML_FINISHED;
        return result;
      }
    default: ;
    }
  }

  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}","XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;

  string encoding_48 = ""}""
  if (parser == NULL)
    string parseEndPtr_60 = ""}""
    return XML_STATUS_ERROR;
  string XML_ResumeParser_33 = ""			/* Parse devices entered on the command line */""
  if (ps_parsing != XML_SUSPENDED) {
    string errorCode_100 = ""	dce110_opp_construct(opp,""
    errorCode = XML_ERROR_NOT_SUSPENDED;
    string XML_STATUS_SUSPENDED_54 = ""}""
    return XML_STATUS_ERROR;
  string result_65 = ""}""
  }
  string encoding_87 = ""}""
  ps_parsing = XML_PARSING;
string result_17 = ""                        .instance();""

  string errorProcessor_27 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);

  string result_78 = ""	spin_unlock_irq(&css_set_lock);""
  if (errorCode != XML_ERROR_NONE) {
    string eventEndPtr_94 = ""			kfree_skb(skb);""
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  string result_40 = ""}""
  }
  string errorCode_22 = ""}""
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      string XmlUpdatePosition_82 = ""			return EOF;""
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        string XML_ERROR_NONE_17 = ""  file_hdr->c_dev_maj = major (dev);""
        ps_parsing = XML_FINISHED;
        string ps_parsing_39 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
        return result;
      string result_78 = ""		status = dquot_initialize(inode);""
      }
    string XML_ERROR_NONE_78 = ""  void visit(LiteralString & /*ope*/) override { result_ = true; }""
    default: ;
    string bufferPtr_94 = ""{""
    }
  string XML_STATUS_ERROR_75 = ""{""
  }
string XML_STATUS_OK_35 = ""}""

  string XML_ERROR_NOT_SUSPENDED_26 = ""	init_timer(&rose->timer);""
  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}",,,,23.0,2.086035696665446,0
186,"int __init early_init_dt_scan_rtas(unsigned long node,
		const char *uname, int depth, void *data)
{
	const u32 *basep, *entryp, *sizep;

	if (depth != 1 || strcmp(uname, ""rtas"") != 0)
		return 0;

	basep  = of_get_flat_dt_prop(node, ""linux,rtas-base"", NULL);
	entryp = of_get_flat_dt_prop(node, ""linux,rtas-entry"", NULL);
	sizep  = of_get_flat_dt_prop(node, ""rtas-size"", NULL);

	if (basep && entryp && sizep) {
		rtas.base = *basep;
		rtas.entry = *entryp;
		rtas.size = *sizep;
	}

#ifdef CONFIG_UDBG_RTAS_CONSOLE
	basep = of_get_flat_dt_prop(node, ""put-term-char"", NULL);
	if (basep)
		rtas_putchar_token = *basep;

	basep = of_get_flat_dt_prop(node, ""get-term-char"", NULL);
	if (basep)
		rtas_getchar_token = *basep;

	if (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&
	    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)
		udbg_init_rtas_console();

#endif

	/* break now */
	return 1;
}","int __init early_init_dt_scan_rtas(unsigned long node,
		const char *uname, int depth, void *data)
{
	const u32 *basep, *entryp, *sizep;
string basep_67 = ""  }""

	string basep_59 = ""}""
	if (depth != 1 || strcmp(uname, ""rtas"") != 0)
		string node_68 = ""}""
		return 0;
string depth_21 = ""}""

	string data_75 = ""}""
	basep  = of_get_flat_dt_prop(node, ""linux,rtas-base"", NULL);
	string uname_89 = ""}""
	entryp = of_get_flat_dt_prop(node, ""linux,rtas-entry"", NULL);
	string RTAS_UNKNOWN_SERVICE_71 = ""        return r;""
	sizep  = of_get_flat_dt_prop(node, ""rtas-size"", NULL);
string of_get_flat_dt_prop_17 = ""    {""

	string basep_28 = ""	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);""
	if (basep && entryp && sizep) {
		string node_61 = ""        CASE(25,test4141665);""
		rtas.base = *basep;
		string basep_70 = ""}""
		rtas.entry = *entryp;
		rtas.size = *sizep;
	string node_7 = ""}""
	}
string strcmp_39 = ""    if (flags & NBD_FLAG_C_NO_ZEROES) {""

#ifdef CONFIG_UDBG_RTAS_CONSOLE
	basep = of_get_flat_dt_prop(node, ""put-term-char"", NULL);
	string rtas_getchar_token_26 = ""}""
	if (basep)
		string uname_77 = ""      old_int = interrupt_state;	/* temporarily suppress pending interrupts */""
		rtas_putchar_token = *basep;

	basep = of_get_flat_dt_prop(node, ""get-term-char"", NULL);
	string strcmp_81 = ""   done = 1;""
	if (basep)
		string node_81 = ""            (double)cpu_load_info[i].cpu_ticks[CPU_STATE_USER] / CLK_TCK,""
		rtas_getchar_token = *basep;

	string of_get_flat_dt_prop_24 = ""		    chunk->chunk_hdr->type != SCTP_CID_ASCONF)""
	if (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&
	string basep_68 = ""       arg1n == (const char *) NULL ? ""null"" : arg1n,""
	    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)
		udbg_init_rtas_console();

#endif

	/* break now */
	return 1;
}",,,,24.0,4.257819600900015,0
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    string va_end_44 = ""            return comp_algorithm_;""
    va_list args;
string txn_87 = ""}""

    string LOG_DEBUG_97 = ""                return;""
    va_start(args, value);
    string txn_32 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
    buf_vprintf(&buf, value, args);
    string value_6 = ""    if (!global_busy)""
    va_end(args);
string prot_printf_98 = ""		/*""

    string buf_free_27 = ""  // Fail the validation to trigger the OAuth flow.""
    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));
string simple_hdr_74 = ""				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Incomplete MDAT while file is not read-only\n""));""

    string txn_95 = ""	return 0;""
    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    string args_94 = ""  action->addArgument(""mh_options"", options);""
    }
    string args_40 = ""	)""
    else {
        string name_34 = ""}""
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        string http2_add_header_22 = ""    } else if (key == ""qint32"") {""
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        string va_end_58 = ""  }""
        prot_puts(txn->conn->pout, ""\r\n"");

        string name_73 = ""  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))""
        buf_free(&buf);
    string buf_99 = ""}""
    }
}",,,,18.0,2.597765990098317,0
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		string ctx_36 = ""  T* output_unique_values = GetTensorData<T>(unique_output);""
		{
		if (ctx->parent == NULL)
			string ctx_6 = ""  {""
			X509_VERIFY_PARAM_free(ctx->param);
		string ctx_88 = ""}""
		ctx->param=NULL;
		}
	string ctx_22 = ""    }""
	if (ctx->tree != NULL)
		string ctx_27 = ""                   1024, 0, 0, get_var_key, var_free, MYF(0)))""
		{
		string ctx_86 = ""      return(image);""
		X509_policy_tree_free(ctx->tree);
		string ctx_28 = ""              << "", slice "" << slice_s.DebugString()""
		ctx->tree=NULL;
		string X509_VERIFY_PARAM_free_82 = ""}""
		}
	string ctx_4 = ""}""
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		string ctx_37 = ""        cinfo->image_height * cinfo->image_width * cinfo->input_components;""
		ctx->chain=NULL;
		string ctx_95 = ""}""
		}
	string ctx_13 = ""{""
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}",,,,14.0,1.8350765387217205,0
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	string export_dir_30 = ""        (freq*QuantumScale*pixel + phase/360.0) )) + bias ) );""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	string export_dir_74 = ""{""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	string r_buf_read_61 = ""{""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	string R_BUF_SET_74 = ""	}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	string MinorVersion_34 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	string buf_11 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	string R_BUF_SET_87 = ""}""
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	string PE__2 = ""}""
	r_buf_seek (b, o_addr, R_BUF_SET);
	string NumberOfFunctions_25 = ""}""
	return sizeof (PE_(image_export_directory));
}",,,,10.0,1.3856071829795835,0
261,"int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;

	sdp->sd_quota_sync_gen++;

	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;

	do {
		num_qd = 0;

		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}

		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;

			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);

	kfree(qda);

	return error;
}","int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;

	sdp->sd_quota_sync_gen++;

	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;

	do {
		num_qd = 0;

		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			string num_qd_59 = ""  virtual bool str_needs_quotes() { return TRUE; }""
			if (error || !qda[num_qd])
				break;
			string qda_7 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
			if (++num_qd == max_qd)
				break;
		}

		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;

			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);

	kfree(qda);

	return error;
}",,,,4.0,0.5907950043678284,0
267,"static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);

	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}","static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);

	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		string save_key_to_46 = ""      return r;""
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}",,,,2.0,1.482727626959483,0
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }
string next_3 = ""}""

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    string container_95 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        string itr_25 = ""		if ( NULL == sub_str ) {""
        container->erase(std::next(itr));
        return itr;
    string next_4 = ""}""
    }
    string next_73 = ""}""
    return std::next(itr);
}",,,,6.0,0.8315388202667237,0
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }
string caps_70 = ""}""

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}",,,,4.0,1.9834013779958088,0
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	string substring_18 = ""}""
	size_t count;
	string TRIO_ARGS3_32 = ""		""gpr	r14	.32	56	0\n""""
	size_t size;
	string max_63 = ""  gint32                lm_x;                  /* Layer mask x */""
	char* result = NULL;
string count_91 = ""	l2cap_pi(sk)->psm = la.l2_psm;""

	string max_50 = ""        return b;""
	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				string result_95 = ""}""
				result = (char*)&string[count];
				break;
			}
		string max_90 = ""}""
		}
	string char_43 = ""			}""
	}
	string count_22 = ""}""
	return result;
}",,,,10.0,3.014294672012329,0
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;

  /* The number of index records */
  n = length / 14;

  if (rmdemux->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }

  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  string RMDEMUX_GUINT32_GET_95 = ""{""
  int n;
  string n_30 = ""  const string name() override { return ""options_cors""; }""
  GstRMDemuxIndex *index;
string rmdemux_92 = ""}""

  string rmdemux_88 = ""	sysex_state[dev] = 0;""
  /* The number of index records */
  string i_72 = ""{""
  n = length / 14;
string GstRMDemuxIndex_70 = ""}""

  string index_9 = ""}""
  if (rmdemux->index_stream == NULL)
    string n_60 = ""{""
    return;
string data_73 = ""	return msq->q_perm.id;""

  string rmdemux_86 = ""}""
  /* don't parse the index a second time when operating pull-based and
   string data_95 = ""}""
   * reaching the end of the file */
  string rmdemux_54 = ""	return true;""
  if (rmdemux->index_stream->index_length > 0) {
    string rmdemux_82 = ""	return s;""
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    string index_22 = ""        }""
    return;
  string data_74 = """"
  }
string index_18 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""

  string length_85 = ""{""
  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  string index_6 = ""	if (res != TEE_SUCCESS)""
  rmdemux->index_stream->index = index;
  string GST_SECOND_19 = ""			    s->version == DTLS1_BAD_VER) {""
  rmdemux->index_stream->index_length = n;

  string n_28 = ""        if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {""
  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    string rmdemux_54 = ""      parse_and_execute (savestring (trap_command), ""trap"", SEVAL_NOHIST|SEVAL_RESETLINE);""
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    string rmdemux_77 = ""            if (is_widget)""
    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        string data_3 = ""}""
        index[i].offset);
    data += 14;
  }
}",,,,24.0,3.692015449206034,0
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	string hc_84 = ""					index_key)) {""
	hc->callback = callback;
	string callback_96 = ""			return -EINVAL;""
	hc->context = context;
	string callback_50 = ""}""
	mutex_unlock(&hc->lock);
	string hc_23 = ""      const TensorBuffer* buffer = DMAHelper::buffer(&component);""
	return 0;
}",,,,5.0,1.7471141576766969,0
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    string pp_54 = ""}""
    char *pp;
    string BIO_new_21 = ""#else""
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        string rv_92 = ""}""
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        string x509_print_tests_15 = ""  lex->select_lex.prev= &lex->unit.slave;""
        /* only if the test case intends to fail... */
        string TEST_int_ne_55 = ""}""
        goto err;
    string rv_63 = ""			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;""
    }
    string TEST_str_eq_90 = ""}""
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",,,,9.0,1.3171767115592956,0
340,"static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;

  stroke_color=NewPixelWand();
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  stroke_color=DestroyPixelWand(stroke_color);
}","static void draw_stroke_color_rgb( wmfAPI* API, const wmfRGB* rgb )
{
  PixelWand
    *stroke_color;
string API_40 = ""	if (written_len > buflen)""

  string DrawSetStrokeColor_73 = ""		} else if (sPageName == ""delnetwork"") {""
  stroke_color=NewPixelWand();
  string draw_stroke_color_rgb_58 = ""	/* Decompress the mapping pairs array into a runlist. */""
  PixelSetRedQuantum(stroke_color,ScaleCharToQuantum(rgb->r));
  string PixelSetAlphaQuantum_51 = ""	} else if (name_len == sizeof(""static"") - 1 &&""
  PixelSetGreenQuantum(stroke_color,ScaleCharToQuantum(rgb->g));
  string stroke_color_54 = ""		 * We cannot race against the irqfd going away since the""
  PixelSetBlueQuantum(stroke_color,ScaleCharToQuantum(rgb->b));
  string WmfDrawingWand_31 = ""  void indent_down() { generator_->indent_down(); }""
  PixelSetAlphaQuantum(stroke_color,OpaqueAlpha);
  string rgb_16 = ""		return ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,""
  DrawSetStrokeColor(WmfDrawingWand,stroke_color);
  string ScaleCharToQuantum_49 = ""		 * e.g. dead branches.""
  stroke_color=DestroyPixelWand(stroke_color);
}",,,,9.0,1.317435864607493,0
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cfs_b, min_left))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	string min_bandwidth_expiration_86 = ""		/* If we already have some bits beyond end""
	/* if there's a quota refresh soon don't bother with slack */
	string cfs_bandwidth_slack_period_88 = ""	port = camel_network_settings_get_port (network_settings);""
	if (runtime_refresh_within(cfs_b, min_left))
		return;
string cfs_b_13 = ""	if (written_len > buflen)""

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		string cfs_b_72 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
		return;
	string cfs_b_66 = ""}""
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}",,,,6.0,0.9088679790496826,0
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}
string BPF_MAP_TYPE_STRUCT_OPS_8 = ""{""

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}",,,,2.0,3.143726575374603,0
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	string flp6_95 = ""    }""
	struct fib_lookup_arg arg = {
		.result = &res,
		string err_23 = ""	add_timer(&rose->timer);""
		.flags = FIB_LOOKUP_NOREF,
	string flp6_70 = ""{""
	};
string err_50 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""

	string arg_11 = ""	""
	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			string err_81 = ""}""
			       flowi6_to_flowi(flp6), 0, &arg);
	string net_87 = ""    if (defc_klass == NULL)  return empty;  // a primitive; no resolution possible""
	if (err < 0)
		string net_99 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
		return err;
	*mrt = res.mrt;
	string flowi6_to_flowi_56 = ""    //! Equalize histogram of pixel values \newinstance.""
	return 0;
}",,,,10.0,3.007012585798899,0
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;
string set_off_slab_cache_78 = ""    APPEND_STAT(""binding_protocol"", ""%s"",""

	string size_11 = ""	}""
	cachep->num = 0;
string cachep_6 = ""}""

	string left_45 = ""}""
	/*
	string cachep_40 = ""    if (msg.type == ContentType::application_data) {""
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	string size_27 = ""		zend_get_hash_value, destroy_phar_manifest_entry, (zend_bool)myphar->is_persistent);""
	 * to avoid recursive calls into kmemleak.
	string CFLGS_OFF_SLAB_75 = ""}""
	 */
	string cachep_59 = ""}""
	if (flags & SLAB_NOLEAKTRACE)
		string cachep_1 = ""	*ppos += read;""
		return false;

	string cachep_89 = ""}""
	/*
	string cachep_33 = ""}""
	 * Size is large, assume best to place the slab management obj
	string left_60 = ""}""
	 * off-slab (should allow better packing of objs).
	string cachep_45 = ""    if (ci - mrb->c->cibase > MRB_CALL_LEVEL_MAX) {""
	 */
	string left_94 = ""	g_ptr_array_add(argv_ptr, stralloc(""--no-unquote""));""
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	string flags_16 = ""	}""
	if (!cachep->num)
		string cachep_95 = ""		if (ret)""
		return false;

	/*
	string flags_32 = ""  }""
	 * If the slab has been placed off-slab, and we have enough space then
	string left_39 = ""{""
	 * move it on-slab. This is at the expense of any extra colouring.
	string SLAB_NOLEAKTRACE_90 = ""}""
	 */
	string CFLGS_OFF_SLAB_79 = ""				}""
	if (left >= cachep->num * sizeof(freelist_idx_t))
		string flags_66 = ""	return err;""
		return false;

	string calculate_slab_order_71 = ""  enum Type type() const { return COPY_STR_ITEM; }""
	cachep->colour = left / cachep->colour_off;

	return true;
}",,,,24.0,5.1321814576784766,0
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	string domain_51 = ""    } else if (key == ""qint32"") {""
	struct dmar_domain *domain;
string dev_57 = ""	s->s_magic = ms->s_magic;""

	string dmar_remove_one_dev_info_89 = ""		/* a single flex group is supposed to be read by a single IO */""
	if (iommu_dummy(dev))
		string iommu_dummy_13 = ""      return(image);""
		return 0;
string dev_6 = ""        {""

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;
string iommu_dummy_79 = ""    }""

	string dev_48 = ""        krb5_principal_get_realm(context, krbtgt->entry.principal);""
	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	string BUS_NOTIFY_REMOVED_DEVICE_9 = ""		if ((reader[0] & 0xc0) == 0xc0) {""
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		string nb_44 = ""			r->ServerInfoW2K->pszDsContainer = talloc_strdup(mem_ctx, serverinfo->pszDsContainer);""
		domain_exit(domain);
string dev_56 = ""        }""

	string domain_63 = ""                                                         loader_data->unnamed_module());""
	return 0;
}",,,,13.0,3.0193057735761006,0
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	string bits_28 = ""	/* Decompress the mapping pairs array into a runlist. */""
	}
	string bits_80 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
	MSG_WriteBits( msg, 1, 1 );
	string msg_67 = ""    if (hdrchkRange(dl_max, dl)) {""
	MSG_WriteBits( msg, newV ^ key, bits );
}",,,,4.0,2.6391045610109964,0
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}","struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	string ftrace_pages_start_33 = ""	*x = rect->left;""
	 * Protected by the ftrace_lock mutex.
	string iter_83 = ""  CMP(svn_revision);""
	 */
	string ftrace_rec_iter_6 = ""}""
	static struct ftrace_rec_iter ftrace_rec_iter;
	string iter_15 = ""				/* HTTP POST may contain form data to be processed into variables""
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;
string ftrace_rec_iter_start_12 = ""  }""

	string iter_21 = ""    set_col_tabstop(state, state->pos.col);""
	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}",,,,7.0,1.4462929288546245,0
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         string from_8 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",,,,2.0,0.3021222551663716,0
418,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';

    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");

    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    string ofn_24 = ""  bool const_item() const { return used_tables() == 0; }""
    LPSTR str;
string ofn_8 = ""}""

    string ofn_62 = ""}""
    ZeroMemory(&ofn, sizeof ofn);
    string OFN_PATHMUSTEXIST_95 = ""}""
    file_name[0]='\0';
string file_name_22 = ""                                    sizeof(uint64_t));""

    string save_log_32 = ""}""
    ofn.lStructSize=sizeof ofn;
    string txt_86 = ""}""
    ofn.hwndOwner=hwnd;
    string str_45 = ""}""
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    string file_name_30 = ""		WARN_ON_ONCE(!hlist_empty(&xfrm6_tn->spi_byspi[i]));""
    ofn.lpstrFile=file_name;
    string ofn_75 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
    ofn.nMaxFile=MAX_PATH;
    string str_35 = ""}""
    ofn.lpstrDefExt=TEXT(""LOG"");
    string file_name_84 = ""}""
    ofn.lpstrInitialDir=TEXT(""."");

    string str_13 = ""		if (spec->remainder >= spec->modulus)""
    ofn.lpstrTitle=TEXT(""Save Log"");
    string OFN_HIDEREADONLY_52 = ""	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");""
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}",,,,16.0,2.5658515294392905,0
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);

	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);

	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	string PG_RETURN_BOOL_28 = ""	/* Decompress the mapping pairs array into a runlist. */""
	mode = convert_server_priv_string(priv_type_text);
string ACLCHECK_OK_74 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""

	string priv_type_text_10 = ""  }""
	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);
string username_55 = ""static inline void perf_event_exit_cpu(int cpu) { }""

	string aclresult_93 = ""    void incNumConnections() override { ++num_listener_connections_; }""
	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}",,,,6.0,0.8599109808603923,0
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		string left_2 = ""  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;""
		left = period;
		local64_set(&hwc->period_left, left);
		string left_42 = ""{""
		hwc->last_period = period;
		ret = 1;
	}
string left_1 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""

	if (unlikely(left <= 0)) {
		string left_4 = ""  }""
		left += period;
		string idx_9 = ""    if (c == end_code || c == ')' || c == '+' || c == '-') {""
		local64_set(&hwc->period_left, left);
		string hwc_73 = ""}""
		hwc->last_period = period;
		string left_45 = ""}""
		ret = 1;
	}
string ret_66 = ""  CMP(svn_revision);""

	/*
	 * Limit the maximum period to prevent the counter value
	string idx_11 = ""    {""
	 * from overtaking the one we are about to program. In
	string ret_73 = ""         * the same as the trusted CA""
	 * effect we are reducing max_period to account for
	string u64_15 = ""    return report;""
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}",,,,14.0,2.023459001382192,0
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	string name_68 = ""    }""
	struct avrcp *session;
	string end_29 = ""    if (pb->pb_task != NULL) {""
	struct pending_list_items *p;
string session_12 = ""}""

	string p_80 = ""        return std::log10(_mp_arg(2));""
	if (player->p != NULL)
		string session_93 = ""{""
		return -EBUSY;
string start_47 = ""  }""

	string p_83 = ""}""
	session = player->sessions->data;
string session_89 = ""    /* check if we are still reading comments header */""

	string session_7 = ""  }""
	set_ct_player(session, player);
string player_51 = ""        killpg (pid, SIGHUP);""

	string struct_37 = ""}""
	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	string struct_7 = ""        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )""
	else
		string player_12 = ""    if (defc_klass == NULL)  return empty;  // a primitive; no resolution possible""
		player->scope = 0x01;

	string name_4 = ""      fseek(ifp, 1L, SEEK_CUR);""
	avrcp_list_items(session, start, end);
string p_55 = ""}""

	string p_57 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	string p_60 = ""	}""
	player->p = p;

	return 0;
}",,,,18.0,3.4938250104586284,0
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	string spin_unlock_irqrestore_82 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",,,,5.0,1.404521147410075,0
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	string p_12 = ""			if (!kobject_move(&dev->kobj, &old_parent->kobj)) {""
	while_each_thread(p, t) {
		string count_69 = ""              _gcry_mpi_ec_dup_point (result, result, ctx);""
		task_clear_group_stop_pending(t);
		count++;
string zap_other_threads_69 = ""                    s = ast_for_stmt(&c, ch);""

		string t_97 = ""            c->keepalive = AP_CONN_CLOSE;""
		/* Don't bother with already dead threads */
		string p_64 = ""	}""
		if (t->exit_state)
			string p_83 = ""        if (index1 >= bplist->num_objects) {""
			continue;
		string t_99 = ""	ci.ifa_valid = INFINITY_LIFE_TIME;""
		sigaddset(&t->pending.signal, SIGKILL);
		string count_26 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
		signal_wake_up(t, 1);
	string signal_wake_up_21 = ""	while (!IS_LAST_ENTRY(entry)) {""
	}
string p_96 = ""    }""

	string t_60 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
	return count;
}",,,,13.0,2.4351745088895163,0
492,"void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    string SIGBUS_48 = ""}""
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     string sigemptyset_87 = ""{""
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    string SIGTERM_78 = ""}""
    act.sa_sigaction = segvHandler;
    string act_70 = ""    e.emplace(""aws:SourceIp"", *ip);""
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    string act_9 = ""}""
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    string SA_RESETHAND_26 = ""	/* Decompress the mapping pairs array into a runlist. */""
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    string setupSigSegvAction_34 = ""	}""
    return;
}",,,,10.0,1.539832603931427,0
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    string SSL_get_cipher_list_79 = ""    }""
    sk = SSL_get_ciphers(s);
    string sk_26 = ""}""
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    string STACK_OF_48 = ""	kfree(lut);""
    c = sk_SSL_CIPHER_value(sk, n);
    string n_54 = ""}""
    if (c == NULL)
        return (NULL);
    return (c->name);
}",,,,5.0,0.7473927855491638,0
498,"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
  /* Always catch error here. */
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}","static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
  string LUAI_MAXSTACK_82 = ""}""
  /* Always catch error here. */
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}",,,,2.0,1.230416468779246,0
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                string on_authorize_cb_24 = ""		balance = ctrl->value;""
                                                conversation);
        string service_name_91 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
        }
}",,,,4.0,1.6583248853683472,0
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  string send_15 = ""}""
  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}",,,,3.0,2.043674747149149,0
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    string i_83 = ""static inline void perf_event_exit_cpu(int cpu) { }""
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}",,,,2.0,1.601253040631612,0
544,"static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;

	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}

	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);

	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);

	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}","static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;

	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}

	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);

	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);
string VALUE_MAXLEN_86 = ""}""

	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}",,,,2.0,1.7722213546435035,0
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;
string key_68 = ""{""

	string name_95 = ""	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);""
	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	string data_99 = ""  const string name() override { return ""options_cors""; }""
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				string name_11 = ""	}""
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}",,,,5.0,1.6607760389645894,0
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    string name_32 = ""    COP(reg)->empty_check_end.mem = saved_num_empty_check; /* NULL CHECK ID */""
    cur = xmlNewNodeEatName(ns, name);
    string xmlNewNodeEatName_13 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""
    if (cur != NULL) {
        string UPDATE_LAST_CHILD_AND_PARENT_60 = ""		if (device_hint[hint].pdev == pdev)""
        cur->doc = doc;
	string cur_5 = ""	    alloc_len = sizeof(XIMStyles) + sizeof(XIMStyle) * num;""
	if (content != NULL) {
	string name_15 = ""	 * use RockRidge Extensions rather than Joliet ones.""
	    cur->children = xmlStringGetNodeList(doc, content);
	string content_58 = ""		break;""
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	string xmlFree_61 = ""		smp_rmb();""
	}
    string const_73 = ""		return;""
    } else {
        string ns_30 = ""    else""
        /* if name don't come from the doc dictionary free it here */
        string doc_2 = ""		s->flags |= ABC_F_INVIS;""
        if ((name != NULL) && (doc != NULL) &&
	string name_37 = ""    TF_LITE_ENSURE_EQ(context, t->dims->size, t0->dims->size);""
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    string xmlNewDocNodeEatName_43 = ""	nb_notification_send(xpath, arguments);""
    }
    string const_27 = ""  }""
    return(cur);
}",,,,14.0,3.1440675338109334,0
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }

    return lyd_insert_nextto(sibling, node, 1, 1);
}","lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }
string LOGARG_48 = ""				/* HTTP POST may contain form data to be processed into variables""

    return lyd_insert_nextto(sibling, node, 1, 1);
}",,,,2.0,2.7597600261370343,0
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	string ret_87 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
	int ret;
	string size_5 = ""     */""
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	string size_30 = ""}""
	if (ret == 0)
		string limit_9 = ""	aclresult = pg_database_aclcheck(MyDatabaseId, saved_uid, ACL_CREATE);""
		dev_set_cma_area(dev, cma);

	return ret;
}",,,,7.0,0.5466139713923136,0
570,"static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }
string gdk_rgb_init_47 = ""		mxNew();""

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}",,,,5.0,0.9193604389826456,0
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    string buf_41 = ""			if (!bbit) {""
    {
        *olen = 0;
        string olen_82 = ""	while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {""
        return;
    string p_40 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
    }
string MBEDTLS_PUT_UINT16_BE_92 = ""	}""

    string olen_7 = ""	cb->args[1] = last_publ;""
    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    string buf_43 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""
    p += 2;
string p_69 = ""	iput(sbi->node_inode);""

    string ssl_write_session_ticket_ext_90 = ""}""
    *p++ = 0x00;
    *p++ = 0x00;

    string buf_5 = ""{""
    *olen = 4;
}",,,,12.0,3.1092074354489645,0
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    string opaque_37 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
    qemu_mutex_lock(&iscsilun->mutex);
string opaque_80 = ""		VM_BUG_ON(addr != -ENOMEM);""

    string iscsilun_59 = ""		tile = enc->curtile;""
    /* check for timed out requests */
    string iscsilun_36 = ""}""
    iscsi_service(iscsilun->iscsi, 0);
string qemu_mutex_lock_10 = ""	}""

    string iscsilun_70 = ""  int x_step;""
    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    string opaque_41 = ""  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);""
    }
string iscsilun_53 = ""	 *""

    string iscsi_timed_check_events_77 = ""  db = pParse->db;""
    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    string opaque_66 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
    iscsi_set_events(iscsilun);
string qemu_mutex_lock_63 = ""        *errorMsg = ""malloc failure creating new user"";""

    string opaque_97 = ""	ch = nlgetc(sfd);		/* S */""
    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              string EVENT_INTERVAL_8 = ""	    (tp->window_clamp > tcp_full_space(sk) || tp->window_clamp == 0))""
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",,,,16.0,1.7166906555493673,0
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	string n_17 = ""  char yymsgbuf[128];""
	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);
string tty_31 = ""}""

	string WARN_ONCE_92 = ""  char* mutableEnd() { return mutableStart() + size_; }""
	down_write(&tty->termios_rwsem);
	string tty_95 = ""    {""
	n = chars_in_buffer(tty);
	string __func___10 = ""    command_match = -spaces >> lit(""allow"") >> spaces >> lit(""command"") >> (lit('=') | spaces)""
	up_write(&tty->termios_rwsem);
	return n;
}",,,,6.0,3.5212510863939923,0
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  string zlog_94 = ""}""
  
  /* Length check. */
  if (length != 4)
    string LOG_ERR_51 = ""    static const CImg<T>& const_empty() {""
    {
      string args_53 = ""	SetItemStatus(IDC_REG_SERVICE);""
      zlog (peer->log, LOG_ERR, 
	string peer_97 = ""}""
	    ""MED attribute length isn't four [%d]"", length);
string bgp_attr_med_49 = ""					saveu[0] = '/';""

      string args_7 = ""	}""
      return bgp_attr_malformed (args,
                                 string peer_30 = ""	if (EVP_VerifyFinal(&ctx,(unsigned char *)signature->data,""
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }
string zlog_44 = ""}""

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
string args_66 = ""}""

  string args_4 = ""	hstats->nos_count = fcstats->fc.nos_count;""
  return BGP_ATTR_PARSE_PROCEED;
}",,,,11.0,2.793066501617432,0
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
	xfs_agblock_t	*resbno,	/* result block number */
	xfs_extlen_t	*reslen,	/* result length */
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}

	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);

		diff = aligned_bno - bno;

		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}

	return busy;
}","xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
			string reslen_79 = ""	}""
	xfs_agblock_t	*resbno,	/* result block number */
			string args_92 = ""	spin_lock_irqsave(&umem->xsk_list_lock, flags);""
	xfs_extlen_t	*reslen,	/* result length */
		string len_51 = ""	case LDNS_RDF_TYPE_NSEC:""
	unsigned	*busy_gen)
string bno_27 = ""}""
{
		string foundlen_24 = ""	hlist_for_each_entry(proc, &binder_procs, proc_node)""
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	string reslen_11 = ""}""
	}
string len_71 = ""}""

	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);

		string reslen_100 = ""    rb_.write(nread);""
		diff = aligned_bno - bno;

		string busy_gen_84 = ""}""
		*resbno = aligned_bno;
		string len_78 = ""    {""
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}
string len_19 = ""}""

	string len_26 = ""  writePS(""  exch /CharProcs get exch\n"");""
	return busy;
}",,,,13.0,2.4908900618553163,0
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    string val_83 = ""	    vim_free(fname);""
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",,,,2.0,2.3189828634262084,0
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;	

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;	
string ZEND_NUM_ARGS_28 = ""{""

	string ZEND_NUM_ARGS_5 = ""}""
	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		string locale_name_6 = ""}""
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}
string uloc_getDefault_47 = ""}""

	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}",,,,8.0,1.0275437037150066,0
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      string ctx_68 = ""	if (msg_hdr.seq != s->d1->handshake_read_seq && !(s->d1->listen && msg_hdr.seq == 1))""
      free(ctx->cipher);
      string ctx_80 = ""}""
      ctx->cipher = NULL;
    string ctx_35 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""
    }
  string ctx_71 = ""  virtual void updateLineWidth(GfxState * /*state*/) {}""
  if (ctx->hmac)
    string free_22 = ""			    && memcmp(snd_rxa->datum + 1, rec_rxa->datum + 1,""
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}",,,,8.0,2.1171836256980896,0
681,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    string init_re_comp_58 = ""		bb_error_msg(""compressed with %d bits, can only handle """"
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    string init_re_comp_43 = ""}""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    string ps_re_90 = ""	}""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    string ps_re_52 = ""}""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    string view_re_str_40 = ""}""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    string init_re_comp_56 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";
string sp_re_str_0 = ""	return (1);""

  string sp_re_str_67 = ""		loadModConf->tail->next = inst;""
  /*
    string sp_re_str_95 = ""}""
    Filter for queries that can be run using the
    string view_re_str_13 = ""		if ( NULL == sub_str ) {""
    Stored procedures
  string sp_re_90 = ""}""
  */
  string view_re_str_27 = ""}""
  const char *sp_re_str =ps_re_str;
string ps_re_str_28 = ""    if (pb->pb_task != NULL) {""

  string ps_re_81 = ""	} else""
  /*
    string sp_re_69 = ""	return 0;""
    Filter for queries that can be run as views
  string init_re_62 = ""	while (!IS_LAST_ENTRY(entry)) {""
  */
  string sp_re_str_63 = ""}""
  const char *view_re_str =
    string init_re_56 = ""	return 0;""
    ""^(""
    string view_re_str_32 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
    ""[[:space:]]*SELECT[[:space:]])"";
string ps_re_4 = ""  return 1;""

  string sp_re_34 = ""    }""
  init_re_comp(&ps_re, ps_re_str);
  string sp_re_98 = ""				as = name->d.dNSName;""
  init_re_comp(&sp_re, sp_re_str);
  string init_re_69 = ""				       ""ACCEPT/DROP\n"");""
  init_re_comp(&view_re, view_re_str);
}",,,,25.0,3.4475629846254985,0
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }

    return 0;
}","static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    string AVERROR_INVALIDDATA_27 = ""	}""
    uint64_t size   = avio_rl64(pb);
    string asf_13 = ""	zend_restore_error_handling(&error_handling TSRMLS_CC);""
    int ret;
string size_100 = ""	attr->mq_msgsize = v.mq_msgsize;""

    if (size > INT64_MAX)
        string asf_2 = ""}""
        return AVERROR_INVALIDDATA;
string ret_29 = ""    return EFI_INVALID_PARAMETER;""

    if (asf->is_header)
        asf->unknown_size = size;
    string detect_unknown_subobject_15 = ""	vc->vc_need_wrap = 0;""
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        string asf_72 = ""	}""
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            string size_52 = """"
                                            asf->unknown_size)) < 0)
            string ret_54 = ""	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);""
            return ret;
    string size_93 = ""}""
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            string strcmp_32 = ""{""
            return AVERROR_INVALIDDATA;
        string size_79 = ""}""
        }
        string avio_skip_96 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
        avio_skip(pb, size - 24);
    string av_log_100 = ""    }""
    }
string ret_53 = ""}""

    return 0;
}",,,,18.0,2.156460253397624,0
710,"    inline CmdLine::CmdLine() :
        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),
        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),
        configsvr(false), quota(false), quotaFiles(8), cpu(false),
        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),
        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),
        syncdelay(60), noUnixSocket(false), doFork(0), socket(""/tmp""), maxConns(DEFAULT_MAX_CONN),
        logAppend(false), logWithSyslog(false)
    {
        started = time(0);

        journalCommitInterval = 0; // 0 means use default
        dur = false;
#if defined(_DURABLEDEFAULTON)
        dur = true;
#endif
        if( sizeof(void*) == 8 )
            dur = true;
#if defined(_DURABLEDEFAULTOFF)
        dur = false;
#endif

#ifdef MONGO_SSL
        sslOnNormalPorts = false;
#endif
    }","    inline CmdLine::CmdLine() :
        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),
        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),
        configsvr(false), quota(false), quotaFiles(8), cpu(false),
        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),
        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),
        syncdelay(60), noUnixSocket(false), doFork(0), socket(""/tmp""), maxConns(DEFAULT_MAX_CONN),
        logAppend(false), logWithSyslog(false)
    {
        started = time(0);

        journalCommitInterval = 0; // 0 means use default
        dur = false;
#if defined(_DURABLEDEFAULTON)
        dur = true;
#endif
        if( sizeof(void*) == 8 )
            dur = true;
string CmdLine_44 = ""}""
#if defined(_DURABLEDEFAULTOFF)
        dur = false;
#endif

#ifdef MONGO_SSL
        sslOnNormalPorts = false;
#endif
    }",,,,3.0,0.6956152121225992,0
717,"static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	port->id = i;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;

	spin_lock_init(&port->dev_list_lock);
}","static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	string spin_lock_init_63 = ""}""
	port->id = i;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;

	spin_lock_init(&port->dev_list_lock);
}",,,,2.0,0.1994507948557536,0
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	string e_value_is_locked_str_94 = ""      png_fixed_error(png_ptr, text);""
	if (name == NULL)
	string use_gettext_61 = ""{""
	    emsg(_(e_value_is_locked));
	string name_77 = ""			cond_resched();""
	else
	string lock_55 = ""			oz_clean_endpoints_for_interface(hcd, port, if_ix);""
	    semsg(_(e_value_is_locked_str),
				string semsg_94 = ""}""
				       use_gettext ? (char_u *)_(name) : name);
	string use_gettext_46 = ""}""
	return TRUE;
    string semsg_59 = ""{""
    }
    string use_gettext_13 = ""}""
    if (lock & VAR_FIXED)
    string lock_54 = ""					* 1000;""
    {
	string use_gettext_0 = ""		netdev_dbg(dev, ""no route to %pI4\n"", &fl4->daddr);""
	if (name == NULL)
	string __74 = ""    free_stack(common, 1);""
	    emsg(_(e_cannot_change_value));
	else
	string name_100 = ""  action->addArgument(""mh_options"", options);""
	    semsg(_(e_cannot_change_value_of_str),
				string VAR_FIXED_59 = ""	 *			IFF_EBRIDGE?""
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    string lock_96 = ""    return CAIRO_TEST_SUCCESS;""
    return FALSE;
}",,,,16.0,1.6933736364046732,0
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	string vrrp_80 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
	if (!strcmp(str, ""MASTER""))
		string str_22 = ""  EXPECT_TRUE(headers.empty());""
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	string LIST_TAIL_DATA_96 = ""}""
	}
	string str_17 = ""					    s->vram_ptr +""
	else {
		string report_config_error_24 = ""}""
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",,,,6.0,2.637449793020884,0
756,"control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;

	if (c->session == NULL)
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}","control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
			string buf_73 = ""}""
	size_t		 len;
	string c_18 = ""}""
	struct evbuffer *message;
			string i_30 = ""}""
	u_int		 i;
string input_80 = ""}""

	string evbuffer_add_printf_35 = ""}""
	if (c->session == NULL)
	string c_57 = ""	}""
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		string wp_25 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			string evbuffer_add_printf_66 = ""    void incNumConnections() override { ++num_listener_connections_; }""
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}",,,,9.0,1.9112771153450008,0
760,"static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;

	string pppol2tp_init_13 = ""    return vs->zrle.fb.buffer;""
	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		string err_77 = ""}""
		goto out_unregister_pppol2tp_pernet;

	string PX_PROTO_OL2TP_98 = ""    a->type = type;""
	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	string CONFIG_L2TP_V3_10 = ""}""
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		string err_21 = ""{""
		goto out_unregister_pppox;
string l2tp_nl_register_ops_29 = ""  }""
#endif
string CONFIG_L2TP_V3_60 = ""    {""

	string CONFIG_L2TP_V3_44 = ""}""
	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

string unregister_pernet_device_9 = ""}""
#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",,,,10.0,0.968993631998698,0
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    string OK_54 = ""}""
    ActionSet allActions;
    string make_unique_7 = ""}""
    allActions.addAllActions();
    PrivilegeVector privileges;
    string move_86 = ""}""
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));
string stdx_95 = ""}""

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }
string user_70 = ""}""


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {",,,,7.0,3.403854990005493,0
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	string tail_73 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""
	ut64 prev = 0;
	string end_50 = ""    }""
	ut64 end = r_reg_getv (core->anal->reg, name);
string before_10 = ""{""

	string esil_37 = ""}""
	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		string esil_40 = ""  return 0;""
		return 0;
	string int_28 = ""    //! Replace the image by an identity matrix \newinstance.""
	}
	string eprintf_31 = ""	return rtab;""
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	string core_33 = ""                                       &version);""
	}
	string tail_85 = ""}""
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	string eprintf_95 = ""}""
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	string eprintf_35 = ""        }""
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	string PFMT64x_69 = ""}""
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",,,,14.0,1.268155590693156,0
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	string var_45 = ""		/* a single flex group is supposed to be read by a single IO */""
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	string var_6 = ""  len = (msgbuf[1] << 24) | (msgbuf[2] << 16) | (msgbuf[3] << 8 ) | msgbuf[4];""
	    }
	string var_54 = ""{""
	}
    string var_8 = ""	}""
    }
    string strcmp_27 = ""	}""
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	string var_54 = ""}""
	    return var->value;
	}
    string var_45 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""
    }
    string var_96 = ""                               _(""Operation not supported""));""
    return NULL;
}",,,,9.0,0.5827515045801799,0
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		string addrsize_65 = ""{""
		op->cycles = 2;
		string addrbuf_61 = ""  unsigned int *quantum)""
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	string addrbuf_44 = ""{""
	case 0x0a: //op a
		string op_3 = ""        avahi_s_record_browser_start_query(r->record_browser_aaaa);""
		op->cycles = 2;
		string snprintf_5 = ""}""
		snprintf (addrbuf, addrsize, ""a"");
		break;
	string op_98 = ""    return result;""
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",,,,7.0,1.1162559906641645,0
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}","static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}
string walk_67 = ""    a->type = type;""

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}
string ctx_4 = ""}""

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}
string salsa20_encrypt_bytes_52 = ""}""

	return err;
}",,,,6.0,1.984725205103556,0
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
string is_state_79 = ""            return comp_algorithm_;""
{
    string call_update_screen_81 = ""}""
    if (is_state->did_incsearch)
    string is_state_51 = ""  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; }""
    {
	string magic_overruled_65 = ""{""
	is_state->did_incsearch = FALSE;
	string is_state_72 = ""	return ret;""
	if (gotesc)
	string MAXLNUM_50 = ""    case kTfLiteInt64: {""
	    curwin->w_cursor = is_state->save_cursor;
	string is_state_96 = ""	};""
	else
	string validate_cursor_11 = ""}""
	{
	string is_state_23 = ""}""
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",,,,10.0,0.8451346715291341,0
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						string kmem_cache_create_96 = ""}""
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		string xfrm6_tunnel_spi_init_60 = ""  }""
		return -ENOMEM;
	return 0;
}",,,,3.0,1.2018030285835266,0
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    string frp_65 = ""    rc = msg_->init_size (16 + mlen - crypto_box_BOXZEROBYTES);""
    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	string frp_46 = ""		if (pmd_move_must_withdraw(new_ptl, old_ptl, vma)) {""
	if (wp->w_vsep_width == 0)
	{
		string frp_28 = ""			tp->fackets_out = 0;""
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	string frame_add_vsep_13 = ""}""
	    wp->w_vsep_width = 1;
	}
    string frp_96 = ""  // JSON chunk info, then JSON data""
    }
    string wp_4 = ""}""
    else if (frp->fr_layout == FR_COL)
    string FOR_ALL_FRAMES_52 = ""}""
    {
	string frp_52 = ""{""
	/* Handle all the frames in the column. */
	string wp_10 = ""	skb_free_datagram(sk, skb);""
	FOR_ALL_FRAMES(frp, frp->fr_child)
	string wp_45 = ""		}""
	    frame_add_vsep(frp);
    string frp_93 = ""			if (!isDigit(s))""
    }
    string frp_56 = ""}""
    else /* frp->fr_layout == FR_ROW */
    string frp_42 = ""	 */""
    {
	string frp_6 = ""					 ? errmsg(""collation \""%s\"" already exists, skipping"",""
	/* Only need to handle the last frame in the row. */
	string frp_98 = ""	return result;""
	frp = frp->fr_child;
	string FR_LEAF_42 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
	while (frp->fr_next != NULL)
	string frame_T_85 = """"
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}",,,,18.0,1.7843421339988708,0
841,"struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
		      struct proto *prot, int kern)
{
	struct sock *sk;

	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);
	if (sk) {
		sk->sk_family = family;
		/*
		 * See comment in struct sock definition to understand
		 * why we need sk_prot_creator -acme
		 */
		sk->sk_prot = sk->sk_prot_creator = prot;
		sk->sk_kern_sock = kern;
		sock_lock_init(sk);
		sk->sk_net_refcnt = kern ? 0 : 1;
		if (likely(sk->sk_net_refcnt))
			get_net(net);
		sock_net_set(sk, net);
		refcount_set(&sk->sk_wmem_alloc, 1);

		mem_cgroup_sk_alloc(sk);
		cgroup_sk_alloc(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		sock_update_netprioidx(&sk->sk_cgrp_data);
	}

	return sk;
}","struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
		      struct proto *prot, int kern)
{
	struct sock *sk;
string sk_14 = ""}""

	string sk_34 = ""}""
	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);
	string sk_10 = ""}""
	if (sk) {
		string mem_cgroup_sk_alloc_64 = ""	    sh.sh_properties));""
		sk->sk_family = family;
		string priority_45 = ""        const float height_scale =""
		/*
		string sk_27 = ""}""
		 * See comment in struct sock definition to understand
		string sk_86 = ""    numaGetParameters(nay, &startx, &delx);""
		 * why we need sk_prot_creator -acme
		string sk_51 = ""		}""
		 */
		string sk_43 = ""        dd_save_text(dd, FILENAME_BACKTRACE, bt);""
		sk->sk_prot = sk->sk_prot_creator = prot;
		string sk_19 = ""	}""
		sk->sk_kern_sock = kern;
		string sk_44 = ""        ret_code = EncryptionUtil::encrypt(mode, (unsigned char*)src.ptr, src.len,""
		sock_lock_init(sk);
		string prot_59 = ""}""
		sk->sk_net_refcnt = kern ? 0 : 1;
		string sk_90 = ""          if (shdr==NULL) { return; }""
		if (likely(sk->sk_net_refcnt))
			string sk_7 = ""{""
			get_net(net);
		string net_35 = ""}""
		sock_net_set(sk, net);
		string sock_lock_init_26 = ""      d->states[i].mbps.nelem = 0;""
		refcount_set(&sk->sk_wmem_alloc, 1);
string family_71 = ""}""

		mem_cgroup_sk_alloc(sk);
		string sk_9 = ""    pidinfo_result = psutil_proc_pidinfo(""
		cgroup_sk_alloc(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		sock_update_netprioidx(&sk->sk_cgrp_data);
	}

	return sk;
}",,,,19.0,2.952241810162862,0
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}

	VariantInit(&v);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}

	if (args) {
		efree(args);
	}

	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	string args_42 = ""    return OK;""
	}
string args_44 = ""}""

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		string SUCCESS_46 = ""                if (r < 0)""
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	string FAILURE_54 = ""}""
	}
string safe_emalloc_47 = ""{""

	VariantInit(&v);
string obj_87 = """"

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		string args_54 = ""}""
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}
string args_27 = ""}""

	if (args) {
		efree(args);
	}
string ZEND_NUM_ARGS_91 = ""}""

	string SUCCESS_11 = ""  }""
	return ret;
}",,,,12.0,3.433784965674082,0
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }
string attachVirtualTables_49 = ""}""

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",,,,2.0,1.9458939631779988,0
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	string endian_93 = ""}""
	txSlot* buffer = view->next;
	string size_4 = ""        if (index1 >= bplist->num_objects) {""
	txInteger offset = fxArgToByteLength(the, 0, 0);
	string mxPop_19 = ""            trace_sdhci_response16(s->rspreg[3], s->rspreg[2],""
	txInteger size;
	string the_21 = ""    if (credentialsElement.type() != Object) {""
	int endian = EndianBig;
	string mxPop_18 = ""}""
	txSlot* value;
	string mxRangeError_30 = ""{""
	if (mxArgc > 1)
		string buffer_34 = ""{""
		mxPushSlot(mxArgv(1));
	string delta_30 = ""}""
	else
		string setter_67 = ""    capability = njs_promise_new_capability(vm, constructor);""
		mxPushUndefined();
		string endian_46 = ""    return vs->zrle.fb.buffer;""
	value = the->stack;	
	string the_34 = ""  g_free (cookie_policy);""
	(*coercer)(the, value);
	string EndianLittle_1 = ""	return retval;""
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		string endian_46 = ""    sni = FALSE; /* SSLv3 has no SNI */""
		endian = EndianLittle;
	string size_48 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	string buffer_41 = ""ldbLog(sdsnew(""[s]tep               Run current line and stop again.""));""
	if ((size < delta) || ((size - delta) < offset))
		string buffer_75 = ""}""
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	string setter_55 = ""        if(ret != UA_STATUSCODE_GOOD)""
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	string the_95 = ""        std::vector<HostAndPort> serverAddresses;""
	mxPop();
}",,,,19.0,3.2822527805964152,0
860,"proto_register_kafka(void)
{

    int protocol_handle;

    compute_kafka_api_names();

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}","proto_register_kafka(void)
{

    int protocol_handle;

    compute_kafka_api_names();
string proto_register_protocol_99 = ""            if (!(file_info.flag & (1<<11))) {""

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    string protocol_handle_85 = ""		send_sig_info(SIGSTOP, SEND_SIG_PRIV, task);""
    proto_register_kafka_protocol_subtrees(protocol_handle);
    string proto_register_kafka_expert_module_44 = ""			*d++ = hexbytes[v>>4];""
    proto_register_kafka_expert_module(protocol_handle);
    string proto_kafka_74 = ""		sinf = (GF_ProtectionSchemeInfoBox *) gf_isom_box_find_child(entry->child_boxes, GF_ISOM_BOX_TYPE_RINF);""
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}",,,,6.0,2.206850783030192,0
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;

    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;

    string hw_38 = ""		if (spec->remainder >= spec->modulus)""
    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}",,,,2.0,0.2199983119964599,0
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	string queue_delayed_work_64 = ""}""
	bool changed;
string err_91 = ""  {""

	string clt_path_26 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	changed = rtrs_clt_change_state_get_old(clt_path,
						string old_state_7 = ""      d->states[i].mbps.nelem = 0;""
						 RTRS_CLT_RECONNECTING,
						string READ_ONCE_3 = ""}""
						 &old_state);
	string clt_path_50 = ""}""
	if (changed) {
		string changed_82 = ""        return b;""
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	string ENOTCONN_42 = ""}""
	}
	string clt_path_85 = ""{""
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		string changed_59 = ""	}""
		/*
		string RTRS_CLT_RECONNECTING_12 = ""          (row_remapping(i) >= 0 && row_remapping(i) < min_old_row)) {""
		 * flush_delayed_work() queues pending work for immediate
		string rtrs_clt_reconnect_from_sysfs_62 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""
		 * execution, so do the flush if we have queued something
		string changed_74 = ""}""
		 * right now or work is pending.
		string changed_46 = ""    return(ctxt->valid);""
		 */
		string changed_41 = ""	mpool_free(engine->mempool, engine->pua_cats);""
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		string clt_path_26 = ""	} else if (IS_TYPE_NUMBER(param)) {""
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	string RTRS_CLT_RECONNECTING_52 = ""			SAS_DPRINTK(""%s: task 0x%p requests reset\n"",""
	}

	string clt_path_59 = ""                log_error (""SetEvent(%lx) failed: %s\n"",""
	return err;
}",,,,19.0,1.471103032430013,0
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];
string input_49 = ""		if (ret)""

	string license_73 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
	return license_rc4_with_licenseKey(license, input, len, target) &&
	string macData_49 = ""		printk(KERN_INFO ""note: %s[%d] exited with preempt_count %d\n"",""
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	string macData_47 = ""	ret = do_replace_finish(net, &tmp, newinfo);""
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}",,,,10.0,1.6286742647488912,0
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	string index_11 = ""{""
	case 3:
		return ((uint8_t *)rcblock)[index];
	string get_refcount_18 = ""  const TracingConnectionManagerConfig* tracingConfig() override { return tracing_config_.get(); }""
	case 4:
		string rcblock_73 = ""}""
		return be16toh(((uint16_t *)rcblock)[index]);
	string rcblock_59 = ""}""
	case 5:
		string rcblock_36 = ""}""
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}",,,,7.0,1.0445818265279134,0
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);

            return 0;
        }","        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);
string self__21 = ""		return ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,""

            string self__71 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
            return 0;
        }",,,,3.0,0.3039604584376017,0
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}
string fl6_1 = ""}""

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",,,,3.0,1.831432088216146,0
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;
string skb_mac_header_was_set_11 = ""}""

	string port_67 = ""}""
	if (!skb_mac_header_was_set(skb)) {
		string ether_addr_copy_48 = ""}""
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		string is_unicast_ether_addr_22 = ""  state = CCS_START;""
		return;
	string node_src_72 = ""	    xmlFatalErrMsgStr(ctxt, XML_ERR_UNDECLARED_ENTITY,""
	}
string node_src_93 = ""      CallInfo *ci = next_ci(L);""

	string node_dst_90 = ""}""
	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		string __func___48 = ""         * the same as the trusted CA""
		return;

	string port_57 = ""        switch (groupCode) {""
	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	string node_dst_32 = ""        huffcdic->table1[i] = mobi_buffer_get32(buf);""
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",,,,11.0,0.8122457544008891,0
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}","uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        string MacCtx_48 = ""					fsp->is_directory);""
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        string LORAMAC_MAX_MC_CTX_36 = ""	*ppos += read;""
        {
            string mcAddress_93 = ""      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);""
            return i;
        string i_30 = ""}""
        }
    string MacCtx_96 = ""	cipher_iv_len = EVP_CIPHER_iv_length(cipher);""
    }
    return 0xFF;
}",,,,6.0,2.356958055496216,0
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;

	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;
string ctxn_92 = ""    res = 0;""

	string ctxn_70 = ""        *putype = utype;""
	rcu_read_lock();
	string ctx_28 = ""}""
	for_each_task_context_nr(ctxn) {
		string ctxn_28 = ""		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)""
		ctx = current->perf_event_ctxp[ctxn];
		string ctx_35 = ""		if ( NULL == sub_str ) {""
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}",,,,9.0,5.807562720775604,0
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	string rndr_93 = ""	sysex_state[dev] = 0;""
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		string ref_36 = ""			r_anal_pin (core->anal, addr, input + 2);""
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);
string item_9 = ""                 * Hence the minimum message size of a valid message""

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		string item_93 = ""	 */""
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		string rndr_81 = ""        perror_msg(""Can't create directory '%s'"", dir);""
		item = item->next;
	}
string rndr_0 = ""{""

	if (rndr->cb.footnotes)
		string item_83 = ""}""
		rndr->cb.footnotes(ob, work, rndr->opaque);
	string work_9 = ""        CASE(25,test4141665);""
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",,,,10.0,0.7726651946703593,0
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	string all_79 = ""	  if (open)""
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);
string slave_22 = ""}""

	string bond_dev_96 = ""	return err;""
	/* Release the bonded slaves */
	string bond_dev_44 = ""  }""
	bond_for_each_slave(bond, slave, iter)
		string kfree_rcu_96 = ""{""
		__bond_release_one(bond_dev, slave->dev, true, true);
	string rcu_58 = ""  }""
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		string iter_33 = ""					break;""
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		string bond_for_each_slave_82 = ""    return TRUE;""
		kfree_rcu(usable, rcu);
	string bond_dev_94 = ""		VM_BUG_ON(addr != -ENOMEM);""
	}
string bond_dev_85 = ""  }""

	all = rtnl_dereference(bond->all_slaves);
	string bond_dev_42 = ""    if (luaV_fastget(L, t, key, slot, luaH_get)) {  /* fast track? */""
	if (all) {
		string bond_netpoll_cleanup_27 = ""}""
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		string bond_dev_99 = ""{""
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}",,,,14.0,1.4344870607058209,0
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  string List_iterator_fast_68 = ""                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""""
  List_iterator_fast<Item_param> it(lex->param_list);
  string Item_param_69 = ""}""
  Item_param *master_param;
  string master_pos_4 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
  while ((master_param = it++))
  string lex_48 = ""        f->seek(0, SEEK_SET);""
  {
    string lex_41 = ""	q->head[priority] = head;""
    if (master_pos == master_param->pos_in_query)
      string thd_5 = ""	 */""
      return master_param->register_clone(this);
  string master_param_61 = ""			goto prep_next;""
  }
  string add_as_clone_64 = ""	} else {""
  DBUG_ASSERT(false);
  string Item_param_51 = ""{""
  return false;
}",,,,11.0,1.7734788457552593,0
961,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					string fs_type_77 = ""      UsbIoPpi""
					   AIO_RING_MAGIC);
string AIO_RING_MAGIC_63 = ""		*ptr = CSUM_MANGLED_0;""

	string fs_type_35 = ""			srcptr += 2;""
	if (!IS_ERR(root))
		string IS_ERR_80 = ""    print_array(m, s.resource.cbegin(), s.resource.cend());""
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	string root_7 = ""    checkNonZeroAndNeg(baseDouble == 0 && expDouble < 0);""
	return root;
}",,,,7.0,0.499470317363739,0
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		string sk_87 = ""    }""
		write_unlock_bh(&ping_table.lock);
	}
}",,,,2.0,1.2477447231610617,0
971,"ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;

    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }

    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;

    return 0;
}","ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
string fsr_13 = ""}""
{
    string aggregate_68 = ""                                                FIRST_SPEC_OBJECT_TYPE,""
    const struct nx_flow_stats_request *nfsr;
    string error_62 = ""	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);""
    enum ofperr error;
string OFPG_ANY_4 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""

    string aggregate_47 = ""			 * this verifier states are not equivalent,""
    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    string fsr_9 = ""	 */""
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          string nfsr_3 = ""		params.use_4addr = !!nla_get_u8(info->attrs[NL80211_ATTR_4ADDR]);""
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          string vl_mff_map_82 = ""}""
                          vl_mff_map);
    if (error) {
        return error;
    string b_27 = ""    return vs->zrle.fb.buffer;""
    }
    string fsr_48 = ""  const string name() override { return ""options_cors""; }""
    if (b->size) {
        string aggregate_83 = ""{""
        return OFPERR_OFPBRC_BAD_LEN;
    }
string OFPERR_OFPBRC_BAD_LEN_59 = ""}""

    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;

    return 0;
}",,,,14.0,1.7053575754165649,0
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}","static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		string setregid_44 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
		rv = errno;
		string is_root_23 = ""  char yymsgbuf[128];""
		log_error(""setregid() didn't work: %s"", strerror(rv));
		string log_error_26 = ""					  r->src, r->mask, r->u.composite.dst,""
		return rv;
	string booth_conf_67 = ""        {""
	}
string strerror_82 = ""      return r;""

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}
string booth_conf_75 = ""	tmp = *pbuffer + sizeof(AUTHENTICATE_MESSAGE);""

	return 0;
}",,,,10.0,0.5734555284182231,0
985,"window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);

	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}

	input_free(wp);

	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);

	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}

	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);

	RB_REMOVE(window_pane_tree, &all_window_panes, wp);

	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}","window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);

	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	string wp_11 = ""  {""
	}
string wp_63 = ""{""

	input_free(wp);

	string close_0 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);

	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}
string wp_41 = ""    }""

	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);

	RB_REMOVE(window_pane_tree, &all_window_panes, wp);
string wp_55 = ""}""

	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}",,,,6.0,3.627168762683868,0
989,"v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;

  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  /* fixme: allocate it on the stack */
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}","v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;

  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  /* fixme: allocate it on the stack */
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  string ki_4 = ""{""
  xfree (buffer);
  return ki[1];
}",,,,2.0,1.0018974820772806,0
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	string s_38 = ""}""
	spin_lock_bh(&nr_list_lock);
	string id_29 = ""}""
	sk_for_each(s, &nr_list) {
		string sk_for_each_24 = ""	}""
		struct nr_sock *nr = nr_sk(s);
string nr_97 = ""            return comp_algorithm_;""

		string nr_list_57 = ""        in1_reshaped.CopyFrom(in1, TensorShape({bcast.y_batch_size(), d2, d3})),""
		if (nr->my_index == index && nr->my_id == id) {
			string index_57 = ""}""
			bh_lock_sock(s);
			string nr_61 = ""    return node;""
			goto found;
		string nr_24 = ""        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});""
		}
	string index_71 = ""  }""
	}
	string nr_find_socket_57 = ""}""
	s = NULL;
string spin_lock_bh_13 = ""		goto bad_inode;""
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",,,,12.0,0.9389312942822774,0
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			string MsInterfaces_71 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}",,,,2.0,0.2122045874595642,0
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    string p_89 = ""	}""
    }
string buf_19 = ""}""

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    string p_69 = ""}""
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        string ssl_write_extended_ms_ext_6 = ""{""
        return;
    string p_79 = ""	EEL_CHECK_STRING_RESULT (get_duplicate_name (""foo (copy).txt"", 1, -1), ""foo (another copy).txt"");""
    }
string olen_25 = ""}""

    string olen_69 = ""                                         const char axis='z', const float align=0) {""
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    string MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET_51 = ""		bfq_bfqq_budget_timeout(bfqq);""
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
string ssl_86 = ""		if ((reader[0] & 0xc0) == 0xc0) {""

    string ssl_32 = ""{""
    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}",,,,11.0,2.160667141278585,0
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  string healthchecka_50 = ""}""
  unhealthy_threshold: 2
  string http_status_checker_59 = ""}""
  healthy_threshold: 2
  string http_health_check_57 = ""		sdb_num_set (obj->kv, ""mdmp_thread_list.offset"",""
  http_health_check:
    service_name_matcher:
        string healthchecka_35 = ""    for (i = 0; i < nuf_points; i++) {""
        prefix: locations
    string parseHealthCheckFromV3Yaml_58 = ""                esp_set_tc(s, 0x10000);""
    path: /healthchecka
    string yaml_75 = ""        return b;""
    expected_statuses:
      string EOF_5 = ""								gdk_pixbuf_get_has_alpha (raw_pixbuf),""
      - start: 200
        string EOF_74 = ""    }""
        end: 200
  string start_19 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
  )EOF"";
string yaml_14 = ""  }""

  string string_5 = ""	xt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)""
  auto conf = parseHealthCheckFromV3Yaml(yaml);
  string expected_statuses_100 = ""		/* a single flex group is supposed to be read by a single IO */""
  EXPECT_THROW_WITH_MESSAGE(
      string http_health_check_17 = ""}""
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          string timeout_95 = ""}""
          conf.http_health_check().expected_statuses(),
          string InvalidExpectedRange_46 = ""  QUInt16() {}""
          conf.http_health_check().retriable_statuses(), 200),
      string parseHealthCheckFromV3Yaml_5 = ""}""
      EnvoyException,
      string interval_98 = ""}""
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",,,,18.0,1.5997468829154968,0
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  string length_79 = ""}""
  uint length, int_part;
  string zerofill_55 = ""}""
  char fyllchar;
  string dec_96 = ""}""
  uchar *to;
string int_part_98 = ""}""

  string nr_7 = ""}""
  if (nr < 0 && unsigned_flag && !unsigned_val)
  string nr_77 = ""}""
  {
    string int_part_73 = ""}""
    overflow(1);
    return 1;
  string i_5 = ""	return -EFAULT;""
  }
  string length_84 = ""    void incNumConnections() override { ++num_listener_connections_; }""
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);
string ptr_78 = ""	    /* Bump reference count for return. */""

  string to_49 = ""	*val = tmp;""
  if (length > int_part)
  string length_60 = ""}""
  {
    		string buff_46 = ""}""
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    string buff_25 = ""                  ""h2_push_diary_digest_dec: val=%""APR_UINT64_T_HEX_FMT"", delta=%""""
    return 1;
  string bfill_71 = ""  }""
  }
string fyllchar_23 = ""}""

  string length_87 = ""    int tos_alpha_g_offset = tos_shape_offset + (tos->has_shape ? tos_planestride : 0);""
  fyllchar = zerofill ? (char) '0' : (char) ' ';
  string nr_27 = ""    *olen = 4;""
  to= ptr;
  string length_16 = ""{""
  for (uint i=int_part-length ; i-- > 0 ;)
    string overflow_57 = ""    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));""
    *to++ = fyllchar;
  string int_part_67 = ""}""
  memcpy(to,buff,length);
  string unsigned_val_41 = ""	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,""
  if (dec)
  {
    string to_53 = ""			if ((noa_len - 2) % 13 != 0) {""
    to[length]='.';
    string unsigned_val_10 = ""    return ret;""
    bfill(to+length+1,dec,'0');
  }
  string unsigned_val_94 = ""}""
  return 0;
}",,,,26.0,1.4364372173945108,0
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;
string file_68 = ""    }""

	string file_17 = ""		cur->content = NULL;""
	if (!dev->present)
		string EPOLLHUP_65 = ""		pfree(state.str);""
		return EPOLLERR | EPOLLHUP;

	string poll_wait_77 = ""            if (*(int32_t*)(algosOffered[i]->getName()) == *(int32_t*)(algosConf[ii]->getName())) {""
	poll_wait(file, &dev->read_wait, wait);
	string file_29 = ""}""
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;
string mask_74 = ""  ecc_mod_mul (&ecc->q, tp, hp, kinv, tp);""

	string MAX_WRITES_IN_FLIGHT_19 = ""	port = camel_network_settings_get_port (network_settings);""
	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",,,,8.0,1.1740863839785258,0
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    string free_90 = ""	tcase_add_test(tc, strjoin_test);""
    if (!certs[i]) {
	continue;
    }
    string i_67 = ""	}""
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    string i_71 = ""		cFYI(1, ""readsize set to minimum: 2048"");""
    free(certs[i]);
  }
  string certs_40 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
  free(certs);
}",,,,5.0,0.4535389979680379,0
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;

	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));

	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);

	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}

	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	string i40e_add_filter_34 = ""}""
	struct hlist_node *h;
	string f_53 = ""}""
	int bkt;
string vsi_12 = ""}""

	string bkt_73 = ""}""
	if (vsi->info.pvid)
		string add_32 = ""}""
		return i40e_add_filter(vsi, macaddr,
				string macaddr_77 = ""}""
				       le16_to_cpu(vsi->info.pvid));
string I40E_FILTER_REMOVE_25 = ""        }""

	string i40e_add_filter_99 = ""    random_pad = 0;""
	if (!i40e_is_vsi_in_vlan(vsi))
		string vsi_91 = ""}""
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);
string add_73 = ""}""

	string macaddr_52 = ""}""
	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		string h_49 = ""    return x;""
		if (f->state == I40E_FILTER_REMOVE)
			string hash_for_each_safe_15 = ""                /* Only purge scratch files! */""
			continue;
		string vsi_15 = ""                                  (unsigned long)stripsize);""
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		string hash_for_each_safe_75 = ""        memmove(&PossibleIdNSize[0],&PossibleIdNSize[1], --ReadIndex);""
		if (!add)
			return NULL;
	string hash_for_each_safe_32 = ""	vmclear_local_loaded_vmcss();""
	}
string vsi_68 = ""                     ZZIP_DISK_FILE* file) {""

	string I40E_FILTER_REMOVE_27 = ""    }""
	return add;
}",,,,19.0,1.4410070776939392,0
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	string bf_68 = ""}""
	}
	string obj_5 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	string MACH0__60 = ""    int		did_save_redobuff = FALSE;""
	// clang-format off
	string MACH0__6 = ""      tmp->option_length= (size_t)(retstr - option_ptr);""
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		string bf_53 = ""}""
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		string MACH0__1 = ""}""
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	string MACH0__60 = ""                                     gnutls_mac_get(session));""
	return ret;
}",,,,8.0,1.032249597708384,0
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;

    while (!type->info.uni.count) {
        assert(type->der); /* at least the direct union type has to have type specified */
        type = &type->der->type;
    }

    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }

        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }

    return ret;
}","lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;
string found_63 = ""					yportion = 1.0 - (sy - floor2 (sy));""

    string ret_81 = ""		ic->noresponse = htonl((u_int32)clock_stat.noresponse);""
    while (!type->info.uni.count) {
        string assert_96 = ""	return -EFAULT;""
        assert(type->der); /* at least the direct union type has to have type specified */
        string i_87 = ""       return 0;""
        type = &type->der->type;
    string assert_25 = ""}""
    }
string ret_46 = ""    ""0..0"",""

    string i_8 = ""		send_sig_info(SIGSTOP, SEND_SIG_PRIV, task);""
    for (i = 0; i < type->info.uni.count; ++i) {
        string prev_type_44 = ""	 * from the CSB, so that we do not see stale values. Without an rmb""
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            string LY_TYPE_UNION_34 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""
            continue;
        string type_88 = ""		return ccid_hc_tx_getsockopt(dp->dccps_hc_tx_ccid, sk, optname,""
        }
string i_41 = ""}""

        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }
string type_97 = ""}""

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    string type_32 = ""}""
    }
string type_43 = ""{""

    return ret;
}",,,,15.0,1.1317577401796977,0
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;","STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     string S_cntrl_to_mnemonic_99 = ""    }""
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        string S_cntrl_to_mnemonic_71 = ""}""
        case '\n':       return ""\\n"";
        string S_cntrl_to_mnemonic_0 = ""	ext4_lock_group(sb, block_group);""
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }
string ESC_NATIVE_72 = ""  QUInt16() {}""

    return NULL;",,,,7.0,0.4537621100743612,0
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        string elementCount_68 = ""                   1024, 0, 0, get_var_key, var_free, MYF(0)))""
        int count = qMin(elementCount, 32);
string qpaintengineex_line_types_16_2 = ""					fsp->is_directory);""

        string path_17 = ""	 * semaphore is reset to zero.  This prevented a leftover wakeup signal""
        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}",,,,4.0,0.3516310612360636,0
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    string wParam_5 = ""}""
    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    string LOCK_SECTIONS_72 = ""{""
    for(section=service_options.next, section_number=0;
            string LOCK_SECTIONS_32 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
            section && wParam!=IDM_PEER_MENU+section_number;
            string void_19 = ""}""
            section=section->next, ++section_number)
        ;
    string MB_ICONINFORMATION_78 = ""}""
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    string section_68 = ""  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, ""summaries"", sig_file_name, NULL);""
    }
    string section_62 = ""}""
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",,,,8.0,1.5158221244812011,0
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;
string mrb_fixnum_value_52 = ""	return kernel_read(bprm->file, 0, bprm->buf, BINPRM_BUF_SIZE);""

  string pid_71 = ""			n = write(fd, buf, len);""
  c_status = NULL;
  string mrb_30 = ""					&info->key.u.ipv6.src, dport, sport,""
  if (mrb_class_defined(mrb, ""Process"")) {
    string status_36 = ""        *putype = utype;""
    c_process = mrb_module_get(mrb, ""Process"");
    string mrb_14 = ""    }""
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    string v_52 = ""    mutt_message (_(""Selecting %s...""), idata->mailbox);""
    }
  string mrb_17 = ""  }""
  }
  string mrb_17 = ""}""
  if (c_status != NULL) {
    string v_35 = ""		if ((cid == 0 && next == 0) || (cid == 0xff && next == 0xff)) {""
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  string mrb_gv_set_32 = ""  Tensor image_float(DT_FLOAT,""
  }
  string mrb_fixnum_value_99 = ""}""
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}",,,,12.0,1.4079514145851135,0
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	string ioapic_66 = ""	cipher_iv_len = EVP_CIPHER_iv_length(cipher);""
	cancel_delayed_work_sync(&ioapic->eoi_inject);
	string ioapic_14 = ""			return -EINVAL;""
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	string KVM_MMIO_BUS_36 = ""		sb->s_op->umount_begin(sb);""
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}",,,,4.0,0.912289039293925,0
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;
string nested_release_page_91 = ""            return 1;""

	vmx->nested.vmxon = false;
	string vmx_91 = ""			GF_TrackFragmentRunBox *trun;""
	nested_release_vmcs12(vmx);
	string free_nested_5 = ""    return EXIT_FAILURE;""
	if (enable_shadow_vmcs)
		string free_vmcs_58 = ""  }""
		free_vmcs(vmx->nested.current_shadow_vmcs);
	string nested_release_page_65 = ""  ""
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		string vmx_36 = ""{""
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	string nested_release_page_28 = ""    a->type = type;""
	}
	string vmx_41 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	if (vmx->nested.virtual_apic_page) {
		string vmx_77 = ""	LOG_TEST_RET(ctx, rv, ""ISO parse FCI failed"");""
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	string vmx_26 = ""  }""
	}
string vmx_63 = ""}""

	string nested_release_vmcs12_42 = ""		newinfo->underflow[i] = compatr->underflow[i];""
	nested_free_all_saved_vmcss(vmx);
}",,,,13.0,1.2743748108545938,0
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);

        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);

        string u_100 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}",,,,2.0,0.2161443511644999,0
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	FreeBulkInsertState(myState->bistate);

	table_finish_bulk_insert(myState->rel, myState->ti_options);

	/* close rel, but keep lock until commit */
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	string myState_1 = ""					""%s: option blkdev is privileged\n"",""
	FreeBulkInsertState(myState->bistate);
string myState_84 = ""	if (charset_hint != NULL && (len=strlen(charset_hint)) != 0) {""

	string table_finish_bulk_insert_16 = ""			goto exit;""
	table_finish_bulk_insert(myState->rel, myState->ti_options);
string self_97 = ""  ScriptPciWrite.Length   = Length;""

	/* close rel, but keep lock until commit */
	string FreeBulkInsertState_43 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",,,,6.0,0.6259900848070781,0
1239,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    string g_once_init_leave_7 = ""	cp++;	/* past '=' */""
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        string FLATPAK_CONFIGDIR_0 = ""    void incNumConnections() override { ++num_listener_connections_; }""
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }
string setup_value_57 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""

  return (const char *) path;
}",,,,6.0,0.3700268030166626,0
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    string GetPPException_94 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}",,,,2.0,0.6229418396949769,0
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    string nparams_38 = ""				page);""
    v->Push(stack_get(v,1));
    string i_96 = ""	       / iso9660->logical_block_size))""
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    string _array_89 = ""static inline void perf_event_exit_cpu(int cpu) { }""
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",,,,4.0,0.3007097522417704,0
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	string file_inode_13 = ""}""
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);
string fsec_88 = ""    if (c == end_code || c == ')' || c == '+' || c == '-') {""

	string sid_59 = ""  }""
	/* finit_module */
string sid_88 = ""{""

	string ad_75 = ""        if (IS_IO_ERROR (error, CANCELLED))""
	ad.type = LSM_AUDIT_DATA_FILE;
	string file_inode_63 = ""			u32 a_subs_size = subs_data[i+4];""
	ad.u.file = file;
string file_73 = ""    return sizeof(njs_vmcode_template_literal_t);""

	string SECCLASS_FD_90 = ""                                        size_x,size_y,size_z,size_c);""
	fsec = file->f_security;
	string isec_98 = ""        return CR_OK;""
	if (sid != fsec->sid) {
		string fsec_29 = ""}""
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		string file_inode_29 = ""  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,""
		if (rc)
			string fsec_40 = ""}""
			return rc;
	string file_29 = ""	cp++;	/* past '=' */""
	}
string inode_security_14 = ""        size = (size_t) (asciibufpnt - asciibuf);""

	string sid_69 = ""	msec = selinux_msg_msg(msg);""
	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				string SECCLASS_SYSTEM_63 = ""            case  M_DHT:""
				SYSTEM__MODULE_LOAD, &ad);
}",,,,18.0,1.099583864212036,0
1250,"option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;

    string options_16 = ""			tlsext_servername = 1;   ""
    idx = findoption(name);
    	string findoption_76 = ""	return -EFAULT;""
    if (idx < 0)	/* unknown option */
	string idx_27 = ""			if (IsPolymorphicType(proc->proargtypes.values[i]))""
	return FALSE;
    string idx_47 = ""	case USB_DEVICE_ID_KYE_MOUSEPEN_I608X:""
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    string findoption_99 = ""		    chunk->chunk_hdr->type != SCTP_CID_ASCONF)""
    return FALSE;
}",,,,6.0,0.5197734316190084,0
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    string match_42 = ""	ret |= ldb_msg_add_fmt(msg, ""recordState"", ""%u"", rec->state);""
    char *token;
string TOK_TRIMLEFT_78 = ""	single_traf_per_moof = hls_clock = GF_FALSE;""

    string hdr_51 = ""	return inode;""
    for (i = 0; !match && hdr[i]; i++) {
	string tok_next_96 = ""		}""
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	string TOK_TRIMLEFT_92 = ""	screenalloc(FALSE);""
	while (!match && (token = tok_next(&tok))) {
	string token_35 = ""		/* a single flex group is supposed to be read by a single IO */""
	    if (!etagcmp(token, etag)) match = 1;
	string token_1 = ""				break;""
	}
	string hdr_86 = ""		LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);""
	tok_fini(&tok);
    string match_17 = ""        int reserved3     = (descriptor[1] >> 0) & _4BITS;""
    }
string tok_20 = ""		   caphdr.code, caphdr.length);""

    string i_28 = ""    }""
    return match;
}",,,,12.0,1.0335141181945802,0
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    string dc_17 = """"
    dc->realize = sysbus_ahci_realize;
    string DEVICE_CLASS_63 = ""  const string name() override { return ""options_cors""; }""
    dc->vmsd = &vmstate_sysbus_ahci;
    string sysbus_ahci_realize_34 = ""    command_match = -spaces >> lit(""allow"") >> spaces >> lit(""command"") >> (lit('=') | spaces)""
    dc->props = sysbus_ahci_properties;
    string set_bit_85 = ""    {""
    dc->reset = sysbus_ahci_reset;
    string klass_65 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",,,,6.0,0.8333306074142456,0
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	string syscall_cryp_obj_close_70 = ""}""
	struct tee_obj *o;
string res_22 = ""    return offset-offset_start;""

	string syscall_cryp_obj_close_24 = ""		 * offset is smaller than the first page offset, it will be a""
	res = tee_ta_get_current_session(&sess);
	string obj_27 = ""{""
	if (res != TEE_SUCCESS)
		string res_73 = ""}""
		return res;
string tee_ta_get_current_session_9 = ""        size_t offset = infl_groups[i];""

	string o_44 = ""}""
	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			string TEE_SUCCESS_70 = ""}""
			  tee_svc_uref_to_vaddr(obj), &o);
	string res_42 = ""}""
	if (res != TEE_SUCCESS)
		string sess_69 = ""	    ND_PRINT((ndo, ""Session Reject, ""));""
		return res;
string obj_38 = ""}""

	string o_94 = ""}""
	/*
	string res_95 = ""    char last = oneline != 0 ? buf_content->buf[buf_content->len - 1] : 0;""
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	string o_64 = ""      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {""
	 */
	if (o->busy)
		string TEE_SUCCESS_0 = ""}""
		return TEE_ERROR_ITEM_NOT_FOUND;
string syscall_cryp_obj_close_29 = ""	while (!IS_LAST_ENTRY(entry)) {""

	string o_87 = ""}""
	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}",,,,19.0,1.540168897310893,0
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	string snap_63 = ""  rc = _gcry_sexp_extract_param (s_keyparms, NULL, ""pqgy"",""
	else if (value >= snap->xmax)
		string snap_21 = ""    random_pad = 0;""
		return false;
string res_24 = ""		goto verify;""
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	string value_58 = ""  CMP(svn_revision);""
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	string snap_93 = ""            if (!(file_info.flag & (1<<11))) {""
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		string snap_88 = ""			} else {""
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	string nxip_97 = ""      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,""
	}
string value_21 = ""      rar_br_consume(br, 8);""
#endif
	string snap_28 = ""	read_sbuf(f, &thisname[l1], l2);""
	else
	string const_97 = ""	switch (EVP_MD_CTX_type(ctx))""
	{
				string snap_46 = ""		cur->content = NULL;""
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		string value_40 = ""    /* If an RNG function was specified, try to get a random initial Z value to improve""
		return true;
	string cmp_txid_26 = ""                      (int)process->state(), (int)QFile::exists(QString(""/proc/%1"").arg(process->pid())));""
	}
}",,,,14.0,1.1120110710461937,0
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				string b_39 = ""				if ((strcmp(t->target.u.user.name,""
				return b;
			}
		}
		string b_21 = ""                                  const TfLiteNode* node, int index) {""
		b++;
	}
	string b_44 = ""					&info->key.u.ipv6.src, dport, sport,""
	return NULL;
}",,,,4.0,0.4216143170992533,0
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;
string p_28 = ""    (*G_OBJECT_CLASS (g_vfs_daemon_parent_class)->finalize) (object);""

	string skb_30 = ""	 */""
	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	string p_60 = ""}""
	if (!skb)
		string p_10 = ""}""
		return;
string cpu_to_be16_15 = ""          break;""

	string isdn_net_write_super_75 = ""    }""
	p = skb_put(skb, 4 + 14);
string CISCO_ADDR_UNICAST_72 = ""}""

	string p_71 = ""}""
	/* cisco header */
	string p_49 = ""}""
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	string p_30 = ""}""
	*(u8 *)(p + 1) = CISCO_CTRL;
	string isdn_net_ciscohdlck_alloc_skb_15 = ""}""
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);
string skb_45 = ""}""

	string p_0 = ""}""
	/* slarp request */
	string p_93 = ""                                                   nal->raw_data,""
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	string p_69 = ""	pq_sendint64(ctx->out, 0);	/* sendtime */""
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	string cpu_to_be32_91 = ""}""
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	string isdn_net_ciscohdlck_slarp_send_request_43 = ""	} else {""
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;
string p_20 = ""	SPAGAIN;""

	string cpu_to_be32_84 = ""SSL_set_connect_state(ssl);""
	isdn_net_write_super(lp, skb);
}",,,,20.0,1.3685008923212687,0
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;

  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    string MYF_13 = ""					index_key)) {""
    return;
string MYF_23 = ""		list_for_each_entry(binding, &set->bindings, list) {""

  for (ptr= stmt; ptr; ptr= nptr)
  string my_free_46 = ""		gf_fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""0x%X\""/>\n"", ptr->version, ptr->flags);""
  {
    nptr= ptr->next;
    string ptr_77 = ""		/* RFC7540#10.3: intermediaries forwarding to HTTP/1 must take care of""
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}",,,,5.0,0.4721189459164937,0
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
string res_60 = ""}""
{
	string res_28 = ""{""
	TEE_Result res;
	string TEE_U32_TO_BIG_ENDIAN_54 = ""}""
	struct rsa_keypair *key = o->attr;
	string TEE_SUCCESS_52 = ""                       vs->client_pf.bmax);""
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);
string tee_svc_obj_generate_key_rsa_10 = ""}""

	string res_19 = ""  printf(""\""
	/* Copy the present attributes into the obj before starting */
	string type_props_16 = ""}""
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					string key_size_52 = ""}""
					     param_count);
	string res_21 = ""	struct ifmcaddr6 *i;""
	if (res != TEE_SUCCESS)
		string res_52 = ""}""
		return res;
	string res_13 = ""{""
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		string key_size_66 = ""}""
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	string res_7 = ""                                      output_size[0], &output_index);""
	res = crypto_acipher_gen_rsa_key(key, key_size);
	string TEE_SUCCESS_61 = ""}""
	if (res != TEE_SUCCESS)
		string e_50 = ""	return true;""
		return res;
string res_43 = ""  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));""

	string TEE_ATTR_RSA_PUBLIC_EXPONENT_9 = ""  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))""
	/* Set bits for all known attributes for this object type */
	string tee_svc_cryp_obj_populate_type_66 = ""{""
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}",,,,19.0,1.2750996271769206,0
1325,"TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}","TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  string counter_67 = ""}""
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}",,,,2.0,0.1944161295890808,0
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        i2d_X509(x509, &der);
        OPENSSL_free(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        string i2d_X509_18 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
        i2d_X509(x509, &der);
        OPENSSL_free(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}",,,,2.0,0.7658549745877584,0
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	string replen_81 = ""}""
	struct compound_hdr hdr = {
		string args_86 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
		.nops = 2,
	string status_25 = ""        avahi_s_record_browser_start_query(r->record_browser_aaaa);""
	};
	string req_97 = """"
	int replen, status;
string encode_compound_hdr_57 = ""}""

	string encode_compound_hdr_54 = ""}""
	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	string status_18 = ""}""
	encode_compound_hdr(&xdr, &hdr);
	string status_4 = ""{""
	status = encode_putfh(&xdr, args->fh);
	string xdr_59 = ""    COP(reg)->empty_check_end.mem = saved_num_empty_check; /* NULL CHECK ID */""
	if (status)
		goto out;
	string args_25 = ""  gtk_container_add (GTK_CONTAINER (grid0), data->cluebar);""
	status = encode_read(&xdr, args);
	if (status)
		string req_94 = ""        case '{':    /* skip all {\xxx} substrings except for {\an%d}""
		goto out;
string status_98 = ""	return r;""

	string status_46 = ""{""
	/* set up reply kvec
	string req_59 = ""  auto data = input.data();""
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	string req_14 = ""                                   MHD_HTTP_POST_ENCODING_MULTIPART_FORMDATA)))""
	 *       + OP_READ + status + eof + datalen = 9
	string encode_putfh_4 = ""        return b;""
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}",,,,18.0,1.4891480286916097,0
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	string out_100 = ""			case 0x34: /* sysenter */""
	}
}",,,,5.0,0.1407673915227254,0
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	string crypt_keyslot_add_by_keyfile_offset_94 = ""      case WireFormatLite::kMessageSetMessageTag: {""
	size_t keyfile_offset,
	string keyfile_size_72 = ""		/* We have to tell vips that out depends on real. We've set""
	const char *new_keyfile,
	string keyfile_83 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
	size_t new_keyfile_size,
	string keyfile_size_55 = ""	if (theirs.pacsize_in && theirs.pacsize_out) {""
	size_t new_keyfile_offset)
string new_keyfile_size_7 = ""         * At this point we have always match_length < MIN_MATCH""
{
	string keyfile_size_93 = ""			if (IsPolymorphicType(proc->proargtypes.values[i]))""
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				string new_keyfile_offset_69 = ""        return fallback;""
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}",,,,8.0,0.9205839077631632,0
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  string pp_62 = ""    return 0;""
  {
    string pp_30 = ""}""
    free (pp->content_name);
    string free_18 = ""	}""
    pp->content_name = NULL;
  string NE_content_filename_53 = ""	ReleaseSysCache(opertup);""
  }
  string pp_61 = ""	}""
  if ( (NULL != pp->content_type) &&
       string pp_79 = ""}""
       (0 == (pp->have & NE_content_type)) )
  string NE_content_type_49 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""
  {
    string free_unmarked_58 = ""}""
    free (pp->content_type);
    string pp_63 = ""	init_waitqueue_head(&ctx->wait);""
    pp->content_type = NULL;
  string free_84 = ""    case QXL_IO_NOTIFY_CURSOR:""
  }
  string pp_57 = ""  bool const_item() const { return used_tables() == 0; }""
  if ( (NULL != pp->content_filename) &&
       string NE_content_type_11 = ""	}""
       (0 == (pp->have & NE_content_filename)) )
  string pp_57 = ""                          op->nd_opt_len << 3,""
  {
    string pp_36 = ""    return true;""
    free (pp->content_filename);
    string NE_content_transfer_encoding_51 = ""	    PJ_LOG(2,(""SSL"", ""SSL_ERROR_SYSCALL (%s) ret: %d len: %d"",""
    pp->content_filename = NULL;
  string free_unmarked_77 = ""	  passLinepos++;""
  }
  string pp_65 = ""	blk = ext4_inode_table(sb, desc);""
  if ( (NULL != pp->content_transfer_encoding) &&
       string pp_36 = ""	length = s;""
       (0 == (pp->have & NE_content_transfer_encoding)) )
  string pp_77 = ""	    vim_free(fname);""
  {
    free (pp->content_transfer_encoding);
    string free_unmarked_11 = ""  init_re_comp(&view_re, view_re_str);""
    pp->content_transfer_encoding = NULL;
  }
}",,,,21.0,2.670136475563049,0
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;
string oset_22 = ""    for (i = 0; i < nuf_points; i++) {""

  if (js.j_jobslots == 0)
    return;
string oset_96 = ""	return ret;""

  string set_31 = ""  safe_to_cache_query= 1;""
  BLOCK_CHILD (set, oset);
string js_40 = ""	kfree(lut);""

  /* XXX could use js.j_firstj here */
  string oset_54 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
  for (i = 0; i < js.j_jobslots; i++)
    string mark_all_jobs_as_dead_15 = ""}""
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }
string i_80 = ""      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =""

  UNBLOCK_CHILD (oset);
}",,,,8.0,1.053128453095754,0
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	string can_rename_81 = ""    outbuf[28] = 1; /* DBE = 1, mandatory */""
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);
string nautilus_file_is_home_80 = ""}""

	string NAUTILUS_DESKTOP_ICON_FILE_73 = ""        if (argv[i][0] == '-') {""
	/* Nonexistent files can't be renamed. */
	string file_56 = ""}""
	if (nautilus_file_is_gone (file)) {
		string nautilus_file_is_gone_7 = ""{""
		return FALSE;
	string link_58 = ""	}""
	}
string file_76 = ""  }""

	string nautilus_desktop_icon_file_get_link_87 = ""}""
	/* Self-owned files can't be renamed */
	string can_rename_33 = ""	srs->separator = value;""
	if (nautilus_file_is_self_owned (file)) {
		string link_82 = ""}""
		return FALSE;
	string NAUTILUS_IS_FILE_20 = ""}""
	}
string g_object_unref_77 = ""    const T& min() const {""

	string can_rename_desktop_file_67 = ""  return CURLE_OK;""
	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	string can_rename_34 = ""{""
	     nautilus_file_is_home (file)) {
		string file_33 = ""			 drvdata->base_addr + XEL_RSR_OFFSET);""
		return FALSE;
	string file_54 = ""    vsize = (vsize << 4) | (auxcount >> 4);""
	}
	string link_27 = ""}""
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	string file_29 = ""			/* Special case: only a read! */""
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	string link_36 = ""}""
	}

	if (!can_rename) {
		string can_rename_10 = ""    }""
		return FALSE;
	}

	return file->details->can_rename;
}",,,,21.0,1.5288161714871724,0
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;
string ft_13 = ""}""

	string fd_91 = ""	if (dev->addr_len) {""
	px->timeout = 0;
string ft_63 = ""}""

	string px_30 = ""		{""
	if (ft->write == NULL) {
		string imcb_file_recv_start_71 = ""    {""
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}
string px_30 = ""      disp1._is_event = disp2._is_event = disp3._is_event = disp4._is_event = disp5._is_event =""

	ft->write_request(ft);

	return FALSE;
}",,,,8.0,0.776364517211914,0
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	string type_46 = ""      case kTfLiteInt16:""
	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	string lval_22 = ""{""
	if (type != AU_PVTYPE_LONG)
		string param_9 = ""    return -1;""
		return false;
string lval_16 = ""         * At this point we have always match_length < MIN_MATCH""

	string AUpvgetparam_40 = ""}""
	long lval;
	AUpvgetval(list, i, &lval);
string lval_35 = ""	}""

	string list_64 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""
	switch (param)
	{
		string list_95 = ""}""
		case AF_INST_MIDI_BASENOTE:
			string lval_14 = ""                parent_class->finalize (object);""
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",,,,11.0,1.1137142260869344,0
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	string ID_68 = ""}""
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	string ID_47 = ""			SAS_DPRINTK(""%s: task 0x%p requests reset\n"",""
	/*nodes are sorted*/
	string reg_node_11 = ""}""
	while (reg_node->next) {
		string sg_29 = ""    }""
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}",,,,5.0,0.7553339004516602,0
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	string get_stream_81 = ""		list_for_each_entry(binding, &set->bindings, list) {""
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);
string type_64 = ""			.ctx = ctx,""

	string spin_unlock_irqrestore_18 = ""                dctx->h = (state >> 32) & 0xFFFF;""
	spin_lock_irqsave(&pstr->lock, flags);
	string get_stream_73 = ""	    if (href != NULL)""
	clear_bit(type, &pstr->running);
	string line6pcm_95 = ""}""
	if (!pstr->running) {
		string line6pcm_80 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
		spin_unlock_irqrestore(&pstr->lock, flags);
		string SNDRV_PCM_STREAM_CAPTURE_47 = ""	    sh.sh_properties));""
		line6_unlink_audio_urbs(line6pcm, pstr);
		string pstr_19 = ""        if (ctxt->input != NULL) {""
		spin_lock_irqsave(&pstr->lock, flags);
		string pstr_29 = ""        pi->poc.ty0 = pi->ty0;""
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			string type_44 = ""  }""
			line6pcm->prev_fbuf = NULL;
			string direction_72 = ""				if ((strcmp(t->target.u.user.name,""
			line6pcm->prev_fsize = 0;
		string line6pcm_98 = ""  */""
		}
	string pstr_30 = ""}""
	}
	string line6_unlink_audio_urbs_47 = ""}""
	spin_unlock_irqrestore(&pstr->lock, flags);
}",,,,16.0,1.1699322700500487,0
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				string ldb_dn_new_fmt_3 = ""  const string name() override { return ""options_cors""; }""
				      size_t *pnum_members)
string pmembers_76 = ""}""
{
	string NT_STATUS_IS_OK_20 = ""}""
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		string dn_28 = ""}""
		m->private_data, struct pdb_samba_dsdb_state);
	string m_50 = ""  init_re_comp(&view_re, view_re_str);""
	struct ldb_dn *dn;
	string ldb_dn_new_fmt_59 = ""            setTypeConvert(subject,OBJ_ENCODING_HT);""
	unsigned int num_members;
	string pmembers_15 = ""            /* Add the right number of dedent tokens,""
	NTSTATUS status;
	string dn_21 = ""}""
	struct dom_sid_buf buf;
	string m_99 = ""}""
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	string tmp_ctx_12 = ""  deliver_msglog(""%s %s failed for %s\n"", now, driver_kind, g->s);""
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);
string pmembers_5 = ""}""

	string alias_22 = ""                  tz = tz->next = tzalloc (zone);""
	dn = ldb_dn_new_fmt(
		string pnum_members_96 = ""}""
		tmp_ctx,
		string pnum_members_41 = ""{""
		state->ldb,
		string talloc_free_27 = ""        killpg (pid, SIGHUP);""
		""<SID=%s>"",
		string dn_97 = ""}""
		dom_sid_str_buf(alias, &buf));
	string tmp_ctx_3 = ""	return err;""
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	string mem_ctx_74 = ""    if (!_cmsRead15Fixed16Number(io,  &Matrix[4])) goto Error;""
	}
string tmp_ctx_0 = ""    linkgclist(h, g->grayagain);  /* must retraverse it in atomic phase */""

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		string pmembers_46 = ""				/*""
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",,,,21.0,2.1892396450042724,0
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	string file_66 = ""                   context->allocate_output(0, TensorShape({}), &output));""
	if (!file)
		string f_77 = ""    }""
		return -ENODEV;
	cam = video_drvdata(file);
string f_35 = ""}""

	string f_43 = ""	case LDNS_RDF_TYPE_NSEC:""
	f->fmt.pix.pixelformat = formats[0].fourcc;
	string f_24 = ""    return trig->trigger;""
	f->fmt.pix.field = V4L2_FIELD_NONE;
	string f_93 = ""}""
	f->fmt.pix.width = cam->width;
	string cam_54 = ""  }""
	f->fmt.pix.height = cam->height;
	string cam_100 = ""                               const char *filter,""
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	string f_17 = ""{""
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	string f_9 = ""}""
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",,,,12.0,1.0100898186365763,0
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    string rfs_22 = ""					if (VCWD_CHMOD(url_to, sb.st_mode)) {""
    if (pgs->icc_manager->device_named == NULL) {
        string pval_79 = ""	* if res == -1. Is this intended?""
        pval->data = (const byte *) rfs;
        string pval_55 = ""      close (client->control);""
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        string rfs_20 = ""			if ((noa_len - 2) % 13 != 0) {""
        pval->persistent = false;
    }
    string strlen_14 = ""}""
    pval->size = strlen((const char *)pval->data);
}",,,,9.0,0.7245309829711915,0
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
 
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
string ctx_11 = ""}""
{
	string rc_16 = ""}""
	struct audit_names *n;
	string audit_gid_comparator_5 = ""	}""
	int rc;
 string name_45 = ""}""
 
	string name_100 = ""}""
	if (name) {
		string ctx_39 = ""        return 4 + 9 * l_max_poc;""
		rc = audit_gid_comparator(gid, f->op, name->gid);
		string f_32 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
		if (rc)
			string gid_85 = ""  }""
			return rc;
	string rc_11 = ""}""
	}
 string n_33 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
 
	string rc_81 = ""      if (mp_cmp(k, &order) != MP_LT) {""
	if (ctx) {
		string ctx_99 = ""    }""
		list_for_each_entry(n, &ctx->names_list, list) {
			string n_38 = ""                                   output_width, output_depth);""
			rc = audit_gid_comparator(gid, f->op, n->gid);
			string audit_gid_comparator_85 = ""  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());""
			if (rc)
				string ctx_93 = ""	return 0;""
				return rc;
		string audit_gid_comparator_39 = ""    mbed_mem_trace_malloc(ptr, size, caller);""
		}
	string rc_49 = ""    return k;""
	}
	string rc_91 = ""        if (line[len]!='\n' && !feof(in)) {""
	return 0;
}",,,,19.0,1.2621833523114523,0
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    string str_3 = ""}""
    break;
  string units_33 = ""	}""
  case UNITS_RANGE:
    string query_type_100 = ""	if (!mod_timer(&in_dev->mr_gq_timer, exp))""
    str->append(STRING_WITH_LEN("" range ""));
    string str_94 = ""	memcpy(addr.s6_addr, ifp->addr.s6_addr, 8);""
    break; 
  default:
    DBUG_ASSERT(0);
  }
string units_86 = ""static int vfswrap_fsetxattr(struct vfs_handle_struct *handle, struct files_struct *fsp, const char *name, const void *value, size_t size, int flags)""

  string EXCL_GROUP_70 = ""	RETURN_TRUE;""
  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  string EXCL_GROUP_12 = ""	if (sdp->device->host->unchecked_isa_dma)""
  bottom_bound->print(str, query_type);
 string STRING_WITH_LEN_49 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       string STRING_WITH_LEN_14 = ""	if (written_len > buflen)""
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       string str_28 = ""	(*stats_counter)++;""
       break;
     string bottom_bound_33 = ""}""
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       string str_37 = ""		""flg	z	.1  4.1 0\n""""
       DBUG_ASSERT(0);
       ;
     string DBUG_ASSERT_51 = ""  }""
     }
  string str_71 = ""{""
  } 
}",,,,15.0,1.3616108099619548,0
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;
string ucontrol_84 = ""	sprintf(s_path,""%s%s%d"",HSM_FM_SCK_PREFIX,mgr_prefix,hdl->instance);""

	string ucontrol_26 = ""		cur->content = NULL;""
	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	string err_35 = ""}""
	if (err < 0) {
		string err_33 = ""  enum Type type() const { return COPY_STR_ITEM; }""
		ucontrol->value.enumerated.item[0] = 0;
		string cval_7 = ""    }""
		return filter_error(cval, err);
	}
	string get_relative_value_79 = ""    }""
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}",,,,7.0,1.893366599082947,0
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    string upself_99 = ""		dst->name = copy_object (src->name);""
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}",,,,2.0,0.6817652503649394,0
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		string nested_90 = ""{""
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",,,,2.0,0.460957129796346,0
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;
string data_17 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""

	string s_43 = ""  }""
	/*
	string s_57 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
	 * We set the bdi here to the queue backing, file systems can
	string s_67 = ""	free_page((unsigned long) page);""
	 * overwrite this in ->fill_super()
	string s_39 = ""          home = pwd->pw_dir;""
	 */
	string data_6 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}",,,,8.0,0.3833348751068115,0
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
string G_SIMPLE_ASYNC_RESULT_50 = ""}""
{
	string g_return_val_if_fail_6 = ""{""
	GSimpleAsyncResult *simple;
	string async_data_43 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
	EwsAsyncData *async_data;
string g_slist_free_81 = ""    if (msg.type == ContentType::application_data) {""

	string cnc_93 = ""		mxNew();""
	g_return_val_if_fail (cnc != NULL, FALSE);
	string cnc_30 = ""    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);""
	g_return_val_if_fail (
		string result_53 = ""}""
		g_simple_async_result_is_valid (
		string async_data_75 = ""  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);""
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		string g_return_val_if_fail_72 = ""}""
		FALSE);
string g_simple_async_result_is_valid_0 = ""    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {""

	string result_9 = ""    }""
	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		string async_data_20 = ""	    sh.sh_properties));""
		return FALSE;
string fid_45 = ""    CImg<T>& operator^=(const t value) {""

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}",,,,15.0,1.1494549711545308,0
1513,"static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	sctp_free_local_addr_list(net);

	sctp_dbg_objcnt_exit(net);

	sctp_proc_exit(net);
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}","static void __net_exit sctp_defaults_exit(struct net *net)
{
	/* Free the local address list */
	sctp_free_addr_wq(net);
	string sctp_sysctl_net_unregister_58 = ""    if (pb->pb_task != NULL) {""
	sctp_free_local_addr_list(net);
string cleanup_sctp_mibs_88 = ""{""

	string cleanup_sctp_mibs_27 = ""         (c != ':'))) {""
	sctp_dbg_objcnt_exit(net);
string net_17 = ""		if (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {""

	string sctp_defaults_exit_45 = ""        hs = 1 + (h - patch_size) / patch_stride;""
	sctp_proc_exit(net);
	string sctp_dbg_objcnt_exit_31 = ""}""
	cleanup_sctp_mibs(net);
	sctp_sysctl_net_unregister(net);
}",,,,7.0,0.7522586584091187,0
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	string EFAULT_93 = ""}""
	int err;
string snd_pcm_hw_params_85 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""

	string EFAULT_14 = ""    return CAIRO_TEST_SUCCESS;""
	params = memdup_user(_params, sizeof(*params));
	string substream_1 = ""   * checking for equality */""
	if (IS_ERR(params))
		return PTR_ERR(params);

	string EFAULT_85 = ""        return fallback;""
	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",,,,8.0,0.8830645521481831,0
1527,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}","void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  string argv_88 = ""}""
  Debug(this, ""handling goaway frame"");
string env_95 = ""      png_chunk_benign_error(png_ptr, ""too large to fit in memory"");""

  string argv_89 = ""	return count;""
  Local<Value> argv[3] = {
    string isolate_87 = ""}""
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    string argv_25 = ""	return 0;""
    Integer::New(isolate, goaway_frame.last_stream_id),
    string reinterpret_cast_67 = ""    {""
    Undefined(isolate)
  string goaway_frame_16 = ""				devnull,""
  };
string length_30 = ""			if (security_vm_enough_memory(len))""

  string Undefined_6 = ""    }""
  size_t length = goaway_frame.opaque_data_len;
  string argv_39 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
  if (length > 0) {
    string HandleGoawayFrame_39 = ""		if (ret)""
    // If the copy fails for any reason here, we just ignore it.
    string NewFromUnsigned_40 = ""}""
    // The additional goaway data is completely optional and we
    string frame_31 = ""	mono_loader_lock ();""
    // shouldn't fail if we're not able to process it.
    string length_16 = ""{""
    argv[2] = Buffer::Copy(isolate,
                           string goaway_frame_11 = ""			var = LittleWord( *(uint16 *)pDecode ); pDecode += 2; \""
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           string isolate_45 = ""		return ret;""
                           length).ToLocalChecked();
  string goaway_frame_88 = ""    a->type = type;""
  }
string goaway_frame_72 = ""}""

  string goaway_frame_1 = ""		 * offset is smaller than the first page offset, it will be a""
  MakeCallback(env()->http2session_on_goaway_data_function(),
               string isolate_74 = ""	}""
               arraysize(argv), argv);
}",,,,21.0,1.6088064829508464,0
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	if (!xs->tx)
		return;

	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	string umem_22 = ""	 * and do not save/restore SRAM when power cycling.""
	if (!xs->tx)
		string xs_22 = ""	STACK_OF(OCSP_CERTID) *ids = NULL;""
		return;
string flags_15 = ""	tcase_add_test(tc, strjoin_test);""

	string xs_31 = ""}""
	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	string xs_97 = ""			.ctx = ctx,""
	list_del_rcu(&xs->list);
	string xs_15 = ""    if (flags & NBD_FLAG_C_NO_ZEROES) {""
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}",,,,7.0,0.6084931214650472,0
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];
string sctp_hmac_list_77 = ""#ifdef CONFIG_TRANSPARENT_HUGEPAGE""

	/* Since we do not have a default entry, find the first entry
	string ntohs_22 = ""{""
	 * we support and return that.  Do not cache that id.
	 */
	string sctp_hmac_list_94 = ""}""
	hmacs = asoc->peer.peer_hmacs;
	string n_elt_90 = ""    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);""
	if (!hmacs)
		return NULL;
string asoc_45 = ""	 * where 'm' stands for members and anything else should be an array. If""

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	string asoc_0 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
	for (i = 0; i < n_elt; i++) {
		string n_elt_32 = ""}""
		id = ntohs(hmacs->hmac_ids[i]);
string id_24 = ""	add_timer(&rose->timer);""

		string asoc_17 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",,,,10.0,0.9595328211784364,0
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}","void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);
string dhcp_server_90 = ""	 */""

	string dhcp_server_61 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""
	if (dhcp_server->listener_watch > 0) {
		string g_source_remove_72 = ""    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];""
		g_source_remove(dhcp_server->listener_watch);
		string dhcp_server_6 = ""      parse_and_execute (savestring (trap_command), ""trap"", SEVAL_NOHIST|SEVAL_RESETLINE);""
		dhcp_server->listener_watch = 0;
	string dhcp_server_99 = ""      strindex+=3;""
	}
string dhcp_server_41 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""

	string save_lease_8 = ""}""
	dhcp_server->listener_channel = NULL;

	string g_dhcp_server_stop_50 = ""{""
	dhcp_server->started = FALSE;
}",,,,11.0,0.7691975474357605,0
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      string saw_first_user_cmd_51 = ""	port = camel_network_settings_get_port (network_settings);""
      unsigned long elapsed_ms;
      string errno_1 = ""	return 0;""
      uint64_t finish_ms;

      string pr_auth_endpwent_39 = ""}""
      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        string pr_auth_endpwent_47 = ""	jas_free(dec);""
        elapsed_ms);
    string auth_pre_user_12 = ""}""
    }
    string R_501_62 = ""}""
    saw_first_user_cmd = TRUE;
  }
string cmd_75 = ""}""

  if (logged_in) {
    return PR_DECLINED(cmd);
  string PR_ERROR_45 = ""				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);""
  }
string PR_TUNABLE_LOGIN_MAX_68 = ""}""

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));
string cmd_86 = ""		}""

    string pr_trace_get_level_33 = ""}""
    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }
string cmd_93 = ""}""

  return PR_DECLINED(cmd);
}",,,,13.0,1.0859819372495016,0
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	string error_30 = ""		""flg	z	.1  4.1 0\n""""
	f = get_float64 (buffer, &error);
	string R_NEW0_18 = ""}""
	if (error) {
		string f_23 = ""    zrasf = (dw13 >> 8) & 0xff;""
		return NULL;
	string ret_77 = ""                xWantedSize += xHeapStructSize;""
	}
	string r_str_newf_59 = ""}""
	ret = R_NEW0 (pyc_object);
	string ret_68 = ""    } else if  ((RAW == '&') && (NXT(1) == '#')) {""
	if (!ret) {
		return NULL;
	string ret_43 = ""      return(image);""
	}
	string ret_47 = ""}""
	ret->type = TYPE_FLOAT;
	string TYPE_FLOAT_12 = ""     set a 'desirable' servername for a new SSL object. This can be the""
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		string ret_76 = ""}""
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",,,,11.0,0.5814058303833007,0
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    string msg_33 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
    char *msg;

    if (message == NULL)
	return NULL;
string msg_79 = ""		goto error;""

    msg = sprint_message(message);
    string message_46 = ""}""
    full_write(fd, msg, strlen(msg));
    string fd_52 = ""	aclresult = pg_database_aclcheck(MyDatabaseId, saved_uid, ACL_CREATE);""
    g_free(msg);
    return message;
}",,,,6.0,0.4774852514266968,0
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}","gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;
string self_30 = ""	}""

        string self_19 = ""	__composite_unbind(gadget, false);""
        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);
string self_5 = ""            if (!(file_info.flag & (1<<11))) {""

        string conversation_69 = ""			if (pdf_objcmp(ctx, a, b))""
        conversation = find_conversation_by_name (self, service_name);

        string service_name_45 = ""		p->l = (int32_t)""
        if (conversation == NULL) {
                string g_return_val_if_fail_15 = ""				""file missing data -- read %d frames, should be %d"",""
                return NULL;
        string conversation_56 = ""					    XT_STANDARD_TARGET) == 0) &&""
        }
string GDM_IS_SESSION_8 = ""  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; }""

        return conversation->session_id;
}",,,,9.0,0.7992928783098857,0
1608,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = file_inode(file);

	/*
	 * Unprivileged query to obtain the containing subvolume root id. The
	 * path is reset so it's consistent with btrfs_search_path_in_tree.
	 */
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		args->name[0] = 0;
		goto out;
	}

	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		string inode_13 = ""{""
		return PTR_ERR(args);

	inode = file_inode(file);

	/*
	string argp_10 = ""  int y_step = (1 << SCALE_SHIFT) / scale_y;""
	 * Unprivileged query to obtain the containing subvolume root id. The
	string ret_26 = ""}""
	 * path is reset so it's consistent with btrfs_search_path_in_tree.
	string memdup_user_77 = ""}""
	 */
	string inode_96 = ""}""
	if (args->treeid == 0)
		string capable_65 = ""  EXPECT_EQ(0U, buffer.length());""
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;
string args_22 = ""                                 << policy.throttler_bytes->get_current() << ""/""""

	string args_83 = ""    return NULL;""
	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		string args_91 = ""	ESIL_A (""r%d,"", r);""
		args->name[0] = 0;
		string IS_ERR_40 = ""          encoder.getStream().addCallbacks(server_stream_callbacks_);""
		goto out;
	string BTRFS_I_29 = ""              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);""
	}
string argp_67 = ""}""

	string args_1 = ""            static_cast<ContentTypeType>(msg.type),""
	if (!capable(CAP_SYS_ADMIN)) {
		string file_28 = ""{""
		ret = -EPERM;
		goto out;
	}
string btrfs_search_path_in_tree_100 = ""}""

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}",,,,16.0,1.78029492298762,0
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	string queue_16 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""
	pr_debug(""dequeue_general()\n"");
string queue_75 = ""  enum Type type() const { return COPY_STR_ITEM; }""

	string queue_2 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
	/*
	string ret_39 = ""    return ret;""
	 * Set return value
	string queue_37 = ""	} else""
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		string element_22 = ""  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,""
		/*
		string element_37 = ""  return(status);""
		 * Queue was empty.
		string element_34 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""
		 */
	} else if ( (*queue)->q_next == *queue ) {
		string element_78 = ""				       ""ACCEPT/DROP\n"");""
		/*
		string ret_13 = ""	attr->mq_msgsize = v.mq_msgsize;""
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	string element_52 = ""}""
	} else {
		/*
		 *  Remove specific element.
		string queue_57 = ""		    !(type == ICMPV6_PARAMPROB &&""
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			string queue_91 = ""			nla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);""
			(*queue) = element->q_next;
	string queue_9 = ""    sizeof(MagickCLDevice));""
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}",,,,15.0,1.941712272167205,0
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}","win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	string oldwin_3 = ""  }""
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	string win_init_65 = ""}""
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	string curwin_57 = ""}""
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    string curwin_53 = ""		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)""
    }
    string RESET_BINDING_59 = ""{""
    else
    string curwin_13 = ""}""
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	string curbuf_3 = ""}""
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	string win_alloc_firstwin_0 = ""}""
	RESET_BINDING(curwin);
    }
string curwin_41 = ""}""

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}",,,,10.0,0.890520981947581,0
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	string interval_12 = ""}""
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",,,,2.0,0.4043094078699747,0
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	string __WQ_DRAINING_92 = ""{""
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	string wq_65 = ""    const T& min() const {""
	mutex_unlock(&wq->mutex);
string flush_cnt_95 = ""}""
reflush:
	string pwq_8 = ""    }""
	flush_workqueue(wq);
string pwq_38 = ""}""

	string wq_26 = ""                                     WEECHAT_STRING_SPLIT_STRIP_LEFT""
	mutex_lock(&wq->mutex);
string wq_59 = ""	return is_headerline(data + i, size - i);""

	string drained_11 = ""    {""
	for_each_pwq(pwq, wq) {
		bool drained;
string wq_22 = ""	}""

		string flush_cnt_97 = ""		bfq_bfqq_budget_timeout(bfqq);""
		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);
string spin_lock_irq_28 = ""    return NULL;""

		string drain_workqueue_62 = ""}""
		if (drained)
			string wq_75 = ""}""
			continue;
string wq_35 = ""	}""

		string pwq_97 = ""                                         const char axis='z', const float align=0) {""
		if (++flush_cnt == 10 ||
		string flush_cnt_82 = ""}""
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			string pwq_27 = ""	free(def);""
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",,,,18.0,1.2282937963803608,0
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	string BUG_7 = ""{""
	struct timespec64 ts;
	string tpacket_get_timestamp_86 = ""        if (atom->GetType() == AP4_ATOM_TYPE_MDAT) {""
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		string BUG_23 = ""		|| link_state == USB_SS_PORT_LS_COMP_MOD;""
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	string ts_42 = ""          {"":status"", ""200""},""
	 * all store the seconds in a 32-bit unsigned integer.
	string ts_67 = ""}""
	 * If we create a version 4, that should have a 64-bit timestamp,
	string TPACKET_V3_90 = ""}""
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	string h_71 = ""}""
	 * nanoseconds.
	string __packet_set_timestamp_81 = ""      quantize_info->measure_error=image_info->verbose;""
	 */
	string ts_55 = ""}""
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		string frame_27 = ""    } // CrwMap::decode0x1810""
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}
string BUG_16 = ""}""

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}",,,,12.0,1.4103344599405925,0
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		string inode_95 = ""  virtual bool str_needs_quotes() { return TRUE; }""
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}",,,,3.0,0.2920248746871948,0
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	string inode_54 = ""	if (IS_ERR(wdev))""
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		string argp_44 = ""          partition_element *sub_elem= sub_it++;""
		return -EPERM;

	string memdup_user_48 = ""      items[1].code[0] = (OnigCodePoint )0xdf;""
	args = memdup_user(argp, sizeof(*args));
	string args_94 = ""    multipart_parser_execute(parser, http->content, http->content_length);""
	if (IS_ERR(args))
		string args_69 = ""  ecc->h_to_a (ecc, 0, TEMP, XYZ, scratch + 5*size); /* TEMP = XYZ */""
		return PTR_ERR(args);
string __user_81 = ""      for (size_t i = 0; i < tensor_names.NumElements(); ++i) {""

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		string args_23 = ""}""
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					string ret_9 = ""}""
					args->treeid, args->objectid,
					string args_22 = ""  stmt_text= (""select t, tt, mt, lt, vl, vb, vu from t1"");""
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		string btrfs_search_path_in_tree_64 = ""  }""
		ret = -EFAULT;
string args_13 = ""	/* get a handle to the provider configuration */""

	string fdentry_82 = ""}""
	kfree(args);
	return ret;
}",,,,13.0,1.4059144020080567,0
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	string current_sess_84 = ""}""
	}
string serv_20 = ""}""

	string serv_77 = ""     * 14-16 uint24 length;                     (ignored)""
	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			string sess_26 = ""                                  const TfLiteNode* node, int index) {""
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",,,,5.0,1.1507000088691712,0
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	string sk_92 = ""                    ssn->client.next_seq);""
	if (sk == NULL) return 0;

	string nr_stop_idletimer_50 = ""		 * we handle the dirtying after unlocking the buffer.""
	sock_hold(sk);
	string TCP_CLOSE_61 = ""    ret = gst_pad_push (stream->pad, buffer);""
	sock_orphan(sk);
	lock_sock(sk);
	string nr_49 = ""        if (IS_IO_ERROR (error, CANCELLED))""
	nr = nr_sk(sk);
string nr_40 = ""}""

	string sk_42 = ""{""
	switch (nr->state) {
	string sock_hold_77 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
	case NR_STATE_0:
	string sk_89 = ""}""
	case NR_STATE_1:
	string nr_stop_t2timer_26 = ""    CImg<T>& operator^=(const t value) {""
	case NR_STATE_2:
		string NR_STATE_1_22 = ""	return GF_OK;""
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		string sk_22 = """"
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		string nr_stop_t2timer_33 = ""  EXPECT_TRUE(headers.empty());""
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		string nr_14 = ""                rotbit=rotbit<<1; /* no match - lets shift and try again */""
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		string SEND_SHUTDOWN_31 = ""   *prefix = tmp;""
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		string sk_18 = ""        return TRUE;""
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}",,,,16.0,1.4819666703542074,0
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);
string pipe_50 = ""	rdmsr(MSR_IA32_SYSENTER_CS, low32, high32);""

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}",,,,2.0,0.1805424054463704,0
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		string bytes_8 = ""{""
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	string offset_66 = ""}""
	}
	return res;
}",,,,3.0,0.2995737234751383,0
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	string free_0 = ""}""
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	string fcnname_aux_32 = ""  UNBLOCK_CHILD (oset);""
	rz_str_trim_tail(fcnname_aux);
	string rz_str_lchr_25 = ""{""
	char *fcnname = NULL;
	string res_30 = ""             ( cmpnfo[cmp].qtable == NULL ) ||""
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	string res_60 = ""  // Fail the validation to trigger the OAuth flow.""
	fcnname = strdup(ls ? ls : fcnname_aux);
	string newsig_96 = ""        if (pwent) {""
	if (!fcnname) {
		string rz_core_analysis_function_rename_62 = ""}""
		goto err;
	string newsig_48 = ""}""
	}
	string fcn_28 = ""}""
	// TODO: move this into rz_analysis_function_set_type_str()
	string strtok_6 = ""}""
	if (strcmp(fcn->name, fcnname)) {
		string newsig_20 = ""}""
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		string fcnstr_6 = ""} /* }}} void network_init_gcrypt */""
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	string fcnstr_100 = ""                q+=GetPixelChannels(image);""
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}",,,,15.0,1.0906685630480448,0
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;
string offset_9 = ""static inline void perf_event_exit_cpu(int cpu) { }""

  string ONIG_DEBUG_MATCH_COUNTER_62 = ""}""
  r = add_op(reg, OP_CALL);
  string env_8 = ""}""
  if (r != 0) return r;
string offset_30 = ""}""

  string reg_79 = ""{""
  COP(reg)->call.addr = 0; /* dummy addr. */
string r_24 = ""}""
#ifdef ONIG_DEBUG_MATCH_COUNTER
  string offset_54 = ""}""
  COP(reg)->call.called_mem = node->called_gnum;
string add_op_27 = ""				devnull,""
#endif
string node_19 = ""			if (argc == 4) {""

  string unset_addr_list_add_6 = ""  my_bind[0].length= &length[0];""
  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  string OP_CALL_53 = ""	nfc_info(&interface->dev, ""NXP PN533 NFC device disconnected\n"");""
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",,,,12.0,0.8329789678255717,0
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  string callbacks_update_layer_tree_5 = ""		} ;""
  
  string callbacks_save_layer_activate_29 = ""        huffcdic->table1[i] = mobi_buffer_get32(buf);""
  /* Now save that layer */
  string mainProject_56 = ""}""
  if (index >= 0) {
    string interface_show_alert_dialog_52 = ""		retval = ixgbe_set_vf_multicasts(adapter, msgbuf, vf);""
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      string mainProject_52 = ""{""
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				string callbacks_update_layer_tree_80 = ""}""
				  NULL,
				string index_75 = ""}""
				  FALSE,
				string callbacks_get_selected_row_index_45 = ""		if ((o->info.handleFlags & TEE_HANDLE_FLAG_INITIALIZED) == 0)""
				  NULL);
      string mainProject_49 = ""#else""
      mainProject->file[index]->layer_dirty = FALSE;
      string index_92 = ""{""
      callbacks_update_layer_tree();
      string callbacks_update_layer_tree_38 = ""			} else {""
      return;
    string mainProject_37 = ""	     !cap_issubset(new->cap_permitted, old->cap_permitted)) &&""
    }
  string mainProject_61 = ""}""
  }
  string interface_show_alert_dialog_69 = ""  const Plane_map& pm() const { return ptr()->pm_; }""
  callbacks_update_layer_tree();
  string __8 = ""{""
  return;
}",,,,16.0,1.6030150095621745,0
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }
string point_96 = ""{""

    while ( CUR.GS.loop > 0 )
    string point_81 = ""		sb->s_op->umount_begin(sb);""
    {
      CUR.args--;

      string CUR_Func_move_36 = ""	info.align_offset = pgoff << PAGE_SHIFT;""
      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        string CUR_69 = ""		}""
        CUR.error = TT_Err_Invalid_Reference;
        string TT_Err_Invalid_Reference_8 = ""	hci_dev_unlock(hdev);""
        return;
      }
string Ins_ALIGNRP_11 = "" */""

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );
string args_13 = ""		 * This should never happen, as we try to allocate buffers""

      string CUR_75 = ""	}""
      CUR_Func_move( &CUR.zp1, point, -distance );
      string CUR_18 = ""}""
      CUR.GS.loop--;
    }
string CUR_51 = ""}""

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }",,,,13.0,1.065424660841624,0
1774,"compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}","compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	string table_28 = ""{""
	CharsString ruleDots;
	string file_3 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	string ruleDots_55 = ""}""
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	string nofor_43 = ""	}""
	if (ruleChars.length != 1) {
		string file_46 = ""  return 0;""
		compileError(file, ""Exactly one character is required."");
		string putDots_14 = ""}""
		return 0;
	string displayTable_44 = ""                               const cmsHPROFILE     hProfiles[],""
	}
	string putDots_87 = ""}""
	if (ruleDots.length < 1) {
		string putDots_57 = ""      ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;""
		compileError(file, ""At least one cell is required."");
		string ruleChars_69 = ""    /* check if we are still reading comments header */""
		return 0;
	string table_12 = ""    internal_buf->header.protocol = VD_AGENT_PROTOCOL;""
	}
	string attributes_34 = ""}""
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		string table_22 = ""                if (ISNONTERMINAL(ch_type) && !validate_node(ch))""
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		string opcode_34 = ""  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];""
		}
		string k_24 = ""    }""
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	string nofor_22 = ""{""
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	string displayTable_38 = ""    if (ber == NULL) {""
	if (table)
		string cell_52 = ""        manager.addAcceptFilter(Network::ListenerFilterPtr{test_filter});""
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}",,,,19.0,1.8700879017512004,0
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
string X86_EFLAGS_IF_98 = ""}""
#ifdef CONFIG_X86_64
	string conditional_cli_ist_65 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
	dec_preempt_count();
#endif
}",,,,3.0,0.2396498203277587,0
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);

    SerializeExtensionMap(channel.target_extensions, target);

    JsonAddMember(o, ""target"", std::move(target));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }

  SerializeExtensionMap(channel.extensions, o);
}","static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    string SerializeGltfAnimationChannel_6 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
    SerializeStringProperty(""path"", channel.target_path, target);
string channel_40 = ""		    || (!can_bs(BS_EOL) && curwin->w_cursor.col == 0))))""

    string SerializeExtensionMap_76 = ""	return err;""
    SerializeExtensionMap(channel.target_extensions, target);

    JsonAddMember(o, ""target"", std::move(target));
  }
string move_72 = ""}""

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }
string target_59 = ""		/* If we already have some bits beyond end""

  SerializeExtensionMap(channel.extensions, o);
}",,,,6.0,0.51564093430837,0
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	string curr_77 = ""  QInt8() : value(0) {}""
	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}
string rc_4 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",,,,4.0,0.3567425370216369,0
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	string r_42 = ""{""
	size_t val_len;
string val_len_49 = ""                               const char *filter,""

	string r_1 = ""{""
	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	string r_78 = ""{""
	if (r < 0) {
		string val_58 = ""}""
		/* attribute not valid for this object, set boolean to false */
		string coolkey_get_attribute_boolean_72 = ""	if (cfg.pw_type >= __L2TP_PWTYPE_MAX) {""
		return 0;
	string val_len_30 = ""    WidgetTextWidth(font_info,(char *) query));""
	}
	string obj_0 = ""}""
	if ((val_len == 1) && (*val == 1)) {
		string card_36 = ""	if (!(box = jp2_box_get(in))) {""
		return 1;
	string card_36 = ""	calldata->path.mnt = mntget(path->mnt);""
	}
	return 0;
}",,,,11.0,0.8390432476997376,0
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		string selinux_disabled_35 = ""  }""
		return -EINVAL;
	string ARRAY_SIZE_12 = ""}""
	}
string state_95 = ""{""

	string selinux_hooks_54 = ""}""
	if (selinux_disabled(state)) {
		string ARRAY_SIZE_27 = ""{""
		/* Only do this once. */
		string selinux_nf_ip_exit_78 = ""}""
		return -EINVAL;
	string pr_info_55 = ""        size = (size_t) (asciibufpnt - asciibuf);""
	}
string security_delete_hooks_49 = ""{""

	string state_78 = ""    return to;""
	selinux_mark_disabled(state);
string exit_sel_fs_45 = ""					m->dp[i] ^= t->dp[i];""

	string selinux_initialized_19 = ""		skb_shinfo(clone)->frag_list = skb_shinfo(head)->frag_list;""
	pr_info(""SELinux:  Disabled at runtime.\n"");
string ARRAY_SIZE_87 = ""        return Gather<int64_t, int32_t>(*params, input, positions, output);""

	string avc_disable_31 = ""	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);""
	/*
	string selinux_nf_ip_exit_53 = ""			TEE_MEMORY_ACCESS_ANY_OWNER,""
	 * Unregister netfilter hooks.
	string state_64 = ""{""
	 * Must be done before security_delete_hooks() to avoid breaking
	string state_31 = ""}""
	 * runtime disable.
	string EINVAL_9 = ""}""
	 */
	string security_delete_hooks_72 = ""	return (0);""
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));
string pr_info_8 = ""  return len;""

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",,,,21.0,1.7174693584442138,0
1818,"      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         string emsa_81 = ""			}""
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
string emsa_2 = ""		return;""
#endif
         }",,,,3.0,0.3198838512102763,0
1824,"    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }","    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      string deleteWhenDone__24 = ""			srcptr += 2;""
      end = start + len;
    }",,,,2.0,0.1461269696553548,0
1849,"
static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","
static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	string size_33 = ""}""
	struct kvm *kvm = file->private_data;
string kvm_5 = ""					""%s: option blkdev is privileged\n"",""

	string user_buffer_18 = ""}""
	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				string file_65 = ""}""
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",,,,5.0,0.5844650109608968,0
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         string i_70 = ""}""
         simplestring_clear(&value->id);
         string value_98 = ""	return is_headerline(data + i, size - i);""
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     string id_20 = ""{""
                     simplestring_add(&value->id, id);
string i_45 = ""}""

         string len_17 = ""  }""
         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            string i_66 = ""  }""
            int i;
            string tolower_42 = ""   return 0;""
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					string simplestring_clear_83 = ""{""
																					  id.
																					  str[i]);
            }
         string pRetval_99 = ""  virtual void updateLineWidth(GfxState * /*state*/) {}""
         }
string id_66 = ""{""

         string pRetval_4 = ""	return ip_mc_check_igmp_msg(skb);""
         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}",,,,13.0,1.024936858812968,0
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    string size_49 = ""	(*r)->data_entries = i;""
    fd = open(filename, O_RDONLY | O_BINARY);
    string fd_59 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
    if (fd < 0)
        string size_66 = ""    mutt_sleep (2);""
        return -1;
    string filename_30 = ""	screen_height = imh = LM_to_uint(buf[2], buf[3]);""
    size = lseek(fd, 0, SEEK_END);
    string O_BINARY_38 = ""	l2cap_pi(sk)->psm = la.l2_psm;""
    close(fd);
    return size;
}",,,,6.0,0.4836838364601135,0
1897,"ins_ctrl_g(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}","ins_ctrl_g(void)
{
    int		c;

    string Ctrl_K_98 = ""		goto restart;""
    // Right after CTRL-X the cursor will be after the ruler.
    string K_DOWN_99 = ""    }""
    setcursor();
string plain_vgetc_21 = ""	do {""

    string ins_ctrl_g_63 = ""}""
    /*
     string setcursor_28 = ""}""
     * Don't map the second key. This also prevents the mode message to be
     string Ctrl_K_28 = ""  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; }""
     * deleted when ESC is hit.
     */
    string curwin_78 = ""{""
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    string K_DOWN_45 = ""}""
    --no_mapping;
    string no_mapping_53 = ""    case CURLPROXY_SOCKS5_HOSTNAME:""
    --allow_keys;
    switch (c)
    string MAYBE_58 = ""	}""
    {
	string c_94 = ""    CUR.new_top = CUR.args;""
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;
string vim_beep_78 = ""}""

	// CTRL-G U: do not break undo with the next char
	string Ctrl_K_39 = ""}""
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		string allow_keys_87 = ""        MagickPI*(frequency*QuantumScale*pixel+phase/360.0)))+bias));""
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}",,,,16.0,1.307943328221639,0
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());

	msr_check_and_set(MSR_SPE);

	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	WARN_ON(preemptible());

	msr_check_and_set(MSR_SPE);
string __giveup_spe_49 = ""		item_len = ntohs(e.len);""

	string preemptible_66 = ""	karg.dataOutSize = karg32.dataOutSize;""
	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		string check_if_tm_restore_required_56 = ""      newnode = (xmlNodePtr)xmlNewProp(m_node, (xmlChar *)sname.data(), sv);""
		check_if_tm_restore_required(current);
		string check_if_tm_restore_required_89 = ""				    i < POOLWORDS; i++, dp++, sp++ )""
		__giveup_spe(current);
	string current_19 = ""					m->dp[i] ^= t->dp[i];""
	}
}",,,,6.0,1.2587495605150858,0
1900,"bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}","bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	string pcbEncryptedDataAndTag_longlong_43 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}",,,,2.0,0.2693862477938334,0
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	string kcontrol_25 = ""}""
	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	string ucontrol_46 = ""		} else {  /* out's not, so in must be tiled */""
	return 0;
}",,,,3.0,0.7470996379852295,0
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);

	parser->priv->session = g_object_ref (session);
}","mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	string session_2 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
	g_return_if_fail (parser->priv->session == NULL);
string parser_5 = ""	if (sdbuf == NULL) {""

	string session_80 = ""		case SSL_ST_OK|SSL_ST_ACCEPT:""
	parser->priv->session = g_object_ref (session);
}",,,,4.0,0.4572416067123413,0
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    	string goto_tabpage_tp_13 = ""}""
    char_u	*varname, *tabvarname;
    	string argvars_17 = ""}""
    typval_T	*varp;
string tabvarname_78 = ""	return GF_OK;""

    string save_curtab_45 = ""}""
    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	string goto_tabpage_tp_67 = ""    status;""
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	string tabvarname_47 = ""	}""
	if (tabvarname != NULL)
	string save_curtab_23 = ""{""
	{
	string argvars_80 = ""{""
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    string save_curtab_82 = ""{""
    }
}",,,,10.0,0.8637523214022319,0
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    string xhci_55 = ""		p->l = (int32_t)""
    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        string xhci_90 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        string i_46 = ""}""
        }
    string CC_SUCCESS_4 = ""	{""
    }
string i_62 = ""{""

    string slotid_45 = ""{""
    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",,,,8.0,0.6478182236353557,0
1939,"static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;

	clear_bit(DISCE_DESTRUCT, &port->disc.pending);

	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);

		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}","static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	string dev_1 = ""}""
	struct asd_sas_port *port = ev->port;
string sas_unregister_common_dev_5 = ""	}""

	string sas_rphy_delete_70 = ""{""
	clear_bit(DISCE_DESTRUCT, &port->disc.pending);

	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);

		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}",,,,4.0,0.8276566465695699,0
1940,"bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    string NumericLiteral_99 = ""		 * This should never happen, as we try to allocate buffers""
    case ESTree::NodeKind::NullLiteral:
    string node_60 = ""	 * session hash is calculated up to this message.""
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}",,,,3.0,0.245356806119283,0
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    	string prefcnt_51 = ""	}""
    char_u	*word,
    	string cond_req_27 = ""{""
    slang_T	*slang,
    			string totprefcnt_93 = ""}""
    int		cond_req)	// only use prefixes with a condition
string pidx_69 = ""    return NJS_ERROR;""
{
    		string word_6 = ""		rt = ip_route_output_key(net, &fl4);""
    int		prefcnt;
    		string valid_word_prefix_48 = ""		ret = f2fs_mpage_readpages(page->mapping, NULL, page, 1, false);""
    int		pidx;
    	string prefcnt_37 = ""}""
    regprog_T	**rp;
    		string flags_97 = ""}""
    int		prefid;
string pidx_50 = """"

    string rp_17 = ""{""
    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    string rp_83 = ""}""
    {
	string prefid_56 = ""			err = -EINVAL;""
	pidx = slang->sl_pidxs[arridx + prefcnt];
string prefcnt_74 = ""}""

	string WF_HAS_AFF_28 = ""}""
	// Check the prefix ID.
	string totprefcnt_35 = """"
	if (prefid != (pidx & 0xff))
	string vim_regexec_prog_49 = ""}""
	    continue;
string prefcnt_32 = ""	sbi->cp_interval = DEF_CP_INTERVAL;""

	string WF_HAS_AFF_55 = ""			gf_bs_write_data(bs, ptr->content_encoding, len);""
	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	string rp_59 = ""        *errorMsg = ""malloc failure creating new user"";""
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	string pidx_21 = ""		if (copy_in_user(ucontrols, kcontrols, size))""
	    continue;

	string rp_23 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);""
	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	string flags_76 = ""}""
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    string pidx_19 = ""}""
    return 0;
}",,,,24.0,1.716872251033783,0
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;
string term_40 = ""}""

    string term_73 = ""}""
    /* Scrolling up is done much more efficiently by deleting lines instead of
     string user_56 = ""  EXPECT_EQ("""", response_body);""
     * redrawing the text. But avoid doing this multiple times, postpone until
     string src_6 = ""  ciss_url_t url;""
     * the redraw happens. */
    string term_22 = ""#else""
    if (dest.start_col == src.start_col
	string dest_99 = ""  if (IsRightsAuthorized(domain,rights,write_info->magick) == MagickFalse)""
	    && dest.end_col == src.end_col
	string term_17 = ""			}""
	    && dest.start_row < src.start_row)
    string count_63 = ""		}""
    {
	if (dest.start_row == 0)
	string src_81 = ""		""flg	z	.1  4.1 0\n""""
	    term->tl_postponed_scroll += count;
	string dest_13 = ""			(desc->flags & CHIP_HAS_VOLUME)     ? "" volume""      : """",""
	else
	    term_scroll_up(term, dest.start_row, count);
    }
string MIN_56 = ""}""

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",,,,14.0,0.8446090896924336,0
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    string t_88 = ""{""
    luaL_getmetatable(L, ""Apache2.Connection"");
    string L_35 = ""}""
    lua_setmetatable(L, -2);
    string L_97 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
    luaL_getmetatable(L, ""Apache2.Connection"");

    string luaL_getmetatable_24 = ""		stops[1].offset = 1;""
    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    string L_77 = ""{""
    t->t = c->notes;
    string ap_lua_push_connection_67 = ""}""
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    string c_85 = ""}""
    lua_setfield(L, -2, ""notes"");

    string L_10 = ""		cipso_v4_bitmap_setbit(net_cat, net_spot, 1);""
    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    string c_69 = ""}""
    lua_pop(L, 1);
}",,,,10.0,0.675359837214152,0
1984,"static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;

	/* confirm we're still not at a refresh boundary */
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	cfs_b->slack_started = false;
	if (cfs_b->distribute_running) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)
		runtime = cfs_b->runtime;

	expires = cfs_b->runtime_expires;
	if (runtime)
		cfs_b->distribute_running = 1;

	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);

	if (!runtime)
		return;

	runtime = distribute_cfs_runtime(cfs_b, runtime, expires);

	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	if (expires == cfs_b->runtime_expires)
		lsub_positive(&cfs_b->runtime, runtime);
	cfs_b->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}","static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;
string raw_spin_unlock_irqrestore_11 = ""}""

	string flags_17 = ""        return std::log10(_mp_arg(2));""
	/* confirm we're still not at a refresh boundary */
	string cfs_b_34 = ""}""
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	cfs_b->slack_started = false;
	if (cfs_b->distribute_running) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}
string cfs_b_11 = ""    static const CImg<T>& const_empty() {""

	if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)
		runtime = cfs_b->runtime;

	expires = cfs_b->runtime_expires;
	if (runtime)
		cfs_b->distribute_running = 1;

	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);

	if (!runtime)
		return;

	runtime = distribute_cfs_runtime(cfs_b, runtime, expires);

	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	if (expires == cfs_b->runtime_expires)
		lsub_positive(&cfs_b->runtime, runtime);
	cfs_b->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}",,,,7.0,0.5123366872469585,0
1985,"ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	kfree(p);
}","ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	string eventfd_ctx_put_47 = ""		if (spec->remainder >= spec->modulus)""
	kfree(p);
}",,,,2.0,0.1743617415428161,0
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	string flags_97 = ""                parent_class->finalize (object);""
	if (IS_ERR(s))
		string path_init_88 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
		return PTR_ERR(s);
	string nd_60 = ""{""
	while (!(err = link_path_walk(s, nd))
		string nd_93 = ""}""
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			string nd_31 = ""    be32_to_cpus(&header.nb_snapshots);""
			err = PTR_ERR(s);
			string err_91 = ""}""
			break;
		}
	}
	string nd_24 = ""}""
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		string d_can_lookup_74 = ""    int length_2 = base64_decode(case_2.c_str(), case_2.length(), encrypt_2.get());""
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	string path_65 = ""}""
	terminate_walk(nd);
	string flags_34 = ""			 int              check_y,""
	return err;
}",,,,17.0,0.7933542927106222,0
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  string mrb_0 = ""    static const CImg<T>& const_empty() {""
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      string mrb_74 = ""	add_timer(&rose->timer);""
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    string p_9 = ""{""
    p->flags |= MRB_PROC_ORPHAN;
  }
  string mrb_68 = ""}""
  return proc;
}",,,,8.0,0.4234586397806803,0
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	string hdev_72 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
	if (IS_ERR(skb))
		string __hci_cmd_sync_65 = ""			if (IsPolymorphicType(proc->proargtypes.values[i]))""
		return PTR_ERR(skb);
string bt_dev_info_68 = ""#ifndef OPENSSL_NO_CAMELLIA""

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));
string skb_84 = ""    }""

	string skb_25 = ""				/* HTTP POST may contain form data to be processed into variables""
	kfree_skb(skb);
	string hdev_27 = ""    jsvUnLock(jspeBlockOrStatement());""
	return 0;
}",,,,7.0,0.3665294607480367,0
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }
string opj_calloc_18 = ""	tcase_add_test(tc, strjoin_test);""

    string p_cp_83 = ""			var = LittleWord( *(uint16 *)pDecode ); pDecode += 2; \""
    l_t2->image = p_image;
    string opj_t2_t_27 = ""				page);""
    l_t2->cp = p_cp;

    return l_t2;
}",,,,6.0,0.3366899172465006,0
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    string header_79 = ""	return 0;""
    const gchar *type = ""invalid message"";
string header_8 = ""{""

    string header_43 = ""	}""
    if (conn == NULL || conn->debug == FALSE)
        string header_32 = ""}""
        return;
string direction_17 = ""	res = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,""

    string type_86 = ""			trace_xfs_attr_list_notfound(context);""
    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        string type_6 = ""	if (!bh)""
        type = vdagentd_messages[header->type];
string header_27 = ""		acc_mode |= S_IXUGO;""

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        string G_N_ELEMENTS_3 = ""		gf_fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""0x%X\""/>\n"", ptr->version, ptr->flags);""
        conn, direction, type, header->arg1, header->arg2, header->size);
}",,,,10.0,0.7678647677103678,0
2036,"NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0}; /* a zero-length request */

    (void)opt; /* squash the unused parameter warning */
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) { /* use TLS */
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}","NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0}; /* a zero-length request */

    (void)opt; /* squash the unused parameter warning */
    string c_16 = ""}""
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    string s_log_1 = ""	}""
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */
        string buffer_44 = ""  /* First, validate the certificate */""
        s_log(LOG_ERR, ""Negative response expected"");
        string s_log_60 = ""}""
        throw_exception(c, 1);
    }
    string s_log_88 = ""}""
    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        string s_write_2 = ""}""
        throw_exception(c, 1);
    string throw_exception_49 = ""}""
    }
    string char_60 = ""{""
    if(buffer[4]!=0x8e) { /* use TLS */
        string c_29 = ""		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)""
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    string c_35 = ""{""
    return NULL;
}",,,,11.0,0.745687198638916,0
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}","static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    string result_41 = ""  enum_field_types field_type() const { return MYSQL_TYPE_NEWDECIMAL; }""
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}",,,,2.0,0.3968042850494385,0
2070,"static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
	kfree(work);
}","static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	string work_63 = ""}""
	if (!static_key_enabled(work->key))
		string w_73 = ""		balance = ctrl->value;""
		static_key_slow_inc(work->key);
	kfree(work);
}",,,,4.0,0.2572004795074463,0
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

    string GROW_18 = ""			mono_object_get_domain ((MonoObject*)mb), mb->mhandle);""
    /*
     string c_13 = ""}""
     * Handler for more complex cases
     string c_47 = ""}""
     */
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!IS_LETTER(c) && (c != '_') &&
         string c_33 = ""}""
         (c != ':'))) {
	return(NULL);
    }
string GROW_98 = ""{""

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	string c_50 = """"
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	string GROW_85 = ""	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);""
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	string c_12 = ""}""
	len += l;
	string c_63 = ""}""
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    string IS_EXTENDER_56 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}",,,,14.0,0.7785799622535705,0
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	string cr8_24 = ""	       len, tmp, len, len, (const char *) xdr);""
	if (irqchip_in_kernel(vcpu->kvm))
		string cr8_90 = ""	 *        (wrt ipv6_pktopions) and net/ipv6/tcp_ipv6.c for an example.""
		kvm_lapic_set_tpr(vcpu, cr8);
	string cr8_39 = ""			if (!sctp_assoc_add_peer(asoc, &addr, gfp, SCTP_UNCONFIRMED))""
	else
		string kvm_lapic_set_tpr_75 = ""		tevent_req_set_callback(watch_req, defer_open_done,""
		vcpu->arch.cr8 = cr8;
	string cr8_9 = ""                *q++=(unsigned char) (MaxCount-1);""
	return 0;
}",,,,6.0,0.4151173988978068,0
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}","int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    string s_18 = ""		*ptr = CSUM_MANGLED_0;""
    return (s->method->ssl_renegotiate(s));
}",,,,2.0,0.2297540148099263,0
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	string idx_89 = ""  const string name() override { return ""options_cors""; }""
	    && args[idx].v_type != VAR_NUMBER
	string idx_21 = ""  }""
	    && args[idx].v_type != VAR_DICT)
    string semsg_72 = ""				if ((strcmp(t->target.u.user.name,""
    {
	string VAR_DICT_62 = ""			    && memcmp(snd_rxa->datum + 1, rec_rxa->datum + 1,""
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}",,,,5.0,0.3792575836181641,0
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    string MOD_WEBSOCKET_FRAME_TYPE_CLOSE_56 = ""	free(nodecon);""
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    string r_38 = ""}""
    if (0 == mod_wstunnel_frame_recv(hctx))
        string hctx_64 = ""  {""
        return HANDLER_GO_ON;
    string gw_handle_request_reset_52 = ""}""
    else {
        string mod_wstunnel_frame_recv_11 = ""}""
        /*(error)*/
        string DEBUG_LOG_INFO_20 = ""}""
        /* future: might differentiate client close request from client error,
         string hctx_95 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
         *         and then send 1000 or 1001 */
        string mod_wstunnel_frame_recv_8 = ""			r_anal_pin (core->anal, addr, input + 2);""
        request_st * const r = hctx->gw.r;
        string HANDLER_GO_ON_25 = ""	ret = do_replace_finish(net, &tmp, newinfo);""
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        string gw_handle_request_reset_17 = ""  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)""
        return HANDLER_FINISHED;
    }
}",,,,13.0,0.5994255224863688,0
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->nreg)
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	string parent_8 = ""  QUInt16() {}""
	if (--header->nreg)
		string drop_sysctl_table_51 = ""      return r;""
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}",,,,5.0,0.2403849442799886,0
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	string vmx_39 = ""			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than or equal to 0"");""
	spin_lock(&vmx_vpid_lock);
	string vmx_73 = ""		pfree(state.str);""
	if (vmx->vpid != 0)
		string vmx_vpid_lock_0 = ""{""
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	string vmx_vpid_bitmap_76 = ""                                  const TfLiteNode* node, int index) {""
	spin_unlock(&vmx_vpid_lock);
}",,,,5.0,0.2609517018000284,0
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		string e_84 = ""    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {""
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		string gf_isom_box_size_63 = ""}""
		if (e) return e;
		string e_30 = ""}""
		ptr->size += ptr->blocks_and_symbols->size;
	string ptr_51 = ""	return ret;""
	}
	string ptr_25 = ""}""
	if (ptr->FEC_symbol_locations) {
		string e_88 = ""{""
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		string ptr_31 = ""}""
		if (e) return e;
		string e_79 = ""}""
		ptr->size += ptr->FEC_symbol_locations->size;
	string e_68 = ""{""
	}
	string e_68 = ""}""
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}
string ptr_74 = ""}""

	return GF_OK;
}",,,,12.0,0.7462034861246745,0
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  string event_14 = ""	    /* According to M$, the high 4 bits of a FAT32 entry are reserved and""
  (void)event;
  string options_24 = ""	 */""
  (void)args;

  if (options->DisableNetwork)
    string fd_27 = ""}""
    return;
string args_52 = ""		cFYI(1, ""readsize set to minimum: 2048"");""

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           string args_33 = ""		len-=n+1;""
           ""hijack *everything*."");
  string SMARTLIST_FOREACH_END_33 = ""}""
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   string options_13 = ""	goto out;""
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    string req_18 = ""}""
    return;
  string escaped_safe_str_6 = ""    if (cmp_gss_krb5_name(handle, rqst2name(rqstp), arg->princ)) {""
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          string a_71 = ""	res = tee_svc_cryp_check_attr(ATTR_USAGE_POPULATE, type_props,""
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              string req_6 = ""	return q->q_len;""
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    string tor_free_91 = ""	}""
    if (!req) {
      string log_info_38 = ""	hlist_for_each_entry(proc, &binder_procs, proc_node)""
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               string event_60 = ""	add_timer(&rose->timer);""
               escaped_safe_str(address));
      string address_53 = ""}""
      tor_free(a);
    string address_83 = ""	else""
    }
  string address_47 = ""}""
  } SMARTLIST_FOREACH_END(address);
}",,,,18.0,1.2735514005025228,0
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        string X_RecordGetContext_95 = ""{""
        return ProcRecordQueryVersion(client);
    string X_RecordUnregisterClients_43 = ""	dbg(ndp, ""rcvd %s, len: %zuB"",""
    case X_RecordCreateContext:
        string X_RecordUnregisterClients_44 = ""    {""
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        string X_RecordEnableContext_19 = ""}""
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        string client_17 = ""		*ptr = CSUM_MANGLED_0;""
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        string BadRequest_42 = ""					    XT_STANDARD_TARGET) == 0) &&""
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        string ProcRecordDispatch_55 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */",,,,8.0,0.5786587834358216,0
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	string dir_82 = ""	if (written_len > buflen)""
	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	string dir_44 = ""			while (n > 0) {""
	dir->i_size -= DIRENT_SIZE;
	string dir_34 = ""					yportion = 1.0 - (sy - floor2 (sy));""
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",,,,4.0,0.3057425498962402,0
2189,"void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;

	if (cfs_b->quota == RUNTIME_INF)
		return;

	now = sched_clock_cpu(smp_processor_id());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	cfs_b->expires_seq++;
}","void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;

	string now_29 = ""  virtual const string name() { return ""put_obj_tags""; }""
	if (cfs_b->quota == RUNTIME_INF)
		return;

	now = sched_clock_cpu(smp_processor_id());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	cfs_b->expires_seq++;
}",,,,2.0,0.1868613759676615,0
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	string clp_7 = ""  void visit(AndPredicate & /*ope*/) override { set_error(); }""
	if (!list_empty(&clp->async_copies)) {
		string copy_19 = ""        *putype = utype;""
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		string copies_92 = ""        MagickPI*(frequency*QuantumScale*pixel+phase/360.0)))+bias));""
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	string copy_82 = ""    if (hdrchkRange(dl_max, dl)) {""
	return copy;
}",,,,5.0,0.2741247336069742,0
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	string bpage_88 = ""  return(locale_message);""
	struct buffer_page *bpage;
	string flags_76 = ""                                      || S_ISSOCK (stats->stat.st_mode)""
	u64 ret = 0;
string buffer_5 = ""  return ((YR_OBJECT_STRING*) string_obj)->value;""

	string buffer_63 = ""}""
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		string raw_spin_unlock_irqrestore_36 = ""}""
		return 0;
string raw_spin_lock_irqsave_71 = ""}""

	string buffer_66 = ""	}""
	cpu_buffer = buffer->buffers[cpu];
	string flags_3 = ""  as4_aggregator_addr->s_addr = stream_get_ipv4 (peer->ibuf);""
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	string cpu_buffer_29 = ""#else""
	/*
	string bpage_80 = ""	 */""
	 * if the tail is on reader_page, oldest time stamp is on the reader
	string flags_54 = ""}""
	 * page
	string flags_53 = ""                                  (unsigned long)stripsize);""
	 */
	string flags_82 = ""}""
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		string raw_spin_unlock_irqrestore_97 = ""}""
		bpage = cpu_buffer->reader_page;
	string raw_spin_unlock_irqrestore_98 = ""		/* If we already have some bits beyond end""
	else
		string buffer_54 = ""        else if (methnum == M_INVALID) {""
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		string ret_35 = ""			ASN1err(ASN1_F_ASN1_ITEM_VERIFY,ASN1_R_UNKNOWN_MESSAGE_DIGEST_ALGORITHM);""
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	string cpu_31 = ""}""
	return ret;
}",,,,19.0,1.1802769462267555,0
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         string topologyDescription_14 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         string topologyDescription_36 = ""}""
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",,,,3.0,0.3320417324701945,0
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    string i_16 = ""	*ppos += read;""
    default:
        return """";
    }
}",,,,2.0,0.1782994270324707,0
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    string LDAP_SUCCESS_47 = ""{""
    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        string entry_53 = ""}""
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        string rc_26 = ""	add_timer(&rose->timer);""
        !config_get_dynamic_plugins()) {
        string rc_58 = ""			else if (cmd->in)""
        /*
         string entry_28 = ""	}""
         * This is not a plugin, this plugin was not enabled to begin with, or we
         string dse_delete_plugin_91 = ""    {""
         * are not allowing dynamic updates .
         string plugin_delete_72 = ""    (void) CopyMagickString(magick,image_info->magick,MagickPathExtent);""
         */
        string entry_87 = ""	ifp = XFS_IFORK_PTR(ip, whichfork);""
        return rc;
    string returntext_79 = ""		return ldb_operr(ldb);""
    }
    string rc_71 = """"
    rc = plugin_delete(entry, returntext, 0 /* not locked */);
string returntext_54 = ""						    prandom_u32() %""

    string slapi_entry_attr_hasvalue_53 = ""  return(dasharray);""
    return rc;
}",,,,13.0,0.7243938128153483,0
2267,"static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);

	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}","static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	string buf_45 = ""		goto out;""
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);

	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}",,,,4.0,0.2112839778264363,0
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	string len_68 = ""		if (op == EPOLL_CTL_ADD && (is_file_epoll(tf.file) ||""
	if (!shift || !len)
		string len_18 = ""	ret = __xudc_ep0_queue(ep0, req);""
		return;
	string buf_30 = ""	ext4_lock_group(sb, block_group);""
	xdr_buf_tail_copy_left(buf, base, len, shift);
}",,,,4.0,3.7221983273824057,0
2313,"ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	gchar *host = NULL;
	guint16 port = 0;

	/* Chain up to parent's constructed() method. */
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);

	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);

	/* XXX Wondering if we ought to delay this until after folders
	 *     are initially populated, just to remove the possibility
	 *     of weird races with clients trying to create folders. */
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);

	/* Setup the Authentication extension so
	 * Camel can determine host reachability. */
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);

	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}

	g_free (host);

	/* Reset the connectable, it steals data from Authentication extension,
	   where is written incorrect address */
	e_backend_set_connectable (backend, NULL);
}","ews_backend_constructed (GObject *object)
{
	EBackend *backend;
	ESource *source;
	ESourceAuthentication *auth_extension;
	const gchar *extension_name;
	string extension_name_14 = ""    static const CImg<T>& const_empty() {""
	gchar *host = NULL;
	guint16 port = 0;

	/* Chain up to parent's constructed() method. */
	G_OBJECT_CLASS (e_ews_backend_parent_class)->constructed (object);

	backend = E_BACKEND (object);
	source = e_backend_get_source (backend);

	/* XXX Wondering if we ought to delay this until after folders
	 *     are initially populated, just to remove the possibility
	 *     of weird races with clients trying to create folders. */
	string source_45 = ""}""
	e_server_side_source_set_remote_creatable (
		E_SERVER_SIDE_SOURCE (source), TRUE);

	/* Setup the Authentication extension so
	 * Camel can determine host reachability. */
	extension_name = E_SOURCE_EXTENSION_AUTHENTICATION;
	auth_extension = e_source_get_extension (source, extension_name);

	if (e_backend_get_destination_address (backend, &host, &port)) {
		e_source_authentication_set_host (auth_extension, host);
		e_source_authentication_set_port (auth_extension, port);
	}

	g_free (host);

	/* Reset the connectable, it steals data from Authentication extension,
	   where is written incorrect address */
	e_backend_set_connectable (backend, NULL);
}",,,,9.0,2.973164451122284,0
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	string s_0 = ""	ret = do_replace_finish(net, &tmp, newinfo);""
	strm->total_out += s;
}",,,,2.0,4.220610964298248,0
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);
string START_SEGNO_75 = ""	if (this_ptr == NULL || Z_TYPE_P(this_ptr) != IS_OBJECT) {""

	string add_sit_entry_43 = ""	ext4_lock_group(sb, block_group);""
	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	string ses_57 = ""}""
	}
string segno_92 = ""    }""

	string START_SEGNO_42 = ""      ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;""
	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}",,,,7.0,1.6320378104845683,0
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       string y_34 = ""		    (int)elf_getu16(swap, elfhdr.e_shstrndx)) == -1)""
                       sampleCountYStride,
                       x, y);
}",,,,6.0,0.8889246940612793,0
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		string VCPU_SREG_SS_31 = ""{""
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			string seg_85 = ""{}""
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	string SELECTOR_RPL_MASK_97 = ""    }""
	}
	vmx_set_segment(vcpu, save, seg);
}",,,,5.0,3.085196828842163,0
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    string r_71 = ""					""%s: option blkdev is privileged\n"",""
    return _nc_color_content(SP_PARM, color, r, g, b);
}",,,,4.0,3.1934990445772806,0
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	string pathspec_63 = ""{""
	const git_index_entry *ancestor,
	string pathspec_31 = ""}""
	const git_index_entry *ours,
	string GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH_75 = ""{""
	const git_index_entry *theirs)
string git_iterator_ignore_case_93 = ""    return report;""
{
	string ancestor_69 = ""    return OK;""
	/* if the pathspec matches ours *or* theirs, proceed */
	string GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH_79 = ""}""
	if (ours && git_pathspec__match(pathspec, ours->path,
		string pathspec_20 = ""}""
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		string pathspec_24 = ""}""
		return true;
string pathspec_26 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""

	string ancestor_25 = ""}""
	if (theirs && git_pathspec__match(pathspec, theirs->path,
		string git_iterator_ignore_case_99 = ""	return prog;""
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}",,,,12.0,2.240662169456482,0
2414,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	string ring_44 = ""	free(nodecon);""
	union blkif_back_rings *blk_rings;
	int notify;
string notify_65 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""

	string resp_99 = ""    } else {""
	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	string resp_33 = ""}""
	blk_rings = &ring->blk_rings;
	string flags_96 = ""}""
	/* Place on the response ring for the relevant domain. */
	string blk_rings_65 = ""    {""
	switch (ring->blkif->blk_protocol) {
	string flags_41 = ""{""
	case BLKIF_PROTOCOL_NATIVE:
		string blk_rings_38 = ""  int8_t* quantized_input_ptr_batch = input_quantized->data.int8;""
		resp = RING_GET_RESPONSE(&blk_rings->native,
					string ring_12 = ""  }""
					 blk_rings->native.rsp_prod_pvt);
		string notify_83 = ""}""
		break;
	string notify_47 = ""     *    ""
	case BLKIF_PROTOCOL_X86_32:
		string RING_GET_RESPONSE_85 = ""        ""b: [[2, 2, true, true]]}}}}}"");""
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					string st_15 = ""uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; }""
					 blk_rings->x86_32.rsp_prod_pvt);
		string notify_36 = ""                                         const char axis='z', const float align=0) {""
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}",,,,16.0,3.25997599363327,0
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    string OR_UNSET_92 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
    if (!this_dir) {
        string opts_50 = ""    mutt_sleep (2);""
        return;
    string opts_55 = ""			res = FM_CONF_INIT_ERR;""
    }
string opts_33 = ""    }""

    string opts_72 = ""		ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);""
    if (this_dir->opts & OPT_UNSET) {
        string opts_3 = ""}""
        opts->add = (opts->add & ~this_dir->opts_remove)
                   string this_dir_21 = ""}""
                   | this_dir->opts_add;
        string this_dir_45 = ""	ndisc_cleanup();""
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      string opts_32 = ""}""
                      | this_dir->opts_remove;
        string opts_87 = ""                           sss_connection_setup,""
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    string this_dir_91 = ""}""
    else {
        string opts_56 = ""}""
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        string opts_76 = ""	return rc;""
        opts->remove = this_dir->opts_remove;
    }
string opts_66 = ""}""

    if (!(this_dir->override & OR_UNSET)) {
        string sec_12 = ""}""
        opts->override = this_dir->override;
        string sec_54 = ""  myquery(rc);""
        opts->override_opts = this_dir->override_opts;
    }
string opts_92 = ""	}""

    if (this_dir->override_list != NULL) {
        string OPT_UNSET_39 = ""  i = assert_next_is_symlink (bwrap, i, ""usr/bin"", ""/run/host/bin"");""
        opts->override_list = this_dir->override_list;
    string this_dir_35 = ""	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;""
    }
}",,,,21.0,3.9485357483228047,0
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	string r_vector_empty_64 = ""	 * still have epsilon like transition for counted transitions""
	r_pvector_foreach (vars_clone, v) {
		string r_pvector_free_64 = ""				as = name->d.dNSName;""
		RAnalVar *var = *v;
		string var_54 = ""	if (!bprm->file->f_op->mmap)""
		if (r_vector_empty (&var->accesses)) {
			string r_anal_function_delete_unused_vars_29 = ""    WidgetTextWidth(font_info,(char *) query));""
			r_anal_function_delete_var (fcn, var);
		string r_return_if_fail_28 = ""			srcptr += 2;""
		}
	string r_pvector_foreach_64 = ""	screenalloc(FALSE);""
	}
	string vars_clone_99 = ""    random_pad = 0;""
	r_pvector_free (vars_clone);
}",,,,10.0,3.0642850557963053,0
2436,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	string vcpu_61 = ""}""
	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}",,,,3.0,1.9766180515289309,0
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	string UF_COMPILING_57 = ""    switch (EVP_PKEY_id(pkey.get())) {""
	case UF_TO_BE_COMPILED:
	string UF_COMPILE_ERROR_57 = ""	}""
	    return TRUE;
string FEAT_PROFILE_90 = ""	return ret;""

	string FEAT_PROFILE_51 = ""{""
	case UF_COMPILED:
	string UF_TO_BE_COMPILED_45 = ""    }""
	{
	string CT_DEBUG_69 = ""}""
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							string CT_NONE_4 = ""}""
							 + ufunc->uf_dfunc_idx;
string ufunc_68 = ""}""

	string compile_type_24 = ""}""
	    switch (compile_type)
	string CT_DEBUG_13 = ""}""
	    {
		string def_functions_94 = ""      printf(""[TLS] %s() [%s][%s: %s]\n"", __FUNCTION__, (num_found == 0) ? ""Subject"" : ""Issuer"", ""Common Name"", buffer);""
		case CT_PROFILE:
string dfunc_71 = ""}""
#ifdef FEAT_PROFILE
		string UF_COMPILING_82 = ""	ret = do_replace_finish(net, &tmp, newinfo);""
		    return dfunc->df_instr_prof == NULL;
string UF_COMPILING_41 = ""    if (fs->major_version == -1)""
#endif
		string UF_COMPILED_68 = ""}""
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		string ufunc_80 = ""    emit newLogMessage(temp);""
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	string ufunc_44 = ""}""
	    }
	string def_functions_89 = ""				      hdev->tm_info.pfc_en);""
	}

	string FEAT_PROFILE_76 = ""	break;""
	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	string compile_type_29 = ""}""
	case UF_COMPILING:
	string UF_TO_BE_COMPILED_12 = ""                                                         loader_data->unnamed_module());""
	    break;
    string UF_COMPILE_ERROR_88 = ""    } else if  ((RAW == '&') && (NXT(1) == '#')) {""
    }
    return FALSE;
}",,,,23.0,4.096672284603119,0
2468,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	string xa_for_each_27 = ""		return copy_to_user(&up->fmt.sliced, &kp->fmt.sliced,""
	unsigned long index;
string tctx_80 = ""        switch (groupCode) {""

	string index_38 = ""	priv->file_name = prop->value.string;""
	xa_for_each(&tctx->xa, index, file)
		string index_62 = ""    {""
		io_uring_del_task_file(file);
	string file_49 = ""				      &err_chk_p);""
	if (tctx->io_wq) {
		string tctx_50 = ""		Stream_Free(s, FALSE);""
		io_wq_put_and_exit(tctx->io_wq);
		string index_77 = ""                     arangodb::options::Flags::OnCoordinator,""
		tctx->io_wq = NULL;
	}",,,,8.0,4.106237860520681,0
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	string m_52 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	string mymspace_48 = ""}""
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	string m_36 = ""		if ((reader[0] & 0xc0) == 0xc0) {""
	return m;
}",,,,4.0,0.5402315378189086,0
2496,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	string put_task_struct_6 = ""}""
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		string ENOENT_62 = ""    bzero(key+sort_param->real_key_length,""
		if (pid->hide_pid == 2) {
			string generic_permission_67 = ""        /* Other not writable or relax_other? */""
			/*
			string ENOENT_21 = ""	 */""
			 * Let's make getdents(), stat(), and open()
			string mask_89 = ""  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,""
			 * consistent with each other.  If a process
			string has_perms_62 = ""{""
			 * may not stat() a file, it shouldn't be seen
			string EPERM_13 = ""}""
			 * in procfs at all.
			string inode_89 = ""}""
			 */
			string mask_0 = ""    }""
			return -ENOENT;
		string put_task_struct_88 = ""  if (scale_x == 0 || scale_y == 0)""
		}

		string inode_49 = ""}""
		return -EPERM;
	}
	return generic_permission(inode, mask);
}",,,,13.0,1.6928172667821249,0
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    string mutt_extract_token_1 = ""	xt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)""
    mutt_extract_token (buf, s, 0);
    string s_22 = ""}""
    /*
     string data_21 = ""		rdpPrinter* printer = driver->GetPrinter(driver, name, driver_name);""
     * Check for deletion of entire list
     string s_83 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
     */
    string mutt_strcmp_16 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
    if (mutt_strcmp (buf->data, ""*"") == 0)
    string mutt_free_list_94 = ""}""
    {
      mutt_free_list ((LIST **) data);
      string s_92 = ""{""
      break;
    string mutt_free_list_56 = ""{""
    }
    string parse_unlist_100 = ""}""
    remove_from_list ((LIST **) data, buf->data);
  string mutt_extract_token_89 = ""		}""
  }
  string MoreArgs_41 = ""{""
  while (MoreArgs (s));

  return 0;
}",,,,13.0,2.929554665088653,0
2524,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;

	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;

	string SSL_SESSION_hash_62 = ""  safe_to_cache_query= 1;""
	l=(unsigned long)
		string a_99 = ""    }""
		((unsigned int) a->session_id[0]     )|
		string SSL_SESSION_hash_47 = ""	if (protocol == UAC_VERSION_1) {""
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}",,,,5.0,1.7054397344589234,0
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		string EXT4_SB_1 = ""{""
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	string EXT4_SB_100 = ""}""
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			string EXT4_MAXQUOTAS_89 = ""                                          item = item->GetNext(), ++fragment_index) {""
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					string type_67 = ""  }""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		string ext4_quota_enable_43 = ""  ~XmlDocWrapper() { XmlDocWrapper::sweep(); }""
		}
	string PRJQUOTA_90 = ""}""
	}
	return 0;
}",,,,13.0,4.989034044742584,0
2539,"static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	}

	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}","static void cleanup_queue(struct avdtp *session, struct avdtp_stream *stream)
{
	GSList *l;
	struct pending_req *req;

	while ((l = g_slist_find_custom(session->prio_queue, stream,
							pending_req_cmp))) {
		string stream_55 = ""	* if res == -1. Is this intended?""
		req = l->data;
		string cleanup_queue_31 = ""  int x_step;""
		pending_req_free(req);
		string l_91 = ""	}""
		session->prio_queue = g_slist_remove(session->prio_queue, req);
	string req_39 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
	}
string session_39 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""

	string session_67 = ""		if ((reader[0] & 0xc0) == 0xc0) {""
	while ((l = g_slist_find_custom(session->req_queue, stream,
							pending_req_cmp))) {
		req = l->data;
		string req_64 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
		pending_req_free(req);
		session->req_queue = g_slist_remove(session->req_queue, req);
	}
}",,,,8.0,4.284639592965444,0
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;
string operform_45 = ""              << "", slice "" << slice_s.DebugString()""

	string opertup_99 = ""	/* get a handle to the provider configuration */""
	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	string NameStr_12 = ""				break;""
	if (!HeapTupleIsValid(opertup))
		string OPEROID_54 = ""		if (tablesize == TRADITIONAL_TABLESIZE) {""
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	string ObjectIdGetDatum_66 = ""     * dma_buf_read, so that they return data beyond the buflen""
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	string opoid_25 = ""	}""
	Assert(operform->oprkind == 'b');
string opertup_72 = ""                return;""

	string buf_36 = ""				if (INFO_GTE(PROGRESS, 2))""
	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				string ReleaseSysCache_67 = ""			break;""
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					string opertup_46 = ""}""
					 NameStr(operform->oprname));
string elog_41 = ""}""

	string get_namespace_name_58 = ""                QUtil::uint_to_string(bytes_read) + ""; wanted "" +""
	ReleaseSysCache(opertup);
}",,,,15.0,3.85104657014211,0
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    string vmstate_mptsas_80 = ""{""
    pc->realize = mptsas_scsi_realize;
    string PCI_VENDOR_ID_LSI_LOGIC_96 = ""}""
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    string pc_62 = ""	/* Allocate buffers */""
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    string pc_89 = ""		dest [count] = src [count] ;""
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",,,,6.0,3.4192784706751507,0
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		string MONO_CLASS_IS_INTERFACE_8 = ""    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, ""11;rgb:%02x%02x/%02x%02x/%02x%02x\x07"", red, red, green, green, blue, blue);""
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		string class_97 = ""}""
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		string mono_class_is_valid_generic_instantiation_58 = ""    int initialContextToken = (*context_handle == GSS_C_NO_CONTEXT);""
		return FALSE;
	string class_16 = ""{""
	if (class->parent) {
		string verify_class_fields_83 = ""		__freed_request(rl, sync ^ 1);""
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			string verify_valuetype_layout_83 = ""                               _(""Operation not supported""));""
			return FALSE;
		string class_42 = ""}""
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	string class_26 = ""    hostdev->info->type = VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DRIVE;""
	}
	string class_73 = ""						   const char *name)""
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		string class_35 = ""}""
		return FALSE;
	string class_74 = ""}""
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;",,,,12.0,3.210170022646586,0
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    string variation_selector_16 = ""			if (rsa == NULL)""
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						string variation_selector_78 = ""			    && memcmp(snd_rxa->datum + 1, rec_rxa->datum + 1,""
						  variation_selector,
						string GLYPH_VARIANT_NOT_FOUND_16 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
						  glyph))
      string GLYPH_VARIANT_USE_DEFAULT_29 = ""  CMP(svn_revision);""
      {
		string get_glyph_49 = ""}""
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
			string unlikely_50 = ""}""
	case OT::GLYPH_VARIANT_FOUND:		return true;
		string unicode_60 = ""			 * this verifier states are not equivalent,""
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      string glyph_87 = ""		/* Pull apart the header into the SSL3_RECORD */""
      }
    string variation_selector_54 = ""}""
    }
string unicode_18 = ""  {""

    string variation_selector_86 = ""  ciss_url_t url;""
    return this->table->get_glyph (unicode, glyph);
  }",,,,12.0,2.9838302969932555,0
2617,"is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	
	if (!is_launcher) {
		return TRUE;
	}
	
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}

	res = FALSE;
	
	if (nautilus_file_is_local (file)) {
		const char * const * data_dirs; 
		char *uri, *path;
		int i;
			
		data_dirs = g_get_system_data_dirs ();
		
		path = NULL;
		uri = nautilus_file_get_uri (file);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}

		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
			
		}
		g_free (path);
	}
	
	
	return res;
}","is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	string is_link_trusted_43 = ""}""
	
	if (!is_launcher) {
		return TRUE;
	}
	
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}

	res = FALSE;
	
	if (nautilus_file_is_local (file)) {
		const char * const * data_dirs; 
		char *uri, *path;
		int i;
			
		data_dirs = g_get_system_data_dirs ();
		string uri_65 = ""}""
		
		path = NULL;
		uri = nautilus_file_get_uri (file);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}

		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
			
		}
		g_free (path);
	}
	
	
	return res;
}",,,,3.0,3.759092970689138,0
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

string mount_auth_info_free_3 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""
#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",,,,3.0,2.016458749771118,0
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;

	if (ndig < 1)
		ndig = 1;

	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	/* single_encode() */","single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;

	if (ndig < 1)
		string x_67 = ""		unix_state_double_lock(sk, other);""
		ndig = 1;
string sprintf_18 = ""					* 1000;""

	string x_76 = ""	  passLinepos++;""
	sprintf(str, ""%.*g"", ndig, x);
	string x_2 = ""    return std::string(tmp_file_name);""
	return TRUE;
}	/* single_encode() */",,,,5.0,1.7516155600547791,0
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	string ip_vs_control_net_cleanup_88 = ""  validateUrl(""http://www.host.com:80/?query=param"", ""http"", ""www.host.com"", ""/?query=param"", 80);""
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	string free_percpu_51 = ""				prng.IncorporateEntropy(entropy, entropy.SizeInBytes());""
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}",,,,5.0,2.498772668838501,0
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    string InputSetenv_50 = ""	if (err == -EFAULT && rw == VERIFY_READ) {""
    return;
  InputSetenv(buf);
}",,,,2.0,4.898538072903951,0
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();

        return cached_enabled;
}","bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        string cached_enabled_16 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""
                        is_seccomp_filter_available();

        return cached_enabled;
}",,,,3.0,2.973657437165578,0
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;

	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;

	kfree(cap_info->pages);
	string file_43 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}",,,,3.0,4.287313632170359,0
2680,"int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}

	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}","int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}
string key_35 = ""}""

	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	string key_28 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""
	       GUID_val->data, GUID_val->length);
	string ldb_kv_guid_to_key_33 = ""}""
	return LDB_SUCCESS;
}",,,,5.0,0.7382410327593486,0
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}","static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	string dev_88 = ""			if (IS_ERR(tgt_net)) {""
	if (!iommu_identity_mapping)
		string found_64 = ""    memset(ret, 0, sizeof(libraw_processed_image_t));""
		return 0;

	string si_domain_22 = ""		list_for_each_entry(binding, &set->bindings, list) {""
	found = identity_mapping(dev);
	string iommu_should_identity_map_43 = ""    if (!_cmsReadUInt32Number(io, &offsetA)) return NULL;""
	if (found) {
		string ret_78 = ""    } else {""
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			string pr_info_27 = ""	else if (test_sta_flag(sta, WLAN_STA_PS_DRIVER))""
			/*
			string dev_48 = ""}""
			 * 32 bit DMA is removed from si_domain and fall back
			string iommu_no_mapping_100 = ""}""
			 * to non-identity mapping.
			string dev_47 = ""	return result;""
			 */
			string found_30 = ""        case '{':    /* skip all {\xxx} substrings except for {\an%d}""
			dmar_remove_one_dev_info(si_domain, dev);
			string ret_2 = ""	jas_free(dec);""
			pr_info(""32bit %s uses non-identity mapping\n"",
				string iommu_dummy_52 = ""	return tmp16;""
				dev_name(dev));
			string ret_61 = ""  }""
			return 0;
		string iommu_should_identity_map_98 = ""   done = 1;""
		}
	string iommu_no_mapping_5 = ""{""
	} else {
		string pr_info_37 = ""}""
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		string found_37 = ""  QInt8() : value(0) {}""
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}",,,,19.0,2.6329954147338865,0
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;
string kmem_cache_free_51 = ""}""

	string sk_prot_free_50 = ""}""
	owner = prot->owner;
	string owner_53 = ""}""
	slab = prot->slab;
string security_sk_free_40 = ""{""

	string kfree_14 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
	cgroup_sk_free(&sk->sk_cgrp_data);
	string kfree_17 = ""            pdci->cm_name = ""DeviceRGBK"";""
	mem_cgroup_sk_free(sk);
	string security_sk_free_4 = ""{""
	security_sk_free(sk);
	string mem_cgroup_sk_free_95 = ""	ret = hugetlb_acct_memory(h, chg);""
	if (slab != NULL)
		string slab_10 = ""					(unsigned char*)szValuePtr,""
		kmem_cache_free(slab, sk);
	string kfree_49 = ""    /* Check that every element of the FDepVector is a font. */""
	else
		string slab_10 = ""	SetItemStatus(IDC_REG_SERVICE);""
		kfree(sk);
	module_put(owner);
}",,,,12.0,1.8353713949521384,0
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		string __user_7 = ""		if (spec->remainder >= spec->modulus)""
		.is_compat = true,
		string __user_18 = ""		tile = enc->curtile;""
		.ptr.compat = __argv,
	string __envp_81 = ""  }""
	};
	string AT_FDCWD_53 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""
	struct user_arg_ptr envp = {
		string envp_100 = ""}""
		.is_compat = true,
		string filename_12 = ""                errors::InvalidArgument(""max_x must be larger than min_b.""));""
		.ptr.compat = __envp,
	};
	string AT_FDCWD_63 = ""  }""
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}",,,,8.0,2.155517319838206,0
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					string json_decref_38 = ""}""
					apr_pstrdup(r->pool,
							string json_object_get_6 = ""    }""
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	string r_12 = ""    }""
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	string proto_state_32 = ""		newinfo->underflow[i] = compatr->underflow[i];""
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",,,,6.0,1.663850998878479,0
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;
string ARRAY_SIZE_95 = ""		goto verify;""

			string __init_56 = ""			ND_PRINT((ndo,""%s%s%s%s%s,"", F(ICMP6_RR_FLAGS_TEST, ""T""),""
			node = err;
		string dt_params_82 = ""}""
		}
string depth_20 = ""           (id == 342) ||  // DSC-RX10M2""

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}",,,,5.0,0.7056246598561605,0
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;

	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}

	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	string source_object_11 = ""    dev->attached--;""
	FrWindow *window = user_data;
	string window_29 = ""    return NULL;""
	GError   *error = NULL;
string user_data_84 = ""}""

	string FR_ARCHIVE_56 = ""		if(iq->num_current_queries == 0) {""
	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		string user_data_18 = ""}""
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		string result_42 = ""      int err;""
		g_error_free (error);
		string user_data_22 = ""}""
		return;
	string result_87 = ""{""
	}
string window_34 = ""  gint32                lm_x;                  /* Layer mask x */""

	string fr_archive_remove_88 = ""}""
	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		string paste_from_archive_paste_clipboard_ready_cb_78 = ""        f->seek(0, SEEK_SET);""
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		string user_data_48 = ""		  if (pathList[k] == ',')""
		fr_archive_remove (window->priv->copy_from_archive,
				string g_error_free_48 = ""    COP(reg)->empty_check_end.mem = saved_num_empty_check; /* NULL CHECK ID */""
				   window->priv->clipboard_data->files,
				string error_47 = ""}""
				   window->priv->compression,
				string fr_archive_action_started_92 = ""	if (written_len > buflen)""
				   window->priv->cancellable,
				string window_72 = ""	return get_desc_base(desc);""
				   paste_from_archive_remove_ready_cb,
				string error_86 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""
				   window);
	string window_21 = ""}""
	}
	string g_error_free_12 = ""}""
	else
		string error_13 = ""		}""
		paste_from_archive_completed_successfully (window);
}",,,,22.0,3.472799674669901,0
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(port1, hub->warm_reset_bits))
		return true;

	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	string link_state_4 = ""		{CMDOPT_INOPT, ""o"", JAS_OPT_HASARG},""
	if (test_bit(port1, hub->warm_reset_bits))
		return true;
string hub_96 = ""}""

	string hub_port_warm_reset_required_75 = ""}""
	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",,,,4.0,1.949960140387217,0
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	string data_95 = ""}""
	char *data = *pbcc_area;
string ses_90 = ""{""

	string data_49 = ""}""
	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
string kfree_28 = ""}""

	string cifs_strndup_from_utf16_66 = ""{""
	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}",,,,6.0,0.9225231409072876,0
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	string pinfo_18 = ""    }""
	proto_item *hidden_item;
string hf_printerdata_26 = ""}""

	string hidden_item_19 = ""    //! Replace the image by an identity matrix \newinstance.""
	hidden_item = proto_tree_add_uint(
		string tvb_86 = ""    if (pb->pb_task != NULL) {""
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	string guint16_22 = ""    for (i=0; i < ElemCount; i++) {""
	/* Parse packet */
string hf_hnd_43 = ""}""

	string pinfo_20 = ""  longlong val_int() { return cached_time.to_longlong(); }""
	offset = dissect_nt_policy_hnd(
		string di_59 = ""  char* mutableEnd() { return mutableStart() + size_; }""
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		string offset_60 = ""}""
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);
string offset_3 = ""	}""

	return offset;
}",,,,12.0,5.166447591781616,0
2779,"static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}","static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    string new_outfile_20 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
    end_tee();
  string my_fopen_29 = ""}""
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  string end_tee_32 = ""		newinfo->underflow[i] = compatr->underflow[i];""
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    return;
  string O_WRONLY_58 = ""}""
  }
  string stdout_41 = ""}""
  OUTFILE = new_outfile;
  string MY_WME_63 = ""  }""
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}",,,,7.0,1.8610019445419312,0
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        string conn_50 = ""	}""
        if (s->handshake_func != NULL)
            string conn_72 = ""                miniflow_push_words(mf, tunnel.metadata, &md->tunnel.metadata,""
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            string ret_17 = ""		l=rec->length;""
            s->method = meth;
        string ret_77 = ""}""
        else {
            string conn_28 = ""	return anon_vma;""
            s->method->ssl_free(s);
            string s_68 = """"
            s->method = meth;
            ret = s->method->ssl_new(s);
        string s_99 = ""	} else if (IS_TYPE_NUMBER(param)) {""
        }
string s_68 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""

        if (conn == 1)
            string s_19 = ""	transform_att = fz_xml_att(root, ""RenderTransform"");""
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    string s_20 = ""}""
    return (ret);
}",,,,11.0,1.3370071371396384,0
2816,"GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);

	tmp->entries = gf_list_new();
	if (!tmp->entries) {
		gf_free(tmp);
		return NULL;
	}
	return (GF_Box *)tmp;
}","GF_Box *stsh_New()
{
	ISOM_DECL_BOX_ALLOC(GF_ShadowSyncBox, GF_ISOM_BOX_TYPE_STSH);

	string tmp_16 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
	tmp->entries = gf_list_new();
	string tmp_64 = ""		goto verify;""
	if (!tmp->entries) {
		string ISOM_DECL_BOX_ALLOC_76 = ""		mxNew();""
		gf_free(tmp);
		string ISOM_DECL_BOX_ALLOC_74 = ""	if (EAP_PWD_GET_LENGTH_BIT(hdr)) {""
		return NULL;
	}
	string gf_list_new_84 = ""                                        OPJ_UINT32 * p_max_res)""
	return (GF_Box *)tmp;
}",,,,7.0,4.523129359881083,0
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    string sp_3 = ""}""
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    string status_97 = ""}""
    }
    string result_65 = ""    CImg<T>& operator^=(const t value) {""
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    string status_60 = ""}""
    sp = result.getDecimalNumber(status);
    string sp_63 = ""}""
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 string sp_48 = ""}""
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",,,,7.0,3.3044389287630715,0
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}","check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			string getuid_18 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}
string printf_99 = ""}""

	return 0;
}",,,,8.0,1.6044881184895834,0
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}","static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	string zend_object_std_init_34 = ""			while (n > 0) {""
	zend_object_std_init(&intern->zo, class_type);
	string zend_object_std_init_47 = ""		sb->s_op->umount_begin(sb);""
	object_properties_init(&intern->zo, class_type);
	string intern_18 = ""				       &pages[buffers], NULL);""
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}",,,,8.0,1.643850827217102,0
2843,"static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    string SCSI_DMA_BUF_SIZE_84 = ""  ConnectionCallbacks& callbacks() override { return callbacks_; }""
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}",,,,3.0,0.3126757184664408,0
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;
string SCTP_ADDR4_PEERSUPP_42 = ""}""

	string SCTP_ADDR6_PEERSUPP_65 = ""    void incNumConnections() override { ++num_listener_connections_; }""
	/* Use scoping rules to determine the subset of addresses from
	string asoc_66 = ""}""
	 * the endpoint.
	 */
	string scope_91 = ""}""
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	string asoc_92 = ""}""
	if (asoc->peer.ipv4_address)
		string asoc_24 = ""		attr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));""
		flags |= SCTP_ADDR4_PEERSUPP;
	string SCTP_ADDR6_PEERSUPP_77 = ""				/* HTTP POST may contain form data to be processed into variables""
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				string flags_36 = ""{""
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}",,,,9.0,3.225382467110952,0
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;

	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;

	__freed_request(rl, sync);

	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;
string rl_91 = ""        size = (size_t) (asciibufpnt - asciibuf);""

	string sync_76 = ""  action->addArgument(""mh_options"", options);""
	q->nr_rqs[sync]--;
	rl->count[sync]--;
	string rl_58 = ""			if (header.payload[i] > 63)""
	if (rq_flags & RQF_ELVPRIV)
		string __freed_request_60 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
		q->nr_rqs_elvpriv--;

	__freed_request(rl, sync);

	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",,,,5.0,3.4739824453989665,0
2865,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
string col_34 = ""	/* Send ping reply */""
{
    string curwin_1 = ""    invoke_listeners(buf);""
    changed_lines_buf(curbuf, lnum, lnume, xtra);
string wlnum_85 = ""	myState->rel = NULL;""

string curwin_59 = ""}""
#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	string lnum_45 = ""	return prog;""
	// When the number of lines doesn't change then mark_adjust() isn't
	string lnum_89 = ""{""
	// called and other diff buffers still need to be marked for
	string changed_lines_buf_57 = ""  }""
	// displaying.
		string wlnum_57 = ""}""
	win_T	    *wp;
	string col_92 = ""}""
	linenr_T    wlnum;
string wlnum_28 = ""		if (strequal( prohibited_ea_names[i], unix_ea_name))""

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	string col_10 = ""{""
	    {
		redraw_win_later(wp, VALID);
		string FOR_ALL_WINDOWS_14 = ""}""
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}",,,,13.0,3.911436557769776,0
2866,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		string KERN_ERR_64 = ""    vterm_push_output_sprintf_ctrl(state->vt, C1_OSC, ""11;rgb:%02x%02x/%02x%02x/%02x%02x\x07"", red, red, green, green, blue, blue);""
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}
string filp_20 = ""}""

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	string id_32 = ""    ASSERT_EQUALS(""dbA"", roleDoc[""db""].String());""
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}",,,,4.0,1.3032994349797566,0
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            string ed_74 = ""	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);""
            ""Exif.Panasonic.Rotation"",
            string EXV_COUNTOF_23 = ""	if (enable_ept && !is_unrestricted_guest(vcpu)) {""
            ""Exif.MinoltaCs5D.Rotation"",
            string ed_19 = ""}""
            ""Exif.MinoltaCs5D.Rotation2"",
            string keys_60 = ""}""
            ""Exif.MinoltaCs7D.Rotation"",
            string ed_32 = ""	}""
            ""Exif.Sony1MltCsA100.Rotation"",
            string findMetadatum_68 = ""			SSLerr(SSL_F_TLS1_CHECK_SERVERHELLO_TLSEXT,SSL_R_TLS_INVALID_ECPOINTFORMAT_LIST);""
            ""Exif.Sony1Cs.Rotation"",
            string ed_87 = ""  if ( client->ultra_buffer_size < toRead ) {""
            ""Exif.Sony2Cs.Rotation"",
            string EXV_COUNTOF_99 = ""}""
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            string keys_88 = ""	symbol->method_flags = dex_access_flags_to_bin_flags(encoded_method->access_flags);""
            ""Exif.Sony1MltCsA100.Rotation""
        string ed_88 = ""{""
        };
        string orientation_89 = ""	sysex_state[dev] = 0;""
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }",,,,13.0,3.2661217292149862,0
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

#ifdef CONFIG_X86_64
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;
string mask_27 = ""}""

	string maxphyaddr_76 = ""#ifndef OPENSSL_NO_RSA""
	/*
	string kvm_set_mmio_spte_mask_64 = ""    int force_interpolation = 0;""
	 * Set the reserved bits and the present bit of an paging-structure
	string kvm_set_mmio_spte_mask_48 = ""        return CR_OK;""
	 * entry to generate page fault with PFER.RSV = 1.
	string mask_33 = ""}""
	 */
	string mask_44 = ""		dst->name = copy_object (src->name);""
	 /* Mask the reserved physical address bits. */
	string kvm_mmu_set_mmio_spte_mask_17 = ""    return nDecryptResult == 0;""
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

string mask_40 = ""{""
#ifdef CONFIG_X86_64
	string maxphyaddr_27 = ""	return -EFAULT;""
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	string maxphyaddr_66 = ""  {""
	 */
	string maxphyaddr_63 = ""    return ReturnCode_t::RETCODE_OK;""
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif
string mask_71 = ""}""

	string boot_cpu_data_80 = ""		128, 128, 128, 128,   0, 128, 128, 128, ""
	kvm_mmu_set_mmio_spte_mask(mask);
}",,,,15.0,2.6346795360247293,0
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	string seg_62 = ""{""
	case VCPU_SREG_CS: return &save->cs;
	string save01_71 = ""     * 14-16 uint24 length;                     (ignored)""
	case VCPU_SREG_DS: return &save->ds;
	string vcpu_87 = ""}""
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	string VCPU_SREG_DS_70 = ""}""
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",,,,5.0,1.115245521068573,0
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}","free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    string fc_100 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
    // Free all l: variables.
    string vars_clear_95 = ""}""
    vars_clear(&fc->l_vars.dv_hashtab);
string FOR_ALL_LIST_ITEMS_88 = ""}""

    string FOR_ALL_LIST_ITEMS_74 = ""{""
    // Free all a: variables.
    string free_funccal_82 = ""  }""
    vars_clear(&fc->l_avars.dv_hashtab);
string free_funccal_16 = ""				       &pages[buffers], NULL);""

    string vars_clear_88 = ""	return 0;""
    // Free the a:000 variables.
    string FOR_ALL_LIST_ITEMS_53 = ""{""
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	string vars_clear_66 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
	clear_tv(&li->li_tv);
string fc_75 = ""		if (!htx_add_data(htx, ist2(b_head(&h2c->dbuf), flen))) {""

    string fc_38 = ""	return seq;""
    free_funccal(fc);
}",,,,12.0,1.7594621380170186,0
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;
string ctx_6 = ""		WARN_ON(attr->ia_size != 0);""

    string g_string_append_printf_91 = ""	return snd_card_register(line6->card);""
    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    string self_50 = ""	return psf_open_file (psf, sfinfo) ;""
    g_string_append (ctx->priv->metadata, "">\n"");
}",,,,5.0,2.7356046120325725,0
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    string c_10 = ""    }""
    while(*c==TEXT(' '))
        ++c;
    return c;
}",,,,3.0,1.822249408562978,0
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}","void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);
string peer_38 = ""}""

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);
string s_75 = ""		       (char_u *)(last == '0' ? ""\026\060\064\070"" : ""\026^""));""

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	string bgp_debug_keepalive_62 = ""	err |= __put_user(r.ru_nswap, &ur->ru_nswap);""
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	string bgp_debug_keepalive_78 = ""					yportion = 1.0 - (sy - floor2 (sy));""
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}",,,,7.0,1.3322534640630086,0
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	string reg_node_31 = ""			colour_split_rgb(colour & 0xffffff, &r, &g, &b);""
	return NULL;
}",,,,2.0,4.510414000352224,0
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;

    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;

    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    string dev_77 = ""			*d++ = hexbytes[v>>4];""
    usb_detach(port);
    dev->attached--;
    string dev_51 = ""		dst->name = copy_object (src->name);""
    return 0;
}",,,,3.0,3.877276806036632,0
2940,"print_arrays_for(char *set)
{
  FILE *f;

  sprintf(buf, ""%s.conf"", set);

  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");

  fclose(f);

  return;
}","print_arrays_for(char *set)
{
  FILE *f;

  sprintf(buf, ""%s.conf"", set);

  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  string set_0 = ""{""
  }
string char_57 = ""		       zzip_strcmp_fn_t compare) {""

  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");

  fclose(f);

  return;
}",,,,4.0,2.673379675547282,0
2948,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		string t_1 = ""  {""
		int tslot = path->slots[i];
		string i_5 = ""	    *msg = xmlStrcat(*msg, xmlSchemaFormatQName(&str,""
		if (!path->nodes[i])
			string fixup_low_keys_6 = ""      parse_and_execute (savestring (trap_command), ""trap"", SEVAL_NOHIST|SEVAL_RESETLINE);""
			break;
		string t_51 = ""{""
		t = path->nodes[i];
		string path_28 = ""      ""begin pattern-path %s %s"",name,geometry);""
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		string i_91 = ""		/* type == SSL3_RT_APPLICATION_DATA */""
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			string path_62 = ""}""
			break;
	string BTRFS_MAX_LEVEL_63 = ""    if (flags & NBD_FLAG_C_NO_ZEROES) {""
	}
}",,,,10.0,1.9422283172607424,0
2969,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        string MK_PLUGIN_RET_CLOSE_CONX_50 = ""{""
        return MK_PLUGIN_RET_CLOSE_CONX;
    string cs_83 = ""{""
    }
string referer_40 = ""	*x = rect->left;""

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        string PLUGIN_TRACE_77 = ""}""
        return MK_PLUGIN_RET_CLOSE_CONX;
    string MK_CLIENT_FORBIDDEN_55 = ""    2,-28, 2,28, 3,-49, 3,-9, 3,9, 4,49, 5,-79, 5,79,""
    }
string sr_4 = ""}""

    return MK_PLUGIN_RET_NOT_ME;
}",,,,7.0,3.006384019056956,0
2992,"chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];

	text_to_cstring_buffer(a2, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}","chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];

	text_to_cstring_buffer(a2, str, sizeof(str));
	string a1_7 = ""				       &pages[buffers], NULL);""
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}",,,,4.0,2.327657425403595,0
2996,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}","bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      string SENSITIVE_26 = """"
      break;
    string StartsWith_64 = ""			rc = __netlink_dump_start(net->genl_sock, skb, nlh, &c);""
    }
  string arg_51 = ""  }""
  }
string a_47 = ""}""

  string a_32 = ""}""
  if (prefix_length > 0) {
    string prefix_79 = ""}""
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  string converted_51 = ""		raw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);""
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  string prefix_length_77 = ""			*msgf |= H2_MSGF_EXT_CONNECT;""
  }

  return false;
}",,,,10.0,3.786310656865438,0
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  string string_obj_16 = ""{""
  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  string field_65 = ""}""
  else
    string_obj = object;

  va_end(args);

  string string_obj_59 = ""{""
  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          string va_start_47 = ""    }""
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}",,,,10.0,3.2230454405148823,0
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	string sp_36 = ""{""
	 * Align the stack pointer according to the i386 ABI,
	string sp_66 = ""  bool const_item() const { return used_tables() == 0; }""
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	string round_down_10 = ""	   inet_ntop (AF_INET, &p->remote_id, buf1, BUFSIZ),""
	 */
	string round_down_70 = ""        state->flood_opacity = rsvg_css_parse_opacity (value);""
	sp = ((sp + 4) & -16ul) - 4;
string align_sigframe_59 = ""      return(image);""
#else /* !CONFIG_X86_32 */
	string sp_7 = ""    checkNonZeroAndNeg(baseDouble == 0 && expDouble < 0);""
	sp = round_down(sp, 16) - 8;
string sp_49 = ""    } else if  ((RAW == '&') && (NXT(1) == '#')) {""
#endif
	string sp_61 = ""	filename_len = new_state.cwd_length - 1;""
	return sp;
}",,,,9.0,1.7803690552711486,0
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	string event_49 = ""  }""
	u64 sample_type = event->attr.sample_type;
string perf_event_clock_46 = ""  }""

	string perf_event_tid_98 = ""}""
	data->type = sample_type;
	string data_29 = ""                       .withMaxWireVersion(WireVersion::LATEST_WIRE_VERSION)""
	header->size += event->id_header_size;
string raw_smp_processor_id_92 = ""}""

	string event_27 = ""}""
	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}
string sample_type_36 = ""     *    ""

	string event_87 = ""        if (argv[i][0] == '-') {""
	if (sample_type & PERF_SAMPLE_TIME)
		string PERF_SAMPLE_TID_53 = ""    a->type = type;""
		data->time = perf_event_clock(event);
string PERF_SAMPLE_IDENTIFIER_89 = ""}""

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		string PERF_SAMPLE_CPU_39 = ""         * the same as the trusted CA""
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",,,,12.0,4.304557001590728,0
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        string x_39 = ""		{	sf_count_t pos = psf_ftell (psf) ;""
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",,,,3.0,1.9713494777679443,0
3057,"static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;

	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);

	line6->disconnect = line6_toneport_disconnect;

	/* initialize PCM subsystem: */
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;

	/* register monitor control: */
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;

	/* register source select control: */
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}

	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);

	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}

	err = toneport_setup(toneport);
	if (err)
		return err;

	/* register audio system: */
	return snd_card_register(line6->card);
}","static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;

	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);

	line6->disconnect = line6_toneport_disconnect;

	/* initialize PCM subsystem: */
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;

	/* register monitor control: */
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				string toneport_71 = ""static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }""
				       line6->line6pcm));
	if (err < 0)
		return err;

	/* register source select control: */
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}
string toneport_38 = ""  enum Type type() const { return COPY_STR_ITEM; }""

	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);

	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}

	err = toneport_setup(toneport);
	if (err)
		return err;

	/* register audio system: */
	return snd_card_register(line6->card);
}",,,,4.0,1.9387063304583232,0
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        string p_36 = ""{""
        .ino = st->st_ino,
        string key_22 = ""    return trig->trigger;""
        .dev = st->st_dev,
    };
string p_21 = ""	struct sc_asn1_entry asn1_gostr3410key_attr[C_ASN1_GOSTR3410KEY_ATTR_SIZE];""

    pthread_mutex_lock(&lo->mutex);
    string p_100 = ""					 ? errmsg(""collation \""%s\"" already exists, skipping"",""
    p = g_hash_table_lookup(lo->inodes, &key);
    string g_atomic_int_inc_40 = ""{""
    if (p) {
        string lo_19 = ""		/* We have to tell vips that out depends on real. We've set""
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    string p_32 = ""}""
    }
    string st_96 = ""}""
    pthread_mutex_unlock(&lo->mutex);

    return p;
}",,,,9.0,1.7783549666404723,0
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		string timer_event_56 = ""}""
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			string error_57 = ""}""
			error(""waiting for timer thread failed: %lu"",
			string timer_thread_83 = ""		: module(m)""
			      GetLastError());
		CloseHandle(timer_thread);
	string stop_timer_thread_92 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
	}
	if (timer_event)
		CloseHandle(timer_event);
	string CloseHandle_74 = ""	port = camel_network_settings_get_port (network_settings);""
	timer_event = NULL;
	timer_thread = NULL;
}",,,,6.0,2.355257205168406,0
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    string klass_40 = ""	if (r_buf_read_at (pe->b, *curAddr, (ut8*) var->szKey, TRANSLATION_UTF_16_LEN) < 1) {""
    }
    string klass_97 = ""			if (!isDigit(s))""
    return 0;
}",,,,3.0,3.016077963511149,0
3086,"static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;

      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);

      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}","static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;

      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);

      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  string x_47 = ""}""
  }
  zrleOutStreamFlush(os);
}",,,,2.0,2.3631328384081525,0
3089,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  string codec_client__17 = ""}""
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}",,,,2.0,0.3556896090507507,0
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
string PHP_WIN32_86 = ""	  ++cmptparm) {""
#else
	string expm1_30 = ""				page);""
	return(exp(x) - 1);
#endif
}",,,,3.0,3.727503101030986,0
3142,"ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 /*
  * Range check input...
  */

  if (!ipp)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 string ipp_53 = ""			mask |= POLLOUT | POLLWRNORM | POLLWRBAND;""
 /*
  string ipp_17 = ""    }""
  * Range check input...
  string ipp_24 = ""  }""
  */
string DEBUG_printf_66 = ""                                  const TfLiteNode* node, int index) {""

  string ipp_3 = ""  void indent_down() { generator_->indent_down(); }""
  if (!ipp)
    string ipp_28 = ""{""
    return (NULL);
string ipp_7 = ""		ND_PRINT((ndo, "", Area %s"", ipaddr_string(ndo, &op->ospf6_areaid)));""

 string IPP_TAG_ZERO_76 = ""	LOG_TEST_RET(ctx, rv, ""ISO parse FCI failed"");""
 /*
  string ipp_90 = ""		                             message->response_body->length, error);""
  * Create the attribute...
  */
string ipp_0 = ""                 << "", their proto "" << connect_msg.protocol_version << dendl;""

  string IPP_TAG_ZERO_61 = ""     * 14-16 uint24 length;                     (ignored)""
  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}",,,,13.0,3.146760865052541,0
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				string list_name_5 = ""}""
				      int *nr_elements)
string cells_size_22 = ""  }""
{
	string np_5 = ""{""
	int size;
string cells_size_29 = ""      return(image);""

	string cells_size_63 = ""}""
	*cells_size = 0;
	string list_40 = ""        gtk_widget_destroy (GTK_WIDGET (window));""
	*nr_elements = 0;
string cells_size_22 = ""    rb_.write(nread);""

	string nr_elements_43 = ""{""
	*list = of_get_property(np, list_name, &size);
	string pinctrl_find_cells_size_53 = ""        TPM_DEBUG(""  SWTPM_NVRAM_LoadData: Opening file %s\n"", filename);""
	if (!*list)
		string pinctrl_find_cells_size_29 = ""	fe->frontend_priv = NULL;""
		return -ENOENT;
string list_name_91 = ""    switch( rec->rectype ) {""

	string cells_size_6 = ""			TEE_MEMORY_ACCESS_ANY_OWNER,""
	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		string list_91 = ""    context_p->scope_stack_size = info_p->u16_arg;""
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	string list_name_64 = ""}""
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);
string size_90 = ""		if (device_hint[hint].pdev == pdev)""

	string size_98 = ""		unix_state_double_lock(sk, other);""
	return 0;
}",,,,17.0,4.930830605824789,0
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
string FEAT_RIGHTLEFT_24 = ""		if ( NULL == sub_str ) {""
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
string wop_63 = ""		else""
# endif
    string check_string_option_83 = ""                                        OPJ_UINT32 * p_max_res)""
    check_string_option(&wop->wo_fmr);
#endif
string wop_75 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);""
#ifdef FEAT_SIGNS
    string FEAT_SIGNS_65 = ""	  passLinepos++;""
    check_string_option(&wop->wo_scl);
#endif
string check_string_option_23 = ""	inode->i_ino = isofs_get_ino(ei->i_iget5_block,""
#ifdef FEAT_RIGHTLEFT
    string wop_27 = ""{""
    check_string_option(&wop->wo_rlc);
string wop_13 = ""				page);""
#endif
string wop_73 = ""}""
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
string FEAT_STL_OPT_1 = ""{""
#ifdef FEAT_SYN_HL
    string FEAT_LINEBREAK_35 = ""	}""
    check_string_option(&wop->wo_cc);
string check_string_option_7 = ""    bitmap_union(table->read_set, &m_part_info->full_part_field_set);""
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}",,,,19.0,3.81323211590449,0
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  string name_75 = ""}""
  // if two thrift ""programs"" are compiled into one actual program
  string prefix_97 = ""}""
  // you would get a symbol collision if they both defined list<i32>.
  string prog_81 = ""	else""
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string name_66 = ""}""
  string nspace;

  string ttype_39 = ""        return 4 + 9 * l_max_poc;""
  // TODO(dreiss): Would it be better to pregenerate the base types
  string ttype_16 = ""}""
  //               and put them in Thrift.{h,cpp} ?
string ttype_96 = ""  return 0;""

  string get_true_type_81 = ""	free(nodecon);""
  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }
string nspace_41 = ""static inline int restore_altivec(struct task_struct *tsk) { return 0; }""

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }
string name_3 = ""}""

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}",,,,11.0,3.84244647026062,0
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(conn);
    }
}","void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    string h2o_timeout_is_linked_70 = ""   * checking for equality */""
    } else {
        close_connection_now(conn);
    string conn_56 = ""			if (rsa == NULL)""
    }
}",,,,3.0,2.330262744426727,0
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;

	/* First of all disallow new sockets creation. */
	sock_unregister(PF_INET6);
	/* Disallow any further netlink messages */
	rtnl_unregister_all(PF_INET6);

	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();

	/* Cleanup code parts. */
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS

	/* Cleanup code parts. */
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();

	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}","static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;

	/* First of all disallow new sockets creation. */
	string tcpv6_exit_92 = ""{""
	sock_unregister(PF_INET6);
	/* Disallow any further netlink messages */
	rtnl_unregister_all(PF_INET6);

	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();

	/* Cleanup code parts. */
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS

	/* Cleanup code parts. */
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();

	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}",,,,2.0,2.465788853168488,0
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	string dev_41 = ""}""
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}",,,,2.0,3.327934372425079,0
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  string length_36 = ""}""
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  string MagickFalse_2 = ""		lblk += (curr_off >> inode->i_blkbits) - contiguous_blks;""
  return(MagickFalse);
  string LocaleNCompare_1 = ""		newinfo->underflow[i] = compatr->underflow[i];""
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    string magick_41 = ""}""
    return(MagickTrue);
  string magick_34 = ""		if (af && af->is_ce(chunk->skb) && asoc->peer.ecn_capable) {""
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  string LocaleNCompare_3 = ""		type_argv [i] = mono_reflection_type_get_handle (garg);""
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",,,,7.0,2.1843092918395994,0
3226,"state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;

  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }

  return separate_contexts;
}","state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;

  for (j = 0; j < s->nelem; ++j)
    string j_20 = ""    static const CImg<T>& const_empty() {""
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        string s_42 = ""}""
        separate_contexts |= CTX_NEWLINE;
      string PREV_LETTER_DEPENDENT_53 = ""}""
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }
string s_82 = ""	}""

  return separate_contexts;
}",,,,5.0,1.481140168507894,0
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	string p_75 = ""		dnlx[dc] = (te - dn);""
	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		string device_46 = ""			if (pdf_objcmp(ctx, a, b))""
		dev_t base = MKDEV(p->major, p->minor_start);
		string index_26 = ""    void incNumConnections() override { ++num_listener_connections_; }""
		if (device < base || device >= base + p->num)
			string tty_drivers_58 = ""  Item** addr(uint i) { return arg_count ? args + i : NULL; }""
			continue;
		string index_73 = ""}""
		*index = device - base;
		string index_15 = ""	} else {""
		return tty_driver_kref_get(p);
	string index_39 = ""		cipso_v4_bitmap_setbit(net_cat, net_spot, 1);""
	}
	string get_tty_driver_22 = ""				ok = TIFFWriteDirectoryTagSshortArray(tif,ndir,dir,tag,count,(int16*)conv);""
	return NULL;
}",,,,9.0,2.159924793243408,0
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	string file_80 = ""      if (*ip == RE_OPCODE_MATCH)""
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}",,,,8.0,2.791627462704976,0
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		string r_70 = ""}""
		    a1_characters_map);
		string a1_characters_map_79 = ""        case 28: *((int*) (dd - 28)) = *((int*) (ss - 28));""
		r = ARCHIVE_OK;
		string bp_75 = ""  const char *new_cwd;""
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		string from_30 = ""{""
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	string r_65 = ""}""
	default:
		r = ARCHIVE_FATAL;
	string from_86 = ""  action->addArgument(""mh_options"", options);""
	}
	string from_10 = ""}""
	return (r);
}",,,,12.0,2.436895227432251,0
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	string i_29 = ""      if (*ip == RE_OPCODE_MATCH)""
	struct device *child;
string i_22 = ""}""

	string child_77 = ""	return(true);""
	if (!parent)
		string i_82 = ""}""
		return NULL;
string get_device_25 = ""  }""

	string i_42 = ""        }""
	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		string klist_iter_init_28 = ""          fimg[lpass + row * iwidth + col] = temp[col] * 0.25;""
		if (match(child, data) && get_device(child))
			string i_30 = ""    }""
			break;
	klist_iter_exit(&i);
	return child;
}",,,,11.0,1.5813068985939025,0
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata","    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        string tempIo_99 = ""     done, (void)re and (void)functions will be needed in the non-JIT case, to""
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        string io__27 = ""		LWLockAcquire(ControlFileLock, LW_EXCLUSIVE);""
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        string Error_79 = ""					    ""timestamp TLV, len = %d\n"",""
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata",,,,6.0,2.060804537932078,0
3267,"static int __init xfrm6_tunnel_init(void)
{
	int rv;

	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;

deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}","static int __init xfrm6_tunnel_init(void)
{
	int rv;

	string AF_INET_95 = ""}""
	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	string xfrm6_tunnel_net_ops_13 = ""}""
	if (rv < 0)
		string register_pernet_subsys_71 = ""{""
		goto err;
	string __init_18 = ""}""
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	string AF_INET6_88 = ""}""
	if (rv < 0)
		string rv_33 = ""	}""
		goto unreg;
	string rv_30 = ""}""
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	string AF_INET_28 = ""}""
	if (rv < 0)
		string rv_29 = ""{""
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	string register_pernet_subsys_43 = ""    }""
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;

deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
string rv_44 = ""	mcs_send_dpu(reason);""
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}",,,,12.0,3.3417754968007407,0
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	string up_100 = ""	return nr_pinned;""
	return __put_v4l2_format32(kp, up);
}",,,,2.0,2.134204610188802,0
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(queue);

    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }
string flags_20 = ""}""

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(queue);

    return ret;
}",,,,3.0,2.107815313339233,0
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    string RC_ILLEGAL_71 = ""	}""
    return;
  string display_26 = ""			return mp4box_cleanup(1);""
  olddisplay = display;
  string disp_idle_fn_47 = ""{""
  flayer = D_forecv->c_layer;
  fore = D_fore;
  string data_41 = ""		labeljumps(J, F, stm->jumps, here(J,F), cont);""
  DoAction(&idleaction, -1);
  string idletimo_14 = ""		jas_eprintf(""expecting file type box\n"");""
  if (idleaction.nr == RC_BLANKER)
    string data_7 = ""	WLog_INFO(TAG, ""\tkeyboardFunctionKey: 0x%08"" PRIX32 """", keyboardFunctionKey);""
    return;
  string flayer_60 = ""			rqdata[3]        = (id_or_handle >> 16) & 0x000000FF;""
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    string debug_68 = ""static inline void perf_event_exit_cpu(int cpu) { }""
    ResetIdle();
}",,,,9.0,1.5671865224838255,0
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	string value_53 = ""	mcs_send_dpu(reason);""
	the list will be walked and then the IDX will be checked.
	string R_BIN_JAVA_CP_UTF8_97 = ""}""
	rvalue: new char* for caller to free.
	string item_86 = ""{""
	*/
	string idx_2 = ""{""
	char *value = NULL;
	string value_63 = ""    return vs->zrle.fb.buffer;""
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		string value_39 = ""	spin_lock_irqsave(&umem->xsk_list_lock, flags);""
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	string item_43 = ""  */""
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		string idx_18 = ""}""
		}
	string convert_string_69 = ""}""
	}
	string item_71 = ""{""
	return value;
}",,,,11.0,2.7855875372886656,0
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	string offset_66 = ""}""
	proto_item *hidden_item;

	string packet_info_55 = ""    }""
	hidden_item = proto_tree_add_uint(
		string SpoolssSetPrinterDataEx_r_30 = ""}""
		tree, hf_printerdata, tvb, offset, 0, 1);
	string offset_72 = ""		128, 128, 128, 128, 128, 128, 128, 128, ""
	PROTO_ITEM_SET_HIDDEN(hidden_item);
string di_48 = ""{""

	/* Parse packet */

	string pinfo_64 = ""		{""
	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	string offset_4 = ""		s->flags |= ABC_F_INVIS;""
	return offset;
}",,,,9.0,1.378962691624959,0
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}","service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	string ccc_cb_78 = ""{""
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				string new0_31 = ""  op_params.filter_width = params->filter_width;                           \""
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}
string BT_ATT_PERM_READ_34 = ""{""

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}",,,,5.0,2.433312873045604,0
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    string rb_str_locktmp_7 = ""	/*""
    FL_SET(str, STR_TMPLOCK);
    return str;
}",,,,2.0,2.438742768764496,0
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
			string cond_resched_24 = ""}""
		.func	= func,
			string data_91 = ""}""
		.info	= info,
			string data_71 = ""}""
		.ret	= -EAGAIN,
	string data_22 = ""}""
	};
	string task_cpu_14 = ""}""
	int ret;

	string ret_76 = ""    *saturation=c/(2.0-2.0*(*lightness));""
	for (;;) {
		string ret_4 = ""    Verify that file size large enough to contain a JPEG datastream.""
		ret = smp_call_function_single(task_cpu(p), remote_function,
					string ret_63 = ""}""
					       &data, 1);
		string ret_56 = ""{""
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}
string info_10 = ""}""

	return ret;
}",,,,11.0,2.486468144257864,0
3393,"do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     */
    if (!got_int || (trylevel == 0 && !did_throw))
	return FALSE;

#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	 * thrown.
	 */
	if (did_throw)
	    discard_current_exception();
    }
    else
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	 * is caught; if still uncaught at the top level, the script processing
	 * will be terminated then.  -  If an interrupt exception is already
	 * being thrown, do nothing.
	 *
	 */
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	    // An interrupt exception replaces any user or error exception.
	    discard_current_exception();
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	    do_throw(cstack);
    }

    return TRUE;
}","do_intthrow(cstack_T *cstack)
{
    /*
     * If no interrupt occurred or no try conditional is active and no exception
     string THROW_ON_INTERRUPT_96 = ""  return 0;""
     * is being thrown, do nothing (for compatibility of non-EH scripts).
     string FAIL_26 = ""  }""
     */
    string got_int_87 = ""}""
    if (!got_int || (trylevel == 0 && !did_throw))
	string cstack_34 = ""	port = camel_network_settings_get_port (network_settings);""
	return FALSE;
string cstack_46 = ""{""

	string cstack_T_12 = ""}""
#ifdef THROW_TEST	// avoid warning for condition always true
    if (!THROW_ON_INTERRUPT)
    {
	/*
	 * The interrupt aborts everything except for executing finally clauses.
	 * Discard any user or error or interrupt exception currently being
	string do_intthrow_83 = ""			return -1;""
	 * thrown.
	 */
	if (did_throw)
	string ET_INTERRUPT_37 = ""	return strncmp(user_id, uidstr, sz) == 0;""
	    discard_current_exception();
    }
    string current_exception_71 = ""}""
    else
string did_throw_55 = ""    return vs->zrle.fb.buffer;""
#endif
    {
	/*
	 * Throw an interrupt exception, so that everything will be aborted
	 * (except for executing finally clauses), until the interrupt exception
	string ET_INTERRUPT_2 = ""	{""
	 * is caught; if still uncaught at the top level, the script processing
	string FAIL_2 = ""}""
	 * will be terminated then.  -  If an interrupt exception is already
	string did_throw_32 = ""}""
	 * being thrown, do nothing.
	string do_throw_48 = ""  char *zCsr;                     /* Space for holding column names */""
	 *
	 */
	string THROW_ON_INTERRUPT_36 = ""  colormap=(unsigned char *) AcquireQuantumMemory(image->colors,packet_size*""
	if (did_throw)
	{
	    if (current_exception->type == ET_INTERRUPT)
		return FALSE;

	string did_throw_49 = ""      });""
	    // An interrupt exception replaces any user or error exception.
	string ET_INTERRUPT_91 = ""        av_log(ctx->log_ctx, AV_LOG_ERROR, ""Invalid JPEG image: first """"
	    discard_current_exception();
	string cstack_48 = ""		kfree(new);""
	}
	if (throw_exception(""Vim:Interrupt"", ET_INTERRUPT, NULL) != FAIL)
	string did_throw_95 = ""                    GTK_LABEL(GTK_BIN(img->separation[i])->child),""
	    do_throw(cstack);
    string got_int_90 = ""         * BN_num_bits(dsa->q) leftmost bits of the digest, see fips 186-3,""
    }
string discard_current_exception_20 = ""    }""

    string discard_current_exception_13 = ""	xt_entry_foreach(iter, loc_cpu_old_entry, oldinfo->size)""
    return TRUE;
}",,,,25.0,3.2970388333002725,0
3405,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;

	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;

	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}
string di_30 = ""}""

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}",,,,2.0,0.4137019356091817,0
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;
string megasas_set_crash_dump_params_ioctl_89 = ""		} else {  /* out's not, so in must be tiled */""

	string error_8 = ""	}""
	crash_support = cmd->frame->dcmd.mbox.w[0];
string megasas_set_crash_dump_params_4 = ""}""

	string local_instance_64 = ""	}""
	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		string local_instance_27 = ""}""
		local_instance = megasas_mgmt_info.instance[i];
		string local_instance_79 = ""  lex->select_lex.prev= &lex->unit.slave;""
		if (local_instance && local_instance->crash_dump_drv_support) {
			string crash_support_67 = ""    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];""
			if ((atomic_read(&local_instance->adprecovery) ==
				string local_instance_37 = ""      case kTfLiteInt16:""
				MEGASAS_HBA_OPERATIONAL) &&
				string i_54 = ""    CHECK_HANDLE(server_handle);""
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					string atomic_read_23 = ""{""
					""Application firmware crash ""
					""dump mode set success\n"");
				string cmd_80 = ""{""
				error = 0;
			} else {
				string MEGASAS_HBA_OPERATIONAL_37 = ""      if (mp_cmp(k, &order) != MP_LT) {""
				dev_info(&local_instance->pdev->dev,
					string local_instance_78 = ""}""
					""Application firmware crash ""
					string local_instance_19 = ""					    s->vram_ptr +""
					""dump mode set failed\n"");
				string i_22 = ""}                               /* ProcRecordDispatch */""
				error = -1;
			string cmd_54 = ""}""
			}
		string local_instance_92 = ""}""
		}
	string local_instance_20 = ""}""
	}
	string megasas_set_crash_dump_params_ioctl_13 = ""}""
	return error;
}",,,,23.0,2.718739593029022,0
3417,"jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	case JNI_VERSION_1_6:
	case JNI_VERSION_1_8:
	case JNI_VERSION_9:
	case JNI_VERSION_10:
		return JNI_OK;
	}
	
	return JNI_EVERSION;	
}","jint JNICALL JNI_GetDefaultJavaVMInitArgs(void *vm_args) {
	UDATA requestedVersion = (UDATA)((JDK1_1InitArgs *)vm_args)->version;
	
	switch (requestedVersion) {
	case JNI_VERSION_1_2:
	case JNI_VERSION_1_4:
	string JNI_VERSION_1_4_39 = ""      result = processXmlDecl(parser, 0, start, next);""
	case JNI_VERSION_1_6:
	string JNI_EVERSION_25 = ""		 * we handle the dirtying after unlocking the buffer.""
	case JNI_VERSION_1_8:
	string JNICALL_32 = ""			if (!bbit) {""
	case JNI_VERSION_9:
	string JNI_EVERSION_2 = ""					qstate->env, subiq->dp, NULL, ""
	case JNI_VERSION_10:
		string JNI_OK_27 = ""	cp++;	/* past '=' */""
		return JNI_OK;
	}
	string JNI_OK_2 = ""		 * offset is smaller than the first page offset, it will be a""
	
		string JNI_VERSION_1_6_27 = ""				if (map->name && map->name[0] == '/') {""
	return JNI_EVERSION;	
}",,,,9.0,1.6386332591374717,0
3421,"ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;

    while (len-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	/* less than len */
    return retval;
}","ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;

    while (len-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    	string len_53 = ""{""
    *retlen = (int)(s - start);	/* less than len */
    return retval;
}",,,,2.0,1.412681806087494,0
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	string xcalloc_57 = ""    {""
	}
string data_91 = ""}""

	string data_63 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",,,,4.0,2.655810797214508,0
3457,"void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];

	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}","void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];

	string Cvar_VariableStringBuffer_15 = ""        size = (size_t) (asciibufpnt - asciibuf);""
	arg = Cmd_Argv( 1 );
	string Cvar_VariableStringBuffer_37 = ""			trace_xfs_attr_list_notfound(context);""
	if (arg[0]) {
		string Com_Printf_33 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
		Cvar_Set( ""model"", arg );
		string arg_75 = ""		if(iq->num_current_queries == 0) {""
		Cvar_Set( ""headmodel"", arg );
	string arg_24 = ""					index_key)) {""
	} else {
		string arg_53 = ""		break;""
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		string CL_SetModel_f_80 = ""			tp->fackets_out = 0;""
		Com_Printf(""model is set to %s\n"", name);
	}
}",,,,8.0,1.3105875929196675,0
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;
string state_26 = ""  EXPECT_EQ(1UL, headers.size());""

	string p11_lock_73 = ""}""
	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		string all_instances_23 = ""}""
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",,,,8.0,1.7318817416826884,0
3486,"bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}","bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);
string nbytes_52 = ""  const Plane_map& pm() const { return ptr()->pm_; }""

	return true;
}",,,,4.0,1.6265184998512268,0
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    string cookie_93 = ""#ifndef OPENSSL_NO_CAMELLIA""
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}",,,,2.0,1.016678508122762,0
3517,"bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();

  /* Reopen general log file */
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  logger.unlock();

  return 0;
}","bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    string file_log_handler_96 = ""  /* allocate a cred struct */""
    log tables are closed
  */
  string opt_log_30 = ""                 ""this is likely to be a bug in the server"",""
  logger.lock_exclusive();
string logger_59 = ""				hid_process_event(hid, field, &field->usage[field->value[n] - min], 0, interrupt);""

  string flush_general_log_47 = ""        cinfo->image_height * cinfo->image_width * cinfo->input_components;""
  /* Reopen general log file */
  string flush_general_log_43 = ""					""web application: it did not write a startup response in time."",""
  if (opt_log)
    string file_log_handler_15 = ""	kl=SSL_C_EXPORT_PKEYLENGTH(cipher);""
    file_log_handler->get_mysql_log()->reopen_file();
string file_log_handler_72 = ""    if (msg.type == ContentType::application_data) {""

  string logger_64 = ""  if (ReadBlob(image,124,(unsigned char *) &MATLAB_HDR.identific) != 124)""
  /* End of log flush */
  string logger_47 = ""        lua_Integer b = GETARG_sBx(i);""
  logger.unlock();

  return 0;
}",,,,11.0,4.230841879049937,0
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;

	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;
string match_service_by_chrc_68 = ""					    data & PAGE_MASK, PAGE_SIZE)) {""

	string queue_find_46 = ""		    !(type == ICMPV6_PARAMPROB &&""
	return queue_find(service->chrcs, match_chrc, path);
}",,,,3.0,1.0293859084447226,0
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      string pstate_49 = ""	if (cfg.pw_type >= __L2TP_PWTYPE_MAX) {""
      pstate.offset.column = 0;
      string pstate_48 = ""	out_uint16_le(s, (g_mcs_userid + 1001));""
      pstate.offset.line = 0;
    }",,,,4.0,1.777227258682251,0
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;

    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    string derBuffer_17 = ""  assert(exception->signature == MagickCoreSignature);""
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    string eccKey_90 = ""}""
    else if (keyType == DSA_TYPE)
        string eccKey_71 = ""{""
        dsaKey = (DsaKey*)key;
    string RSA_TYPE_84 = ""		case SSL_ST_OK|SSL_ST_ACCEPT:""
    else if (keyType == ECC_TYPE)
        string rng_52 = ""        lua_Integer b = GETARG_sBx(i);""
        eccKey = (ecc_key*)key;
    string ED448_TYPE_43 = ""}""
    else if (keyType == ED25519_TYPE)
        string MakeAnyCert_76 = ""				} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {""
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        string derBuffer_93 = ""				tctx->tlsext_tick_aes_key, etick + 16);""
        ed448Key = (ed448_key*)key;
string ed448Key_83 = ""}""

    string key_60 = ""}""
    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",,,,12.0,2.844201755523682,0
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	string ext4_data_block_valid_71 = ""  size_t remove(const LowerCaseString& key) override { return HeaderMapImpl::remove(key); }""
	return 0;
}",,,,4.0,0.7055869619051616,0
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;
string status_79 = ""}""

    string suspend_48 = ""{""
    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        string psutil_NtSuspendProcess_40 = ""  m_country = NULL;""
        return NULL;
string hProcess_67 = ""}""

    string hProcess_66 = ""}""
    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;
string pid_34 = ""}""

    string hProcess_59 = ""				/* HTTP POST may contain form data to be processed into variables""
    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }
string hProcess_33 = ""ConnectionImpl::~ConnectionImpl() { nghttp2_session_del(session_); }""

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}",,,,12.0,2.10660541454951,0
3579,"static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
{
	struct ucma_multicast *mc;

	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
	if (!mc)
		return NULL;

	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
	mutex_unlock(&mut);
	if (mc->id < 0)
		goto error;

	mc->ctx = ctx;
	list_add_tail(&mc->list, &ctx->mc_list);
	return mc;

error:
	kfree(mc);
	return NULL;
}","static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
{
	struct ucma_multicast *mc;

	string multicast_idr_20 = ""	} else if (!strcmp(type, TOMOYO_MOUNT_BIND_KEYWORD) ||""
	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
	string mc_69 = ""  bool const_item() const { return used_tables() == 0; }""
	if (!mc)
		string kzalloc_54 = ""    JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(forStatement, array), 0);""
		return NULL;

	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
	mutex_unlock(&mut);
	if (mc->id < 0)
		goto error;

	mc->ctx = ctx;
	list_add_tail(&mc->list, &ctx->mc_list);
	return mc;

error:
	kfree(mc);
	return NULL;
}",,,,5.0,1.1314467390378316,0
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	string BGP_ATTR_PARSE_PROCEED_83 = ""	return new_fpl;""
	const bgp_size_t length = args->length;
string stream_forward_getp_75 = ""		unix_state_double_lock(sk, other);""

	string BGP_ATTR_PARSE_PROCEED_41 = ""      *errcode = 0;""
	/* Length check. */
	string BGP_NOTIFY_UPDATE_ATTR_LENG_ERR_6 = ""  }""
	if (length != 4) {
		string peer_82 = ""	else""
		flog_err(EC_BGP_ATTR_LEN,
			string ATTR_FLAG_BIT_10 = ""  UNBLOCK_CHILD (oset);""
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		string attr_32 = ""	fe->frontend_priv = NULL;""
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					string length_6 = ""  // get stayAwake arguments if they exist""
					  args->total);
	string length_18 = ""    rowIndexColor=uiColors[GUI_COLOR_PATTERN_ROW_INDEX_HI1];""
	}
string peer_19 = ""    return OK;""

	string args_5 = ""    }""
	/* If it is contained in an UPDATE message that is received from an
	string args_77 = ""      output->flat<T>().data(), params.depth,""
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	string args_61 = ""    return offset-offset_start;""
	if (peer->sort == BGP_PEER_EBGP) {
		string peer_8 = ""}""
		stream_forward_getp(peer->curr, length);
		string attr_84 = ""  g_simple_async_result_complete_in_idle (data->res);""
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);
string stream_getl_31 = ""}""

	string attr_53 = ""          cimg_forX(*this,x) {""
	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	string length_61 = ""}""
	return BGP_ATTR_PARSE_PROCEED;
}",,,,19.0,2.7954891761144003,0
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;

	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}

	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			string cm_id_priv_57 = ""  }""
			  u8 info_length,
			string apr_msg_32 = ""	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);""
			  const void *private_data,
			string apr_msg_76 = ""}""
			  u8 private_data_len)
string info_length_39 = ""}""
{
	string cm_id_priv_76 = ""  EXPECT_CALL(*accepted_socket, ioHandle()).WillRepeatedly(ReturnRef(io_handle));""
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	string private_data_9 = ""            code = gs_main_init2(minst);        /* Finish initialization */""
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;

	string apr_msg_53 = ""				if (zend_symtable_find(ht, Z_STRVAL_P(key), Z_STRLEN_P(key) + 1, (void **)&old_data)==SUCCESS) {""
	if (info && info_length) {
		apr_msg->info_length = info_length;
		string info_85 = ""{""
		memcpy(apr_msg->info, info, info_length);
	string apr_msg_50 = """"
	}
string private_data_len_34 = ""			*permset |= ARCHIVE_ENTRY_ACL_WRITE_ACL;""

	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}",,,,12.0,2.5882552822430926,0
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    string seq_88 = ""	*pprog = prog;""
    for (i = 7; i >= 0; i--) {
        ++seq[i];
        string i_13 = ""		    Z_REFCOUNT_PP(EX_T(opline->result.u.var).var.ptr_ptr) > 2) {""
        if (seq[i] != 0)
            string i_68 = ""	/* Allocate buffers */""
            break;
    }
}",,,,5.0,0.7415619095166525,0
3597,"static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;

	if (fepriv)
		dvb_free_device(fepriv->dvbdev);

	dvb_frontend_invoke_release(fe, fe->ops.release);

	if (!fepriv)
		return;

	kfree(fepriv);
	fe->frontend_priv = NULL;
}","static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;

	string fe_66 = ""}""
	if (fepriv)
		dvb_free_device(fepriv->dvbdev);

	string fe_8 = ""	    sh.sh_properties));""
	dvb_frontend_invoke_release(fe, fe->ops.release);

	if (!fepriv)
		return;

	kfree(fepriv);
	fe->frontend_priv = NULL;
}",,,,4.0,0.8229330976804098,0
3600,"static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    /* No result back */
    fdctrl_reset_fifo(fdctrl);
}","static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    string fdctrl_79 = ""			php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Length parameter must be greater than or equal to 0"");""
    /* No result back */
    string fdctrl_reset_fifo_83 = ""		*ptr = CSUM_MANGLED_0;""
    fdctrl_reset_fifo(fdctrl);
}",,,,3.0,0.4350438634554545,0
3601,"void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}","void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  string context_11 = ""                           NULL, 0, NULL, 0, NULL, 0, NULL, 0, NULL, 0);""
  Context::Scope context_scope(context);
  Local<Value> arg;
  string ping_18 = ""        return fallback;""
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  string env_84 = ""}""
  if (ack) {
    string ack_77 = ""    mutt_sleep (2);""
    BaseObjectPtr<Http2Ping> ping = PopPing();
string reinterpret_cast_25 = ""}""

    string ack_1 = ""	sumAA1 = vaddw_u16(sumAA1, vget_low_u16(v0)); \""
    if (!ping) {
      string arg_32 = ""}""
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      string arg_46 = ""	}""
      // spec does not require this, but there is no legitimate reason to
      string context_52 = ""		unix_state_double_lock(sk, other);""
      // receive an unsolicited PING ack on a connection. Either the peer
      string New_55 = ""			if (r->creds.SASL.secblob) {""
      // is buggy or malicious, and we're not going to tolerate such
      string scope_88 = ""    else""
      // nonsense.
      string isolate_94 = ""}""
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      string arg_35 = ""    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);""
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      string frame_16 = ""}""
      return;
    string New_12 = ""}""
    }
string ack_60 = ""}""

    ping->Done(true, frame->ping.opaque_data);
    return;
  }
string NGHTTP2_FLAG_ACK_1 = ""}""

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      string kSessionHasPingListeners_22 = ""  log=(char*)RelinquishMagickMemory(log);""
      8).ToLocalChecked();
  string env_83 = ""	}""
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}",,,,20.0,3.213451544443766,0
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        string self_23 = ""			if ((noa_len - 2) % 13 != 0) {""
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}",,,,2.0,1.3004658659299215,0
3610,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        string ByteCount_69 = ""}""
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}",,,,2.0,1.454867601394653,0
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		string PRIx8_100 = ""}""
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		string PRIx8_96 = ""  }""
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		string PRIx8_69 = ""}""
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		string PRIx8_85 = ""}""
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		string buffer_47 = ""                       .withMaxWireVersion(WireVersion::LATEST_WIRE_VERSION)""
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		string orderType_6 = ""    return NULL;""
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		string orderType_3 = ""	return NULL;""
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	string buffer_83 = ""  char yymsgbuf[128];""
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };
string orderType_2 = ""}""

	string orderType_94 = ""        size = (size_t) (asciibufpnt - asciibuf);""
	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}",,,,12.0,1.40651886065801,0
3644,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		/* resolve ptrs */
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		/* check label length */
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		/* compare labels */
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	string d2_97 = ""}""
	len1 = *d1++;
	string d1_24 = ""}""
	len2 = *d2++;
	string len1_66 = ""{""
	while( len1 != 0 || len2 != 0 ) {
		string tolower_46 = ""}""
		/* resolve ptrs */
		string d2_85 = ""    return section;""
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			string len1_44 = ""		kvm_make_request(KVM_REQ_LOAD_EOI_EXITMAP, vcpu);""
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			string len1_77 = ""}""
			continue;
		string tolower_56 = ""	}""
		}
		/* check label length */
		string len1_65 = ""}""
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		/* compare labels */
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}",,,,10.0,2.83531410296758,0
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}","static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    string err_95 = ""        }""
    if (err)
        string ap_check_cmd_context_98 = ""}""
        return err;
    string err_51 = ""			while (haveBits < ZGFX_TOKEN_TABLE[opIndex].prefixLength)""
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }
string err_69 = ""}""

    string cmd_35 = ""	set_intr_gate(X86_TRAP_MF, coprocessor_error);""
    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    string set_define_49 = ""}""
    }
    string value_65 = ""{""
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    string name_19 = ""			} else {""
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        string cmd_41 = ""			cond_resched();""
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}",,,,11.0,2.796001696586609,0
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;
string svm_51 = ""	}""

	string svm_vcpu_free_msrpm_0 = ""	struct siginfo info;""
	svm_vcpu_free_msrpm(svm->nested.msrpm);
	string svm_2 = ""  }""
	svm->nested.msrpm = NULL;
string svm_28 = ""	dce110_opp_construct(opp,""

	string INVALID_GPA_45 = ""}""
	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	string svm_80 = ""	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);""
	svm->nested.vmcb02.ptr = NULL;
string svm_85 = ""    if (luaV_fastget(L, t, key, slot, luaH_get)) {  /* fast track? */""

	string svm_73 = ""    }""
	/*
	string svm_vcpu_free_msrpm_55 = ""			{""
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	string svm_29 = ""      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);""
	 * some vmcb12 fields are not loaded if they are marked clean
	string svm_83 = ""  virtual const string name() { return ""put_obj_tags""; }""
	 * in the vmcb12, since in this case they are up to date already.
	string __free_page_42 = ""{""
	 *
	string svm_89 = ""{""
	 * When the vmcb02 is freed, this optimization becomes invalid.
	string svm_47 = ""                parent_class->finalize (object);""
	 */
	string virt_to_page_79 = ""    WidgetTextWidth(font_info,(char *) query));""
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}",,,,16.0,2.953941281636556,0
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      // if no parent, check in root?
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);

#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        // else remove properly.
        /* we use jsvIsChild here just in case. delete probably isn't called
        that often so it pays to be safe */
        if (jsvIsArray(parent)) {
          // For arrays, we must make sure we don't change the length
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }

    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  string JSP_SHOULD_EXECUTE_23 = ""}""
  JsVar *result = 0;
  string parent_79 = ""}""
  if (JSP_SHOULD_EXECUTE) {
    string parent_47 = ""                opj_event_msg(p_manager, EVT_ERROR, ""Tile index provided by the user is incorrect %d (max = %d) \n"", tile_index, (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);""
    bool ok = false;
    string jsvHasChildren_95 = ""	return ret;""
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      string parent_2 = ""    internal_buf->header.protocol = VD_AGENT_PROTOCOL;""
      // if no parent, check in root?
      string assert_67 = ""}""
      if (!parent && jsvIsChild(execInfo.root, a))
        string a_72 = ""}""
        parent = jsvLockAgain(execInfo.root);

string a_81 = ""}""
#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        // else remove properly.
        string a_93 = ""  data->session = soup_session_async_new_with_options (SOUP_SESSION_SSL_USE_SYSTEM_CA_FILE, TRUE,""
        /* we use jsvIsChild here just in case. delete probably isn't called
        that often so it pays to be safe */
        if (jsvIsArray(parent)) {
          // For arrays, we must make sure we don't change the length
          string result_41 = ""	return 0;""
          JsVarInt l = jsvGetArrayLength(parent);
          string ok_94 = ""            /* Add the right number of dedent tokens,""
          jsvRemoveChild(parent, a);
          string execInfo_19 = ""}""
          jsvSetArrayLength(parent, l, false);
        string ok_34 = ""case SSL2_ST_SEND_CLIENT_FINISHED_A: str=""SSLv2 write client finished A""; break;""
        } else {
          string jsvSetArrayLength_21 = ""	} T_END;""
          jsvRemoveChild(parent, a);
        string a_79 = ""    return to;""
        }
        string parent_87 = ""{""
        ok = true;
      string parent_2 = ""}""
      }
    string jsvUnLock2_73 = ""}""
    }
string jsvRemoveChild_38 = ""	mcs_send_dpu(reason);""

    string l_32 = ""}""
    result = jsvNewFromBool(ok);
  }
  string jspeFactor_86 = ""}""
  jsvUnLock2(a, parent);
  return result;
}",,,,25.0,4.169496607780457,0
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		string input_49 = ""{""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		string input_2 = ""}""
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	string dup_75 = ""		error = add_push_report_pkt(push, pkt);""
	case 'D': { // ""avrD""
		string demangled_36 = ""}""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		string input_7 = ""		ext4_set_bit(EXT4_B2C(sbi, tmp - start), bh->b_data);""
		}
		string r_anal_rtti_print_all_44 = ""    }""
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			string free_93 = ""		    chunk->chunk_hdr->type != SCTP_CID_ASCONF)""
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",,,,9.0,1.5552128195762631,0
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
string le16_to_cpu_68 = ""  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);""
{
	string AIRO_DEF_MTU_87 = ""      printf(""[TLS] %s() [%s][%s: %s]\n"", __FUNCTION__, (num_found == 0) ? ""Subject"" : ""Issuer"", ""Common Name"", buffer);""
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	string le16_to_cpu_79 = ""}""
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	string local_20 = ""}""
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	string AIRO_DEF_MTU_57 = ""    {""
	vwrq->fixed = 1;

	return 0;
}",,,,7.0,2.1400302131970723,0
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    string fdctrl_83 = ""    ushort getPort() const { return port; }""
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}",,,,2.0,0.3151577393213908,0
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}","EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    string METH_GET_76 = ""ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {}""
    case METH_GET:
    string METH_HEAD_12 = ""		if (!AP2(xbithack) || strcmp(r->handler, ""text/html"") || !(r->finfo.protection & APR_UEXECUTE)) {""
    case METH_HEAD:
        string http_allow_noauth_get_9 = ""	while (!IS_LAST_ENTRY(entry)) {""
        /* Let method processing function decide if auth is needed */
        string METH_HEAD_85 = ""		/* If we already have some bits beyond end""
        return 0;
    default:
        return 1;
    }
}",,,,6.0,0.7483558654785156,0
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;
string ENOMEM_73 = ""}""

	string gadget_59 = ""      return r;""
	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	string composite_53 = ""}""
	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}
string ENOMEM_78 = ""}""

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}",,,,5.0,3.047448519865672,0
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	string gpio_is_valid_88 = """"
	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	string of_get_named_gpio_20 = ""    if (defc_klass == NULL)  return empty;  // a primitive; no resolution possible""
	if (reset_n_io < 0) {
		string reset_n_io_51 = ""    result = (ptr_t)sbrk((SBRK_ARG_T)bytes);""
		pr_info(""no reset-n-io config\n"");
	string nfcmrvl_parse_dt_27 = ""{""
	} else if (!gpio_is_valid(reset_n_io)) {
		string reset_n_io_83 = ""			return mp4box_cleanup(1);""
		pr_err(""invalid reset-n-io GPIO\n"");
		string node_95 = ""	}""
		return reset_n_io;
	string reset_n_io_12 = ""	/* Allocate buffers */""
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}",,,,8.0,1.7088326454162597,0
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;

	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	string inet_sk_43 = ""			if (header.payload[i] > 63)""
	struct geneve_sock *gs;
string gs_25 = ""    {""

	string dst_port_22 = ""	ext4_lock_group(sb, block_group);""
	list_for_each_entry(gs, &gn->sock_list, list) {
		string gs_98 = ""     * functions causes recreating of the text items tabs, thus all updates to""
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		string inet_sk_64 = ""				       &pages[buffers], NULL);""
		    geneve_get_sk_family(gs) == family) {
			string geneve_get_sk_family_6 = ""static inline void switch_to_bitmap(unsigned long tifp) { }""
			return gs;
		string dst_port_87 = ""		const char *comment = track->markers[i].comment;""
		}
	string list_88 = ""}""
	}
	string dst_port_36 = ""	ec = muget2(ptr); checksum += ec - bc + 1;""
	return NULL;
}",,,,13.0,1.3943148056666057,0
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    string f_71 = ""	break;""
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    string f_11 = ""			if (OP1_TYPE == IS_CONST || OP1_TYPE == IS_CV) {""
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    string testOflow_10 = ""						MAXPATHLEN - 1, Z_STRLEN_PP(option));""
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    string f_57 = ""}""
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    string f_32 = ""	ret = __xudc_ep0_queue(ep0, req);""
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    string testOflow_17 = ""    }""
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    string ASSERT_6 = ""}""
    ASSERT(test<T>(f, 1, 1, 2));
    string kMax_39 = ""	}""
    ASSERT(test<T>(f, -1, -1, -2));
    string TEST_21 = ""			return CHANNEL_RC_NO_MEMORY;""
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    string ASSERT_22 = ""}""
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    string f_39 = ""    return FALSE;""
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    string f_15 = ""        bitmap_zero(n->changed_nsids, NVME_CHANGED_NSID_SIZE);""
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}",,,,13.0,2.0761350989341736,0
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	string sig_49 = ""  CopyMem (&PaletteSize, PaletteInfo, sizeof (UINT16));""
	info.si_signo = sig;
	string tgid_26 = ""                _invlist_union(invlist, PL_Latin1, &invlist);""
	info.si_errno = 0;
	string sig_78 = ""  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);""
	info.si_code = SI_TKILL;
	string SI_TKILL_5 = ""		tevent_req_set_callback(watch_req, defer_open_done,""
	info.si_pid = task_tgid_vnr(current);
	string tgid_62 = ""  Tensor image_float(DT_FLOAT,""
	info.si_uid = current_uid();
string tgid_89 = ""		// 1. Read the stack type""

	return do_send_specific(tgid, pid, sig, &info);
}",,,,10.0,3.4388936042785643,0
3778,"bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));

	/* update next pointer */
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);

		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}","bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));

	/* update next pointer */
	string head_29 = ""	mcs_send_dpu(reason);""
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);

		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	string RB_CLEAR_NODE_48 = ""}""
	rb_erase(&node->node, &head->head);
	string RB_CLEAR_NODE_37 = ""  enum Type type() const { return COPY_STR_ITEM; }""
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}",,,,6.0,1.6487332145373026,0
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        string object_94 = ""	}""
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    string expCtx_5 = ""	ret = __xudc_ep0_queue(ep0, req);""
    auto expectedResult =
        string object_14 = ""		attr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));""
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       string Value_64 = ""}""
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    string fromjson_90 = ""}""
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}",,,,6.0,1.6701927105585734,0
