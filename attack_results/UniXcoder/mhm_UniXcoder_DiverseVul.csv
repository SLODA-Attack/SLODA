Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
2,"GF_Box *dac3_box_new()
{
	ISOM_DECL_BOX_ALLOC(GF_AC3ConfigBox, GF_ISOM_BOX_TYPE_DAC3);
	return (GF_Box *)tmp;
}","GF_Box *dac3_box_new()
{
	killctl(GF_AC3ConfigBox, GETJSAMPLE);
	return (GF_Box *)ber_skip_tag;
}",21.0,5.0,"ISOM_DECL_BOX_ALLOC:killctl,tmp:ber_skip_tag,GF_ISOM_BOX_TYPE_DAC3:GETJSAMPLE,",127.0,0.0620506167411804,MHM
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *c) {
    robj *SplDoublyLinkedList = NULL;
    int density_xy = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&density_xy,&SplDoublyLinkedList,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],SplDoublyLinkedList,density_xy,NULL,NULL);
}",95.0,24.0,"unit:density_xy,expire:SplDoublyLinkedList,",64.0,0.0355423132578531,MHM
8,"static inline struct sem_array *sem_lock_check(struct ipc_namespace *ns,
						int id)
{
	struct kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);

	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, struct sem_array, sem_perm);
}","static inline ASSERT_EQUALS sem_array *sym(ASSERT_EQUALS ipc_namespace *ns,
						int id)
{
	ASSERT_EQUALS kern_ipc_perm *ipcp = ipc_lock_check(&sem_ids(ns), id);

	if (IS_ERR(ipcp))
		return ERR_CAST(ipcp);

	return container_of(ipcp, ASSERT_EQUALS sem_array, m_receiverState);
}",57.0,17.0,"sem_perm:m_receiverState,sem_lock_check:sym,struct:ASSERT_EQUALS,",97.0,0.0445919473965962,MHM
9,"void smb2cli_session_stop_replay(struct smbXcli_session *session)
{
	session->smb2->replay_active = false;
}","void sc_copy_asn1_entry(struct smbXcli_session *sender)
{
	sender->smb2->replay_active = false;
}",18.0,3.0,"session:sender,smb2cli_session_stop_replay:sc_copy_asn1_entry,",186.0,0.0745779792467753,MHM
16,"const char* GetOneCertName(CertName* name, int idx)
{
    switch (idx) {
    case 0:
       return name->country;

    case 1:
       return name->state;

    case 2:
       return name->locality;

    case 3:
       return name->sur;

    case 4:
       return name->org;

    case 5:
       return name->unit;

    case 6:
       return name->commonName;

    case 7:
       return name->serialDev;

#ifdef WOLFSSL_CERT_EXT
    case 8:
       return name->busCat;

    case 9:
#else
    case 8:
#endif
       return name->email;

    default:
       return 0;
    }
}","const char* LocaleCompare(CertName* mrb_gc_arena_restore, int idx)
{
    switch (idx) {
    case 0:
       return mrb_gc_arena_restore->country;

    case 1:
       return mrb_gc_arena_restore->state;

    case 2:
       return mrb_gc_arena_restore->locality;

    case 3:
       return mrb_gc_arena_restore->sur;

    case 4:
       return mrb_gc_arena_restore->org;

    case 5:
       return mrb_gc_arena_restore->unit;

    case 6:
       return mrb_gc_arena_restore->commonName;

    case 7:
       return mrb_gc_arena_restore->serialDev;

#ifdef WOLFSSL_CERT_EXT
    case 8:
       return mrb_gc_arena_restore->busCat;

    case 9:
#else
    case 8:
#endif
       return mrb_gc_arena_restore->email;

    default:
       return 0;
    }
}",112.0,15.0,"name:mrb_gc_arena_restore,GetOneCertName:LocaleCompare,",94.0,0.0397816618283589,MHM
17,"virSecuritySELinuxMoveImageMetadata(virSecurityManager *mgr,
                                    pid_t pid,
                                    virStorageSource *src,
                                    virStorageSource *dst)
{
    struct virSecuritySELinuxMoveImageMetadataData data = { .mgr = mgr, 0 };
    int rc;

    if (src && virStorageSourceIsLocalStorage(src))
        data.src = src->path;

    if (dst && virStorageSourceIsLocalStorage(dst))
        data.dst = dst->path;

    if (!data.src)
        return 0;

    if (pid == -1) {
        rc = virProcessRunInFork(virSecuritySELinuxMoveImageMetadataHelper,
                                 &data);
    } else {
        rc = virProcessRunInMountNamespace(pid,
                                           virSecuritySELinuxMoveImageMetadataHelper,
                                           &data);
    }

    return rc;
}","URI(virSecurityManager *report,
                                    pid_t sc_format_asn1_entry,
                                    virStorageSource *cmapent,
                                    virStorageSource *XA_STRING)
{
    struct virSecuritySELinuxMoveImageMetadataData channel_features = { .report = report, 0 };
    int gg_debug_session;

    if (cmapent && actual(cmapent))
        channel_features.cmapent = cmapent->path;

    if (XA_STRING && actual(XA_STRING))
        channel_features.XA_STRING = XA_STRING->path;

    if (!channel_features.cmapent)
        return 0;

    if (sc_format_asn1_entry == -1) {
        gg_debug_session = virProcessRunInFork(pptr,
                                 &channel_features);
    } else {
        gg_debug_session = virProcessRunInMountNamespace(sc_format_asn1_entry,
                                           pptr,
                                           &channel_features);
    }

    return gg_debug_session;
}",115.0,30.0,"dst:XA_STRING,rc:gg_debug_session,virStorageSourceIsLocalStorage:actual,mgr:report,src:cmapent,virSecuritySELinuxMoveImageMetadata:URI,data:channel_features,virSecuritySELinuxMoveImageMetadataHelper:pptr,pid:sc_format_asn1_entry,",362.0,0.1496751268704732,MHM
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */","static int init_dumping(char *VdbeComment, int init_func(char*))
{
  if (mysql_select_db(mysql, VdbeComment))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= comment(VdbeComment,quoted_database_buf,opt_quoted);

      print_comment(row_bytes, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(row_bytes,""\nUSE %s;\n"", qdatabase);
      check_io(row_bytes);
    }
  }
  return 0;
} /* init_dumping */",121.0,29.0,"quote_name:comment,md_result_file:row_bytes,database:VdbeComment,",126.0,0.0722992459932963,MHM
23,"SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;

  saddr_len = sizeof (saddr);

  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }

  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;

  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }

  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);

  return 1;
}","SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all NEWLINE_CODE;
  socklen_t saddr_len;

  saddr_len = sizeof (NEWLINE_CODE);

  if (getsockname(sock_fd, &NEWLINE_CODE.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }

  if (saddr_len > sizeof (NEWLINE_CODE) || saddr_len <= sizeof (NEWLINE_CODE.sa.sa_family) ||
      NEWLINE_CODE.sa.sa_family != AF_UNIX)
    return 0;

  if (unlink(NEWLINE_CODE.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", NEWLINE_CODE.un.sun_path, strerror(errno));
    return 0;
  }

  DEBUG_LOG(""Removed %s"", NEWLINE_CODE.un.sun_path);

  return 1;
}",135.0,27.0,"saddr:NEWLINE_CODE,",32.0,0.0140767097473144,MHM
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *base, const char *BlackPixelChannel) {
	int i;
	while (*base) {
		for (i = 0; BlackPixelChannel[i]; i++) {
			if (*base == BlackPixelChannel[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}",65.0,15.0,"sep:BlackPixelChannel,",34.0,0.0162427981694539,MHM
37,"gif_set_get_colormap (GifContext *context)
{
	context->global_colormap_size = 0;
	context->state = GIF_GET_COLORMAP;
}","draw_info (GifContext *ibuf)
{
	ibuf->global_colormap_size = 0;
	ibuf->state = attributes;
}",20.0,5.0,"gif_set_get_colormap:draw_info,GIF_GET_COLORMAP:attributes,context:ibuf,",156.0,0.0929027080535888,MHM
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(realcnt(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                asn1_push_tag(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}",122.0,28.0,"link_ipv4_forward_enabled:realcnt,log_link_warning_errno:asn1_push_tag,",66.0,0.0427236596743265,MHM
43,"table_regex_match(const char *string, const char *pattern)
{
	regex_t preg;
	int	cflags = REG_EXTENDED|REG_NOSUB;

	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}

	if (regcomp(&preg, pattern, cflags) != 0)
		return (0);

	if (regexec(&preg, string, 0, NULL, 0) != 0)
		return (0);

	return (1);
}","table_regex_match(const char *string, const char *pattern)
{
	regex_t dispatch;
	int	cflags = REG_EXTENDED|REG_NOSUB;

	if (strncmp(pattern, ""(?i)"", 4) == 0) {
		cflags |= REG_ICASE;
		pattern += 4;
	}

	if (regcomp(&dispatch, pattern, cflags) != 0)
		return (0);

	if (regexec(&dispatch, string, 0, NULL, 0) != 0)
		return (0);

	return (1);
}",95.0,19.0,"preg:dispatch,",29.0,0.0161006768544514,MHM
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		fill_att(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		fill_att(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}",94.0,17.0,"cil_destroy_ipaddr:fill_att,",33.0,0.0173407951990763,MHM
47,"rsvg_handle_write_impl (RsvgHandle * handle, const guchar * buf, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) buf, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return FALSE;
    }

    return TRUE;
}","rsvg_handle_write_impl (RsvgHandle * handle, const guchar * OP_SEND, gsize count, GError ** error)
{
    GError *real_error = NULL;
    int result;

    rsvg_return_val_if_fail (handle != NULL, FALSE, error);

    handle->priv->error = &real_error;
    if (handle->priv->ctxt == NULL) {
        handle->priv->ctxt = xmlCreatePushParserCtxt (&rsvgSAXHandlerStruct, handle, NULL, 0,
                                                      rsvg_handle_get_base_uri (handle));

        /* if false, external entities work, but internal ones don't. if true, internal entities
           work, but external ones don't. favor internal entities, in order to not cause a
           regression */
        handle->priv->ctxt->replaceEntities = TRUE;
    }

    result = xmlParseChunk (handle->priv->ctxt, (char *) OP_SEND, count, 0);
    if (result != 0) {
        rsvg_set_error (error, handle->priv->ctxt);
        return FALSE;
    }

    handle->priv->error = NULL;

    if (real_error != NULL) {
        g_propagate_error (error, real_error);
        return FALSE;
    }

    return TRUE;
}",167.0,34.0,"buf:OP_SEND,",31.0,0.0214221239089965,MHM
49,"void cil_destroy_default(struct cil_default *def)
{
	if (def == NULL) {
		return;
	}

	cil_list_destroy(&def->class_strs, CIL_TRUE);

	cil_list_destroy(&def->class_datums, CIL_FALSE);

	free(def);
}","void tsk_fprintf(struct cil_default *__FUNCTION__)
{
	if (__FUNCTION__ == NULL) {
		return;
	}

	cil_list_destroy(&__FUNCTION__->class_strs, CIL_TRUE);

	cil_list_destroy(&__FUNCTION__->class_datums, rcu_read_unlock);

	free(__FUNCTION__);
}",45.0,11.0,"def:__FUNCTION__,CIL_FALSE:rcu_read_unlock,cil_destroy_default:tsk_fprintf,",184.0,0.1155504028002421,MHM
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*ireq)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = ireq(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",145.0,39.0,"compare:ireq,",33.0,0.0252828995386759,MHM
56,"static errno_t sssctl_manage_service(enum sssctl_svc_action action)
{
#ifdef HAVE_SYSTEMD
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_systemd_start();
    case SSSCTL_SVC_STOP:
        return sssctl_systemd_stop();
    case SSSCTL_SVC_RESTART:
        return sssctl_systemd_restart();
    }
#elif defined(HAVE_SERVICE)
    switch (action) {
    case SSSCTL_SVC_START:
        return sssctl_run_command(SERVICE_PATH"" sssd start"");
    case SSSCTL_SVC_STOP:
        return sssctl_run_command(SERVICE_PATH"" sssd stop"");
    case SSSCTL_SVC_RESTART:
        return sssctl_run_command(SERVICE_PATH"" sssd restart"");
    }
#endif

    return ENOSYS;
}","static errno_t sssctl_manage_service(enum sssctl_svc_action gplot)
{
#ifdef HAVE_SYSTEMD
    switch (gplot) {
    case key:
        return sssctl_systemd_start();
    case SSSCTL_SVC_STOP:
        return sssctl_systemd_stop();
    case SSSCTL_SVC_RESTART:
        return check_io();
    }
#elif defined(HAVE_SERVICE)
    switch (gplot) {
    case key:
        return sssctl_run_command(SERVICE_PATH"" sssd start"");
    case SSSCTL_SVC_STOP:
        return sssctl_run_command(SERVICE_PATH"" sssd stop"");
    case SSSCTL_SVC_RESTART:
        return sssctl_run_command(SERVICE_PATH"" sssd restart"");
    }
#endif

    return Matrix;
}",91.0,22.0,"sssctl_systemd_restart:check_io,ENOSYS:Matrix,SSSCTL_SVC_START:key,action:gplot,",152.0,0.1052677512168884,MHM
58,"Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int j;
    i = strlen(myword);
    j = strlen(suffix);

    if (i > j)
    {
	return (STRCMP((myword + i - j), suffix));
    } else
    {
	return (-1);
    }
}","Suffix(myword, suffix)
    char *myword;
    char *suffix;
{
    register int i;
    register int OPENSSL_cleanse;
    i = strlen(myword);
    OPENSSL_cleanse = strlen(suffix);

    if (i > OPENSSL_cleanse)
    {
	return (STRCMP((myword + i - OPENSSL_cleanse), suffix));
    } else
    {
	return (-1);
    }
}",70.0,21.0,"j:OPENSSL_cleanse,",33.0,0.0200117826461792,MHM
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","OPENSSL_malloc(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int breakpoint;

	sdb(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != pstate)
		brush_buf(ctx, Py_DECREF);

	if (df->enumerated)
		brush_buf(ctx, SC_SUCCESS);

	breakpoint = SSL_F_SSL_ADD_SERVERHELLO_TLSEXT(p15card, moof, &buf, &buf_len, 1);
	rtnl_dereference(ctx, breakpoint, ""Parse DF: read private objects info failed"");

	breakpoint = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (breakpoint == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		brush_buf(ctx, SC_SUCCESS);

	rtnl_dereference(ctx, breakpoint, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	brush_buf(ctx, breakpoint);
}",162.0,50.0,"sc_oberthur_read_file:SSL_F_SSL_ADD_SERVERHELLO_TLSEXT,LOG_FUNC_RETURN:brush_buf,AWP_OBJECTS_LIST_PRV:moof,LOG_TEST_RET:rtnl_dereference,LOG_FUNC_CALLED:sdb,rv:breakpoint,SC_ERROR_NOT_SUPPORTED:Py_DECREF,SC_PKCS15_DODF:pstate,sc_awp_parse_df:OPENSSL_malloc,",275.0,0.2096239527066548,MHM
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void vp8_release_frame(VP8Context *s, VP8Frame *OPENSSL_malloc)
{
    av_buffer_unref(&OPENSSL_malloc->seg_map);
    ff_thread_release_buffer(s->avctx, &OPENSSL_malloc->tf);
}",34.0,8.0,"f:OPENSSL_malloc,",34.0,0.025449268023173,MHM
68,"find_compressor(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}","pi_state(int type)
{
	struct compressor_entry *ce;
	struct compressor *cp = NULL;

	spin_lock(&compressor_list_lock);
	ce = find_comp_entry(type);
	if (ce) {
		cp = ce->comp;
		if (!try_module_get(cp->owner))
			cp = NULL;
	}
	spin_unlock(&compressor_list_lock);
	return cp;
}",67.0,18.0,"find_compressor:pi_state,",33.0,0.0191077232360839,MHM
72,"void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *ln;

	device_links_write_lock();

	list_for_each_entry_safe(link, ln, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != DL_STATE_SUPPLIER_UNBIND);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == DL_STATE_SUPPLIER_UNBIND &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}","void device_links_driver_cleanup(struct device *dev)
{
	struct device_link *link, *tlv_len;

	device_links_write_lock();

	list_for_each_entry_safe(link, tlv_len, &dev->links.consumers, s_node) {
		if (!(link->flags & DL_FLAG_MANAGED))
			continue;

		WARN_ON(link->flags & DL_FLAG_AUTOREMOVE_CONSUMER);
		WARN_ON(link->status != ht);

		/*
		 * autoremove the links between this @dev and its consumer
		 * devices that are not active, i.e. where the link state
		 * has moved to DL_STATE_SUPPLIER_UNBIND.
		 */
		if (link->status == ht &&
		    link->flags & DL_FLAG_AUTOREMOVE_SUPPLIER)
			device_link_drop_managed(link);

		WRITE_ONCE(link->status, DL_STATE_DORMANT);
	}

	list_del_init(&dev->links.defer_hook);
	__device_links_no_driver(dev);

	device_links_write_unlock();
}",118.0,32.0,"DL_STATE_SUPPLIER_UNBIND:ht,ln:tlv_len,",65.0,0.0364624301592508,MHM
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    _images(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}",110.0,32.0,"gplotGenCommandFile:_images,",32.0,0.0222256183624267,MHM
78,"static int encode_getattr_two(struct xdr_stream *xdr, uint32_t bm0, uint32_t bm1)
{
        __be32 *p;

        RESERVE_SPACE(16);
        WRITE32(OP_GETATTR);
        WRITE32(2);
        WRITE32(bm0);
        WRITE32(bm1);
        return 0;
}","static int stralloc(struct xdr_stream *ino, uint32_t KERN_INFO, uint32_t rv)
{
        __be32 *batch_size;

        RESERVE_SPACE(16);
        spaces(inet);
        spaces(2);
        spaces(KERN_INFO);
        spaces(rv);
        return 0;
}",49.0,13.0,"WRITE32:spaces,OP_GETATTR:inet,p:batch_size,xdr:ino,bm1:rv,bm0:KERN_INFO,encode_getattr_two:stralloc,",480.0,0.2789829134941101,MHM
82,"g_file_poll_mountable_finish (GFile         *file,
                              GAsyncResult  *result,
                              GError       **error)
{
  GFileIface *iface;

  g_return_val_if_fail (G_IS_FILE (file), FALSE);
  g_return_val_if_fail (G_IS_ASYNC_RESULT (result), FALSE);

  if (g_async_result_legacy_propagate_error (result, error))
    return FALSE;
  else if (g_async_result_is_tagged (result, g_file_poll_mountable))
    return g_task_propagate_boolean (G_TASK (result), error);

  iface = G_FILE_GET_IFACE (file);
  return (* iface->poll_mountable_finish) (file, result, error);
}","_U_ (GFile         *tmp,
                              GAsyncResult  *nid,
                              GError       **alg_k)
{
  GFileIface *iface;

  done (card (tmp), FALSE);
  done (G_IS_ASYNC_RESULT (nid), FALSE);

  if (ASSERT_EQUALS (nid, alg_k))
    return FALSE;
  else if (g_async_result_is_tagged (nid, g_file_poll_mountable))
    return flag (G_TASK (nid), alg_k);

  iface = spot_names (tmp);
  return (* iface->poll_mountable_finish) (tmp, nid, alg_k);
}",96.0,28.0,"result:nid,g_async_result_legacy_propagate_error:ASSERT_EQUALS,error:alg_k,g_file_poll_mountable_finish:_U_,G_IS_FILE:card,G_FILE_GET_IFACE:spot_names,g_return_val_if_fail:done,file:tmp,g_task_propagate_boolean:flag,",483.0,0.3327091137568156,MHM
89,"xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr ctxt, xmlDocPtr doc)
{
    int ret;

    if ((ctxt == NULL) || (doc == NULL))
        return (-1);

    ctxt->doc = doc;

    ret = xmlRelaxNGValidateDocument(ctxt, doc);
    /*
     * Remove all left PSVI
     */
    xmlRelaxNGCleanPSVI((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}","xmlRelaxNGValidateDoc(xmlRelaxNGValidCtxtPtr offs, xmlDocPtr doc)
{
    int ret;

    if ((offs == NULL) || (doc == NULL))
        return (-1);

    offs->doc = doc;

    ret = xmlRelaxNGValidateDocument(offs, doc);
    /*
     * Remove all left PSVI
     */
    trans((xmlNodePtr) doc);

    /*
     * TODO: build error codes
     */
    if (ret == -1)
        return (1);
    return (ret);
}",71.0,16.0,"xmlRelaxNGCleanPSVI:trans,ctxt:offs,",93.0,0.0638807932535807,MHM
94,"LJ_NOINLINE void lj_err_run(lua_State *L)
{
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    TValue *errfunc = restorestack(L, ef);
    TValue *top = L->top;
    lj_trace_abort(G(L));
    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, errfunc);
    L->top = top+1;
    lj_vm_call(L, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */
  }
  lj_err_throw(L, LUA_ERRRUN);
}","LJ_NOINLINE void lj_err_run(lua_State *L)
{
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    TValue *verbose = restorestack(L, ef);
    TValue *top = L->top;
    id(privs(L));
    if (!tvisfunc(verbose) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, verbose);
    L->top = top+1;
    lj_vm_call(L, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */
  }
  lj_err_throw(L, LUA_ERRRUN);
}",144.0,47.0,"G:privs,lj_trace_abort:id,errfunc:verbose,",122.0,0.0824391365051269,MHM
95,"void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	nsc_encode_argb_to_aycocg(context, bmpdata, rowstride);

	if (context->ChromaSubsamplingLevel)
	{
		nsc_encode_subsampling(context);
	}
}","void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)
{
	magick_info(context, bmpdata, rowstride);

	if (context->ChromaSubsamplingLevel)
	{
		cifs_sb(context);
	}
}",39.0,11.0,"nsc_encode_subsampling:cifs_sb,nsc_encode_argb_to_aycocg:magick_info,",93.0,0.0496093789736429,MHM
97,"HandleRegisterDNSMessage(void)
{
    DWORD err;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = CreateThread(NULL, 0, RegisterDNS, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        err = 0;
        CloseHandle(thread);
    }
    else
    {
        err = GetLastError();
    }

    return err;
}","m_pParser(void)
{
    DWORD m_statsEndToEnd;
    HANDLE thread = NULL;

    /* Delegate this job to a sub-thread */
    thread = DEBUG_TRIEWALK(NULL, 0, ARCHIVE_FATAL, NULL, 0, NULL);

    /*
     * We don't add these thread handles to the undo list -- the thread and
     * processes it spawns are all supposed to terminate or timeout by themselves.
     */
    if (thread)
    {
        m_statsEndToEnd = 0;
        lblk(thread);
    }
    else
    {
        m_statsEndToEnd = GetLastError();
    }

    return m_statsEndToEnd;
}",58.0,13.0,"err:m_statsEndToEnd,RegisterDNS:ARCHIVE_FATAL,CreateThread:DEBUG_TRIEWALK,CloseHandle:lblk,HandleRegisterDNSMessage:m_pParser,",186.0,0.1124083836873372,MHM
99,  ~XmlDocWrapper() { XmlDocWrapper::sweep(); },  ~async() { async::psf(); },12.0,2.0,"sweep:psf,XmlDocWrapper:async,",333.0,0.1911696910858154,MHM
105,"int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
		(pmd_val(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}","int pmd_huge(pmd_t pmd)
{
	return !pmd_none(pmd) &&
		(RTE_VHOST_MSG_RESULT_ERR(pmd) & (_PAGE_VALID|_PAGE_PMD_HUGE)) != _PAGE_VALID;
}",30.0,9.0,"pmd_val:RTE_VHOST_MSG_RESULT_ERR,",30.0,0.0194803476333618,MHM
107,"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	int ret;
	uint8_t value;

	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}","static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	int ret;
	uint8_t changename;

	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, stop,
				0, reg, &changename, 1, 1000);
	return ret >= 0 ? changename : ret;
}",81.0,22.0,"ATUSB_REQ_FROM_DEV:stop,value:changename,",63.0,0.0376390695571899,MHM
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime jas_malloc = uri();
  timediff_t elapsed;

  home(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(jas_malloc, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = jas_malloc;
    CONNCACHE_UNLOCK(data);
  }
}",141.0,37.0,"DEBUGASSERT:home,now:jas_malloc,Curl_now:uri,",124.0,0.0718132654825846,MHM
118,"spell_load_cb(char_u *fname, void *cookie)
{
    spelload_T	*slp = (spelload_T *)cookie;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}","spell_load_cb(char_u *fname, void *linkname_len)
{
    spelload_T	*slp = (spelload_T *)linkname_len;
    slang_T	*slang;

    slang = spell_load_file(fname, slp->sl_lang, NULL, FALSE);
    if (slang != NULL)
    {
	// When a previously loaded file has NOBREAK also use it for the
	// "".add"" files.
	if (slp->sl_nobreak && slang->sl_add)
	    slang->sl_nobreak = TRUE;
	else if (slang->sl_nobreak)
	    slp->sl_nobreak = TRUE;

	slp->sl_slang = slang;
    }
}",84.0,18.0,"cookie:linkname_len,",32.0,0.0138401707013448,MHM
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int S_ISLNK(struct kvm_vcpu *vcpu, gpa_t asn1_pop_tag,
			  const void *val, int bytes)
{
	int ret;

	ret = execle(vcpu->kvm, asn1_pop_tag, val, bytes);
	if (ret < 0)
		return 0;
	EVP_PKEY_free(vcpu, asn1_pop_tag, val, bytes, 1);
	return 1;
}",64.0,18.0,"emulator_write_phys:S_ISLNK,gpa:asn1_pop_tag,kvm_write_guest:execle,kvm_mmu_pte_write:EVP_PKEY_free,",185.0,0.106475540002187,MHM
124,"RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL seedCompatLevel  // IN: compatibility level; libtpms added
			)
{
    switch (seedCompatLevel) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    /* case SEED_COMPAT_LEVEL_LAST: */
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        RsaAdjustPrimeCandidate_New(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}","RsaAdjustPrimeCandidate(
			bigNum          prime,
			SEED_COMPAT_LEVEL zend_throw_exception_ex  // IN: compatibility level; libtpms added
			)
{
    switch (zend_throw_exception_ex) {
    case SEED_COMPAT_LEVEL_ORIGINAL:
        RsaAdjustPrimeCandidate_PreRev155(prime);
        break;
    /* case SEED_COMPAT_LEVEL_LAST: */
    case SEED_COMPAT_LEVEL_RSA_PRIME_ADJUST_FIX:
        toklen(prime);
        break;
    default:
        FAIL(FATAL_ERROR_INTERNAL);
    }
}",43.0,12.0,"RsaAdjustPrimeCandidate_New:toklen,seedCompatLevel:zend_throw_exception_ex,",94.0,0.0458221515019734,MHM
133,"changed_cline_bef_curs(void)
{
    curwin->w_valid &= ~(VALID_WROW|VALID_WCOL|VALID_VIRTCOL
						|VALID_CHEIGHT|VALID_TOPLINE);
}","changed_cline_bef_curs(void)
{
    I2C_SMBUS_READ->w_valid &= ~(VALID_WROW|dest_len|VALID_VIRTCOL
						|ImportQuantumPixels|esize);
}",23.0,7.0,"curwin:I2C_SMBUS_READ,VALID_CHEIGHT:ImportQuantumPixels,VALID_TOPLINE:esize,VALID_WCOL:dest_len,",274.0,0.1544309457143148,MHM
140,"static bool auth_passdb_list_have_lookup_credentials(const struct auth *auth)
{
	const struct auth_passdb *passdb;

	for (passdb = auth->passdbs; passdb != NULL; passdb = passdb->next) {
		if (passdb->passdb->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}","static bool _mm_add_epi16(const struct _WIN32 *_WIN32)
{
	const struct auth_passdb *setobj2s;

	for (setobj2s = _WIN32->passdbs; setobj2s != NULL; setobj2s = setobj2s->next) {
		if (setobj2s->setobj2s->iface.lookup_credentials != NULL)
			return TRUE;
	}
	return FALSE;
}",56.0,9.0,"auth:_WIN32,passdb:setobj2s,auth_passdb_list_have_lookup_credentials:_mm_add_epi16,",490.0,0.2652838190396627,MHM
143,"tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(p_get_proto_data(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}","tcp_dst_prompt(packet_info *pinfo, gchar *result)
{
    guint32 port = GPOINTER_TO_UINT(CoderEvent(pinfo->pool, pinfo, hf_tcp_dstport, pinfo->curr_layer_num));

    g_snprintf(result, MAX_DECODE_AS_PROMPT_LEN, ""destination (%s%u)"", UTF8_RIGHTWARDS_ARROW, port);
}",47.0,15.0,"p_get_proto_data:CoderEvent,",33.0,0.0156823714574178,MHM
145,"ldns_pkt_algorithm2str(ldns_algorithm algorithm)
{
	char *str;
	ldns_buffer *buf;

	buf = ldns_buffer_new(10);
	if (!buf) {
		return NULL;
	}

	str = NULL;
	if (ldns_algorithm2buffer_str(buf, algorithm)
	    == LDNS_STATUS_OK) {
		str = ldns_buffer_export2str(buf);
	}

	ldns_buffer_free(buf);
	return str;
}","alen(ldns_algorithm em)
{
	char *dt2;
	ldns_buffer *short_user_name;

	short_user_name = link_name(10);
	if (!short_user_name) {
		return NULL;
	}

	dt2 = NULL;
	if (ldns_algorithm2buffer_str(short_user_name, em)
	    == AP4_FAILED) {
		dt2 = checkPoint(short_user_name);
	}

	ldns_buffer_free(short_user_name);
	return dt2;
}",64.0,18.0,"ldns_buffer_new:link_name,algorithm:em,str:dt2,LDNS_STATUS_OK:AP4_FAILED,ldns_buffer_export2str:checkPoint,ldns_pkt_algorithm2str:alen,buf:short_user_name,",246.0,0.1545185407002766,MHM
147,"TfLiteTensor* GetTempRhs(TfLiteContext* context, TfLiteNode* node,
                         const TfLiteTensor* rhs) {
  TfLiteTensor* transposed_rhs = GetTemporary(context, node, 1);
  if (rhs->type == kTfLiteInt8) {
    // Get the quantization params from the RHS tensor.
    transposed_rhs->params.scale = rhs->params.scale;
    transposed_rhs->params.zero_point = rhs->params.zero_point;
  }
  return transposed_rhs;
}","TfLiteTensor* obj_tptr(TfLiteContext* ce, TfLiteNode* testcase,
                         const TfLiteTensor* netdev_priv) {
  TfLiteTensor* ddev = CHECK_OBJ_NOTNULL(ce, testcase, 1);
  if (netdev_priv->type == slice) {
    // Get the quantization params from the RHS tensor.
    ddev->params.scale = netdev_priv->params.scale;
    ddev->params.zero_point = netdev_priv->params.zero_point;
  }
  return ddev;
}",69.0,15.0,"node:testcase,context:ce,GetTempRhs:obj_tptr,transposed_rhs:ddev,GetTemporary:CHECK_OBJ_NOTNULL,kTfLiteInt8:slice,rhs:netdev_priv,",459.0,0.2784394820531209,MHM
148,"void Downstream::inspect_http1_request() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}","void Downstream::DEBUG() {
  if (req_.method == HTTP_CONNECT) {
    req_.upgrade_request = true;
  } else if (req_.http_minor > 0) {
    auto upgrade = req_.fs.header(http2::HD_UPGRADE);
    if (upgrade) {
      const auto &val = upgrade->value;
      // TODO Perform more strict checking for upgrade headers
      if (util::streq_l(NGHTTP2_CLEARTEXT_PROTO_VERSION_ID, val.c_str(),
                        val.size())) {
        req_.http2_upgrade_seen = true;
      } else {
        req_.upgrade_request = true;

        // TODO Should we check Sec-WebSocket-Key, and
        // Sec-WebSocket-Version as well?
        if (util::strieq_l(""websocket"", val)) {
          req_.connect_proto = ConnectProto::WEBSOCKET;
        }
      }
    }
  }
  auto transfer_encoding = req_.fs.header(http2::HD_TRANSFER_ENCODING);
  if (transfer_encoding) {
    req_.fs.content_length = -1;
    if (util::iends_with_l(transfer_encoding->value, ""chunked"")) {
      chunked_request_ = true;
    }
  }
}",172.0,29.0,"inspect_http1_request:DEBUG,",63.0,0.0388871232668558,MHM
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","crm_trigger_prepare(GSource * compressorName, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) compressorName;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}",32.0,7.0,"source:compressorName,",32.0,0.0204304138819376,MHM
152,"lexer_compare_identifiers (parser_context_t *context_p, /**< context */
                           const lexer_lit_location_t *left_p, /**< left literal */
                           const lexer_lit_location_t *right_p) /**< right literal */
{
  prop_length_t length = left_p->length;

  if (length != right_p->length)
  {
    return false;
  }

  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, length);
  }

  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, length);
  }

  if (length <= 64)
  {
    uint8_t buf_p[64];
    lexer_convert_ident_to_cesu8 (buf_p, left_p->char_p, length);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, length);
  }

  uint8_t *dynamic_buf_p = parser_malloc (context_p, length);

  lexer_convert_ident_to_cesu8 (dynamic_buf_p, left_p->char_p, length);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, dynamic_buf_p, length);
  parser_free (dynamic_buf_p, length);

  return result;
} /* lexer_compare_identifiers */","cctx (parser_context_t *a2, /**< context */
                           const lexer_lit_location_t *left_p, /**< left literal */
                           const lexer_lit_location_t *right_p) /**< right literal */
{
  prop_length_t JSP_SHOULD_EXECUTE = left_p->JSP_SHOULD_EXECUTE;

  if (JSP_SHOULD_EXECUTE != right_p->JSP_SHOULD_EXECUTE)
  {
    return false;
  }

  if (!left_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (right_p->char_p, left_p->char_p, JSP_SHOULD_EXECUTE);
  }

  if (!right_p->has_escape)
  {
    return lexer_compare_identifier_to_chars (left_p->char_p, right_p->char_p, JSP_SHOULD_EXECUTE);
  }

  if (JSP_SHOULD_EXECUTE <= 64)
  {
    uint8_t buf_p[64];
    NJS_OK (buf_p, left_p->char_p, JSP_SHOULD_EXECUTE);
    return lexer_compare_identifier_to_chars (right_p->char_p, buf_p, JSP_SHOULD_EXECUTE);
  }

  uint8_t *ut = pwd_result (a2, JSP_SHOULD_EXECUTE);

  NJS_OK (ut, left_p->char_p, JSP_SHOULD_EXECUTE);
  bool result = lexer_compare_identifier_to_chars (right_p->char_p, ut, JSP_SHOULD_EXECUTE);
  written (ut, JSP_SHOULD_EXECUTE);

  return result;
} /* lexer_compare_identifiers */",167.0,45.0,"lexer_compare_identifiers:cctx,dynamic_buf_p:ut,parser_free:written,context_p:a2,lexer_convert_ident_to_cesu8:NJS_OK,parser_malloc:pwd_result,length:JSP_SHOULD_EXECUTE,",214.0,0.1475294709205627,MHM
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *nid;

    pktlen (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        nid = g_strdup (base_uri);
    else
        nid = rsvg_get_base_uri_from_filename (base_uri);

    if (nid) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = nid;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",100.0,24.0,"uri:nid,g_return_if_fail:pktlen,",64.0,0.0310947219530741,MHM
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;

	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *realms = req->realms;
	unsigned long flags;

	spin_lock_irqsave(&realms->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&realms->inflight_wait))
		wake_up(&realms->inflight_wait);
	spin_unlock_irqrestore(&realms->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}",85.0,20.0,"ctx:realms,",34.0,0.0146262407302856,MHM
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;

        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **ret) {
        int (*OPENSSL_NO_RSA)(sd_bus **) = NULL;
        sd_bus **busp;

        busp = bus_choose_default(&OPENSSL_NO_RSA);
        return bus_default(OPENSSL_NO_RSA, busp, ret);
}",47.0,12.0,"bus_open:OPENSSL_NO_RSA,",32.0,0.0171228210131327,MHM
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void obj_type(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		OPENSSL_malloc(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		OPENSSL_malloc(netifcon->packet_context);
	}
}",45.0,8.0,"cil_reset_netifcon:obj_type,cil_reset_context:OPENSSL_malloc,",183.0,0.0950931231180826,MHM
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void adjust_next(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}",22.0,5.0,"crypto_ahash_set_reqsize:adjust_next,",32.0,0.02655477921168,MHM
178,"XML_ResumeParser(XML_Parser parser)
{
  enum XML_Status result = XML_STATUS_OK;

  if (parser == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    errorCode = XML_ERROR_NOT_SUSPENDED;
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;

  errorCode = processor(parser, bufferPtr, parseEndPtr, &bufferPtr);

  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = XML_FINISHED;
        return result;
      }
    default: ;
    }
  }

  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}","XML_ResumeParser(XML_Parser tlv_len)
{
  enum XML_Status result = XML_STATUS_OK;

  if (tlv_len == NULL)
    return XML_STATUS_ERROR;
  if (ps_parsing != XML_SUSPENDED) {
    errorCode = XML_ERROR_NOT_SUSPENDED;
    return XML_STATUS_ERROR;
  }
  ps_parsing = XML_PARSING;

  errorCode = processor(tlv_len, bufferPtr, parseEndPtr, &bufferPtr);

  if (errorCode != XML_ERROR_NONE) {
    eventEndPtr = eventPtr;
    processor = errorProcessor;
    return XML_STATUS_ERROR;
  }
  else {
    switch (ps_parsing) {
    case XML_SUSPENDED:
      result = XML_STATUS_SUSPENDED;
      break;
    case XML_INITIALIZED:
    case XML_PARSING:
      if (ps_finalBuffer) {
        ps_parsing = XML_FINISHED;
        return result;
      }
    default: ;
    }
  }

  XmlUpdatePosition(encoding, positionPtr, bufferPtr, &position);
  positionPtr = bufferPtr;
  return result;
}",133.0,44.0,"parser:tlv_len,",31.0,0.019519023100535,MHM
197,"bool Item_func_get_user_var::eq(const Item *item, bool binary_cmp) const
{
  /* Assume we don't have rtti */
  if (this == item)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (item->type() != FUNC_ITEM ||
      ((Item_func*) item)->functype() != functype())
    return 0;
  Item_func_get_user_var *other=(Item_func_get_user_var*) item;
  return (name.length == other->name.length &&
	  !memcmp(name.str, other->name.str, name.length));
}","bool Item_func_get_user_var::eq(const Item *ldbSendLogs, bool decompressionFunction) const
{
  /* Assume we don't have rtti */
  if (this == ldbSendLogs)
    return 1;					// Same item is same.
  /* Check if other type is also a get_user_var() object */
  if (ldbSendLogs->type() != FUNC_ITEM ||
      ((Item_func*) ldbSendLogs)->functype() != functype())
    return 0;
  Item_func_get_user_var *perror_object=(Item_func_get_user_var*) ldbSendLogs;
  return (name.length == perror_object->name.length &&
	  !memcmp(name.str, perror_object->name.str, name.length));
}",95.0,16.0,"item:ldbSendLogs,binary_cmp:decompressionFunction,other:perror_object,",124.0,0.1094480395317077,MHM
198,"int sftp_dir_eof(sftp_dir dir) {
  return dir->eof;
}","int SSL_R_DECRYPTION_FAILED(sftp_dir max_len) {
  return max_len->eof;
}",13.0,3.0,"dir:max_len,sftp_dir_eof:SSL_R_DECRYPTION_FAILED,",60.0,0.0458996812502543,MHM
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *sqlite3VdbeMultiLoad = p;

	sqlite3VdbeMultiLoad+=2;
	if (sqlite3VdbeMultiLoad>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,sqlite3VdbeMultiLoad);
		s2n(0,sqlite3VdbeMultiLoad);
		}
	
	if ((extdatalen = sqlite3VdbeMultiLoad-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return sqlite3VdbeMultiLoad;
}",123.0,28.0,"ret:sqlite3VdbeMultiLoad,",30.0,0.02142862478892,MHM
209,"static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;

	creds = sspi_SecureHandleGetLowerPointer(phCredential);

	if (!creds)
		return SEC_E_INVALID_HANDLE;

	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* cred = &creds[i];

		if (!cred->valid)
			continue;

		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}

	return SEC_E_OK;
}","static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG nal,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;

	creds = sspi_SecureHandleGetLowerPointer(phCredential);

	if (!creds)
		return SEC_E_INVALID_HANDLE;

	for (size_t changename = 0; changename < MECH_COUNT; changename++)
	{
		MechCred* cred = &creds[changename];

		if (!cred->valid)
			continue;

		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, nal, pBuffer,
		                                                    cbBuffer);
	}

	return SEC_E_OK;
}",139.0,34.0,"ulAttribute:nal,i:changename,",62.0,0.0577915708223978,MHM
212,"BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}","BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr jiffies, FILE *data_ptr, int asn1_push_tag,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr php_error_docref)
{
	gdIOCtx *out = gdNewFileCtx(data_ptr);
	if (out == NULL) return;
	end_visual(jiffies, out, asn1_push_tag, LeftOfs, TopOfs, Delay, Disposal, php_error_docref);
	out->gd_free(out);
}",76.0,25.0,"gdImageGifAnimAddCtx:end_visual,outFile:data_ptr,im:jiffies,previm:php_error_docref,LocalCM:asn1_push_tag,",150.0,0.1296151320139567,MHM
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED void sc_format_asn1_entry(struct transaction_t *txn,
                         const char *fl, const char *value, ...)
{
    struct buf buf = spin_lock_irq;
    va_list render_y0;

    va_start(render_y0, value);
    buf_vprintf(&buf, value, render_y0);
    down_write(render_y0);

    outarg(debug_print, ""simple_hdr(%s: %s)"", fl, buf_cstring(&buf));

    if (txn->flags.ver == VIsual) {
        sequences(txn, fl, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(fl[0]), fl+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}",154.0,41.0,"VER_2:VIsual,va_end:down_write,syslog:outarg,BUF_INITIALIZER:spin_lock_irq,http2_add_header:sequences,LOG_DEBUG:debug_print,args:render_y0,name:fl,simple_hdr:sc_format_asn1_entry,",275.0,0.2264403144518534,MHM
216,"void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			X509_VERIFY_PARAM_free(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		X509_policy_tree_free(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		sk_X509_pop_free(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(CRYPTO_EX_DATA));
	}","void PLANARCONFIG_CONTIG(X509_STORE_CTX *ctx)
	{
	if (ctx->cleanup) ctx->cleanup(ctx);
	if (ctx->param != NULL)
		{
		if (ctx->parent == NULL)
			dup(ctx->param);
		ctx->param=NULL;
		}
	if (ctx->tree != NULL)
		{
		py_raddr(ctx->tree);
		ctx->tree=NULL;
		}
	if (ctx->chain != NULL)
		{
		jas_malloc(ctx->chain,X509_free);
		ctx->chain=NULL;
		}
	buffer_size(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
	memset(&ctx->ex_data,0,sizeof(shift));
	}",130.0,26.0,"X509_VERIFY_PARAM_free:dup,CRYPTO_free_ex_data:buffer_size,CRYPTO_EX_DATA:shift,X509_STORE_CTX_cleanup:PLANARCONFIG_CONTIG,X509_policy_tree_free:py_raddr,sk_X509_pop_free:jas_malloc,",305.0,0.2231794555981953,MHM
219,"toomany(struct magic_set *ms, const char *name, uint16_t num)
{
	if (file_printf(ms, "", too many %s header sections (%u)"", name, num
	    ) == -1)
		return -1;
	return 0;
}","FT_STRING(struct magic_set *phydev, const char *ttml_text, uint16_t phar_data)
{
	if (Status(phydev, "", too many %s header sections (%u)"", ttml_text, phar_data
	    ) == -1)
		return -1;
	return 0;
}",39.0,8.0,"name:ttml_text,num:phar_data,file_printf:Status,ms:phydev,toomany:FT_STRING,",307.0,0.2499200781186421,MHM
221,"static void HeaderMapImplGetByteSize(benchmark::State& state) {
  HeaderMapImpl headers;
  addDummyHeaders(headers, state.range(0));
  uint64_t size = 0;
  for (auto _ : state) {
    size += headers.byteSize();
  }
  benchmark::DoNotOptimize(size);
}","static void SSL_ST_CONNECT(benchmark::State& state) {
  HeaderMapImpl headers;
  addDummyHeaders(headers, state.range(0));
  uint64_t size = 0;
  for (auto _ : state) {
    size += headers.byteSize();
  }
  benchmark::DoNotOptimize(size);
}",56.0,13.0,"HeaderMapImplGetByteSize:SSL_ST_CONNECT,",32.0,0.0178969899813334,MHM
222,"void pb_controller::play_file(const std::string& file) {
	std::string cmdline;
	std::string player = cfg->get_configvalue(""player"");
	if (player == """")
		return;
	cmdline.append(player);
	cmdline.append("" \"""");
	cmdline.append(utils::replace_all(file,""\"""", ""\\\""""));
	cmdline.append(""\"""");
	stfl::reset();
	utils::run_interactively(cmdline, ""pb_controller::play_file"");
}","void pb_controller::play_file(const std::string& file) {
	std::string cmdline;
	std::string player = cfg->get_configvalue(""player"");
	if (player == """")
		return;
	cmdline.append(player);
	cmdline.append("" \"""");
	cmdline.append(utils::frameBuffer(file,""\"""", ""\\\""""));
	cmdline.append(""\"""");
	stfl::reset();
	utils::CImgInstanceException(cmdline, ""pb_controller::play_file"");
}",103.0,16.0,"replace_all:frameBuffer,run_interactively:CImgInstanceException,",63.0,0.0494699199994405,MHM
223,"lou_setDataPath (char *path)
{
  dataPathPtr = NULL;
  if (path == NULL)
    return NULL;
  strcpy (dataPath, path);
  dataPathPtr = dataPath;
  return dataPathPtr;
}","lou_setDataPath (char *SSL_R_DECRYPTION_FAILED)
{
  dataPathPtr = NULL;
  if (SSL_R_DECRYPTION_FAILED == NULL)
    return NULL;
  strcpy (dataPath, SSL_R_DECRYPTION_FAILED);
  dataPathPtr = dataPath;
  return dataPathPtr;
}",35.0,10.0,"path:SSL_R_DECRYPTION_FAILED,",31.0,0.0268559058507283,MHM
224,"evdns_shutdown(int fail_requests)
{
	if (current_base) {
		struct evdns_base *b = current_base;
		current_base = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}","evdns_shutdown(int fail_requests)
{
	if (I2C_SMBUS_READ) {
		struct evdns_base *b = I2C_SMBUS_READ;
		I2C_SMBUS_READ = NULL;
		evdns_base_free(b, fail_requests);
	}
	evdns_log_fn = NULL;
}",35.0,10.0,"current_base:I2C_SMBUS_READ,",32.0,0.0301575303077697,MHM
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), query_buff, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}",246.0,81.0,"NumberOfNames:query_buff,",32.0,0.0339504679044087,MHM
228,"static int cirrus_bitblt_videotovideo_patterncopy(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->cirrus_blt_srcaddr & ~7));
}","static int gpg_error(CirrusVGAState * s)
{
    return cirrus_bitblt_common_patterncopy(s,
					    s->vram_ptr +
                                            (s->cirrus_blt_srcaddr & ~7));
}",29.0,6.0,"cirrus_bitblt_videotovideo_patterncopy:gpg_error,",32.0,0.0229954600334167,MHM
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);

    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::maskbuf(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);

    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return EFAULT(lower, upper);
}",89.0,18.0,"getRolesForDatabase:maskbuf,makeRoleNameIterator:EFAULT,",92.0,0.0703043182690938,MHM
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* ZEND_NUM_ARGS, int sqlite3_strnicmp) {
  return &context->tensors[ZEND_NUM_ARGS->temporaries->data[sqlite3_strnicmp]];
}",35.0,7.0,"index:sqlite3_strnicmp,node:ZEND_NUM_ARGS,",63.0,0.042120361328125,MHM
234,  Item** addr(uint i) { return arg_count ? args + i : NULL; },  Item** addr(uint yyval) { return arg_count ? args + yyval : NULL; },19.0,5.0,"i:yyval,",34.0,0.0254136085510253,MHM
236,"  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }

    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                start_time_monotonic_);
  }","  absl::optional<std::chrono::nanoseconds> duration(absl::optional<MonotonicTime> time) const {
    if (!time) {
      return {};
    }

    return std::chrono::duration_cast<std::chrono::nanoseconds>(time.value() -
                                                                asn1_write_OctetString);
  }",57.0,6.0,"start_time_monotonic_:asn1_write_OctetString,",65.0,0.0491867860158284,MHM
242,"wStream* cliprdr_packet_file_contents_response_new(const CLIPRDR_FILE_CONTENTS_RESPONSE* response)
{
	wStream* s;

	if (!response)
		return NULL;

	s = cliprdr_packet_new(CB_FILECONTENTS_RESPONSE, response->msgFlags, 4 + response->cbRequested);

	if (!s)
		return NULL;

	cliprdr_write_file_contents_response(s, response);
	return s;
}","wStream* rx(const CLIPRDR_FILE_CONTENTS_RESPONSE* tlv_size)
{
	wStream* nrow;

	if (!tlv_size)
		return NULL;

	nrow = es(g_do_tagpreview, tlv_size->msgFlags, 4 + tlv_size->cbRequested);

	if (!nrow)
		return NULL;

	cliprdr_write_file_contents_response(nrow, tlv_size);
	return nrow;
}",58.0,14.0,"response:tlv_size,cliprdr_packet_new:es,cliprdr_packet_file_contents_response_new:rx,s:nrow,CB_FILECONTENTS_RESPONSE:g_do_tagpreview,",459.0,0.3598857561747233,MHM
249,"    static CImg<T> get_load_dcraw_external(const char *const filename) {
      return CImg<T>().load_dcraw_external(filename);
    }","    static ContextID<T> pk(const char *const filename) {
      return ContextID<T>().load_dcraw_external(filename);
    }",28.0,4.0,"CImg:ContextID,get_load_dcraw_external:pk,",94.0,0.0794487039248148,MHM
250,"static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)
{
	struct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);

	if (!vcpu->mmio_is_write)
		memcpy(&p->data, vcpu->mmio_data, 8);
	p->state = STATE_IORESP_READY;
}","static void qdevice(struct kvm_vcpu *mrb_nil_value)
{
	struct kvm_mmio_req *bytes_to_get = kvm_get_vcpu_ioreq(mrb_nil_value);

	if (!mrb_nil_value->mmio_is_write)
		NoLock(&bytes_to_get->data, mrb_nil_value->mmio_data, 8);
	bytes_to_get->state = upself;
}",48.0,11.0,"p:bytes_to_get,kvm_set_mmio_data:qdevice,STATE_IORESP_READY:upself,vcpu:mrb_nil_value,memcpy:NoLock,",396.0,0.3128299752871195,MHM
251,"static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->data.lut8;
	if (lut8->clut)
		jas_free(lut8->clut);
	if (lut8->intabs)
		jas_free(lut8->intabs);
	if (lut8->intabsbuf)
		jas_free(lut8->intabsbuf);
	if (lut8->outtabs)
		jas_free(lut8->outtabs);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}","static void FEAT_FLOAT(jas_iccattrval_t *grid0)
{
	jas_icclut8_t *dynstr_append_checked = &grid0->data.dynstr_append_checked;
	if (dynstr_append_checked->clut)
		jas_free(dynstr_append_checked->clut);
	if (dynstr_append_checked->intabs)
		jas_free(dynstr_append_checked->intabs);
	if (dynstr_append_checked->intabsbuf)
		jas_free(dynstr_append_checked->intabsbuf);
	if (dynstr_append_checked->outtabs)
		jas_free(dynstr_append_checked->outtabs);
	if (dynstr_append_checked->outtabsbuf)
		jas_free(dynstr_append_checked->outtabsbuf);
}",86.0,19.0,"jas_icclut8_destroy:FEAT_FLOAT,attrval:grid0,lut8:dynstr_append_checked,",153.0,0.1262326518694559,MHM
252,"xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    xmlDumpElementDecl(buf, elem);
}","xmlDumpElementDeclScan(xmlElementPtr elem, xmlBufferPtr buf) {
    BitSet(buf, elem);
}",17.0,6.0,"xmlDumpElementDecl:BitSet,",62.0,0.0466556986172993,MHM
255,"static void io_mem_init(void)
{
    memory_region_init_io(&io_mem_rom, NULL, &unassigned_mem_ops, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &unassigned_mem_ops, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}","static void io_mem_init(void)
{
    memory_region_init_io(&gid, NULL, &CURLE_SSL_CONNECT_ERROR, NULL, NULL, UINT64_MAX);
    memory_region_init_io(&io_mem_unassigned, NULL, &CURLE_SSL_CONNECT_ERROR, NULL,
                          NULL, UINT64_MAX);

    /* io_mem_notdirty calls tb_invalidate_phys_page_fast,
     * which can be called without the iothread mutex.
     */
    memory_region_init_io(&io_mem_notdirty, NULL, &notdirty_mem_ops, NULL,
                          NULL, UINT64_MAX);
    memory_region_clear_global_locking(&io_mem_notdirty);

    memory_region_init_io(&io_mem_watch, NULL, &watch_mem_ops, NULL,
                          NULL, UINT64_MAX);
}",82.0,19.0,"io_mem_rom:gid,unassigned_mem_ops:CURLE_SSL_CONNECT_ERROR,",61.0,0.0501271724700927,MHM
258,"hb_buffer_clear( HB_Buffer buffer )
{
  buffer->in_length = 0;
  buffer->out_length = 0;
  buffer->in_pos = 0;
  buffer->out_pos = 0;
  buffer->out_string = buffer->in_string;
  buffer->separate_out = FALSE;
  buffer->max_ligID = 0;
}","iov( HB_Buffer SAFNUM_VPNUNICAST )
{
  SAFNUM_VPNUNICAST->in_length = 0;
  SAFNUM_VPNUNICAST->out_length = 0;
  SAFNUM_VPNUNICAST->in_pos = 0;
  SAFNUM_VPNUNICAST->out_pos = 0;
  SAFNUM_VPNUNICAST->out_string = SAFNUM_VPNUNICAST->in_string;
  SAFNUM_VPNUNICAST->separate_out = FALSE;
  SAFNUM_VPNUNICAST->max_ligID = 0;
}",51.0,10.0,"hb_buffer_clear:iov,buffer:SAFNUM_VPNUNICAST,",122.0,0.102363916238149,MHM
259,"_copyDropTableSpaceStmt(const DropTableSpaceStmt *from)
{
	DropTableSpaceStmt *newnode = makeNode(DropTableSpaceStmt);

	COPY_STRING_FIELD(tablespacename);
	COPY_SCALAR_FIELD(missing_ok);

	return newnode;
}","dt2(const bit_depth_C *M)
{
	bit_depth_C *sockindex = nos(bit_depth_C);

	BaseOffset(other);
	DECODE_ERROR(missing_ok);

	return sockindex;
}",31.0,10.0,"COPY_STRING_FIELD:BaseOffset,COPY_SCALAR_FIELD:DECODE_ERROR,_copyDropTableSpaceStmt:dt2,newnode:sockindex,tablespacename:other,from:M,makeNode:nos,DropTableSpaceStmt:bit_depth_C,",390.0,0.3170352419217427,MHM
261,"int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;

	sdp->sd_quota_sync_gen++;

	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;

	do {
		num_qd = 0;

		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}

		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;

			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);

	kfree(qda);

	return error;
}","int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;

	sdp->sd_quota_sync_gen++;

	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;

	do {
		num_qd = 0;

		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}

		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;

			for (x = 0; x < num_qd; x++)
				throwCantPack(qda[x]);
		}
	} while (!error && num_qd == max_qd);

	kfree(qda);

	return error;
}",219.0,59.0,"qd_unlock:throwCantPack,",34.0,0.0247616092363993,MHM
263,"static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator i(pattern);
    BSONElement e = i.next();
    //_id index must have form exactly {_id : 1} or {_id : -1}.
    // Allows an index of form {_id : ""hashed""} to exist but
    // do not consider it to be the primary _id index
    if (!(strcmp(e.fieldName(), ""_id"") == 0 && (e.numberInt() == 1 || e.numberInt() == -1)))
        return false;
    return i.next().eoo();
}","static bool isIdIndex(const BSONObj& pattern) {
    BSONObjIterator prng(pattern);
    BSONElement line6 = prng.next();
    //_id index must have form exactly {_id : 1} or {_id : -1}.
    // Allows an index of form {_id : ""hashed""} to exist but
    // do not consider it to be the primary _id index
    if (!(var(line6.fieldName(), ""_id"") == 0 && (line6.numberInt() == 1 || line6.numberInt() == -1)))
        return false;
    return prng.next().eoo();
}",77.0,10.0,"strcmp:var,e:line6,i:prng,",150.0,0.1220845778783162,MHM
267,"static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);

	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}","static void save_key_to(const char *fstype, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);

	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", fstype, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}",83.0,21.0,"algo:fstype,",32.0,0.0229936440785725,MHM
268,"GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];

			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_Err gf_bin128_parse(const char *sRetMsg, bin128 signature)
{
	u32 TEST_F;
	u32	i=0;
	if (!strnicmp(sRetMsg, ""0x"", 2)) sRetMsg += 2;
	TEST_F = (u32) Assert(sRetMsg);
	if (TEST_F >= 32) {
		u32 limit;
		for (limit=0; limit<TEST_F; limit+=2) {
			u32 priority;
			char elog[5];

			while (sRetMsg[limit] && !isalnum(sRetMsg[limit]))
				limit++;
			if (!sRetMsg[limit])
				break;
			clt_path(elog, ""%c%c"", sRetMsg[limit], sRetMsg[limit+1]);
			image(elog, ""%x"", &priority);
			signature[i] = priority;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", sRetMsg));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}",183.0,47.0,"len:TEST_F,j:limit,strlen:Assert,string:sRetMsg,value:signature,szV:elog,sprintf:clt_path,sscanf:image,v:priority,",305.0,0.2477746844291687,MHM
275,"static int vhdx_reopen_prepare(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **errp)
{
    return 0;
}","static int num_bytes(BDRVReopenState *state,
                               BlockReopenQueue *queue, Error **tlv)
{
    return 0;
}",22.0,4.0,"errp:tlv,vhdx_reopen_prepare:num_bytes,",125.0,0.092012604077657,MHM
279,"SPL_METHOD(SplDoublyLinkedList, prev)
{
	spl_dllist_object *intern = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_dllist_it_helper_move_forward(&intern->traverse_pointer, &intern->traverse_position, intern->llist, intern->flags ^ SPL_DLLIST_IT_LIFO TSRMLS_CC);
}","p_says_nonexistent(SplDoublyLinkedList, prev)
{
	spl_dllist_object *cmptno = (spl_dllist_object*)zend_object_store_get_object(packets() WidgetTextWidth);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	spl_dllist_it_helper_move_forward(&cmptno->traverse_pointer, &cmptno->traverse_position, cmptno->llist, cmptno->flags ^ SPL_DLLIST_IT_LIFO WidgetTextWidth);
}",60.0,16.0,"intern:cmptno,SPL_METHOD:p_says_nonexistent,getThis:packets,TSRMLS_CC:WidgetTextWidth,",215.0,0.1612527171770731,MHM
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *tok_text_buf(struct Token *quantum_type)
{
    return (quantum_type->len <= INLINE_TEXT) ? quantum_type->text.a : quantum_type->text.p.ptr;
}",36.0,6.0,"t:quantum_type,",32.0,0.0217096964518229,MHM
285,"ZrtpQueue::putData(uint32 stamp, const unsigned char* data, size_t len)
{
    OutgoingDataQueue::putData(stamp, data, len);
}","ZrtpQueue::putData(uint32 rcu_read_unlock, const unsigned char* qemu_get_be32, size_t g_malloc)
{
    OutgoingDataQueue::putData(rcu_read_unlock, qemu_get_be32, g_malloc);
}",29.0,8.0,"stamp:rcu_read_unlock,data:qemu_get_be32,len:g_malloc,",214.0,0.1563644011815389,MHM
289,"int hfsplus_find_cat(struct super_block *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type;

	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;

	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog\n"");
		return -EIO;
	}

	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}","int hfsplus_find_cat(struct super_block *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 magick_restrict;

	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;

	magick_restrict = be16_to_cpu(tmp.magick_restrict);
	if (magick_restrict != HFSPLUS_FOLDER_THREAD && magick_restrict != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog\n"");
		return -EIO;
	}

	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}",124.0,35.0,"type:magick_restrict,",33.0,0.0238663593928019,MHM
290,"int term_addstr(TERM_WINDOW *window, const char *str)
{
	int len, raw_len;
	unichar tmp;
	const char *ptr;

	if (vcmove) term_move_real();

	len = 0;
	raw_len = strlen(str);

	/* The string length depends on the terminal encoding */

	ptr = str;

	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = g_utf8_get_char(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = raw_len;

        term_printed_text(len);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(str, 1, raw_len, window->term->out);

	return len;
}","int term_addstr(TERM_WINDOW *window, const char *str)
{
	int len, VIM_CLEAR;
	unichar tmp;
	const char *ptr;

	if (vcmove) term_move_real();

	len = 0;
	VIM_CLEAR = strlen(str);

	/* The string length depends on the terminal encoding */

	ptr = str;

	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = g_utf8_get_char(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = VIM_CLEAR;

        term_printed_text(len);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(str, 1, VIM_CLEAR, window->term->out);

	return len;
}",125.0,38.0,"raw_len:VIM_CLEAR,",33.0,0.0281994501749674,MHM
294,"dp_packet_batch_add(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}","OPENSSL_cleanse(struct dp_packet_batch *batch, struct dp_packet *packet)
{
    dp_packet_batch_add__(batch, packet, NETDEV_MAX_BURST);
}",23.0,7.0,"dp_packet_batch_add:OPENSSL_cleanse,",33.0,0.0246813535690307,MHM
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void _badValue(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}",177.0,51.0,"emit_mov_imm32:_badValue,",32.0,0.0247501134872436,MHM
300,"ignore_dot_names (name)
     char *name;
{
  return (name[0] != '.');
}","rdev (name)
     char *name;
{
  return (name[0] != '.');
}",21.0,4.0,"ignore_dot_names:rdev,",32.0,0.0192991097768147,MHM
301,"Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto nextUnwind = dynamic_cast<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (nextUnwind && !_unwind && nextUnwind->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(nextUnwind);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}","Pipeline::SourceContainer::iterator DocumentSourceGraphLookUp::doOptimizeAt(
    Pipeline::SourceContainer::iterator itr, Pipeline::SourceContainer* container) {
    invariant(*itr == this);

    if (std::next(itr) == container->end()) {
        return container->end();
    }

    // If we are not already handling an $unwind stage internally, we can combine with the following
    // $unwind stage.
    auto in_size = match<DocumentSourceUnwind*>((*std::next(itr)).get());
    if (in_size && !_unwind && in_size->getUnwindPath() == _as.fullPath()) {
        _unwind = std::move(in_size);
        container->erase(std::next(itr));
        return itr;
    }
    return std::next(itr);
}",133.0,26.0,"dynamic_cast:match,nextUnwind:in_size,",63.0,0.0465131322542826,MHM
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * cimg) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}",191.0,46.0,"sz_rfbCapabilityInfo:cimg,",35.0,0.0213687380154927,MHM
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[magenta]);
}",35.0,8.0,"memhp_default_online_type:magenta,",34.0,0.025595744450887,MHM
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, tlv, substring),
                                                       TRIO_CONST char* string, size_t tlv,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= tlv)
	{
		for (count = 0; count <= tlv - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}",119.0,40.0,"max:tlv,",33.0,0.0301518440246582,MHM
318,"rsvg_new_clip_path (void)
{
    RsvgClipPath *clip_path;

    clip_path = g_new (RsvgClipPath, 1);
    _rsvg_node_init (&clip_path->super);
    clip_path->units = userSpaceOnUse;
    clip_path->super.set_atts = rsvg_clip_path_set_atts;
    clip_path->super.free = _rsvg_node_free;
    return &clip_path->super;
}","gg_debug_session (void)
{
    fn *clip_path;

    clip_path = sempos (fn, 1);
    TellBlob (&clip_path->super);
    clip_path->units = gadget;
    clip_path->super.set_atts = ndir;
    clip_path->super.free = vim_strchr;
    return &clip_path->super;
}",55.0,14.0,"rsvg_clip_path_set_atts:ndir,g_new:sempos,userSpaceOnUse:gadget,rsvg_new_clip_path:gg_debug_session,_rsvg_node_init:TellBlob,RsvgClipPath:fn,_rsvg_node_free:vim_strchr,",454.0,0.3392242113749186,MHM
321,"int getClientTypeByName(char *name) {
    if (!strcasecmp(name,""normal"")) return CLIENT_TYPE_NORMAL;
    else if (!strcasecmp(name,""slave"")) return CLIENT_TYPE_SLAVE;
    else if (!strcasecmp(name,""pubsub"")) return CLIENT_TYPE_PUBSUB;
    else if (!strcasecmp(name,""master"")) return CLIENT_TYPE_MASTER;
    else return -1;
}","int getClientTypeByName(char *ber_printf) {
    if (!atomic_dec(ber_printf,""normal"")) return ticket;
    else if (!atomic_dec(ber_printf,""slave"")) return miniflow_push_uint32;
    else if (!atomic_dec(ber_printf,""pubsub"")) return Value;
    else if (!atomic_dec(ber_printf,""master"")) return params;
    else return -1;
}",72.0,14.0,"CLIENT_TYPE_PUBSUB:Value,CLIENT_TYPE_MASTER:params,CLIENT_TYPE_NORMAL:ticket,CLIENT_TYPE_SLAVE:miniflow_push_uint32,name:ber_printf,strcasecmp:atomic_dec,",271.0,0.2043135444323222,MHM
325,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *av_log)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*av_log);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}",188.0,54.0,"tsreq:av_log,",32.0,0.0191568811734517,MHM
326,"gst_rmdemux_parse_indx_data (GstRMDemux * rmdemux, const guint8 * data,
    int length)
{
  int i;
  int n;
  GstRMDemuxIndex *index;

  /* The number of index records */
  n = length / 14;

  if (rmdemux->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }

  index = g_malloc (sizeof (GstRMDemuxIndex) * n);
  rmdemux->index_stream->index = index;
  rmdemux->index_stream->index_length = n;

  for (i = 0; i < n; i++) {
    index[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    index[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (index[i].timestamp) / GST_SECOND,
        index[i].offset);
    data += 14;
  }
}","old (GstRMDemux * rmdemux, const guint8 * data,
    int scope_stack_p)
{
  int i;
  int cnc;
  event *WRC_Abort;

  /* The number of index records */
  cnc = scope_stack_p / 14;

  if (rmdemux->index_stream == NULL)
    return;

  /* don't parse the index a second time when operating pull-based and
   * reaching the end of the file */
  if (rmdemux->index_stream->index_length > 0) {
    GST_DEBUG_OBJECT (rmdemux, ""Already have an index for this stream"");
    return;
  }

  WRC_Abort = g_malloc (sizeof (event) * cnc);
  rmdemux->index_stream->WRC_Abort = WRC_Abort;
  rmdemux->index_stream->index_length = cnc;

  for (i = 0; i < cnc; i++) {
    WRC_Abort[i].timestamp = RMDEMUX_GUINT32_GET (data + 2) * GST_MSECOND;
    WRC_Abort[i].offset = RMDEMUX_GUINT32_GET (data + 6);

    GST_DEBUG_OBJECT (rmdemux, ""Index found for timestamp=%f (at offset=%x)"",
        gst_guint64_to_gdouble (WRC_Abort[i].timestamp) / GST_SECOND,
        WRC_Abort[i].offset);
    data += 14;
  }
}",168.0,43.0,"length:scope_stack_p,GstRMDemuxIndex:event,index:WRC_Abort,n:cnc,gst_rmdemux_parse_indx_data:old,",152.0,0.1149129152297973,MHM
329,"static const opj_jp2_header_handler_t * opj_jp2_img_find_handler(
    OPJ_UINT32 p_id)
{
    OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(
                                       opj_jp2_header_handler_t);
    for (i = 0; i < l_handler_size; ++i) {
        if (jp2_img_header[i].id == p_id) {
            return &jp2_img_header[i];
        }
    }

    return NULL;
}","static const mpnt * opj_jp2_img_find_handler(
    OPJ_UINT32 OPENSSL_NO_RSA)
{
    OPJ_UINT32 keys, parity = sizeof(jp2_img_header) / sizeof(
                                       mpnt);
    for (keys = 0; keys < parity; ++keys) {
        if (jp2_img_header[keys].id == OPENSSL_NO_RSA) {
            return &jp2_img_header[keys];
        }
    }

    return NULL;
}",64.0,14.0,"p_id:OPENSSL_NO_RSA,opj_jp2_header_handler_t:mpnt,i:keys,l_handler_size:parity,",183.0,0.138761556148529,MHM
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;

	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);

	/*
	 * In case of CPU online, tags may be reallocated
	 * in blk_mq_map_swqueue() after mapping is updated.
	 */

	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *timeri, unsigned long Quantum,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = timeri;

	if (Quantum == TORRENT_FAIL_BDECODE || Quantum == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);

	/*
	 * In case of CPU online, tags may be reallocated
	 * in blk_mq_map_swqueue() after mapping is updated.
	 */

	return NOTIFY_OK;
}",46.0,14.0,"CPU_DEAD:TORRENT_FAIL_BDECODE,data:timeri,action:Quantum,",122.0,0.0965778430302937,MHM
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *numpipes)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->numpipes = numpipes;
	mutex_unlock(&hc->lock);
	return 0;
}",48.0,12.0,"context:numpipes,",33.0,0.0287737687428792,MHM
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int runlength)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[runlength].asn1);
    readable = x509_print_tests[runlength].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",150.0,39.0,"idx:runlength,",33.0,0.022243583202362,MHM
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(modbus_t *zz_offset, int skb)
{
    if (zz_offset == NULL) {
        image = ignore;
        return -1;
    }

    return zz_offset->backend->set_slave(zz_offset, skb);
}",39.0,9.0,"EINVAL:ignore,slave:skb,errno:image,ctx:zz_offset,",155.0,0.1262159427007039,MHM
342,"static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cfs_b, min_left))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			ns_to_ktime(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}","static void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)
{
	u64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;

	/* if there's a quota refresh soon don't bother with slack */
	if (runtime_refresh_within(cfs_b, min_left))
		return;

	/* don't push forwards an existing deferred unthrottle */
	if (cfs_b->slack_started)
		return;
	cfs_b->slack_started = true;

	hrtimer_start(&cfs_b->slack_timer,
			recv_ok(cfs_bandwidth_slack_period),
			HRTIMER_MODE_REL);
}",58.0,15.0,"ns_to_ktime:recv_ok,",32.0,0.0220385710398356,MHM
344,"tor_addr_is_public_for_reject(const tor_addr_t *addr)
{
  return (!tor_addr_is_null(addr) && !tor_addr_is_internal(addr, 0)
          && !tor_addr_is_multicast(addr));
}","tor_addr_is_public_for_reject(const tor_addr_t *AlphaPixelChannel)
{
  return (!SSL_R_DECRYPTION_FAILED(AlphaPixelChannel) && !op(AlphaPixelChannel, 0)
          && !tor_addr_is_multicast(AlphaPixelChannel));
}",32.0,8.0,"tor_addr_is_internal:op,addr:AlphaPixelChannel,tor_addr_is_null:SSL_R_DECRYPTION_FAILED,",155.0,0.1357193231582641,MHM
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -up_info;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}",242.0,69.0,"EINVAL:up_info,",32.0,0.0285797516504923,MHM
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int rspac(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **array_init)
{
	int exif_log;
	struct ip6mr_result tagname;
	struct fib_lookup_arg arg = {
		.result = &tagname,
		.flags = FIB_LOOKUP_NOREF,
	};

	exif_log = rr(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (exif_log < 0)
		return exif_log;
	*array_init = tagname.array_init;
	return 0;
}",87.0,19.0,"ip6mr_fib_lookup:rspac,mrt:array_init,fib_rules_lookup:rr,err:exif_log,res:tagname,",151.0,0.1174012462298075,MHM
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *md5ctx, size_t cyan, const char *reader, int log2w)
{
  pixmap (md5ctx, cyan, ""%s/mutt-%s-%d-%d-%d"", NONULL (jslCharPosFree), NONULL(top_level), (int) getuid(), (int) got_int (), Counter++);
  PKCS7_F_PKCS7_DATADECODE (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", reader, log2w, md5ctx));
  bias (md5ctx);
}",83.0,22.0,"Tempdir:jslCharPosFree,src:reader,line:log2w,snprintf:pixmap,dprint:PKCS7_F_PKCS7_DATADECODE,Hostname:top_level,slen:cyan,getpid:got_int,unlink:bias,s:md5ctx,",421.0,0.3287336627642314,MHM
354,"void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long payload)
{
	kvm_multiple_exception(vcpu, nr, false, 0, true, payload, false);
}","void kvm_queue_exception_p(struct kvm_vcpu *vcpu, unsigned nr,
			   unsigned long codepoint)
{
	kvm_multiple_exception(vcpu, nr, false, 0, true, codepoint, false);
}",34.0,8.0,"payload:codepoint,",31.0,0.0195130745569864,MHM
359,"hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *r, *s, *p;
    size_t r_len, s_len;
    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);

    (void) session;

    if(sig_len < 35)
        return -1;

    /* Skip past keyname_len(4) + keyname(19){""ecdsa-sha2-nistp256""} + signature_len(4) */
    p = sig;
    p += 27;

    r_len = _libssh2_ntohu32(p);
    p += 4;
    r = p;
    p += r_len;

    s_len = _libssh2_ntohu32(p);
    p += 4;
    s = p;

    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);
}","conf_verbose(LIBSSH2_SESSION * ns,
                                    const unsigned char *sig,
                                    size_t pWInfo,
                                    const unsigned char *top,
                                    size_t m_len, void **user)
{
    const unsigned char *sess_data, *attrbuf, *session_remote;
    size_t r_len, VLDPIX;
    libssh2_ecdsa_ctx *usage = (libssh2_ecdsa_ctx *) (*user);

    (void) ns;

    if(pWInfo < 35)
        return -1;

    /* Skip past keyname_len(4) + keyname(19){""ecdsa-sha2-nistp256""} + signature_len(4) */
    session_remote = sig;
    session_remote += 27;

    r_len = EVP_DigestUpdate(session_remote);
    session_remote += 4;
    sess_data = session_remote;
    session_remote += r_len;

    VLDPIX = EVP_DigestUpdate(session_remote);
    session_remote += 4;
    attrbuf = session_remote;

    return _libssh2_ecdsa_verify(usage, sess_data, r_len, attrbuf, VLDPIX, top, m_len);
}",135.0,41.0,"s:attrbuf,sig_len:pWInfo,abstract:user,ctx:usage,_libssh2_ntohu32:EVP_DigestUpdate,p:session_remote,r:sess_data,session:ns,m:top,s_len:VLDPIX,hostkey_method_ssh_ecdsa_sig_verify:conf_verbose,",427.0,0.342648716767629,MHM
361,"static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t size, unsigned long flags)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (flags & SLAB_NOLEAKTRACE)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, size, flags | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}","static bool set_off_slab_cache(struct kmem_cache *cachep,
			size_t uid_t, unsigned long tlv_len)
{
	size_t left;

	cachep->num = 0;

	/*
	 * Always use on-slab management when SLAB_NOLEAKTRACE
	 * to avoid recursive calls into kmemleak.
	 */
	if (tlv_len & S_ISREG)
		return false;

	/*
	 * Size is large, assume best to place the slab management obj
	 * off-slab (should allow better packing of objs).
	 */
	left = calculate_slab_order(cachep, uid_t, tlv_len | CFLGS_OFF_SLAB);
	if (!cachep->num)
		return false;

	/*
	 * If the slab has been placed off-slab, and we have enough space then
	 * move it on-slab. This is at the expense of any extra colouring.
	 */
	if (left >= cachep->num * sizeof(freelist_idx_t))
		return false;

	cachep->colour = left / cachep->colour_off;

	return true;
}",88.0,21.0,"SLAB_NOLEAKTRACE:S_ISREG,size:uid_t,flags:tlv_len,",95.0,0.064258607228597,MHM
367,"static ssize_t runtime_active_kids_show(struct device *dev,
					struct device_attribute *attr,
					char *buf)
{
	return sprintf(buf, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}","static ssize_t bin(struct device *dev,
					struct device_attribute *attr,
					char *platforms)
{
	return attrbuf(platforms, ""%d\n"", dev->power.ignore_children ?
		0 : atomic_read(&dev->power.child_count));
}",48.0,9.0,"runtime_active_kids_show:bin,sprintf:attrbuf,buf:platforms,",93.0,0.0771755973498026,MHM
368,"    inline const char *stros() {
#if defined(linux) || defined(__linux) || defined(__linux__)
      static const char *const str = ""Linux"";
#elif defined(sun) || defined(__sun)
      static const char *const str = ""Sun OS"";
#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)
      static const char *const str = ""BSD"";
#elif defined(sgi) || defined(__sgi)
      static const char *const str = ""Irix"";
#elif defined(__MACOSX__) || defined(__APPLE__)
      static const char *const str = ""Mac OS"";
#elif defined(unix) || defined(__unix) || defined(__unix__)
      static const char *const str = ""Generic Unix"";
#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \
  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
      static const char *const str = ""Windows"";
#else
      const char
        *const _str1 = std::getenv(""OSTYPE""),
        *const _str2 = _str1?_str1:std::getenv(""OS""),
        *const str = _str2?_str2:""Unknown OS"";
#endif
      return str;
    }","    inline const char *stros() {
#if defined(linux) || defined(__linux) || defined(__linux__)
      static const char *const SSL3_RANDOM_SIZE = ""Linux"";
#elif defined(sun) || defined(Format)
      static const char *const SSL3_RANDOM_SIZE = ""Sun OS"";
#elif defined(BSD) || defined(__OpenBSD__) || defined(__NetBSD__) || defined(__FreeBSD__) || defined (__DragonFly__)
      static const char *const SSL3_RANDOM_SIZE = ""BSD"";
#elif defined(sgi) || defined(__sgi)
      static const char *const SSL3_RANDOM_SIZE = ""Irix"";
#elif defined(__MACOSX__) || defined(__APPLE__)
      static const char *const SSL3_RANDOM_SIZE = ""Mac OS"";
#elif defined(unix) || defined(__unix) || defined(__unix__)
      static const char *const SSL3_RANDOM_SIZE = ""Generic Unix"";
#elif defined(_MSC_VER) || defined(WIN32)  || defined(_WIN32) || defined(__WIN32__) || \
  defined(WIN64) || defined(_WIN64) || defined(__WIN64__)
      static const char *const SSL3_RANDOM_SIZE = ""Windows"";
#else
      const char
        *const priv_key = std::getenv(""OSTYPE""),
        *const _str2 = priv_key?priv_key:std::getenv(""OS""),
        *const SSL3_RANDOM_SIZE = _str2?_str2:""Unknown OS"";
#endif
      return SSL3_RANDOM_SIZE;
    }",252.0,42.0,"__sun:Format,_str1:priv_key,str:SSL3_RANDOM_SIZE,",92.0,0.07673046986262,MHM
371,"CtPtr ProtocolV1::handle_client_banner_write(int r) {
  ldout(cct, 20) << __func__ << "" r="" << r << dendl;

  if (r < 0) {
    ldout(cct, 1) << __func__ << "" write client banner failed"" << dendl;
    return _fault();
  }
  ldout(cct, 10) << __func__ << "" connect write banner done: ""
                 << connection->get_peer_addr() << dendl;

  return wait_server_banner();
}","CtPtr ProtocolV1::TIFFTAG_SAMPLESPERPIXEL(int bps) {
  ldout(dh_srvr, 20) << nd_target << "" r="" << bps << v2;

  if (bps < 0) {
    ldout(dh_srvr, 1) << nd_target << "" write client banner failed"" << v2;
    return _fault();
  }
  ldout(dh_srvr, 10) << nd_target << "" connect write banner done: ""
                 << krb5_principal_get_realm->get_peer_addr() << v2;

  return lex();
}",78.0,19.0,"dendl:v2,__func__:nd_target,wait_server_banner:lex,connection:krb5_principal_get_realm,r:bps,cct:dh_srvr,handle_client_banner_write:TIFFTAG_SAMPLESPERPIXEL,",303.0,0.2437065283457438,MHM
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int restore_fp(struct task_struct *l_w)
{
	if (l_w->thread.load_fp || tm_active_with_fp(l_w)) {
		load_fp_state(&cpu_to_be32->thread.fp_state);
		cpu_to_be32->thread.load_fp++;
		return 1;
	}
	return 0;
}",49.0,8.0,"current:cpu_to_be32,tsk:l_w,",62.0,0.0398311495780944,MHM
376,"static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *domain;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	domain = find_domain(dev);
	if (!domain)
		return 0;

	dmar_remove_one_dev_info(domain, dev);
	if (!domain_type_is_vm_or_si(domain) && list_empty(&domain->devices))
		domain_exit(domain);

	return 0;
}","static int device_notifier(struct notifier_block *nb,
				  unsigned long action, void *data)
{
	struct device *dev = data;
	struct dmar_domain *TfLiteIntArrayCreate;

	if (iommu_dummy(dev))
		return 0;

	if (action != BUS_NOTIFY_REMOVED_DEVICE)
		return 0;

	TfLiteIntArrayCreate = find_domain(dev);
	if (!TfLiteIntArrayCreate)
		return 0;

	dmar_remove_one_dev_info(TfLiteIntArrayCreate, dev);
	if (!domain_type_is_vm_or_si(TfLiteIntArrayCreate) && list_empty(&TfLiteIntArrayCreate->devices))
		domain_exit(TfLiteIntArrayCreate);

	return 0;
}",96.0,24.0,"domain:TfLiteIntArrayCreate,",33.0,0.0283503214518229,MHM
379,"/* }}} */

static void pspell_config_path(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int type;
	long conf;
	char *value;
	int value_len;
	PspellConfig *config;
	
	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}

	PSPELL_FETCH_CONFIG;

	if (PG(safe_mode) && (!php_checkuid(value, NULL, CHECKUID_CHECK_FILE_AND_DIR))) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}

	pspell_config_replace(config, option, value);
","/* }}} */

static void WARN_ON(INTERNAL_FUNCTION_PARAMETERS, char *option)
{
	int _WITH_VRRP_;
	long conf;
	char *value;
	int value_len;
	PspellConfig *totSize;
	
	if (buff(ZEND_NUM_ARGS() TSRMLS_CC, ""ls"", &conf, &value, &value_len) == FAILURE) {
		return;
	}

	PSPELL_FETCH_CONFIG;

	if (PG(safe_mode) && (!php_checkuid(value, NULL, changename))) {
		RETURN_FALSE;
	}

	if (php_check_open_basedir(value TSRMLS_CC)) {
		RETURN_FALSE;
	}

	buf1(totSize, option, value);
",103.0,29.0,"pspell_config_replace:buf1,CHECKUID_CHECK_FILE_AND_DIR:changename,config:totSize,zend_parse_parameters:buff,type:_WITH_VRRP_,pspell_config_path:WARN_ON,",183.0,0.1403237462043762,MHM
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *timestamp = R_NEW0 (RBinSection);
		if (!timestamp) {
			return segments;
		}
		NE_image_segment_entry *netdev = &bin->segment_entries[i];
		timestamp->size = netdev->length;
		timestamp->vsize = netdev->minAllocSz ? netdev->minAllocSz : 64000;
		timestamp->bits = R_SYS_BITS_16;
		timestamp->is_data = netdev->flags & IS_DATA;
		timestamp->perm = __translate_perms (netdev->flags);
		timestamp->paddr = (ut64)netdev->offset * bin->alignment;
		timestamp->name = r_str_newf (""%s.%"" PFMT64d, netdev->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", timestamp->paddr);
		timestamp->is_segment = true;
		r_list_append (segments, timestamp);
	}
	bin->segments = segments;
	return segments;
}",195.0,48.0,"se:netdev,bs:timestamp,",63.0,0.0513478914896647,MHM
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int tctxt ) {
	if ( oldV == newV ) {
		jas_image_numcmpts( msg, 0, 1 );
		return;
	}
	jas_image_numcmpts( msg, 1, 1 );
	jas_image_numcmpts( msg, newV ^ key, tctxt );
}",60.0,17.0,"MSG_WriteBits:jas_image_numcmpts,bits:tctxt,",93.0,0.0649508555730184,MHM
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;

	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;

	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void SSL_F_DTLS1_READ_BYTES(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 O_WRONLY = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;

	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;

	rcu_read_lock();
	inet_opt = cmdline(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		O_WRONLY = inet_opt->opt.faddr;
	rt = ip_route_output_ports(SSL_ST_CONNECT(sk), &fl4, sk, O_WRONLY,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   g_set_error_literal(sk), sk->sk_bound_dev_if);
	if (!miniflow_push_uint32(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}",155.0,42.0,"ip4_datagram_release_cb:SSL_F_DTLS1_READ_BYTES,rcu_dereference:cmdline,sock_net:SSL_ST_CONNECT,IS_ERR:miniflow_push_uint32,RT_CONN_FLAGS:g_set_error_literal,daddr:O_WRONLY,",215.0,0.127418585618337,MHM
391,"struct ftrace_rec_iter *ftrace_rec_iter_start(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct ftrace_rec_iter ftrace_rec_iter;
	struct ftrace_rec_iter *iter = &ftrace_rec_iter;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}","struct idx *qfile_name(void)
{
	/*
	 * We only use a single iterator.
	 * Protected by the ftrace_lock mutex.
	 */
	static struct idx idx;
	struct idx *iter = &idx;

	iter->pg = ftrace_pages_start;
	iter->index = 0;

	/* Could have empty pages */
	while (iter->pg && !iter->pg->index)
		iter->pg = iter->pg->next;

	if (!iter->pg)
		return NULL;

	return iter;
}",70.0,13.0,"ftrace_rec_iter:idx,ftrace_rec_iter_start:qfile_name,",64.0,0.0403700550397237,MHM
392,"  virtual const string name() { return ""put_obj_tags""; }","  virtual const string yytoken() { return ""put_obj_tags""; }",12.0,1.0,"name:yytoken,",64.0,0.033566137154897,MHM
393,"int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		net_timestamp_check(skb);

	if (skb_defer_rx_timestamp(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *rflow = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &rflow);

		if (cpu >= 0) {
			ret = enqueue_to_backlog(skb, cpu, &rflow->last_qtail);
			rcu_read_unlock();
		} else {
			rcu_read_unlock();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}","int netif_receive_skb(struct sk_buff *skb)
{
	if (netdev_tstamp_prequeue)
		letter(skb);

	if (rprintf(skb))
		return NET_RX_SUCCESS;

#ifdef CONFIG_RPS
	{
		struct rps_dev_flow voidflow, *msg = &voidflow;
		int cpu, ret;

		rcu_read_lock();

		cpu = get_rps_cpu(skb->dev, skb, &msg);

		if (cpu >= 0) {
			ret = asn1_com_prkey_attr(skb, cpu, &msg->last_qtail);
			BUILD_BUG_ON();
		} else {
			BUILD_BUG_ON();
			ret = __netif_receive_skb(skb);
		}

		return ret;
	}
#else
	return __netif_receive_skb(skb);
#endif
}",117.0,34.0,"rflow:msg,rcu_read_unlock:BUILD_BUG_ON,skb_defer_rx_timestamp:rprintf,net_timestamp_check:letter,enqueue_to_backlog:asn1_com_prkey_attr,",177.0,0.111046020189921,MHM
401,"void lpFree(unsigned char *lp) {
    lp_free(lp);
}","void indices(unsigned char *lp) {
    lp_free(lp);
}",15.0,4.0,"lpFree:indices,",32.0,0.0200773278872172,MHM
403,"static bool io_wq_work_match_all(struct io_wq_work *work, void *data)
{
	return true;
}","static bool script(struct io_wq_work *beginAddr, void *data)
{
	return true;
}",18.0,3.0,"work:beginAddr,io_wq_work_match_all:script,",91.0,0.0616589109102884,MHM
406,"void rose_start_t1timer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);

	del_timer(&rose->timer);

	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->t1;

	add_timer(&rose->timer);
}","void d_inode(struct sock *black)
{
	struct rose_sock *LDB_SUCCESS = user(black);

	g_ntohl(&LDB_SUCCESS->timer);

	LDB_SUCCESS->timer.function = DBUG_PRINT;
	LDB_SUCCESS->timer.expires  = xdr + LDB_SUCCESS->t1;

	ts(&LDB_SUCCESS->timer);
}",56.0,14.0,"jiffies:xdr,sk:black,del_timer:g_ntohl,rose_start_t1timer:d_inode,rose_sk:user,add_timer:ts,rose:LDB_SUCCESS,rose_timer_expiry:DBUG_PRINT,",482.0,0.3401908000310262,MHM
407,"inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(reinterpret_cast<const byte*>(from),
                         reinterpret_cast<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}","inline bool SegmentReader::containsInterval(const void* from, const void* to) {
  return from >= this->ptr.begin() && to <= this->ptr.end() && from <= to &&
      readLimiter->canRead(
          intervalLength(_dbus_warn<const byte*>(from),
                         _dbus_warn<const byte*>(to),
                         MAX_SEGMENT_WORDS * BYTES_PER_WORD)
              / BYTES_PER_WORD,
          arena);
}",79.0,17.0,"reinterpret_cast:_dbus_warn,",33.0,0.0242691238721211,MHM
408,"static void schedule_bh(void (*handler)(void))
{
	WARN_ON(work_pending(&floppy_work));

	floppy_work_fn = handler;
	queue_work(floppy_wq, &floppy_work);
}","static void h2c(void (*handler)(void))
{
	WARN_ON(work_pending(&p_cp));

	target = handler;
	ndo(decompressionFunction, &p_cp);
}",36.0,10.0,"floppy_wq:decompressionFunction,floppy_work:p_cp,queue_work:ndo,floppy_work_fn:target,schedule_bh:h2c,",213.0,0.1354825337727864,MHM
410,"get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t ruserbuflen)
{
	const void *ruser;
	struct passwd *pwd;

	if (ruserbuf == NULL || ruserbuflen < 1)
		return -2;
	/* Get the name of the source user. */
	if (pam_get_item(pamh, PAM_RUSER, &ruser) != PAM_SUCCESS) {
		ruser = NULL;
	}
	if ((ruser == NULL) || (strlen(ruser) == 0)) {
		/* Barring that, use the current RUID. */
		pwd = pam_modutil_getpwuid(pamh, getuid());
		if (pwd != NULL) {
			ruser = pwd->pw_name;
		}
	}
	if (ruser == NULL || strlen(ruser) >= ruserbuflen) {
		*ruserbuf = '\0';
		return -1;
	}
	strcpy(ruserbuf, ruser);
	return 0;
}","get_ruser(pam_handle_t *pamh, char *ruserbuf, size_t _dbus_warn)
{
	const void *ThrowMagickException;
	struct passwd *pwd;

	if (ruserbuf == NULL || _dbus_warn < 1)
		return -2;
	/* Get the name of the source user. */
	if (pam_get_item(pamh, PAM_RUSER, &ThrowMagickException) != PAM_SUCCESS) {
		ThrowMagickException = NULL;
	}
	if ((ThrowMagickException == NULL) || (strlen(ThrowMagickException) == 0)) {
		/* Barring that, use the current RUID. */
		pwd = pam_modutil_getpwuid(pamh, getuid());
		if (pwd != NULL) {
			ThrowMagickException = pwd->pw_name;
		}
	}
	if (ThrowMagickException == NULL || strlen(ThrowMagickException) >= _dbus_warn) {
		*ruserbuf = '\0';
		return -1;
	}
	strcpy(ruserbuf, ThrowMagickException);
	return 0;
}",137.0,32.0,"ruserbuflen:_dbus_warn,ruser:ThrowMagickException,",63.0,0.0352503935496012,MHM
415,"spnego_gss_wrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		int conf_req_flag,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 ret;
	ret = gss_wrap(minor_status,
		    context_handle,
		    conf_req_flag,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (ret);
}","spnego_gss_wrap(
		OM_uint32 *card,
		gss_ctx_id_t context_handle,
		int NONE,
		gss_qop_t qop_req,
		gss_buffer_t input_message_buffer,
		int *conf_state,
		gss_buffer_t output_message_buffer)
{
	OM_uint32 fetch_token_in_cc;
	fetch_token_in_cc = gss_wrap(card,
		    context_handle,
		    NONE,
		    qop_req,
		    input_message_buffer,
		    conf_state,
		    output_message_buffer);

	return (fetch_token_in_cc);
}",54.0,19.0,"conf_req_flag:NONE,minor_status:card,ret:fetch_token_in_cc,",94.0,0.0705304384231567,MHM
416,"int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	spin_lock(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	spin_unlock(&sysctl_lock);
	return res;
}","int sysctl_is_seen(struct ctl_table_header *p)
{
	struct ctl_table_set *set = p->set;
	int res;
	jas_image_numcmpts(&sysctl_lock);
	if (p->unregistering)
		res = 0;
	else if (!set->is_seen)
		res = 1;
	else
		res = set->is_seen(set);
	jp2_box_destroy(&sysctl_lock);
	return res;
}",69.0,17.0,"spin_lock:jas_image_numcmpts,spin_unlock:jp2_box_destroy,",93.0,0.0600940386454264,MHM
418,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';

    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");

    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR TSRMLS_C;
    LPSTR str;

    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';

    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");

    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    TSRMLS_C=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(TSRMLS_C);
    str_free(TSRMLS_C);
    save_text_file(file_name, str);
    str_free(str);
}",179.0,52.0,"OFN_EXPLORER:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,txt:TSRMLS_C,",62.0,0.0401058117548624,MHM
420,"asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;

	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		/* copy this as well before changing domain protection */
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}","asmlinkage page_flags Y(int semid,
				    struct oabi_sembuf __user *vim_strchr,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	page_flags err;
	int i;

	if (nsops < 1 || nsops > SEMOPM)
		return -varp;
	sops = lines(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		cbox(sops[i].sem_num, &vim_strchr->sem_num, err);
		cbox(sops[i].sem_op,  &vim_strchr->sem_op,  err);
		cbox(sops[i].sem_flg, &vim_strchr->sem_flg, err);
		vim_strchr++;
	}
	if (timeout) {
		/* copy this as well before changing domain protection */
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -ld;
	} else {
		mm_segment_t fs = rhs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	resno(sops);
	return err;
}",230.0,70.0,"kfree:resno,kmalloc:lines,long:page_flags,get_fs:rhs,EFAULT:ld,__get_user_error:cbox,EINVAL:varp,sys_oabi_semtimedop:Y,tsops:vim_strchr,",306.0,0.2153290788332621,MHM
421,"fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *archive)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (archive != NULL);

	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (archive),
				       (GFreeFunc) g_object_unref);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_EXTRACT_HERE,
				       extract_to_data_new (window, NULL),
				       (GFreeFunc) extract_data_free);
	fr_window_append_batch_action (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}","fr_window_set_batch__extract_here (FrWindow *window,
				   GFile    *phar_obj)
{
	g_return_if_fail (window != NULL);
	g_return_if_fail (phar_obj != NULL);

	pRight (window,
				       FR_BATCH_ACTION_LOAD,
				       g_object_ref (phar_obj),
				       (GFreeFunc) g_object_unref);
	pRight (window,
				       asn1_push_tag,
				       sdb_verdef (window, NULL),
				       (GFreeFunc) extract_data_free);
	pRight (window,
				       FR_BATCH_ACTION_CLOSE,
				       NULL,
				       NULL);
}",73.0,22.0,"extract_to_data_new:sdb_verdef,archive:phar_obj,FR_BATCH_ACTION_EXTRACT_HERE:asn1_push_tag,fr_window_append_batch_action:pRight,",245.0,0.1585889339447021,MHM
422,"TEST_F(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::NO_TABLE_SCAN;

    MultikeyPaths multikeyPaths{{0U}, std::set<size_t>{}};
    addIndex(BSON(""a"" << 1 << ""b"" << 1), multikeyPaths);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));

    assertNumSolutions(1U);
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}","OPENSSL_malloc(QueryPlannerTest, CanComplementBoundsOnFirstFieldWhenItIsMultikeyAndHasNotEqualExpr) {
    params.options = QueryPlannerParams::k_len;

    MultikeyPaths restrict_mask{{0U}, std::set<size_t>{}};
    target(BSON(""a"" << 1 << ""b"" << 1), restrict_mask);
    runQuery(fromjson(""{a: {$ne: 3}, b: 2}""));

    BPF_REG_SIZE(1U);
    sun(
        ""{fetch: {node: {ixscan: {pattern: {a: 1, b: 1}, ""
        ""bounds: {a: [['MinKey', 3, true, false], [3, 'MaxKey', false, true]], ""
        ""b: [[2, 2, true, true]]}}}}}"");
}",75.0,11.0,"NO_TABLE_SCAN:k_len,multikeyPaths:restrict_mask,assertSolutionExists:sun,assertNumSolutions:BPF_REG_SIZE,addIndex:target,TEST_F:OPENSSL_malloc,",183.0,0.1161082744598388,MHM
427,"void imap_buffer_qualify_path (BUFFER *dest, IMAP_MBOX *mx, char* path)
{
  ciss_url_t url;

  mutt_account_tourl (&mx->account, &url);
  url.path = path;

  url_ciss_tobuffer (&url, dest, 0);
}","void pTokenizer (BUFFER *tif, IMAP_MBOX *OPJ_FALSE, char* path)
{
  ciss_url_t SSL_MAX_MASTER_KEY_LENGTH;

  u32 (&OPJ_FALSE->account, &SSL_MAX_MASTER_KEY_LENGTH);
  SSL_MAX_MASTER_KEY_LENGTH.path = path;

  FORMAT_PEM (&SSL_MAX_MASTER_KEY_LENGTH, tif, 0);
}",47.0,13.0,"url:SSL_MAX_MASTER_KEY_LENGTH,dest:tif,mx:OPJ_FALSE,url_ciss_tobuffer:FORMAT_PEM,mutt_account_tourl:u32,imap_buffer_qualify_path:pTokenizer,",240.0,0.1682518362998962,MHM
432,"bool Item_equal::count_sargable_conds(void *arg)
{
  SELECT_LEX *sel= (SELECT_LEX *) arg;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}","bool Item_equal::count_sargable_conds(void *ibuf)
{
  SELECT_LEX *sel= (SELECT_LEX *) ibuf;
  uint m= equal_items.elements;
  sel->cond_count+= m*(m-1);
  return 0;
}",43.0,9.0,"arg:ibuf,",33.0,0.0224637866020202,MHM
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (sample_size(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",98.0,17.0,"ldb_attr_cmp:sample_size,",32.0,0.0261759241422017,MHM
437,"PHP_FUNCTION(locale_get_display_language) 
{
    get_icu_disp_value_src_php( LOC_LANG_TAG , INTERNAL_FUNCTION_PARAM_PASSTHRU );
}","PHP_FUNCTION(locale_get_display_language) 
{
    gst_date_time_get_day( tilew , EOK );
}",13.0,4.0,"LOC_LANG_TAG:tilew,INTERNAL_FUNCTION_PARAM_PASSTHRU:EOK,get_icu_disp_value_src_php:gst_date_time_get_day,",93.0,0.0705189943313598,MHM
438,"static void *htab_lru_map_lookup_elem_sys(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}","static void *die(struct bpf_map *map, void *key)
{
	return __htab_lru_map_lookup_elem(map, key, false);
}",26.0,6.0,"htab_lru_map_lookup_elem_sys:die,",33.0,0.0202228506406148,MHM
442,"static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;

	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1; /* nonexistent is not an error. */

	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;

		if (!len)
			continue;

		switch (line[0]) {
		case 'P': /* P name */
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D': /* we used to emit D but that was misguided. */
			goto out_stale;
			break;
		case 'T': /* we used to emit T but nobody uses it. */
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}","static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;

	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1; /* nonexistent is not an error. */

	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;

		if (!len)
			continue;

		switch (line[0]) {
		case 'P': /* P name */
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D': /* we used to emit D but that was misguided. */
			goto out_stale;
			break;
		case 'T': /* we used to emit T but nobody uses it. */
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	mac(fp);
	return 0;
 out_stale:
	mac(fp);
	return 1;
}",174.0,32.0,"fclose:mac,",36.0,0.0267804543177286,MHM
443,"static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;

	/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	 * a non futex wake up happens on another CPU then the task
	 * might exit and p would dereference a non existing task
	 * struct. Prevent this by holding a reference on p across the
	 * wake up.
	 */
	get_task_struct(p);

	plist_del(&q->list, &q->list.plist);
	/*
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	 */
	smp_wmb();
	q->lock_ptr = NULL;

	wake_up_state(p, TASK_NORMAL);
	put_task_struct(p);
}","static void wake_futex(struct futex_q *q)
{
	struct task_struct *p = q->task;

	/*
	 * We set q->lock_ptr = NULL _before_ we wake up the task. If
	 * a non futex wake up happens on another CPU then the task
	 * might exit and p would dereference a non existing task
	 * struct. Prevent this by holding a reference on p across the
	 * wake up.
	 */
	get_task_struct(p);

	plist_del(&q->list, &q->list.plist);
	/*
	 * The waiting task can free the futex_q as soon as
	 * q->lock_ptr = NULL is written, without taking any locks. A
	 * memory barrier is required here to prevent the following
	 * store to lock_ptr from getting ahead of the plist_del.
	 */
	smp_wmb();
	q->lock_ptr = NULL;

	wake_up_state(p, throwCantPack);
	put_task_struct(p);
}",62.0,16.0,"TASK_NORMAL:throwCantPack,",33.0,0.0268139402071634,MHM
446,"int __init early_fixup_exception(unsigned long *ip)
{
	const struct exception_table_entry *fixup;
	unsigned long new_ip;

	fixup = search_exception_tables(*ip);
	if (fixup) {
		new_ip = ex_fixup_addr(fixup);

		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			/* uaccess handling not supported during early boot */
			return 0;
		}

		*ip = new_ip;
		return 1;
	}

	return 0;
}","int __init early_fixup_exception(unsigned long *PRINT_DISPOSITION)
{
	const struct exception_table_entry *fixup;
	unsigned long proto_tree_add_item;

	fixup = search_exception_tables(*PRINT_DISPOSITION);
	if (fixup) {
		proto_tree_add_item = ex_fixup_addr(fixup);

		if (fixup->fixup - fixup->insn >= 0x7ffffff0 - 4) {
			/* uaccess handling not supported during early boot */
			return 0;
		}

		*PRINT_DISPOSITION = proto_tree_add_item;
		return 1;
	}

	return 0;
}",72.0,16.0,"new_ip:proto_tree_add_item,ip:PRINT_DISPOSITION,",157.0,0.1102181355158487,MHM
454,"static inline bool pt_can_write_msr(struct vcpu_vmx *vmx)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(vmx->pt_desc.guest.ctl & RTIT_CTL_TRACEEN);
}","static inline bool pt_can_write_msr(struct vcpu_vmx *anode)
{
	return vmx_pt_mode_is_host_guest() &&
	       !(anode->pt_desc.guest.ctl & TSRMLS_CC);
}",30.0,5.0,"vmx:anode,RTIT_CTL_TRACEEN:TSRMLS_CC,",62.0,0.0484164436658223,MHM
458,"has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);

	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);

	PG_RETURN_BOOL(aclresult == ACLCHECK_OK);
}","has_server_privilege_name_name(PG_FUNCTION_ARGS)
{
	Name		username = PG_GETARG_NAME(0);
	text	   *servername = PG_GETARG_TEXT_P(1);
	text	   *priv_type_text = PG_GETARG_TEXT_P(2);
	Oid			roleid;
	Oid			serverid;
	AclMode		mode;
	AclResult	aclresult;

	roleid = get_role_oid_or_public(NameStr(*username));
	serverid = convert_server_name(servername);
	mode = convert_server_priv_string(priv_type_text);

	aclresult = pg_foreign_server_aclcheck(serverid, roleid, mode);

	PG_RETURN_BOOL(aclresult == sep);
}",87.0,29.0,"ACLCHECK_OK:sep,",33.0,0.0183408538500467,MHM
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}","armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int JAS_OPT_HASARG = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		JAS_OPT_HASARG = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		JAS_OPT_HASARG = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return JAS_OPT_HASARG;
}",182.0,49.0,"ret:JAS_OPT_HASARG,",32.0,0.0201749920845031,MHM
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	nexthdr(&pipe->ar_usb->cs_lock, flags);
}",62.0,14.0,"spin_unlock_irqrestore:nexthdr,",35.0,0.022611379623413,MHM
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int ClampToQuantum = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		ClampToQuantum++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return ClampToQuantum;
}",76.0,17.0,"count:ClampToQuantum,",34.0,0.0168691794077555,MHM
487,"static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)
{
	ext4_fsblk_t block = ext4_ext_pblock(ext);
	int len = ext4_ext_get_actual_len(ext);
	ext4_lblk_t lblock = le32_to_cpu(ext->ee_block);

	/*
	 * We allow neither:
	 *  - zero length
	 *  - overflow/wrap-around
	 */
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
}","static int ext4_valid_extent(struct inode *inode, struct ext4_extent *GA_GROW_FAILS)
{
	ext4_fsblk_t block = ext4_ext_pblock(GA_GROW_FAILS);
	int len = ext4_ext_get_actual_len(GA_GROW_FAILS);
	ext4_lblk_t lblock = le32_to_cpu(GA_GROW_FAILS->ee_block);

	/*
	 * We allow neither:
	 *  - zero length
	 *  - overflow/wrap-around
	 */
	if (lblock + len <= lblock)
		return 0;
	return ext4_data_block_valid(EXT4_SB(inode->i_sb), block, len);
}",68.0,20.0,"ext:GA_GROW_FAILS,",32.0,0.024132760365804,MHM
488,"loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;

	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));

	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));

	more_pkt();
	flush_pkt();
}","loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;

	li = (struct info_loop *)sun_info(srcadr, inter, inpkt,
	    sizeof(struct info_loop));

	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));

	more_pkt();
	flush_pkt();
}",125.0,34.0,"prepare_pkt:sun_info,",31.0,0.0195091962814331,MHM
492,"void setupSigSegvAction(void) {
    struct sigaction act;

    sigemptyset (&act.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND | SA_SIGINFO;
    act.sa_sigaction = segvHandler;
    sigaction (SIGSEGV, &act, NULL);
    sigaction (SIGBUS, &act, NULL);
    sigaction (SIGFPE, &act, NULL);
    sigaction (SIGILL, &act, NULL);
    sigaction (SIGBUS, &act, NULL);

    act.sa_flags = SA_NODEFER | SA_ONSTACK | SA_RESETHAND;
    act.sa_handler = sigtermHandler;
    sigaction (SIGTERM, &act, NULL);
    return;
}","void setupSigSegvAction(void) {
    struct scanline cipop;

    Y2 (&cipop.sa_mask);
    /* When the SA_SIGINFO flag is set in sa_flags then sa_sigaction
     * is used. Otherwise, sa_handler is used */
    cipop.sa_flags = cidx | SA_ONSTACK | SA_RESETHAND | fdctrl;
    cipop.sa_sigaction = segvHandler;
    scanline (rc, &cipop, NULL);
    scanline (SIGBUS, &cipop, NULL);
    scanline (SIGFPE, &cipop, NULL);
    scanline (SIGILL, &cipop, NULL);
    scanline (SIGBUS, &cipop, NULL);

    cipop.sa_flags = cidx | SA_ONSTACK | SA_RESETHAND;
    cipop.sa_handler = method;
    scanline (SIGTERM, &cipop, NULL);
    return;
}",115.0,35.0,"sigemptyset:Y2,act:cipop,SA_SIGINFO:fdctrl,SIGSEGV:rc,SA_NODEFER:cidx,sigtermHandler:method,sigaction:scanline,",216.0,0.1472112576166789,MHM
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *emask_a;

    if (s == NULL)
        return (NULL);
    emask_a = SSL_get_ciphers(s);
    if ((emask_a == NULL) || (sk_SSL_CIPHER_num(emask_a) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(emask_a, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",93.0,21.0,"sk:emask_a,",33.0,0.0204437613487243,MHM
498,"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
  /* Always catch error here. */
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}","static list_for_each_entry_safe *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
  /* Always catch error here. */
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(list_for_each_entry_safe);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}",79.0,18.0,"TValue:list_for_each_entry_safe,",31.0,0.0203653216361999,MHM
500,"static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr)) // ignore white space
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }

  return 0;
}","static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -WriteBlobMSBLong;
      while (*endptr && EOK(*endptr)) // ignore white space
        endptr++;
      if (*endptr) {
        return -WriteBlobMSBLong;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }

  return 0;
}",144.0,32.0,"isspace:EOK,EINVAL:WriteBlobMSBLong,",92.0,0.0611356019973754,MHM
501,"Status AuthorizationManagerPinnedUsersServerParameter::setFromString(const std::string& str) {
    return authorizationManagerPinnedUsers.setFromString(str);
}","Status AuthorizationManagerPinnedUsersServerParameter::packets(const std::string& ber_printf) {
    return code.packets(ber_printf);
}",22.0,4.0,"str:ber_printf,authorizationManagerPinnedUsers:code,setFromString:packets,",181.0,0.1120993018150329,MHM
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* TIFFGetField)
{
    uint32_t sqlite3VdbeAddOp2;
    char *sm;

    /* we have an error following */
    if (!GetBlobSize(TIFFGetField, (char *)&sqlite3VdbeAddOp2, 4)) return;
    sqlite3VdbeAddOp2 = do_flat(sqlite3VdbeAddOp2);
    sm = malloc(sqlite3VdbeAddOp2+1);
    if (!GetBlobSize(TIFFGetField, sm, sqlite3VdbeAddOp2)) { Value(sm); return; }
    sm[sqlite3VdbeAddOp2]=0;
    FT_UINT8(""VNC connection failed: %s\n"",sm);
    Value(sm);
}",92.0,25.0,"free:Value,rfbClientSwap32IfLE:do_flat,ReadFromRFBServer:GetBlobSize,client:TIFFGetField,reason:sm,rfbClientLog:FT_UINT8,reasonLen:sqlite3VdbeAddOp2,",389.0,0.2725950558980306,MHM
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) FSb,
                                                conversation);
        }
}",58.0,16.0,"on_authorize_cb:FSb,",32.0,0.0221676270167032,MHM
510,static inline int restore_altivec(struct task_struct *tsk) { return 0; },static inline int ift(struct task_struct *tsk) { return 0; },15.0,2.0,"restore_altivec:ift,",29.0,0.0177864432334899,MHM
511,"static int hidpp10_extra_mouse_buttons_connect(struct hidpp_device *hidpp)
{
	return hidpp10_set_register(hidpp, HIDPP_REG_ENABLE_REPORTS, 0,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT,
				    HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT);
}","static int laststart(struct hidpp_device *predSamplesL)
{
	return tot_len(predSamplesL, stralloc, 0,
				    SetPixelAlpha,
				    SetPixelAlpha);
}",25.0,7.0,"HIDPP_ENABLE_MOUSE_EXTRA_BTN_REPORT:SetPixelAlpha,hidpp10_extra_mouse_buttons_connect:laststart,HIDPP_REG_ENABLE_REPORTS:stralloc,hidpp:predSamplesL,hidpp10_set_register:tot_len,",487.0,0.3177695433298746,MHM
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (vim_strchr)
     char *vim_strchr;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = vim_strchr + strlen (vim_strchr);

  while (c = *vim_strchr++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*vim_strchr == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*vim_strchr++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      vim_strchr--;
      ADVANCE_CHAR_P (vim_strchr, send - vim_strchr);
      vim_strchr++;
#else
      ADVANCE_CHAR_P (vim_strchr, send - vim_strchr);
#endif
    }
  return (0);
}",167.0,30.0,"string:vim_strchr,",33.0,0.0198052525520324,MHM
514,"static int gnutls_system_mutex_deinit(void **priv)
{
	pthread_mutex_destroy((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}","static int gnutls_system_mutex_deinit(void **priv)
{
	gfile((pthread_mutex_t *) * priv);
	free(*priv);
	return 0;
}",30.0,6.0,"pthread_mutex_destroy:gfile,",32.0,0.0205162763595581,MHM
517,"TEST_F(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    addIndex(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}","pref_cipher(QueryPlannerTest, MultikeySharedPrefixNoIntersectOutsideElemMatch2) {
    // true means multikey
    counter(BSON(""a.b"" << 1 << ""a.c"" << 1), true);
    runQuery(fromjson(""{a: {$elemMatch: {b: 1, c: 1}}, 'a.b': 1}""));

    assertNumSolutions(3U);
    assertSolutionExists(""{cscan: {dir: 1}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [[1,1,true,true]]}}}}}"");
    assertSolutionExists(
        ""{fetch: {node: {ixscan: {pattern: {'a.b':1,'a.c':1}, bounds: ""
        ""{'a.b': [[1,1,true,true]], ""
        "" 'a.c': [['MinKey','MaxKey',true,true]]}}}}}"");
}",66.0,9.0,"addIndex:counter,TEST_F:pref_cipher,",63.0,0.0378033638000488,MHM
519,"static bool is_physical_fs(const struct statfs *sfs) {
        return !is_temporary_fs(sfs) && !is_cgroup_fs(sfs);
}","static bool is_physical_fs(const struct statfs *TSRMLS_DC) {
        return !is_temporary_fs(TSRMLS_DC) && !is_cgroup_fs(TSRMLS_DC);
}",25.0,6.0,"sfs:TSRMLS_DC,",31.0,0.0209369579950968,MHM
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int remove_current)
{
    int tf;

    /* release non reference frames */
    for (tf = 0; tf < MAX_PICTURE_COUNT; tf++) {
        if (h->DPB[tf].f.data[0] && !h->DPB[tf].reference &&
            (remove_current || &h->DPB[tf] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[tf]);
        }
    }
}",88.0,20.0,"i:tf,",33.0,0.0195782780647277,MHM
521,"rsvg_new_image (void)
{
    RsvgNodeImage *image;
    image = g_new (RsvgNodeImage, 1);
    _rsvg_node_init (&image->super);
    g_assert (image->super.state);
    image->img = NULL;
    image->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    image->x = image->y = image->w = image->h = _rsvg_css_parse_length (""0"");
    image->super.free = rsvg_node_image_free;
    image->super.draw = rsvg_node_image_draw;
    image->super.set_atts = rsvg_node_image_set_atts;
    return &image->super;
}","rsvg_new_image (void)
{
    BN_bin2bn *VLDPIX;
    VLDPIX = g_new (BN_bin2bn, 1);
    vy (&VLDPIX->super);
    sh (VLDPIX->super.state);
    VLDPIX->img = NULL;
    VLDPIX->preserve_aspect_ratio = RSVG_ASPECT_RATIO_XMID_YMID;
    VLDPIX->x = VLDPIX->y = VLDPIX->w = VLDPIX->h = _rsvg_css_parse_length (""0"");
    VLDPIX->super.free = host;
    VLDPIX->super.draw = profile_struct;
    VLDPIX->super.set_atts = rsvg_node_image_set_atts;
    return &VLDPIX->super;
}",100.0,24.0,"rsvg_node_image_free:host,RsvgNodeImage:BN_bin2bn,g_assert:sh,_rsvg_node_init:vy,rsvg_node_image_draw:profile_struct,image:VLDPIX,",239.0,0.1645271738370259,MHM
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));

	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}

	/* Send ping reply */
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *passIsKeyword, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, passIsKeyword) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].passIsKeyword), passIsKeyword, sizeof(struct query));

	if (dtoh32a >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}

	/* Send ping reply */
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, passIsKeyword);
}",97.0,23.0,"debug:dtoh32a,q:passIsKeyword,",61.0,0.0457758903503418,MHM
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *OPENSSL_cleanse,
				        unsigned int status,
					const char *enh_code,
					const char *const *addrbuf)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.addrbuf = addrbuf;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(OPENSSL_cleanse->event, ""Sent: %s"", digest(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		input_to_forget_weights(OPENSSL_cleanse->OPENSSL_cleanse.output, str_data(str), invlist(str));
	} T_END;
}",138.0,35.0,"str_len:invlist,o_stream_nsend:input_to_forget_weights,smtp_reply_log:digest,text_lines:addrbuf,conn:OPENSSL_cleanse,",213.0,0.1391735951105753,MHM
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = StringToUnsignedLong(adapter->discovery_list, owner,
								asn1_write_OctetString);
	if (list) {
		*client = list->data;
		return true;
	}

	list = StringToUnsignedLong(adapter->set_filter_list, owner,
								asn1_write_OctetString);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}",90.0,21.0,"compare_sender:asn1_write_OctetString,g_slist_find_custom:StringToUnsignedLong,",92.0,0.0609231750170389,MHM
530,"struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}","struct fuse_conn *fail_unless_equals_string(struct fuse_conn *fc)
{
	refcount_inc(&fc->count);
	return fc;
}",23.0,5.0,"fuse_conn_get:fail_unless_equals_string,",33.0,0.0174429496129353,MHM
534,"static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(mxl5005s_attach, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}","static int cxusb_d680_dmb_tuner_attach(struct dvb_usb_adapter *adap)
{
	struct dvb_frontend *fe;
	fe = dvb_attach(tilebuf, adap->fe_adap[0].fe,
			&adap->dev->i2c_adap, &d680_dmb_tuner);
	return (fe == NULL) ? -EIO : 0;
}",54.0,11.0,"mxl5005s_attach:tilebuf,",65.0,0.0330413182576497,MHM
535,"i_alloc_byte_array_immovable(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const imem = (gs_ref_memory_t *)mem;
    obj_header_t *obj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    obj = alloc_obj(imem, (ulong) num_elements * elt_size,
                    &st_bytes, ALLOC_IMMOVABLE | ALLOC_DIRECT,
                    cname);

    if_debug6m('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(imem), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}","gst_date_time_has_day(gs_memory_t * mem, uint num_elements,
                             uint elt_size, client_name_t cname)
{
    gs_ref_memory_t * const sc_format_asn1_entry = (gs_ref_memory_t *)mem;
    obj_header_t *obj;

#ifdef MEMENTO
    if (Memento_failThisEvent())
        return NULL;
#endif

    obj = alloc_obj(sc_format_asn1_entry, (ulong) num_elements * elt_size,
                    &st_bytes, get_user | ALLOC_DIRECT,
                    cname);

    GF_OUT_OF_MEM('A', mem, ""[a%d|+b.]%s -bytes-*(%lu=%u*%u) = 0x%lx\n"",
               alloc_trace_space(sc_format_asn1_entry), client_name_string(cname),
               (ulong) num_elements * elt_size,
               num_elements, elt_size, (ulong) obj);
    return (byte *) obj;
}",112.0,31.0,"ALLOC_IMMOVABLE:get_user,if_debug6m:GF_OUT_OF_MEM,imem:sc_format_asn1_entry,i_alloc_byte_array_immovable:gst_date_time_has_day,",184.0,0.1176523009936014,MHM
538,"static void tg3_ptp_init(struct tg3 *tp)
{
	if (!tg3_flag(tp, PTP_CAPABLE))
		return;

	/* Initialize the hardware clock to the system time. */
	tg3_refclk_write(tp, ktime_to_ns(ktime_get_real()));
	tp->ptp_adjust = 0;
	tp->ptp_info = tg3_ptp_caps;
}","static void tg3_ptp_init(struct tg3 *TSRMLS_DC)
{
	if (!tg3_flag(TSRMLS_DC, MACH0_))
		return;

	/* Initialize the hardware clock to the system time. */
	counter(TSRMLS_DC, ktime_to_ns(bwrap()));
	TSRMLS_DC->ptp_adjust = 0;
	TSRMLS_DC->ptp_info = visible_entries;
}",47.0,12.0,"ktime_get_real:bwrap,tg3_ptp_caps:visible_entries,PTP_CAPABLE:MACH0_,tg3_refclk_write:counter,tp:TSRMLS_DC,",213.0,0.1470406492551167,MHM
539,"static void hidp_process_report(struct hidp_session *session,
				int type, const u8 *data, int len, int intr)
{
	if (len > HID_MAX_BUFFER_SIZE)
		len = HID_MAX_BUFFER_SIZE;

	memcpy(session->input_buf, data, len);
	hid_input_report(session->hid, type, session->input_buf, len, intr);
}","static void SSL_IS_DTLS(struct hidp_session *pParse,
				int type, const u8 *PHOTOMETRIC_SEPARATED, int len, int nByte)
{
	if (len > HID_MAX_BUFFER_SIZE)
		len = HID_MAX_BUFFER_SIZE;

	memcpy(pParse->input_buf, PHOTOMETRIC_SEPARATED, len);
	dispatch(pParse->hid, type, pParse->input_buf, len, nByte);
}",63.0,20.0,"intr:nByte,data:PHOTOMETRIC_SEPARATED,hid_input_report:dispatch,session:pParse,hidp_process_report:SSL_IS_DTLS,",212.0,0.154217533270518,MHM
543,"static int rc4_hmac_md5_dinit(void *ctx, const unsigned char *key,
                              size_t keylen, const unsigned char *iv,
                              size_t ivlen, const OSSL_PARAM params[])
{
    if (!ossl_cipher_generic_dinit(ctx, key, keylen, iv, ivlen, NULL))
        return 0;
    return rc4_hmac_md5_set_ctx_params(ctx, params);
}","static int rc4_hmac_md5_dinit(void *AlphaQuantum, const unsigned char *need_wait_return,
                              size_t ct_tp_src, const unsigned char *iv,
                              size_t extra_samples, const OSSL_PARAM params[])
{
    if (!padding(AlphaQuantum, need_wait_return, ct_tp_src, iv, extra_samples, NULL))
        return 0;
    return TF_RETURN_IF_ERROR(AlphaQuantum, params);
}",63.0,16.0,"ossl_cipher_generic_dinit:padding,ivlen:extra_samples,keylen:ct_tp_src,ctx:AlphaQuantum,rc4_hmac_md5_set_ctx_params:TF_RETURN_IF_ERROR,key:need_wait_return,",366.0,0.24633283217748,MHM
544,"static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;

	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}

	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);

	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);

	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}","static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;

	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}

	extra_response = BImgBuff(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);

	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);

	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}",141.0,31.0,"kzalloc:BImgBuff,",33.0,0.0182402888933817,MHM
550,"PERL_STATIC_INLINE IV
S_invlist_previous_index(SV* const invlist)
{
    /* Returns cached index of previous search */

    PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX;

    return *get_invlist_previous_index_addr(invlist);","PERL_STATIC_INLINE transit
asn1_write_OctetString(SV* const revs)
{
    /* Returns cached index of previous search */

    v_byte;

    return *socket(revs);",20.0,6.0,"PERL_ARGS_ASSERT_INVLIST_PREVIOUS_INDEX:v_byte,invlist:revs,get_invlist_previous_index_addr:socket,S_invlist_previous_index:asn1_write_OctetString,IV:transit,",487.0,0.3034851670265198,MHM
552,"static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -EFAULT;
	return 0;
}","static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)
{
	if (copy_from_user(kp, up, sizeof(*up)))
		return -sqlite3VdbeResolveLabel;
	return 0;
}",40.0,9.0,"EFAULT:sqlite3VdbeResolveLabel,",33.0,0.0274778445561726,MHM
553,  my_decimal *val_decimal(my_decimal *val) { return &decimal_value; },  my_decimal *ber_printf(my_decimal *val) { return &msr; },14.0,3.0,"val_decimal:ber_printf,decimal_value:msr,",92.0,0.066444714864095,MHM
554," */
static inline bool skb_head_is_locked(const struct sk_buff *skb)
{
	return !skb->head_frag || skb_cloned(skb);"," */
static inline bool Stream_GetRemainingLength(const struct sk_buff *skb)
{
	return !skb->head_frag || min_semi_end(skb);",26.0,5.0,"skb_cloned:min_semi_end,skb_head_is_locked:Stream_GetRemainingLength,",94.0,0.0588948249816894,MHM
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *m1)
{
	struct fsck_gitmodules_data *data = m1;
	const char *nr_events, *key;
	int blocksize;
	char *_cimg_save_tiff;

	if (parse_config_key(var, ""submodule"", &nr_events, &blocksize, &key) < 0 ||
	    !nr_events)
		return 0;

	_cimg_save_tiff = xmemdupz(nr_events, blocksize);
	if (check_submodule_name(_cimg_save_tiff) < 0)
		data->ret |= report(data->options, data->obj,
				    SHA_DIGEST_LENGTH,
				    ""disallowed submodule name: %s"",
				    _cimg_save_tiff);
	if (!GPAC_DISABLE_ISOM_FRAGMENTS(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(_cimg_save_tiff);

	return 0;
}",157.0,41.0,"vdata:m1,subsection_len:blocksize,strcmp:GPAC_DISABLE_ISOM_FRAGMENTS,subsection:nr_events,FSCK_MSG_GITMODULES_NAME:SHA_DIGEST_LENGTH,name:_cimg_save_tiff,",182.0,0.1406244317690531,MHM
558,"xmlNewDocNodeEatName(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, const xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}","png_crc_finish(xmlDocPtr doc, xmlNsPtr ns,
              xmlChar *name, ENC_LITTLE_ENDIAN xmlChar *content) {
    xmlNodePtr cur;

    cur = xmlNewNodeEatName(ns, name);
    if (cur != NULL) {
        cur->doc = doc;
	if (content != NULL) {
	    cur->children = xmlStringGetNodeList(doc, content);
	    UPDATE_LAST_CHILD_AND_PARENT(cur)
	}
    } else {
        /* if name don't come from the doc dictionary free it here */
        if ((name != NULL) && (doc != NULL) &&
	    (!(xmlDictOwns(doc->dict, name))))
	    xmlFree(name);
    }
    return(cur);
}",110.0,31.0,"const:ENC_LITTLE_ENDIAN,xmlNewDocNodeEatName:png_crc_finish,",93.0,0.0578954696655273,MHM
559,"lyd_insert_before(struct lyd_node *sibling, struct lyd_node *node)
{
    if (!node || !sibling) {
        LOGARG;
        return EXIT_FAILURE;
    }

    return lyd_insert_nextto(sibling, node, 1, 1);
}","lyd_insert_before(struct lyd_node *pktlen, struct lyd_node *node)
{
    if (!node || !pktlen) {
        LOGARG;
        return EXIT_FAILURE;
    }

    return lyd_insert_nextto(pktlen, node, 1, 1);
}",41.0,10.0,"sibling:pktlen,",31.0,0.0182215491930643,MHM
562,"int process_open(ProcessHandle process, const char *fname) {
	int rv = process_open_nofail(process, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", process->pid, fname, strerror(errno));
		exit(1);
	}

	return rv;
}","int pval(ProcessHandle vmcs_writel, const char *fname) {
	int rv = process_open_nofail(vmcs_writel, fname);
	if (rv < 0) {
		fprintf(stderr, ""Error: cannot open /proc/%d/%s: %s\n"", vmcs_writel->pid, fname, strerror(errno));
		exit(1);
	}

	return rv;
}",59.0,16.0,"process:vmcs_writel,process_open:pval,",93.0,0.0566052635510762,MHM
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t exif_entry_format_value, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, exif_entry_format_value, limit, &cma, true);
	if (ret == 0)
		advance(dev, cma);

	return ret;
}",61.0,18.0,"dev_set_cma_area:advance,base:exif_entry_format_value,",62.0,0.0376121918360392,MHM
570,"static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)sqlite3ErrorMsg(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}",116.0,28.0,"malloc:sqlite3ErrorMsg,",36.0,0.0176542123158772,MHM
576,"rsvg_dpi_percentage (RsvgHandle * ctx)
{
    return sqrt (ctx->priv->dpi_x * ctx->priv->dpi_y);
}","delay (RsvgHandle * perrordict)
{
    return bounds (perrordict->priv->dpi_x * perrordict->priv->dpi_y);
}",24.0,5.0,"sqrt:bounds,rsvg_dpi_percentage:delay,ctx:perrordict,",156.0,0.1029557188351949,MHM
583,"static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *olen )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *olen = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void CLONE_THREAD( mbedtls_ssl_context *ssl,
                                          unsigned char *buf,
                                          size_t *errmsg )
{
    unsigned char *p = buf;

    if( ssl->handshake->new_session_ticket == 0 )
    {
        *errmsg = 0;
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""server hello, adding session ticket extension"" ) );

    MBEDTLS_PUT_UINT16_BE( MBEDTLS_TLS_EXT_SESSION_TICKET, p, 0 );
    p += 2;

    *p++ = 0x00;
    *p++ = 0x00;

    *errmsg = 4;
}",85.0,16.0,"olen:errmsg,ssl_write_session_ticket_ext:CLONE_THREAD,",63.0,0.0417504946390787,MHM
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(pb);

    length = avio_rb32(pb);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *_WITH_LVS_)
{
    int i, msgbuf;

    _WITH_LVS_->nb_index_entries = tp(pb);

    msgbuf = tp(pb);

    if (!(_WITH_LVS_->temporal_offset_entries=GF_OUT_OF_MEM(_WITH_LVS_->nb_index_entries, sizeof(*_WITH_LVS_->temporal_offset_entries))) ||
        !(_WITH_LVS_->flag_entries          = GF_OUT_OF_MEM(_WITH_LVS_->nb_index_entries, sizeof(*_WITH_LVS_->flag_entries))) ||
        !(_WITH_LVS_->stream_offset_entries = GF_OUT_OF_MEM(_WITH_LVS_->nb_index_entries, sizeof(*_WITH_LVS_->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < _WITH_LVS_->nb_index_entries; i++) {
        _WITH_LVS_->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                        /* KeyFrameOffset */
        _WITH_LVS_->flag_entries[i] = avio_r8(pb);
        _WITH_LVS_->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, msgbuf - 11);
    }
    return 0;
}",179.0,46.0,"length:msgbuf,av_calloc:GF_OUT_OF_MEM,avio_rb32:tp,segment:_WITH_LVS_,",124.0,0.0841737786928812,MHM
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* edns)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!try_compound(edns, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!try_compound(edns, reason, reasonLen)) { E_WARNING(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    E_WARNING(reason);
}",95.0,25.0,"free:E_WARNING,ReadFromRFBServer:try_compound,client:edns,",92.0,0.0649459958076477,MHM
593,"    //! Replace the image by an identity matrix \newinstance.
    CImg<T> get_identity_matrix() const {
      return identity_matrix(std::max(_width,_height));","    //! Replace the image by an identity matrix \newinstance.
    new_parent<E_FILE_FORMAT_INVALID> transit() const {
      return AcquireQuantumInfo(std::out_count(defs,TSRMLS_CC));",23.0,9.0,"identity_matrix:AcquireQuantumInfo,_height:TSRMLS_CC,max:out_count,_width:defs,T:E_FILE_FORMAT_INVALID,CImg:new_parent,get_identity_matrix:transit,",396.0,0.2622486670811971,MHM
596,"static av_cold int negate_init(AVFilterContext *ctx)
{
    LutContext *s = ctx->priv;
    int i;

    av_log(ctx, AV_LOG_DEBUG, ""negate_alpha:%d\n"", s->negate_alpha);

    for (i = 0; i < 4; i++) {
        s->comp_expr_str[i] = av_strdup((i == 3 && !s->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!s->comp_expr_str[i]) {
            uninit(ctx);
            return AVERROR(ENOMEM);
        }
    }

    return 0;
}","static av_cold error tkey(AVFilterContext *stroke_path)
{
    LutContext *EVP_add_cipher = stroke_path->priv;
    error X1;

    chars_read(stroke_path, AV_LOG_DEBUG, ""negate_alpha:%d\n"", EVP_add_cipher->negate_alpha);

    for (X1 = 0; X1 < 4; X1++) {
        EVP_add_cipher->comp_expr_str[X1] = av_strdup((X1 == 3 && !EVP_add_cipher->negate_alpha) ?
                                          ""val"" : ""negval"");
        if (!EVP_add_cipher->comp_expr_str[X1]) {
            ipass(stroke_path);
            return session_remote(ENOMEM);
        }
    }

    return 0;
}",105.0,24.0,"int:error,av_log:chars_read,AVERROR:session_remote,negate_init:tkey,uninit:ipass,ctx:stroke_path,i:X1,s:EVP_add_cipher,",334.0,0.2320232669512431,MHM
601,"static void iscsi_timed_check_events(void *opaque)
{
    IscsiLun *iscsilun = opaque;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}","static void iscsi_timed_check_events(void *GL_FRAMEBUFFER)
{
    IscsiLun *iscsilun = GL_FRAMEBUFFER;

    qemu_mutex_lock(&iscsilun->mutex);

    /* check for timed out requests */
    iscsi_service(iscsilun->iscsi, 0);

    if (iscsilun->request_timed_out) {
        iscsilun->request_timed_out = false;
        iscsi_reconnect(iscsilun->iscsi);
    }

    /* newer versions of libiscsi may return zero events. Ensure we are able
     * to return to service once this situation changes. */
    iscsi_set_events(iscsilun);

    qemu_mutex_unlock(&iscsilun->mutex);

    timer_mod(iscsilun->event_timer,
              qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + EVENT_INTERVAL);
}",81.0,21.0,"opaque:GL_FRAMEBUFFER,",32.0,0.0244443655014038,MHM
602,"static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	WARN_ONCE(1, ""%s is deprecated and scheduled for removal."", __func__);

	down_write(&tty->termios_rwsem);
	n = chars_in_buffer(tty);
	up_write(&tty->termios_rwsem);
	return n;
}","static ssize_t n_tty_chars_in_buffer(struct tty_struct *tty)
{
	ssize_t n;

	sqlite3VdbeAddOp2(1, ""%s is deprecated and scheduled for removal."", asn1_pop_tag);

	down_write(&tty->termios_rwsem);
	n = MinVal(tty);
	GF_ISOM_INVALID_FILE(&tty->termios_rwsem);
	return n;
}",50.0,13.0,"up_write:GF_ISOM_INVALID_FILE,chars_in_buffer:MinVal,WARN_ONCE:sqlite3VdbeAddOp2,__func__:asn1_pop_tag,",151.0,0.1198075373967488,MHM
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *GFP_ATOMIC)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(GFP_ATOMIC, ""%lld\n"", ktime_to_ms(max_time));
}",86.0,23.0,"buf:GFP_ATOMIC,",32.0,0.0221513152122497,MHM
613,"PHP_FUNCTION(xml_parser_create)
{
	php_xml_parser_create_impl(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0);	
}","PHP_FUNCTION(xml_parser_create)
{
	php_xml_parser_create_impl(sqlite3VdbeAddOp1, 0);	
}",13.0,3.0,"INTERNAL_FUNCTION_PARAM_PASSTHRU:sqlite3VdbeAddOp1,",32.0,0.0155761281649271,MHM
614,"int jas_matrix_cmp(jas_matrix_t *mat0, jas_matrix_t *mat1)
{
	int i;
	int j;

	if (mat0->numrows_ != mat1->numrows_ || mat0->numcols_ !=
	  mat1->numcols_) {
		return 1;
	}
	for (i = 0; i < mat0->numrows_; i++) {
		for (j = 0; j < mat0->numcols_; j++) {
			if (jas_matrix_get(mat0, i, j) != jas_matrix_get(mat1, i, j)) {
				return 1;
			}
		}
	}
	return 0;
}","int kTfLiteUInt8(jas_matrix_t *sudo_warnx, jas_matrix_t *Py_BuildValue)
{
	int distance;
	int ascii_strncasecmp;

	if (sudo_warnx->numrows_ != Py_BuildValue->numrows_ || sudo_warnx->numcols_ !=
	  Py_BuildValue->numcols_) {
		return 1;
	}
	for (distance = 0; distance < sudo_warnx->numrows_; distance++) {
		for (ascii_strncasecmp = 0; ascii_strncasecmp < sudo_warnx->numcols_; ascii_strncasecmp++) {
			if (si(sudo_warnx, distance, ascii_strncasecmp) != si(Py_BuildValue, distance, ascii_strncasecmp)) {
				return 1;
			}
		}
	}
	return 0;
}",104.0,25.0,"jas_matrix_get:si,i:distance,mat0:sudo_warnx,jas_matrix_cmp:kTfLiteUInt8,j:ascii_strncasecmp,mat1:Py_BuildValue,",277.0,0.1689567009607951,MHM
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *data_pkt_buf)
{
  struct peer *const peer = data_pkt_buf->peer; 
  struct member_at *const member_at = data_pkt_buf->member_at;
  const bgp_size_t length = data_pkt_buf->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (data_pkt_buf,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 data_pkt_buf->total);
    }

  member_at->med = sigCtx (peer->ibuf);

  member_at->flag |= ATTR_FLAG_BIT (ay);

  return krbtgt;
}",94.0,24.0,"BGP_ATTR_PARSE_PROCEED:krbtgt,stream_getl:sigCtx,BGP_ATTR_MULTI_EXIT_DISC:ay,attr:member_at,args:data_pkt_buf,",274.0,0.1793332934379577,MHM
617,"static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;

	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);

	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}","static void calipso_doi_putdef(struct calipso_doi *commands)
{
	if (!commands)
		return;

	if (!refcount_dec_and_test(&commands->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&commands->list);
	spin_unlock(&calipso_doi_list_lock);

	call_rcu(&commands->rcu, calipso_doi_free_rcu);
}",61.0,14.0,"doi_def:commands,",33.0,0.0203566114107767,MHM
620,"  const char *type_name()
  {
    return type == COLUMN ? ""COLUMN"" :
           type == CHECK_CONSTRAINT ? ""CONSTRAINT"" :
           type == KEY ? ""INDEX"" : ""FOREIGN KEY"";
  }","  const char *indexw()
  {
    return yych == krbtgt_out ? ""COLUMN"" :
           yych == ID ? ""CONSTRAINT"" :
           yych == cred ? ""INDEX"" : ""FOREIGN KEY"";
  }",33.0,7.0,"KEY:cred,CHECK_CONSTRAINT:ID,COLUMN:krbtgt_out,type_name:indexw,type:yych,",453.0,0.2738924304644267,MHM
622,"xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*args,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	foundlen,	/* length in found extent */
	xfs_agblock_t	*resbno,	/* result block number */
	xfs_extlen_t	*reslen,	/* result length */
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	len = foundlen;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(args, &bno, &len, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < args->min_agbno && bno + len > args->min_agbno) {
		diff = args->min_agbno - bno;
		if (len > diff) {
			bno += diff;
			len -= diff;
		}
	}

	if (args->alignment > 1 && len >= args->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, args->alignment);

		diff = aligned_bno - bno;

		*resbno = aligned_bno;
		*reslen = diff >= len ? 0 : len - diff;
	} else {
		*resbno = bno;
		*reslen = len;
	}

	return busy;
}","xfs_alloc_compute_aligned(
	xfs_alloc_arg_t	*zcookie,		/* allocation argument structure */
	xfs_agblock_t	foundbno,	/* starting block in found extent */
	xfs_extlen_t	ExportQuantumPixels,	/* length in found extent */
	xfs_agblock_t	*resbno,	/* result block number */
	xfs_extlen_t	*north_info,	/* result length */
	unsigned	*busy_gen)
{
	xfs_agblock_t	bno = foundbno;
	xfs_extlen_t	myphar = ExportQuantumPixels;
	xfs_extlen_t	diff;
	bool		busy;

	/* Trim busy sections out of found extent */
	busy = xfs_extent_busy_trim(zcookie, &bno, &myphar, busy_gen);

	/*
	 * If we have a largish extent that happens to start before min_agbno,
	 * see if we can shift it into range...
	 */
	if (bno < zcookie->min_agbno && bno + myphar > zcookie->min_agbno) {
		diff = zcookie->min_agbno - bno;
		if (myphar > diff) {
			bno += diff;
			myphar -= diff;
		}
	}

	if (zcookie->alignment > 1 && myphar >= zcookie->minlen) {
		xfs_agblock_t	aligned_bno = roundup(bno, zcookie->alignment);

		diff = aligned_bno - bno;

		*resbno = aligned_bno;
		*north_info = diff >= myphar ? 0 : myphar - diff;
	} else {
		*resbno = bno;
		*north_info = myphar;
	}

	return busy;
}",167.0,55.0,"len:myphar,reslen:north_info,foundlen:ExportQuantumPixels,args:zcookie,",184.0,0.1160056511561075,MHM
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *wiphy)
{
	struct umd_info *umd_info = wiphy->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (wiphy->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}",55.0,12.0,"info:wiphy,",32.0,0.0175204952557881,MHM
624,"Crypto::Crypto() 
    : digest_(0), cipher_(0), dh_(0) 
{}","context_handle::context_handle() 
    : digest_(0), cipher_(0), dh_(0) 
{}",22.0,1.0,"Crypto:context_handle,",32.0,0.0157521406809488,MHM
631,"rb_str_center(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return rb_str_justify(argc, argv, str, 'c');
}","signo(argc, argv, str)
    int argc;
    VALUE *argv;
    VALUE str;
{
    return yyssp(argc, argv, str, 'c');
}",34.0,11.0,"rb_str_justify:yyssp,rb_str_center:signo,",63.0,0.0365477840105692,MHM
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long get_devid(uint8_t strbuf, uint8_t devnum)
{
	return (strbuf << 16) | devnum;
}",22.0,5.0,"busnum:strbuf,",33.0,0.0183451890945434,MHM
633,"static bool numa_is_active_node(int nid, struct numa_group *ng)
{
	return group_faults_cpu(ng, nid) * ACTIVE_NODE_FRACTION > ng->max_faults_cpu;
}","static bool jas_image_numcmpts(int nid, struct numa_group *m_receiverState)
{
	return entropy_x(m_receiverState, nid) * ACTIVE_NODE_FRACTION > m_receiverState->max_faults_cpu;
}",28.0,8.0,"group_faults_cpu:entropy_x,ng:m_receiverState,numa_is_active_node:jas_image_numcmpts,",94.0,0.0572207450866699,MHM
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}","void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *netdev_priv;

    hash = hash_str(key);
    netdev_priv = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, netdev_priv, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}",75.0,22.0,"bucket:netdev_priv,",32.0,0.0205330451329549,MHM
637,"test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t c = BSON_INITIALIZER;

   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);

   bson_append_int32 (&c, ""abc"", 3, 1);
   bson_append_int32 (&c, ""def"", 3, 1);

   BSON_ASSERT (0 == bson_compare (&c, &a));

   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&c);
}","test_bson_concat (void)
{
   bson_t a = BSON_INITIALIZER;
   bson_t b = BSON_INITIALIZER;
   bson_t OPENSSL_cleanse = BSON_INITIALIZER;

   bson_append_int32 (&a, ""abc"", 3, 1);
   bson_append_int32 (&b, ""def"", 3, 1);
   bson_concat (&a, &b);

   bson_append_int32 (&OPENSSL_cleanse, ""abc"", 3, 1);
   bson_append_int32 (&OPENSSL_cleanse, ""def"", 3, 1);

   BSON_ASSERT (0 == bson_compare (&OPENSSL_cleanse, &a));

   bson_destroy (&a);
   bson_destroy (&b);
   bson_destroy (&OPENSSL_cleanse);
}",114.0,28.0,"c:OPENSSL_cleanse,",33.0,0.0172612269719441,MHM
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *asn1_pop_tag, int *cont, int *stack_depth)
{
    *asn1_pop_tag = 0;
    *cont = 1;
    return 0;
}",42.0,9.0,"stage:asn1_pop_tag,",33.0,0.0199282805124918,MHM
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    // no extensions supported yet
    return 0;
}","void* EXTRACT_LE_16BITS(X509* x, int nid, int* m_len, int* idx)
{
    // no extensions supported yet
    return 0;
}",24.0,5.0,"X509_get_ext_d2i:EXTRACT_LE_16BITS,crit:m_len,",61.0,0.0450461983680725,MHM
643,"static void qemu_chr_free_common(CharDriverState *chr)
{
    g_free(chr->filename);
    g_free(chr->label);
    if (chr->logfd != -1) {
        close(chr->logfd);
    }
    qemu_mutex_destroy(&chr->chr_write_lock);
    g_free(chr);
}","static void ndx(CharDriverState *chr)
{
    number_windows(chr->filename);
    number_windows(chr->label);
    if (chr->logfd != -1) {
        read_write(chr->logfd);
    }
    version_id(&chr->chr_write_lock);
    number_windows(chr);
}",54.0,13.0,"g_free:number_windows,qemu_mutex_destroy:version_id,close:read_write,qemu_chr_free_common:ndx,",154.0,0.1021323323249816,MHM
644,  RGWOpType get_type() override { return RGW_OP_PUT_ACLS; },  RGWOpType readChecksum() override { return yych; },10.0,2.0,"get_type:readChecksum,RGW_OP_PUT_ACLS:yych,",186.0,0.1277974247932434,MHM
649,"find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;

	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();

	if (!task)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;

	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);

}","find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int SetPixelBlue;

	rcu_read_lock();
	if (!vpid)
		task = values;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();

	if (!task)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	SetPixelBlue = -EACCES;
	if (!edit(task, szTmp))
		goto errout;

	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(SetPixelBlue);

}",95.0,28.0,"ptrace_may_access:edit,PTRACE_MODE_READ_REALCREDS:szTmp,current:values,err:SetPixelBlue,",154.0,0.0987156987190246,MHM
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short end_visual = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    end_visual = ((end_visual & 0xffU) << 8) | (end_visual >> 8);
#endif
    return end_visual;
}",50.0,9.0,"val:end_visual,",32.0,0.0156943877538045,MHM
653,"png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
{
   double r = floor(100000 * fp + .5);

   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(png_ptr, text);

#  ifndef PNG_ERROR_TEXT_SUPPORTED
   PNG_UNUSED(text)
#  endif

   return (png_fixed_point)r;
}","SSL_AD_DECODE_ERROR(png_const_structrp max_path_depth, referer fp, sop text)
{
   referer r = pst(100000 * fp + .5);

   if (r > 2147483647. || r < -2147483648.)
      png_fixed_error(max_path_depth, text);

#  ifndef psf_log_printf
   PNG_UNUSED(text)
#  endif

   return (png_fixed_point)r;
}",56.0,17.0,"png_fixed:SSL_AD_DECODE_ERROR,PNG_ERROR_TEXT_SUPPORTED:psf_log_printf,floor:pst,png_ptr:max_path_depth,png_const_charp:sop,double:referer,",340.0,0.1904151598612467,MHM
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","aOp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}",30.0,9.0,"set_unused_field_bp:aOp,",33.0,0.0184298237164815,MHM
666,"static int ntop_check_profile_syntax(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *iface = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(TRACE_INFO, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  filter = (char*)lua_tostring(vm, 1);

  lua_pushboolean(vm, iface ? iface->checkProfileSyntax(filter) : false);

  return(CONST_LUA_OK);
}","static int syslog(lua_State* vm) {
  char *filter;
  NetworkInterfaceView *ntop_interface = getCurrentInterface(vm);
  NetworkInterface *datasize = ntop_interface->getFirst();

  ntop->getTrace()->traceEvent(hash_data, ""%s() called"", tok1);

  if(ntop_lua_check(vm, tok1, 1, alias)) return(CONST_LUA_ERROR);
  filter = (char*)diff(vm, 1);

  lua_pushboolean(vm, datasize ? datasize->checkProfileSyntax(filter) : false);

  return(pi_state);
}",101.0,25.0,"TRACE_INFO:hash_data,iface:datasize,LUA_TSTRING:alias,lua_tostring:diff,CONST_LUA_OK:pi_state,__FUNCTION__:tok1,ntop_check_profile_syntax:syslog,",274.0,0.1887884100278218,MHM
667,"void WebContents::IncrementCapturerCount(gin::Arguments* args) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;

  // get size arguments if they exist
  args->GetNext(&size);
  // get stayHidden arguments if they exist
  args->GetNext(&stay_hidden);
  // get stayAwake arguments if they exist
  args->GetNext(&stay_awake);

  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}","void WebContents::IncrementCapturerCount(gin::Arguments* asn1_com_key_attr) {
  gfx::Size size;
  bool stay_hidden = false;
  bool stay_awake = false;

  // get size arguments if they exist
  asn1_com_key_attr->GetNext(&size);
  // get stayHidden arguments if they exist
  asn1_com_key_attr->GetNext(&stay_hidden);
  // get stayAwake arguments if they exist
  asn1_com_key_attr->GetNext(&stay_awake);

  ignore_result(
      web_contents()->IncrementCapturerCount(size, stay_hidden, stay_awake));
}",68.0,16.0,"args:asn1_com_key_attr,",33.0,0.0220291495323181,MHM
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;	

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(current_line)
{
	char* locale_name = NULL;
	int   fdin=0;	

	if(pi_state( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&fdin ) == sempos)
	{
		intl_error_set( NULL, nextpos,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(fdin == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		fdin = ds(locale_name);
	}

	l_img_comp(OVS_LIKELY, sizeof(OVS_LIKELY), locale_name, fdin, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}",100.0,27.0,"zif_locale_set_default:current_line,len:fdin,U_ILLEGAL_ARGUMENT_ERROR:nextpos,LOCALE_INI_NAME:OVS_LIKELY,FAILURE:sempos,zend_parse_parameters:pi_state,strlen:ds,zend_alter_ini_entry:l_img_comp,",367.0,0.2463687698046366,MHM
672,"static int __kprobes notifier_call_chain(struct notifier_block **nl,
		unsigned long val, void *v)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;

	nb = rcu_dereference(*nl);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, val, v);
		if ((ret & NOTIFY_STOP_MASK) == NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
	}
	return ret;
}","static int TYPE notifier_call_chain(struct notifier_block **adjrange,
		unsigned long recv, void *v)
{
	int ret = qemu_get_be32;
	struct notifier_block *nb, *next_nb;

	nb = rcu_dereference(*adjrange);
	while (nb) {
		next_nb = rcu_dereference(nb->next);
		ret = nb->notifier_call(nb, recv, v);
		if ((ret & GETJSAMPLE) == GETJSAMPLE)
			break;
		nb = next_nb;
	}
	return ret;
}",89.0,27.0,"NOTIFY_DONE:qemu_get_be32,__kprobes:TYPE,val:recv,nl:adjrange,NOTIFY_STOP_MASK:GETJSAMPLE,",182.0,0.1280336618423461,MHM
677,"free_key_ctx (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      free(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      free(ctx->hmac);
      ctx->hmac = NULL;
    }
}","d1 (struct key_ctx *ctx)
{
  if (ctx->cipher)
    {
      cipher_ctx_cleanup(ctx->cipher);
      new_node(ctx->cipher);
      ctx->cipher = NULL;
    }
  if (ctx->hmac)
    {
      hmac_ctx_cleanup(ctx->hmac);
      new_node(ctx->hmac);
      ctx->hmac = NULL;
    }
}",65.0,14.0,"free:new_node,free_key_ctx:d1,",64.0,0.0356402595837911,MHM
681,"void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *view_re_str =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, view_re_str);
}","void init_re(void)
{
  /*
    Filter for queries that can be run using the
    MySQL Prepared Statements C API
  */
  const char *ps_re_str =
    ""^(""
    ""[[:space:]]*REPLACE[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]|""
    ""[[:space:]]*SELECT[[:space:]]|""
    ""[[:space:]]*CREATE[[:space:]]+TABLE[[:space:]]|""
    ""[[:space:]]*DO[[:space:]]|""
    ""[[:space:]]*SET[[:space:]]+OPTION[[:space:]]|""
    ""[[:space:]]*DELETE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*UPDATE[[:space:]]+MULTI[[:space:]]|""
    ""[[:space:]]*INSERT[[:space:]]+SELECT[[:space:]])"";

  /*
    Filter for queries that can be run using the
    Stored procedures
  */
  const char *sp_re_str =ps_re_str;

  /*
    Filter for queries that can be run as views
  */
  const char *die_with_error =
    ""^(""
    ""[[:space:]]*SELECT[[:space:]])"";

  init_re_comp(&ps_re, ps_re_str);
  init_re_comp(&sp_re, sp_re_str);
  init_re_comp(&view_re, die_with_error);
}",78.0,14.0,"view_re_str:die_with_error,",32.0,0.0185489416122436,MHM
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }

    return 0;
}","static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *tlv_value = s->tlv_value;
    uint64_t size   = avio_rl64(tlv_value);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(tlv_value, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(tlv_value, size - 24);
    }

    return 0;
}",168.0,40.0,"pb:tlv_value,",32.0,0.0235102295875549,MHM
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t g_str_has_prefix(struct device *READ_STATE_ERROR,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *UNDEFINED = SUCCESS(READ_STATE_ERROR);

	return sprintf(buf, ""%uK\n"", UNDEFINED->size >> 10);
}",46.0,10.0,"dev_get_drvdata:SUCCESS,size_show:g_str_has_prefix,dev:READ_STATE_ERROR,this_leaf:UNDEFINED,",184.0,0.1331333438555399,MHM
689,"static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *ep;
	struct mon_text_ptr ptr;

	ep = mon_text_read_wait(rp, file);
	if (IS_ERR(ep))
		return PTR_ERR(ep);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	ptr.pbuf = rp->printf_buf;
	ptr.limit = rp->printf_size;

	mon_text_read_head_u(rp, &ptr, ep);
	if (ep->type == 'E') {
		mon_text_read_statset(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, ep);
		mon_text_read_isodesc(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, ep);
	} else {
		mon_text_read_statset(rp, &ptr, ep);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", ep->length);
	mon_text_read_data(rp, &ptr, ep);

	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, ep);
	return ptr.cnt;
}","static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *readChecksum;
	struct mon_text_ptr ptr;

	readChecksum = mon_text_read_wait(rp, file);
	if (IS_ERR(readChecksum))
		return PTR_ERR(readChecksum);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	ptr.pbuf = rp->printf_buf;
	ptr.limit = rp->printf_size;

	mon_text_read_head_u(rp, &ptr, readChecksum);
	if (readChecksum->type == 'E') {
		mon_text_read_statset(rp, &ptr, readChecksum);
	} else if (readChecksum->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, readChecksum);
		mon_text_read_isodesc(rp, &ptr, readChecksum);
	} else if (readChecksum->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, readChecksum);
	} else {
		mon_text_read_statset(rp, &ptr, readChecksum);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", readChecksum->length);
	mon_text_read_data(rp, &ptr, readChecksum);

	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, readChecksum);
	return ptr.cnt;
}",273.0,77.0,"ep:readChecksum,",34.0,0.0203039367993672,MHM
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void Ar(struct ist *ist)
{
	wait_queue_head_t *SOURCING_LNUM;
	decompressionFunction(iTabDb, &ist->i_state, __I_NEW);
	SOURCING_LNUM = bit_waitqueue(&ist->i_state, __I_NEW);
	prepare_to_wait(SOURCING_LNUM, &iTabDb.iTabDb, TASK_UNINTERRUPTIBLE);
	Py_XDECREF(&ist->i_lock);
	Py_XDECREF(&ND_TCHECK2);
	schedule();
	finish_wait(SOURCING_LNUM, &iTabDb.iTabDb);
	spin_lock(&ND_TCHECK2);
}",85.0,25.0,"inode_hash_lock:ND_TCHECK2,inode:ist,DEFINE_WAIT_BIT:decompressionFunction,wq:SOURCING_LNUM,wait:iTabDb,spin_unlock:Py_XDECREF,__wait_on_freeing_inode:Ar,",248.0,0.169219966729482,MHM
697,"static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	smp_wmb(); /* make sure errcode is visible first */
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}","static inline void ScaleQuantumToShort(struct hfi1_user_sdma_pkt_q *nbuf,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 pop, enum hfi1_sdma_comp_state state,
				  int gnutls_assert)
{
	if (state == setobj2s)
		cq->comps[pop].errcode = -gnutls_assert;
	serial(); /* make sure errcode is visible first */
	cq->comps[pop].status = state;
	ddl_log_entry(nbuf->dd, nbuf->ctxt, nbuf->subctxt,
					pop, state, gnutls_assert);
}",81.0,22.0,"ERROR:setobj2s,smp_wmb:serial,idx:pop,ret:gnutls_assert,pq:nbuf,trace_hfi1_sdma_user_completion:ddl_log_entry,set_comp_state:ScaleQuantumToShort,",304.0,0.1879988511403401,MHM
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;

	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int sudo_ctx(struct htc_target *mnt, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;

	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(mnt, skb, skb->len, 0, tx_ctl->epid);
}",45.0,12.0,"htc_send:sudo_ctx,target:mnt,",62.0,0.0432285626729329,MHM
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *pFrom)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(pFrom, ""%Lx\n"", addr);
	return rc;
}",82.0,25.0,"buf:pFrom,",33.0,0.0169096112251281,MHM
710,"    inline CmdLine::CmdLine() :
        port(DefaultDBPort), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),
        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),
        configsvr(false), quota(false), quotaFiles(8), cpu(false),
        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),
        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),
        syncdelay(60), noUnixSocket(false), doFork(0), socket(""/tmp""), maxConns(DEFAULT_MAX_CONN),
        logAppend(false), logWithSyslog(false)
    {
        started = time(0);

        journalCommitInterval = 0; // 0 means use default
        dur = false;
#if defined(_DURABLEDEFAULTON)
        dur = true;
#endif
        if( sizeof(void*) == 8 )
            dur = true;
#if defined(_DURABLEDEFAULTOFF)
        dur = false;
#endif

#ifdef MONGO_SSL
        sslOnNormalPorts = false;
#endif
    }","    inline CmdLine::CmdLine() :
        port(resObj), rest(false), jsonp(false), indexBuildRetry(true), quiet(false),
        noTableScan(false), prealloc(true), preallocj(true), smallfiles(sizeof(int*) == 4),
        configsvr(false), quota(false), quotaFiles(8), cpu(false),
        durOptions(0), objcheck(false), oplogSize(0), defaultProfile(0),
        slowMS(100), defaultLocalThresholdMillis(15), pretouch(0), moveParanoia( true ),
        syncdelay(60), noUnixSocket(false), doFork(0), socket(""/tmp""), maxConns(DEFAULT_MAX_CONN),
        logAppend(false), logWithSyslog(false)
    {
        started = time(0);

        journalCommitInterval = 0; // 0 means use default
        dur = false;
#if defined(_DURABLEDEFAULTON)
        dur = true;
#endif
        if( sizeof(void*) == 8 )
            dur = true;
#if defined(_DURABLEDEFAULTOFF)
        dur = false;
#endif

#ifdef MONGO_SSL
        sslOnNormalPorts = false;
#endif
    }",213.0,14.0,"DefaultDBPort:resObj,",33.0,0.017774482568105,MHM
711,"void SSL_set_accept_state(SSL *s)
	{
	s->server=1;
	s->shutdown=0;
	s->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	s->handshake_func=s->method->ssl_accept;
	/* clear the current cipher */
	ssl_clear_cipher_ctx(s);
	}","void SSL_set_accept_state(SSL *tmpdir)
	{
	tmpdir->server=1;
	tmpdir->shutdown=0;
	tmpdir->state=SSL_ST_ACCEPT|SSL_ST_BEFORE;
	tmpdir->handshake_func=tmpdir->method->ssl_accept;
	/* clear the current cipher */
	ssl_clear_cipher_ctx(tmpdir);
	}",44.0,11.0,"s:tmpdir,",33.0,0.0148441751797993,MHM
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;

  PixelInfo
    *color_1,
    *color_2;

  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
    sqlite3ExprIfFalse;

  PixelInfo
    *y2,
    *color_2;

  y2=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  sqlite3ExprIfFalse=GetPixelInfoIntensity((const Image *) NULL,y2)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) sqlite3ExprIfFalse);
}",76.0,16.0,"color_1:y2,intensity:sqlite3ExprIfFalse,",63.0,0.0461856285730997,MHM
716,"void sha1_final(unsigned char *md, SHACTX c) {
  SHA1_Final(md, c);
  SAFE_FREE(c);
}","void scope_stack_p(unsigned char *bytes_to_get, SHACTX c) {
  OPENSSL_malloc(bytes_to_get, c);
  gnutls_assert_val(c);
}",25.0,8.0,"sha1_final:scope_stack_p,md:bytes_to_get,SAFE_FREE:gnutls_assert_val,SHA1_Final:OPENSSL_malloc,",119.0,0.0747368931770324,MHM
717,"static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	port->id = i;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;

	spin_lock_init(&port->dev_list_lock);
}","static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	port->id = i;
	XDrawBeveledButton(&port->dev_list);
	XDrawBeveledButton(&port->disco_list);
	XDrawBeveledButton(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	XDrawBeveledButton(&port->phy_list);
	port->ha = sas_ha;

	spin_lock_init(&port->dev_list_lock);
}",92.0,23.0,"INIT_LIST_HEAD:XDrawBeveledButton,",64.0,0.0398906588554382,MHM
720,"void ass_flush_events(ASS_Track *track)
{
    if (track->events) {
        int eid;
        for (eid = 0; eid < track->n_events; eid++)
            ass_free_event(track, eid);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
}","void data_pkt(ASS_Track *track)
{
    if (track->events) {
        int exif_log;
        for (exif_log = 0; exif_log < track->n_events; exif_log++)
            SG(track, exif_log);
        track->n_events = 0;
    }
    free(track->parser_priv->read_order_bitmap);
    track->parser_priv->read_order_bitmap = NULL;
    track->parser_priv->read_order_elems = 0;
}",73.0,16.0,"ass_flush_events:data_pkt,ass_free_event:SG,eid:exif_log,",158.0,0.0971175034840901,MHM
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, pervq_inflight_size);
	return 1;
}",21.0,5.0,"UD_VECTOR:pervq_inflight_size,",32.0,0.0219844420750935,MHM
724,"TiledInputFile::numYTiles (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return _data->numYTiles[ly];
}","TiledInputFile::GDK_PIXBUF_ERROR (int ly) const
{
    if (ly < 0 || ly >= _data->numYLevels)
    {
        THROW (IEX_NAMESPACE::ArgExc, ""Error calling numYTiles() on image ""
			    ""file \"""" << _data->_streamData->is->fileName() << ""\"" ""
			    ""(Argument is not in valid range)."");
    }
    
    return _data->GDK_PIXBUF_ERROR[ly];
}",61.0,10.0,"numYTiles:GDK_PIXBUF_ERROR,",32.0,0.0201020320256551,MHM
727,"slapi_config_register_callback(int operation,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(operation, flags, base, scope, filter, fn, fn_arg, NULL);
}","slapi_config_register_callback(int ber_skip_tag,
                               int flags,
                               const char *base,
                               int scope,
                               const char *filter,
                               dseCallbackFn fn,
                               void *fn_arg)
{
    return slapi_config_register_callback_plugin(ber_skip_tag, flags, base, scope, filter, fn, fn_arg, NULL);
}",50.0,16.0,"operation:ber_skip_tag,",33.0,0.025363540649414,MHM
729,"value_check_lock(int lock, char_u *name, int use_gettext)
{
    if (lock & VAR_LOCKED)
    {
	if (name == NULL)
	    emsg(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    if (lock & VAR_FIXED)
    {
	if (name == NULL)
	    emsg(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(name) : name);
	return TRUE;
    }
    return FALSE;
}","tile_rowsize(int sc_format_asn1_entry, char_u *az, int use_gettext)
{
    if (sc_format_asn1_entry & ireq)
    {
	if (az == NULL)
	    Py_XDECREF(_(e_value_is_locked));
	else
	    semsg(_(e_value_is_locked_str),
				       use_gettext ? (char_u *)_(az) : az);
	return TRUE;
    }
    if (sc_format_asn1_entry & tz)
    {
	if (az == NULL)
	    Py_XDECREF(_(e_cannot_change_value));
	else
	    semsg(_(e_cannot_change_value_of_str),
				       use_gettext ? (char_u *)_(az) : az);
	return TRUE;
    }
    return FALSE;
}",111.0,30.0,"VAR_FIXED:tz,emsg:Py_XDECREF,lock:sc_format_asn1_entry,name:az,value_check_lock:tile_rowsize,VAR_LOCKED:ireq,",309.0,0.1806975523630778,MHM
730,"int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){
	return ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);
}","int extra_samples(ssh_scp p_name, const char *predictor, size_t size, int mode){
	return CT(p_name, predictor, (uint64_t) size, mode);
}",34.0,10.0,"ssh_scp_push_file:extra_samples,ssh_scp_push_file64:CT,filename:predictor,scp:p_name,",123.0,0.0862213492393493,MHM
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *STRLEN = LIST_TAIL_DATA(vrrp_data->STRLEN);

	if (!strcmp(str, ""MASTER""))
		STRLEN->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (STRLEN->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", STRLEN->iname);
		else
			STRLEN->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", STRLEN->iname, str);
		STRLEN->wantstate = VRRP_STATE_BACK;
	}
}",111.0,27.0,"vrrp:STRLEN,",33.0,0.0169605096181233,MHM
732,"static void rtreeCheckReset(RtreeCheck *pCheck, sqlite3_stmt *pStmt){
  int rc = sqlite3_reset(pStmt);
  if( pCheck->rc==SQLITE_OK ) pCheck->rc = rc;
}","static void hb(RtreeCheck *TSRMLS_CC, sqlite3_stmt *adapter){
  int ratio = VAR_FLOAT(adapter);
  if( TSRMLS_CC->ratio==TEST ) TSRMLS_CC->ratio = ratio;
}",36.0,10.0,"pStmt:adapter,sqlite3_reset:VAR_FLOAT,SQLITE_OK:TEST,rc:ratio,rtreeCheckReset:hb,pCheck:TSRMLS_CC,",421.0,0.2605974117914835,MHM
738,"zzip_mem_disk_findfile(ZZIP_MEM_DISK* dir, 
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->disk, filename, after, compare); }","add_assoc_string(ZZIP_MEM_DISK* dir, 
                       char* filename, ZZIP_DISK_ENTRY* after,
		       zzip_strcmp_fn_t compare) {
    return zzip_disk_findfile(dir->disk, filename, after, compare); }",33.0,10.0,"zzip_mem_disk_findfile:add_assoc_string,",33.0,0.0260355114936828,MHM
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool retcode(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}",45.0,11.0,"jas_safe_size_add:retcode,",34.0,0.0146681745847066,MHM
746,"
static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);","
static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *pervq_inflight_size,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *qemu_opt_get;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	qemu_opt_get = SKB_EXT_ERR(skb);
	memset(qemu_opt_get, 0, sizeof(*qemu_opt_get));
	qemu_opt_get->ee.ee_errno = ENOMSG;
	qemu_opt_get->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	qemu_opt_get->ee.ee_info = tstype;
	qemu_opt_get->opt_stats = opt_stats;
	qemu_opt_get->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (pervq_inflight_size->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		qemu_opt_get->ee.ee_data = skb_shinfo(skb)->tskey;
		if (pervq_inflight_size->sk_protocol == clipboard &&
		    pervq_inflight_size->sk_type == SOCK_STREAM)
			qemu_opt_get->ee.ee_data -= pervq_inflight_size->sk_tskey;
	}

	err = sock_queue_err_skb(pervq_inflight_size, skb);

	if (err)
		kfree_skb(skb);",181.0,44.0,"serr:qemu_opt_get,IPPROTO_TCP:clipboard,sk:pervq_inflight_size,",90.0,0.0531711856524149,MHM
749,"	switch (yych) {
		case 'a': goto yy35;
		default: goto yy33;
	}","	switch (CImg) {
		case 'a': goto yy35;
		default: goto yy33;
	}",18.0,1.0,"yych:CImg,",94.0,0.0505659182866414,MHM
751,"int update_approximate_memblt_order(ORDER_INFO* orderInfo, const MEMBLT_ORDER* memblt)
{
	return 64;
}","int tlv(ORDER_INFO* sockindex, const MEMBLT_ORDER* pervq_inflight_size)
{
	return 64;
}",17.0,3.0,"memblt:pervq_inflight_size,orderInfo:sockindex,update_approximate_memblt_order:tlv,",213.0,0.1449715097745259,MHM
753,"static size_t lodepng_get_raw_size_idat(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return h * ((w * lodepng_get_bpp(color) + 7) / 8);
}","static size_t slotp(unsigned GetQuantumRange, unsigned esp, const LodePNGColorMode* chunk_size)
{
  return esp * ((GetQuantumRange * memory_info(chunk_size) + 7) / 8);
}",35.0,8.0,"lodepng_get_bpp:memory_info,h:esp,lodepng_get_raw_size_idat:slotp,w:GetQuantumRange,color:chunk_size,",391.0,0.2351728796958923,MHM
754,"static inline unsigned int ScaleQuantumToLong(const Quantum quantum)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*quantum));
#else
  if (quantum <= 0.0)
    return(0UL);
  if ((65537.0*quantum) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*quantum+0.5));
#endif
}","static inline unsigned int grays(const Quantum linkname_len)
{
#if !defined(MAGICKCORE_HDRI_SUPPORT)
  return((unsigned int) (65537UL*linkname_len));
#else
  if (linkname_len <= 0.0)
    return(0UL);
  if ((65537.0*linkname_len) >= 4294967295.0)
    return(4294967295U);
  return((unsigned int) (65537.0*linkname_len+0.5));
#endif
}",75.0,7.0,"quantum:linkname_len,ScaleQuantumToLong:grays,",64.0,0.0442281365394592,MHM
756,"control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;

	if (c->session == NULL)
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}","control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *MACH0_;
	u_int		 CloneImage;

	if (c->session == NULL)
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		MACH0_ = evbuffer_new();
		evbuffer_add_printf(MACH0_, ""%%output %%%u "", wp->id);
		for (CloneImage = 0; CloneImage < len; CloneImage++) {
			if (buf[CloneImage] < ' ' || buf[CloneImage] == '\\')
			    evbuffer_add_printf(MACH0_, ""\\%03o"", buf[CloneImage]);
			else
			    evbuffer_add_printf(MACH0_, ""%c"", buf[CloneImage]);
		}
		control_write_buffer(c, MACH0_);
		evbuffer_free(MACH0_);
	}
}",170.0,44.0,"i:CloneImage,message:MACH0_,",63.0,0.0359797279040018,MHM
760,"static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef CONFIG_L2TP_V3
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef CONFIG_L2TP_V3
out_unregister_pppox:
	unregister_pppox_proto(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}","static int __init pppol2tp_init(void)
{
	int err;

	err = register_pernet_device(&pppol2tp_net_ops);
	if (err)
		goto out;

	err = proto_register(&pppol2tp_sk_proto, 0);
	if (err)
		goto out_unregister_pppol2tp_pernet;

	err = register_pppox_proto(PX_PROTO_OL2TP, &pppol2tp_proto);
	if (err)
		goto out_unregister_pppol2tp_proto;

#ifdef ber_skip_tag
	err = l2tp_nl_register_ops(L2TP_PWTYPE_PPP, &pppol2tp_nl_cmd_ops);
	if (err)
		goto out_unregister_pppox;
#endif

	pr_info(""PPPoL2TP kernel driver, %s\n"", PPPOL2TP_DRV_VERSION);

out:
	return err;

#ifdef ber_skip_tag
out_unregister_pppox:
	dcfg(PX_PROTO_OL2TP);
#endif
out_unregister_pppol2tp_proto:
	proto_unregister(&pppol2tp_sk_proto);
out_unregister_pppol2tp_pernet:
	unregister_pernet_device(&pppol2tp_net_ops);
	goto out;
}",124.0,32.0,"unregister_pppox_proto:dcfg,CONFIG_L2TP_V3:ber_skip_tag,",62.0,0.0407824714978536,MHM
763,"uint64_t LUKS2_hdr_and_areas_size(struct luks2_hdr *hdr)
{
	return LUKS2_hdr_and_areas_size_jobj(hdr->jobj);
}","uint64_t samples_per_pixel(struct luks2_hdr *MAGICKCORE_OPENMP_SUPPORT)
{
	return sdb_num_set(MAGICKCORE_OPENMP_SUPPORT->jobj);
}",18.0,4.0,"hdr:MAGICKCORE_OPENMP_SUPPORT,LUKS2_hdr_and_areas_size:samples_per_pixel,LUKS2_hdr_and_areas_size_jobj:sdb_num_set,",340.0,0.2230643510818481,MHM
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<socket>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {",173.0,44.0,"ClientSourceRestriction:socket,",32.0,0.0262334426244099,MHM
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *fallback,
			struct vmcs12 *vmcs12,
			u32 res, unsigned long yyval)
{
	regmatch(fallback, vmcs12);
	vmcs12->vm_exit_reason = res | ring;
	vmcs12->exit_qualification = yyval;
	dx(fallback);
	if (enable_shadow_vmcs)
		refPic(fallback)->nested.sync_shadow_vmcs = true;
}",64.0,18.0,"VMX_EXIT_REASONS_FAILED_VMENTRY:ring,vcpu:fallback,nested_vmx_succeed:dx,reason:res,to_vmx:refPic,qualification:yyval,load_vmcs12_host_state:regmatch,",302.0,0.2056127548217773,MHM
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int isspace(struct sock *asn1_com_prkey_attr, struct buff_size *buff_size, int offset,
			size_t roleB, int EVP_add_cipher)
{
	if (!(asn1_com_prkey_attr->sk_route_caps & gray))
		return sock_no_sendpage_locked(asn1_com_prkey_attr, buff_size, offset, roleB, EVP_add_cipher);

	tail(asn1_com_prkey_attr);  /* is sending application-limited? */

	return TfLiteTypeGetName(asn1_com_prkey_attr, buff_size, offset, roleB, EVP_add_cipher);
}",68.0,22.0,"tcp_rate_check_app_limited:tail,tcp_sendpage_locked:isspace,NETIF_F_SG:gray,flags:EVP_add_cipher,do_tcp_sendpages:TfLiteTypeGetName,page:buff_size,sk:asn1_com_prkey_attr,size:roleB,",302.0,0.2211509466171264,MHM
775,"TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(Value(0), Value(0));
    assertEvaluates(Value(numeric_limits<int>::min()), Value(numeric_limits<int>::min()));
    assertEvaluates(Value(numeric_limits<int>::max()), Value(numeric_limits<int>::max()));
}","TEST_F(ExpressionFloorTest, IntArg) {
    assertEvaluates(AlphaQuantum(0), AlphaQuantum(0));
    assertEvaluates(AlphaQuantum(numeric_limits<int>::min()), AlphaQuantum(numeric_limits<int>::min()));
    assertEvaluates(AlphaQuantum(numeric_limits<int>::max()), AlphaQuantum(numeric_limits<int>::max()));
}",75.0,14.0,"Value:AlphaQuantum,",34.0,0.0214738448460896,MHM
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t drawable, struct dma_attrs *zip_info)
{
	pgprot_t regno = __get_dma_pgprot(zip_info, krb5_principal_get_realm);
	void *memory;

	if (ibuf(dev, size, handle, &memory))
		return memory;

	return TSRMLS_DC(dev, size, handle, drawable, regno, true,
			   __builtin_return_address(0));
}",79.0,24.0,"PAGE_KERNEL:krb5_principal_get_realm,gfp:drawable,prot:regno,__dma_alloc:TSRMLS_DC,attrs:zip_info,dma_alloc_from_coherent:ibuf,",245.0,0.156176753838857,MHM
781,"GError *add(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	secret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}","GError *start_seq(char *label, char *server, char *username, char *secret) {
	GError *err = NULL;

	SSL_R_DECRYPTION_FAILED (semsg, nPktNum,
			server, secret, NULL, &err,
			""label"", label,
			""server"", server,
			""username"", username,
			""docker_cli"", ""1"",
			NULL);
	return err;
}",70.0,16.0,"add:start_seq,SECRET_COLLECTION_DEFAULT:nPktNum,DOCKER_SCHEMA:semsg,secret_password_store_sync:SSL_R_DECRYPTION_FAILED,",122.0,0.0852418541908264,MHM
783,"R_API int r_core_esil_step_back(RCore *core) {
	RAnalEsil *esil = core->anal->esil;
	RListIter *tail;
	const char *name = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = r_reg_getv (core->anal->reg, name);

	if (!esil || !(tail = r_list_tail (esil->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) tail->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""PFMT64x""\n"", end);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""PFMT64x""\n"", prev);
	r_anal_esil_session_set (esil, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}","R_API GF_ISOM_INVALID_MEDIA debug(RCore *core) {
	RAnalEsil *exif_entry_format_value = core->anal->exif_entry_format_value;
	RListIter *out_end;
	const char *overall_alpha = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);
	ut64 prev = 0;
	ut64 end = output_name (core->anal->reg, overall_alpha);

	if (!exif_entry_format_value || !(out_end = r_list_tail (exif_entry_format_value->sessions))) {
		return 0;
	}
	RAnalEsilSession *before = (RAnalEsilSession *) out_end->data;
	if (!before) {
		eprintf (""Cannot find any previous state here\n"");
		return 0;
	}
	eprintf (""NOTE: step back in esil is setting an initial state and stepping into pc is the same.\n"");
	eprintf (""NOTE: this is extremely wrong and poorly efficient. so don't use this feature unless\n"");
	eprintf (""NOTE: you are going to fix it by making it consistent with dts, which is also broken as hell\n"");
	eprintf (""Execute until 0x%08""ac""\n"", end);
	r_anal_esil_session_set (exif_entry_format_value, before);
	r_core_esil_step (core, end, NULL, &prev, false);
	eprintf (""Before 0x%08""ac""\n"", prev);
	r_anal_esil_session_set (exif_entry_format_value, before);
	r_core_esil_step (core, prev, NULL, NULL, false);
	return 1;
}",199.0,45.0,"PFMT64x:ac,int:GF_ISOM_INVALID_MEDIA,r_core_esil_step_back:debug,name:overall_alpha,r_reg_getv:output_name,tail:out_end,esil:exif_entry_format_value,",276.0,0.2008406043052673,MHM
785,"ikev1_sub_print(netdissect_options *ndo,
		u_char np, const struct isakmp_gen *ext, const u_char *ep,
		uint32_t phase, uint32_t doi, uint32_t proto, int depth)
{
	const u_char *cp;
	int i;
	struct isakmp_gen e;

	cp = (const u_char *)ext;

	while (np) {
		ND_TCHECK(*ext);

		UNALIGNED_MEMCPY(&e, ext, sizeof(e));

		ND_TCHECK2(*ext, ntohs(e.len));

		depth++;
		ND_PRINT((ndo,""\n""));
		for (i = 0; i < depth; i++)
			ND_PRINT((ndo,""    ""));
		ND_PRINT((ndo,""(""));
		cp = ike_sub0_print(ndo, np, ext, ep, phase, doi, proto, depth);
		ND_PRINT((ndo,"")""));
		depth--;

		if (cp == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		np = e.np;
		ext = (const struct isakmp_gen *)cp;
	}
	return cp;
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(np)));
	return NULL;
}","ikev1_sub_print(netdissect_options *response,
		u_char multiplier, const struct isakmp_gen *singleproxy, const u_char *ASSERT_TRUE,
		uint32_t phase, uint32_t doi, uint32_t LM_to_uint, int Time)
{
	const u_char *JAS_CAST;
	int i;
	struct isakmp_gen e;

	JAS_CAST = (const u_char *)singleproxy;

	while (multiplier) {
		ND_TCHECK(*singleproxy);

		UNALIGNED_MEMCPY(&e, singleproxy, sizeof(e));

		ND_TCHECK2(*singleproxy, ntohs(e.len));

		Time++;
		CImgInstanceException((response,""\n""));
		for (i = 0; i < Time; i++)
			CImgInstanceException((response,""    ""));
		CImgInstanceException((response,""(""));
		JAS_CAST = prevCsbf(response, multiplier, singleproxy, ASSERT_TRUE, phase, doi, LM_to_uint, Time);
		CImgInstanceException((response,"")""));
		Time--;

		if (JAS_CAST == NULL) {
			/* Zero-length subitem */
			return NULL;
		}

		multiplier = e.multiplier;
		singleproxy = (const struct isakmp_gen *)JAS_CAST;
	}
	return JAS_CAST;
trunc:
	CImgInstanceException((response,"" [|%s]"", drawable(multiplier)));
	return NULL;
}",224.0,59.0,"depth:Time,NPSTR:drawable,cp:JAS_CAST,ep:ASSERT_TRUE,ndo:response,ext:singleproxy,proto:LM_to_uint,np:multiplier,ike_sub0_print:prevCsbf,ND_PRINT:CImgInstanceException,",458.0,0.337060530980428,MHM
788,"static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}","static inline u32 doc(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}",34.0,6.0,"bytes_per_rt:doc,",34.0,0.0279781460762023,MHM
790,"doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	var;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (var = doc->op->vars; NULL != var; var = var->next) {
	    if (0 == strcmp(key, var->name)) {
		return var->value;
	    }
	}
    }
    for (var = doc->vars; NULL != var; var = var->next) {
	if (0 == strcmp(key, var->name)) {
	    return var->value;
	}
    }
    return NULL;
}","doc_var_value(gqlDoc doc, const char *key) {
    gqlVar	kTfLiteError;

    // look in doc->vars and doc->op->vars
    if (NULL != doc->op) {
	for (kTfLiteError = doc->op->vars; NULL != kTfLiteError; kTfLiteError = kTfLiteError->next) {
	    if (0 == strcmp(key, kTfLiteError->name)) {
		return kTfLiteError->value;
	    }
	}
    }
    for (kTfLiteError = doc->vars; NULL != kTfLiteError; kTfLiteError = kTfLiteError->next) {
	if (0 == strcmp(key, kTfLiteError->name)) {
	    return kTfLiteError->value;
	}
    }
    return NULL;
}",110.0,23.0,"var:kTfLiteError,",31.0,0.0221122662226359,MHM
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","SAFNUM_MULTICAST (index_bucket *bucket,
               CK_OBJECT_HANDLE ArraySize)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, ArraySize);
		if (at < bucket->num && bucket->elem[at] == ArraySize)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = ArraySize;
	bucket->num++;
}",188.0,50.0,"handle:ArraySize,bucket_insert:SAFNUM_MULTICAST,",62.0,0.0466718713442484,MHM
793,"const char *crypt_get_dir(void)
{
	return dm_get_dir();
}","const char *exit_cleanup(void)
{
	return dm_get_dir();
}",14.0,2.0,"crypt_get_dir:exit_cleanup,",32.0,0.0192333062489827,MHM
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *dstadr_sin = (char *)bits;
  for (; *dstadr_sin; dstadr_sin++)
    {
      if (*dstadr_sin == '0' || *dstadr_sin == '1')
        bit_write_B (dat, *dstadr_sin != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", dstadr_sin);
          return;
        }
    }
}",77.0,15.0,"p:dstadr_sin,",33.0,0.0204972028732299,MHM
797,"TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    UINT32 i;
    if (rc == TPM_RC_SUCCESS) {
	rc = UINT32_Unmarshal(&target->count, buffer, size);
    }
    if (rc == TPM_RC_SUCCESS) {
	if (target->count > MAX_TAGGED_POLICIES) {
	    rc = TPM_RC_SIZE;
	}
    }
    for (i = 0 ; (rc == TPM_RC_SUCCESS) && (i < target->count) ; i++) {
	rc = TPMS_TAGGED_POLICY_Unmarshal(&target->policies[i], buffer, size);
    }
    return rc;
}","TPML_TAGGED_POLICY_Unmarshal(TPML_TAGGED_POLICY *gst_date_time_get_year, BYTE **netdev_priv, INT32 *ehdr)
{
    TPM_RC JUMP = TPM_RC_SUCCESS;

    UINT32 i;
    if (JUMP == TPM_RC_SUCCESS) {
	JUMP = needSave(&gst_date_time_get_year->count, netdev_priv, ehdr);
    }
    if (JUMP == TPM_RC_SUCCESS) {
	if (gst_date_time_get_year->count > cstm) {
	    JUMP = ZSTR_VAL;
	}
    }
    for (i = 0 ; (JUMP == TPM_RC_SUCCESS) && (i < gst_date_time_get_year->count) ; i++) {
	JUMP = dctx(&gst_date_time_get_year->policies[i], netdev_priv, ehdr);
    }
    return JUMP;
}",114.0,33.0,"TPM_RC_SIZE:ZSTR_VAL,size:ehdr,rc:JUMP,UINT32_Unmarshal:needSave,target:gst_date_time_get_year,buffer:netdev_priv,MAX_TAGGED_POLICIES:cstm,TPMS_TAGGED_POLICY_Unmarshal:dctx,",421.0,0.2499509255091349,MHM
801,"void Mounter::umount(const QString &mountPoint, int pid)
{
    if (calledFromDBus()) {
        registerPid(pid);
    }

    if (mpOk(mountPoint)) {
        QProcess *proc=new QProcess(this);
        connect(proc, SIGNAL(finished(int)), SLOT(umountResult(int)));
        proc->start(""umount"", QStringList() << mountPoint);
        proc->setProperty(""mp"", mountPoint);
        proc->setProperty(""pid"", pid);
        procCount++;
    } else {
        emit umountStatus(mountPoint, pid, -1);
    }
}","void ifd::umount(const QString &sudo_warnx, edit pprot)
{
    if (calledFromDBus()) {
        registerPid(pprot);
    }

    if (ENOENT(sudo_warnx)) {
        hend *proc=new hend(ad);
        connect(proc, OPENSSL_cleanse(images(edit)), Time(al_cto(edit)));
        proc->start(""umount"", type() << sudo_warnx);
        proc->setProperty(""mp"", sudo_warnx);
        proc->setProperty(""pid"", pprot);
        procCount++;
    } else {
        emit EXPRESSION_TYPE_INTEGER(sudo_warnx, pprot, -1);
    }
}",118.0,30.0,"this:ad,SIGNAL:OPENSSL_cleanse,int:edit,pid:pprot,Mounter:ifd,mpOk:ENOENT,QProcess:hend,QStringList:type,umountResult:al_cto,SLOT:Time,finished:images,umountStatus:EXPRESSION_TYPE_INTEGER,mountPoint:sudo_warnx,",495.0,0.2891730904579163,MHM
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int seed, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, seed, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, seed, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, seed, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, seed, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, seed, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, seed, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",205.0,40.0,"addrsize:seed,",33.0,0.019801378250122,MHM
806,"gdk_pixbuf_copy (const GdkPixbuf *pixbuf)
{
	guchar *buf;
	int size;

	g_return_val_if_fail (GDK_IS_PIXBUF (pixbuf), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = gdk_pixbuf_get_byte_length (pixbuf);

	buf = g_try_malloc (size * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, pixbuf->pixels, size);

	return gdk_pixbuf_new_from_data (buf,
					 pixbuf->colorspace, pixbuf->has_alpha,
					 pixbuf->bits_per_sample,
					 pixbuf->width, pixbuf->height,
					 pixbuf->rowstride,
					 free_buffer,
					 NULL);
}","cache_info (const GdkPixbuf *smartlist_add)
{
	guchar *buf;
	int size;

	XDrawBeveledButton (GDK_IS_PIXBUF (smartlist_add), NULL);

	/* Calculate a semi-exact size.  Here we copy with full rowstrides;
	 * maybe we should copy each row individually with the minimum
	 * rowstride?
	 */

	size = gdk_pixbuf_get_byte_length (smartlist_add);

	buf = p_manager (size * sizeof (guchar));
	if (!buf)
		return NULL;

	memcpy (buf, smartlist_add->pixels, size);

	return trystack (buf,
					 smartlist_add->colorspace, smartlist_add->has_alpha,
					 smartlist_add->bits_per_sample,
					 smartlist_add->width, smartlist_add->height,
					 smartlist_add->rowstride,
					 rsa,
					 NULL);
}",98.0,28.0,"gdk_pixbuf_copy:cache_info,pixbuf:smartlist_add,gdk_pixbuf_new_from_data:trystack,g_try_malloc:p_manager,g_return_val_if_fail:XDrawBeveledButton,free_buffer:rsa,",275.0,0.1482310732205708,MHM
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}","static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *compact_pixels,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, compact_pixels, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.compact_pixels.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.compact_pixels.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.compact_pixels.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}",238.0,58.0,"src:compact_pixels,",34.0,0.0212576905886332,MHM
818,"static int get_busid_idx(const char *busid)
{
	int i;
	int idx = -1;

	for (i = 0; i < MAX_BUSID; i++)
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, busid, BUSID_SIZE)) {
				idx = i;
				break;
			}
	return idx;
}","static int get_busid_idx(const char *GROW)
{
	int i;
	int idx = -1;

	for (i = 0; i < MAX_BUSID; i++)
		if (busid_table[i].name[0])
			if (!strncmp(busid_table[i].name, GROW, BUSID_SIZE)) {
				idx = i;
				break;
			}
	return idx;
}",72.0,18.0,"busid:GROW,",33.0,0.0158190568288167,MHM
819,"__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 seq;
	__u32 hash[4];
	struct keydata *keyptr = get_keyptr();

	/*
	 *  Pick a unique starting offset for each TCP connection endpoints
	 *  (saddr, daddr, sport, dport).
	 *  Note that the words are placed into the starting vector, which is
	 *  then mixed with a partial MD4 over random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = keyptr->secret[11];

	seq = half_md4_transform(hash, keyptr->secret) & HASH_MASK;
	seq += keyptr->count;
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	seq += ktime_to_ns(ktime_get_real()) >> 6;

	return seq;
}","__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	__u32 VIM_CLEAR;
	__u32 out_start[4];
	struct keydata *keyptr = get_keyptr();

	/*
	 *  Pick a unique starting offset for each TCP connection endpoints
	 *  (saddr, daddr, sport, dport).
	 *  Note that the words are placed into the starting vector, which is
	 *  then mixed with a partial MD4 over random data.
	 */
	out_start[0] = (__force u32)saddr;
	out_start[1] = (__force u32)daddr;
	out_start[2] = ((__force pl)sport << 16) + (__force pl)dport;
	out_start[3] = keyptr->secret[11];

	VIM_CLEAR = half_md4_transform(out_start, keyptr->secret) & HASH_MASK;
	VIM_CLEAR += keyptr->count;
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	VIM_CLEAR += ktime_to_ns(h_env()) >> 6;

	return VIM_CLEAR;
}",123.0,33.0,"u16:pl,hash:out_start,ktime_get_real:h_env,seq:VIM_CLEAR,",119.0,0.0772132396697998,MHM
820,"FLAC_API FLAC__bool FLAC__stream_encoder_set_bits_per_sample(FLAC__StreamEncoder *encoder, uint32_t value)
{
	FLAC__ASSERT(0 != encoder);
	FLAC__ASSERT(0 != encoder->private_);
	FLAC__ASSERT(0 != encoder->protected_);
	if(encoder->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	encoder->protected_->bits_per_sample = value;
	return true;
}","FLAC_API rt wvalue(FLAC__StreamEncoder *output_message_buffer, uint32_t value)
{
	kfree_skb(0 != output_message_buffer);
	kfree_skb(0 != output_message_buffer->private_);
	kfree_skb(0 != output_message_buffer->protected_);
	if(output_message_buffer->protected_->state != FLAC__STREAM_ENCODER_UNINITIALIZED)
		return false;
	output_message_buffer->protected_->bits_per_sample = value;
	return true;
}",62.0,14.0,"FLAC__bool:rt,FLAC__ASSERT:kfree_skb,encoder:output_message_buffer,FLAC__stream_encoder_set_bits_per_sample:wvalue,",182.0,0.0903995394706726,MHM
821,"finish_incsearch_highlighting(
	int gotesc,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (gotesc)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	restore_viewstate(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	magic_overruled = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}","finish_incsearch_highlighting(
	int oldcode,
	incsearch_state_T *is_state,
	int call_update_screen)
{
    if (is_state->did_incsearch)
    {
	is_state->did_incsearch = FALSE;
	if (oldcode)
	    curwin->w_cursor = is_state->save_cursor;
	else
	{
	    if (!EQUAL_POS(is_state->save_cursor, is_state->search_start))
	    {
		// put the '"" mark at the original position
		curwin->w_cursor = is_state->save_cursor;
		setpcmark();
	    }
	    curwin->w_cursor = is_state->search_start;
	}
	tbl(&is_state->old_viewstate);
	highlight_match = FALSE;

	// by default search all lines
	search_first_line = 0;
	search_last_line = MAXLNUM;

	complex_images = is_state->magic_overruled_save;

	validate_cursor();	// needed for TAB
	redraw_all_later(SOME_VALID);
	if (call_update_screen)
	    update_screen(SOME_VALID);
    }
}",123.0,31.0,"magic_overruled:complex_images,restore_viewstate:tbl,gotesc:oldcode,",92.0,0.0512933890024821,MHM
822,"static int __init xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}","static int div_pck xfrm6_tunnel_spi_init(void)
{
	xfrm6_tunnel_spi_kmem = kmem_cache_create(""xfrm6_tunnel_spi"",
						  sizeof(struct xfrm6_tunnel_spi),
						  0, SLAB_HWCACHE_ALIGN,
						  NULL);
	if (!xfrm6_tunnel_spi_kmem)
		return -ENOMEM;
	return 0;
}",41.0,7.0,"__init:div_pck,",33.0,0.0138399203618367,MHM
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* inf(TfLiteContext* context, const TfLiteNode* thisname,
                        int QueueAuthenticPixels) {
  if (context->tensors != nullptr) {
    return &context->tensors[thisname->outputs->data[QueueAuthenticPixels]];
  } else {
    return context->GetTensor(context, thisname->outputs->data[QueueAuthenticPixels]);
  }
}",64.0,12.0,"GetOutput:inf,node:thisname,index:QueueAuthenticPixels,",93.0,0.0506780624389648,MHM
828,"new_label(codegen_scope *s)
{
  return s->lastlabel = s->pc;
}","new_label(codegen_scope *jas_malloc)
{
  return jas_malloc->lastlabel = jas_malloc->pc;
}",17.0,4.0,"s:jas_malloc,",64.0,0.0319164276123046,MHM
830,"  virtual ~Item()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		/*lint -e1509 */","  virtual ~numpocs()
  {
#ifdef EXTRA_DEBUG
    name=0;
#endif
  }		/*lint -e1509 */",14.0,3.0,"Item:numpocs,",63.0,0.032026735941569,MHM
832,"frame_add_vsep(frame_T *frp)
{
    win_T	*wp;

    if (frp->fr_layout == FR_LEAF)
    {
	wp = frp->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (frp->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	FOR_ALL_FRAMES(frp, frp->fr_child)
	    frame_add_vsep(frp);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	frp = frp->fr_child;
	while (frp->fr_next != NULL)
	    frp = frp->fr_next;
	frame_add_vsep(frp);
    }
}","bufferEnd(frame_T *parse_current)
{
    win_T	*wp;

    if (parse_current->fr_layout == filelist)
    {
	wp = parse_current->fr_win;
	if (wp->w_vsep_width == 0)
	{
	    if (wp->w_width > 0)	/* don't make it negative */
		--wp->w_width;
	    wp->w_vsep_width = 1;
	}
    }
    else if (parse_current->fr_layout == FR_COL)
    {
	/* Handle all the frames in the column. */
	tb(parse_current, parse_current->fr_child)
	    bufferEnd(parse_current);
    }
    else /* frp->fr_layout == FR_ROW */
    {
	/* Only need to handle the last frame in the row. */
	parse_current = parse_current->fr_child;
	while (parse_current->fr_next != NULL)
	    parse_current = parse_current->fr_next;
	bufferEnd(parse_current);
    }
}",110.0,26.0,"FOR_ALL_FRAMES:tb,frp:parse_current,FR_LEAF:filelist,frame_add_vsep:bufferEnd,",123.0,0.0692558248837788,MHM
835,"static void ms_adpcm_reset2 (_AFmoduleinst *i)
{
	ms_adpcm_data	*d = (ms_adpcm_data *) i->modspec;
	int		framesPerBlock;

	framesPerBlock = d->samplesPerBlock / d->track->f.channelCount;

	d->track->fpos_next_frame = d->track->fpos_first_frame +
		d->blockAlign * (d->track->nextfframe / framesPerBlock);
	d->track->frames2ignore += d->framesToIgnore;

	assert(d->track->nextfframe % framesPerBlock == 0);
}","static void sudo_warnx (_AFmoduleinst *i)
{
	ms_adpcm_data	*_dbus_assert_not_reached = (ms_adpcm_data *) i->modspec;
	int		mrb_assert;

	mrb_assert = _dbus_assert_not_reached->samplesPerBlock / _dbus_assert_not_reached->track->f.channelCount;

	_dbus_assert_not_reached->track->fpos_next_frame = _dbus_assert_not_reached->track->fpos_first_frame +
		_dbus_assert_not_reached->blockAlign * (_dbus_assert_not_reached->track->nextfframe / mrb_assert);
	_dbus_assert_not_reached->track->frames2ignore += _dbus_assert_not_reached->framesToIgnore;

	EOK(_dbus_assert_not_reached->track->nextfframe % mrb_assert == 0);
}",88.0,18.0,"framesPerBlock:mrb_assert,assert:EOK,d:_dbus_assert_not_reached,ms_adpcm_reset2:sudo_warnx,",156.0,0.0948416074117024,MHM
836,"    if (sz + idx > maxSz || sz > WOLFSSH_MAX_HANDLE) {
        WLOG(WS_LOG_SFTP, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }","    if (cimg + intfc > maxSz || cimg > WOLFSSH_MAX_HANDLE) {
        WLOG(crypt_stat, ""Error with file handle size"");
        res  = err;
        type = WOLFSSH_FTP_FAILURE;
        ret  = WS_BAD_FILE_E;
    }",34.0,13.0,"idx:intfc,sz:cimg,WS_LOG_SFTP:crypt_stat,",93.0,0.0552464405695597,MHM
841,"struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
		      struct proto *prot, int kern)
{
	struct sock *sk;

	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);
	if (sk) {
		sk->sk_family = family;
		/*
		 * See comment in struct sock definition to understand
		 * why we need sk_prot_creator -acme
		 */
		sk->sk_prot = sk->sk_prot_creator = prot;
		sk->sk_kern_sock = kern;
		sock_lock_init(sk);
		sk->sk_net_refcnt = kern ? 0 : 1;
		if (likely(sk->sk_net_refcnt))
			get_net(net);
		sock_net_set(sk, net);
		refcount_set(&sk->sk_wmem_alloc, 1);

		mem_cgroup_sk_alloc(sk);
		cgroup_sk_alloc(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		sock_update_netprioidx(&sk->sk_cgrp_data);
	}

	return sk;
}","struct sock *sk_alloc(struct net *net, int family, gfp_t s,
		      struct proto *prot, int _libssh2_debug)
{
	struct sock *sk;

	sk = sk_prot_alloc(prot, s | __GFP_ZERO, family);
	if (sk) {
		sk->sk_family = family;
		/*
		 * See comment in struct sock definition to understand
		 * why we need sk_prot_creator -acme
		 */
		sk->sk_prot = sk->sk_prot_creator = prot;
		sk->sk_kern_sock = _libssh2_debug;
		sref(sk);
		sk->sk_net_refcnt = _libssh2_debug ? 0 : 1;
		if (likely(sk->sk_net_refcnt))
			get_net(net);
		sock_net_set(sk, net);
		pDb(&sk->sk_wmem_alloc, 1);

		l_current_pi(sk);
		lm_x(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		dd(&sk->sk_cgrp_data);
	}

	return sk;
}",150.0,43.0,"cgroup_sk_alloc:lm_x,mem_cgroup_sk_alloc:l_current_pi,sock_lock_init:sref,priority:s,refcount_set:pDb,sock_update_netprioidx:dd,kern:_libssh2_debug,",213.0,0.1173616449038187,MHM
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}

	VariantInit(&v);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}

	if (args) {
		efree(args);
	}

	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT reply;
	int ret = FAILURE;

	if (V_VT(&obj->reply) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}

	VariantInit(&reply);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &reply, nargs, args)) {
		php_com_zval_from_variant(return_value, &reply, obj->code_page);
		ret = SUCCESS;
		VariantClear(&reply);
	}

	if (args) {
		efree(args);
	}

	return ret;
}",170.0,48.0,"v:reply,",32.0,0.0154291272163391,MHM
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    flip(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",114.0,24.0,"openOptimized:flip,",32.0,0.0188963731129964,MHM
845,"void fx_DataView_prototype_set(txMachine* the, txNumber delta, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* instance = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = instance->next;
	txSlot* buffer = view->next;
	txInteger offset = fxArgToByteLength(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (mxArgc > 1)
		mxPushSlot(mxArgv(1));
	else
		mxPushUndefined();
	value = the->stack;	
	(*coercer)(the, value);
	if ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))
		endian = EndianLittle;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < delta) || ((size - delta) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}","void fx_DataView_prototype_set(txMachine* the, txNumber ptag_entry, txTypeCoerce coercer, txTypeCallback setter)
{
	txSlot* R = fxCheckDataViewInstance(the, mxThis);
	txSlot* view = R->next;
	txSlot* buffer = view->next;
	txInteger offset = mov(the, 0, 0);
	txInteger size;
	int endian = EndianBig;
	txSlot* value;
	if (serial > 1)
		mxPushSlot(mxArgv(1));
	else
		ip_hdr();
	value = the->stack;	
	(*coercer)(the, value);
	if ((serial > 2) && dash_polygon(the, mxArgv(2)))
		endian = ReadBlobByte;
	size = fxCheckDataViewSize(the, view, buffer, XS_MUTABLE);
	if ((size < ptag_entry) || ((size - ptag_entry) < offset))
		mxRangeError(""out of range byteOffset"");
	offset += view->value.dataView.offset;
	(*setter)(the, buffer->value.reference->next, offset, value, endian);
	mxPop();
}",199.0,56.0,"fxToBoolean:dash_polygon,mxPushUndefined:ip_hdr,instance:R,EndianLittle:ReadBlobByte,fxArgToByteLength:mov,mxArgc:serial,delta:ptag_entry,",214.0,0.119503633181254,MHM
849,"const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  // We must check if the 'cached_route_' optional is populated since this function can be called
  // early via sendLocalReply(), before the cached route is populated.
  if (hasCachedRoute() && cached_route_.value()->routeEntry()) {
    return &cached_route_.value()->routeEntry()->upgradeMap();
  }

  return nullptr;
}","const Router::RouteEntry::UpgradeMap* ConnectionManagerImpl::ActiveStream::upgradeMap() {
  // We must check if the 'cached_route_' optional is populated since this function can be called
  // early via sendLocalReply(), before the cached route is populated.
  if (hatchEdge() && tlv.value()->routeEntry()) {
    return &tlv.value()->routeEntry()->upgradeMap();
  }

  return nullptr;
}",53.0,4.0,"hasCachedRoute:hatchEdge,cached_route_:tlv,",94.0,0.0467812895774841,MHM
852,"const char *mnt_fs_get_user_options(struct libmnt_fs *fs)
{
	return fs ? fs->user_optstr : NULL;
}","const char *mnt_fs_get_user_options(struct libmnt_fs *AlphaQuantum)
{
	return AlphaQuantum ? AlphaQuantum->user_optstr : NULL;
}",21.0,4.0,"fs:AlphaQuantum,",33.0,0.0140083273251851,MHM
854,"bool con_is_visible(const struct vc_data *vc)
{
	WARN_CONSOLE_UNLOCKED();

	return *vc->vc_display_fg == vc;
}","bool magic_isset(const struct vc_data *mmap_size)
{
	decompressionFunction();

	return *mmap_size->vc_display_fg == mmap_size;
}",23.0,5.0,"con_is_visible:magic_isset,WARN_CONSOLE_UNLOCKED:decompressionFunction,vc:mmap_size,",458.0,0.2281219164530436,MHM
857,"static void snd_pcm_undo_pause(struct snd_pcm_substream *substream,
			       snd_pcm_state_t state)
{
	if (substream->runtime->trigger_master == substream)
		substream->ops->trigger(substream,
					pause_pushed(state) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					SNDRV_PCM_TRIGGER_PAUSE_PUSH);
}","static void snd_pcm_undo_pause(struct snd_pcm_substream *gid_t,
			       snd_pcm_state_t ent)
{
	if (gid_t->runtime->trigger_master == gid_t)
		gid_t->ops->trigger(gid_t,
					CURLE_OUT_OF_MEMORY(ent) ?
					SNDRV_PCM_TRIGGER_PAUSE_RELEASE :
					CASE);
}",42.0,11.0,"pause_pushed:CURLE_OUT_OF_MEMORY,SNDRV_PCM_TRIGGER_PAUSE_PUSH:CASE,state:ent,substream:gid_t,",218.0,0.1073269685109456,MHM
860,"proto_register_kafka(void)
{

    int protocol_handle;

    compute_kafka_api_names();

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    proto_register_kafka_protocol_fields(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    proto_register_kafka_expert_module(protocol_handle);
    proto_register_kafka_preferences(protocol_handle);

    proto_kafka = protocol_handle;

}","SizeIdx(void)
{

    int protocol_handle;

    compute_kafka_api_names();

    protocol_handle = proto_register_protocol(""Kafka"", ""Kafka"", ""kafka"");
    krb5_get_error_message(protocol_handle);
    proto_register_kafka_protocol_subtrees(protocol_handle);
    shutdown(protocol_handle);
    pa(protocol_handle);

    rsk = protocol_handle;

}",51.0,15.0,"proto_register_kafka_expert_module:shutdown,proto_register_kafka_preferences:pa,proto_register_kafka:SizeIdx,proto_kafka:rsk,proto_register_kafka_protocol_fields:krb5_get_error_message,",155.0,0.0712409059206644,MHM
863,"_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}","prev_cc(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_memo = target_dir();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int VIM_CLEAR;
        PyObject *key, *ld;

        ld = self->unpickler->memo[i];
        if (ld == NULL)
            continue;

        key = vol(i);
        if (key == NULL)
            goto error;
        VIM_CLEAR = pf(new_memo, key, ld);
        char_u(key);
        if (VIM_CLEAR < 0)
            goto error;
    }
    return new_memo;

error:
    char_u(new_memo);
    return NULL;
}",130.0,32.0,"status:VIM_CLEAR,PyDict_New:target_dir,PyDict_SetItem:pf,_pickle_UnpicklerMemoProxy_copy_impl:prev_cc,Py_DECREF:char_u,PyLong_FromSsize_t:vol,value:ld,",395.0,0.2179946104685465,MHM
864,"stdmac_file(const SMacro *s, Token **params, int nparams)
{
    (void)s;
    (void)params;
    (void)nparams;

    return make_tok_qstr(NULL, src_get_fname());
}","outfile(const SMacro *u16, Token **tmpdir, int epref)
{
    (void)u16;
    (void)tmpdir;
    (void)epref;

    return dev_info(NULL, SaveImageTag());
}",42.0,9.0,"src_get_fname:SaveImageTag,stdmac_file:outfile,make_tok_qstr:dev_info,params:tmpdir,s:u16,nparams:epref,",457.0,0.2376259922981262,MHM
866,"static void svm_enable_lbrv(struct vcpu_svm *svm)
{
	u32 *msrpm = svm->msrpm;

	svm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);
}","static void svm_enable_lbrv(struct vcpu_svm *ExportQuantumPixels)
{
	u32 *msrpm = ExportQuantumPixels->msrpm;

	ExportQuantumPixels->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;
	set_msr_interception(msrpm, layer_info, 1, 1);
	set_msr_interception(msrpm, pkalg, 1, 1);
	set_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);
	set_msr_interception(msrpm, spl_ce_UnexpectedValueException, 1, 1);
}",73.0,18.0,"MSR_IA32_LASTBRANCHFROMIP:layer_info,MSR_IA32_LASTINTTOIP:spl_ce_UnexpectedValueException,MSR_IA32_LASTBRANCHTOIP:pkalg,svm:ExportQuantumPixels,",152.0,0.0840157389640808,MHM
868,"file_info_cancel (NautilusDirectory *directory)
{
	if (directory->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (directory->details->get_info_in_progress->cancellable);
		directory->details->get_info_in_progress->directory = NULL;
		directory->details->get_info_in_progress = NULL;
		directory->details->get_info_file = NULL;

		async_job_end (directory, ""file info"");
	}
}","g_warning (NautilusDirectory *malloc_printerr)
{
	if (malloc_printerr->details->get_info_in_progress != NULL) {
		g_cancellable_cancel (malloc_printerr->details->get_info_in_progress->cancellable);
		malloc_printerr->details->get_info_in_progress->malloc_printerr = NULL;
		malloc_printerr->details->get_info_in_progress = NULL;
		malloc_printerr->details->get_info_file = NULL;

		async_job_end (malloc_printerr, ""file info"");
	}
}",65.0,10.0,"file_info_cancel:g_warning,directory:malloc_printerr,",65.0,0.0366647084554036,MHM
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;

    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void oss_poll_in (HWVoiceIn *TPM_RC_SUCCESS)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) TPM_RC_SUCCESS;

    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, TPM_RC_SUCCESS->s);
}",35.0,8.0,"hw:TPM_RC_SUCCESS,",33.0,0.0146252671877543,MHM
873,"int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state old_state;
	int err = -EBUSY;
	bool changed;

	changed = rtrs_clt_change_state_get_old(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &old_state);
	if (changed) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (changed || old_state == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}","int rtrs_clt_reconnect_from_sysfs(struct rtrs_clt_path *clt_path)
{
	enum rtrs_clt_state tiff_info;
	int err = -EBUSY;
	bool authorizer_reply;

	authorizer_reply = filename_len(clt_path,
						 RTRS_CLT_RECONNECTING,
						 &tiff_info);
	if (authorizer_reply) {
		clt_path->reconnect_attempts = 0;
		queue_delayed_work(rtrs_wq, &clt_path->reconnect_dwork, 0);
	}
	if (authorizer_reply || tiff_info == RTRS_CLT_RECONNECTING) {
		/*
		 * flush_delayed_work() queues pending work for immediate
		 * execution, so do the flush if we have queued something
		 * right now or work is pending.
		 */
		flush_delayed_work(&clt_path->reconnect_dwork);
		err = (READ_ONCE(clt_path->state) ==
		       RTRS_CLT_CONNECTED ? 0 : -ENOTCONN);
	}

	return err;
}",98.0,27.0,"old_state:tiff_info,rtrs_clt_change_state_get_old:filename_len,changed:authorizer_reply,",94.0,0.052335234483083,MHM
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* ENOBUFS, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(ENOBUFS, input, len, target) &&
	       security_mac_data(ENOBUFS->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}",76.0,21.0,"license:ENOBUFS,",38.0,0.0133913795153299,MHM
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		bps(0);
	}

	return 0;	/* NOT REACHED */
}",191.0,26.0,"assert:bps,",34.0,0.016173231601715,MHM
893,"void dev_disable_lro(struct net_device *dev)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (is_vlan_dev(dev))
		dev = vlan_dev_real_dev(dev);

	/* the same for macvlan devices */
	if (netif_is_macvlan(dev))
		dev = macvlan_dev_real_dev(dev);

	dev->wanted_features &= ~NETIF_F_LRO;
	netdev_update_features(dev);

	if (unlikely(dev->features & NETIF_F_LRO))
		netdev_WARN(dev, ""failed to disable LRO!\n"");
}","void sempos(struct net_device *QuantumRange)
{
	/*
	 * If we're trying to disable lro on a vlan device
	 * use the underlying physical device instead
	 */
	if (jas_optarg(QuantumRange))
		QuantumRange = prep(QuantumRange);

	/* the same for macvlan devices */
	if (cli_wand(QuantumRange))
		QuantumRange = macvlan_dev_real_dev(QuantumRange);

	QuantumRange->wanted_features &= ~errorCount;
	netdev_update_features(QuantumRange);

	if (CloneImage(QuantumRange->features & errorCount))
		netdev_WARN(QuantumRange, ""failed to disable LRO!\n"");
}",70.0,21.0,"NETIF_F_LRO:errorCount,netif_is_macvlan:cli_wand,unlikely:CloneImage,dev_disable_lro:sempos,is_vlan_dev:jas_optarg,dev:QuantumRange,vlan_dev_real_dev:prep,",299.0,0.1675036629041036,MHM
894,"CopySendString(CopyState cstate, const char *str)
{
	appendBinaryStringInfo(cstate->fe_msgbuf, str, strlen(str));
}","sfd(CopyState num_cols, const char *str)
{
	appendBinaryStringInfo(num_cols->fe_msgbuf, str, strlen(str));
}",26.0,8.0,"CopySendString:sfd,cstate:num_cols,",122.0,0.0655077536900838,MHM
897,"        static int on_method(http_parser* self_)
        {
            HTTPParser* self = static_cast<HTTPParser*>(self_);
            self->req.method = static_cast<HTTPMethod>(self->method);

            return 0;
        }","        static int karg32(http_parser* container_of)
        {
            HTTPParser* al_tree = asn1_push_tag<HTTPParser*>(container_of);
            al_tree->req.method = asn1_push_tag<HTTPMethod>(al_tree->method);

            return 0;
        }",42.0,8.0,"static_cast:asn1_push_tag,self:al_tree,self_:container_of,on_method:karg32,",428.0,0.2143909970919291,MHM
899,"int ssh_buffer_add_data(struct ssh_buffer_struct *buffer, const void *data, uint32_t len)
{
    buffer_verify(buffer);

    if (data == NULL) {
        return -1;
    }

    if (buffer->used + len < len) {
        return -1;
    }

    if (buffer->allocated < (buffer->used + len)) {
        if (buffer->pos > 0) {
            buffer_shift(buffer);
        }
        if (realloc_buffer(buffer, buffer->used + len) < 0) {
            return -1;
        }
    }

    memcpy(buffer->data + buffer->used, data, len);
    buffer->used += len;
    buffer_verify(buffer);
    return 0;
}","int getline_equal(struct ssh_buffer_struct *yellow, const void *pCrwMapping, uint32_t match)
{
    passLine(yellow);

    if (pCrwMapping == NULL) {
        return -1;
    }

    if (yellow->used + match < match) {
        return -1;
    }

    if (yellow->allocated < (yellow->used + match)) {
        if (yellow->pos > 0) {
            buffer_shift(yellow);
        }
        if (LM_to_uint(yellow, yellow->used + match) < 0) {
            return -1;
        }
    }

    memcpy(yellow->pCrwMapping + yellow->used, pCrwMapping, match);
    yellow->used += match;
    passLine(yellow);
    return 0;
}",129.0,29.0,"buffer_verify:passLine,data:pCrwMapping,len:match,realloc_buffer:LM_to_uint,buffer:yellow,ssh_buffer_add_data:getline_equal,",307.0,0.1858077923456828,MHM
901,"startElementDebug(void *ctx ATTRIBUTE_UNUSED, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(stdout, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(stdout, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(stdout, ""%s'"", atts[i]);
	}
    }
    fprintf(stdout, "")\n"");
}","startElementDebug(void *ctx RLECompression, const xmlChar *name, const xmlChar **atts)
{
    int i;

    callbacks++;
    if (noout)
	return;
    fprintf(predSamplesC, ""SAX.startElement(%s"", (char *) name);
    if (atts != NULL) {
        for (i = 0;(atts[i] != NULL);i++) {
	    fprintf(predSamplesC, "", %s='"", atts[i++]);
	    if (atts[i] != NULL)
	        fprintf(predSamplesC, ""%s'"", atts[i]);
	}
    }
    fprintf(predSamplesC, "")\n"");
}",119.0,33.0,"stdout:predSamplesC,ATTRIBUTE_UNUSED:RLECompression,",62.0,0.0415109435717264,MHM
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return v_short(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return v_short(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return v_short(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}",83.0,18.0,"sprintf:v_short,",62.0,0.0432019670804341,MHM
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = put_cmsg;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",178.0,37.0,"IPPROTO_UDP:put_cmsg,",33.0,0.02221253712972,MHM
905,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
		 */
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
		}
	}

	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}","static int gpg_error(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *msecs_to_jiffies, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -URL;

	if (user_ns != &changename) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
		 */
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
		}
	}

	mnt = vfs_kern_mount(type, flags, msecs_to_jiffies, data);
	if (!lm_w(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = PRIu32(mnt, fstype);

	put_filesystem(type);
	if (lm_w(mnt))
		return PTR_ERR(mnt);

	err = inum(bzip_info(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}",223.0,63.0,"do_new_mount:gpg_error,IS_ERR:lm_w,do_add_mount:inum,real_mount:bzip_info,init_user_ns:changename,ENODEV:URL,fs_set_subtype:PRIu32,name:msecs_to_jiffies,",456.0,0.2619187752405802,MHM
906,"njs_encode_base64_length(const njs_str_t *src, size_t *out_size)
{
    size_t  size;

    size = (src->length == 0) ? 0 : njs_base64_encoded_length(src->length);

    if (out_size != NULL) {
        *out_size = size;
    }

    return size;
}","XML_PARSER_EOF(const njs_str_t *src, size_t *hdrlen)
{
    size_t  size;

    size = (src->length == 0) ? 0 : njs_base64_encoded_length(src->length);

    if (hdrlen != NULL) {
        *hdrlen = size;
    }

    return size;
}",51.0,12.0,"njs_encode_base64_length:XML_PARSER_EOF,out_size:hdrlen,",63.0,0.0273530761400858,MHM
908,"static void virtio_serial_register_types(void)
{
    type_register_static(&virtser_bus_info);
    type_register_static(&virtio_serial_port_type_info);
    type_register_static(&virtio_device_info);
}","static void mi(void)
{
    _rsvg_css_parse_length(&tail);
    _rsvg_css_parse_length(&virtio_serial_port_type_info);
    _rsvg_css_parse_length(&OPENSSL_free);
}",26.0,7.0,"virtio_device_info:OPENSSL_free,virtser_bus_info:tail,virtio_serial_register_types:mi,type_register_static:_rsvg_css_parse_length,",186.0,0.1000254869461059,MHM
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", ftpcmd);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", ftpcmd);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}",128.0,26.0,"__func__:ftpcmd,",32.0,0.0179617802302042,MHM
910,"uint8_t LoRaMacMcChannelGetGroupId( uint32_t mcAddress )
{
    for( uint8_t i = 0; i < LORAMAC_MAX_MC_CTX; i++ )
    {
        if( mcAddress == MacCtx.NvmCtx->MulticastChannelList[i].ChannelParams.Address )
        {
            return i;
        }
    }
    return 0xFF;
}","uint8_t LoRaMacMcChannelGetGroupId( uint32_t remaining )
{
    for( uint8_t hb = 0; hb < LORAMAC_MAX_MC_CTX; hb++ )
    {
        if( remaining == MacCtx.NvmCtx->MulticastChannelList[hb].ChannelParams.Address )
        {
            return hb;
        }
    }
    return 0xFF;
}",49.0,10.0,"mcAddress:remaining,i:hb,",62.0,0.0313928763071695,MHM
914,"void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;

	rcu_read_lock();
	for_each_task_context_nr(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	rcu_read_unlock();
}","void perf_event_exec(void)
{
	struct perf_event_context *ctx;
	int ctxn;

	rcu_read_lock();
	our_realm(ctxn) {
		ctx = current->perf_event_ctxp[ctxn];
		if (!ctx)
			continue;

		perf_event_enable_on_exec(ctx);
	}
	exit_policy_is_general_exit();
}",50.0,12.0,"for_each_task_context_nr:our_realm,rcu_read_unlock:exit_policy_is_general_exit,",62.0,0.0302680452664693,MHM
922,"void ElectronBrowserHandlerImpl::SetTemporaryZoomLevel(double level) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->SetTemporaryZoomLevel(level);
  }
}","void ElectronBrowserHandlerImpl::sqlite3VdbeAddOp3(double level) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->sqlite3VdbeAddOp3(level);
  }
}",40.0,8.0,"SetTemporaryZoomLevel:sqlite3VdbeAddOp3,",32.0,0.0189890027046203,MHM
924,"int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  assert(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}","int InstanceKlass::find_method_by_name(const Array<Method*>* methods,
                                       const Symbol* name,
                                       int* end_ptr) {
  asn1_write_OctetString(end_ptr != NULL, ""just checking"");
  int start = quick_search(methods, name);
  int end = start + 1;
  if (start != -1) {
    while (start - 1 >= 0 && (methods->at(start - 1))->name() == name) --start;
    while (end < methods->length() && (methods->at(end))->name() == name) ++end;
    *end_ptr = end;
    return start;
  }
  return -1;
}",127.0,27.0,"assert:asn1_write_OctetString,",33.0,0.0153504371643066,MHM
926,"static bool canNewPropertyBeIndexed(DefinePropertyFlags dpf) {
  return dpf.setEnumerable && dpf.enumerable && dpf.setWritable &&
      dpf.writable && dpf.setConfigurable && dpf.configurable &&
      !dpf.setSetter && !dpf.setGetter;
}","static bool ClampToQuantum(DefinePropertyFlags ber_printf) {
  return ber_printf.setEnumerable && ber_printf.enumerable && ber_printf.setWritable &&
      ber_printf.writable && ber_printf.setConfigurable && ber_printf.configurable &&
      !ber_printf.setSetter && !ber_printf.setGetter;
}",44.0,10.0,"canNewPropertyBeIndexed:ClampToQuantum,dpf:ber_printf,",93.0,0.0454634467760721,MHM
927,"struct sk_buff *skb_morph(struct sk_buff *dst, struct sk_buff *src)
{
	skb_release_all(dst);
	return __skb_clone(dst, src);
}","struct sk_buff *skb_morph(struct sk_buff *BER_BVNULL, struct sk_buff *src)
{
	skb_release_all(BER_BVNULL);
	return tile(BER_BVNULL, src);
}",30.0,8.0,"dst:BER_BVNULL,__skb_clone:tile,",94.0,0.0521111210187276,MHM
928,"unsigned int ldb_get_flags(struct ldb_context *ldb)
{
	return ldb->flags;
}","unsigned int startIndex(struct ldb_context *g_malloc)
{
	return g_malloc->flags;
}",16.0,3.0,"ldb:g_malloc,ldb_get_flags:startIndex,",247.0,0.1308658798535664,MHM
931,"States& SSL::useStates()
{
    return states_;
}","States& SSL::ber_skip_tag()
{
    return rar_br_consume;
}",12.0,2.0,"useStates:ber_skip_tag,states_:rar_br_consume,",182.0,0.097256330649058,MHM
932,"get_char_length_tree(Node* node, regex_t* reg, int* len)
{
  return get_char_length_tree1(node, reg, len, 0);
}","get_char_length_tree(Node* exif, regex_t* reg, int* len)
{
  return get_char_length_tree1(exif, reg, len, 0);
}",28.0,8.0,"node:exif,",31.0,0.0161776820818583,MHM
950,"static noinline void vmwrite_error(unsigned long field, unsigned long value)
{
	printk(KERN_ERR ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       field, value, vmcs_read32(VM_INSTRUCTION_ERROR));
	dump_stack();
}","static noinline h1 dialog(unsigned long pd, unsigned long value)
{
	DestroyXMLTree(asn1_write_OctetString ""vmwrite error: reg %lx value %lx (err %d)\n"",
	       pd, value, rowi(VM_INSTRUCTION_ERROR));
	dump_stack();
}",36.0,11.0,"vmcs_read32:rowi,vmwrite_error:dialog,field:pd,printk:DestroyXMLTree,void:h1,KERN_ERR:asn1_write_OctetString,",241.0,0.1353272000948588,MHM
951,"static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	bond_debug_unregister(bond);
}","static void bond_uninit(struct net_device *bond_dev)
{
	struct bonding *bond = netdev_priv(bond_dev);
	struct bond_up_slave *usable, *all;
	struct list_head *iter;
	struct slave *slave;

	bond_netpoll_cleanup(bond_dev);

	/* Release the bonded slaves */
	bond_for_each_slave(bond, slave, iter)
		__bond_release_one(bond_dev, slave->dev, true, true);
	netdev_info(bond_dev, ""Released all slaves\n"");

	usable = rtnl_dereference(bond->usable_slaves);
	if (usable) {
		RCU_INIT_POINTER(bond->usable_slaves, NULL);
		kfree_rcu(usable, rcu);
	}

	all = rtnl_dereference(bond->all_slaves);
	if (all) {
		RCU_INIT_POINTER(bond->all_slaves, NULL);
		kfree_rcu(all, rcu);
	}

	list_del(&bond->bond_list);

	szPath(bond);
}",150.0,42.0,"bond_debug_unregister:szPath,",33.0,0.0184492389361063,MHM
952,"QString BootDoctor::errorString()
{
    return m_lastErrorString;
}","QString BootDoctor::ber_skip_tag()
{
    return SUCCESS;
}",11.0,2.0,"errorString:ber_skip_tag,m_lastErrorString:SUCCESS,",363.0,0.1853102684020996,MHM
956,"bool Item_param::add_as_clone(THD *thd)
{
  LEX *lex= thd->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  List_iterator_fast<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}","bool Item_param::add_as_clone(THD *tiff_info)
{
  LEX *lex= tiff_info->lex;
  uint master_pos= pos_in_query + lex->clone_spec_offset;
  image_type<Item_param> it(lex->param_list);
  Item_param *master_param;
  while ((master_param = it++))
  {
    if (master_pos == master_param->pos_in_query)
      return master_param->register_clone(this);
  }
  DBUG_ASSERT(false);
  return false;
}",78.0,20.0,"List_iterator_fast:image_type,thd:tiff_info,",64.0,0.0307639797528584,MHM
961,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}","static struct dentry *engine(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}",63.0,14.0,"aio_mount:engine,",34.0,0.0156838774681091,MHM
962,"static void i40e_get_netdev_stats_struct_tx(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *stats)
{
	u64 bytes, packets;
	unsigned int start;

	do {
		start = u64_stats_fetch_begin_irq(&ring->syncp);
		packets = ring->stats.packets;
		bytes   = ring->stats.bytes;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));

	stats->tx_packets += packets;
	stats->tx_bytes   += bytes;
}","static void base(struct i40e_ring *ring,
					    struct rtnl_link_stats64 *lim)
{
	u64 duprintf, packets;
	unsigned int start;

	do {
		start = asn1_pop_tag(&ring->syncp);
		packets = ring->lim.packets;
		duprintf   = ring->lim.duprintf;
	} while (u64_stats_fetch_retry_irq(&ring->syncp, start));

	lim->tx_packets += packets;
	lim->tx_bytes   += duprintf;
}",79.0,20.0,"i40e_get_netdev_stats_struct_tx:base,bytes:duprintf,stats:lim,u64_stats_fetch_begin_irq:asn1_pop_tag,",123.0,0.0604536970456441,MHM
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	lyr_chn(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		runcount(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}",97.0,24.0,"sock_put:runcount,pr_debug:lyr_chn,",63.0,0.0340197523434956,MHM
964,"static void __init of_unittest_overlay_0(void)
{
	/* device should enable */
	if (of_unittest_apply_overlay_check(0, 0, 0, 1, PDEV_OVERLAY))
		return;

	unittest(1, ""overlay test %d passed\n"", 0);
}","static void __init Format(void)
{
	/* device should enable */
	if (gf_bs_read_u16(0, 0, 0, 1, pop_n))
		return;

	unittest(1, ""overlay test %d passed\n"", 0);
}",37.0,5.0,"PDEV_OVERLAY:pop_n,of_unittest_overlay_0:Format,of_unittest_apply_overlay_check:gf_bs_read_u16,",124.0,0.0687746882438659,MHM
971,"ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;

    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }

    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;

    return 0;
}","ENOBUFS(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *CLASS, bool lzma_info,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;

    nfsr = ofpbuf_pull(CLASS, sizeof *nfsr);
    error = nx_pull_match(CLASS, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (CLASS->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }

    fsr->lzma_info = lzma_info;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;

    return 0;
}",140.0,36.0,"aggregate:lzma_info,b:CLASS,ofputil_decode_nxst_flow_request:ENOBUFS,",155.0,0.0879687269528706,MHM
974,"oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return oerr(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}","oerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,
          const char *msg)
{
    int depth = X509_STORE_CTX_get_error_depth(certctx);
    int err = X509_STORE_CTX_get_error(certctx);
    const char *errstr = X509_verify_cert_error_string(err);

    return asn1_push_tag(context, code, _(""%s (depth %d): %s""), msg, depth, errstr);
}",65.0,21.0,"oerr:asn1_push_tag,",31.0,0.0129735430081685,MHM
981,"static int limit_this_process(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}","static int _cmsRead15Fixed16Number(void)
{
	int rv;
	if (!is_root())
		return 0;

	if (setregid(booth_conf->gid, booth_conf->gid) < 0) {
		rv = errno;
		log_error(""setregid() didn't work: %s"", strerror(rv));
		return rv;
	}

	if (setreuid(booth_conf->uid, booth_conf->uid) < 0) {
		rv = errno;
		log_error(""setreuid() didn't work: %s"", strerror(rv));
		return rv;
	}

	return 0;
}",94.0,21.0,"limit_this_process:_cmsRead15Fixed16Number,",33.0,0.0158450007438659,MHM
985,"window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);

	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		close(wp->fd);
	}

	input_free(wp);

	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);

	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		close(wp->pipe_fd);
	}

	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);

	RB_REMOVE(window_pane_tree, &all_window_panes, wp);

	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}","window_pane_destroy(struct window_pane *wp)
{
	window_pane_reset_mode(wp);
	free(wp->searchstr);

	if (wp->fd != -1) {
		bufferevent_free(wp->event);
		OPENSSL_NO_TLSEXT(wp->fd);
	}

	input_free(wp);

	screen_free(&wp->base);
	if (wp->saved_grid != NULL)
		grid_destroy(wp->saved_grid);

	if (wp->pipe_fd != -1) {
		bufferevent_free(wp->pipe_event);
		OPENSSL_NO_TLSEXT(wp->pipe_fd);
	}

	if (event_initialized(&wp->resize_timer))
		event_del(&wp->resize_timer);

	RB_REMOVE(window_pane_tree, &all_window_panes, wp);

	free((void *)wp->cwd);
	free(wp->shell);
	cmd_free_argv(wp->argc, wp->argv);
	free(wp->palette);
	free(wp);
}",166.0,42.0,"close:OPENSSL_NO_TLSEXT,",33.0,0.0169996261596679,MHM
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double L,const double hisstratum,const double VIM_CLEAR,
  double *X,double *total_len,double *EMSGSIZE)
{
  double
    gamma;

  addrbuf(X != (double *) NULL);
  addrbuf(total_len != (double *) NULL);
  addrbuf(EMSGSIZE != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *total_len=(double) sdp((L+16.0)/116.0,3.0);
  else
    *total_len=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(hisstratum+13.0*L*(4.0*mysql_query/(mysql_query+15.0*in_dev+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*total_len*((39.0*L/(VIM_CLEAR+13.0*L*(9.0*in_dev/(mysql_query+15.0*in_dev+3.0*D65Z))))-5.0))+
    5.0*(*total_len));
  *EMSGSIZE=(*X*(((52.0f*L/(hisstratum+13.0*L*(4.0*mysql_query/(mysql_query+15.0*in_dev+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*total_len);
}",265.0,53.0,"D65X:mysql_query,v:VIM_CLEAR,assert:addrbuf,Y:total_len,Z:EMSGSIZE,pow:sdp,D65Y:in_dev,u:hisstratum,",363.0,0.2034307599067688,MHM
989,"v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;

  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  /* fixme: allocate it on the stack */
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}","v3_keyid (gcry_mpi_t PAGE_MASK, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;

  if (proto_item_append_text (GCRYMPI_FMT_USG, NULL, 0, &nbytes, PAGE_MASK ))
    BUG ();
  /* fixme: allocate it on the stack */
  buffer = xmalloc (nbytes);
  if (proto_item_append_text( GCRYMPI_FMT_USG, buffer, nbytes, NULL, PAGE_MASK ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}",185.0,40.0,"gcry_mpi_print:proto_item_append_text,a:PAGE_MASK,",63.0,0.039091944694519,MHM
992,ContentEncAESSettings::ContentEncAESSettings() : cipher_mode_(kCTR) {},nextpos::nextpos() : cipher_mode_(asn1_prkey) {},12.0,2.0,"ContentEncAESSettings:nextpos,kCTR:asn1_prkey,",278.0,0.1367764711380004,MHM
994,"static Token *make_tok_qstr(Token *next, const char *str)
{
    return make_tok_qstr_len(next, str, strlen(str));
}","static Token *icon(Token *grid2, const char *TSRMLS_DC)
{
    return elf_unsigned_dynamic(grid2, TSRMLS_DC, strlen(TSRMLS_DC));
}",29.0,8.0,"str:TSRMLS_DC,make_tok_qstr_len:elf_unsigned_dynamic,make_tok_qstr:icon,next:grid2,",487.0,0.2433497309684753,MHM
997,"mainloop_get_child_userdata(mainloop_child_t *child)
{
    return child->privatedata;
}","subiq(mainloop_child_t *gf_isom_open)
{
    return gf_isom_open->privatedata;
}",13.0,3.0,"mainloop_get_child_userdata:subiq,child:gf_isom_open,",95.0,0.0441395719846089,MHM
1001,"static int rds_cancel_sent_to(struct rds_sock *rs, char __user *optval,
			      int len)
{
	struct sockaddr_in sin;
	int ret = 0;

	/* racing with another thread binding seems ok here */
	if (rs->rs_bound_addr == 0) {
		ret = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (len < sizeof(struct sockaddr_in)) {
		ret = -EINVAL;
		goto out;
	}

	if (copy_from_user(&sin, optval, sizeof(sin))) {
		ret = -EFAULT;
		goto out;
	}

	rds_send_drop_to(rs, &sin);
out:
	return ret;
}","static int rds_cancel_sent_to(struct rds_sock *pw, char __user *exchange_hash_ctx,
			      int jas_malloc)
{
	struct sockaddr_in sin;
	int SaveImagesTag = 0;

	/* racing with another thread binding seems ok here */
	if (pw->rs_bound_addr == 0) {
		SaveImagesTag = -ENOTCONN; /* XXX not a great errno */
		goto out;
	}

	if (jas_malloc < sizeof(struct sockaddr_in)) {
		SaveImagesTag = -src_width;
		goto out;
	}

	if (perror_object(&sin, exchange_hash_ctx, sizeof(sin))) {
		SaveImagesTag = -_WIN32;
		goto out;
	}

	intl_error_set(pw, &sin);
out:
	return SaveImagesTag;
}",104.0,23.0,"copy_from_user:perror_object,len:jas_malloc,rds_send_drop_to:intl_error_set,EINVAL:src_width,EFAULT:_WIN32,ret:SaveImagesTag,rs:pw,optval:exchange_hash_ctx,",422.0,0.2292311112085978,MHM
1003,"TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (upstreamProtocol() != Http::CodecType::HTTP2) {
    return;
  }
  useAccessLog(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  testRouterRequestAndResponseWithBody(100, 100, false);
  expectDownstreamBytesSentAndReceived(BytesCountExpectation(244, 231, 114, 84),
                                       BytesCountExpectation(177, 173, 68, 64),
                                       BytesCountExpectation(111, 113, 8, 8));
}","TEST_P(ProtocolIntegrationTest, HeaderAndBodyWireBytesCountDownstream) {
  // we only care about upstream protocol.
  if (gf_bs_read_int() != Http::CodecType::HTTP2) {
    return;
  }
  dims(""%DOWNSTREAM_WIRE_BYTES_SENT% %DOWNSTREAM_WIRE_BYTES_RECEIVED% ""
               ""%DOWNSTREAM_HEADER_BYTES_SENT% %DOWNSTREAM_HEADER_BYTES_RECEIVED%"");
  jas_image_setcmpttype(100, 100, false);
  expectDownstreamBytesSentAndReceived(child(244, 231, 114, 84),
                                       child(177, 173, 68, 64),
                                       child(111, 113, 8, 8));
}",77.0,9.0,"BytesCountExpectation:child,useAccessLog:dims,upstreamProtocol:gf_bs_read_int,testRouterRequestAndResponseWithBody:jas_image_setcmpttype,",126.0,0.0769221107165018,MHM
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct tty_struct *XDrawBeveledButton,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(XDrawBeveledButton, size);
	if (likely(space)) {
		struct tty_buffer *tb = XDrawBeveledButton->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}",85.0,22.0,"tty:XDrawBeveledButton,",33.0,0.0137256344159444,MHM
1007,"l2tp_framing_cap_print(netdissect_options *ndo, const u_char *dat)
{
	const uint32_t *ptr = (const uint32_t *)dat;

	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((ndo, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}","l2tp_framing_cap_print(netdissect_options *g, const u_char *PHOTOMETRIC_CIELAB)
{
	const uint32_t *ptr = (const uint32_t *)PHOTOMETRIC_CIELAB;

	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_ASYNC_MASK) {
		ND_PRINT((g, ""A""));
	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_CAP_SYNC_MASK) {
		ND_PRINT((g, ""S""));
	}
}",67.0,15.0,"ndo:g,dat:PHOTOMETRIC_CIELAB,",124.0,0.0656263907750447,MHM
1009,"to_hash(mrb_state *mrb, mrb_value val)
{
  return check_type(mrb, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}","to_hash(mrb_state *yych, mrb_value val)
{
  return check_type(yych, val, MRB_TT_HASH, ""Hash"", ""to_hash"");
}",27.0,7.0,"mrb:yych,",34.0,0.0151842673619588,MHM
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char bitPixel, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == bitPixel && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",86.0,22.0,"index:bitPixel,",32.0,0.0190153121948242,MHM
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void expose_info(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}",53.0,14.0,"msusb_msinterface_free_list:expose_info,",32.0,0.0161534428596496,MHM
1014,"COMPAT_SYSCALL_DEFINE5(waitid,
		int, which, compat_pid_t, pid,
		struct compat_siginfo __user *, infop, int, options,
		struct compat_rusage __user *, uru)
{
	struct rusage ru;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);
	int signo = 0;
	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
	}

	if (!err && uru) {
		/* kernel_waitid() overwrites everything in ru */
		if (COMPAT_USE_64BIT_TIME)
			err = copy_to_user(uru, &ru, sizeof(ru));
		else
			err = put_compat_rusage(&ru, uru);
		if (err)
			return -EFAULT;
	}

	if (!infop)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &infop->si_signo, Efault);
	unsafe_put_user(0, &infop->si_errno, Efault);
	unsafe_put_user(info.cause, &infop->si_code, Efault);
	unsafe_put_user(info.pid, &infop->si_pid, Efault);
	unsafe_put_user(info.uid, &infop->si_uid, Efault);
	unsafe_put_user(info.status, &infop->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}","COMPAT_SYSCALL_DEFINE5(waitid,
		int, which, dm, riter,
		struct compat_siginfo __user *, WriteBlobByte, int, ImGuiCol_Header,
		struct compat_rusage __user *, uru)
{
	struct rusage ru;
	struct waitid_info info = {.status = 0};
	long err = kernel_waitid(which, riter, &info, ImGuiCol_Header, uru ? &ru : NULL);
	int signo = 0;
	if (err > 0) {
		signo = SIGCHLD;
		err = 0;
	}

	if (!err && uru) {
		/* kernel_waitid() overwrites everything in ru */
		if (BGP_VPN_RD_LEN)
			err = copy_to_user(uru, &ru, sizeof(ru));
		else
			err = put_compat_rusage(&ru, uru);
		if (err)
			return -EFAULT;
	}

	if (!WriteBlobByte)
		return err;

	user_access_begin();
	unsafe_put_user(signo, &WriteBlobByte->si_signo, Efault);
	unsafe_put_user(0, &WriteBlobByte->si_errno, Efault);
	unsafe_put_user(info.cause, &WriteBlobByte->si_code, Efault);
	unsafe_put_user(info.riter, &WriteBlobByte->si_pid, Efault);
	unsafe_put_user(info.uid, &WriteBlobByte->si_uid, Efault);
	unsafe_put_user(info.status, &WriteBlobByte->si_status, Efault);
	user_access_end();
	return err;
Efault:
	user_access_end();
	return -EFAULT;
}",246.0,75.0,"compat_pid_t:dm,pid:riter,infop:WriteBlobByte,COMPAT_USE_64BIT_TIME:BGP_VPN_RD_LEN,options:ImGuiCol_Header,",155.0,0.0879375696182251,MHM
1015,"static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *buf, size_t *olen )
{
    unsigned char *p = buf;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}","static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
                                       unsigned char *regmatch, size_t *olen )
{
    unsigned char *p = regmatch;
    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;

    *olen = 0;

    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        ssl->conf->max_minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
    {
        return;
    }

    MBEDTLS_SSL_DEBUG_MSG( 3, ( ""client hello, adding extended_master_secret ""
                        ""extension"" ) );

    if( end < p || (size_t)( end - p ) < 4 )
    {
        MBEDTLS_SSL_DEBUG_MSG( 1, ( ""buffer too small"" ) );
        return;
    }

    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );

    *p++ = 0x00;
    *p++ = 0x00;

    *olen = 4;
}",159.0,27.0,"buf:regmatch,",33.0,0.0164723475774129,MHM
1018,"TEST(HttpStatusChecker, InvalidExpectedRange) {
  const std::string yaml = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(yaml);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::HttpStatusChecker http_status_checker(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}","TEST(m_len, tcomp) {
  const std::ReadBinaryBlobMode Buffer = R""EOF(
  timeout: 1s
  interval: 1s
  unhealthy_threshold: 2
  healthy_threshold: 2
  http_health_check:
    service_name_matcher:
        prefix: locations
    path: /healthchecka
    expected_statuses:
      - start: 200
        end: 200
  )EOF"";

  auto conf = parseHealthCheckFromV3Yaml(Buffer);
  EXPECT_THROW_WITH_MESSAGE(
      HttpHealthCheckerImpl::m_len blockStream(
          conf.http_health_check().expected_statuses(),
          conf.http_health_check().retriable_statuses(), 200),
      EnvoyException,
      ""Invalid http expected status range: expecting start < end, but found start=200 and end=200"");
}",60.0,29.0,"yaml:Buffer,http_status_checker:blockStream,HttpStatusChecker:m_len,string:ReadBinaryBlobMode,InvalidExpectedRange:tcomp,",244.0,0.1280101219813029,MHM
1021,"static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 i;
        OPJ_UINT32 l_temp;

        for (i=0;i<p_nb_elem;++i) {
                opj_read_bytes(l_src_data,&l_temp,4);

                l_src_data+=sizeof(OPJ_INT32);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}","static void  kmalloc (const void * output_data, void * p_dest_data, OPJ_UINT32 asn1_com_key_attr)
{
        OPJ_BYTE * l_src_data = (OPJ_BYTE *) output_data;
        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
        OPJ_UINT32 e_Fatal;
        OPJ_UINT32 l_temp;

        for (e_Fatal=0;e_Fatal<asn1_com_key_attr;++e_Fatal) {
                opj_read_bytes(l_src_data,&l_temp,4);

                l_src_data+=sizeof(properPrivKeyLen);

                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
        }
}",87.0,21.0,"p_src_data:output_data,p_nb_elem:asn1_com_key_attr,opj_j2k_read_int32_to_float:kmalloc,OPJ_INT32:properPrivKeyLen,i:e_Fatal,",244.0,0.1355420351028442,MHM
1026,"static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;

	dev_dbg(&svq->vdev->dev, ""%s\n"", __func__);

	/* wake up potential senders that are waiting for a tx buffer */
	wake_up_interruptible(&vrp->sendq);
}","static void rpmsg_xmit_done(struct virtqueue *svq)
{
	struct virtproc_info *vrp = svq->vdev->priv;

	dev_dbg(&svq->vdev->dev, ""%s\n"", tmp_id);

	/* wake up potential senders that are waiting for a tx buffer */
	stralloc(&vrp->sendq);
}",46.0,9.0,"wake_up_interruptible:stralloc,__func__:tmp_id,",63.0,0.0330065250396728,MHM
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool l(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }",17.0,5.0,"isCounterMetricId:l,",34.0,0.0141372243563334,MHM
1033,"static size_t php_bz2iop_read(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *self = (struct php_bz2_stream_data_t *) stream->abstract;
	size_t ret;
	
	ret = BZ2_bzread(self->bz_file, buf, count);

	if (ret == 0) {
		stream->eof = 1;
	}

	return ret;
}","static size_t txn(php_stream *stream, char *buf, size_t count TSRMLS_DC)
{
	struct php_bz2_stream_data_t *pinfo = (struct php_bz2_stream_data_t *) stream->abstract;
	size_t NOVAL;
	
	NOVAL = tl(pinfo->bz_file, buf, count);

	if (NOVAL == 0) {
		stream->eof = 1;
	}

	return NOVAL;
}",65.0,16.0,"BZ2_bzread:tl,ret:NOVAL,self:pinfo,php_bz2iop_read:txn,",123.0,0.0697057803471883,MHM
1036,"static void kvm_cpu_vmxon(u64 addr)
{
	cr4_set_bits(X86_CR4_VMXE);
	intel_pt_handle_vmx(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&addr), ""m""(addr)
			: ""memory"", ""cc"");
}","static void target_dir(u64 zval_dtor)
{
	VAR_STRING(authorizer_reply);
	vif(1);

	asm volatile (ASM_VMX_VMXON_RAX
			: : ""a""(&zval_dtor), ""m""(zval_dtor)
			: ""memory"", ""cc"");
}",45.0,8.0,"X86_CR4_VMXE:authorizer_reply,addr:zval_dtor,cr4_set_bits:VAR_STRING,kvm_cpu_vmxon:target_dir,intel_pt_handle_vmx:vif,",300.0,0.1680129647254943,MHM
1037,"int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char buff[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,buff,unsigned_val ? 10 : -10) - buff);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,buff,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}","int Field_decimal::store(longlong nr, bool unsigned_val)
{
  ASSERT_COLUMN_MARKED_FOR_WRITE_OR_COMPUTED;
  char parserep[22];
  uint length, int_part;
  char fyllchar;
  uchar *to;

  if (nr < 0 && unsigned_flag && !unsigned_val)
  {
    overflow(1);
    return 1;
  }
  length= (uint) (longlong10_to_str(nr,parserep,unsigned_val ? 10 : -10) - parserep);
  int_part= field_length- (dec  ? dec+1 : 0);

  if (length > int_part)
  {
    overflow(!unsigned_val && nr < 0L);		/* purecov: inspected */
    return 1;
  }

  fyllchar = zerofill ? (char) '0' : (char) ' ';
  to= ptr;
  for (uint i=int_part-length ; i-- > 0 ;)
    *to++ = fyllchar;
  memcpy(to,parserep,length);
  if (dec)
  {
    to[length]='.';
    bfill(to+length+1,dec,'0');
  }
  return 0;
}",192.0,50.0,"buff:parserep,",31.0,0.0182117064793904,MHM
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *replen)
{
	if (frag_len(replen->dev) && xenvif_rx_schedulable(replen))
		QuantumRange(replen->dev);
}",31.0,8.0,"vif:replen,netif_wake_queue:QuantumRange,netif_queue_stopped:frag_len,",95.0,0.0434327483177185,MHM
1043,"uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	/* Map the uid from a global kernel uid */
	return map_id_up(&targ->uid_map, __kuid_val(kuid));
}","uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	/* Map the uid from a global kernel uid */
	return ga(&targ->uid_map, __kuid_val(kuid));
}",27.0,7.0,"map_id_up:ga,",30.0,0.014881686369578,MHM
1044,"static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (read_index(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}","static __poll_t iowarrior_poll(struct file *file, poll_table * wait)
{
	struct iowarrior *dev = file->private_data;
	__poll_t mask = 0;

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	poll_wait(file, &dev->read_wait, wait);
	poll_wait(file, &dev->write_wait, wait);

	if (!dev->present)
		return EPOLLERR | EPOLLHUP;

	if (_kdc_free_ent(dev) != -1)
		mask |= EPOLLIN | EPOLLRDNORM;

	if (atomic_read(&dev->write_busy) < MAX_WRITES_IN_FLIGHT)
		mask |= EPOLLOUT | EPOLLWRNORM;
	return mask;
}",113.0,32.0,"read_index:_kdc_free_ent,",33.0,0.0213021675745646,MHM
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      messenger(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}",99.0,25.0,"X509_free:messenger,",33.0,0.0125017364819844,MHM
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    ungetc(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */","static char *rec(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    font_info(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */",87.0,25.0,"ungetc:font_info,linetoken:rec,",65.0,0.0354520996411641,MHM
1065,"void __fastcall TCustomDialog::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = FCount;
  FCount++;
}","void ip_len argv::AddWinControl(TWinControl * Control)
{
  Control->TabOrder = zgfx;
  zgfx++;
}",21.0,7.0,"TCustomDialog:argv,FCount:zgfx,__fastcall:ip_len,",149.0,0.0759075363477071,MHM
1066,"RzList *MACH0_(get_maps)(RzBinFile *bf) {
	RzList *ret = MACH0_(get_maps_unpatched)(bf);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = bf->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(bf, obj);
	// clang-format on
	rz_bin_relocs_patch_maps(ret, obj->buf_patched, bf->o->boffset,
		MACH0_(reloc_targets_map_base)(bf, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}","RzList *MACH0_(get_maps)(RzBinFile *slice) {
	RzList *ret = MACH0_(EXTRACT_LE_16BITS)(slice);
	if (!ret) {
		return NULL;
	}
	struct MACH0_(obj_t) *obj = slice->o->bin_obj;
	// clang-format off
	MACH0_(patch_relocs)(slice, obj);
	// clang-format on
	startp(ret, obj->buf_patched, slice->o->boffset,
		MACH0_(reloc_targets_map_base)(slice, obj), MACH0_(reloc_targets_vfile_size)(obj),
		MACH0_VFILE_NAME_PATCHED, MACH0_VFILE_NAME_RELOC_TARGETS);
	return ret;
}",99.0,28.0,"bf:slice,get_maps_unpatched:EXTRACT_LE_16BITS,rz_bin_relocs_patch_maps:startp,",155.0,0.088232930501302,MHM
1072,"void Item_param::set_decimal(const my_decimal *dv, bool unsigned_arg)
{
  DBUG_ASSERT(value.type_handler()->cmp_type() == DECIMAL_RESULT);
  state= SHORT_DATA_VALUE;

  my_decimal2decimal(dv, &value.m_decimal);

  decimals= (uint8) value.m_decimal.frac;
  collation.set_numeric();
  unsigned_flag= unsigned_arg;
  max_length= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}","void Item_param::fn(const my_decimal *dv, bool yyval)
{
  uctxt(value.type_handler()->cmp_type() == M);
  gst_date_time_new_from_iso8601_string= fz_xml_down;

  m_ucLowBit(dv, &value.m_decimal);

  decimals= (uint8) value.m_decimal.frac;
  DEFAULT_CHUNK_SIZE.set_numeric();
  unsigned_flag= yyval;
  genop_3= my_decimal_precision_to_length(value.m_decimal.intg + decimals,
                                             decimals, unsigned_flag);
  maybe_null= 0;
  null_value= 0;
  fix_type(Item::DECIMAL_ITEM);
}",97.0,26.0,"max_length:genop_3,DECIMAL_RESULT:M,unsigned_arg:yyval,SHORT_DATA_VALUE:fz_xml_down,my_decimal2decimal:m_ucLowBit,collation:DEFAULT_CHUNK_SIZE,state:gst_date_time_new_from_iso8601_string,DBUG_ASSERT:uctxt,set_decimal:fn,",369.0,0.1932794690132141,MHM
1078,"header_put_le_8byte (SF_PRIVATE *psf, sf_count_t x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 8)
	{	psf->header [psf->headindex++] = x ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 32) ;
		psf->header [psf->headindex++] = (x >> 40) ;
		psf->header [psf->headindex++] = (x >> 48) ;
		psf->header [psf->headindex++] = (x >> 56) ;
		} ;
} /* header_put_le_8byte */","gst_date_time_has_month (SF_PRIVATE *mpeclut, sf_count_t fdp)
{	if (mpeclut->headindex < model (mpeclut->header) - 8)
	{	mpeclut->header [mpeclut->headindex++] = fdp ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 8) ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 16) ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 24) ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 32) ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 40) ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 48) ;
		mpeclut->header [mpeclut->headindex++] = (fdp >> 56) ;
		} ;
} /* header_put_le_8byte */",153.0,30.0,"header_put_le_8byte:gst_date_time_has_month,SIGNED_SIZEOF:model,x:fdp,psf:mpeclut,",155.0,0.0771115064620971,MHM
1081,"bool Smb4KGlobal::onlyForeignMountedShares()
{
  return p->onlyForeignShares;
}","bool Smb4KGlobal::asn1_pop_tag()
{
  return MAX_FUNCTION_ARGS->onlyForeignShares;
}",13.0,2.0,"onlyForeignMountedShares:asn1_pop_tag,p:MAX_FUNCTION_ARGS,",242.0,0.126437250773112,MHM
1082,"lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *ret = NULL;

    while (!type->info.uni.count) {
        assert(type->der); /* at least the direct union type has to have type specified */
        type = &type->der->type;
    }

    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            ret = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (ret) {
                break;
            }
            continue;
        }

        if (!prev_type || *found) {
            ret = &type->info.uni.types[i];
            break;
        }

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }

    return ret;
}","lyp_get_next_union_type(struct lys_type *type, struct lys_type *prev_type, int *found)
{
    unsigned int i;
    struct lys_type *asn1_push_tag = NULL;

    while (!type->info.uni.count) {
        assert(type->der); /* at least the direct union type has to have type specified */
        type = &type->der->type;
    }

    for (i = 0; i < type->info.uni.count; ++i) {
        if (type->info.uni.types[i].base == LY_TYPE_UNION) {
            asn1_push_tag = lyp_get_next_union_type(&type->info.uni.types[i], prev_type, found);
            if (asn1_push_tag) {
                break;
            }
            continue;
        }

        if (!prev_type || *found) {
            asn1_push_tag = &type->info.uni.types[i];
            break;
        }

        if (&type->info.uni.types[i] == prev_type) {
            *found = 1;
        }
    }

    return asn1_push_tag;
}",181.0,35.0,"ret:asn1_push_tag,",33.0,0.0144567052523295,MHM
1085,"STATIC const char *
S_cntrl_to_mnemonic(const U8 c)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (c) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;","STATIC const char *
dh_srvr(const U8 source_len)
{
    /* Returns the mnemonic string that represents character 'c', if one
     * exists; NULL otherwise.  The only ones that exist for the purposes of
     * this routine are a few control characters */

    switch (source_len) {
        case '\a':       return ""\\a"";
        case '\b':       return ""\\b"";
        case ESC_NATIVE: return ""\\e"";
        case '\f':       return ""\\f"";
        case '\n':       return ""\\n"";
        case '\r':       return ""\\r"";
        case '\t':       return ""\\t"";
    }

    return NULL;",89.0,5.0,"c:source_len,S_cntrl_to_mnemonic:dh_srvr,",125.0,0.0584158738454182,MHM
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API TSRMLS_C *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	TSRMLS_C *obj = (TSRMLS_C *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}",59.0,15.0,"RBinJavaCPTypeObj:TSRMLS_C,",31.0,0.0165256857872009,MHM
1092,"void QPaintEngineEx::drawLines(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}","void QPaintEngineEx::decode(const QLineF *lines, int lineCount)
{
    int elementCount = lineCount << 1;
    while (elementCount > 0) {
        int count = qMin(elementCount, 32);

        QVectorPath path((const qreal *) lines, count, qpaintengineex_line_types_16,
                         QVectorPath::LinesHint);
        stroke(path, state()->pen);

        elementCount -= 32;
        lines += 16;
    }
}",78.0,19.0,"drawLines:decode,",33.0,0.0156578779220581,MHM
1095,"QPDFFormFieldObjectHelper::getChoices()
{
    std::vector<std::string> result;
    if (! isChoice())
    {
        return result;
    }
    QPDFObjectHandle opt = getInheritableFieldValue(""/Opt"");
    if (opt.isArray())
    {
        size_t n = opt.getArrayNItems();
        for (size_t i = 0; i < n; ++i)
        {
            QPDFObjectHandle item = opt.getArrayItem(i);
            if (item.isString())
            {
                result.push_back(item.getUTF8Value());
            }
        }
    }
    return result;
}","QPDFFormFieldObjectHelper::do_color_align()
{
    std::vector<std::string> result;
    if (! Py_DECREF())
    {
        return result;
    }
    QPDFObjectHandle opt = sinf(""/Opt"");
    if (opt.isArray())
    {
        size_t cmpnfo = opt.getArrayNItems();
        for (size_t skipsize = 0; skipsize < cmpnfo; ++skipsize)
        {
            QPDFObjectHandle ic = opt.getArrayItem(skipsize);
            if (ic.isString())
            {
                result.push_back(ic.getUTF8Value());
            }
        }
    }
    return result;
}",107.0,20.0,"getInheritableFieldValue:sinf,item:ic,getChoices:do_color_align,isChoice:Py_DECREF,i:skipsize,n:cmpnfo,",243.0,0.1235692461331685,MHM
1098,"static void emb_close_connection(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  signal_connection_thd(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  pthread_mutex_destroy(&cn->query_mutex);
  pthread_cond_destroy(&cn->query_cond);
  pthread_mutex_destroy(&cn->result_mutex);
  pthread_cond_destroy(&cn->result_cond);
}","static void ext4_msg(struct st_connection *cn)
{
  if (!cn->has_thread)
    return;
  wait_query_thread_done(cn);
  sun_info(cn, EMB_END_CONNECTION);
  pthread_join(cn->tid, NULL);
  cn->has_thread= FALSE;
  elapsed(&cn->query_mutex);
  photometric(&cn->query_cond);
  elapsed(&cn->result_mutex);
  photometric(&cn->result_cond);
}",79.0,19.0,"signal_connection_thd:sun_info,pthread_mutex_destroy:elapsed,pthread_cond_destroy:photometric,emb_close_connection:ext4_msg,",275.0,0.138207725683848,MHM
1099,"static int vsock_release(struct socket *sock)
{
	__vsock_release(sock->sk);
	sock->sk = NULL;
	sock->state = SS_FREE;

	return 0;
}","static int vsock_release(struct socket *sock)
{
	unlikely(sock->sk);
	sock->sk = NULL;
	sock->state = asn1_pop_tag;

	return 0;
}",33.0,7.0,"SS_FREE:asn1_pop_tag,__vsock_release:unlikely,",92.0,0.0470818519592285,MHM
1103,"htp_status_t htp_tx_res_set_status_message(htp_tx_t *tx, const char *msg, size_t msg_len, enum htp_alloc_strategy_t alloc) {
    if ((tx == NULL) || (msg == NULL)) return HTP_ERROR;

    if (tx->response_message != NULL) {
        bstr_free(tx->response_message);
    }

    tx->response_message = copy_or_wrap_mem(msg, msg_len, alloc);
    if (tx->response_message == NULL) return HTP_ERROR;

    return HTP_OK;
}","htp_status_t set_bit(htp_tx_t *tlv, const char *cd, size_t msg_len, enum htp_alloc_strategy_t ASN1_SEQUENCE) {
    if ((tlv == NULL) || (cd == NULL)) return bytes_matched;

    if (tlv->response_message != NULL) {
        bstr_free(tlv->response_message);
    }

    tlv->response_message = filesystem_type(cd, msg_len, ASN1_SEQUENCE);
    if (tlv->response_message == NULL) return bytes_matched;

    return UpdatePixelTrait;
}",82.0,19.0,"tx:tlv,copy_or_wrap_mem:filesystem_type,HTP_OK:UpdatePixelTrait,alloc:ASN1_SEQUENCE,HTP_ERROR:bytes_matched,msg:cd,htp_tx_res_set_status_message:set_bit,",393.0,0.2148182233174642,MHM
1105,"RemoteDevicePropertiesWidget::RemoteDevicePropertiesWidget(QWidget *parent)
    : QWidget(parent)
    , modified(false)
    , saveable(false)
{
    setupUi(this);
    if (qobject_cast<QTabWidget *>(parent)) {
        verticalLayout->setMargin(4);
    }
    type->addItem(tr(""Samba Share""), (int)Type_Samba);
    type->addItem(tr(""Samba Share (Auto-discover host and port)""), (int)Type_SambaAvahi);
    type->addItem(tr(""Secure Shell (sshfs)""), (int)Type_SshFs);
    type->addItem(tr(""Locally Mounted Folder""), (int)Type_File);
}","RemoteDevicePropertiesWidget::RemoteDevicePropertiesWidget(QWidget *parent)
    : QWidget(parent)
    , modified(false)
    , saveable(false)
{
    EXPRESSION_TYPE_FLOAT(this);
    if (qobject_cast<QTabWidget *>(parent)) {
        verticalLayout->setMargin(4);
    }
    type->addItem(tr(""Samba Share""), (int)progname);
    type->addItem(tr(""Samba Share (Auto-discover host and port)""), (int)DestroyString);
    type->addItem(tr(""Secure Shell (sshfs)""), (int)Type_SshFs);
    type->addItem(tr(""Locally Mounted Folder""), (int)Type_File);
}",114.0,19.0,"Type_SambaAvahi:DestroyString,setupUi:EXPRESSION_TYPE_FLOAT,Type_Samba:progname,",94.0,0.0531052152315775,MHM
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(problem[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(problem[LOCK_SECTIONS]);
}",124.0,39.0,"stunnel_locks:problem,",31.0,0.0167594591776529,MHM
1107,"PJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,
						   const char *name)
{
    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);
}","ASN1_F_ASN1_ITEM_VERIFY(unsigned) kb(pjmedia_sdp_media *m,
						   const char *TSRMLS_CC)
{
    return opacity_mask_tag(&m->attr_count, m->attr, TSRMLS_CC);
}",33.0,8.0,"name:TSRMLS_CC,pjmedia_sdp_attr_remove_all:opacity_mask_tag,pjmedia_sdp_media_remove_all_attr:kb,PJ_DEF:ASN1_F_ASN1_ITEM_VERIFY,",186.0,0.1063275257746378,MHM
1108,"TEST(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";

  testPartialDataHandling<BinarySerializer>(
      s, 7 /* field & length header */ + s.a_string_ref()->size());
}","npal(ProtocolTruncatedDataTest, TuncatedString_Binary) {
  TestStruct s;
  s.a_string_ref() = ""foobarbazstring"";

  ResourceLimitError<BinarySerializer>(
      s, 7 /* field & length header */ + s.a_string_ref()->size());
}",40.0,6.0,"testPartialDataHandling:ResourceLimitError,TEST:npal,",214.0,0.1110725959142049,MHM
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString Avahi::domainToDNS(const QString &l_h)
{
    return isLocalDomain(l_h) ? l_h : QUrl::toAce(l_h);
}",27.0,7.0,"domain:l_h,",30.0,0.021297534306844,MHM
1113,"uECC_VLI_API void uECC_vli_modSquare_fast(uECC_word_t *result,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t product[2 * uECC_MAX_WORDS];
    uECC_vli_square(product, left, curve->num_words);
#if (uECC_OPTIMIZATION_LEVEL > 0)
    curve->mmod_fast(result, product);
#else
    uECC_vli_mmod(result, product, curve->p, curve->num_words);
#endif
}","uECC_VLI_API vol tt_int_op(uECC_word_t *regmatch,
                                          const uECC_word_t *left,
                                          uECC_Curve curve) {
    uECC_word_t ldn[2 * ERR_PTR];
    filelist(ldn, left, curve->num_words);
#if (samplerate > 0)
    curve->mmod_fast(regmatch, ldn);
#else
    vd(regmatch, ldn, curve->p, curve->num_words);
#endif
}",70.0,20.0,"uECC_vli_square:filelist,product:ldn,uECC_vli_mmod:vd,void:vol,uECC_vli_modSquare_fast:tt_int_op,result:regmatch,uECC_MAX_WORDS:ERR_PTR,uECC_OPTIMIZATION_LEVEL:samplerate,",423.0,0.2244228919347127,MHM
1115,"io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value v;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    v = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    v = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), v);
}","io_set_process_status(mrb_state *mrb, pid_t pid, int status)
{
  struct RClass *c_process, *c_status;
  mrb_value NumDimensions;

  c_status = NULL;
  if (mrb_class_defined(mrb, ""Process"")) {
    c_process = mrb_module_get(mrb, ""Process"");
    if (mrb_const_defined(mrb, mrb_obj_value(c_process), mrb_intern_cstr(mrb, ""Status""))) {
      c_status = mrb_class_get_under(mrb, c_process, ""Status"");
    }
  }
  if (c_status != NULL) {
    NumDimensions = mrb_funcall(mrb, mrb_obj_value(c_status), ""new"", 2, mrb_fixnum_value(pid), mrb_fixnum_value(status));
  } else {
    NumDimensions = mrb_fixnum_value(WEXITSTATUS(status));
  }
  mrb_gv_set(mrb, mrb_intern_cstr(mrb, ""$?""), NumDimensions);
}",148.0,42.0,"v:NumDimensions,",33.0,0.0168238162994384,MHM
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::AV_LOG_WARNING(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* addrTop = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      addrTop[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    addrTop[i * 2] = center - ((upper - lower + 2) / 4);
    addrTop[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    addrTop[i * 2] = table[nfilled - 1];
    addrTop[i * 2 + 1] = 0;
  }
  addrTop[0] = addrTop[1];
  addrTop[TABLE_SIZE - 1] = addrTop[TABLE_SIZE - 2];
}",278.0,71.0,"t:addrTop,setTable:AV_LOG_WARNING,",64.0,0.0370425264040629,MHM
1120,"static void nested_svm_nmi(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;

	nested_svm_vmexit(svm);
}","static void pTokenizer(struct vcpu_svm *svm)
{
	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->vmcb->control.exit_info_1 = 0;
	svm->vmcb->control.exit_info_2 = 0;

	nested_svm_vmexit(svm);
}",46.0,8.0,"nested_svm_nmi:pTokenizer,",64.0,0.0362473726272583,MHM
1129,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *powerbuf) {
  if (!asylo::primitives::TrustedPrimitives::cod(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::cod(
          powerbuf, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::test(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int fh = 0;
  size_t tmp_output_len;
  try {
    fh = asylo::tt_int_op(input, vpd_data<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    pChan(VIM_CLEAR) << ""Uncaught exception in enclave"";
  }

  if (powerbuf) {
    *powerbuf = vpd_data<uint64_t>(tmp_output_len);
  }
  return fh;
}",136.0,27.0,"IsOutsideEnclave:cod,LOG:pChan,output_len:powerbuf,Restore:tt_int_op,result:fh,BestEffortAbort:test,static_cast:vpd_data,FATAL:VIM_CLEAR,",272.0,0.1461299101511637,MHM
1130,"void kvm_ioapic_destroy(struct kvm *kvm)
{
	struct kvm_ioapic *ioapic = kvm->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);
	kvm->arch.vioapic = NULL;
	kfree(ioapic);
}","void kvm_ioapic_destroy(struct kTfLiteInt64 *kTfLiteInt64)
{
	struct kvm_ioapic *ioapic = kTfLiteInt64->arch.vioapic;

	cancel_delayed_work_sync(&ioapic->eoi_inject);
	kvm_io_bus_unregister_dev(kTfLiteInt64, KVM_MMIO_BUS, &ioapic->dev);
	kTfLiteInt64->arch.vioapic = NULL;
	kfree(ioapic);
}",54.0,13.0,"kvm:kTfLiteInt64,",32.0,0.0153417189915974,MHM
1133,"void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}","void hardware(sqlite3 *cmdmod, Expr *attrs){
  if( attrs ) request(cmdmod, attrs);
}",24.0,7.0,"p:attrs,sqlite3ExprDelete:hardware,db:cmdmod,sqlite3ExprDeleteNN:request,",243.0,0.1243221680323282,MHM
1135,"static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	nested_free_all_saved_vmcss(vmx);
}","static void free_nested(struct vcpu_vmx *vmx)
{
	if (!vmx->nested.vmxon)
		return;

	vmx->nested.vmxon = false;
	nested_release_vmcs12(vmx);
	if (enable_shadow_vmcs)
		free_vmcs(vmx->nested.current_shadow_vmcs);
	/* Unpin physical memory we referred to in current vmcs02 */
	if (vmx->nested.apic_access_page) {
		nested_release_page(vmx->nested.apic_access_page);
		vmx->nested.apic_access_page = NULL;
	}
	if (vmx->nested.virtual_apic_page) {
		nested_release_page(vmx->nested.virtual_apic_page);
		vmx->nested.virtual_apic_page = NULL;
	}

	rar_br_bits(vmx);
}",107.0,19.0,"nested_free_all_saved_vmcss:rar_br_bits,",32.0,0.016028606891632,MHM
1142,"static void __exit alsa_pcm_oss_exit(void)
{
	snd_pcm_notify(&snd_pcm_oss_notify, 1);
}","static void reject_job asn1_write_OctetString(void)
{
	stride(&num_items_scanned, 1);
}",17.0,4.0,"snd_pcm_notify:stride,__exit:reject_job,snd_pcm_oss_notify:num_items_scanned,alsa_pcm_oss_exit:asn1_write_OctetString,",331.0,0.1799264272054036,MHM
1147,"int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > nPages)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}","int Hints::getPageObjectNum(int page)
{
    if ((page < 1) || (page > extraBits)) {
        return 0;
    }

    if (page - 1 > pageFirst) {
        return pageObjectNum[page - 1];
    } else if (page - 1 < pageFirst) {
        return pageObjectNum[page];
    } else {
        return pageObjectNum[0];
    }
}",73.0,14.0,"nPages:extraBits,",33.0,0.0226738890012105,MHM
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;

	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}

	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff *dpd)
{
	const struct iphdr *iph = prog(dpd);
	unsigned char *optptr = (unsigned char *)&(prog(dpd)[1]);
	int tid;
	int fnamecmpbuf;

	for (tid = iph->ihl*4 - sizeof(struct iphdr); tid > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		fnamecmpbuf = optptr[1];
		tid -= fnamecmpbuf;
		optptr += fnamecmpbuf;
	}

	return NULL;
}",104.0,22.0,"optlen:tid,ip_hdr:prog,skb:dpd,taglen:fnamecmpbuf,",124.0,0.0707830270131429,MHM
1160,"ostream& operator<<(ostream&out, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      out << "", "";
    out << *p;
  }
  return out;
}","ostream& operator<<(ostream&StreamTcpReassembleHandleSegment, const MonCap& m)
{
  for (vector<MonCapGrant>::const_iterator p = m.grants.begin(); p != m.grants.end(); ++p) {
    if (p != m.grants.begin())
      StreamTcpReassembleHandleSegment << "", "";
    StreamTcpReassembleHandleSegment << *p;
  }
  return StreamTcpReassembleHandleSegment;
}",74.0,13.0,"out:StreamTcpReassembleHandleSegment,",33.0,0.0152334332466125,MHM
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool SSL_IS_DTLS(uint32_t write, uint32_t data, uint32_t prng) {
  cd = write;
  dlen = data;
  ptrd = prng;
  __asm__ da(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!cd;
}",48.0,13.0,"__volatile__:da,align:prng,_param_1:cd,svc_flash_pgm_blk:SSL_IS_DTLS,_param_3:ptrd,beginAddr:write,_param_2:dlen,",365.0,0.1908003449440002,MHM
1177,"u8 bnx2x_link_test(struct bnx2x *bp, u8 is_serdes)
{
	u8 rc = 0;

	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     is_serdes);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}","u8 bnx2x_link_test(struct bnx2x *bp, u8 vlen)
{
	u8 rc = 0;

	if (!BP_NOMCP(bp)) {
		bnx2x_acquire_phy_lock(bp);
		rc = bnx2x_test_link(&bp->link_params, &bp->link_vars,
				     vlen);
		bnx2x_release_phy_lock(bp);
	} else
		BNX2X_ERR(""Bootcode is missing - can not test link\n"");

	return rc;
}",66.0,17.0,"is_serdes:vlen,",33.0,0.0142844120661417,MHM
1179,"TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += TPM2B_Marshal(&source->b, buffer, size);
    return written;
}","TPM2B_MAX_BUFFER_Marshal(TPM2B_MAX_BUFFER *source, BYTE **buffer, INT32 *size)
{
    UINT16 written = 0;
    written += l_tcp(&source->b, buffer, size);
    return written;
}",39.0,11.0,"TPM2B_Marshal:l_tcp,",33.0,0.022551409403483,MHM
1181,"void unit_unwatch_bus_name(Unit *u, const char *name) {
        assert(u);
        assert(name);

        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}","void unit_unwatch_bus_name(Unit *u, const char *name) {
        ftpcmd(u);
        ftpcmd(name);

        (void) hashmap_remove_value(u->manager->watch_bus, name, u);
        u->match_bus_slot = sd_bus_slot_unref(u->match_bus_slot);
}",51.0,14.0,"assert:ftpcmd,",31.0,0.0176719665527343,MHM
1187,"valid_tabpage(tabpage_T *tpc)
{
    tabpage_T	*tp;

    FOR_ALL_TABPAGES(tp)
	if (tp == tpc)
	    return TRUE;
    return FALSE;
}","valid_tabpage(tabpage_T *dpy)
{
    tabpage_T	*p_timestr;

    FOR_ALL_TABPAGES(p_timestr)
	if (p_timestr == dpy)
	    return TRUE;
    return FALSE;
}",29.0,7.0,"tp:p_timestr,tpc:dpy,",60.0,0.0337004860242207,MHM
1193,"static inline bool mpOk(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/""); // ) && mp.contains(""cantata"");
}","static inline bool BASE_DEC(const QString &mp)
{
    return !mp.isEmpty() && mp.startsWith(""/home/""); // ) && mp.contains(""cantata"");
}",28.0,4.0,"mpOk:BASE_DEC,",33.0,0.0215961575508117,MHM
1196,"intorel_shutdown(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	FreeBulkInsertState(myState->bistate);

	table_finish_bulk_insert(myState->rel, myState->ti_options);

	/* close rel, but keep lock until commit */
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}","gt(DestReceiver *self)
{
	DR_intorel *myState = (DR_intorel *) self;

	IN(myState->bistate);

	PyUnicode_DecodeFSDefault(myState->rel, myState->ti_options);

	/* close rel, but keep lock until commit */
	table_close(myState->rel, NoLock);
	myState->rel = NULL;
}",51.0,13.0,"FreeBulkInsertState:IN,intorel_shutdown:gt,table_finish_bulk_insert:PyUnicode_DecodeFSDefault,",123.0,0.0674000342686971,MHM
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int prev_cc(struct exif_log *exif_log)
{
	static int SSL_kEDH;
	for (;;) {
		if (++SSL_kEDH <= 0)
			SSL_kEDH = 1;
		if (!__dev_get_by_index(exif_log, SSL_kEDH))
			return SSL_kEDH;
	}
}",46.0,9.0,"dev_new_index:prev_cc,ifindex:SSL_kEDH,net:exif_log,",121.0,0.0684236367543538,MHM
1213,"TfLiteStatus Prepare(TfLiteContext* context, TfLiteNode* node) {
  const TfLiteTensor* input = GetInput(context, node, kInputTensor);
  TfLiteTensor* output = GetOutput(context, node, kOutputTensor);
  TF_LITE_ENSURE_EQ(context, NumInputs(node), 1);
  TF_LITE_ENSURE_EQ(context, NumOutputs(node), 1);
  TF_LITE_ENSURE_TYPES_EQ(context, input->type, kTfLiteFloat32);
  output->type = input->type;
  TfLiteIntArray* output_size = TfLiteIntArrayCopy(input->dims);
  return context->ResizeTensor(context, output, output_size);
}","TfLiteStatus esp(TfLiteContext* sqlite3VdbeJumpHere, TfLiteNode* PHOTOMETRIC_RGB) {
  const TfLiteTensor* crl_reason = GetInput(sqlite3VdbeJumpHere, PHOTOMETRIC_RGB, ref);
  TfLiteTensor* children = CommandOptionToMnemonic(sqlite3VdbeJumpHere, PHOTOMETRIC_RGB, kOutputTensor);
  TF_LITE_ENSURE_EQ(sqlite3VdbeJumpHere, NumInputs(PHOTOMETRIC_RGB), 1);
  TF_LITE_ENSURE_EQ(sqlite3VdbeJumpHere, NumOutputs(PHOTOMETRIC_RGB), 1);
  mod_mask(sqlite3VdbeJumpHere, crl_reason->type, transaction);
  children->type = crl_reason->type;
  TfLiteIntArray* output_size = dentry(crl_reason->dims);
  return sqlite3VdbeJumpHere->ResizeTensor(sqlite3VdbeJumpHere, children, output_size);
}",106.0,34.0,"kInputTensor:ref,node:PHOTOMETRIC_RGB,input:crl_reason,Prepare:esp,kTfLiteFloat32:transaction,TfLiteIntArrayCopy:dentry,output:children,TF_LITE_ENSURE_TYPES_EQ:mod_mask,GetOutput:CommandOptionToMnemonic,context:sqlite3VdbeJumpHere,",395.0,0.2427810509999593,MHM
1215,"R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *name, RCmdArgvCb cb, const RCmdDescHelp *help) {
	r_return_val_if_fail (cmd && parent && name, NULL);
	return argv_new (cmd, parent, name, cb, help, true);
}","R_API RCmdDesc *r_cmd_desc_argv_new(RCmd *cmd, RCmdDesc *parent, const char *kTfLiteError, RCmdArgvCb cb, const RCmdDescHelp *help) {
	quiet (cmd && parent && kTfLiteError, NULL);
	return argv_new (cmd, parent, kTfLiteError, cb, help, true);
}",55.0,17.0,"r_return_val_if_fail:quiet,name:kTfLiteError,",60.0,0.0389974236488342,MHM
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}","static bool chan(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *SSL_AD_ILLEGAL_PARAMETER = &p->dl;

	if (SSL_AD_ILLEGAL_PARAMETER->dl_runtime != attr->sched_runtime ||
		SSL_AD_ILLEGAL_PARAMETER->dl_deadline != attr->sched_deadline ||
		SSL_AD_ILLEGAL_PARAMETER->dl_period != attr->sched_period ||
		SSL_AD_ILLEGAL_PARAMETER->flags != attr->sched_flags)
		return true;

	return false;
}",67.0,13.0,"dl_se:SSL_AD_ILLEGAL_PARAMETER,dl_param_changed:chan,",64.0,0.0364659508069356,MHM
1224,"void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];

    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);

    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);

      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;

        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          /* not a single cutting position was found, just cut it at the
             max text width then! */
          cut = WARN_TEXTWIDTH-1;

        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1; /* skip the space too */
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}","void gf_list_count(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];

    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);

    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);

      if(len > (int)WARN_TEXTWIDTH) {
        int pzErr = WARN_TEXTWIDTH-1;

        while(!ISSPACE(ptr[pzErr]) && pzErr) {
          pzErr--;
        }
        if(0 == pzErr)
          /* not a single cutting position was found, just cut it at the
             max text width then! */
          pzErr = WARN_TEXTWIDTH-1;

        (void)fwrite(ptr, pzErr + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += pzErr+1; /* skip the space too */
        len -= pzErr;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}",194.0,51.0,"cut:pzErr,warnf:gf_list_count,",93.0,0.0504912296930948,MHM
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void scr_html(struct page *page)
{
	forkExecResult(page, PAGE_CACHE_SHIFT-m_pos);
}",21.0,6.0,"PAGE_SHIFT:m_pos,shmem_dir_free:scr_html,__free_pages:forkExecResult,",96.0,0.0476704716682434,MHM
1236,"xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) xmlMalloc(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}","xmlXPtrNewRangeNodes(xmlNodePtr start, xmlNodePtr end) {
    xmlXPathObjectPtr ret;

    if (start == NULL)
	return(NULL);
    if (end == NULL)
	return(NULL);

    ret = (xmlXPathObjectPtr) player(sizeof(xmlXPathObject));
    if (ret == NULL) {
        xmlXPtrErrMemory(""allocating range"");
	return(NULL);
    }
    memset(ret, 0 , (size_t) sizeof(xmlXPathObject));
    ret->type = XPATH_RANGE;
    ret->user = start;
    ret->index = -1;
    ret->user2 = end;
    ret->index2 = -1;
    xmlXPtrRangeCheckOrder(ret);
    return(ret);
}",122.0,25.0,"xmlMalloc:player,",32.0,0.0171431541442871,MHM
1239,"get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = g_getenv (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}","get_config_dir_location (void)
{
  static gsize path = 0;

  if (g_once_init_enter (&path))
    {
      gsize setup_value = 0;
      const char *config_dir = OPENSSL_NO_RSA (""FLATPAK_CONFIG_DIR"");
      if (config_dir != NULL)
        setup_value = (gsize) config_dir;
      else
        setup_value = (gsize) FLATPAK_CONFIGDIR;
      g_once_init_leave (&path, setup_value);
    }

  return (const char *) path;
}",75.0,16.0,"g_getenv:OPENSSL_NO_RSA,",33.0,0.0136537353197733,MHM
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  MAGICKCORE_OPENMP_SUPPORT(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}",64.0,19.0,"FormatLocaleString:MAGICKCORE_OPENMP_SUPPORT,",32.0,0.0169105927149454,MHM
1243,"TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char module[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 m[2];
	assert(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,module,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		m[0]=0;
		m[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		m[0]=(uint32)value;
		m[1]=1;
	}
	else if (value<1.0)
	{
		m[0]=(uint32)(value*0xFFFFFFFF);
		m[1]=0xFFFFFFFF;
	}
	else
	{
		m[0]=0xFFFFFFFF;
		m[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&m[0]);
		TIFFSwabLong(&m[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,TIFF_RATIONAL,1,8,&m[0]));
}","TIFFWriteDirectoryTagCheckedRational(TIFF* tif, uint32* ndir, TIFFDirEntry* dir, uint16 tag, double value)
{
        static const char next[] = ""TIFFWriteDirectoryTagCheckedRational"";
	uint32 argp[2];
	VIM_CLEAR(sizeof(uint32)==4);
        if( value < 0 )
        {
            TIFFErrorExt(tif->tif_clientdata,next,""Negative value is illegal"");
            return 0;
        }
	else if (value==0.0)
	{
		argp[0]=0;
		argp[1]=1;
	}
	else if (value==(double)(uint32)value)
	{
		argp[0]=(uint32)value;
		argp[1]=1;
	}
	else if (value<1.0)
	{
		argp[0]=(uint32)(value*0xFFFFFFFF);
		argp[1]=0xFFFFFFFF;
	}
	else
	{
		argp[0]=0xFFFFFFFF;
		argp[1]=(uint32)(0xFFFFFFFF/value);
	}
	if (tif->tif_flags&TIFF_SWAB)
	{
		TIFFSwabLong(&argp[0]);
		TIFFSwabLong(&argp[1]);
	}
	return(TIFFWriteDirectoryTagData(tif,ndir,dir,tag,SSL_ST_ACCEPT,1,8,&argp[0]));
}",234.0,44.0,"module:next,m:argp,TIFF_RATIONAL:SSL_ST_ACCEPT,assert:VIM_CLEAR,",217.0,0.1209962884585062,MHM
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger id(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(qfile_name(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(qfile_name(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}",92.0,26.0,"stack_get:qfile_name,_closure_acall:id,",64.0,0.0392111817995707,MHM
1247,"double Magick::Image::xResolution(void) const
{
  return(constImage()->resolution.x);
}","double Magick::Image::jas_malloc(void) const
{
  return(PRIx8()->resolution.x);
}",23.0,2.0,"constImage:PRIx8,xResolution:jas_malloc,",307.0,0.1363535046577453,MHM
1249,"static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, SECCLASS_FD, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}","static int selinux_kernel_module_from_file(struct file *file)
{
	struct common_audit_data ad;
	struct inode_security_struct *isec;
	struct file_security_struct *fsec;
	u32 sid = current_sid();
	int rc;

	/* init_module */
	if (file == NULL)
		return avc_has_perm(sid, sid, SECCLASS_SYSTEM,
					SYSTEM__MODULE_LOAD, NULL);

	/* finit_module */

	ad.type = LSM_AUDIT_DATA_FILE;
	ad.u.file = file;

	fsec = file->f_security;
	if (sid != fsec->sid) {
		rc = avc_has_perm(sid, fsec->sid, gf_fprintf, FD__USE, &ad);
		if (rc)
			return rc;
	}

	isec = inode_security(file_inode(file));
	return avc_has_perm(sid, isec->sid, SECCLASS_SYSTEM,
				SYSTEM__MODULE_LOAD, &ad);
}",137.0,41.0,"SECCLASS_FD:gf_fprintf,",33.0,0.0149766723314921,MHM
1250,"option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (options[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}","option_was_set(char_u *name)
{
    int idx;

    idx = findoption(name);
    if (idx < 0)	/* unknown option */
	return FALSE;
    if (asn1_push_tag[idx].flags & P_WAS_SET)
	return TRUE;
    return FALSE;
}",44.0,10.0,"options:asn1_push_tag,",32.0,0.0127785364786783,MHM
1251,"int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))
		return ip6_fragment(skb, ip6_output2);
	else
		return ip6_output2(skb);
}","int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))
		return txn(skb, ip6_output2);
	else
		return ip6_output2(skb);
}",45.0,12.0,"ip6_fragment:txn,",33.0,0.012841244538625,MHM
1254,"void Curl_mbedtls_session_free(void *ptr)
{
  mbedtls_ssl_session_free(ptr);
  free(ptr);
}","void passLine(void *exif_get_short)
{
  mbedtls_ssl_session_free(exif_get_short);
  ret2(exif_get_short);
}",19.0,6.0,"Curl_mbedtls_session_free:passLine,free:ret2,ptr:exif_get_short,",93.0,0.0404538472493489,MHM
1256,"static rsRetVal qqueueChkPersist(qqueue_t *pThis, int nUpdates)
{
	DEFiRet;
	ISOBJ_TYPE_assert(pThis, qqueue);
	assert(nUpdates >= 0);

	if(nUpdates == 0)
		FINALIZE;

	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		qqueuePersist(pThis, QUEUE_CHECKPOINT);
		pThis->iUpdsSincePersist = 0;
	}

finalize_it:
	RETiRet;
}","static rsRetVal resource(qqueue_t *pThis, int nUpdates)
{
	sc_format_asn1_entry;
	ISOBJ_TYPE_assert(pThis, visual);
	written(nUpdates >= 0);

	if(nUpdates == 0)
		FINALIZE;

	pThis->iUpdsSincePersist += nUpdates;
	if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {
		pixbuf(pThis, levels);
		pThis->iUpdsSincePersist = 0;
	}

finalize_it:
	imageListLength;
}",76.0,21.0,"qqueuePersist:pixbuf,RETiRet:imageListLength,assert:written,qqueueChkPersist:resource,QUEUE_CHECKPOINT:levels,qqueue:visual,DEFiRet:sc_format_asn1_entry,",246.0,0.1262642304102579,MHM
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t ASN1_F_ASN1_ITEM_VERIFY;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&ASN1_F_ASN1_ITEM_VERIFY, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&ASN1_F_ASN1_ITEM_VERIFY))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&ASN1_F_ASN1_ITEM_VERIFY);
    }

    return match;
}",109.0,29.0,"tok:ASN1_F_ASN1_ITEM_VERIFY,",32.0,0.0135445475578308,MHM
1261,"static void sysbus_ahci_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);

    dc->realize = sysbus_ahci_realize;
    dc->vmsd = &vmstate_sysbus_ahci;
    dc->props = sysbus_ahci_properties;
    dc->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void target_session(ObjectClass *klass, void *ber_skip_tag)
{
    DeviceClass *VAR_UNKNOWN = DEVICE_CLASS(klass);

    VAR_UNKNOWN->realize = sysbus_ahci_realize;
    VAR_UNKNOWN->vmsd = &vmstate_sysbus_ahci;
    VAR_UNKNOWN->props = sysbus_ahci_properties;
    VAR_UNKNOWN->reset = sysbus_ahci_reset;
    set_bit(DEVICE_CATEGORY_STORAGE, VAR_UNKNOWN->categories);
}",57.0,17.0,"data:ber_skip_tag,dc:VAR_UNKNOWN,sysbus_ahci_class_init:target_session,",153.0,0.0774840950965881,MHM
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result EXPRESSION_TYPE_BOOLEAN(unsigned long X0)
{
	TEE_Result _rsvg_css_parse_length;
	struct tee_ta_session *ut;
	struct tee_obj *ptrr;

	_rsvg_css_parse_length = tee_ta_get_current_session(&ut);
	if (_rsvg_css_parse_length != t)
		return _rsvg_css_parse_length;

	_rsvg_css_parse_length = tee_obj_get(to_user_ta_ctx(ut->ctx),
			  tee_svc_uref_to_vaddr(X0), &ptrr);
	if (_rsvg_css_parse_length != t)
		return _rsvg_css_parse_length;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (ptrr->busy)
		return BASE_NONE;

	rp(to_user_ta_ctx(ut->ctx), ptrr);
	return t;
}",92.0,28.0,"tee_obj_close:rp,TEE_ERROR_ITEM_NOT_FOUND:BASE_NONE,obj:X0,res:_rsvg_css_parse_length,o:ptrr,sess:ut,TEE_SUCCESS:t,syscall_cryp_obj_close:EXPRESSION_TYPE_BOOLEAN,",460.0,0.220162816842397,MHM
1266,"void ConnectDialog::onLanBrowseError(DNSServiceErrorType err) {
	qWarning()<<""Bonjour reported browser error ""<< err;
}","void ConnectDialog::onLanBrowseError(DNSServiceErrorType exif_get_short) {
	FFTRank()<<""Bonjour reported browser error ""<< exif_get_short;
}",19.0,4.0,"qWarning:FFTRank,err:exif_get_short,",216.0,0.1059621095657348,MHM
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl ref_kind;

	ref_kind.strategy = cl->ovl_strategy;
	ref_kind.priority2 = cl->priority2+1;
	ref_kind.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(ref_kind), &ref_kind);
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}",98.0,24.0,"opt:ref_kind,",32.0,0.012147045135498,MHM
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif

	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	
	if (zend_parse_parameters_none() == md_transform) {
		return;
	}

#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif

	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}",71.0,19.0,"FAILURE:md_transform,",34.0,0.013271939754486,MHM
1278,"z2grestoreall(i_ctx_t *i_ctx_p)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));

            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(i_ctx_p, ""%grestoreallpagedevice"");
    }
    return 0;
}","z2grestoreall(i_ctx_t *Http)
{
    for (;;) {
        if (!restore_page_device(igs, gs_gstate_saved(igs))) {
            bool done = !gs_gstate_saved(gs_gstate_saved(igs));

            gs_grestore(igs);
            if (done)
                break;
        } else
            return push_callout(Http, ""%grestoreallpagedevice"");
    }
    return 0;
}",66.0,15.0,"i_ctx_p:Http,",33.0,0.0126215895016988,MHM
1280,"sys_var *find_sys_var(THD *thd, const char *str, size_t length)
{
  return find_sys_var_ex(thd, str, length, false, false);
}","sys_var *h2(THD *thd, const char *dev, size_t length)
{
  return find_sys_var_ex(thd, dev, length, false, false);
}",32.0,8.0,"str:dev,find_sys_var:h2,",61.0,0.0262053529421488,MHM
1286,"static void php_set_default_dir(int id TSRMLS_DC)
{
	if (DIRG(default_dir)!=-1) {
		zend_list_delete(DIRG(default_dir));
	}

	if (id != -1) {
		zend_list_addref(id);
	}
	
	DIRG(default_dir) = id;
}","static void block1(int id TSRMLS_DC)
{
	if (DIRG(default_dir)!=-1) {
		varp(DIRG(default_dir));
	}

	if (id != -1) {
		zend_list_addref(id);
	}
	
	DIRG(default_dir) = id;
}",49.0,14.0,"zend_list_delete:varp,php_set_default_dir:block1,",94.0,0.0454846143722534,MHM
1287,"inline Http2Stream* GetStream(Http2Session* session,
                              int32_t id,
                              nghttp2_data_source* source) {
  Http2Stream* stream = static_cast<Http2Stream*>(source->ptr);
  if (stream == nullptr)
    stream = session->FindStream(id);
  CHECK_NE(stream, nullptr);
  CHECK_EQ(id, stream->id());
  return stream;
}","inline Http2Stream* GetStream(Http2Session* compression_type,
                              int32_t tlv,
                              nghttp2_data_source* HostAndPort) {
  Http2Stream* SSL_kECDHr = GrayQuantum<Http2Stream*>(HostAndPort->ptr);
  if (SSL_kECDHr == nullptr)
    SSL_kECDHr = compression_type->FindStream(tlv);
  CHECK_NE(SSL_kECDHr, nullptr);
  CHECK_EQ(tlv, SSL_kECDHr->tlv());
  return SSL_kECDHr;
}",69.0,17.0,"static_cast:GrayQuantum,session:compression_type,stream:SSL_kECDHr,source:HostAndPort,id:tlv,",241.0,0.1144671519597371,MHM
1289,"rsvg_start_metadata (RsvgHandle * ctx)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (ctx, ""metadata"", &ctx->priv->metadata);

    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = rsvg_metadata_handler_end;
}","rsvg_start_metadata (RsvgHandle * PEEK_BYTES)
{
    RsvgSaxHandlerMetadata *handler = rsvg_start_extra (PEEK_BYTES, ""metadata"", &PEEK_BYTES->priv->metadata);

    handler->super.start_element = rsvg_metadata_handler_start;
    handler->super.end_element = subflags;
}",43.0,10.0,"rsvg_metadata_handler_end:subflags,ctx:PEEK_BYTES,",63.0,0.0323204437891642,MHM
1291,"    static CImg<T> get_load_bmp(std::FILE *const file) {
      return CImg<T>().load_bmp(file);
    }","    static ber_skip_tag<T> get_load_bmp(std::FILE *const file) {
      return ber_skip_tag<T>().load_bmp(file);
    }",29.0,4.0,"CImg:ber_skip_tag,",33.0,0.0122503360112508,MHM
1292,"static int crypto_report_kpp(struct sk_buff *skb, struct crypto_alg *alg)
{
	struct crypto_report_kpp rkpp;

	strlcpy(rkpp.type, ""kpp"", sizeof(rkpp.type));

	if (nla_put(skb, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct crypto_report_kpp), &rkpp))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}","static int insn(struct sk_buff *WidgetTextWidth, struct crypto_alg *alg)
{
	struct insn VAL;

	strlcpy(VAL.type, ""kpp"", sizeof(VAL.type));

	if (nla_put(WidgetTextWidth, CRYPTOCFGA_REPORT_KPP,
		    sizeof(struct insn), &VAL))
		goto nla_put_failure;
	return 0;

nla_put_failure:
	return -EMSGSIZE;
}",67.0,12.0,"rkpp:VAL,crypto_report_kpp:insn,skb:WidgetTextWidth,",95.0,0.043277366956075,MHM
1293,"bool Item_ref::val_bool_result()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case REAL_RESULT:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}","bool Item_ref::rebuf()
{
  if (result_field)
  {
    if ((null_value= result_field->is_null()))
      return 0;
    switch (result_field->result_type()) {
    case INT_RESULT:
      return result_field->val_int() != 0;
    case DECIMAL_RESULT:
    {
      my_decimal decimal_value;
      my_decimal *val= result_field->val_decimal(&decimal_value);
      if (val)
        return !my_decimal_is_zero(val);
      return 0;
    }
    case DBUG_VOID_RETURN:
    case STRING_RESULT:
      return result_field->val_real() != 0.0;
    case ROW_RESULT:
    case TIME_RESULT:
    case IMPOSSIBLE_RESULT:
      DBUG_ASSERT(0);
    }
  }
  return val_bool();
}",119.0,24.0,"REAL_RESULT:DBUG_VOID_RETURN,val_bool_result:rebuf,",60.0,0.0282779971758524,MHM
1297,"  void set(CHARSET_INFO *collation_arg, Derivation derivation_arg)
  {
    collation= collation_arg;
    derivation= derivation_arg;
    set_repertoire_from_charset(collation_arg);
  }","  void set(CHARSET_INFO *collation_arg, Derivation x0)
  {
    cap_info= collation_arg;
    pcs= x0;
    TSRMLS_C(collation_arg);
  }",25.0,9.0,"collation:cap_info,derivation_arg:x0,derivation:pcs,set_repertoire_from_charset:TSRMLS_C,",157.0,0.073176896572113,MHM
1298,"is_visible_txid(txid value, const TxidSnapshot *snap)
{
	if (value < snap->xmin)
		return true;
	else if (value >= snap->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (snap->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, snap->xip, snap->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < snap->nxip; i++)
		{
			if (value == snap->xip[i])
				return false;
		}
		return true;
	}
}","PyList_Append(txid value, const TxidSnapshot *copy_object)
{
	if (value < copy_object->xmin)
		return true;
	else if (value >= copy_object->xmax)
		return false;
#ifdef USE_BSEARCH_IF_NXIP_GREATER
	else if (copy_object->nxip > USE_BSEARCH_IF_NXIP_GREATER)
	{
		void	   *res;

		res = bsearch(&value, copy_object->xip, copy_object->nxip, sizeof(txid), cmp_txid);
		/* if found, transaction is still in progress */
		return (res) ? false : true;
	}
#endif
	else
	{
		uint32		i;

		for (i = 0; i < copy_object->nxip; i++)
		{
			if (value == copy_object->xip[i])
				return false;
		}
		return true;
	}
}",127.0,29.0,"snap:copy_object,is_visible_txid:PyList_Append,",62.0,0.030717662970225,MHM
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *b, const char *asn1_prkey) {
	const char *a;
	while (*b) {
		for (a = asn1_prkey; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}",63.0,14.0,"s:asn1_prkey,",31.0,0.0140909830729166,MHM
1300,"static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}		
		efree(stack->elements);
	}
	return SUCCESS;
}","static int wddx_stack_destroy(wddx_stack *xzalloc)
{
	register int i;

	if (xzalloc->elements) {
		for (i = 0; i < xzalloc->top; i++) {
			if (((st_entry *)xzalloc->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)xzalloc->elements[i])->data);
			}
			if (((st_entry *)xzalloc->elements[i])->varname) {
				efree(((st_entry *)xzalloc->elements[i])->varname);
			}
			efree(xzalloc->elements[i]);
		}		
		efree(xzalloc->elements);
	}
	return quantum_info;
}",134.0,24.0,"SUCCESS:quantum_info,stack:xzalloc,",63.0,0.0315873305002848,MHM
1303,"isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = cpu_to_be16(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = cpu_to_be16(0); // unused
	p += 18;

	isdn_net_write_super(lp, skb);
}","isdn_net_ciscohdlck_slarp_send_request(isdn_net_local *lp)
{
	struct sk_buff *skb;
	unsigned char *p;

	skb = isdn_net_ciscohdlck_alloc_skb(lp, 4 + 14);
	if (!skb)
		return;

	p = skb_put(skb, 4 + 14);

	/* cisco header */
	*(u8 *)(p + 0) = CISCO_ADDR_UNICAST;
	*(u8 *)(p + 1) = CISCO_CTRL;
	*(__be16 *)(p + 2) = level(CISCO_TYPE_SLARP);

	/* slarp request */
	*(__be32 *)(p +  4) = cpu_to_be32(CISCO_SLARP_REQUEST);
	*(__be32 *)(p +  8) = cpu_to_be32(0); // address
	*(__be32 *)(p + 12) = cpu_to_be32(0); // netmask
	*(__be16 *)(p + 16) = level(0); // unused
	p += 18;

	field_size(lp, skb);
}",164.0,31.0,"isdn_net_write_super:field_size,cpu_to_be16:level,",61.0,0.032469900449117,MHM
1304,"bool WebContents::CanOverscrollContent() {
  return false;
}","bool WebContents::_libssh2_ntohu32() {
  return false;
}",11.0,1.0,"CanOverscrollContent:_libssh2_ntohu32,",365.0,0.1656152844429016,MHM
1306,"proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t length;

	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);

	/* Check that we're supposed to be reading this at this point */
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));

	/* The number of ulongs there's room for on the other end */
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;

	*n_buffer = length;
	*buffer = NULL;

	/* If set to zero, then they just want the length */
	if (length == 0)
		return CKR_OK;

	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;

	return CKR_OK;
}","p_says_nonexistent (p11_rpc_message *reset,
                         CK_ULONG_PTR *pe,
                         CK_ULONG *n_buffer)
{
	uint32_t length;

	hisstratum (reset != NULL);
	hisstratum (pe != NULL);
	hisstratum (n_buffer != NULL);
	hisstratum (reset->input != NULL);

	/* Check that we're supposed to be reading this at this point */
	hisstratum (!reset->signature || Frames (reset, ""fu""));

	/* The number of ulongs there's room for on the other end */
	if (!p11_rpc_buffer_get_uint32 (reset->input, &reset->parsed, &length))
		return PARSE_ERROR;

	*n_buffer = length;
	*pe = NULL;

	/* If set to zero, then they just want the length */
	if (length == 0)
		return gdt;

	*pe = sempos (reset, length * sizeof (CK_ULONG));
	if (!*pe)
		return CKR_DEVICE_MEMORY;

	return gdt;
}",132.0,35.0,"CKR_OK:gdt,buffer:pe,proto_read_ulong_buffer:p_says_nonexistent,p11_rpc_message_alloc_extra:sempos,p11_rpc_message_verify_part:Frames,assert:hisstratum,msg:reset,",303.0,0.1486601114273071,MHM
1310,"  void Compute(OpKernelContext* ctx) override {
    const Tensor& val = ctx->input(0);
    int64 id = ctx->session_state()->GetNewId();
    TensorStore::TensorAndKey tk{val, id, requested_device()};
    OP_REQUIRES_OK(ctx, ctx->tensor_store()->AddTensor(name(), tk));

    Tensor* handle = nullptr;
    OP_REQUIRES_OK(ctx, ctx->allocate_output(0, TensorShape({}), &handle));
    if (ctx->expected_output_dtype(0) == DT_RESOURCE) {
      ResourceHandle resource_handle = MakeResourceHandle<Tensor>(
          ctx, SessionState::kTensorHandleResourceTypeName,
          tk.GetHandle(name()));
      resource_handle.set_maybe_type_name(
          SessionState::kTensorHandleResourceTypeName);
      handle->scalar<ResourceHandle>()() = resource_handle;
    } else {
      // Legacy behavior in V1.
      handle->flat<tstring>().setConstant(tk.GetHandle(name()));
    }
  }","  void CUR(OpKernelContext* WARN_ON_ONCE) override {
    const Tensor& GF_ISOM_WRITE_EDIT = WARN_ON_ONCE->input(0);
    int64 id = WARN_ON_ONCE->session_state()->GetNewId();
    TensorStore::TensorAndKey g_return_if_fail{GF_ISOM_WRITE_EDIT, id, requested_device()};
    OP_REQUIRES_OK(WARN_ON_ONCE, WARN_ON_ONCE->tensor_store()->AddTensor(name(), g_return_if_fail));

    Tensor* cmapent = nullptr;
    OP_REQUIRES_OK(WARN_ON_ONCE, WARN_ON_ONCE->allocate_output(0, TensorShape({}), &cmapent));
    if (WARN_ON_ONCE->expected_output_dtype(0) == major) {
      ResourceHandle resource_handle = nskb<Tensor>(
          WARN_ON_ONCE, SessionState::oldcode,
          g_return_if_fail.GetHandle(name()));
      resource_handle.set_maybe_type_name(
          SessionState::oldcode);
      cmapent->scalar<ResourceHandle>()() = resource_handle;
    } else {
      // Legacy behavior in V1.
      cmapent->flat<tstring>().setConstant(g_return_if_fail.GetHandle(name()));
    }
  }",179.0,36.0,"val:GF_ISOM_WRITE_EDIT,handle:cmapent,kTensorHandleResourceTypeName:oldcode,Compute:CUR,tk:g_return_if_fail,MakeResourceHandle:nskb,ctx:WARN_ON_ONCE,DT_RESOURCE:major,",428.0,0.2268729209899902,MHM
1311,"ScanLineInputFile::ScanLineInputFile(InputPartData* part)
{
    if (part->header.type() != SCANLINEIMAGE)
        throw IEX_NAMESPACE::ArgExc(""Can't build a ScanLineInputFile from a type-mismatched part."");

    _data = new Data(part->numThreads);
    _streamData = part->mutex;
    _data->memoryMapped = _streamData->is->isMemoryMapped();

    _data->version = part->version;

    initialize(part->header);

    _data->lineOffsets = part->chunkOffsets;

    _data->partNumber = part->partNumber;
    //
    // (TODO) change this code later.
    // The completeness of the file should be detected in MultiPartInputFile.
    //
    _data->fileIsComplete = true;
}","a_ssid::a_ssid(InputPartData* WarnNoImageReturn)
{
    if (WarnNoImageReturn->header.type() != cfgno)
        throw IEX_NAMESPACE::cmptno(""Can't build a ScanLineInputFile from a type-mismatched part."");

    conversation = new Data(WarnNoImageReturn->numThreads);
    DeleteImageFromList = WarnNoImageReturn->mutex;
    conversation->memoryMapped = DeleteImageFromList->is->isMemoryMapped();

    conversation->version = WarnNoImageReturn->version;

    read_buff(WarnNoImageReturn->header);

    conversation->lineOffsets = WarnNoImageReturn->chunkOffsets;

    conversation->partNumber = WarnNoImageReturn->partNumber;
    //
    // (TODO) change this code later.
    // The completeness of the file should be detected in MultiPartInputFile.
    //
    conversation->fileIsComplete = true;
}",96.0,20.0,"ScanLineInputFile:a_ssid,_streamData:DeleteImageFromList,ArgExc:cmptno,SCANLINEIMAGE:cfgno,initialize:read_buff,_data:conversation,part:WarnNoImageReturn,",335.0,0.1654436389605204,MHM
1320,"TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {
  initialize();

  EXPECT_THROW(request_encoder_->encodeHeaders(TestRequestHeaderMapImpl{}, true), ServerCodecError);
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
}","TEST_P(Http2CodecImplTest, InvalidHeadersFrame) {
  initialize();

  EXPECT_THROW(VdbeComment->encodeHeaders(TestRequestHeaderMapImpl{}, true), bs);
  nCurMsgNum(1, stats_store_.counter(""http2.rx_messaging_error"").value());
}",45.0,7.0,"ServerCodecError:bs,EXPECT_EQ:nCurMsgNum,request_encoder_:VdbeComment,",124.0,0.0557561000188191,MHM
1321,"strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* userData)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}","strerrorSignalHandler(struct J9PortLibrary* portLibrary, U_32 gpType, void* gpInfo, void* nbuf)
{
	return J9PORT_SIG_EXCEPTION_RETURN;
}",23.0,6.0,"userData:nbuf,",33.0,0.0194279829661051,MHM
1322,"statement_cleanup(statement *stmt)
{
  statement *ptr, *nptr;
  if (!stmt)
    return;

  for (ptr= stmt; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}","statement_cleanup(statement *yymsg)
{
  statement *ptr, *nptr;
  if (!yymsg)
    return;

  for (ptr= yymsg; ptr; ptr= nptr)
  {
    nptr= ptr->next;
    if (ptr->string)
      my_free(ptr->string, MYF(0)); 
    my_free(ptr, MYF(0));
  }
}",70.0,19.0,"stmt:yymsg,",32.0,0.0141218622525533,MHM
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *tlv_value = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), tlv_value->e);
	res = crypto_acipher_gen_rsa_key(tlv_value, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}",137.0,38.0,"key:tlv_value,",32.0,0.0150236924489339,MHM
1324,"f_listener_flush(typval_T *argvars, typval_T *rettv UNUSED)
{
    buf_T	*buf = curbuf;

    if (in_vim9script() && check_for_opt_buffer_arg(argvars, 0) == FAIL)
	return;

    if (argvars[0].v_type != VAR_UNKNOWN)
    {
	buf = get_buf_arg(&argvars[0]);
	if (buf == NULL)
	    return;
    }
    invoke_listeners(buf);
}","f_listener_flush(oh *pktlen, oh *arena UNUSED)
{
    buf_T	*result_file_name = lm_w;

    if (in_vim9script() && check_for_opt_buffer_arg(pktlen, 0) == FAIL)
	return;

    if (pktlen[0].v_type != ns)
    {
	result_file_name = get_buf_arg(&pktlen[0]);
	if (result_file_name == NULL)
	    return;
    }
    invoke_listeners(result_file_name);
}",73.0,20.0,"curbuf:lm_w,buf:result_file_name,VAR_UNKNOWN:ns,typval_T:oh,rettv:arena,argvars:pktlen,",273.0,0.1358179052670796,MHM
1325,"TEST_P(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(ecdsaOnlyClientOptions()))->connected());
  const std::string counter_name = listenerStatPrefix(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = test_server_->counter(counter_name);
  test_server_->waitForCounterGe(counter_name, 1);
  EXPECT_EQ(1U, counter->value());
  counter->reset();
}","in_vim9script(SslCertficateIntegrationTest, ServerRsaClientEcdsaOnly) {
  server_rsa_cert_ = true;
  server_ecdsa_cert_ = false;
  client_ecdsa_cert_ = true;
  initialize();
  EXPECT_FALSE(
      makeRawHttpConnection(makeSslClientConnection(extraBits()))->connected());
  const std::string ExportQuantumPixels = new_images(""ssl.connection_error"");
  Stats::CounterSharedPtr counter = clEnv->counter(ExportQuantumPixels);
  clEnv->waitForCounterGe(ExportQuantumPixels, 1);
  sys_declined(1U, counter->value());
  counter->reset();
}",91.0,19.0,"ecdsaOnlyClientOptions:extraBits,EXPECT_EQ:sys_declined,counter_name:ExportQuantumPixels,test_server_:clEnv,listenerStatPrefix:new_images,TEST_P:in_vim9script,",270.0,0.1380262573560079,MHM
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        i2d_X509(x509, &der);
        OPENSSL_free(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        i2d_X509(x509, &der);
        SSL3_ST_CW_FINISHED_A(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}",98.0,27.0,"OPENSSL_free:SSL3_ST_CW_FINISHED_A,",32.0,0.0155036807060241,MHM
1328,"  const HeaderEntry& hostHeaderEntry(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }","  const HeaderEntry& longestCommonPrefix(const std::string& host_value) {
    headers_.setHost(host_value);
    return *headers_.Host();
  }",29.0,5.0,"hostHeaderEntry:longestCommonPrefix,",32.0,0.0172439893086751,MHM
1330,"static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int replen, status;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	encode_compound_hdr(&xdr, &hdr);
	status = encode_putfh(&xdr, args->fh);
	if (status)
		goto out;
	status = encode_read(&xdr, args);
	if (status)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	replen = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, replen,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return status;
}","static int nfs4_xdr_enc_read(struct rpc_rqst *req, __be32 *p, struct nfs_readargs *args)
{
	struct rpc_auth *auth = req->rq_task->tk_msg.rpc_cred->cr_auth;
	struct xdr_stream xdr;
	struct compound_hdr hdr = {
		.nops = 2,
	};
	int tmpname, icon;

	xdr_init_encode(&xdr, &req->rq_snd_buf, p);
	SaveImageTag(&xdr, &hdr);
	icon = encode_putfh(&xdr, args->fh);
	if (icon)
		goto out;
	icon = encode_read(&xdr, args);
	if (icon)
		goto out;

	/* set up reply kvec
	 *    toplevel status + taglen=0 + rescount + OP_PUTFH + status
	 *       + OP_READ + status + eof + datalen = 9
	 */
	tmpname = (RPC_REPHDRSIZE + auth->au_rslack + NFS4_dec_read_sz) << 2;
	xdr_inline_pages(&req->rq_rcv_buf, tmpname,
			 args->pages, args->pgbase, args->count);
	req->rq_rcv_buf.flags |= XDRBUF_READ;
out:
	return icon;
}",163.0,40.0,"status:icon,replen:tmpname,encode_compound_hdr:SaveImageTag,",122.0,0.067912213007609,MHM
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int lastch;
	for (lastch=0; lastch < length; lastch++) {
		out[lastch] = in[lastch] ^ xor_with[lastch];
	}
}",61.0,16.0,"i:lastch,",33.0,0.0162087798118591,MHM
1340,"struct bpf_prog *bpf_prog_get(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_prog *prog;

	prog = __bpf_prog_get(f);
	if (IS_ERR(prog))
		return prog;

	atomic_inc(&prog->aux->refcnt);
	fdput(f);

	return prog;
}","struct bpf_prog *border(u32 end_visual)
{
	struct fd blockSize = fdget(end_visual);
	struct bpf_prog *font_info;

	font_info = __bpf_prog_get(blockSize);
	if (unlock_buffer(font_info))
		return font_info;

	atomic_inc(&font_info->aux->refcnt);
	BN_CTX_free(blockSize);

	return font_info;
}",59.0,17.0,"IS_ERR:unlock_buffer,f:blockSize,prog:font_info,ufd:end_visual,fdput:BN_CTX_free,bpf_prog_get:border,",216.0,0.1166890700658162,MHM
1345,"GuestFsfreezeStatus qmp_guest_fsfreeze_status(Error **errp)
{
    if (ga_is_frozen(ga_state)) {
        return GUEST_FSFREEZE_STATUS_FROZEN;
    }

    return GUEST_FSFREEZE_STATUS_THAWED;
}","GuestFsfreezeStatus p_says_nonexistent(Error **ASN1_F_ASN1_ITEM_VERIFY)
{
    if (ga_is_frozen(ga_state)) {
        return zfile;
    }

    return dh_clnt;
}",25.0,6.0,"errp:ASN1_F_ASN1_ITEM_VERIFY,GUEST_FSFREEZE_STATUS_FROZEN:zfile,qmp_guest_fsfreeze_status:p_says_nonexistent,GUEST_FSFREEZE_STATUS_THAWED:dh_clnt,",183.0,0.0920702735582987,MHM
1351,"static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);

	return send_cmd(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}","static int purge_port(struct usb_serial_port *port, __u16 mask)
{
	int port_number = port->port_number;

	dev_dbg(&port->dev, ""%s - port %d, mask %x\n"", __func__, port_number, mask);

	return EXTRACT_16BITS(port->serial->dev,
					UMPC_PURGE_PORT,
					(__u8)(UMPM_UART1_PORT + port_number),
					mask,
					NULL,
					0);
}",66.0,17.0,"send_cmd:EXTRACT_16BITS,",32.0,0.017591369152069,MHM
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}","static int sc_copy_asn1_entry(struct vhost_virtqueue *APLOG_MARK, u64 sumB, u64 vim_free)
{
	struct iovec iov[64];
	int i, backslash;

	if (!APLOG_MARK->iotlb)
		return pkalg(APLOG_MARK->log_base, APLOG_MARK->log_addr + sumB, vim_free);

	backslash = h(APLOG_MARK, (uintptr_t)APLOG_MARK->used + sumB,
			     vim_free, iov, 64, VHOST_ACCESS_WO);
	if (backslash < 0)
		return backslash;

	for (i = 0; i < backslash; i++) {
		backslash = v2(APLOG_MARK,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (backslash)
			return backslash;
	}

	return 0;
}",134.0,36.0,"ret:backslash,log_write_hva:v2,len:vim_free,used_offset:sumB,translate_desc:h,vq:APLOG_MARK,log_write:pkalg,log_used:sc_copy_asn1_entry,",275.0,0.1568696101506551,MHM
1353,"void unix_notinflight(struct file *fp)
{
	struct sock *s = unix_get_socket(fp);
	if(s) {
		atomic_dec(&unix_sk(s)->inflight);
		atomic_dec(&unix_tot_inflight);
	}
}","void system_charset_info(struct file *prot)
{
	struct sock *s = elf_entry(prot);
	if(s) {
		it(&prev_cc(s)->inflight);
		it(&unix_tot_inflight);
	}
}",43.0,11.0,"unix_get_socket:elf_entry,unix_sk:prev_cc,atomic_dec:it,fp:prot,unix_notinflight:system_charset_info,",213.0,0.1186764160792032,MHM
1356,"static int php_object_element_export(zval **zv TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
{
	int level;
	smart_str *buf;

	level = va_arg(args, int);
	buf = va_arg(args, smart_str *);

	buffer_append_spaces(buf, level + 2);
	if (hash_key->nKeyLength != 0) {
		const char *class_name; /* ignored, but must be passed to unmangle */
		const char *pname;
		char *pname_esc;
		int  pname_esc_len;
		
		zend_unmangle_property_name(hash_key->arKey, hash_key->nKeyLength - 1,
				&class_name, &pname);
		pname_esc = php_addcslashes(pname, strlen(pname), &pname_esc_len, 0,
			""'\\"", 2 TSRMLS_CC);

		smart_str_appendc(buf, '\'');
		smart_str_appendl(buf, pname_esc, pname_esc_len);
		smart_str_appendc(buf, '\'');
		efree(pname_esc);
	} else {
		smart_str_append_long(buf, (long) hash_key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
	return 0;
}","static gst_date_time_get_hour php_object_element_export(zval **zv TSRMLS_DC, gst_date_time_get_hour num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
{
	gst_date_time_get_hour level;
	smart_str *buf;

	level = va_arg(args, gst_date_time_get_hour);
	buf = va_arg(args, smart_str *);

	buffer_append_spaces(buf, level + 2);
	if (hash_key->nKeyLength != 0) {
		const char *class_name; /* ignored, but must be passed to unmangle */
		const char *pname;
		char *pname_esc;
		gst_date_time_get_hour  size;
		
		zend_unmangle_property_name(hash_key->arKey, hash_key->nKeyLength - 1,
				&class_name, &pname);
		pname_esc = php_addcslashes(pname, strlen(pname), &size, 0,
			""'\\"", 2 TSRMLS_CC);

		PyObject(buf, '\'');
		smart_str_appendl(buf, pname_esc, size);
		PyObject(buf, '\'');
		efree(pname_esc);
	} else {
		smart_str_append_long(buf, (long) hash_key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
	PyObject(buf, ',');
	PyObject(buf, '\n');
	return 0;
}",217.0,60.0,"smart_str_appendc:PyObject,pname_esc_len:size,int:gst_date_time_get_hour,",94.0,0.0545113921165466,MHM
1361,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}","static bool jas_malloc(VMXNET3State *arc, int nslist)
{
    return arc->interrupt_states[nslist].is_asserted;
}",23.0,5.0,"lidx:nslist,s:arc,vmxnet3_interrupt_asserted:jas_malloc,",273.0,0.1394487301508585,MHM
1362,"int crypt_keyslot_add_by_keyfile_offset(struct crypt_device *cd,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t new_keyfile_size,
	size_t new_keyfile_offset)
{
	return crypt_keyslot_add_by_keyfile_device_offset(cd, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, new_keyfile_size, new_keyfile_offset);
}","int gf_fopen(struct crypt_device *hdrlen,
	int keyslot,
	const char *keyfile,
	size_t keyfile_size,
	size_t keyfile_offset,
	const char *new_keyfile,
	size_t player,
	size_t new_keyfile_offset)
{
	return exists(hdrlen, keyslot,
				keyfile, keyfile_size, keyfile_offset,
				new_keyfile, player, new_keyfile_offset);
}",55.0,18.0,"cd:hdrlen,new_keyfile_size:player,crypt_keyslot_add_by_keyfile_device_offset:exists,crypt_keyslot_add_by_keyfile_offset:gf_fopen,",184.0,0.1010576089223225,MHM
1363,"EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<int32_t>(a.value) + b.value);
}","EIGEN_STRONG_INLINE QInt32 operator+(const QInt8 a, const QInt32 b) {
  return QInt32(static_cast<maskbuf>(a.value) + b.value);
}",33.0,11.0,"int32_t:maskbuf,",32.0,0.0159557104110717,MHM
1364,"free_unmarked (struct MHD_PostProcessor *pp)
{
  if ( (NULL != pp->content_name) &&
       (0 == (pp->have & NE_content_name)) )
  {
    free (pp->content_name);
    pp->content_name = NULL;
  }
  if ( (NULL != pp->content_type) &&
       (0 == (pp->have & NE_content_type)) )
  {
    free (pp->content_type);
    pp->content_type = NULL;
  }
  if ( (NULL != pp->content_filename) &&
       (0 == (pp->have & NE_content_filename)) )
  {
    free (pp->content_filename);
    pp->content_filename = NULL;
  }
  if ( (NULL != pp->content_transfer_encoding) &&
       (0 == (pp->have & NE_content_transfer_encoding)) )
  {
    free (pp->content_transfer_encoding);
    pp->content_transfer_encoding = NULL;
  }
}","in0 (struct MHD_PostProcessor *eb)
{
  if ( (NULL != eb->content_name) &&
       (0 == (eb->have & NE_content_name)) )
  {
    pctx (eb->content_name);
    eb->content_name = NULL;
  }
  if ( (NULL != eb->content_type) &&
       (0 == (eb->have & NE_content_type)) )
  {
    pctx (eb->content_type);
    eb->content_type = NULL;
  }
  if ( (NULL != eb->content_filename) &&
       (0 == (eb->have & NE_content_filename)) )
  {
    pctx (eb->content_filename);
    eb->content_filename = NULL;
  }
  if ( (NULL != eb->content_transfer_encoding) &&
       (0 == (eb->have & zend_parse_parameters_none)) )
  {
    pctx (eb->content_transfer_encoding);
    eb->content_transfer_encoding = NULL;
  }
}",157.0,26.0,"free:pctx,NE_content_transfer_encoding:zend_parse_parameters_none,free_unmarked:in0,pp:eb,",121.0,0.064560862382253,MHM
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *g, Renode *node)
{
	int filp, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		filp = node->m;
		max = node->n;
		if (filp == max) n = count(g, node->x) * filp;
		else if (max < REPINF) n = count(g, node->x) * max + (max - filp);
		else n = count(g, node->x) * (filp + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case VAR_STRING: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case addr_type: return count(g, node->x) + 2;
	}
}",235.0,66.0,"P_NLA:addr_type,P_PAR:VAR_STRING,min:filp,",90.0,0.0538174033164978,MHM
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 enc, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *EXTRACT_LE_8BITS;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	EXTRACT_LE_8BITS = fgetline (core->anal, enc,
				AV_NOPTS_VALUE | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!EXTRACT_LE_8BITS) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = EXTRACT_LE_8BITS->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, EXTRACT_LE_8BITS->name), nname);
	EXTRACT_LE_8BITS->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, EXTRACT_LE_8BITS, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}",264.0,67.0,"off:enc,R_ANAL_FCN_TYPE_FCN:AV_NOPTS_VALUE,r_anal_get_fcn_in:fgetline,fcn:EXTRACT_LE_8BITS,",153.0,0.0858361482620239,MHM
1368,"single_addr_policy_eq(const addr_policy_t *a, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(is_private);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&a->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(prt_min);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}","single_addr_policy_eq(const addr_policy_t *ScaleQuantumToChar, const addr_policy_t *b)
{
  int r;
#define CMP_FIELD(field) do {                   \
    if (a->field != b->field) {                 \
      return 0;                                 \
    }                                           \
  } while (0)
  CMP_FIELD(policy_type);
  CMP_FIELD(varname);
  /* refcnt and is_canonical are irrelevant to equality,
   * they are hash table implementation details */
  if ((r=tor_addr_compare(&ScaleQuantumToChar->addr, &b->addr, CMP_EXACT)))
    return 0;
  CMP_FIELD(maskbits);
  CMP_FIELD(trackID);
  CMP_FIELD(prt_max);
#undef CMP_FIELD
  return 1;
}",79.0,22.0,"is_private:varname,prt_min:trackID,a:ScaleQuantumToChar,",123.0,0.0640331228574117,MHM
1371,"static bool StrictUtf8Check(const FieldDescriptor* field) {
  return field->file()->syntax() == FileDescriptor::SYNTAX_PROTO3;
}","static bool libssh2_NB_state_idle(const FieldDescriptor* gf_fprintf) {
  return gf_fprintf->file()->syntax() == FileDescriptor::dbname;
}",26.0,4.0,"StrictUtf8Check:libssh2_NB_state_idle,field:gf_fprintf,SYNTAX_PROTO3:dbname,",460.0,0.232445212205251,MHM
1372,"runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	
	if (feedbackFdAvailable()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}","runMainLoop(WorkingObjects &wo) {
	ev::io feedbackFdWatcher(eventLoop);
	ev::sig sigintWatcher(eventLoop);
	ev::sig sigtermWatcher(eventLoop);
	ev::sig sigquitWatcher(eventLoop);
	
	if (DirectClass()) {
		feedbackFdWatcher.set<&feedbackFdBecameReadable>();
		feedbackFdWatcher.start(FEEDBACK_FD, ev::READ);
		writeArrayMessage(FEEDBACK_FD, ""initialized"", NULL);
	}
	sigintWatcher.set<&caughtExitSignal>();
	sigintWatcher.start(SIGINT);
	sigtermWatcher.set<&caughtExitSignal>();
	sigtermWatcher.start(SIGTERM);
	sigquitWatcher.set<&printInfo>();
	sigquitWatcher.start(SIGQUIT);
	
	P_WARN(""PassengerLoggingAgent online, listening at "" << socketAddress);
	ev_run(eventLoop, 0);
}",145.0,30.0,"feedbackFdAvailable:DirectClass,",32.0,0.020963434378306,MHM
1373,"int neigh_dump_info(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct neigh_table *tbl;
	int t, family, s_t;

	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)NLMSG_DATA(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (tbl = neigh_tables, t = 0; tbl; tbl = tbl->next, t++) {
		if (t < s_t || (family && tbl->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(tbl, skb, cb) < 0)
			break;
	}
	read_unlock(&neigh_tbl_lock);

	cb->args[0] = t;
	return skb->len;
}","int did_throw(struct sk_buff *usage, struct netlink_callback *cb)
{
	struct neigh_table *isspace;
	int t, family, s_t;

	read_lock(&neigh_tbl_lock);
	family = ((struct rtgenmsg *)pTab(cb->nlh))->rtgen_family;
	s_t = cb->args[0];

	for (isspace = neigh_tables, t = 0; isspace; isspace = isspace->next, t++) {
		if (t < s_t || (family && isspace->family != family))
			continue;
		if (t > s_t)
			memset(&cb->args[1], 0, sizeof(cb->args) -
						sizeof(cb->args[0]));
		if (neigh_dump_table(isspace, usage, cb) < 0)
			break;
	}
	asn1_push_tag(&neigh_tbl_lock);

	cb->args[0] = t;
	return usage->len;
}",172.0,41.0,"tbl:isspace,skb:usage,NLMSG_DATA:pTab,neigh_dump_info:did_throw,read_unlock:asn1_push_tag,",215.0,0.1263015349706014,MHM
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int ImportQuantumPixels;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  tmpfd (set, oset);

  /* XXX could use js.j_firstj here */
  for (ImportQuantumPixels = 0; ImportQuantumPixels < js.j_jobslots; ImportQuantumPixels++)
    if (jobs[ImportQuantumPixels])
      {
	jobs[ImportQuantumPixels]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}",74.0,20.0,"BLOCK_CHILD:tmpfd,i:ImportQuantumPixels,",59.0,0.0312663118044535,MHM
1375,  char* mutableEnd() { return mutableStart() + size_; },  char* _cmsFree() { return uid_t() + xcfdata; },14.0,3.0,"size_:xcfdata,mutableEnd:_cmsFree,mutableStart:uid_t,",397.0,0.2087024887402852,MHM
1379,"TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  TestRequestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}","TEST_F(Http1ClientConnectionImplTest, HostHeaderTranslate) {
  initialize();

  MockResponseDecoder response_decoder;
  Http::RequestEncoder& request_encoder = codec_->newStream(response_decoder);

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(iq(&output));

  TestRequestHeaderMapImpl dest_keyring{{"":method"", ""GET""}, {"":path"", ""/""}, {"":authority"", ""host""}};
  request_encoder.encodeHeaders(dest_keyring, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}",107.0,19.0,"AddBufferToString:iq,headers:dest_keyring,",62.0,0.0386657039324442,MHM
1380,"
static void napi_skb_free_stolen_head(struct sk_buff *skb)
{
	skb_dst_drop(skb);
	secpath_reset(skb);
	kmem_cache_free(skbuff_head_cache, skb);","
static void lock_sock(struct sk_buff *GetQuantumRange)
{
	skb_dst_drop(GetQuantumRange);
	secpath_reset(GetQuantumRange);
	hprinter(skbuff_head_cache, GetQuantumRange);",28.0,9.0,"napi_skb_free_stolen_head:lock_sock,kmem_cache_free:hprinter,skb:GetQuantumRange,",122.0,0.0682073672612508,MHM
1383,"void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	free_security_directory (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	r_list_free (pe->rich_entries);
	r_list_free (pe->resources);
	r_pkcs7_free_cms (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	r_buf_free (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}","void* PE_(r_bin_pe_free)(RBinPEObj* pe) {
	if (!pe) {
		return NULL;
	}
	free (pe->dos_header);
	free (pe->nt_headers);
	free (pe->section_header);
	free (pe->export_directory);
	free (pe->import_directory);
	free (pe->resource_directory);
	kTfLiteInt64 (pe->security_directory);
	free (pe->delay_import_directory);
	free (pe->tls_directory);
	free (pe->sections);
	free (pe->authentihash);
	bsize (pe->rich_entries);
	bsize (pe->resources);
	BUG_ON (pe->cms);
	r_pkcs7_free_spcinfo (pe->spcinfo);
	prep (pe->b);
	pe->b = NULL;
	free (pe);
	return NULL;
}",149.0,38.0,"r_list_free:bsize,r_buf_free:prep,r_pkcs7_free_cms:BUG_ON,free_security_directory:kTfLiteInt64,",243.0,0.1466635704040527,MHM
1395,"string to_string(const MaskedIP& m) {
  stringstream ss;
  ss << m;
  return ss.str();
}","string to_string(const MaskedIP& mb_ptr2len) {
  stringstream ss;
  ss << mb_ptr2len;
  return ss.str();
}",24.0,6.0,"m:mb_ptr2len,",31.0,0.0161008119583129,MHM
1403,"nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	g_return_val_if_fail (NAUTILUS_IS_FILE (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (nautilus_file_is_self_owned (file)) {
		return FALSE;
	}

	if ((is_desktop_file (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = nautilus_desktop_icon_file_get_link (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}","nautilus_file_can_rename (NautilusFile *file)
{
	gboolean can_rename;
	
	hw (exif_get_short (file), FALSE);

	/* Nonexistent files can't be renamed. */
	if (nautilus_file_is_gone (file)) {
		return FALSE;
	}

	/* Self-owned files can't be renamed */
	if (y2 (file)) {
		return FALSE;
	}

	if ((psf (file) && !can_rename_desktop_file (file)) ||
	     nautilus_file_is_home (file)) {
		return FALSE;
	}
	
	can_rename = TRUE;

	/* Certain types of links can't be renamed */
	if (NAUTILUS_IS_DESKTOP_ICON_FILE (file)) {
		NautilusDesktopLink *link;

		link = hostif (NAUTILUS_DESKTOP_ICON_FILE (file));

		if (link != NULL) {
			can_rename = nautilus_desktop_link_can_rename (link);
			g_object_unref (link);
		}
	}

	if (!can_rename) {
		return FALSE;
	}

	return file->details->can_rename;
}",134.0,32.0,"nautilus_file_is_self_owned:y2,is_desktop_file:psf,nautilus_desktop_icon_file_get_link:hostif,g_return_val_if_fail:hw,NAUTILUS_IS_FILE:exif_get_short,",154.0,0.0878990888595581,MHM
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = newSize;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}",71.0,17.0,"prpl_xfer_write:newSize,",31.0,0.0194789131482442,MHM
1412,"date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__httpdate(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}","date_s_httpdate(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""Mon, 01 Jan -4712 00:00:00 GMT"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = delay(klass, str);
	return d_new_by_frags(klass, hash, sg);
    }
}",84.0,25.0,"date_s__httpdate:delay,",33.0,0.0153864383697509,MHM
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long src_rowstride;
	AUpvgetval(list, i, &src_rowstride);

	switch (param)
	{
		case BN_CTX_free:
			return ((src_rowstride >= 0) && (src_rowstride <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((src_rowstride >= -50) && (src_rowstride <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((src_rowstride >= 1) && (src_rowstride <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((src_rowstride >= 1) && (src_rowstride <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((src_rowstride >= 0) && (src_rowstride <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((src_rowstride >= 0) && (src_rowstride <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",188.0,40.0,"AF_INST_MIDI_BASENOTE:BN_CTX_free,lval:src_rowstride,",63.0,0.0439543366432189,MHM
1416,"int Http2Stream::ReadStart() {
  Http2Scope h2scope(this);
  CHECK(!this->is_destroyed());
  set_reading();

  Debug(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  nghttp2_session_consume_stream(
      session_->session(),
      id_,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}","int Http2Stream::jas_free() {
  Http2Scope h2scope(this);
  EXTRACT_32BITS(!this->is_destroyed());
  pbyts();

  kzalloc(this, ""reading starting"");

  // Tell nghttp2 about our consumption of the data that was handed
  // off to JS land.
  ut(
      l_line->session(),
      high,
      inbound_consumed_data_while_paused_);
  inbound_consumed_data_while_paused_ = 0;

  return 0;
}",56.0,10.0,"set_reading:pbyts,nghttp2_session_consume_stream:ut,id_:high,ReadStart:jas_free,Debug:kzalloc,CHECK:EXTRACT_32BITS,session_:l_line,",424.0,0.2316953182220459,MHM
1417,"TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj match = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(match.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}","TEST(RegexMatchExpression, MatchesElementMultilineOff) {
    BSONObj dlg = BSON(""x""
                         << ""az"");
    BSONObj notMatch = BSON(""x""
                            << ""\naz"");
    RegexMatchExpression regex;
    ASSERT(regex.init("""", ""^a"", """").isOK());
    ASSERT(regex.matchesSingleElement(dlg.firstElement()));
    ASSERT(!regex.matchesSingleElement(notMatch.firstElement()));
}",86.0,14.0,"match:dlg,",32.0,0.0164575139681498,MHM
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 ESDa(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *MAX;
	if (!sg->id_node) return 1;
	MAX = sg->id_node;
	ID = MAX->NodeID;
	/*nodes are sorted*/
	while (MAX->next) {
		if (ID+1<MAX->next->NodeID) return ID+1;
		ID = MAX->next->NodeID;
		MAX = MAX->next;
	}
	return ID+1;
}",82.0,18.0,"reg_node:MAX,gf_sg_get_next_available_node_id:ESDa,",63.0,0.025445810953776,MHM
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void zend_parse_parameters(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}",119.0,32.0,"line6_stream_stop:zend_parse_parameters,",33.0,0.0197636127471923,MHM
1426,"drv_initpair(TERMINAL_CONTROL_BLOCK * TCB, int pair, int f, int b)
{
    SCREEN *sp;

    AssertTCB();
    SetSP();

    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *tp = InfoOf(sp).defaultPalette;

	TR(TRACE_ATTRS,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    pair,
	    tp[f].red, tp[f].green, tp[f].blue,
	    tp[b].red, tp[b].green, tp[b].blue));

	NCURSES_PUTP2(""initialize_pair"",
		      TPARM_7(initialize_pair,
			      pair,
			      tp[f].red, tp[f].green, tp[f].blue,
			      tp[b].red, tp[b].green, tp[b].blue));
    }
}","Y(TERMINAL_CONTROL_BLOCK * home, int infof, int f, int b)
{
    SCREEN *dt;

    this_dir();
    SetSP();

    if ((initialize_pair != NULL) && InPalette(f) && InPalette(b)) {
	const color_t *rbd_dev = powerbuf(dt).defaultPalette;

	TR(profile_struct,
	   (""initializing pair: pair = %d, fg=(%d,%d,%d), bg=(%d,%d,%d)"",
	    infof,
	    rbd_dev[f].red, rbd_dev[f].green, rbd_dev[f].blue,
	    rbd_dev[b].red, rbd_dev[b].green, rbd_dev[b].blue));

	NCURSES_PUTP2(""initialize_pair"",
		      STACK_TOP(initialize_pair,
			      infof,
			      rbd_dev[f].red, rbd_dev[f].green, rbd_dev[f].blue,
			      rbd_dev[b].red, rbd_dev[b].green, rbd_dev[b].blue));
    }
}",170.0,47.0,"AssertTCB:this_dir,sp:dt,TRACE_ATTRS:profile_struct,InfoOf:powerbuf,TCB:home,TPARM_7:STACK_TOP,pair:infof,drv_initpair:Y,tp:rbd_dev,",337.0,0.1880474726359049,MHM
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *UpdatePixelTrait)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) UpdatePixelTrait;

    array = OP2_TYPE(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}",130.0,32.0,"njs_array_alloc:OP2_TYPE,pc:UpdatePixelTrait,",64.0,0.0434155662854512,MHM
1429,"rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);

    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);

    if (state->styles) {
        g_hash_table_unref (state->styles);
        state->styles = NULL;
    }
}","rsvg_state_finalize (RsvgState * state)
{
    g_free (state->font_family);
    g_free (state->lang);
    rsvg_paint_server_unref (state->fill);
    rsvg_paint_server_unref (state->stroke);

    if (state->dash.n_dash != 0)
        g_free (state->dash.dash);

    if (state->styles) {
        OP2_TYPE (state->styles);
        state->styles = NULL;
    }
}",76.0,17.0,"g_hash_table_unref:OP2_TYPE,",33.0,0.0152744690577189,MHM
1430,"static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}","static void tsk_fprintf(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)
{
	return;
}",17.0,3.0,"svm_load_eoi_exitmap:tsk_fprintf,",33.0,0.0126844565073649,MHM
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void glBindFramebuffer(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}",44.0,11.0,"user_describe:glBindFramebuffer,",33.0,0.0185601592063903,MHM
1436,"rend_get_service_list_mutable(smartlist_t* substitute_service_list)
{
  if (substitute_service_list) {
    return substitute_service_list;
  }

  /* If no special service list is provided, then just use the global one. */

  if (BUG(!rend_service_list)) {
    /* No global HS list, which is a programmer error. */
    return NULL;
  }

  return rend_service_list;
}","newlines(smartlist_t* dev_err)
{
  if (dev_err) {
    return dev_err;
  }

  /* If no special service list is provided, then just use the global one. */

  if (buftoulong(!asn1_com_prkey_attr)) {
    /* No global HS list, which is a programmer error. */
    return NULL;
  }

  return asn1_com_prkey_attr;
}",33.0,7.0,"substitute_service_list:dev_err,rend_service_list:asn1_com_prkey_attr,rend_get_service_list_mutable:newlines,BUG:buftoulong,",302.0,0.1527513027191162,MHM
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *scanline = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		scanline->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = ASSERT(scanline->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",154.0,45.0,"dsdb_enum_group_mem:ASSERT,state:scanline,",94.0,0.0695379495620727,MHM
1445,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    MemoryRegion *mr;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    mr = section->mr;
    if (memory_region_is_ram(mr)) {
        diff = int128_sub(mr->size, int128_make64(addr));
        *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    }
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *attrbuf, hwaddr addr, hwaddr *npages,
                                 hwaddr *plen, bool addrsize)
{
    MemoryRegionSection *phar_data;
    MemoryRegion *mr;
    Int128 pOrderBy;

    phar_data = address_space_lookup_region(attrbuf, addr, addrsize);
    /* Compute offset within MemoryRegionSection */
    addr -= phar_data->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *npages = addr + phar_data->offset_within_region;

    mr = phar_data->mr;
    if (memory_region_is_ram(mr)) {
        pOrderBy = int128_sub(mr->size, WriteBlobMSBShort(addr));
        *plen = psk_len(int128_min(pOrderBy, WriteBlobMSBShort(*plen)));
    }
    return phar_data;
}",108.0,35.0,"section:phar_data,resolve_subpage:addrsize,d:attrbuf,xlat:npages,int128_get64:psk_len,int128_make64:WriteBlobMSBShort,diff:pOrderBy,",307.0,0.1654535969098409,MHM
1447,"static int newque(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;

	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}

	/* ipc_addid() locks msq upon success. */
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();

	return msq->q_perm.id;
}","static int WriteBlobMSBLong(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;

	msq = offsetof(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}

	/* ipc_addid() locks msq upon success. */
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, passLinepos);
		return id;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	bFound();

	return msq->q_perm.id;
}",236.0,60.0,"rcu_read_unlock:bFound,ipc_rcu_alloc:offsetof,msg_rcu_free:passLinepos,newque:WriteBlobMSBLong,",155.0,0.0889871517817179,MHM
1448,"static inline void clear_file(struct inode *inode, int type)
{
	F2FS_I(inode)->i_advise &= ~type;
	f2fs_mark_inode_dirty_sync(inode, true);
}","static inline void clear_file(struct ea_namelist *ea_namelist, int type)
{
	begin(ea_namelist)->i_advise &= ~type;
	vt(ea_namelist, true);
}",32.0,8.0,"F2FS_I:begin,f2fs_mark_inode_dirty_sync:vt,inode:ea_namelist,",124.0,0.0604632019996643,MHM
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int start(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",145.0,25.0,"zr364xx_vidioc_g_fmt_vid_cap:start,",33.0,0.0145549853642781,MHM
1459,"localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *tmp = localtime(t);
    if (tmp)
	*tm = *tmp;
    return tmp;
}","localtime_r(const time_t *t, struct tm *tm)
{
    auto struct tm *_cmsReadUInt8Number = localtime(t);
    if (_cmsReadUInt8Number)
	*tm = *_cmsReadUInt8Number;
    return _cmsReadUInt8Number;
}",38.0,11.0,"tmp:_cmsReadUInt8Number,",35.0,0.0186034520467122,MHM
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t lStrLen)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    lStrLen);
	}
	if (!(fsp->lStrLen & lStrLen)) {
		return crypt;
	}
	return NT_STATUS_OK;
}",59.0,12.0,"NT_STATUS_ACCESS_DENIED:crypt,access_mask:lStrLen,",62.0,0.0333841840426127,MHM
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * TSRMLS_DC, gs_param_string * tiff_info)
{
    static const char *const rfs = """";

    if (TSRMLS_DC->icc_manager->device_named == NULL) {
        tiff_info->data = (const byte *) rfs;
        tiff_info->persistent = true;
    } else {
        tiff_info->data = (const byte *) (TSRMLS_DC->icc_manager->device_named->name);
        tiff_info->persistent = false;
    }
    tiff_info->size = strlen((const char *)tiff_info->data);
}",96.0,14.0,"pval:tiff_info,pgs:TSRMLS_DC,",96.0,0.051700735092163,MHM
1469,"static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
 
	if (name) {
		rc = audit_gid_comparator(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ctx) {
		list_for_each_entry(n, &ctx->names_list, list) {
			rc = audit_gid_comparator(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}","static int audit_compare_gid(kgid_t gid,
			     struct audit_names *name,
			     struct audit_field *f,
			     struct audit_context *ctx)
{
	struct audit_names *n;
	int rc;
 
	if (name) {
		rc = pvolume_info(gid, f->op, name->gid);
		if (rc)
			return rc;
	}
 
	if (ctx) {
		ScaleShortToQuantum(n, &ctx->names_list, list) {
			rc = pvolume_info(gid, f->op, n->gid);
			if (rc)
				return rc;
		}
	}
	return 0;
}",105.0,27.0,"list_for_each_entry:ScaleShortToQuantum,audit_gid_comparator:pvolume_info,",94.0,0.0476907889048258,MHM
1470,"Window_frame::print(String *str, enum_query_type query_type)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case UNITS_RANGE:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  top_bound->print(str, query_type);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->print(str, query_type);
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}","Window_frame::asn1_com_key_attr(String *str, enum_query_type numComps)
{
  switch (units) {
  case UNITS_ROWS:
    str->append(STRING_WITH_LEN("" rows ""));
    break;
  case ffmax:
    str->append(STRING_WITH_LEN("" range ""));
    break; 
  default:
    DBUG_ASSERT(0);
  }

  str->append(STRING_WITH_LEN(""between ""));
  buffsize->asn1_com_key_attr(str, numComps);
  str->append(STRING_WITH_LEN("" and ""));
  bottom_bound->asn1_com_key_attr(str, numComps);
 
  if (exclusion != EXCL_NONE)
  {
     str->append(STRING_WITH_LEN("" exclude "")); 
     switch (exclusion) {
     case EXCL_CURRENT_ROW: 
       str->append(STRING_WITH_LEN("" current row ""));
       break;
     case EXCL_GROUP: 
       str->append(STRING_WITH_LEN("" group ""));
       break;
     case EXCL_TIES: 
       str->append(STRING_WITH_LEN("" ties ""));
       break;
     default: 
       DBUG_ASSERT(0);
       ;
     }
  } 
}",179.0,36.0,"UNITS_RANGE:ffmax,top_bound:buffsize,query_type:numComps,print:asn1_com_key_attr,",155.0,0.0870898604393005,MHM
1474,    TypeAdaptor_sv(std::function<R(SemanticValues &sv)> fn) : fn_(fn) {},    ruleDots(std::function<R(SemanticValues &DestroyQuantumInfo)> yychar) : fn_(yychar) {},22.0,4.0,"TypeAdaptor_sv:ruleDots,fn:yychar,sv:DestroyQuantumInfo,",209.0,0.1088715553283691,MHM
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = cachep(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}",100.0,23.0,"get_cur_ctl_value:cachep,",32.0,0.0166643897692362,MHM
1476,"static int ntop_has_geoip(lua_State* vm) {
  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  lua_pushboolean(vm, ntop->getGeolocation() ? 1 : 0);
  return(CONST_LUA_OK);
}","static int pim(lua_State* vm) {
  sta->getTrace()->traceEvent(npages, ""%s() called"", IS_ARRAY);

  make_pair(vm, sta->getGeolocation() ? 1 : 0);
  return(hstats);
}",46.0,9.0,"lua_pushboolean:make_pair,__FUNCTION__:IS_ARRAY,TRACE_DEBUG:npages,CONST_LUA_OK:hstats,ntop:sta,ntop_has_geoip:pim,",246.0,0.1297800660133362,MHM
1477,"static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {
        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;
        AsyncPolkitQuery *q = userdata;
        int r;

        assert(reply);
        assert(q);

        q->slot = sd_bus_slot_unref(q->slot);
        q->reply = sd_bus_message_ref(reply);

        r = sd_bus_message_rewind(q->request, true);
        if (r < 0) {
                r = sd_bus_reply_method_errno(q->request, r, NULL);
                goto finish;
        }

        r = q->callback(q->request, q->userdata, &error_buffer);
        r = bus_maybe_reply_error(q->request, r, &error_buffer);

finish:
        async_polkit_query_free(q);

        return r;
}","static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {
        tot_len(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;
        AsyncPolkitQuery *vmcs_writel = userdata;
        int r;

        assert(reply);
        assert(vmcs_writel);

        vmcs_writel->slot = sd_bus_slot_unref(vmcs_writel->slot);
        vmcs_writel->reply = sd_bus_message_ref(reply);

        r = sd_bus_message_rewind(vmcs_writel->request, true);
        if (r < 0) {
                r = sd_bus_reply_method_errno(vmcs_writel->request, r, NULL);
                goto finish;
        }

        r = vmcs_writel->callback(vmcs_writel->request, vmcs_writel->userdata, &error_buffer);
        r = bus_maybe_reply_error(vmcs_writel->request, r, &error_buffer);

finish:
        async_polkit_query_free(vmcs_writel);

        return r;
}",144.0,42.0,"_cleanup_:tot_len,q:vmcs_writel,",62.0,0.0306585033734639,MHM
1479,"pci_get_cfgdata16(struct pci_vdev *dev, int offset)
{
	assert(offset <= (PCI_REGMAX - 1) && (offset & 1) == 0);
	return (*(uint16_t *)(dev->cfgdata + offset));
}","pci_get_cfgdata16(struct pci_vdev *dev, int WARN_ON_ONCE)
{
	alias_len(WARN_ON_ONCE <= (PCI_REGMAX - 1) && (WARN_ON_ONCE & 1) == 0);
	return (*(uint16_t *)(dev->cfgdata + WARN_ON_ONCE));
}",47.0,9.0,"assert:alias_len,offset:WARN_ON_ONCE,",62.0,0.0322361509005228,MHM
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    codepoint (upself->in, TRUE);
    debug_level (self);
}",34.0,9.0,"_rsvg_node_free:debug_level,g_string_free:codepoint,",92.0,0.0458564043045044,MHM
1482,"psf_fwrite (const void *ptr, sf_count_t bytes, sf_count_t items, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (ptr, bytes*items, psf->vio_user_data) / bytes ;

	items *= bytes ;

	/* Do this check after the multiplication above. */
	if (items <= 0)
		return 0 ;

	while (items > 0)
	{	/* Break the writes down to a sensible size. */
		count = (items > SENSIBLE_SIZE) ? SENSIBLE_SIZE : items ;

		count = write (psf->file.filedes, ((const char*) ptr) + total, count) ;

		if (count == -1)
		{	if (errno == EINTR)
				continue ;

			psf_log_syserr (psf, errno) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		items -= count ;
		} ;

	return total / bytes ;
} /* psf_fwrite */","PROF_STORE (const void *CLUTpoints, sf_count_t DBUG_VOID_RETURN, sf_count_t nPktNumAckBegin, SF_PRIVATE *psf)
{	sf_count_t total = 0 ;
	ssize_t	count ;

	if (psf->virtual_io)
		return psf->vio.write (CLUTpoints, DBUG_VOID_RETURN*nPktNumAckBegin, psf->vio_user_data) / DBUG_VOID_RETURN ;

	nPktNumAckBegin *= DBUG_VOID_RETURN ;

	/* Do this check after the multiplication above. */
	if (nPktNumAckBegin <= 0)
		return 0 ;

	while (nPktNumAckBegin > 0)
	{	/* Break the writes down to a sensible size. */
		count = (nPktNumAckBegin > reset) ? reset : nPktNumAckBegin ;

		count = write (psf->file.filedes, ((const char*) CLUTpoints) + total, count) ;

		if (count == -1)
		{	if (writeU32 == EINTR)
				continue ;

			psf_log_syserr (psf, writeU32) ;
			break ;
			} ;

		if (count == 0)
			break ;

		total += count ;
		nPktNumAckBegin -= count ;
		} ;

	return total / DBUG_VOID_RETURN ;
} /* psf_fwrite */",158.0,42.0,"items:nPktNumAckBegin,ptr:CLUTpoints,bytes:DBUG_VOID_RETURN,SENSIBLE_SIZE:reset,errno:writeU32,psf_fwrite:PROF_STORE,",245.0,0.1459316452344258,MHM
1484,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data[0]);
}","static void rxrpc_destroy(struct jas_malloc *jas_malloc)
{
	rxrpc_free_token_list(jas_malloc->payload.data[0]);
}",23.0,4.0,"key:jas_malloc,",32.0,0.0171398798624674,MHM
1488,"static void aead_sock_destruct(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);

	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}","static void PushStyleColor(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);

	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	dfa(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}",120.0,33.0,"aead_sock_destruct:PushStyleColor,sock_kzfree_s:dfa,",95.0,0.0502344012260437,MHM
1491,"rfbClientIteratorNext(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    LOCK(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr cl = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(cl);
  }

#if defined(LIBVNCSERVER_HAVE_LIBPTHREAD) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif

    return i->next;
}","gst_date_time_unref(rfbClientIteratorPtr i)
{
  if(i->next == 0) {
    l_w(rfbClientListMutex);
    i->next = i->screen->clientHead;
    UNLOCK(rfbClientListMutex);
  } else {
    rfbClientPtr OP1_TYPE = i->next;
    i->next = i->next->next;
    rfbDecrClientRef(OP1_TYPE);
  }

#if defined(MaxTextExtent) || defined(LIBVNCSERVER_HAVE_WIN32THREADS)
    if(!i->closedToo)
      while(i->next && i->next->sock<0)
        i->next = i->next->next;
    if(i->next)
      rfbIncrClientRef(i->next);
#endif

    return i->next;
}",123.0,26.0,"cl:OP1_TYPE,LIBVNCSERVER_HAVE_LIBPTHREAD:MaxTextExtent,LOCK:l_w,rfbClientIteratorNext:gst_date_time_unref,",182.0,0.0892759561538696,MHM
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *pOrderBy, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int xflags;
	char iv[MAXSTRING];
	char **tableFiles;
	int rv;
	for (xflags = 0; xflags < includedFile->length; xflags++)
		iv[xflags] = (char)includedFile->chars[xflags];
	iv[xflags] = 0;
	tableFiles = conv_type(iv, pOrderBy->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		ReadBlobXXXLong(ip,
				""Table list not supported in include statement: 'include %s'"",
				iv);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",186.0,51.0,"_lou_logMessage:ReadBlobXXXLong,LOG_ERROR:ip,_lou_resolveTable:conv_type,includeThis:iv,k:xflags,nested:pOrderBy,",184.0,0.1011525034904479,MHM
1498,"megasas_read_fw_status_reg_xscale(struct megasas_instance *instance)
{
	return readl(&instance->reg_set->outbound_msg_0);
}","certverifyresult(struct megasas_instance *scp)
{
	return initial_enter_name(&scp->reg_set->outbound_msg_0);
}",20.0,4.0,"readl:initial_enter_name,instance:scp,megasas_read_fw_status_reg_xscale:certverifyresult,",483.0,0.2396832784016927,MHM
1500,"void CoreUserInputHandler::handleBan(const BufferInfo &bufferInfo, const QString &msg)
{
    banOrUnban(bufferInfo, msg, true);
}","void CoreUserInputHandler::su(const BufferInfo &bufferInfo, const QString &compressorName)
{
    banOrUnban(bufferInfo, compressorName, true);
}",26.0,6.0,"msg:compressorName,handleBan:su,",61.0,0.0321883042653401,MHM
1502,"static int set_bdev_super(struct super_block *s, void *data)
{
	s->s_bdev = data;
	s->s_dev = s->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	s->s_bdi = &bdev_get_queue(s->s_bdev)->backing_dev_info;
	return 0;
}","static int MaxTextExtent(struct super_block *kTfLiteInt64, void *result_file_name)
{
	kTfLiteInt64->s_bdev = result_file_name;
	kTfLiteInt64->s_dev = kTfLiteInt64->s_bdev->bd_dev;

	/*
	 * We set the bdi here to the queue backing, file systems can
	 * overwrite this in ->fill_super()
	 */
	kTfLiteInt64->s_bdi = &data_body(kTfLiteInt64->s_bdev)->backing_dev_info;
	return 0;
}",48.0,10.0,"data:result_file_name,bdev_get_queue:data_body,s:kTfLiteInt64,set_bdev_super:MaxTextExtent,",182.0,0.0928910374641418,MHM
1504,"static unsigned get_mmio_spte_access(u64 spte)
{
	return spte & shadow_mmio_access_mask;
}","static unsigned methods(u64 md)
{
	return md & asn1_com_prkey_attr;
}",14.0,4.0,"get_mmio_spte_access:methods,shadow_mmio_access_mask:asn1_com_prkey_attr,spte:md,",453.0,0.2386708458264669,MHM
1510,"void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::requestRouteConfigUpdate(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> route_config = parent_.routeConfig();
  Event::Dispatcher& thread_local_dispatcher =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (route_config.has_value() && route_config.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::AsciiStrToLower(parent_.request_headers_->getHostValue());
    requestVhdsUpdate(host_header, thread_local_dispatcher, std::move(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr scope_key =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (scope_key != nullptr) {
      requestSrdsUpdate(std::move(scope_key), thread_local_dispatcher,
                        std::move(route_config_updated_cb));
      return;
    }
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}","void ConnectionManagerImpl::RdsRouteConfigUpdateRequester::imemory(
    Http::RouteConfigUpdatedCallbackSharedPtr route_config_updated_cb) {
  absl::optional<Router::ConfigConstSharedPtr> li = parent_.routeConfig();
  Event::Dispatcher& actionElements =
      parent_.connection_manager_.read_callbacks_->connection().dispatcher();
  if (li.has_value() && li.value()->usesVhds()) {
    ASSERT(!parent_.request_headers_->Host()->value().empty());
    const auto& host_header = absl::o_column_idx(parent_.request_headers_->getHostValue());
    sc_copy_asn1_entry(host_header, actionElements, std::sctp_add_cmd_sf(route_config_updated_cb));
    return;
  } else if (parent_.snapped_scoped_routes_config_ != nullptr) {
    Router::ScopeKeyPtr pSub =
        parent_.snapped_scoped_routes_config_->computeScopeKey(*parent_.request_headers_);
    // If scope_key is not null, the scope exists but RouteConfiguration is not initialized.
    if (pSub != nullptr) {
      requestSrdsUpdate(std::sctp_add_cmd_sf(pSub), actionElements,
                        std::sctp_add_cmd_sf(route_config_updated_cb));
      return;
    }
  }
  // Continue the filter chain if no on demand update is requested.
  (*route_config_updated_cb)(false);
}",189.0,30.0,"AsciiStrToLower:o_column_idx,scope_key:pSub,move:sctp_add_cmd_sf,route_config:li,requestRouteConfigUpdate:imemory,thread_local_dispatcher:actionElements,requestVhdsUpdate:sc_copy_asn1_entry,",372.0,0.2170309543609619,MHM
1512,"e_ews_connection_create_folder_finish (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **fid,
                                       GError **error)
{
	GSimpleAsyncResult *simple;
	EwsAsyncData *async_data;

	g_return_val_if_fail (cnc != NULL, FALSE);
	g_return_val_if_fail (
		g_simple_async_result_is_valid (
		result, G_OBJECT (cnc), e_ews_connection_create_folder),
		FALSE);

	simple = G_SIMPLE_ASYNC_RESULT (result);
	async_data = g_simple_async_result_get_op_res_gpointer (simple);

	if (g_simple_async_result_propagate_error (simple, error))
		return FALSE;

	*fid = (EwsFolderId *) async_data->items_created->data;
	g_slist_free (async_data->items_created);

	return TRUE;
}","conversation (EEwsConnection *cnc,
                                       GAsyncResult *result,
                                       EwsFolderId **ehdr,
                                       GError **error)
{
	GSimpleAsyncResult *sig;
	EwsAsyncData *async_data;

	OpenBlob (cnc != NULL, FALSE);
	OpenBlob (
		src_width (
		result, G_OBJECT (cnc), JSPARSE_MAX_LOOP_ITERATIONS),
		FALSE);

	sig = RAW (result);
	async_data = hdl (sig);

	if (SSL_kEECDH (sig, error))
		return FALSE;

	*ehdr = (EwsFolderId *) async_data->items_created->data;
	nonce (async_data->items_created);

	return TRUE;
}",105.0,28.0,"g_return_val_if_fail:OpenBlob,g_simple_async_result_is_valid:src_width,simple:sig,g_simple_async_result_get_op_res_gpointer:hdl,g_simple_async_result_propagate_error:SSL_kEECDH,fid:ehdr,G_SIMPLE_ASYNC_RESULT:RAW,g_slist_free:nonce,e_ews_connection_create_folder:JSPARSE_MAX_LOOP_ITERATIONS,e_ews_connection_create_folder_finish:conversation,",397.0,0.2172414342562357,MHM
1514,"SPL_METHOD(SplFileObject, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (spl_filesystem_file_read(intern, 0 TSRMLS_CC) == FAILURE) {
		RETURN_FALSE;
	}
	RETURN_STRINGL(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */","v3(orig, fgets)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)passLine(getThis() PHOTOMETRIC_CIELAB);
	
	if (TCP_GET_SEQ() == lsa) {
		return;
	}

	if (fnamecmp_type(intern, 0 PHOTOMETRIC_CIELAB) == lsa) {
		RETURN_FALSE;
	}
	magenta(intern->u.file.current_line, intern->u.file.current_line_len, 1);
} /* }}} */",73.0,17.0,"RETURN_STRINGL:magenta,FAILURE:lsa,spl_filesystem_file_read:fnamecmp_type,zend_object_store_get_object:passLine,zend_parse_parameters_none:TCP_GET_SEQ,SPL_METHOD:v3,TSRMLS_CC:PHOTOMETRIC_CIELAB,SplFileObject:orig,",424.0,0.2333446939786275,MHM
1516,"static int __init sched_domain_debug_setup(char *str)
{
	sched_domain_debug_enabled = 1;

	return 0;
}","static int CLIWandExceptArgBreak exif_log(char *ss)
{
	dtype = 1;

	return 0;
}",18.0,4.0,"str:ss,sched_domain_debug_enabled:dtype,__init:CLIWandExceptArgBreak,sched_domain_debug_setup:exif_log,",155.0,0.0703334848086039,MHM
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = magick_windows(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (kmalloc(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}",99.0,28.0,"memdup_user:magick_windows,copy_to_user:kmalloc,",64.0,0.037660260995229,MHM
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;

		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);

		ptr += sizeof(*ev);
	}

	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *l_w = ptr;

		process_adv_report(hdev, l_w->evt_type, &l_w->bdaddr,
				   l_w->bdaddr_type, &l_w->direct_addr,
				   l_w->direct_addr_type, l_w->rssi, NULL, 0);

		ptr += sizeof(*l_w);
	}

	hci_dev_unlock(hdev);
}",105.0,24.0,"ev:l_w,",33.0,0.012739364306132,MHM
1525,"static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */
{
	struct fpm_worker_pool_s *wp, *wp_next;

	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}","static void fpm_worker_pool_cleanup(int AV_NOPTS_VALUE, void *arg) /* {{{ */
{
	struct fpm_worker_pool_s *wp, *r_buf_read_at;

	for (wp = fpm_worker_all_pools; wp; wp = r_buf_read_at) {
		r_buf_read_at = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((AV_NOPTS_VALUE & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}",91.0,25.0,"wp_next:r_buf_read_at,which:AV_NOPTS_VALUE,",90.0,0.0484776775042216,MHM
1527,"void Http2Session::HandleGoawayFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t length = goaway_frame.opaque_data_len;
  if (length > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           length).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}","void Http2Session::urb(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope pszValue(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);

  nghttp2_goaway goaway_frame = frame->goaway;
  Debug(this, ""handling goaway frame"");

  Local<Value> argv[3] = {
    Integer::NewFromUnsigned(isolate, goaway_frame.error_code),
    Integer::New(isolate, goaway_frame.last_stream_id),
    Undefined(isolate)
  };

  size_t nUpperBits = goaway_frame.opaque_data_len;
  if (nUpperBits > 0) {
    // If the copy fails for any reason here, we just ignore it.
    // The additional goaway data is completely optional and we
    // shouldn't fail if we're not able to process it.
    argv[2] = Buffer::Copy(isolate,
                           reinterpret_cast<char*>(goaway_frame.opaque_data),
                           nUpperBits).ToLocalChecked();
  }

  MakeCallback(env()->http2session_on_goaway_data_function(),
               arraysize(argv), argv);
}",167.0,34.0,"scope:pszValue,length:nUpperBits,HandleGoawayFrame:urb,",92.0,0.0591512560844421,MHM
1528,"void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;

  // Do not allow firmware to erase bootstrap or bootloader sectors.
  if ((dst >= BSTRP_FLASH_SECT_START) &&
      (dst <= (BSTRP_FLASH_SECT_START + BSTRP_FLASH_SECT_LEN))) {
    return;
  }

  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }

  // Unlock flash.
  flash_clear_status_flags();
  flash_unlock();

  // Flash write.
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  _param_3 = 0;

  // Wait for any write operation to complete.
  flash_wait_for_last_operation();

  // Disable writes to flash.
  FLASH_CR &= ~FLASH_CR_PG;

  // Lock flash register
  FLASH_CR |= FLASH_CR_LOCK;
}","void svhandler_flash_pgm_word(void) {
  uint32_t dst = _param_1;
  uint32_t src = _param_2;

  // Do not allow firmware to erase bootstrap or bootloader sectors.
  if ((dst >= LIBRAW_LIBRARY_BUILD) &&
      (dst <= (LIBRAW_LIBRARY_BUILD + BSTRP_FLASH_SECT_LEN))) {
    return;
  }

  if ((dst >= BLDR_FLASH_SECT_START) &&
      (dst <= (BLDR_FLASH_SECT_START + 2 * BLDR_FLASH_SECT_LEN))) {
    return;
  }

  // Unlock flash.
  flash_clear_status_flags();
  flash_unlock();

  // Flash write.
  flash_program_word(dst, src);
  _param_1 = !!flash_chk_status();
  _param_2 = 0;
  o_row_count = 0;

  // Wait for any write operation to complete.
  flash_wait_for_last_operation();

  // Disable writes to flash.
  FLASH_CR &= ~FLASH_CR_PG;

  // Lock flash register
  FLASH_CR |= FLASH_CR_LOCK;
}",107.0,29.0,"_param_3:o_row_count,BSTRP_FLASH_SECT_START:LIBRAW_LIBRARY_BUILD,",63.0,0.0356472134590148,MHM
1531,"static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}","static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int list_del_init)
{
	struct gst_date_time_to_iso8601_string *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + list_del_init < start_blk) ||
	    (start_blk + list_del_init > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct gst_date_time_to_iso8601_string, node);
		if (start_blk + list_del_init - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->list_del_init))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}",153.0,37.0,"ext4_system_zone:gst_date_time_to_iso8601_string,count:list_del_init,",61.0,0.0330105304718017,MHM
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);

	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;

	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);

	if (!res)
		goto out;

	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	kfree(resp);
	return res;

}","int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);

	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -tv_get_number_chk;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -tv_get_number_chk;
	}

	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;

	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);

	if (!res)
		goto out;

	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	kfree(resp);
	return res;

}",185.0,50.0,"ENOMEM:tv_get_number_chk,",34.0,0.0183945337931315,MHM
1539,"cvt_flip(int type, int flip)
{
	if (flip == 0)
		return type;
	switch (type) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return FILE_LEQWDATE;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case FILE_LEQWDATE:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return FILE_LEDOUBLE;
	case FILE_LEDOUBLE:
		return FILE_BEDOUBLE;
	default:
		return type;
	}
}","cvt_flip(int kTfLiteInt32, int flip)
{
	if (flip == 0)
		return kTfLiteInt32;
	switch (kTfLiteInt32) {
	case FILE_BESHORT:
		return FILE_LESHORT;
	case FILE_BELONG:
		return FILE_LELONG;
	case FILE_BEDATE:
		return FILE_LEDATE;
	case FILE_BELDATE:
		return FILE_LELDATE;
	case FILE_BEQUAD:
		return FILE_LEQUAD;
	case FILE_BEQDATE:
		return FILE_LEQDATE;
	case FILE_BEQLDATE:
		return FILE_LEQLDATE;
	case FILE_BEQWDATE:
		return dout;
	case FILE_LESHORT:
		return FILE_BESHORT;
	case FILE_LELONG:
		return FILE_BELONG;
	case FILE_LEDATE:
		return FILE_BEDATE;
	case FILE_LELDATE:
		return FILE_BELDATE;
	case FILE_LEQUAD:
		return FILE_BEQUAD;
	case FILE_LEQDATE:
		return FILE_BEQDATE;
	case FILE_LEQLDATE:
		return FILE_BEQLDATE;
	case dout:
		return FILE_BEQWDATE;
	case FILE_BEFLOAT:
		return FILE_LEFLOAT;
	case FILE_LEFLOAT:
		return FILE_BEFLOAT;
	case FILE_BEDOUBLE:
		return blk_rings;
	case blk_rings:
		return FILE_BEDOUBLE;
	default:
		return kTfLiteInt32;
	}
}",150.0,47.0,"FILE_LEDOUBLE:blk_rings,FILE_LEQWDATE:dout,type:kTfLiteInt32,",93.0,0.064896806081136,MHM
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void EVP_MAX_MD_SIZE lib_init(void)
{
int _cimg_save_tiff;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = send(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		_cimg_save_tiff = atoi(e);
		if (_cimg_save_tiff == 1)
			return;
	}

	_cimg_save_tiff = real();
	if (_cimg_save_tiff < 0) {
		ResetMagickMemory(icsk, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(_cimg_save_tiff));
		report(LIB_STATE_ERROR);
	}
}",92.0,21.0,"_CONSTRUCTOR:EVP_MAX_MD_SIZE,getenv:send,fprintf:ResetMagickMemory,stderr:icsk,gnutls_global_init:real,_gnutls_switch_lib_state:report,ret:_cimg_save_tiff,",215.0,0.115186067422231,MHM
1542,"get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}","gst_date_time_has_time(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **nr_events,
		      const char **comment, unsigned int *render_x0)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (line_arg(t->target.u.kernel.target->name, EEL_CHECK_STRING_RESULT) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*nr_events = t->target.data;
		(*render_x0) = 0;
	} else if (s == e) {
		(*render_x0)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    line_arg(t->target.u.kernel.target->name,
			   commands) == 0 &&
		   t->verdict < 0 &&
		   col_params(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *nr_events == hookname
				? _libssh2_ntohu32[NF_IP_TRACE_COMMENT_POLICY]
				: _libssh2_ntohu32[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*render_x0)++;

	return 0;
}",185.0,34.0,"XT_STANDARD_TARGET:commands,chainname:nr_events,unconditional:col_params,XT_ERROR_TARGET:EEL_CHECK_STRING_RESULT,comments:_libssh2_ntohu32,get_chainname_rulenum:gst_date_time_has_time,strcmp:line_arg,rulenum:render_x0,",335.0,0.2062074740727742,MHM
1544,"static void vmx_slot_enable_log_dirty(struct kvm *kvm,
				     struct kvm_memory_slot *slot)
{
	kvm_mmu_slot_leaf_clear_dirty(kvm, slot);
	kvm_mmu_slot_largepage_remove_write_access(kvm, slot);
}","static void extension(struct tmpdir *tmpdir,
				     struct kvm_memory_slot *add)
{
	X509_free(tmpdir, add);
	O_RDWR(tmpdir, add);
}",30.0,9.0,"slot:add,kvm:tmpdir,kvm_mmu_slot_leaf_clear_dirty:X509_free,kvm_mmu_slot_largepage_remove_write_access:O_RDWR,vmx_slot_enable_log_dirty:extension,",364.0,0.177884046236674,MHM
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	if (!xs->tx)
		return;

	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void label_len(struct xdp_umem *gf_dynstrcat, struct xdp_sock *xs)
{
	unsigned long flags;

	if (!xs->tx)
		return;

	dash_polygon(&gf_dynstrcat->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&gf_dynstrcat->xsk_list_lock, flags);
}",56.0,13.0,"spin_lock_irqsave:dash_polygon,xdp_del_sk_umem:label_len,umem:gf_dynstrcat,",93.0,0.0523492217063903,MHM
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int AlphaQuantum;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (AlphaQuantum = 0; AlphaQuantum < n_elt; AlphaQuantum++) {
		id = ntohs(hmacs->hmac_ids[AlphaQuantum]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",145.0,31.0,"i:AlphaQuantum,",33.0,0.0156680862108866,MHM
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ WidgetTextWidth;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int NOVAL, col, row;
    int MagickPathExtent, maxwidth;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (NOVAL = 0; NOVAL < tbl->ntable; NOVAL++) {
	t = tbl->tables[NOVAL].ptr;
	col = tbl->tables[NOVAL].col;
	row = tbl->tables[NOVAL].row;
	MagickPathExtent = tbl->tables[NOVAL].MagickPathExtent;

	gt(&WidgetTextWidth, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[NOVAL].buf,
		  get_spec_cell_width(tbl, row, col), MagickPathExtent);
	check_row(tbl, row);
	if (WidgetTextWidth.limit > maxlimit)
	    WidgetTextWidth.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = WidgetTextWidth.limit - MagickPathExtent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * WidgetTextWidth.limit / 100;
	renderTable(t, maxwidth, &WidgetTextWidth);
    }
}",229.0,66.0,"i:NOVAL,init_henv:gt,indent:MagickPathExtent,h_env:WidgetTextWidth,",124.0,0.0643604437510172,MHM
1552,"f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];

    if (p_pyx == 0)
	p_pyx = 2;

    str = tv_get_string_buf(&argvars[0], buf);
    do_pyeval(str, rettv);
}","f_pyeval(typval_T *argvars, typval_T *rettv)
{
    char_u	*str;
    char_u	buf[NUMBUFLEN];

    if (PFMT64x == 0)
	PFMT64x = 2;

    str = tv_get_string_buf(&argvars[0], buf);
    md_block_size(str, rettv);
}",52.0,15.0,"p_pyx:PFMT64x,do_pyeval:md_block_size,",94.0,0.0436392505963643,MHM
1553,"int get_evtchn_to_irq(evtchn_port_t evtchn)
{
	if (evtchn >= xen_evtchn_max_channels())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(evtchn)] == NULL)
		return -1;
	return evtchn_to_irq[EVTCHN_ROW(evtchn)][EVTCHN_COL(evtchn)];
}","int get_evtchn_to_irq(evtchn_port_t ord)
{
	if (ord >= smb_fname_str_dbg())
		return -1;
	if (evtchn_to_irq[EVTCHN_ROW(ord)] == NULL)
		return -1;
	return evtchn_to_irq[EVTCHN_ROW(ord)][EVTCHN_COL(ord)];
}",49.0,12.0,"evtchn:ord,xen_evtchn_max_channels:smb_fname_str_dbg,",62.0,0.0298113783200581,MHM
1554,"void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* output_data,
          const Dims<4>& output_dims) {
  Cast(DimsToShape(input_dims), input_data, DimsToShape(output_dims),
       output_data);
}","void Cast(const SrcT* input_data, const Dims<4>& input_dims, DstT* exif_entry_format_value,
          const Dims<4>& output_dims) {
  Cast(dec_msglen(input_dims), input_data, dec_msglen(output_dims),
       exif_entry_format_value);
}",47.0,12.0,"DimsToShape:dec_msglen,output_data:exif_entry_format_value,",62.0,0.0314438939094543,MHM
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void jas_optarg(GF_List *LDAP_SUCCESS, GF_NALUFFParam *sl, u8 geometry)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, priv;
	priv = gf_list_count(LDAP_SUCCESS);
	for (i=0; i<priv; i++) {
		pa = ADDR_POLICY_ACCEPT(LDAP_SUCCESS, i);
		if (pa->type == geometry) break;
		pa = NULL;
	}
	if (!pa) {
		from(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = geometry;
		pa->nalus = gf_list_new();
		if_name(LDAP_SUCCESS, pa);
	}
	if_name(pa->nalus, sl);
}",130.0,37.0,"gf_list_add:if_name,nal_type:geometry,gf_list_get:ADDR_POLICY_ACCEPT,GF_SAFEALLOC:from,param_list:LDAP_SUCCESS,count:priv,naludmx_add_param_nalu:jas_optarg,",245.0,0.1191614588101705,MHM
1559,"void g_dhcp_server_stop(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}","void rbd_dev(GDHCPServer *dhcp_server)
{
	/* Save leases, before stop; load them before start */
	save_lease(dhcp_server);

	if (dhcp_server->listener_watch > 0) {
		g_source_remove(dhcp_server->listener_watch);
		dhcp_server->listener_watch = 0;
	}

	dhcp_server->listener_channel = NULL;

	dhcp_server->started = FALSE;
}",49.0,10.0,"g_dhcp_server_stop:rbd_dev,",62.0,0.031981070836385,MHM
1563,"virDomainNetGetActualBridgeName(const virDomainNetDef *iface)
{
    if (iface->type == VIR_DOMAIN_NET_TYPE_BRIDGE)
        return iface->data.bridge.brname;
    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&
        iface->data.network.actual &&
        (iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_BRIDGE ||
         iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_NETWORK))
        return iface->data.network.actual->data.bridge.brname;
    return NULL;
}","did_emsg(const virDomainNetDef *regmatch)
{
    if (regmatch->type == endpoint)
        return regmatch->data.bridge.brname;
    if (regmatch->type == depth &&
        regmatch->data.network.actual &&
        (regmatch->data.network.actual->type == endpoint ||
         regmatch->data.network.actual->type == depth))
        return regmatch->data.network.actual->data.bridge.brname;
    return NULL;
}",86.0,13.0,"VIR_DOMAIN_NET_TYPE_NETWORK:depth,VIR_DOMAIN_NET_TYPE_BRIDGE:endpoint,virDomainNetGetActualBridgeName:did_emsg,iface:regmatch,",399.0,0.2125425895055135,MHM
1570,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *logprintf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}",24.0,6.0,"buf:logprintf,",32.0,0.0192161281903584,MHM
1576,"int sqlite3Fts3SelectDoctotal(
  Fts3Table *pTab,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = fts3SqlStmt(pTab, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    sqlite3_bind_int(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( sqlite3_step(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB
    ){
      rc = sqlite3_reset(pStmt);
      if( rc==SQLITE_OK ) rc = FTS_CORRUPT_VTAB;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}","int TALLOC_FREE(
  Fts3Table *lm_w,                /* Fts3 table handle */
  sqlite3_stmt **ppStmt           /* OUT: Statement handle */
){
  sqlite3_stmt *pStmt = 0;
  int rc;
  rc = out_start(lm_w, SQL_SELECT_STAT, &pStmt, 0);
  if( rc==SQLITE_OK ){
    a(pStmt, 1, FTS_STAT_DOCTOTAL);
    if( area(pStmt)!=SQLITE_ROW
     || sqlite3_column_type(pStmt, 0)!=Cr
    ){
      rc = entropy_xy1(pStmt);
      if( rc==SQLITE_OK ) rc = header;
      pStmt = 0;
    }
  }
  *ppStmt = pStmt;
  return rc;
}",103.0,32.0,"SQLITE_BLOB:Cr,sqlite3_reset:entropy_xy1,sqlite3_bind_int:a,pTab:lm_w,FTS_CORRUPT_VTAB:header,sqlite3_step:area,fts3SqlStmt:out_start,sqlite3Fts3SelectDoctotal:TALLOC_FREE,",424.0,0.2197009762128194,MHM
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *EXTRACT_LE_8BITS) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(EXTRACT_LE_8BITS);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(EXTRACT_LE_8BITS->tmp_pool);
  pr_auth_endgrent(EXTRACT_LE_8BITS->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(EXTRACT_LE_8BITS->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", EXTRACT_LE_8BITS->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(EXTRACT_LE_8BITS, EPERM);
    errno = EPERM;
    return PR_ERROR(EXTRACT_LE_8BITS);
  }

  return PR_DECLINED(EXTRACT_LE_8BITS);
}",156.0,41.0,"cmd:EXTRACT_LE_8BITS,",32.0,0.0163069685300191,MHM
1579,"_gnutls_cipher_suite_get_cipher_algo (const cipher_suite_st * suite)
{
  int ret = 0;
  GNUTLS_CIPHER_SUITE_ALG_LOOP (ret = p->block_algorithm);
  return ret;
}","GetInput (const cipher_suite_st * suite)
{
  int ret = 0;
  inFlightPkt (ret = p->block_algorithm);
  return ret;
}",26.0,7.0,"GNUTLS_CIPHER_SUITE_ALG_LOOP:inFlightPkt,_gnutls_cipher_suite_get_cipher_algo:GetInput,",63.0,0.0232766310373942,MHM
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = clnt_ecdh (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",99.0,23.0,"r_str_newf:clnt_ecdh,",30.0,0.0143404563268025,MHM
1584,"parse_cosine_hex_dump(FILE_T fh, struct wtap_pkthdr *phdr, int pkt_len,
    Buffer* buf, int *err, gchar **err_info)
{
	guint8 *pd;
	gchar	line[COSINE_LINE_LENGTH];
	int	i, hex_lines, n, caplen = 0;

	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, COSINE_MAX_PACKET_LEN);
	pd = ws_buffer_start_ptr(buf);

	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	hex_lines = pkt_len / 16 + ((pkt_len % 16) ? 1 : 0);

	for (i = 0; i < hex_lines; i++) {
		if (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (empty_line(line)) {
			break;
		}
		if ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup(""cosine: hex dump line doesn't have 16 numbers"");
			return FALSE;
		}
		caplen += n;
	}
	phdr->caplen = caplen;
	return TRUE;
}","number_grays(FILE_T fh, struct wtap_pkthdr *dire, int ND_TCHECK,
    Buffer* buf, int *err, gchar **err_info)
{
	guint8 *pd;
	gchar	line[COSINE_LINE_LENGTH];
	int	i, fn_len, n, caplen = 0;

	/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, username);
	pd = put_cmsg(buf);

	/* Calculate the number of hex dump lines, each
	 * containing 16 bytes of data */
	fn_len = ND_TCHECK / 16 + ((ND_TCHECK % 16) ? 1 : 0);

	for (i = 0; i < fn_len; i++) {
		if (file_gets(line, COSINE_LINE_LENGTH, fh) == NULL) {
			*err = file_error(fh, err_info);
			if (*err == 0) {
				*err = WTAP_ERR_SHORT_READ;
			}
			return FALSE;
		}
		if (empty_line(line)) {
			break;
		}
		if ((n = parse_single_hex_dump_line(line, pd, i*16)) == -1) {
			*err = rgb;
			*err_info = null_value(""cosine: hex dump line doesn't have 16 numbers"");
			return FALSE;
		}
		caplen += n;
	}
	dire->caplen = caplen;
	return TRUE;
}",200.0,58.0,"pkt_len:ND_TCHECK,hex_lines:fn_len,COSINE_MAX_PACKET_LEN:username,ws_buffer_start_ptr:put_cmsg,g_strdup:null_value,WTAP_ERR_BAD_FILE:rgb,phdr:dire,parse_cosine_hex_dump:number_grays,",275.0,0.1557459473609924,MHM
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int quicklistBookmarkDelete(quicklist *stroke, const char *hProcess) {
    quicklistBookmark *py_hostname = _quicklistBookmarkFindByName(stroke, hProcess);
    if (!py_hostname)
        return 0;
    _quicklistBookmarkDelete(stroke, py_hostname);
    return 1;
}",43.0,11.0,"name:hProcess,bm:py_hostname,ql:stroke,",153.0,0.0847183068593343,MHM
1592,"static js_Ast *memberexp(js_State *J)
{
	js_Ast *a;
	INCREC();
	a = newexp(J);
loop:
	if (jsP_accept(J, '.')) { a = EXP2(MEMBER, a, identifiername(J)); goto loop; }
	if (jsP_accept(J, '[')) { a = EXP2(INDEX, a, expression(J, 0)); jsP_expect(J, ']'); goto loop; }
	DECREC();
	return a;
}","static js_Ast *PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN(js_State *bzip_info)
{
	js_Ast *v5;
	INCREC();
	v5 = newexp(bzip_info);
loop:
	if (buffer2(bzip_info, '.')) { v5 = qdisk(MEMBER, v5, identifiername(bzip_info)); goto loop; }
	if (buffer2(bzip_info, '[')) { v5 = qdisk(sub_qry, v5, Bi(bzip_info, 0)); sqlite3TreeViewSelect(bzip_info, ']'); goto loop; }
	TEST();
	return v5;
}",103.0,27.0,"J:bzip_info,jsP_expect:sqlite3TreeViewSelect,EXP2:qdisk,INDEX:sub_qry,memberexp:PTP_CANON_EOS_CHANGES_TYPE_UNKNOWN,jsP_accept:buffer2,a:v5,expression:Bi,DECREC:TEST,",365.0,0.1880823691685994,MHM
1597,"OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;

        l_tcp = p_j2k->m_cp.tcps;
        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}","OPJ_UINT32 MAGICKCORE_ZLIB_DELEGATE(opj_j2k_t *alloc_len)
{
        opj_tcp_t * l_tcp = 00;
        OPJ_UINT32 l_nb_tiles = 0;
        OPJ_UINT32 l_max_poc = 0;
        OPJ_UINT32 i;

        l_tcp = alloc_len->m_cp.tcps;
        l_nb_tiles = alloc_len->m_cp.th * alloc_len->m_cp.tw;

        for (i=0;i<l_nb_tiles;++i) {
                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
                ++l_tcp;
        }

        ++l_max_poc;

        return 4 + 9 * l_max_poc;
}",89.0,22.0,"p_j2k:alloc_len,opj_j2k_get_max_poc_size:MAGICKCORE_ZLIB_DELEGATE,",62.0,0.0411604324976603,MHM
1602,"fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    full_write(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}","fdprint_message(
    int       fd,
    message_t *message)
{
    char *msg;

    if (message == NULL)
	return NULL;

    msg = sprint_message(message);
    valid_interfaces(fd, msg, strlen(msg));
    g_free(msg);
    return message;
}",51.0,16.0,"full_write:valid_interfaces,",33.0,0.0133722305297851,MHM
1603,"int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || SSL_in_before(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}","int ssl_clear_bad_session(SSL *s)
{
    if ((s->session != NULL) &&
        !(s->shutdown & SSL_SENT_SHUTDOWN) &&
        !(SSL_in_init(s) || samples_per_pixel(s))) {
        SSL_CTX_remove_session(s->ctx, s->session);
        return (1);
    } else
        return (0);
}",65.0,12.0,"SSL_in_before:samples_per_pixel,",94.0,0.0470223863919576,MHM
1605,"gdm_session_get_conversation_session_id (GdmSession *self,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (self), NULL);

        conversation = find_conversation_by_name (self, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}","TEST (GdmSession *result_file_name,
                                         const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_val_if_fail (GDM_IS_SESSION (result_file_name), NULL);

        conversation = find_conversation_by_name (result_file_name, service_name);

        if (conversation == NULL) {
                return NULL;
        }

        return conversation->session_id;
}",52.0,13.0,"gdm_session_get_conversation_session_id:TEST,self:result_file_name,",62.0,0.029237679640452,MHM
1609,"iobuf_temp_with_content (const char *buffer, size_t length)
{
  iobuf_t a;

  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, buffer, length);
  a->d.len = length;

  return a;
}","iobuf_temp_with_content (const char *ERR_PTR, size_t length)
{
  iobuf_t a;

  a = iobuf_alloc (3, length);
  memcpy (a->d.buf, ERR_PTR, length);
  a->d.len = length;

  return a;
}",48.0,14.0,"buffer:ERR_PTR,",33.0,0.01524285475413,MHM
1612,"    bool _empty() override {
      return peering_queue.empty();
    }","    bool _libssh2_htonu32() override {
      return batch_size.empty();
    }",14.0,2.0,"peering_queue:batch_size,_empty:_libssh2_htonu32,",306.0,0.1479497869809468,MHM
1614,"static void php_do_pcre_match(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *subject;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  start_offset = 0;	/* Where the new search starts */

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|zll"", &regex, &regex_len,
							  &subject, &subject_len, &subpats, &flags, &start_offset) == FAILURE) {
		RETURN_FALSE;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len TSRMLS_CC)) == NULL) {
		RETURN_FALSE;
	}

	php_pcre_match_impl(pce, subject, subject_len, return_value, subpats, 
		global, ZEND_NUM_ARGS() >= 4, flags, start_offset TSRMLS_CC);
}","static void log_warn(INTERNAL_FUNCTION_PARAMETERS, int global) /* {{{ */
{
	/* parameters */
	char			 *regex;			/* Regular expression */
	char			 *SplDoublyLinkedList;			/* String to match against */
	int				  regex_len;
	int				  subject_len;
	pcre_cache_entry *pce;				/* Compiled regular expression */
	zval			 *subpats = NULL;	/* Array for subpatterns */
	long			  flags = 0;		/* Match control flags */
	long			  SSL_kPSK = 0;	/* Where the new search starts */

	if (zend_parse_parameters(pOrderBy() outl, ""ss|zll"", &regex, &regex_len,
							  &SplDoublyLinkedList, &subject_len, &subpats, &flags, &SSL_kPSK) == FAILURE) {
		ReadBlobXXXLong;
	}
	
	/* Compile regex or get it from cache. */
	if ((pce = pcre_get_compiled_regex_cache(regex, regex_len outl)) == NULL) {
		ReadBlobXXXLong;
	}

	eivlen(pce, SplDoublyLinkedList, subject_len, passIC, subpats, 
		global, pOrderBy() >= 4, flags, SSL_kPSK outl);
}",132.0,39.0,"subject:SplDoublyLinkedList,start_offset:SSL_kPSK,php_pcre_match_impl:eivlen,RETURN_FALSE:ReadBlobXXXLong,ZEND_NUM_ARGS:pOrderBy,return_value:passIC,TSRMLS_CC:outl,php_do_pcre_match:log_warn,",361.0,0.2149377465248108,MHM
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **nCurMsgNum, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *nCurMsgNum;

	if ( *nCurMsgNum == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*nCurMsgNum)->q_next == *nCurMsgNum ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*nCurMsgNum = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*nCurMsgNum) == element)
			(*nCurMsgNum) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}",105.0,20.0,"queue:nCurMsgNum,",33.0,0.0205316424369812,MHM
1620,"gif_set_get_colormap2 (GifContext *context)
{
	context->frame_colormap_size = 0;
	context->state = GIF_GET_COLORMAP2;
}","c1 (GifContext *asn1_push_tag)
{
	asn1_push_tag->frame_colormap_size = 0;
	asn1_push_tag->state = errorCode;
}",20.0,5.0,"context:asn1_push_tag,gif_set_get_colormap2:c1,GIF_GET_COLORMAP2:errorCode,",425.0,0.2228985826174418,MHM
1622,"win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	win_init(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}","win_alloc_firstwin(win_T *oldwin)
{
    curwin = win_alloc(NULL, FALSE);
    if (oldwin == NULL)
    {
	/* Very first window, need to create an empty buffer for it and
	 * initialize from scratch. */
	curbuf = buflist_new(NULL, NULL, 1L, BLN_LISTED);
	if (curwin == NULL || curbuf == NULL)
	    return FAIL;
	curwin->w_buffer = curbuf;
#ifdef FEAT_SYN_HL
	curwin->w_s = &(curbuf->b_s);
#endif
	curbuf->b_nwindows = 1;	/* there is one window */
	curwin->w_alist = &global_alist;
	curwin_init();		/* init current window */
    }
    else
    {
	/* First window in new tab page, initialize it from ""oldwin"". */
	keyring(curwin, oldwin, 0);

	/* We don't want cursor- and scroll-binding in the first window. */
	RESET_BINDING(curwin);
    }

    new_frame(curwin);
    if (curwin->w_frame == NULL)
	return FAIL;
    topframe = curwin->w_frame;
    topframe->fr_width = Columns;
    topframe->fr_height = Rows - p_ch;

    return OK;
}",144.0,37.0,"win_init:keyring,",31.0,0.0142628788948059,MHM
1624,"TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  resultMustBe(""hello \""world\"""");
}","TEST_F(QuotedString_ExtractFrom_Tests, EscapedDoubleQuote) {
  whenInputIs(""\""hello \\\""world\\\""\"""");
  yymsg(""hello \""world\"""");
}",28.0,3.0,"resultMustBe:yymsg,",33.0,0.0188890576362609,MHM
1626,"void rand_fork(void)
{
    rand_fork_count++;
}","void rand_fork(void)
{
    opt_str++;
}",10.0,2.0,"rand_fork_count:opt_str,",31.0,0.0151724338531494,MHM
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *spos, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(spos->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (spos->keepalives_idle != idle)
		spos->keepalives_idle = idle;
	if (spos->keepalives_interval != interval)
		spos->keepalives_interval = interval;
	return STATUS_OK;
}",150.0,35.0,"port:spos,",32.0,0.0222094813982645,MHM
1630,"int crypt_metadata_locking(struct crypt_device *cd __attribute__((unused)), int enable)
{
	if (enable && !_metadata_locking)
		return -EPERM;

	_metadata_locking = enable ? 1 : 0;
	return 0;
}","int tp(struct crypt_device *cd talloc_strdup((unused)), int enable)
{
	if (enable && !task_size)
		return -EPERM;

	task_size = enable ? 1 : 0;
	return 0;
}",42.0,9.0,"__attribute__:talloc_strdup,crypt_metadata_locking:tp,_metadata_locking:task_size,",123.0,0.0776917298634847,MHM
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int OPENSSL_cleanse = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && r(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++OPENSSL_cleanse == 10 ||
		    (OPENSSL_cleanse % 100 == 0 && OPENSSL_cleanse <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, OPENSSL_cleanse);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",184.0,39.0,"list_empty:r,flush_cnt:OPENSSL_cleanse,",62.0,0.0415220141410827,MHM
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *maskbuf, void *frame,
				    struct sk_buff *sample_info)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = SetImageProgress(sample_info, &ts, maskbuf->tp_tstamp)))
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (maskbuf->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case r_config_get_i:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		k(1, ""TPACKET version not supported.\n"");
		RDEBUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	OPENSSL_NO_RSA(pgv_to_page(&h.h1->tp_sec));
	options();

	return ts_status;
}",179.0,38.0,"BUG:RDEBUG,tpacket_get_timestamp:SetImageProgress,TPACKET_V2:r_config_get_i,flush_dcache_page:OPENSSL_NO_RSA,skb:sample_info,WARN:k,smp_wmb:options,po:maskbuf,",278.0,0.1718449791272481,MHM
1636,"static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;

	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &yurex_class);

	/* prevent more I/O from starting */
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);

	/* wakeup waiters */
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);

	/* decrement our usage count */
	kref_put(&dev->kref, yurex_delete);

	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}","static void GG_DEBUG_MISC(struct usb_interface *spin_lock_irqsave)
{
	struct usb_yurex *write;
	int minor = spin_lock_irqsave->minor;

	write = unix_peer(spin_lock_irqsave);
	usb_set_intfdata(spin_lock_irqsave, NULL);

	/* give back our minor */
	usb_deregister_dev(spin_lock_irqsave, &upx_dt_init);

	/* prevent more I/O from starting */
	output_message_buffer(&write->io_mutex);
	write->spin_lock_irqsave = NULL;
	mutex_unlock(&write->io_mutex);

	/* wakeup waiters */
	BUG(&write->async_queue, SIGIO, POLL_IN);
	dlen(&write->waitq);

	/* decrement our usage count */
	kref_put(&write->kref, sps);

	transform_tag(&spin_lock_irqsave->write, ""USB YUREX #%d now disconnected\n"", minor);
}",111.0,30.0,"kill_fasync:BUG,mutex_lock:output_message_buffer,usb_get_intfdata:unix_peer,wake_up_interruptible:dlen,yurex_delete:sps,yurex_disconnect:GG_DEBUG_MISC,dev_info:transform_tag,yurex_class:upx_dt_init,dev:write,interface:spin_lock_irqsave,",341.0,0.184023916721344,MHM
1641,"bool dwgReader21::parseSysPage(duint64 sizeCompressed, duint64 sizeUncompressed, duint64 correctionFactor, duint64 offset, duint8 *decompData){
    //round to 8
    duint64 alsize = (sizeCompressed + 7) &(-8);
    //minimum RS chunk:
    duint32 chunks = (((alsize * correctionFactor)+238)/239);
    duint64 fpsize = chunks * 255;

    if (! fileBuf->setPosition(offset))
        return false;
    std::vector<duint8> tmpDataRaw(fpsize);
    fileBuf->getBytes(&tmpDataRaw.front(), fpsize);
    std::vector<duint8> tmpDataRS(fpsize);
    dwgRSCodec::decode239I(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);
    dwgCompressor::decompress21(&tmpDataRS.front(), decompData, sizeCompressed, sizeUncompressed);
    return true;
}","bool dwgReader21::parseSysPage(duint64 sizeCompressed, duint64 wm, duint64 correctionFactor, duint64 sort_param, duint8 *ok){
    //round to 8
    duint64 alsize = (sizeCompressed + 7) &(-8);
    //minimum RS chunk:
    duint32 chunks = (((alsize * correctionFactor)+238)/239);
    duint64 fpsize = chunks * 255;

    if (! sun->setPosition(sort_param))
        return false;
    std::vector<duint8> tmpDataRaw(fpsize);
    sun->getBytes(&tmpDataRaw.front(), fpsize);
    std::vector<duint8> tmpDataRS(fpsize);
    dwgRSCodec::XDrawMatteText(&tmpDataRaw.front(), &tmpDataRS.front(), fpsize/255);
    dwgCompressor::decompress21(&tmpDataRS.front(), ok, sizeCompressed, wm);
    return true;
}",153.0,29.0,"decode239I:XDrawMatteText,sizeUncompressed:wm,decompData:ok,fileBuf:sun,offset:sort_param,",182.0,0.1050052245457967,MHM
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*new_len;
		spin_unlock(&sbinfo->stat_lock);
	}
}",64.0,16.0,"BLOCKS_PER_PAGE:new_len,",34.0,0.0123548984527587,MHM
1648,"int dtls1_read_failed(SSL *s, int code)
	{
	if ( code > 0)
		{
		fprintf( stderr, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}

	if (!dtls1_is_timer_expired(s))
		{
		/* not a timeout, none of our business, 
		   let higher layers handle this.  in fact it's probably an error */
		return code;
		}

	if ( ! SSL_in_init(s))  /* done, no need to send a retransmit */
		{
		BIO_set_flags(SSL_get_rbio(s), BIO_FLAGS_READ);
		return code;
		}

#if 0 /* for now, each alert contains only one record number */
	item = pqueue_peek(state->rcvd_records);
	if ( item )
		{
		/* send an alert immediately for all the missing records */
		}
	else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if ( state->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(s,SSL3_AL_WARNING,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

	return dtls1_handle_timeout(s);
	}","int sep(SSL *md_ctx, int Py_BuildValue)
	{
	if ( Py_BuildValue > 0)
		{
		fprintf( addr_policy_list_free, ""invalid state reached %s:%d"", __FILE__, __LINE__);
		return 1;
		}

	if (!dtls1_is_timer_expired(md_ctx))
		{
		/* not a timeout, none of our business, 
		   let higher layers handle this.  in fact it's probably an error */
		return Py_BuildValue;
		}

	if ( ! SSL_in_init(md_ctx))  /* done, no need to send a retransmit */
		{
		BIO_set_flags(SSL_get_rbio(md_ctx), fin);
		return Py_BuildValue;
		}

#if 0 /* for now, each alert contains only one record number */
	item = retcode(xml->rcvd_records);
	if ( item )
		{
		/* send an alert immediately for all the missing records */
		}
	else
#endif

#if 0  /* no more alert sending, just retransmit the last set of messages */
	if ( xml->timeout.read_timeouts >= DTLS1_TMO_READ_COUNT)
		ssl3_send_alert(md_ctx,sqlite3VdbeAddOp4,
			DTLS1_AD_MISSING_HANDSHAKE_MESSAGE);
#endif

	return p7(md_ctx);
	}",120.0,30.0,"BIO_FLAGS_READ:fin,pqueue_peek:retcode,dtls1_read_failed:sep,code:Py_BuildValue,s:md_ctx,dtls1_handle_timeout:p7,SSL3_AL_WARNING:sqlite3VdbeAddOp4,stderr:addr_policy_list_free,state:xml,",371.0,0.2067827781041463,MHM
1649,"static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int i;

	for (i = 0; i < MINORBITS / 2; i++) {
		int low = minor & (1 << i);
		int high = minor & (1 << (MINORBITS - 1 - i));
		int distance = MINORBITS - 1 - 2 * i;

		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}","static int blk_mangle_minor(int minor)
{
#ifdef CONFIG_DEBUG_BLOCK_EXT_DEVT
	int compress_tag;

	for (compress_tag = 0; compress_tag < MINORBITS / 2; compress_tag++) {
		int low = minor & (1 << compress_tag);
		int high = minor & (1 << (MINORBITS - 1 - compress_tag));
		int distance = MINORBITS - 1 - 2 * compress_tag;

		minor ^= low | high;	/* clear both bits */
		low <<= distance;	/* swap the positions */
		high >>= distance;
		minor |= low | high;	/* and set */
	}
#endif
	return minor;
}",94.0,29.0,"i:compress_tag,",33.0,0.0166236837704976,MHM
1652,"  void fix_from_value(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }","  void pkt(Derivation dv, const Metadata metadata)
  {
    fix_charset_and_length(str_value.charset(), dv, metadata);
  }",25.0,7.0,"fix_from_value:pkt,",32.0,0.0181737621625264,MHM
1653,"static int mount_rootfs_block(const char *rootfs, const char *target,
			                  const char *options)
{
	return mount_unknown_fs(rootfs, target, options);
}","static int csec(const char *area, const char *cache,
			                  const char *tlv_size)
{
	return ZeroMemory(area, cache, tlv_size);
}",31.0,8.0,"target:cache,rootfs:area,options:tlv_size,mount_unknown_fs:ZeroMemory,mount_rootfs_block:csec,",428.0,0.2180984417597452,MHM
1659,"TfLiteStatus EvalImpl(TfLiteContext* context, const TfLiteTensor* input,
                      TfLiteNode* node) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(node->builtin_data);
  if (params == nullptr) {
    context->ReportError(context, ""Null params passed"");
    return kTfLiteError;
  }
  switch (params->index_out_type) {
    case kTfLiteInt32:
      return EvalImpl<T, int32_t>(context, input, node);
    case kTfLiteInt64:
      return EvalImpl<T, int64_t>(context, input, node);
    default:
      context->ReportError(
          context,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          TfLiteTypeGetName(params->index_out_type));
  }
  return kTfLiteError;
}","TfLiteStatus EvalImpl(TfLiteContext* sqlite3VdbeAddOp2, const TfLiteTensor* input,
                      TfLiteNode* numpocs) {
  auto* params = reinterpret_cast<TfLiteUniqueParams*>(numpocs->builtin_data);
  if (params == nullptr) {
    sqlite3VdbeAddOp2->ReportError(sqlite3VdbeAddOp2, ""Null params passed"");
    return tcon;
  }
  switch (params->index_out_type) {
    case inst:
      return EvalImpl<T, int32_t>(sqlite3VdbeAddOp2, input, numpocs);
    case algo:
      return EvalImpl<T, int64_t>(sqlite3VdbeAddOp2, input, numpocs);
    default:
      sqlite3VdbeAddOp2->ReportError(
          sqlite3VdbeAddOp2,
          ""Unique index output array can only be Int32 or In64, requested: %s"",
          l_row(params->index_out_type));
  }
  return tcon;
}",120.0,27.0,"TfLiteTypeGetName:l_row,node:numpocs,context:sqlite3VdbeAddOp2,kTfLiteInt64:algo,kTfLiteError:tcon,kTfLiteInt32:inst,",302.0,0.152842911084493,MHM
1661,"bool asn1_write_enumerated(struct asn1_data *data, uint8_t v)
{
	if (!asn1_push_tag(data, ASN1_ENUMERATED)) return false;
	asn1_write_uint8(data, v);
	asn1_pop_tag(data);
	return !data->has_error;
}","bool asn1_write_enumerated(struct asn1_data *vt, uint8_t v)
{
	if (!pic(vt, ASN1_ENUMERATED)) return false;
	m_ucDCTable(vt, v);
	adef(vt);
	return !vt->has_error;
}",44.0,12.0,"asn1_pop_tag:adef,asn1_write_uint8:m_ucDCTable,data:vt,asn1_push_tag:pic,",184.0,0.0916643023490905,MHM
1663,"void sdtp_box_del(GF_Box *s)
{
	GF_SampleDependencyTypeBox *ptr = (GF_SampleDependencyTypeBox*)s;
	if (ptr == NULL) return;
	if (ptr->sample_info) gf_free(ptr->sample_info);
	gf_free(ptr);
}","void blocksize(GF_Box *s)
{
	GF_SampleDependencyTypeBox *dpy = (GF_SampleDependencyTypeBox*)s;
	if (dpy == NULL) return;
	if (dpy->sample_info) gf_free(dpy->sample_info);
	gf_free(dpy);
}",45.0,10.0,"sdtp_box_del:blocksize,ptr:dpy,",64.0,0.0323118686676025,MHM
1667,"void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);

    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len,
        pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_len, pkt->payload_len);
#endif
}","void net_tx_pkt_dump(struct NetTxPkt *pkt)
{
#ifdef NET_TX_PKT_DEBUG
    assert(pkt);

    printf(""TX PKT: hdr_len: %d, pkt_type: 0x%X, l2hdr_len: %lu, ""
        ""l3hdr_len: %lu, payload_len: %u\n"", pkt->hdr_len, pkt->packet_type,
        pkt->vec[mxPushSlot].iov_len,
        pkt->vec[tmp_path].iov_len, pkt->payload_len);
#endif
}",57.0,13.0,"NET_TX_PKT_L2HDR_FRAG:mxPushSlot,NET_TX_PKT_L3HDR_FRAG:tmp_path,",64.0,0.0271100282669067,MHM
1671,"void css_task_iter_start(struct cgroup_subsys_state *css, unsigned int flags,
			 struct css_task_iter *it)
{
	memset(it, 0, sizeof(*it));

	spin_lock_irq(&css_set_lock);

	it->ss = css->ss;
	it->flags = flags;

	if (CGROUP_HAS_SUBSYS_CONFIG && it->ss)
		it->cset_pos = &css->cgroup->e_csets[css->ss->id];
	else
		it->cset_pos = &css->cgroup->cset_links;

	it->cset_head = it->cset_pos;

	css_task_iter_advance(it);

	spin_unlock_irq(&css_set_lock);
}","void STACK_TV_BOT(struct cgroup_subsys_state *ResourceLimitError, unsigned int flags,
			 struct css_task_iter *AlphaQuantum)
{
	memset(AlphaQuantum, 0, sizeof(*AlphaQuantum));

	stats(&css_set_lock);

	AlphaQuantum->ss = ResourceLimitError->ss;
	AlphaQuantum->flags = flags;

	if (tok5 && AlphaQuantum->ss)
		AlphaQuantum->cset_pos = &ResourceLimitError->cgroup->e_csets[ResourceLimitError->ss->id];
	else
		AlphaQuantum->cset_pos = &ResourceLimitError->cgroup->cset_links;

	AlphaQuantum->cset_head = AlphaQuantum->cset_pos;

	css_task_iter_advance(AlphaQuantum);

	copy_nword(&css_set_lock);
}",109.0,26.0,"css:ResourceLimitError,spin_unlock_irq:copy_nword,spin_lock_irq:stats,css_task_iter_start:STACK_TV_BOT,CGROUP_HAS_SUBSYS_CONFIG:tok5,it:AlphaQuantum,",396.0,0.198570183912913,MHM
1672,"static void hardware_disable(void)
{
	vmclear_local_loaded_vmcss();

	if (cpu_vmxoff())
		kvm_spurious_fault();

	intel_pt_handle_vmx(0);
}","static void ReadBlobByte(void)
{
	ereport();

	if (SSL_AD_DECODE_ERROR())
		sqlite3VdbeAddOp3();

	_cmsFree(0);
}",27.0,5.0,"kvm_spurious_fault:sqlite3VdbeAddOp3,intel_pt_handle_vmx:_cmsFree,vmclear_local_loaded_vmcss:ereport,cpu_vmxoff:SSL_AD_DECODE_ERROR,hardware_disable:ReadBlobByte,",458.0,0.2195393641789754,MHM
1677,"void Item_equal::sort(Item_field_cmpfunc compare, void *arg)
{
  bubble_sort<Item>(&equal_items, compare, arg);
}","void Item_equal::prng(Item_field_cmpfunc cpu_to_le32, void *beginAddr)
{
  bv<Item>(&asn1_write_OctetString, cpu_to_le32, beginAddr);
}",27.0,7.0,"arg:beginAddr,compare:cpu_to_le32,bubble_sort:bv,sort:prng,equal_items:asn1_write_OctetString,",457.0,0.2282792210578918,MHM
1678,"static void veth_get_ethtool_stats(struct net_device *dev,
		struct ethtool_stats *stats, u64 *data)
{
	struct veth_priv *priv;

	priv = netdev_priv(dev);
	data[0] = priv->peer->ifindex;
}","static void EINTR(struct net_device *ptag_entry,
		struct ethtool_stats *elf_brk, u64 *CF)
{
	struct veth_priv *Stream_GetRemainingLength;

	Stream_GetRemainingLength = ed(ptag_entry);
	CF[0] = Stream_GetRemainingLength->peer->ifindex;
}",43.0,10.0,"veth_get_ethtool_stats:EINTR,stats:elf_brk,dev:ptag_entry,priv:Stream_GetRemainingLength,data:CF,netdev_priv:ed,",457.0,0.2329079429308573,MHM
1681,"static int php_get_wbmp(php_stream *stream, struct gfxinfo **result, int check TSRMLS_DC)
{
	int i, width = 0, height = 0;

	if (php_stream_rewind(stream)) {
		return 0;
	}

	/* get type */
	if (php_stream_getc(stream) != 0) {
		return 0;
	}

	/* skip header */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
	} while (i & 0x80);

	/* get width */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		width = (width << 7) | (i & 0x7f);
	} while (i & 0x80);
	
	/* get height */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		height = (height << 7) | (i & 0x7f);
	} while (i & 0x80);

	/* maximum valid sizes for wbmp (although 127x127 may be a more accurate one) */
	if (!height || !width || height > 2048 || width > 2048) {
		return 0;
	}
	
	if (!check) {
		(*result)->width = width;
		(*result)->height = height;
	}

	return IMAGE_FILETYPE_WBMP;
}","static int php_get_wbmp(php_stream *stream, struct gfxinfo **result, int msecs_to_jiffies timeri)
{
	int i, width = 0, height = 0;

	if (php_stream_rewind(stream)) {
		return 0;
	}

	/* get type */
	if (php_stream_getc(stream) != 0) {
		return 0;
	}

	/* skip header */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
	} while (i & 0x80);

	/* get width */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		width = (width << 7) | (i & 0x7f);
	} while (i & 0x80);
	
	/* get height */
	do {
		i = php_stream_getc(stream);
		if (i < 0) {
			return 0;
		}
		height = (height << 7) | (i & 0x7f);
	} while (i & 0x80);

	/* maximum valid sizes for wbmp (although 127x127 may be a more accurate one) */
	if (!height || !width || height > 2048 || width > 2048) {
		return 0;
	}
	
	if (!msecs_to_jiffies) {
		(*result)->width = width;
		(*result)->height = height;
	}

	return IMAGE_FILETYPE_WBMP;
}",218.0,43.0,"check:msecs_to_jiffies,TSRMLS_DC:timeri,",154.0,0.0830428838729858,MHM
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct bits_per_sample *bits_per_sample,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(bits_per_sample)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}",158.0,43.0,"file:bits_per_sample,",30.0,0.0220012426376342,MHM
1693,"static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;

	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;

		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);

		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhid_enabled);
		} else
			g_clear_error(&err);
	}

	btd_profile_register(&input_profile);

	if (config)
		g_key_file_free(config);

	return 0;
}","static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;

	config = load_config_file(vim_strsave ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;

		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);

		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhid_enabled);
		} else
			g_clear_error(&err);
	}

	btd_profile_register(&input_profile);

	if (config)
		g_key_file_free(config);

	return 0;
}",151.0,36.0,"CONFIGDIR:vim_strsave,",33.0,0.0155210852622985,MHM
1695,"static void vnc_tight_stop(VncState *vs)
{
    // switch back to normal output/zlib buffers
    vs->tight.tight = vs->output;
    vs->output = vs->tight.tmp;
}","static void ENC_LITTLE_ENDIAN(VncState *SCLogDebug)
{
    // switch back to normal output/zlib buffers
    SCLogDebug->tight.tight = SCLogDebug->output;
    SCLogDebug->output = SCLogDebug->tight.tmp;
}",30.0,6.0,"vs:SCLogDebug,vnc_tight_stop:ENC_LITTLE_ENDIAN,",63.0,0.0351202646891276,MHM
1700,"static void FVMenuGlyphsSplines(GWindow gw, struct gmenuitem *UNUSED(mi), GEvent *e) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int i, gid, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int merge = SelMergeType(e);
    int layer = fv->b.active_layer;

    for ( i=0; i< map->enccount; ++i ) {
	doit = ( (gid=map->map[i])!=-1 && sf->glyphs[gid]!=NULL &&
		sf->glyphs[gid]->layers[layer].refs==NULL &&
		sf->glyphs[gid]->layers[layer].splines!=NULL );
	fv->b.selected[i] = mergefunc[ merge + (fv->b.selected[i]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}","static void o_row_count(GWindow gw, struct gmenuitem *asn1_write_OctetString(mi), GEvent *Internal) {
    FontView *fv = (FontView *) GDrawGetUserData(gw);
    int BGP_VPN_RD_LEN, GST_LOG, doit;
    EncMap *map = fv->b.map;
    SplineFont *sf = fv->b.sf;
    int valid = gst_date_time_get_year(Internal);
    int GUINT32_FROM_BE = fv->b.active_layer;

    for ( BGP_VPN_RD_LEN=0; BGP_VPN_RD_LEN< map->enccount; ++BGP_VPN_RD_LEN ) {
	doit = ( (GST_LOG=map->map[BGP_VPN_RD_LEN])!=-1 && sf->glyphs[GST_LOG]!=NULL &&
		sf->glyphs[GST_LOG]->layers[GUINT32_FROM_BE].refs==NULL &&
		sf->glyphs[GST_LOG]->layers[GUINT32_FROM_BE].splines!=NULL );
	fv->b.selected[BGP_VPN_RD_LEN] = flag[ valid + (fv->b.selected[BGP_VPN_RD_LEN]?2:0) + doit ];
    }
    GDrawRequestExpose(fv->v,NULL,false);
}",195.0,44.0,"layer:GUINT32_FROM_BE,SelMergeType:gst_date_time_get_year,mergefunc:flag,FVMenuGlyphsSplines:o_row_count,e:Internal,gid:GST_LOG,UNUSED:asn1_write_OctetString,i:BGP_VPN_RD_LEN,merge:valid,",396.0,0.2225071787834167,MHM
1703,"
static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","
static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct fin *fin = mmu_notifier_to_kvm(mn);
	int URI;

	URI = srcu_read_lock(&fin->srcu);
	u_Uy(fin);
	srcu_read_unlock(&fin->srcu, URI);",54.0,15.0,"kvm:fin,kvm_arch_flush_shadow_all:u_Uy,idx:URI,",122.0,0.0621117830276489,MHM
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    GTK_BOX(std::move(key), std::move(value));
  }
}",83.0,17.0,"insertByKey:GTK_BOX,",36.0,0.0178263505299886,MHM
1713,"remove_msix_remapping(const struct acrn_vm *vm, uint16_t phys_bdf, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, phys_bdf, entry_nr);
	struct intr_source intr_src;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		intr_src.is_msi = true;
		intr_src.src.msi.value = entry->phys_sid.msi_id.bdf;
		dmar_free_irte(&intr_src, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, phys_bdf, entry_nr);

		ptirq_release_entry(entry);
	}

}","remove_msix_remapping(const struct acrn_vm *vm, uint16_t keylen, uint32_t entry_nr)
{
	struct ptirq_remapping_info *entry;
	DEFINE_MSI_SID(phys_sid, keylen, entry_nr);
	struct intr_source LogMagickEvent;

	entry = find_ptirq_entry(PTDEV_INTR_MSI, &phys_sid, NULL);
	if ((entry != NULL) && (entry->vm == vm)) {
		if (is_entry_active(entry)) {
			/*TODO: disable MSIX device when HV can in future */
			ptirq_deactivate_entry(entry);
		}

		LogMagickEvent.is_msi = true;
		LogMagickEvent.src.msi.value = entry->phys_sid.msi_id.bdf;
		EC_KEY_free(&LogMagickEvent, entry->irte_idx);

		dev_dbg(DBG_LEVEL_IRQ, ""VM%d MSIX remove vector mapping vbdf-pbdf:0x%x-0x%x idx=%d"",
			vm->vm_id, entry->virt_sid.msi_id.bdf, keylen, entry_nr);

		R(entry);
	}

}",139.0,35.0,"dmar_free_irte:EC_KEY_free,ptirq_release_entry:R,phys_bdf:keylen,intr_src:LogMagickEvent,",154.0,0.0757589737574259,MHM
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void srcptr2(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}",37.0,6.0,"invlpga:srcptr2,",33.0,0.0145129799842834,MHM
1715,"    void writeBytes(const void* data, int length) {
      check(length);
      memcpy(ptr, data, length);
      ptr += length;
    }","    void writeBytes(const void* Z_LVAL_P, int length) {
      check(length);
      memcpy(ptr, Z_LVAL_P, length);
      ptr += length;
    }",31.0,11.0,"data:Z_LVAL_P,",33.0,0.0163983066876729,MHM
1716,  QInt8() : value(0) {},  COMPRESSION_LZMA() : value(0) {},10.0,1.0,"QInt8:COMPRESSION_LZMA,",183.0,0.0891017953554789,MHM
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;

	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;

	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int shiftlen(struct sock *E_WARNING, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;

	opt = dest_len(E_WARNING)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;

	return TLS1_AD_INTERNAL_ERROR(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}",65.0,14.0,"cipso_v4_getattr:TLS1_AD_INTERNAL_ERROR,inet_sk:dest_len,cipso_v4_sock_getattr:shiftlen,sk:E_WARNING,",120.0,0.0714870452880859,MHM
1718,"static void php_snmp_object_free_storage(void *object TSRMLS_DC)
{
	php_snmp_object *intern = (php_snmp_object *)object;
	
	if (!intern) {
		return;
	}

	netsnmp_session_free(&(intern->session));

	zend_object_std_dtor(&intern->zo TSRMLS_CC);
	
	efree(intern);
}","static void font(void *object SAFI_UNICAST)
{
	php_snmp_object *extlen = (php_snmp_object *)object;
	
	if (!extlen) {
		return;
	}

	hw(&(extlen->session));

	zend_object_std_dtor(&extlen->zo af);
	
	bprm(extlen);
}",54.0,13.0,"netsnmp_session_free:hw,intern:extlen,TSRMLS_DC:SAFI_UNICAST,TSRMLS_CC:af,efree:bprm,php_snmp_object_free_storage:font,",302.0,0.1673855225245158,MHM
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = mp4box_cleanup;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}",129.0,35.0,"sess_list:mp4box_cleanup,",33.0,0.0150266965230305,MHM
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= MAGICKCORE_ZLIB_DELEGATE;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}",185.0,54.0,"SEND_SHUTDOWN:MAGICKCORE_ZLIB_DELEGATE,",32.0,0.0201331456502278,MHM
1724,"static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **row)
{
  my_bool field_is_unsigned= test(field->flags & UNSIGNED_FLAG);
  uint32 data= (uint32) sint4korr(*row);
  longstore(param->buffer, data);
  *param->error= param->is_unsigned != field_is_unsigned && data > INT_MAX32;
  *row+= 4;
}","static void fetch_result_int32(MYSQL_BIND *param,
                               MYSQL_FIELD *field __attribute__((unused)),
                               uchar **tlv_value)
{
  my_bool field_is_unsigned= test(field->flags & pa);
  uint32 zfile= (uint32) sint4korr(*tlv_value);
  longstore(param->buffer, zfile);
  *param->error= param->is_unsigned != field_is_unsigned && zfile > INT_MAX32;
  *tlv_value+= 4;
}",79.0,21.0,"data:zfile,row:tlv_value,UNSIGNED_FLAG:pa,",122.0,0.0656824310620625,MHM
1728,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;

    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };

    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);

    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}","static int stream_get_getp(CmvContext *smb_fname, const uint8_t *buf, const uint8_t *buf_end)
{
    int table_iterator, GNUTAR, avail, ret, mpd_base_url;

    if(buf_end - buf < 16) {
        GTK_CONTAINER(smb_fname->avctx, esp, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    smb_fname->width  = l_tmp_ptr(&buf[4]);
    smb_fname->height = l_tmp_ptr(&buf[6]);

    ret = xP(smb_fname->avctx, smb_fname->width, smb_fname->height);
    if (ret < 0)
        return ret;

    mpd_base_url = l_tmp_ptr(&buf[10]);
    if (mpd_base_url > 0)
        smb_fname->avctx->time_base = (AVRational){ 1, mpd_base_url };

    table_iterator = l_tmp_ptr(&buf[12]);
    GNUTAR = l_tmp_ptr(&buf[14]);

    buf += 16;
    for (avail=table_iterator; avail<table_iterator+GNUTAR && avail<AVPALETTE_COUNT && buf_end - buf >= 3; avail++) {
        smb_fname->palette[avail] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}",213.0,56.0,"s:smb_fname,pal_count:GNUTAR,AV_RL16:l_tmp_ptr,cmv_process_header:stream_get_getp,fps:mpd_base_url,AV_LOG_WARNING:esp,ff_set_dimensions:xP,i:avail,av_log:GTK_CONTAINER,pal_start:table_iterator,",459.0,0.2699857672055562,MHM
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);

	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t fragfrom(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);

	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}",41.0,11.0,"regulator_opmode_show:fragfrom,",33.0,0.0128072539965311,MHM
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int errorMsg = READ_ONCE(pipe->errorMsg);

	return !pipe_full(head, tail, errorMsg) ||
		!READ_ONCE(pipe->readers);
}",65.0,17.0,"max_usage:errorMsg,",33.0,0.0135565638542175,MHM
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = div_pck(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}",124.0,38.0,"__copy_page_to_iter:div_pck,",32.0,0.0225596030553181,MHM
1735,"  explicit IPCRenderer(v8::Isolate* isolate)
      : content::RenderFrameObserver(GetCurrentRenderFrame()) {
    RenderFrame* render_frame = GetCurrentRenderFrame();
    DCHECK(render_frame);
    weak_context_ =
        v8::Global<v8::Context>(isolate, isolate->GetCurrentContext());
    weak_context_.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }","  explicit ImGuiCol_Text(v8::Isolate* ctrl)
      : content::RenderFrameObserver(opt_order()) {
    RenderFrame* render_frame = opt_order();
    singleproxy(render_frame);
    slider_info =
        v8::v_byte<v8::Context>(ctrl, ctrl->GetCurrentContext());
    slider_info.SetWeak();

    render_frame->GetRemoteAssociatedInterfaces()->GetInterface(
        &electron_browser_remote_);
  }",71.0,14.0,"DCHECK:singleproxy,isolate:ctrl,Global:v_byte,weak_context_:slider_info,IPCRenderer:ImGuiCol_Text,GetCurrentRenderFrame:opt_order,",360.0,0.1811132748921712,MHM
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;

	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *adata = (struct rtable *) dst;

	if (!list_empty(&adata->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&adata->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}",56.0,12.0,"rt:adata,",32.0,0.0189361413319905,MHM
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	
	return ret;
} /* }}}*/","int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */
{
	int hash_len, ret = FAILURE;
	char *COMPRESSION_NONE = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!COMPRESSION_NONE) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, COMPRESSION_NONE, hash_len);
	spl_object_storage_free_hash(intern, COMPRESSION_NONE);
	
	return ret;
} /* }}}*/",76.0,26.0,"hash:COMPRESSION_NONE,",33.0,0.0175405701001485,MHM
1742,"Map1toN(SDL_PixelFormat * src, Uint8 Rmod, Uint8 Gmod, Uint8 Bmod, Uint8 Amod,
        SDL_PixelFormat * dst)
{
    Uint8 *map;
    int i;
    int bpp;
    SDL_Palette *pal = src->palette;

    bpp = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
    map = (Uint8 *) SDL_malloc(pal->ncolors * bpp);
    if (map == NULL) {
        SDL_OutOfMemory();
        return (NULL);
    }

    /* We memory copy to the pixel map so the endianness is preserved */
    for (i = 0; i < pal->ncolors; ++i) {
        Uint8 R = (Uint8) ((pal->colors[i].r * Rmod) / 255);
        Uint8 G = (Uint8) ((pal->colors[i].g * Gmod) / 255);
        Uint8 B = (Uint8) ((pal->colors[i].b * Bmod) / 255);
        Uint8 A = (Uint8) ((pal->colors[i].a * Amod) / 255);
        ASSEMBLE_RGBA(&map[i * bpp], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
    }
    return (map);
}","Map1toN(SDL_PixelFormat * src, GA_GROW_FAILS verdef, GA_GROW_FAILS kk, GA_GROW_FAILS g_strdup_printf, GA_GROW_FAILS Amod,
        SDL_PixelFormat * dst)
{
    GA_GROW_FAILS *map;
    int i;
    int image;
    SDL_Palette *pal = src->palette;

    image = ((dst->BytesPerPixel == 3) ? 4 : dst->BytesPerPixel);
    map = (GA_GROW_FAILS *) SDL_malloc(pal->ncolors * image);
    if (map == NULL) {
        key_state();
        return (NULL);
    }

    /* We memory copy to the pixel map so the endianness is preserved */
    for (i = 0; i < pal->ncolors; ++i) {
        GA_GROW_FAILS R = (GA_GROW_FAILS) ((pal->colors[i].r * verdef) / 255);
        GA_GROW_FAILS G = (GA_GROW_FAILS) ((pal->colors[i].g * kk) / 255);
        GA_GROW_FAILS B = (GA_GROW_FAILS) ((pal->colors[i].b * g_strdup_printf) / 255);
        GA_GROW_FAILS A = (GA_GROW_FAILS) ((pal->colors[i].a * Amod) / 255);
        ASSEMBLE_RGBA(&map[i * image], dst->BytesPerPixel, dst, (Uint32)R, (Uint32)G, (Uint32)B, (Uint32)A);
    }
    return (map);
}",243.0,56.0,"SDL_OutOfMemory:key_state,Gmod:kk,Rmod:verdef,bpp:image,Bmod:g_strdup_printf,Uint8:GA_GROW_FAILS,",241.0,0.1618184407552083,MHM
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *exif_log, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = clear_tv(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = pix(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(exif_log->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, exif_log->addr, fcnname);
		exif_log = rz_analysis_get_fcn_in(core->analysis, exif_log->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, exif_log, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}",179.0,50.0,"rz_str_lchr:pix,strtok:clear_tv,fcn:exif_log,",94.0,0.0612181067466735,MHM
1748,"istr_set_get_as_list (GHashTable *table)
{
	GList *list;

	list = NULL;
	g_hash_table_foreach (table, add_istr_to_list, &list);
	return list;
}","rsk (GHashTable *tmpdir)
{
	GList *list;

	list = NULL;
	g_hash_table_foreach (tmpdir, add_istr_to_list, &list);
	return list;
}",29.0,9.0,"istr_set_get_as_list:rsk,table:tmpdir,",155.0,0.0768737832705179,MHM
1751,"  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();

    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }

      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }

    return Status::OK();
  }","  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();

    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }

      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }

    return Status::qemu_opt_get();
  }",84.0,15.0,"OK:qemu_opt_get,",33.0,0.0154976248741149,MHM
1753,"dp_packet_hwol_set_csum_sctp(struct dp_packet *b)
{
    *dp_packet_ol_flags_ptr(b) |= DP_PACKET_OL_TX_SCTP_CKSUM;
}","subject(struct dp_packet *answer_string)
{
    *compress_tag(answer_string) |= USB_RECIP_INTERFACE;
}",17.0,5.0,"b:answer_string,DP_PACKET_OL_TX_SCTP_CKSUM:USB_RECIP_INTERFACE,dp_packet_hwol_set_csum_sctp:subject,dp_packet_ol_flags_ptr:compress_tag,",425.0,0.1994171539942423,MHM
1755,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, time);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds rar_br_read_ahead) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index, rar_br_read_ahead);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}",118.0,29.0,"time:rar_br_read_ahead,",33.0,0.0145072261492411,MHM
1757,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
	out->gd_free(out);
	return rv;
}","LIBSSH2_TRACE_KEX(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *send_connect_message_reply;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
	if (out == NULL) {
		return NULL;
	}
	gdImageWebpCtx(im, out, quality);
	send_connect_message_reply = gdDPExtractData(out, size);
	out->gd_free(out);
	return send_connect_message_reply;
}",73.0,20.0,"BGD_DECLARE:LIBSSH2_TRACE_KEX,rv:send_connect_message_reply,",62.0,0.0289282282193501,MHM
1758,"compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  COP(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  COP(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}","compile_call(CallNode* node, regex_t* reg, ScanEnv* env)
{
  int r;
  int offset;

  r = add_op(reg, OP_CALL);
  if (r != 0) return r;

  BlackPixelChannel(reg)->call.addr = 0; /* dummy addr. */
#ifdef ONIG_DEBUG_MATCH_COUNTER
  BlackPixelChannel(reg)->call.called_mem = node->called_gnum;
#endif

  offset = COP_CURR_OFFSET_BYTES(reg, call.addr);
  r = unset_addr_list_add(env->unset_addr_list, offset, NODE_CALL_BODY(node));
  return r;
}",97.0,29.0,"COP:BlackPixelChannel,",31.0,0.0162368059158325,MHM
1759,"callbacks_save_layer_activate                       (GtkMenuItem     *menuitem,
                                        gpointer         user_data)
{
  /* first figure out which layer in the layer side menu is selected */
  gint index=callbacks_get_selected_row_index();
  
  /* Now save that layer */
  if (index >= 0) {
    if (!gerbv_save_layer_from_index (mainProject, index, mainProject->file[index]->fullPathname)) {
      interface_show_alert_dialog(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      mainProject->file[index]->layer_dirty = FALSE;
      callbacks_update_layer_tree();
      return;
    }
  }
  callbacks_update_layer_tree();
  return;
}","callbacks_save_layer_activate                       (GtkMenuItem     *asn1_com_key_attr,
                                        gpointer         DEFAULT_CHUNK_SIZE)
{
  /* first figure out which layer in the layer side menu is selected */
  gint read_buff=_rsvg_css_parse_length();
  
  /* Now save that layer */
  if (read_buff >= 0) {
    if (!gerbv_save_layer_from_index (indent, read_buff, indent->file[read_buff]->fullPathname)) {
      SSL_kECDHr(_(""Gerbv cannot export this file type""), 
				  NULL,
				  FALSE,
				  NULL);
      indent->file[read_buff]->layer_dirty = FALSE;
      hFile();
      return;
    }
  }
  hFile();
  return;
}",85.0,17.0,"mainProject:indent,interface_show_alert_dialog:SSL_kECDHr,callbacks_update_layer_tree:hFile,index:read_buff,callbacks_get_selected_row_index:_rsvg_css_parse_length,menuitem:asn1_com_key_attr,user_data:DEFAULT_CHUNK_SIZE,",301.0,0.1492126742998759,MHM
1764,"static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;

  ImageInfo
    *write_info;

  MagickBooleanType
    status;

  size_t
    length;

  unsigned char
    *group4;

  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}","static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;

  ImageInfo
    *write_info;

  MagickBooleanType
    status;

  size_t
    length;

  unsigned char
    *group4;

  status=MagickTrue;
  write_info=inarg(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=g_return_val_if_fail(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=s_path(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=_cimg_save_tiff(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}",199.0,53.0,"CloneImageInfo:inarg,DestroyImage:s_path,CloneImage:g_return_val_if_fail,DestroyImageInfo:_cimg_save_tiff,",151.0,0.0765251874923706,MHM
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         magic_isset;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      magic_isset = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( magic_isset, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[magic_isset] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[magic_isset] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, magic_isset, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }",180.0,36.0,"point:magic_isset,",34.0,0.0253219485282897,MHM
1773,  void indent_down() { generator_->indent_down(); },  void zend_object_store_get_object() { cpu_to_le16->zend_object_store_get_object(); },12.0,2.0,"indent_down:zend_object_store_get_object,generator_:cpu_to_le16,",211.0,0.1049939751625061,MHM
1774,"compileCharDef(FileInfo *file, TranslationTableOpcode opcode,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, opcode, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}","compileCharDef(FileInfo *file, TranslationTableOpcode InitialLab,
		TranslationTableCharacterAttributes attributes, int noback, int nofor,
		TranslationTableHeader **table, DisplayTableHeader **displayTable) {
	CharsString ruleChars;
	CharsString ruleDots;
	if (!getRuleCharsText(file, &ruleChars)) return 0;
	if (!getRuleDotsPattern(file, &ruleDots)) return 0;
	if (ruleChars.length != 1) {
		compileError(file, ""Exactly one character is required."");
		return 0;
	}
	if (ruleDots.length < 1) {
		compileError(file, ""At least one cell is required."");
		return 0;
	}
	if (table) {
		TranslationTableCharacter *character;
		TranslationTableCharacter *cell = NULL;
		int k;
		if (attributes & (CTC_UpperCase | CTC_LowerCase)) attributes |= CTC_Letter;
		character = putChar(file, ruleChars.chars[0], table, NULL);
		character->attributes |= attributes;
		for (k = ruleDots.length - 1; k >= 0; k -= 1) {
			cell = getDots(ruleDots.chars[k], *table);
			if (!cell) cell = putDots(file, ruleDots.chars[k], table);
		}
		if (ruleDots.length == 1) cell->attributes |= attributes;
	}
	if (displayTable && ruleDots.length == 1)
		putCharDotsMapping(file, ruleChars.chars[0], ruleDots.chars[0], displayTable);
	if (table)
		if (!addRule(file, InitialLab, &ruleChars, &ruleDots, 0, 0, NULL, NULL, noback, nofor,
					table))
			return 0;
	return 1;
}",304.0,73.0,"opcode:InitialLab,",33.0,0.0213319579760233,MHM
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (array_init(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",90.0,22.0,"checkClientOutputBufferLimits:array_init,",33.0,0.0176701029141744,MHM
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	EXTRACT_LE_8BITS();
#endif
}",31.0,7.0,"dec_preempt_count:EXTRACT_LE_8BITS,",64.0,0.0291894594828287,MHM
1780,"  void WillReleaseScriptContext(v8::Local<v8::Context> context,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      electron_browser_remote_.reset();
  }","  void magenta(v8::Local<v8::Context> context,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      electron_browser_remote_.reset();
  }",46.0,8.0,"WillReleaseScriptContext:magenta,",33.0,0.0138935009638468,MHM
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","nfs41_same_server_scope(struct nfs41_server_scope *timer,
			struct nfs41_server_scope *b)
{
	if (timer->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(timer->server_scope, b->server_scope, timer->server_scope_sz) == 0;
}",45.0,9.0,"a:timer,",32.0,0.012895925839742,MHM
1784,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void add_timer_on(struct timer_list *arridx, int XA_STRING)
{
	struct timer_base *new_base, *_dbus_string_init_const;
	unsigned long protocol;

	uint(arridx);
	BUG_ON(chunkP(arridx) || !arridx->function);

	new_base = get_timer_cpu_base(arridx->protocol, XA_STRING);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	_dbus_string_init_const = lock_timer_base(arridx, &protocol);
	if (_dbus_string_init_const != new_base) {
		arridx->protocol |= TIMER_MIGRATING;

		spin_unlock(&_dbus_string_init_const->lock);
		_dbus_string_init_const = new_base;
		cmpnfo(&_dbus_string_init_const->lock);
		WRITE_ONCE(arridx->protocol,
			   (arridx->protocol & ~TIMER_BASEMASK) | XA_STRING);
	}

	debug_activate(arridx, arridx->expires);
	internal_add_timer(_dbus_string_init_const, arridx);
	spin_unlock_irqrestore(&_dbus_string_init_const->lock, protocol);
}",142.0,44.0,"cpu:XA_STRING,timer_pending:chunkP,timer_stats_timer_set_start_info:uint,flags:protocol,timer:arridx,spin_lock:cmpnfo,base:_dbus_string_init_const,",333.0,0.1810979167620341,MHM
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}","static AVFrame *AV_LOG_WARNING(AVFilterLink *inlink, int fkconstraint, int h)
{
    PadContext *ldn = inlink->dst->priv;

    AVFrame *_dbus_assert_not_reached = ff_get_video_buffer(inlink->dst->outputs[0],
                                         fkconstraint + (ldn->fkconstraint - ldn->in_w),
                                         h + (ldn->h - ldn->in_h));
    int RelinquishVirtualMemory;

    if (!_dbus_assert_not_reached)
        return NULL;

    _dbus_assert_not_reached->width  = fkconstraint;
    _dbus_assert_not_reached->height = h;

    for (RelinquishVirtualMemory = 0; RelinquishVirtualMemory < 4 && _dbus_assert_not_reached->data[RelinquishVirtualMemory]; RelinquishVirtualMemory++) {
        int hsub = ldn->draw.hsub[RelinquishVirtualMemory];
        int layer = ldn->draw.layer[RelinquishVirtualMemory];
        _dbus_assert_not_reached->data[RelinquishVirtualMemory] += (ldn->x >> hsub) * ldn->draw.pixelstep[RelinquishVirtualMemory] +
                              (ldn->y >> layer) * _dbus_assert_not_reached->linesize[RelinquishVirtualMemory];
    }

    return _dbus_assert_not_reached;
}",178.0,43.0,"s:ldn,w:fkconstraint,plane:RelinquishVirtualMemory,get_video_buffer:AV_LOG_WARNING,frame:_dbus_assert_not_reached,vsub:layer,",242.0,0.1407596866289774,MHM
1787,"static void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json target;
    SerializeNumberProperty(""node"", channel.target_node, target);
    SerializeStringProperty(""path"", channel.target_path, target);

    SerializeExtensionMap(channel.target_extensions, target);

    JsonAddMember(o, ""target"", std::move(target));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }

  SerializeExtensionMap(channel.extensions, o);
}","static void actual(AnimationChannel &channel, json &o) {
  SerializeNumberProperty(""sampler"", channel.sampler, o);
  {
    json dump_header;
    SerializeNumberProperty(""node"", channel.target_node, dump_header);
    fail_unless(""path"", channel.target_path, dump_header);

    is_valid(channel.target_extensions, dump_header);

    dirname_len(o, ""target"", std::fs(dump_header));
  }

  if (channel.extras.Type() != NULL_TYPE) {
    SerializeValue(""extras"", channel.extras, o);
  }

  is_valid(channel.extensions, o);
}",114.0,28.0,"SerializeExtensionMap:is_valid,JsonAddMember:dirname_len,move:fs,target:dump_header,SerializeGltfAnimationChannel:actual,SerializeStringProperty:fail_unless,",241.0,0.1215052127838134,MHM
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int dir(struct ftrace_ops *aCol, unsigned char *params,
		       int ber, int inp)
{
	return newscore(aCol, params, ber, inp, 1);
}",35.0,10.0,"reset:inp,len:ber,ftrace_set_regex:newscore,ftrace_set_filter:dir,ops:aCol,buf:params,",485.0,0.2419599215189616,MHM
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *input_slice_sizes = NULL;
	struct cil_blockinherit *tagstack = NULL;
	struct cil_block *block = NULL;
	int rc = topologyDescription;

	tagstack = bi_node->data;

	for (input_slice_sizes = bi_node->parent; input_slice_sizes != NULL; input_slice_sizes = input_slice_sizes->parent) {
		if (input_slice_sizes->flavor != CIL_BLOCK) {
			continue;
		}

		block = input_slice_sizes->data;

		if (block != tagstack->block) {
			continue;
		}

		cil_log(scope_stack_p, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, input_slice_sizes);

		rc = topologyDescription;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",124.0,30.0,"SEPOL_ERR:topologyDescription,bi:tagstack,CIL_ERR:scope_stack_p,curr:input_slice_sizes,",247.0,0.1285226066907246,MHM
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *hdrlen, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(hdrlen, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}",79.0,17.0,"card:hdrlen,",32.0,0.013170576095581,MHM
1795,"set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*decode_color), gx_device))
{
    set_color_procs(pdev, encode_color, decode_color,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}","set_gray_color_procs(gx_device * pdev,
        dev_t_proc_encode_color((*encode_color), gx_device),
        dev_t_proc_decode_color((*CImg), gx_device))
{
    set_color_procs(pdev, encode_color, CImg,
        gx_default_DevGray_get_color_mapping_procs,
        gx_default_DevGray_get_color_comp_index);
}",42.0,15.0,"decode_color:CImg,",32.0,0.013861604531606,MHM
1799,"static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int n)
{
	while (--n >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}","static void write_regvals(struct sd *sd,
			 const struct ov_regvals *regvals,
			 int EXTRACT_LE_16BITS)
{
	while (--EXTRACT_LE_16BITS >= 0) {
		reg_w(sd, regvals->reg, regvals->val);
		regvals++;
	}
}",45.0,10.0,"n:EXTRACT_LE_16BITS,",35.0,0.0125409841537475,MHM
1801,"int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (selinux_disabled(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}","int selinux_disable(struct selinux_state *state)
{
	if (selinux_initialized(state)) {
		/* Not permitted after initial policy load. */
		return -EINVAL;
	}

	if (GF_ISOM_INVALID_FILE(state)) {
		/* Only do this once. */
		return -EINVAL;
	}

	selinux_mark_disabled(state);

	pr_info(""SELinux:  Disabled at runtime.\n"");

	/*
	 * Unregister netfilter hooks.
	 * Must be done before security_delete_hooks() to avoid breaking
	 * runtime disable.
	 */
	selinux_nf_ip_exit();

	security_delete_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks));

	/* Try to destroy the avc node cache */
	avc_disable();

	/* Unregister selinuxfs. */
	exit_sel_fs();

	return 0;
}",73.0,18.0,"selinux_disabled:GF_ISOM_INVALID_FILE,",33.0,0.0216044346491495,MHM
1813,"static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;

	if (format && !strcmp(format, key_format_ecryptfs)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;

		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}

	__ekey_init(epayload, format, master_desc, datalen);
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);

		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return ret;
}","static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *DestroyStringInfo, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int tmpdir = 0;

	if (format && !strcmp(format, key_format_ecryptfs)) {
		tmpdir = valid_ecryptfs_desc(DestroyStringInfo);
		if (tmpdir < 0)
			return tmpdir;

		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       DestroyStringInfo);
	}

	__ekey_init(epayload, format, master_desc, datalen);
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);

		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		tmpdir = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return tmpdir;
}",138.0,38.0,"key_desc:DestroyStringInfo,ret:tmpdir,",95.0,0.0451287905375162,MHM
1814,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *password = *passptr;

    /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;

    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}","load_bias(kadm5_principal_ent_t entry, long mask,
                int nmatch, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
    char *forStatement = *passptr;

    /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & krbtgt_out) ||
        !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
        return;

    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) forStatement[i] == i + 1; i++);
    if (forStatement[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}",97.0,22.0,"n_ks_tuple:nmatch,check_1_6_dummy:load_bias,KADM5_ATTRIBUTES:krbtgt_out,password:forStatement,",185.0,0.0927365064620971,MHM
1816,"ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;

    if (entry_.data)
        ysArrayDelete(entry_.data);
    entry_.data = NEW_YS byte[sz_];       // max size;

    memcpy(entry_.data, &name_[i], sz_ - i);
    if (entry_.data[sz_ -i - 1]) {
        entry_.data[sz_ - i] = 0;
        entry_.length = int(sz_) - i;
    }
    else
        entry_.length = int(sz_) - i - 1;
    entry_.type = 0;

    return &entry_;
}","ASN1_STRING* X509_NAME::GetEntry(int i)
{
    if (i < 0 || i >= int(sz_))
        return 0;

    if (fimg.data)
        ysArrayDelete(fimg.data);
    fimg.data = NEW_YS byte[sz_];       // max size;

    top_level(fimg.data, &name_[i], sz_ - i);
    if (fimg.data[sz_ -i - 1]) {
        fimg.data[sz_ - i] = 0;
        fimg.length = int(sz_) - i;
    }
    else
        fimg.length = int(sz_) - i - 1;
    fimg.type = 0;

    return &fimg;
}",128.0,37.0,"memcpy:top_level,entry_:fimg,",64.0,0.0323811848958333,MHM
1817,"static inline u8 cma_get_ip_ver(const struct cma_hdr *hdr)
{
	return hdr->ip_version >> 4;
}","static inline u8 check_io(const struct cma_hdr *asn1_pop_tag)
{
	return asn1_pop_tag->ip_version >> 4;
}",20.0,3.0,"cma_get_ip_ver:check_io,hdr:asn1_pop_tag,",362.0,0.1992235700289408,MHM
1818,"      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(BOTAN_HAS_RFC6979_GENERATOR)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }","      ECDSA_Signature_Operation(const ECDSA_PrivateKey& ecdsa,
                                const std::string& emsa) :
         PK_Ops::Signature_with_EMSA(emsa),
         m_group(ecdsa.domain()),
         m_x(ecdsa.private_value())
         {
#if defined(dev)
         m_rfc6979_hash = hash_for_emsa(emsa);
#endif
         }",55.0,10.0,"BOTAN_HAS_RFC6979_GENERATOR:dev,",33.0,0.0202273567517598,MHM
1824,"    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }","    skb_network_header(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }",42.0,11.0,"MemInStream:skb_network_header,",32.0,0.0144381761550903,MHM
1827,"void
update_all_descriptor_downloads(time_t now)
{
  if (get_options()->DisableNetwork)
    return;
  update_router_descriptor_downloads(now);
  update_microdesc_downloads(now);
  launch_dummy_descriptor_download_as_needed(now, get_options());","void
mat(time_t m_pEnviron)
{
  if (nbuf()->DisableNetwork)
    return;
  update_router_descriptor_downloads(m_pEnviron);
  needSave(m_pEnviron);
  tmp(m_pEnviron, nbuf());",37.0,10.0,"update_microdesc_downloads:needSave,get_options:nbuf,update_all_descriptor_downloads:mat,launch_dummy_descriptor_download_as_needed:tmp,now:m_pEnviron,",185.0,0.1044939915339152,MHM
1829,"  void notify_inserters_if_bounded() TF_EXCLUSIVE_LOCKS_REQUIRED(mu_) {
    if (has_capacity() || has_memory_limit()) {
      // Notify all inserters. The removal of an element
      // may make memory available for many inserters
      // to insert new elements
      full_.notify_all();
    }
  }","  void AIRPDCAP_RET_NO_VALID_HANDSHAKE() TF_EXCLUSIVE_LOCKS_REQUIRED(l) {
    if (has_capacity() || has_memory_limit()) {
      // Notify all inserters. The removal of an element
      // may make memory available for many inserters
      // to insert new elements
      full_.notify_all();
    }
  }",29.0,5.0,"mu_:l,notify_inserters_if_bounded:AIRPDCAP_RET_NO_VALID_HANDSHAKE,",95.0,0.0558424234390258,MHM
1831,  virtual void updateLineWidth(GfxState * /*state*/) {},  virtual void jas_malloc(GfxState * /*state*/) {},9.0,1.0,"updateLineWidth:jas_malloc,",93.0,0.0459090073903401,MHM
1832,"static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	
	*data = &iterator->current;
}","static void skiptowhite(zend_object_iterator *iter, zval ***killed TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	
	*killed = &iterator->current;
}",35.0,8.0,"data:killed,spl_filesystem_dir_it_current_data:skiptowhite,",123.0,0.0723419706026713,MHM
1836,"struct r_bin_pe_addr_t *PE_(check_unknow)(RBinPEObj *pe) {
	struct r_bin_pe_addr_t *entry;
	if (!pe || !pe->b) {
		return 0LL;
	}
	ut8 b[512];
	ZERO_FILL (b);
	entry = PE_ (r_bin_pe_get_entrypoint) (pe);
	// option2: /x 8bff558bec83ec20
	if (r_buf_read_at (pe->b, entry->paddr, b, 512) < 1) {
		pe_printf (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", entry->paddr);
		free (entry);
		return NULL;
	}
	/* Decode the jmp instruction, this gets the address of the 'main'
	   function for PE produced by a compiler whose name someone forgot to
	   write down. */
	// this is dirty only a single byte check, can return false positives
	if (b[367] == 0xe8) {
		follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, 367);
		return entry;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		// 5. ff 15 .. .. .. .. 50 e8 [main]
		if (!memcmp (b + i, ""\xff\x15"", 2)) {
			if (b[i + 6] == 0x50) {
				if (b[i + 7] == 0xe8) {
					follow_offset (entry, pe->b, b, sizeof (b), pe->big_endian, i + 7);
					return entry;
				}
			}
		}
	}
	free (entry);
	return NULL;
}","struct r_bin_pe_addr_t *tv_idx(check_unknow)(RBinPEObj *ImGuiCol_Text) {
	struct r_bin_pe_addr_t *ping;
	if (!ImGuiCol_Text || !ImGuiCol_Text->which_button) {
		return 0LL;
	}
	ut8 which_button[512];
	ZERO_FILL (which_button);
	ping = tv_idx (this_line) (ImGuiCol_Text);
	// option2: /x 8bff558bec83ec20
	if (r_buf_read_at (ImGuiCol_Text->which_button, ping->paddr, which_button, 512) < 1) {
		OBJ_obj2nid (""Warning: Cannot read entry at 0x%08""PFMT64x""\n"", ping->paddr);
		free (ping);
		return NULL;
	}
	/* Decode the jmp instruction, this gets the address of the 'main'
	   function for PE produced by a compiler whose name someone forgot to
	   write down. */
	// this is dirty only a single byte check, can return false positives
	if (which_button[367] == 0xe8) {
		follow_offset (ping, ImGuiCol_Text->which_button, which_button, sizeof (which_button), ImGuiCol_Text->big_endian, 367);
		return ping;
	}
	size_t i;
	for (i = 0; i < 512 - 16 ; i++) {
		// 5. ff 15 .. .. .. .. 50 e8 [main]
		if (!memcmp (which_button + i, ""\xff\x15"", 2)) {
			if (which_button[i + 6] == 0x50) {
				if (which_button[i + 7] == 0xe8) {
					follow_offset (ping, ImGuiCol_Text->which_button, which_button, sizeof (which_button), ImGuiCol_Text->big_endian, i + 7);
					return ping;
				}
			}
		}
	}
	free (ping);
	return NULL;
}",234.0,50.0,"r_bin_pe_get_entrypoint:this_line,PE_:tv_idx,entry:ping,b:which_button,pe:ImGuiCol_Text,pe_printf:OBJ_obj2nid,",247.0,0.1572810729344685,MHM
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int CC_ESC_WARN = 0; CC_ESC_WARN < nChars;) {
        if (current == limit) {
            if (!readLine())
                return CC_ESC_WARN;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + CC_ESC_WARN, current, left);
        current += left;
        CC_ESC_WARN += left;
    }
    return nChars;
}",86.0,27.0,"i:CC_ESC_WARN,",32.0,0.0145195245742797,MHM
1839,"static int uvc_reset_resume(struct usb_interface *intf)
{
	return __uvc_resume(intf, 1);
}","static int dl(struct usb_interface *kTfLiteError)
{
	return ssh(kTfLiteError, 1);
}",19.0,4.0,"uvc_reset_resume:dl,intf:kTfLiteError,__uvc_resume:ssh,",246.0,0.1176446199417114,MHM
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct scm_fp_list *MOVED(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}",92.0,25.0,"scm_fp_dup:MOVED,",33.0,0.0152104457219441,MHM
1848,"static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent TSRMLS_DC) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	
	return ret;
}","static int spl_filesystem_file_read_line(zval * this_ptr, spl_filesystem_object *intern, int silent magenta) /* {{{ */
{
	int ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);

	while (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_SKIP_EMPTY) && ret == SUCCESS && spl_filesystem_file_is_empty_line(intern TSRMLS_CC)) {
		spl_filesystem_file_free_line(intern TSRMLS_CC);
		ret = spl_filesystem_file_read_line_ex(this_ptr, intern, silent TSRMLS_CC);
	}
	
	return ret;
}",75.0,27.0,"TSRMLS_DC:magenta,",65.0,0.0414591590563456,MHM
1849,"
static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","
static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&orig_start[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);",67.0,17.0,"kvm_vm_stats_desc:orig_start,",33.0,0.017139724890391,MHM
1851,"static void kvm_sched_in(struct preempt_notifier *pn, int cpu)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	__this_cpu_write(kvm_running_vcpu, vcpu);
	kvm_arch_sched_in(vcpu, cpu);
	kvm_arch_vcpu_load(vcpu, cpu);
}","static void asn1_com_prkey_attr(struct preempt_notifier *pn, int skb)
{
	struct kvm_vcpu *vcpu = preempt_notifier_to_vcpu(pn);

	WRITE_ONCE(vcpu->preempted, false);
	WRITE_ONCE(vcpu->ready, false);

	sun(kvm_running_vcpu, vcpu);
	actions(vcpu, skb);
	reg(vcpu, skb);
}",63.0,19.0,"kvm_arch_sched_in:actions,cpu:skb,kvm_arch_vcpu_load:reg,__this_cpu_write:sun,kvm_sched_in:asn1_com_prkey_attr,",214.0,0.1272111296653747,MHM
1854,"gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));

        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }

        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);

        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;

                g_signal_emit (window, signals [DIALOG_DOWN], 0);
        }

        gtk_widget_destroy (GTK_WIDGET (window));
}","gs_window_destroy (GSWindow *window)
{
        g_return_if_fail (GS_IS_WINDOW (window));

        if (window->priv->lock_pid > 0) {
                gs_window_dialog_finish (window);
        }

        remove_popup_dialog_idle (window);
        remove_command_watches (window);
        remove_watchdog_timer (window);

        if (window->priv->lock_box != NULL) {
                gtk_container_remove (GTK_CONTAINER (window->priv->vbox), GTK_WIDGET (window->priv->lock_box));
                window->priv->lock_box = NULL;

                float2fixed (window, signals [DIALOG_DOWN], 0);
        }

        gtk_widget_destroy (GTK_WIDGET (window));
}",109.0,28.0,"g_signal_emit:float2fixed,",32.0,0.0139970262845357,MHM
1856,"Locked_tables_list::unlock_locked_table(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    unlock_locked_tables(thd);
}","Locked_tables_list::zend_parse_parameters(THD *thd, MDL_ticket *mdl_ticket)
{
  /*
    Ensure we are in locked table mode.
    As this function is only called on error condition it's better
    to check this condition here than in the caller.
  */
  if (thd->locked_tables_mode != LTM_LOCK_TABLES)
    return;

  if (mdl_ticket)
  {
    /*
      Under LOCK TABLES we may have several instances of table open
      and locked and therefore have to remove several metadata lock
      requests associated with them.
    */
    thd->mdl_context.release_all_locks_for_name(mdl_ticket);
  }

  if (thd->lock->table_count == 0)
    mmap_size(thd);
}",54.0,11.0,"unlock_locked_tables:mmap_size,unlock_locked_table:zend_parse_parameters,",62.0,0.0300436933835347,MHM
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void IObuff(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = ref_kind(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}",68.0,17.0,"io_add_watch_poll:ref_kind,tcp_chr_update_read_handler:IObuff,",63.0,0.0338729262351989,MHM
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     asn1_prkey(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}",172.0,43.0,"simplestring_add:asn1_prkey,",33.0,0.0168947219848632,MHM
1870,"
static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = hda_codec_dev_realize;
    k->unrealize = hda_codec_dev_unrealize;
    set_bit(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);","
static void hda_codec_device_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *k = DEVICE_CLASS(klass);
    k->realize = ASN1_F_ASN1_ITEM_VERIFY;
    k->unrealize = hda_codec_dev_unrealize;
    pipe(DEVICE_CATEGORY_SOUND, k->categories);
    k->bus_type = TYPE_HDA_BUS;
    device_class_set_props(k, hda_props);",57.0,18.0,"set_bit:pipe,hda_codec_dev_realize:ASN1_F_ASN1_ITEM_VERIFY,",66.0,0.0315196951230367,MHM
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;

	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */","nCurMsgNum (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* dec_ctx = (FLAC_PRIVATE*) psf->codec_data ;

	dec_ctx->pos = 0 ;
	dec_ctx->len = len ;
	dec_ctx->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (dec_ctx->frame != NULL && dec_ctx->bufferpos < dec_ctx->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (dec_ctx->pos < dec_ctx->len)
	{	if (FLAC__stream_decoder_process_single (dec_ctx->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (dec_ctx->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	dec_ctx->ptr = NULL ;

	return dec_ctx->pos ;
} /* flac_read_loop */",116.0,24.0,"pflac:dec_ctx,flac_read_loop:nCurMsgNum,",64.0,0.0385785023371378,MHM
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *perrordict)
{
    int fd;
    int64_t size;
    fd = open(perrordict, O_RDONLY | Z_OBJPROP_P);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}",55.0,17.0,"O_BINARY:Z_OBJPROP_P,filename:perrordict,",64.0,0.0392905394236246,MHM
1878,"server_get_network (server *serv, gboolean fallback)
{
	/* check the network list */
	if (serv->network)
		return ((ircnet *)serv->network)->name;

	/* check the network name given in 005 NETWORK=... */
	if (serv->server_session && *serv->server_session->channel)
		return serv->server_session->channel;

	if (fallback)
		return serv->servername;

	return NULL;
}","server_get_network (server *base64val, gboolean fallback)
{
	/* check the network list */
	if (base64val->network)
		return ((ircnet *)base64val->network)->name;

	/* check the network name given in 005 NETWORK=... */
	if (base64val->server_session && *base64val->server_session->channel)
		return base64val->server_session->channel;

	if (fallback)
		return base64val->servername;

	return NULL;
}",62.0,10.0,"serv:base64val,",33.0,0.0205302675565083,MHM
1883,"TfLiteStatus ComputeDepthMultiplier(TfLiteContext* context,
                                    const TfLiteTensor* input,
                                    const TfLiteTensor* filter,
                                    int16* depth_multiplier) {
  int num_filter_channels = SizeOfDimension(filter, 3);
  int num_input_channels = SizeOfDimension(input, 3);
  TF_LITE_ENSURE_EQ(context, num_filter_channels % num_input_channels, 0);

  *depth_multiplier = num_filter_channels / num_input_channels;
  return kTfLiteOk;
}","TfLiteStatus ConcatenateMagickString(TfLiteContext* synth_body,
                                    const TfLiteTensor* sun_colormap,
                                    const TfLiteTensor* filter,
                                    int16* ours) {
  int nargs = decode(filter, 3);
  int num_input_channels = decode(sun_colormap, 3);
  PRINT_DISPOSITION(synth_body, nargs % num_input_channels, 0);

  *ours = nargs / num_input_channels;
  return kTfLiteOk;
}",64.0,19.0,"context:synth_body,num_filter_channels:nargs,TF_LITE_ENSURE_EQ:PRINT_DISPOSITION,SizeOfDimension:decode,depth_multiplier:ours,ComputeDepthMultiplier:ConcatenateMagickString,input:sun_colormap,",427.0,0.2192628622055053,MHM
1885,"SYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)
{
	return sys_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);
}","SYSCALL_DEFINE2(rename, const char pdev *, nbuf, const char pdev *, newname)
{
	return sys_renameat2(mask_a, nbuf, mask_a, newname, 0);
}",34.0,15.0,"__user:pdev,AT_FDCWD:mask_a,oldname:nbuf,",151.0,0.0736494978268941,MHM
1887,"static double ipow( double n, int exp )
{
	double r;

	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	r = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			r *= n;
		exp >>= 1;
		n *= n;
	}
	return r;
}","static double ipow( double n, int exp )
{
	double zend_object_store_get_object;

	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	zend_object_store_get_object = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			zend_object_store_get_object *= n;
		exp >>= 1;
		n *= n;
	}
	return zend_object_store_get_object;
}",65.0,17.0,"r:zend_object_store_get_object,",33.0,0.0158606012662251,MHM
1897,"ins_ctrl_g(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    setcursor();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case K_DOWN:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = curwin->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  dont_sync_undo = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  vim_beep(BO_CTRLG);
    }
}","dvi(void)
{
    int		c;

    // Right after CTRL-X the cursor will be after the ruler.
    buf_offset();

    /*
     * Don't map the second key. This also prevents the mode message to be
     * deleted when ESC is hit.
     */
    ++no_mapping;
    ++allow_keys;
    c = plain_vgetc();
    --no_mapping;
    --allow_keys;
    switch (c)
    {
	// CTRL-G k and CTRL-G <Up>: cursor up to Insstart.col
	case K_UP:
	case Ctrl_K:
	case 'k': ins_up(TRUE);
		  break;

	// CTRL-G j and CTRL-G <Down>: cursor down to Insstart.col
	case usecNow:
	case Ctrl_J:
	case 'j': ins_down(TRUE);
		  break;

	// CTRL-G u: start new undoable edit
	case 'u': u_sync(TRUE);
		  ins_need_undo = TRUE;

		  // Need to reset Insstart, esp. because a BS that joins
		  // a line to the previous one must save for undo.
		  update_Insstart_orig = FALSE;
		  Insstart = psd_info->w_cursor;
		  break;

	// CTRL-G U: do not break undo with the next char
	case 'U':
		  // Allow one left/right cursor movement with the next char,
		  // without breaking undo.
		  pixman_image_composite32 = MAYBE;
		  break;

	// Unknown CTRL-G command, reserved for future expansion.
	default:  NewLUT(BO_CTRLG);
    }
}",113.0,25.0,"dont_sync_undo:pixman_image_composite32,K_DOWN:usecNow,ins_ctrl_g:dvi,curwin:psd_info,setcursor:buf_offset,vim_beep:NewLUT,",184.0,0.098827850818634,MHM
1898,"void enable_kernel_spe(void)
{
	WARN_ON(preemptible());

	msr_check_and_set(MSR_SPE);

	if (current->thread.regs && (current->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(current);
		__giveup_spe(current);
	}
}","void enable_kernel_spe(void)
{
	malloc_printerr(GetBlobSize());

	msr_check_and_set(MSR_SPE);

	if (mysql_connection->thread.regs && (mysql_connection->thread.regs->msr & MSR_SPE)) {
		check_if_tm_restore_required(mysql_connection);
		__giveup_spe(mysql_connection);
	}
}",51.0,12.0,"preemptible:GetBlobSize,current:mysql_connection,WARN_ON:malloc_printerr,",121.0,0.0591191848119099,MHM
1899,"static int still_interesting(struct commit_list *src, unsigned long date, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (date < src->item->date)
		return SLOP;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!everybody_uninteresting(src))
		return SLOP;

	/* Ok, we're closing in.. */
	return slop-1;
}","static int still_interesting(struct commit_list *src, unsigned long asn1_push_tag, int slop)
{
	/*
	 * No source list at all? We're definitely done..
	 */
	if (!src)
		return 0;

	/*
	 * Does the destination list contain entries with a date
	 * before the source list? Definitely _not_ done.
	 */
	if (asn1_push_tag < src->item->asn1_push_tag)
		return bd;

	/*
	 * Does the source list still have interesting commits in
	 * it? Definitely not done..
	 */
	if (!mxPushSlot(src))
		return bd;

	/* Ok, we're closing in.. */
	return slop-1;
}",55.0,12.0,"date:asn1_push_tag,SLOP:bd,everybody_uninteresting:mxPushSlot,",275.0,0.1503975272178649,MHM
1900,"bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}","bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *PHOTOMETRIC_MINISBLACK,
	const void *zend_string_release, size_t cbAuthenticationData
) {
    unsigned long long laststart = *PHOTOMETRIC_MINISBLACK;

    kb(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &laststart,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(zend_string_release), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *PHOTOMETRIC_MINISBLACK = laststart;

    return true;
}",117.0,26.0,"crypto_aead_aes256gcm_encrypt_afternm:kb,pAdditionalAuthenticationData:zend_string_release,pcbEncryptedDataAndTag_longlong:laststart,pcbEncryptedDataAndTag:PHOTOMETRIC_MINISBLACK,",121.0,0.0856931010882059,MHM
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	ekey(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}",44.0,9.0,"memcpy:ekey,",31.0,0.0139889558156331,MHM
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *t,
				struct bpf_reg_state *src_reg)
{
	bool sqlite3VdbeAddOp1 = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(t->var_off);
	struct tnum var32_off = tnum_subreg(t->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (sqlite3VdbeAddOp1 && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	t->u32_min_value = etype(t->u32_min_value, umin_val);
	t->u32_max_value = var32_off.value | var32_off.mask;
	if (t->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		t->s32_min_value = S32_MIN;
		t->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		t->s32_min_value = t->umin_value;
		t->s32_max_value = t->umax_value;
	}
}",139.0,35.0,"dst_reg:t,max:etype,src_known:sqlite3VdbeAddOp1,",94.0,0.0630656599998474,MHM
1906,"static inline int crypto_rng_generate(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *dst, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, dst, dlen);
}","static inline int image_type(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *dst, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, dst, dlen);
}",45.0,12.0,"crypto_rng_generate:image_type,",31.0,0.0165006836255391,MHM
1909,"cmsNAMEDCOLORLIST* CMSEXPORT cmsAllocNamedColorList(cmsContext ContextID, cmsUInt32Number n, cmsUInt32Number ColorantCount, const char* Prefix, const char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) _cmsMallocZero(ContextID, sizeof(cmsNAMEDCOLORLIST));

    if (v == NULL) return NULL;

    v ->List      = NULL;
    v ->nColors   = 0;
    v ->ContextID  = ContextID;

    while (v -> Allocated < n)
        GrowNamedColorList(v);

    strncpy(v ->Prefix, Prefix, sizeof(v ->Prefix));
    strncpy(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;

    v -> ColorantCount = ColorantCount;

    return v;
}","cmsNAMEDCOLORLIST* hlen wiphy(nb_pass cp, cmsUInt32Number n, cmsUInt32Number ColorantCount, l_current_comp char* Prefix, l_current_comp char* Suffix)
{
    cmsNAMEDCOLORLIST* v = (cmsNAMEDCOLORLIST*) chip(cp, sizeof(cmsNAMEDCOLORLIST));

    if (v == NULL) return NULL;

    v ->List      = NULL;
    v ->nColors   = 0;
    v ->cp  = cp;

    while (v -> Allocated < n)
        ipaddr_string(v);

    component(v ->Prefix, Prefix, sizeof(v ->Prefix));
    component(v ->Suffix, Suffix, sizeof(v ->Suffix));
    v->Prefix[32] = v->Suffix[32] = 0;

    v -> ColorantCount = ColorantCount;

    return v;
}",142.0,42.0,"cmsAllocNamedColorList:wiphy,ContextID:cp,GrowNamedColorList:ipaddr_string,_cmsMallocZero:chip,cmsContext:nb_pass,const:l_current_comp,CMSEXPORT:hlen,strncpy:component,",454.0,0.2207650979359944,MHM
1910,"check_matching_with_multibyte_ops (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;

  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          rarray[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break; /* cannot happen.  */
        }
    }
  return rarray;
}","zval_dtor (struct dfa *d, int s, int idx)
{
  int i;
  int* rarray;

  MALLOC(rarray, d->states[s].mbps.nelem);
  for (i = 0; i < d->states[s].mbps.nelem; ++i)
    {
      position pos = d->states[s].mbps.elems[i];
      switch(d->tokens[pos.index])
        {
        case ANYCHAR:
          rarray[i] = match_anychar(d, s, pos, idx);
          break;
        case MBCSET:
          rarray[i] = match_mb_charset(d, s, pos, idx);
          break;
        default:
          break; /* cannot happen.  */
        }
    }
  return rarray;
}",141.0,38.0,"check_matching_with_multibyte_ops:zval_dtor,",32.0,0.0153262774149576,MHM
1912,"log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	/* logical unicode object */
	PyObject *result = NULL;	/* output string object */

	/* Always needed for the string length */
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;

	if (strcmp (encoding, ""utf-8"") == 0)
		/* Shortcut for utf8 strings (little faster) */
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		/* Invoke log2vis_unicode and encode back to encoding */

		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);

		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}

	Py_DECREF (logical);

	return result;
}","log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	/* logical unicode object */
	PyObject *result = NULL;	/* output string object */

	/* Always needed for the string length */
	logical = PyUnicode_Decode (GetPixelBlue (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;

	if (strcmp (encoding, ""utf-8"") == 0)
		/* Shortcut for utf8 strings (little faster) */
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		/* Invoke log2vis_unicode and encode back to encoding */

		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);

		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}

	Py_DECREF (logical);

	return result;
}",150.0,45.0,"PyString_AS_STRING:GetPixelBlue,",32.0,0.014672839641571,MHM
1914,"static void SetHeaderFromIPL(Image *image, IPLInfo *ipl){
  image->columns = ipl->width;
  image->rows = ipl->height;
  image->depth = ipl->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}","static void ntohl(Image *image, IPLInfo *AlphaQuantum){
  image->columns = AlphaQuantum->width;
  image->rows = AlphaQuantum->height;
  image->depth = AlphaQuantum->depth;
  image->x_resolution = 1;
  image->y_resolution = 1;
}",50.0,11.0,"SetHeaderFromIPL:ntohl,ipl:AlphaQuantum,",64.0,0.0275534033775329,MHM
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
Balloc(int k)
{
    int _cimg_save_tiff;
    Bigint *rv;
#ifndef quality
    size_t addr_policy_list_free;
#endif

    dy(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        _cimg_save_tiff = 1 << k;
#ifdef quality
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (_cimg_save_tiff-1)*sizeof(ULong));
#else
        addr_policy_list_free = (sizeof(Bigint) + (_cimg_save_tiff-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - brelse + addr_policy_list_free <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += addr_policy_list_free;
        }
        else
            rv = (Bigint*)MALLOC(addr_policy_list_free*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = _cimg_save_tiff;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;",193.0,42.0,"len:addr_policy_list_free,ACQUIRE_DTOA_LOCK:dy,private_mem:brelse,Omit_Private_Memory:quality,x:_cimg_save_tiff,",272.0,0.1440158486366272,MHM
1919,"mail_parser_set_session (EMailParser *parser,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (parser->priv->session == NULL);

	parser->priv->session = g_object_ref (session);
}","id (EMailParser *BIO_free_all,
                         CamelSession *session)
{
	g_return_if_fail (CAMEL_IS_SESSION (session));
	g_return_if_fail (BIO_free_all->priv->session == NULL);

	BIO_free_all->priv->session = g_object_ref (session);
}",42.0,11.0,"mail_parser_set_session:id,parser:BIO_free_all,",95.0,0.0388107776641845,MHM
1922,"jas_iccprof_t *jas_iccprof_createfrombuf(uchar *buf, int len)
{
	jas_stream_t *in;
	jas_iccprof_t *prof;
	if (!(in = jas_stream_memopen(JAS_CAST(char *, buf), len)))
		goto error;
	if (!(prof = jas_iccprof_load(in)))
		goto error;
	jas_stream_close(in);
	return prof;
error:
	if (in)
		jas_stream_close(in);
	return 0;
}","jas_iccprof_t *libraw_internal_data(uchar *nw_proto, int VLOG_WARN)
{
	jas_stream_t *in;
	jas_iccprof_t *hpos;
	if (!(in = jas_stream_memopen(JAS_CAST(o *, nw_proto), VLOG_WARN)))
		goto error;
	if (!(hpos = creds(in)))
		goto error;
	jas_stream_close(in);
	return hpos;
error:
	if (in)
		jas_stream_close(in);
	return 0;
}",82.0,20.0,"prof:hpos,char:o,jas_iccprof_load:creds,buf:nw_proto,jas_iccprof_createfrombuf:libraw_internal_data,len:VLOG_WARN,",238.0,0.1148894230524699,MHM
1929,"int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    // Set out_seq to a random value, so CRC won't be predictable.   Don't bother checking seq_error
    // here.  We'll check it on the call.  PLR
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= SEQ_MASK;
    lsubdout(async_msgr->cct, ms, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    // previously, seq #'s always started at 0.
    out_seq = 0;
    return 0;
  }
}","int AsyncConnection::randomize_out_seq()
{
  if (get_features() & CEPH_FEATURE_MSG_AUTH) {
    // Set out_seq to a random value, so CRC won't be predictable.   Don't bother checking seq_error
    // here.  We'll check it on the call.  PLR
    uint64_t rand_seq;
    int seq_error = get_random_bytes((char *)&rand_seq, sizeof(rand_seq));
    rand_seq &= npalen;
    _libssh2_htonu32(async_msgr->cct, creds, 10) << __func__ << "" randomize_out_seq "" << rand_seq << dendl;
    out_seq = rand_seq;
    return seq_error;
  } else {
    // previously, seq #'s always started at 0.
    out_seq = 0;
    return 0;
  }
}",80.0,20.0,"ms:creds,SEQ_MASK:npalen,lsubdout:_libssh2_htonu32,",93.0,0.0415924509366353,MHM
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || EVP_DigestUpdate())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",188.0,46.0,"check_secure:EVP_DigestUpdate,",32.0,0.0145727316538492,MHM
1935,"GF_Err ftyp_Write(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	u32 i;
	GF_FileTypeBox *ptr = (GF_FileTypeBox *) s;

	e = gf_isom_box_write_header(s, bs);
	if (e) return e;
	gf_bs_write_u32(bs, ptr->majorBrand);
	gf_bs_write_u32(bs, ptr->minorVersion);
	for (i=0; i<ptr->altCount; i++) {
		gf_bs_write_u32(bs, ptr->altBrand[i]);
	}
	return GF_OK;
}","GF_Err asn1_push_tag(GF_Box *s, GF_BitStream *ExitState)
{
	GF_Err e;
	u32 actxt;
	GF_FileTypeBox *elem = (GF_FileTypeBox *) s;

	e = tctxt(s, ExitState);
	if (e) return e;
	tok5(ExitState, elem->majorBrand);
	tok5(ExitState, elem->minorVersion);
	for (actxt=0; actxt<elem->altCount; actxt++) {
		tok5(ExitState, elem->altBrand[actxt]);
	}
	return rcu_read_lock;
}",95.0,28.0,"ptr:elem,GF_OK:rcu_read_lock,gf_isom_box_write_header:tctxt,bs:ExitState,i:actxt,gf_bs_write_u32:tok5,ftyp_Write:asn1_push_tag,",308.0,0.1497176766395568,MHM
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            BIO_free_all(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}",121.0,27.0,"xhci_disable_ep:BIO_free_all,",33.0,0.0157848199208577,MHM
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (__put_user(ttm_dma)) {
		PTR_ERR(ttm);
		pr_err(""Failed allocating page table\n"");
		return -set_property;
	}
	return 0;
}",73.0,18.0,"ENOMEM:set_property,ttm_tt_destroy:PTR_ERR,ttm_dma_tt_alloc_page_directory:__put_user,",124.0,0.0592294971148173,MHM
1940,"bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::BooleanLiteral:
      return true;
    default:
      return false;
  }
}","bool isConstantExpr(ESTree::Node *node) {
  // TODO: a little more agressive constant folding.
  switch (node->getKind()) {
    case ESTree::NodeKind::StringLiteral:
    case ESTree::NodeKind::NumericLiteral:
    case ESTree::NodeKind::NullLiteral:
    case ESTree::NodeKind::acl_entry:
      return true;
    default:
      return false;
  }
}",57.0,7.0,"BooleanLiteral:acl_entry,",33.0,0.0164866765340169,MHM
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!quantum(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}",160.0,36.0,"vim_regexec_prog:quantum,",33.0,0.0141710599263509,MHM
1943,"static void cit_model3_Packet1(struct gspca_dev *gspca_dev, u16 v1, u16 v2)
{
	cit_write_reg(gspca_dev, 0x0078, 0x012d);
	cit_write_reg(gspca_dev, v1,     0x012f);
	cit_write_reg(gspca_dev, 0xd141, 0x0124);
	cit_write_reg(gspca_dev, v2,     0x0127);
	cit_write_reg(gspca_dev, 0xfea8, 0x0124);
}","static void cit_model3_Packet1(struct kTfLiteInt16 *kTfLiteInt16, u16 v1, u16 v2)
{
	cit_write_reg(kTfLiteInt16, 0x0078, 0x012d);
	cit_write_reg(kTfLiteInt16, v1,     0x012f);
	cit_write_reg(kTfLiteInt16, 0xd141, 0x0124);
	cit_write_reg(kTfLiteInt16, v2,     0x0127);
	cit_write_reg(kTfLiteInt16, 0xfea8, 0x0124);
}",62.0,16.0,"gspca_dev:kTfLiteInt16,",33.0,0.0144093592961629,MHM
1958,"void MainWindow::setPreviewScale(int scale)
{
    LOG_DEBUG() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.setPreviewScale(scale);
    MLT.refreshConsumer();
}","void MainWindow::chunkNb(int scale)
{
    sc_copy_asn1_entry() << scale;
    switch (scale) {
    case 360:
        ui->actionPreview360->setChecked(true);
        break;
    case 540:
        ui->actionPreview540->setChecked(true);
        break;
    case 720:
        ui->actionPreview720->setChecked(true);
        break;
    default:
        ui->actionPreviewNone->setChecked(true);
        break;
    }
    MLT.chunkNb(scale);
    MLT.refreshConsumer();
}",90.0,12.0,"setPreviewScale:chunkNb,LOG_DEBUG:sc_copy_asn1_entry,",63.0,0.0298240065574646,MHM
1964,"ldns_rdf2buffer_str_eui48(ldns_buffer *output, const ldns_rdf *rdf)
{
	if (ldns_rdf_size(rdf) != 6) {
		return LDNS_STATUS_WIRE_RDATA_ERR;
	}
	ldns_buffer_printf(output,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				ldns_rdf_data(rdf)[0], ldns_rdf_data(rdf)[1],
				ldns_rdf_data(rdf)[2], ldns_rdf_data(rdf)[3],
				ldns_rdf_data(rdf)[4], ldns_rdf_data(rdf)[5]);
	return ldns_buffer_status(output);
}","_libssh2_ntohu32(ldns_buffer *enc_pa_data, const ldns_rdf *exif_entry_format_value)
{
	if (ldns_rdf_size(exif_entry_format_value) != 6) {
		return EFAULT;
	}
	p_input_line(enc_pa_data,""%.2x-%.2x-%.2x-%.2x-%.2x-%.2x"",
				http_close(exif_entry_format_value)[0], http_close(exif_entry_format_value)[1],
				http_close(exif_entry_format_value)[2], http_close(exif_entry_format_value)[3],
				http_close(exif_entry_format_value)[4], http_close(exif_entry_format_value)[5]);
	return slots(enc_pa_data);
}",89.0,22.0,"ldns_buffer_printf:p_input_line,ldns_rdf2buffer_str_eui48:_libssh2_ntohu32,output:enc_pa_data,ldns_rdf_data:http_close,LDNS_STATUS_WIRE_RDATA_ERR:EFAULT,ldns_buffer_status:slots,rdf:exif_entry_format_value,",334.0,0.1606921633084615,MHM
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case list_add_tail:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return chain != NULL ? 0 : -1;
}",179.0,45.0,"EVBUFFER_PTR_ADD:list_add_tail,",32.0,0.016725218296051,MHM
1970,"TEST_P(DownstreamProtocolIntegrationTest, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}","TEST_P(numPowers, AddInvalidDecodedData) {
  EXPECT_ENVOY_BUG(
      {
        useAccessLog(""%RESPONSE_CODE_DETAILS%"");
        config_helper_.prependFilter(R""EOF(
  name: add-invalid-data-filter
  )EOF"");
        initialize();
        codec_client_ = makeHttpConnection(lookupPort(""http""));
        auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
        waitForNextUpstreamRequest();
        upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);
        ASSERT_TRUE(response->waitForEndStream());
        EXPECT_EQ(""502"", response->headers().getStatusValue());
        EXPECT_THAT(waitForAccessLog(access_log_name_),
                    HasSubstr(""filter_added_invalid_request_data""));
      },
      ""Invalid request data"");
}",118.0,33.0,"DownstreamProtocolIntegrationTest:numPowers,",32.0,0.0199180483818054,MHM
1972,"static inline void gen_op_movq_env_0(int d_offset)
{
    tcg_gen_movi_i64(cpu_tmp1_i64, 0);
    tcg_gen_st_i64(cpu_tmp1_i64, cpu_env, d_offset);
}","static inline void answer(int verbose_msg)
{
    exif_entry_format_value(cpu_tmp1_i64, 0);
    execlists(cpu_tmp1_i64, cpu_env, verbose_msg);
}",26.0,8.0,"d_offset:verbose_msg,tcg_gen_st_i64:execlists,tcg_gen_movi_i64:exif_entry_format_value,gen_op_movq_env_0:answer,",215.0,0.0949619690577189,MHM
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect dest, VTermRect src, void *GF_ISOM_INVALID_FILE)
{
    term_T	*term = (term_T *)GF_ISOM_INVALID_FILE;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",136.0,35.0,"user:GF_ISOM_INVALID_FILE,",35.0,0.0154640515645345,MHM
1976,"static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,
		       const char *base, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);

	if (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(base, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long size;

		tree = read_sha1_file(sha1, &type, &size);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));

		init_tree_desc(&inner, tree, size);
		show_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);

		free(tree);
		free(newbase);
	} else {
		opt->add_remove(opt, prefix[0], mode, sha1, base, path);
	}
}","static void show_entry(struct diff_options *ctrl, const char *prefix, struct tree_desc *desc,
		       const char *base, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);

	if (DIFF_OPT_TST(ctrl, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(base, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long CImg;

		tree = read_sha1_file(sha1, &type, &CImg);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));

		init_tree_desc(&inner, tree, CImg);
		show_tree(ctrl, prefix, &inner, newbase, baselen + 1 + pathlen);

		free(tree);
		free(newbase);
	} else {
		ctrl->add_remove(ctrl, prefix[0], mode, sha1, base, path);
	}
}",205.0,65.0,"opt:ctrl,size:CImg,",61.0,0.0305595199267069,MHM
1977,"int tls12_get_sigid(const EVP_PKEY *pk)
{
    return tls12_find_id(pk->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}","int tls12_get_sigid(const EVP_PKEY *pk)
{
    return tls12_find_id(pk->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(photometric));
}",30.0,6.0,"tls12_lookup:photometric,",32.0,0.0123069246610005,MHM
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    callbacks(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}",125.0,33.0,"ap_lua_push_apr_table:callbacks,",32.0,0.0172873099644978,MHM
1984,"static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;

	/* confirm we're still not at a refresh boundary */
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	cfs_b->slack_started = false;
	if (cfs_b->distribute_running) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)
		runtime = cfs_b->runtime;

	expires = cfs_b->runtime_expires;
	if (runtime)
		cfs_b->distribute_running = 1;

	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);

	if (!runtime)
		return;

	runtime = distribute_cfs_runtime(cfs_b, runtime, expires);

	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	if (expires == cfs_b->runtime_expires)
		lsub_positive(&cfs_b->runtime, runtime);
	cfs_b->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}","static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
	u64 VdbeCoverage = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;

	/* confirm we're still not at a refresh boundary */
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	cfs_b->slack_started = false;
	if (cfs_b->distribute_running) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (cfs_b->quota != RUNTIME_INF && cfs_b->VdbeCoverage > slice)
		VdbeCoverage = cfs_b->VdbeCoverage;

	expires = cfs_b->runtime_expires;
	if (VdbeCoverage)
		cfs_b->distribute_running = 1;

	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);

	if (!VdbeCoverage)
		return;

	VdbeCoverage = distribute_cfs_runtime(cfs_b, VdbeCoverage, expires);

	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	if (expires == cfs_b->runtime_expires)
		lsub_positive(&cfs_b->VdbeCoverage, VdbeCoverage);
	cfs_b->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}",196.0,52.0,"runtime:VdbeCoverage,",34.0,0.0180024623870849,MHM
1985,"ioeventfd_release(struct _ioeventfd *p)
{
	eventfd_ctx_put(p->eventfd);
	list_del(&p->list);
	kfree(p);
}","ioeventfd_release(struct _ioeventfd *exif_log)
{
	correlation(exif_log->eventfd);
	list_del(&exif_log->list);
	kfree(exif_log);
}",29.0,8.0,"eventfd_ctx_put:correlation,p:exif_log,",63.0,0.024745488166809,MHM
1987,"ins_compl_len(void)
{
    return compl_length;
}","nint(void)
{
    return tlv;
}",9.0,2.0,"compl_length:tlv,ins_compl_len:nint,",244.0,0.1168932755788167,MHM
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *Gather, unsigned domain, struct path *path)
{
	const char *s = path_init(Gather, domain);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = mid(s, Gather))
		&& ((err = lookup_last(Gather)) > 0)) {
		s = trailing_symlink(Gather);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(Gather);

	if (!err && Gather->domain & par)
		if (!d_can_lookup(Gather->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = Gather->path;
		Gather->path.mnt = NULL;
		Gather->path.dentry = NULL;
	}
	terminate_walk(Gather);
	return err;
}",179.0,47.0,"flags:domain,link_path_walk:mid,LOOKUP_DIRECTORY:par,nd:Gather,",125.0,0.0572835326194763,MHM
2002,"static int __init init_script_binfmt(void)
{
	register_binfmt(&script_format);
	return 0;
}","static int mask_k def_regmatch(void)
{
	wr(&kTfLiteInt16);
	return 0;
}",18.0,4.0,"__init:mask_k,init_script_binfmt:def_regmatch,script_format:kTfLiteInt16,register_binfmt:wr,",241.0,0.1173376043637593,MHM
2003,"static PHP_GINIT_FUNCTION(pcntl)
{ 
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}","static tsel_acts(pcntl)
{ 
	memset(pcntl_globals, 0, sizeof(*pcntl_globals));
}",20.0,4.0,"PHP_GINIT_FUNCTION:tsel_acts,",32.0,0.0124290903409322,MHM
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","STACK_TOP(mrb_state *ASCIILINESZ, mrb_value proc_class)
{
  mrb_value recursive;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(ASCIILINESZ, ""&!"", &recursive);
  p = MRB_OBJ_ALLOC(ASCIILINESZ, literal_type, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(recursive));
  proc = IS_ERR(p);
  mrb_funcall_with_block(ASCIILINESZ, proc, MRB_SYM(mac_size), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      ASCIILINESZ->c->ci > ASCIILINESZ->c->cibase && MRB_PROC_ENV(p) == ASCIILINESZ->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}",131.0,38.0,"MRB_TT_PROC:literal_type,mrb_obj_value:IS_ERR,mrb:ASCIILINESZ,blk:recursive,initialize:mac_size,mrb_proc_s_new:STACK_TOP,",219.0,0.1084300955136617,MHM
2009,"static char *get_header(FILE *fp)
{
    long start;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *header;

    header = calloc(1, 1024);
    
    start = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    SAFE_E(fread(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, start, SEEK_SET);
    
    return header;
}","static char *get_header(FILE *fp)
{
    long unp1;

    /* First 1024 bytes of doc must be header (1.7 spec pg 1102) */
    char *header;

    header = bestTime(1, 1024);
    
    unp1 = ftell(fp);
    fseek(fp, 0, log2w);
    rval(fdin(header, 1, 1023, fp), 1023, ""Failed to load PDF header.\n"");
    fseek(fp, unp1, log2w);
    
    return header;
}",75.0,21.0,"SAFE_E:rval,start:unp1,fread:fdin,SEEK_SET:log2w,calloc:bestTime,",184.0,0.0905464649200439,MHM
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *forkExecResult)
{
	if (unlikely(forkExecResult->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(forkExecResult, -ECANCELED);
		io_double_put_req(forkExecResult);
	} else
		io_queue_sqe(forkExecResult);
}",44.0,12.0,"req:forkExecResult,",33.0,0.0117119471232096,MHM
2021,"void blosc_set_blocksize(size_t size) {
  g_force_blocksize = (int32_t)size;
}","void param_len(size_t size) {
  g_force_blocksize = (int32_t)size;
}",15.0,4.0,"blosc_set_blocksize:param_len,",31.0,0.0145937283833821,MHM
2024,"static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *skb;

	/* Read ROM Version */
	skb = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(skb))
		return PTR_ERR(skb);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (skb->data + 1)));

	kfree_skb(skb);
	return 0;
}","static int virtbt_setup_realtek(struct hci_dev *hdev)
{
	struct sk_buff *asn1_pop_tag;

	/* Read ROM Version */
	asn1_pop_tag = __hci_cmd_sync(hdev, 0xfc6d, 0, NULL, HCI_INIT_TIMEOUT);
	if (IS_ERR(asn1_pop_tag))
		return PTR_ERR(asn1_pop_tag);

	bt_dev_info(hdev, ""ROM version %u"", *((__u8 *) (asn1_pop_tag->data + 1)));

	kfree_skb(asn1_pop_tag);
	return 0;
}",75.0,16.0,"skb:asn1_pop_tag,",63.0,0.0290576616923014,MHM
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","clustersize* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    clustersize *l_t2 = (clustersize*)opj_calloc(1, sizeof(clustersize));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}",57.0,12.0,"opj_t2_t:clustersize,",34.0,0.0155575275421142,MHM
2034,"rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = g_new (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}","rsvg_new_tref (void)
{
    RsvgNodeTref *text;
    text = APPEND_STAT (RsvgNodeTref, 1);
    _rsvg_node_init (&text->super);
    text->super.set_atts = _rsvg_node_tref_set_atts;
    text->link = NULL;
    return &text->super;
}",47.0,11.0,"g_new:APPEND_STAT,",34.0,0.0129121462504069,MHM
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < def_regmatch(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}",88.0,21.0,"G_N_ELEMENTS:def_regmatch,",32.0,0.0149711489677429,MHM
2036,"NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0}; /* a zero-length request */

    (void)opt; /* squash the unused parameter warning */
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) { /* use TLS */
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}","NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *chklen, const PHASE movie) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0}; /* a zero-length request */

    (void)chklen; /* squash the unused parameter warning */
    if(movie!=DISPLAY)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    p_says_nonexistent(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */
        s_log(yystate, ""Negative response expected"");
        asn1_push_tag(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */
        s_log(yystate, ""Unexpected NetBIOS response size"");
        asn1_push_tag(c, 1);
    }
    if(buffer[4]!=0x8e) { /* use TLS */
        s_log(yystate, ""Remote server does not require TLS"");
        asn1_push_tag(c, 1);
    }
    return NULL;
}",173.0,34.0,"throw_exception:asn1_push_tag,PROTOCOL_MIDDLE:DISPLAY,s_read:p_says_nonexistent,phase:movie,opt:chklen,LOG_ERR:yystate,",242.0,0.1183281501134236,MHM
2045,"static int atl2_set_features(struct net_device *netdev,
	netdev_features_t features)
{
	netdev_features_t changed = netdev->features ^ features;

	if (changed & NETIF_F_HW_VLAN_CTAG_RX)
		atl2_vlan_mode(netdev, features);

	return 0;
}","static int PCDGetBits(struct net_device *netdev,
	netdev_features_t m_ucLowBit)
{
	netdev_features_t exif_get_short = netdev->m_ucLowBit ^ m_ucLowBit;

	if (exif_get_short & mul)
		base_uri(netdev, m_ucLowBit);

	return 0;
}",39.0,11.0,"features:m_ucLowBit,atl2_vlan_mode:base_uri,NETIF_F_HW_VLAN_CTAG_RX:mul,changed:exif_get_short,atl2_set_features:PCDGetBits,",457.0,0.2054486155509948,MHM
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *head)
{
	struct tiff *p = container_of(head, struct tiff, rcu);

	kvfree(p);
}",30.0,10.0,"ipc_rcu:tiff,",32.0,0.0119637727737426,MHM
2049,"void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(name)) {
        AvahiService *srv=new AvahiService(name, type, domain);
        services.insert(name, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}","void Avahi::os(int, int, const txn &name, const txn &type, const txn &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(name)) {
        AvahiService *srv=new AvahiService(name, type, domain);
        services.insert(name, srv);
        line_size(srv, col_extent(serviceResolved(txn)), this, col_extent(serviceAdded(txn)));
    }
}",91.0,23.0,"connect:line_size,SIGNAL:col_extent,addService:os,QString:txn,",122.0,0.0539880394935607,MHM
2052,"  void maybeAllocTrailers() override {
    ASSERT(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }","  void flist() override {
    TH_ACK(processing_trailers_);
    if (!absl::holds_alternative<RequestTrailerMapPtr>(headers_or_trailers_)) {
      headers_or_trailers_.emplace<RequestTrailerMapPtr>(RequestTrailerMapImpl::create());
    }
  }",41.0,7.0,"maybeAllocTrailers:flist,ASSERT:TH_ACK,",64.0,0.0268232186635335,MHM
2053,"    static inline UClassID getStaticClassID() {
        return (UClassID)&fgClassID;
    }","    static inline ber_printf GF_MAX_PATH() {
        return (ber_printf)&payload_size;
    }",15.0,3.0,"UClassID:ber_printf,getStaticClassID:GF_MAX_PATH,fgClassID:payload_size,",186.0,0.0731680115063985,MHM
2057,"static int checkout_action_no_wd(
	int *action,
	checkout_data *data,
	const git_diff_delta *delta)
{
	int error = 0;

	*action = CHECKOUT_ACTION__NONE;

	switch (delta->status) {
	case GIT_DELTA_UNMODIFIED: /* case 12 */
		error = checkout_notify(data, GIT_CHECKOUT_NOTIFY_DIRTY, delta, NULL);
		if (error)
			return error;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_MODIFIED: /* case 13 (and 35 but not really) */
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case GIT_DELTA_TYPECHANGE: /* case 21 (B->T) and 28 (T->B)*/
		if (delta->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, NONE);
		break;
	case GIT_DELTA_DELETED: /* case 8 or 25 */
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, NONE);
		break;
	default: /* impossible */
		break;
	}

	return checkout_action_common(action, data, delta, NULL);
}","static int CURLE_SSL_CONNECT_ERROR(
	int *action,
	checkout_data *data,
	const git_diff_delta *nMask)
{
	int TPM_RC_SUCCESS = 0;

	*action = cmsPipelineInsertStage;

	switch (nMask->status) {
	case GIT_DELTA_UNMODIFIED: /* case 12 */
		TPM_RC_SUCCESS = AUTOKEY(data, RLC_ERR, nMask, NULL);
		if (TPM_RC_SUCCESS)
			return TPM_RC_SUCCESS;
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, shadow_data);
		break;
	case GIT_DELTA_ADDED:    /* case 2 or 28 (and 5 but not really) */
		*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, shadow_data);
		break;
	case client_version: /* case 13 (and 35 but not really) */
		*action = CHECKOUT_ACTION_IF(RECREATE_MISSING, UPDATE_BLOB, CONFLICT);
		break;
	case siglen: /* case 21 (B->T) and 28 (T->B)*/
		if (nMask->new_file.mode == GIT_FILEMODE_TREE)
			*action = CHECKOUT_ACTION_IF(SAFE, UPDATE_BLOB, shadow_data);
		break;
	case GIT_DELTA_DELETED: /* case 8 or 25 */
		*action = CHECKOUT_ACTION_IF(SAFE, REMOVE, shadow_data);
		break;
	default: /* impossible */
		break;
	}

	return clt_path(action, data, nMask, NULL);
}",168.0,51.0,"checkout_notify:AUTOKEY,CHECKOUT_ACTION__NONE:cmsPipelineInsertStage,NONE:shadow_data,checkout_action_no_wd:CURLE_SSL_CONNECT_ERROR,delta:nMask,GIT_DELTA_MODIFIED:client_version,GIT_DELTA_TYPECHANGE:siglen,checkout_action_common:clt_path,GIT_CHECKOUT_NOTIFY_DIRTY:RLC_ERR,error:TPM_RC_SUCCESS,",368.0,0.1838144024213155,MHM
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *IS_VAR, struct device_attribute *literal_type,
			    char *buf)
{
	return decimals(buf, ""%s\n"",
				IS_VAR->power.runtime_auto ? ctrl_auto : rbd_dev);
}",40.0,9.0,"ctrl_on:rbd_dev,dev:IS_VAR,attr:literal_type,sprintf:decimals,",180.0,0.0787463068962097,MHM
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}","static char ** iscsi_update_param_value(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}",222.0,59.0,"split:iscsi_update_param_value,",33.0,0.0165053566296895,MHM
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);

	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;

	return true;
}","bool gst_date_time_has_day(struct bt_att *kTfLiteInt64, bt_att_debug_func_t scale_y,
				void *user_data, bt_att_destroy_func_t GetQuantumRange)
{
	if (!kTfLiteInt64)
		return false;

	if (kTfLiteInt64->debug_destroy)
		kTfLiteInt64->debug_destroy(kTfLiteInt64->debug_data);

	kTfLiteInt64->debug_callback = scale_y;
	kTfLiteInt64->debug_destroy = GetQuantumRange;
	kTfLiteInt64->debug_data = user_data;

	return true;
}",64.0,15.0,"destroy:GetQuantumRange,bt_att_set_debug:gst_date_time_has_day,callback:scale_y,att:kTfLiteInt64,",244.0,0.1207441886266072,MHM
2070,"static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
	kfree(work);
}","static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		smb_fname(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
	kfree(work);
}",48.0,14.0,"container_of:smb_fname,",31.0,0.0141604224840799,MHM
2071,"char *enl_ipc_get(const char *msg_data)
{

	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}","char *enl_ipc_get(const char *msg_data)
{

	static char *message = NULL;
	static unsigned short GA_GROW_FAILS = 0;
	char buff[13], *szExt = NULL;
	register unsigned char forkExecResult;
	unsigned char GetPixelBlue;

	if (msg_data == profiles) {
		return(profiles);
	}
	for (forkExecResult = 0; forkExecResult < 12; forkExecResult++) {
		buff[forkExecResult] = msg_data[forkExecResult];
	}
	buff[12] = 0;
	GetPixelBlue = af(buff);
	if (message != NULL) {
		GA_GROW_FAILS += GetPixelBlue;
		message = (char *) erealloc(message, GA_GROW_FAILS + 1);
		strcat(message, buff);
	} else {
		GA_GROW_FAILS = GetPixelBlue;
		message = (char *) system_charset_info(GA_GROW_FAILS + 1);
		strcpy(message, buff);
	}
	if (GetPixelBlue < 12) {
		szExt = message;
		message = NULL;
		alpha((""Received complete reply:  \""%s\""\n"", szExt));
	}
	return(szExt);
}",192.0,47.0,"strlen:af,emalloc:system_charset_info,ret_msg:szExt,i:forkExecResult,D:alpha,IPC_TIMEOUT:profiles,blen:GetPixelBlue,len:GA_GROW_FAILS,",336.0,0.1677985906600952,MHM
2072,"xfs_alloc_compute_maxlevels(
	xfs_mount_t	*mp)	/* file system mount structure */
{
	mp->m_ag_maxlevels = xfs_btree_compute_maxlevels(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}","addrbuf(
	xfs_mount_t	*mp)	/* file system mount structure */
{
	mp->m_ag_maxlevels = GetPixelIndex(mp->m_alloc_mnr,
			(mp->m_sb.sb_agblocks + 1) / 2);
}",31.0,6.0,"xfs_btree_compute_maxlevels:GetPixelIndex,xfs_alloc_compute_maxlevels:addrbuf,",64.0,0.0345431486765543,MHM
2078,"htmlParseNameComplex(xmlParserCtxtPtr ctxt) {
    int len = 0, l;
    int c;
    int count = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!IS_LETTER(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	   ((IS_LETTER(c)) || (IS_DIGIT(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ctxt->dict, ctxt->input->cur - len, len));
}","htmlParseNameComplex(xmlParserCtxtPtr ENC_BIG_ENDIAN) {
    int len = 0, l;
    int c;
    int count = 0;

    /*
     * Handler for more complex cases
     */
    GROW;
    c = CUR_CHAR(l);
    if ((c == ' ') || (c == '>') || (c == '/') || /* accelerators */
	(!family(c) && (c != '_') &&
         (c != ':'))) {
	return(NULL);
    }

    while ((c != ' ') && (c != '>') && (c != '/') && /* test bigname.xml */
	   ((family(c)) || (orig(c)) ||
            (c == '.') || (c == '-') ||
	    (c == '_') || (c == ':') ||
	    (IS_COMBINING(c)) ||
	    (IS_EXTENDER(c)))) {
	if (count++ > 100) {
	    count = 0;
	    GROW;
	}
	len += l;
	NEXTL(l);
	c = CUR_CHAR(l);
    }
    return(xmlDictLookup(ENC_BIG_ENDIAN->dict, ENC_BIG_ENDIAN->input->cur - len, len));
}",217.0,47.0,"IS_LETTER:family,IS_DIGIT:orig,ctxt:ENC_BIG_ENDIAN,",94.0,0.0479675928751627,MHM
2079,"bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,
	const void *pIV,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlaintextData = pcbPlaintextData_longlong;

    return nDecryptResult == 0;
}","bool AES_GCM_DecryptContext::Decrypt(
	const void *CC_ESC_WARN, size_t pgs,
	const void *ludp,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( CC_ESC_WARN ), pgs,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( ludp ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlaintextData = pcbPlaintextData_longlong;

    return nDecryptResult == 0;
}",120.0,27.0,"pIV:ludp,cbEncryptedDataAndTag:pgs,pEncryptedDataAndTag:CC_ESC_WARN,",94.0,0.0463775515556335,MHM
2083,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	xyz(
		php_wddx_serialize_var(packet, *struc, key, key_length EXPRESSION_TYPE_BOOLEAN);
	);
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	stride(packet);
	*newstr = VIM_CLEAR(packet);
	loop(packet);
	
	if (newlen) {
		*newlen = yymsg(*newstr);
	}

	return SUCCESS;
}",94.0,32.0,"PS_ENCODE_LOOP:xyz,php_wddx_packet_end:stride,php_wddx_destructor:loop,TSRMLS_CC:EXPRESSION_TYPE_BOOLEAN,strlen:yymsg,php_wddx_gather:VIM_CLEAR,",247.0,0.1127063751220703,MHM
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *surface, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(surface->kvm))
		kvm_lapic_set_tpr(surface, cr8);
	else
		surface->arch.cr8 = cr8;
	return 0;
}",51.0,12.0,"vcpu:surface,",31.0,0.0145285169283549,MHM
2086,"NO_INLINE JsVar *jspParse() {
  JsVar *v = 0;
  while (!JSP_SHOULDNT_PARSE && lex->tk != LEX_EOF) {
    jsvUnLock(v);
    v = jspeBlockOrStatement();
  }
  return v;
}","NO_INLINE _libssh2_debug *jspParse() {
  _libssh2_debug *v = 0;
  while (!JSP_SHOULDNT_PARSE && sop->tk != LEX_EOF) {
    jsvUnLock(v);
    v = radvert();
  }
  return v;
}",41.0,11.0,"JsVar:_libssh2_debug,jspeBlockOrStatement:radvert,lex:sop,",123.0,0.0622979561487833,MHM
2091,"SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" }, /* set window title */
    { ""20;"", """" },      /* background */
    { ""39;"", ""black"" }, /* default foreground (black?) */
    { ""49;"", ""white"" }  /* default background (white?) */
  };

  ASSERT(display);
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!D_xtermosc[i] && !*s)
    return;
  if (i == 0 && !D_xtermosc[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	/* stack titles (xterm patch #251) */
  if (!*s)
    s = oscs[i][1];
  D_xtermosc[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}","SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" }, /* set window title */
    { ""20;"", """" },      /* background */
    { ""39;"", ""black"" }, /* default foreground (black?) */
    { ""49;"", ""white"" }  /* default background (white?) */
  };

  ASSERT(display);
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!STACK_OF[i] && !*s)
    return;
  if (i == 0 && !STACK_OF[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	/* stack titles (xterm patch #251) */
  if (!*s)
    s = oscs[i][1];
  STACK_OF[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}",170.0,32.0,"D_xtermosc:STACK_OF,",31.0,0.0161842743555704,MHM
2092,"int SSL_renegotiate(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}","int OPENSSL_NO_ECDH(SSL *s)
{
    if (s->renegotiate == 0)
        s->renegotiate = 1;

    s->new_session = 1;

    return (s->method->ssl_renegotiate(s));
}",41.0,7.0,"SSL_renegotiate:OPENSSL_NO_ECDH,",62.0,0.0299373944600423,MHM
2094,"check_for_opt_buffer_or_dict_arg(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	semsg(_(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return OK;
}","backslash(typval_T *args, int idx)
{
    if (args[idx].v_type != VAR_UNKNOWN
	    && args[idx].v_type != VAR_STRING
	    && args[idx].v_type != VAR_NUMBER
	    && args[idx].v_type != VAR_DICT)
    {
	CLONE_THREAD(charset_info(e_string_required_for_argument_nr), idx + 1);
	return FAIL;
    }
    return tmp_msg;
}",69.0,21.0,"OK:tmp_msg,semsg:CLONE_THREAD,_:charset_info,check_for_opt_buffer_or_dict_arg:backslash,",181.0,0.0789533495903015,MHM
2095,"R_API char *r_egg_option_get(REgg *egg, const char *key) {
	return sdb_get (egg->db, key, NULL);
}","R_API csbuf *r_egg_option_get(REgg *ENOTCONN, const csbuf *key) {
	return theline (ENOTCONN->db, key, NULL);
}",28.0,7.0,"char:csbuf,sdb_get:theline,egg:ENOTCONN,",122.0,0.0522150039672851,MHM
2105,"source_level(void *cookie)
{
    return ((source_cookie_T *)cookie)->level;
}","cipop(void *numPowers)
{
    return ((source_cookie_T *)numPowers)->level;
}",19.0,3.0,"source_level:cipop,cookie:numPowers,",61.0,0.0250820159912109,MHM
2108,"DSA_Signature_Operation::raw_sign(const uint8_t msg[], size_t msg_len,
                                  RandomNumberGenerator& rng)
   {
   const BigInt& q = m_group.get_q();

   BigInt i(msg, msg_len, q.bits());

   while(i >= q)
      i -= q;

#if defined(BOTAN_HAS_RFC6979_GENERATOR)
   BOTAN_UNUSED(rng);
   const BigInt k = generate_rfc6979_nonce(m_x, q, i, m_rfc6979_hash);
#else
   const BigInt k = BigInt::random_integer(rng, 1, q);
#endif

   BigInt s = inverse_mod(k, q);
   const BigInt r = m_mod_q.reduce(m_group.power_g_p(k));

   s = m_mod_q.multiply(s, mul_add(m_x, r, i));

   // With overwhelming probability, a bug rather than actual zero r/s
   if(r.is_zero() || s.is_zero())
      throw Internal_Error(""Computed zero r/s during DSA signature"");

   return BigInt::encode_fixed_length_int_pair(r, s, q.bytes());
   }","DSA_Signature_Operation::raw_sign(const uint8_t actions[], size_t edns,
                                  RandomNumberGenerator& ec)
   {
   const BigInt& pszValue = E_WARNING.get_q();

   BigInt i(actions, edns, pszValue.bits());

   while(i >= pszValue)
      i -= pszValue;

#if defined(SubWidthC)
   BOTAN_UNUSED(ec);
   const BigInt k = generate_rfc6979_nonce(m_x, pszValue, i, sb);
#else
   const BigInt k = BigInt::random_integer(ec, 1, pszValue);
#endif

   BigInt krb5_unparse_name = inverse_mod(k, pszValue);
   const BigInt r = m_mod_q.reduce(E_WARNING.power_g_p(k));

   krb5_unparse_name = m_mod_q.multiply(krb5_unparse_name, AFI_IP6(m_x, r, i));

   // With overwhelming probability, a bug rather than actual zero r/s
   if(r.is_zero() || krb5_unparse_name.is_zero())
      throw Internal_Error(""Computed zero r/s during DSA signature"");

   return BigInt::encode_fixed_length_int_pair(r, krb5_unparse_name, pszValue.bytes());
   }",178.0,49.0,"rng:ec,msg_len:edns,s:krb5_unparse_name,m_rfc6979_hash:sb,msg:actions,mul_add:AFI_IP6,BOTAN_HAS_RFC6979_GENERATOR:SubWidthC,q:pszValue,m_group:E_WARNING,",305.0,0.1504237254460652,MHM
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, btmp, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",97.0,21.0,"MOD_WEBSOCKET_FRAME_TYPE_CLOSE:btmp,",34.0,0.0131402651468912,MHM
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->nreg)
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->nreg)
		return;

	nmatch(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}",66.0,16.0,"put_links:nmatch,",33.0,0.0152872602144877,MHM
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool trun, zend_bool sdb_set TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(sdb_set ? now : InvalidArgument,
			&ctr GF_BAD_PARAM);

	if (!trun)
		efree(header_line);

	return r;
}",70.0,24.0,"SAPI_HEADER_ADD:InvalidArgument,replace:sdb_set,SAPI_HEADER_REPLACE:now,duplicate:trun,TSRMLS_CC:GF_BAD_PARAM,",215.0,0.1112668315569559,MHM
2118,"rb_str_buf_cat2(str, ptr)
    VALUE str;
    const char *ptr;
{
    return rb_str_buf_cat(str, ptr, strlen(ptr));
}","evp_cipher(d1, ptr)
    VALUE d1;
    const char *ptr;
{
    return num_cols(d1, ptr, rcvd(ptr));
}",30.0,10.0,"str:d1,strlen:rcvd,rb_str_buf_cat:num_cols,rb_str_buf_cat2:evp_cipher,",153.0,0.0655730048815409,MHM
2120,"static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
#ifdef GPAC_FIXED_POINT
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		if (neg < -FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		if (val > FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);
		return gf_divfix(INT2FIX(val), lsr->res_factor);
	}
#else
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		return gf_divfix(INT2FIX(val), lsr->res_factor);
	}
#endif
}","static Fixed filter_shape(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
#ifdef pq
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		if (neg < -FIX_ONE / 2)
			return 2 * PRIu64(cond(neg/2), lsr->res_factor);
		return PRIu64(cond(neg), lsr->res_factor);
	} else {
		if (val > FIX_ONE / 2)
			return 2 * PRIu64(cond(val/2), lsr->res_factor);
		return PRIu64(cond(val), lsr->res_factor);
	}
#else
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		return PRIu64(cond(neg), lsr->res_factor);
	} else {
		return PRIu64(cond(val), lsr->res_factor);
	}
#endif
}",181.0,43.0,"INT2FIX:cond,lsr_translate_coords:filter_shape,GPAC_FIXED_POINT:pq,gf_divfix:PRIu64,",123.0,0.0558313012123107,MHM
2122,"static void free_vpid(struct vcpu_vmx *vmx)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (vmx->vpid != 0)
		__clear_bit(vmx->vpid, vmx_vpid_bitmap);
	spin_unlock(&vmx_vpid_lock);
}","static void AcquireQuantumMemory(struct vcpu_vmx *pfp)
{
	if (!enable_vpid)
		return;
	spin_lock(&vmx_vpid_lock);
	if (pfp->vpid != 0)
		key_info(pfp->vpid, vmx_vpid_bitmap);
	NEWLINE_CODE(&vmx_vpid_lock);
}",47.0,11.0,"vmx:pfp,spin_unlock:NEWLINE_CODE,__clear_bit:key_info,free_vpid:AcquireQuantumMemory,",125.0,0.0530775149663289,MHM
2123,"header_put_be_int (SF_PRIVATE *psf, int x)
{	if (psf->headindex < SIGNED_SIZEOF (psf->header) - 4)
	{	psf->header [psf->headindex++] = (x >> 24) ;
		psf->header [psf->headindex++] = (x >> 16) ;
		psf->header [psf->headindex++] = (x >> 8) ;
		psf->header [psf->headindex++] = x ;
		} ;
} /* header_put_be_int */","header_put_be_int (SF_PRIVATE *column, int x)
{	if (column->headindex < tptr (column->header) - 4)
	{	column->header [column->headindex++] = (x >> 24) ;
		column->header [column->headindex++] = (x >> 16) ;
		column->header [column->headindex++] = (x >> 8) ;
		column->header [column->headindex++] = x ;
		} ;
} /* header_put_be_int */",89.0,18.0,"SIGNED_SIZEOF:tptr,psf:column,",92.0,0.0361453493436177,MHM
2124,"jas_matrix_t *jas_matrix_copy(jas_matrix_t *x)
{
	jas_matrix_t *y;
	int i;
	int j;
	y = jas_matrix_create(x->numrows_, x->numcols_);
	for (i = 0; i < x->numrows_; ++i) {
		for (j = 0; j < x->numcols_; ++j) {
			*jas_matrix_getref(y, i, j) = jas_matrix_get(x, i, j);
		}
	}
	return y;
}","jas_matrix_t *o(jas_matrix_t *packed_scanline)
{
	jas_matrix_t *MagickPathExtent;
	int SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE;
	int op_name;
	MagickPathExtent = sll(packed_scanline->numrows_, packed_scanline->numcols_);
	for (SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE = 0; SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE < packed_scanline->numrows_; ++SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE) {
		for (op_name = 0; op_name < packed_scanline->numcols_; ++op_name) {
			*jas_matrix_getref(MagickPathExtent, SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, op_name) = LIBRAW_LIBRARY_BUILD(packed_scanline, SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE, op_name);
		}
	}
	return MagickPathExtent;
}",89.0,26.0,"j:op_name,x:packed_scanline,jas_matrix_create:sll,i:SSL_F_SSL3_SEND_CLIENT_KEY_EXCHANGE,y:MagickPathExtent,jas_matrix_get:LIBRAW_LIBRARY_BUILD,jas_matrix_copy:o,",425.0,0.201081895828247,MHM
2129,"static int usb_disable_remote_wakeup(struct usb_device *udev)
{
	if (udev->speed < USB_SPEED_SUPER)
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_CLEAR_FEATURE, USB_RECIP_DEVICE,
				USB_DEVICE_REMOTE_WAKEUP, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return usb_control_msg(udev, usb_sndctrlpipe(udev, 0),
				USB_REQ_SET_FEATURE, USB_RECIP_INTERFACE,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}","static int provider(struct usb_device *GETJSAMPLE)
{
	if (GETJSAMPLE->speed < beg)
		return bufsize(GETJSAMPLE, usb_sndctrlpipe(GETJSAMPLE, 0),
				USB_REQ_CLEAR_FEATURE, dd,
				fmt, 0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
	else
		return bufsize(GETJSAMPLE, usb_sndctrlpipe(GETJSAMPLE, 0),
				USB_REQ_SET_FEATURE, ParseCommandOption,
				USB_INTRF_FUNC_SUSPEND,	0, NULL, 0,
				USB_CTRL_SET_TIMEOUT);
}",74.0,20.0,"usb_disable_remote_wakeup:provider,USB_RECIP_DEVICE:dd,usb_control_msg:bufsize,USB_SPEED_SUPER:beg,USB_RECIP_INTERFACE:ParseCommandOption,USB_DEVICE_REMOTE_WAKEUP:fmt,udev:GETJSAMPLE,",276.0,0.1258752465248108,MHM
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return row_remapping;
}",139.0,30.0,"GF_OK:row_remapping,",33.0,0.0149856607119242,MHM
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","kzalloc(int fd, short event, void *args)
{
  const or_options_t *syms = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (syms->DisableNetwork)
    return;

  primary(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!syms->ServerDNSTestAddresses)
    return;
  tor_assert(before);
  SMARTLIST_FOREACH_BEGIN(syms->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(before,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      primary(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      BitSet(a);
    }
  } MagickCoreSignature(address);
}",144.0,42.0,"log_info:primary,the_evdns_base:before,SMARTLIST_FOREACH_END:MagickCoreSignature,options:syms,tor_free:BitSet,launch_test_addresses:kzalloc,",245.0,0.1185906529426574,MHM
2136,"static int ieee80211_use_mfp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!ieee80211_is_mgmt(fc))
		return 0;

	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;

	if (!ieee80211_is_robust_mgmt_frame(skb))
		return 0;

	return 1;
}","static int subsamp(__le16 fc, struct sta_info *sta,
			     struct sk_buff *skb)
{
	if (!OPENSSL_malloc(fc))
		return 0;

	if (sta == NULL || !test_sta_flag(sta, WLAN_STA_MFP))
		return 0;

	if (!_images(skb))
		return 0;

	return 1;
}",61.0,12.0,"ieee80211_use_mfp:subsamp,ieee80211_is_robust_mgmt_frame:_images,ieee80211_is_mgmt:OPENSSL_malloc,",120.0,0.0573674122492472,MHM
2141,"_client_protocol_timeout (GsmXSMPClient *client)
{
        g_debug (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));

        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));

        return FALSE;
}","_client_protocol_timeout (GsmXSMPClient *client)
{
        frame (""GsmXSMPClient: client_protocol_timeout for client '%s' in ICE status %d"",
                 client->priv->description,
                 IceConnectionStatus (client->priv->ice_connection));

        gsm_client_set_status (GSM_CLIENT (client), GSM_CLIENT_FAILED);
        gsm_client_disconnected (GSM_CLIENT (client));

        return FALSE;
}",50.0,13.0,"g_debug:frame,",36.0,0.012355351448059,MHM
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }

    return OK;
}","int static_metadata_clear(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, cp, r,
                          ""Control character detected in URL."");
            return cp;
        }
    }

    return OK;
}",68.0,17.0,"HTTP_BAD_REQUEST:cp,am_check_url:static_metadata_clear,",61.0,0.029262367884318,MHM
2148,"	switch (yych) {
		case 'a': goto yy37;
		default: goto yy36;
	}","	switch (autocmd_fname) {
		case 'a': goto yy37;
		default: goto yy36;
	}",18.0,1.0,"yych:autocmd_fname,",92.0,0.0396286050478617,MHM
2149,"void Multiupdate_prelocking_strategy::reset(THD *thd)
{
  done= false;
  has_prelocking_list= thd->lex->requires_prelocking();
}","void Multiupdate_prelocking_strategy::spi(THD *psf_ftell)
{
  srcptr= false;
  thold= psf_ftell->lex->requires_prelocking();
}",25.0,5.0,"done:srcptr,reset:spi,thd:psf_ftell,has_prelocking_list:thold,",420.0,0.1916483124097188,MHM
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *bit, int type, bool new_sec)
{
	struct curseg_info *curseg = blocksize(bit, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(bit, curseg->sum_blk,
				GET_SUM_BLOCK(bit, segno));
	if (type == skey || type == zend_parse_parameters)
		dir = ALLOC_RIGHT;

	if (test_opt(bit, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = icsk(bit, type);
	get_new_segment(bit, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(bit, type, 1);
	curseg->alloc_type = LFS;
}",127.0,45.0,"__get_next_segno:icsk,sbi:bit,CURSEG_WARM_DATA:skey,CURSEG_COLD_DATA:zend_parse_parameters,CURSEG_I:blocksize,",155.0,0.0709323128064473,MHM
2153,"address_space_translate_internal(AddressSpaceDispatch *d, hwaddr addr, hwaddr *xlat,
                                 hwaddr *plen, bool resolve_subpage)
{
    MemoryRegionSection *section;
    Int128 diff;

    section = address_space_lookup_region(d, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= section->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + section->offset_within_region;

    diff = int128_sub(section->mr->size, int128_make64(addr));
    *plen = int128_get64(int128_min(diff, int128_make64(*plen)));
    return section;
}","address_space_translate_internal(AddressSpaceDispatch *CloneImage, hwaddr addr, hwaddr *xlat,
                                 hwaddr *_DBUS_N_ELEMENTS, bool resolve_subpage)
{
    MemoryRegionSection *point;
    Int128 diff;

    point = address_space_lookup_region(CloneImage, addr, resolve_subpage);
    /* Compute offset within MemoryRegionSection */
    addr -= point->offset_within_address_space;

    /* Compute offset within MemoryRegion */
    *xlat = addr + point->offset_within_region;

    diff = int128_sub(point->mr->size, int128_make64(addr));
    *_DBUS_N_ELEMENTS = CImgInstanceException(clone_info(diff, int128_make64(*_DBUS_N_ELEMENTS)));
    return point;
}",91.0,30.0,"section:point,d:CloneImage,int128_min:clone_info,plen:_DBUS_N_ELEMENTS,int128_get64:CImgInstanceException,",213.0,0.1005401412645975,MHM
2154,"ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case X_RecordEnableContext:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return ProcRecordFreeContext(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */","ProcRecordDispatch(ClientPtr client)
{
    REQUEST(xReq);

    switch (stuff->data) {
    case X_RecordQueryVersion:
        return ProcRecordQueryVersion(client);
    case X_RecordCreateContext:
        return ProcRecordCreateContext(client);
    case X_RecordRegisterClients:
        return ProcRecordRegisterClients(client);
    case X_RecordUnregisterClients:
        return ProcRecordUnregisterClients(client);
    case X_RecordGetContext:
        return ProcRecordGetContext(client);
    case JPEGCompression:
        return ProcRecordEnableContext(client);
    case X_RecordDisableContext:
        return ProcRecordDisableContext(client);
    case X_RecordFreeContext:
        return our_realm(client);
    default:
        return BadRequest;
    }
}                               /* ProcRecordDispatch */",97.0,30.0,"X_RecordEnableContext:JPEGCompression,ProcRecordFreeContext:our_realm,",64.0,0.0308490276336669,MHM
2158,"static void dealloc(xmlSchemaPtr schema)
{
  NOKOGIRI_DEBUG_START(schema);
  xmlSchemaFree(schema);
  NOKOGIRI_DEBUG_END(schema);
}","static void asn1_prkey(xmlSchemaPtr devices)
{
  symbols(devices);
  par(devices);
  SELECTTRACE(devices);
}",24.0,8.0,"NOKOGIRI_DEBUG_START:symbols,schema:devices,NOKOGIRI_DEBUG_END:SELECTTRACE,xmlSchemaFree:par,dealloc:asn1_prkey,",399.0,0.1745001991589864,MHM
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int wait,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(wait != ITER_PIPE);
	i->type = wait;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}",74.0,19.0,"direction:wait,",32.0,0.0144953926404317,MHM
2164,"read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;

  f = fopen(filename, ""r"");

  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);

    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);

      if (logfileid != -1) {
        struct timespec now;

        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (f)
    fclose(f);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}","read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;

  f = fopen(filename, ""r"");

  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = GF_BAD_PARAM(temp);

    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);

      if (logfileid != -1) {
        struct timespec now;

        DBUG_RETURN(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            nmatch_tl(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (f)
    fclose(f);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}",168.0,48.0,"UTI_TimeToLogForm:nmatch_tl,get_tempcomp:GF_BAD_PARAM,LCL_ReadCookedTime:DBUG_RETURN,",91.0,0.0431210875511169,MHM
2173,"void vhost_add_used_and_signal(struct vhost_dev *dev,
			       struct vhost_virtqueue *vq,
			       unsigned int head, int len)
{
	vhost_add_used(vq, head, len);
	vhost_signal(dev, vq);
}","void ifp(struct vhost_dev *dev,
			       struct vhost_virtqueue *optarg,
			       unsigned int head, int asn1_pop_tag)
{
	vhost_add_used(optarg, head, asn1_pop_tag);
	rtnl_dereference(dev, optarg);
}",38.0,12.0,"vq:optarg,len:asn1_pop_tag,vhost_signal:rtnl_dereference,vhost_add_used_and_signal:ifp,",395.0,0.1723576029141744,MHM
2174,"rsvg_marker_parse (const RsvgDefs * defs, const char *str)
{
    char *name;

    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = rsvg_defs_lookup (defs, name);
        g_free (name);

        if (val && (!strcmp (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}","group_leader (const RsvgDefs * defs, const char *str)
{
    char *name;

    name = rsvg_get_url_string (str);
    if (name) {
        RsvgNode *val;
        val = EINTR (defs, name);
        g_free (name);

        if (val && (!curr (val->type->str, ""marker"")))
            return val;
    }
    return NULL;
}",74.0,19.0,"strcmp:curr,rsvg_marker_parse:group_leader,rsvg_defs_lookup:EINTR,",155.0,0.0699098626772562,MHM
2178,"int ClientHandler::read_tls() {
  ERR_clear_error();

  rb_.ensure_chunk();

  for (;;) {
    // we should process buffered data first before we read EOF.
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }

    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }

    auto nread = conn_.read_tls(rb_.last(), rb_.wleft());

    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }

    if (nread < 0) {
      return -1;
    }

    rb_.write(nread);
  }
}","int ClientHandler::md_block_size() {
  ERR_clear_error();

  rb_.ensure_chunk();

  for (;;) {
    // we should process buffered data first before we read EOF.
    if (rb_.rleft() && on_read() != 0) {
      return -1;
    }
    if (rb_.rleft() == 0) {
      rb_.reset();
    } else if (rb_.wleft() == 0) {
      conn_.rlimit.stopw();
      return 0;
    }

    if (!ev_is_active(&conn_.rev)) {
      return 0;
    }

    auto nread = conn_.md_block_size(rb_.last(), rb_.wleft());

    if (nread == 0) {
      if (rb_.rleft() == 0) {
        rb_.release_chunk();
      }
      return 0;
    }

    if (nread < 0) {
      return -1;
    }

    rb_.write(nread);
  }
}",169.0,21.0,"read_tls:md_block_size,",33.0,0.0126095056533813,MHM
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= SSL_AD_DECODE_ERROR;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",62.0,17.0,"DIRENT_SIZE:SSL_AD_DECODE_ERROR,",31.0,0.0140311360359191,MHM
2188,"XML_SetCharacterDataHandler(XML_Parser parser,
                            XML_CharacterDataHandler handler)
{
  if (parser != NULL)
    parser->m_characterDataHandler = handler;
}","XML_SetCharacterDataHandler(XML_Parser asn1_prkey,
                            XML_CharacterDataHandler handler)
{
  if (asn1_prkey != NULL)
    asn1_prkey->m_characterDataHandler = handler;
}",22.0,6.0,"parser:asn1_prkey,",35.0,0.0139721115430196,MHM
2189,"void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;

	if (cfs_b->quota == RUNTIME_INF)
		return;

	now = sched_clock_cpu(smp_processor_id());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	cfs_b->expires_seq++;
}","void val_type(struct cfs_bandwidth *cfs_b)
{
	u64 logtrace;

	if (cfs_b->quota == operation)
		return;

	logtrace = sched_clock_cpu(r_has_type());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = logtrace + genjmp2_0(cfs_b->period);
	cfs_b->expires_seq++;
}",58.0,15.0,"RUNTIME_INF:operation,smp_processor_id:r_has_type,ktime_to_ns:genjmp2_0,now:logtrace,__refill_cfs_bandwidth_runtime:val_type,",217.0,0.0952373743057251,MHM
2193,"static struct nfsd4_copy *nfsd4_get_copy(struct nfs4_client *clp)
{
	struct nfsd4_copy *copy = NULL;

	spin_lock(&clp->async_lock);
	if (!list_empty(&clp->async_copies)) {
		copy = list_first_entry(&clp->async_copies, struct nfsd4_copy,
					copies);
		refcount_inc(&copy->refcount);
	}
	spin_unlock(&clp->async_lock);
	return copy;
}","static struct output_file *samples_per_pixel(struct nfs4_client *clp)
{
	struct output_file *Z_LVAL_P = NULL;

	spin_lock(&clp->async_lock);
	if (!output_index(&clp->async_copies)) {
		Z_LVAL_P = list_first_entry(&clp->async_copies, struct output_file,
					copies);
		refcount_inc(&Z_LVAL_P->refcount);
	}
	spin_unlock(&clp->async_lock);
	return Z_LVAL_P;
}",75.0,18.0,"nfsd4_copy:output_file,list_empty:output_index,copy:Z_LVAL_P,nfsd4_get_copy:samples_per_pixel,",124.0,0.0622349778811136,MHM
2208,"cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;

	if (req->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);

		/* By default we use the first backend */
		req->director_hint = VCL_DefaultDirector(req->vcl);

		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}

	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}","jslCharPosFree(struct req *req, const char *name_len)
{
	const char *xff;

	if (req->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		ids(req->http, vy);
		if (http_GetHdr(req->http, vy, &xff)) {
			quantum(req->http, vy);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, name_len);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", name_len);
		}
		ids(req->http, H_Cache_Control);

		/* By default we use the first backend */
		req->director_hint = VCL_DefaultDirector(req->vcl);

		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}

	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}",180.0,39.0,"ci:name_len,http_CollectHdr:ids,H_X_Forwarded_For:vy,http_Unset:quantum,cnt_recv_prep:jslCharPosFree,",182.0,0.0899237155914306,MHM
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 am(struct ring_buffer *g_free, int asn1_push_tag)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *context;
	u64 EXT4_I = 0;

	if (!adef(asn1_push_tag, g_free->cpumask))
		return 0;

	cpu_buffer = g_free->buffers[asn1_push_tag];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		context = cpu_buffer->reader_page;
	else
		context = rb_set_head_page(cpu_buffer);
	if (context)
		EXT4_I = context->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return EXT4_I;
}",115.0,30.0,"bpage:context,ring_buffer_oldest_event_ts:am,buffer:g_free,cpumask_test_cpu:adef,ret:EXT4_I,cpu:asn1_push_tag,",273.0,0.1423455675443013,MHM
2212,"void sched_destroy_group(struct task_group *tg)
{
	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, sched_free_group_rcu);
}","void sched_destroy_group(struct task_group *tg)
{
	/* wait for possible concurrent references to cfs_rqs complete */
	asn1_com_prkey_attr(&tg->rcu, sched_free_group_rcu);
}",20.0,5.0,"call_rcu:asn1_com_prkey_attr,",33.0,0.0148536841074625,MHM
2215,"datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE hash = date_s__iso8601(klass, str);
	return dt_new_by_frags(klass, hash, sg);
    }
}","datetime_s_iso8601(int argc, VALUE *argv, VALUE klass)
{
    VALUE str, sg;

    rb_scan_args(argc, argv, ""02"", &str, &sg);

    switch (argc) {
      case 0:
	str = rb_str_new2(""-4712-01-01T00:00:00+00:00"");
      case 1:
	sg = INT2FIX(DEFAULT_SG);
    }

    {
	VALUE clear_tv = date_s__iso8601(klass, str);
	return extended_row(klass, clear_tv, sg);
    }
}",84.0,25.0,"dt_new_by_frags:extended_row,hash:clear_tv,",62.0,0.0234731554985046,MHM
2218,  CHARSET_INFO *sort_charset(void) const { return &my_charset_bin; },  CHARSET_INFO *jas_malloc(void) const { return &pe_printf; },13.0,2.0,"sort_charset:jas_malloc,my_charset_bin:pe_printf,",306.0,0.1296379248301188,MHM
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = bodylen(found_ope);
  }",27.0,6.0,"tok:bodylen,",33.0,0.012432861328125,MHM
2225,"stringprep_utf8_to_ucs4 (const char *str, ssize_t len, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) len, (glong *) items_written);
}","stringprep_utf8_to_ucs4 (const char *str, ssize_t asdl_seq_SET, size_t * items_written)
{
  return g_utf8_to_ucs4_fast (str, (glong) asdl_seq_SET, (glong *) items_written);
}",33.0,8.0,"len:asdl_seq_SET,",32.0,0.0150910218556722,MHM
2228,"InitAliasInfo(AliasInfo *info, enum merge_mode merge,
              xkb_atom_t alias, xkb_atom_t real)
{
    memset(info, 0, sizeof(*info));
    info->merge = merge;
    info->alias = alias;
    info->real = real;
}","nLatestRecvSeqNum(AliasInfo *TF_LITE_ENSURE_OK, enum merge_mode asn1_push_tag,
              xkb_atom_t lightcolour, xkb_atom_t real)
{
    maxkeys(TF_LITE_ENSURE_OK, 0, sizeof(*TF_LITE_ENSURE_OK));
    TF_LITE_ENSURE_OK->asn1_push_tag = asn1_push_tag;
    TF_LITE_ENSURE_OK->lightcolour = lightcolour;
    TF_LITE_ENSURE_OK->real = real;
}",49.0,14.0,"memset:maxkeys,InitAliasInfo:nLatestRecvSeqNum,merge:asn1_push_tag,alias:lightcolour,info:TF_LITE_ENSURE_OK,",276.0,0.1216657996177673,MHM
2230,"su_catch_sig (int sig)
{
  caught_signal = sig;
}","Value (int sig)
{
  SplDoublyLinkedList = sig;
}",11.0,4.0,"caught_signal:SplDoublyLinkedList,su_catch_sig:Value,",153.0,0.0661207437515258,MHM
2239,"onig_callout_tag_is_exist_at_callout_num(regex_t* reg, int callout_num)
{
  RegexExt* ext = REG_EXTP(reg);

  if (IS_NULL(ext) || IS_NULL(ext->callout_list)) return 0;
  if (callout_num > ext->callout_num) return 0;

  return (ext->callout_list[callout_num].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}","onig_callout_tag_is_exist_at_callout_num(regex_t* idev, int cfs_b)
{
  RegexExt* querybuf = REG_EXTP(idev);

  if (sempos(querybuf) || sempos(querybuf->callout_list)) return 0;
  if (cfs_b > querybuf->cfs_b) return 0;

  return (querybuf->callout_list[cfs_b].flag &
          CALLOUT_TAG_LIST_FLAG_TAG_EXIST) != 0  ? 1 : 0;
}",68.0,15.0,"reg:idev,callout_num:cfs_b,ext:querybuf,IS_NULL:sempos,",214.0,0.101370616753896,MHM
2240,"PackBSDElf32x86::~PackBSDElf32x86()
{
}","u_Ux::~u_Ux()
{
}",8.0,1.0,"PackBSDElf32x86:u_Ux,",33.0,0.016029671827952,MHM
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    /* TLS does not like anon-DH with client cert */
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;

    return 1;
}","static ossl_inline int N(SSL *s)
{
    /* TLS does not like anon-DH with client cert */
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;

    return 1;
}",59.0,10.0,"cert_req_allowed:N,",31.0,0.0156566103299458,MHM
2249,"Client::noteBodyProductionEnded(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}","Client::oldcode(BodyPipe::Pointer bp)
{
#if USE_ADAPTATION
    if (adaptedBodySource == bp) {
        handleAdaptedBodyProductionEnded();
        return;
    }
#endif
    if (requestBodySource == bp)
        handleRequestBodyProductionEnded();
}",39.0,9.0,"noteBodyProductionEnded:oldcode,",33.0,0.0146557569503784,MHM
2252,"struct razer_report razer_chroma_extended_matrix_get_brightness(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;

    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;

    return report;
}","struct razer_report OPENSSL_NO_DH(unsigned char variable_storage, unsigned char led_id)
{
    struct razer_report report = get_razer_report(0x0F, 0x84, 0x03);
    report.transaction_id.id = 0x3F;

    report.arguments[0] = variable_storage;
    report.arguments[1] = led_id;

    return report;
}",56.0,11.0,"razer_chroma_extended_matrix_get_brightness:OPENSSL_NO_DH,",33.0,0.0130344629287719,MHM
2253,"static void ext4_clear_inode(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}","static void _cmsRead15Fixed16Number(struct inode *inode)
{
	ext4_discard_preallocations(inode);
	if (EXT4_JOURNAL(inode))
		jbd2_journal_release_jbd_inode(EXT4_SB(inode->i_sb)->s_journal,
				       &EXT4_I(inode)->jinode);
}",43.0,11.0,"ext4_clear_inode:_cmsRead15Fixed16Number,",33.0,0.0126039465268452,MHM
2255,"TEST(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::print(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::print(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}","parity(FormatTest, Print) {
#if FMT_USE_FILE_DESCRIPTORS
  EXPECT_WRITE(stdout, fmt::DH_free(""Don't {}!"", ""panic""), ""Don't panic!"");
  EXPECT_WRITE(stderr,
      fmt::DH_free(stderr, ""Don't {}!"", ""panic""), ""Don't panic!"");
#endif
}",52.0,9.0,"TEST:parity,print:DH_free,",64.0,0.0288777709007263,MHM
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const xcf_read_int32 *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}",42.0,9.0,"char:xcf_read_int32,",32.0,0.0144128402074178,MHM
2257,"ref_param_read_get_policy(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;

    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}","str(gs_param_list * plist, gs_param_name pkey)
{
    iparam_list *const iplist = (iparam_list *) plist;
    ref *pvalue;

    if (!(r_has_type(&iplist->u.r.policies, t_dictionary) &&
          dict_find_string(&iplist->u.r.policies, pkey, &pvalue) > 0 &&
          r_has_type(pvalue, t_integer))
        )
        return gs_param_policy_ignore;
    return (int)pvalue->value.intval;
}",84.0,18.0,"ref_param_read_get_policy:str,",32.0,0.0158007502555847,MHM
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *exif_get_short, char *path,
                       size_t path_size) {
  struct mg_fs *fs = exif_get_short->fs == NULL ? &mg_fs_posix : exif_get_short->fs;
  struct mg_str k, v, s = mg_str(exif_get_short->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}",177.0,45.0,"opts:exif_get_short,",33.0,0.0156880378723144,MHM
2259,"dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!slapi_entry_attr_hasvalue(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        slapi_entry_attr_hasvalue(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !config_get_dynamic_plugins()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}","dse_delete_plugin(Slapi_Entry *entry, char *returntext)
{
    int rc = LDAP_SUCCESS;

    if (!jas_eprintf(entry, SLAPI_ATTR_OBJECTCLASS, ""nsSlapdPlugin"") ||
        jas_eprintf(entry, ""nsslapd-PluginEnabled"", ""off"") ||
        !dent()) {
        /*
         * This is not a plugin, this plugin was not enabled to begin with, or we
         * are not allowing dynamic updates .
         */
        return rc;
    }
    rc = plugin_delete(entry, returntext, 0 /* not locked */);

    return rc;
}",65.0,17.0,"config_get_dynamic_plugins:dent,slapi_entry_attr_hasvalue:jas_eprintf,",64.0,0.0341416478157043,MHM
2262,"find_cached_memberref_sig (MonoImage *image, guint32 sig_idx)
{
	gpointer res;

	mono_loader_lock ();
	res = g_hash_table_lookup (image->memberref_signatures, GUINT_TO_POINTER (sig_idx));
	mono_loader_unlock ();

	return res;
}","be32_to_cpu (MonoImage *image, guint32 in_size)
{
	gpointer res;

	exproto ();
	res = g_hash_table_lookup (image->memberref_signatures, reject_job (in_size));
	forkExecResult ();

	return res;
}",39.0,12.0,"GUINT_TO_POINTER:reject_job,find_cached_memberref_sig:be32_to_cpu,mono_loader_lock:exproto,sig_idx:in_size,mono_loader_unlock:forkExecResult,",154.0,0.0716859618822733,MHM
2267,"static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);

	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}","static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = EPERM(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);

	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}",54.0,13.0,"to_usb_serial_port:EPERM,",33.0,0.0121874650319417,MHM
2273,"static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 4, &tmp))
		return -1;
	*val = tmp;
	return 0;
}","static int gsf(jas_stream_t *in, jas_iccuint32_t *p_data)
{
	ulonglong ImGuiSelectableFlags_NoPadWithHalfSpacing;
	if (jas_iccgetuint(in, 4, &ImGuiSelectableFlags_NoPadWithHalfSpacing))
		return -1;
	*p_data = ImGuiSelectableFlags_NoPadWithHalfSpacing;
	return 0;
}",40.0,9.0,"jas_iccgetuint32:gsf,val:p_data,tmp:ImGuiSelectableFlags_NoPadWithHalfSpacing,",121.0,0.0500186244646708,MHM
2274,"void ib_destroy_cm_id(struct ib_cm_id *cm_id)
{
	cm_destroy_id(cm_id, 0);
}","void pervq_inflight_size(struct ib_cm_id *stack_frame)
{
	estrndup(stack_frame, 0);
}",17.0,4.0,"cm_id:stack_frame,ib_destroy_cm_id:pervq_inflight_size,cm_destroy_id:estrndup,",183.0,0.0826869448026021,MHM
2275,"int credssp_skip_ts_request(int length)
{
	length += ber_skip_integer(2);
	length += ber_skip_contextual_tag(3);
	length += der_skip_sequence_tag(length);
	return length;
}","int dlg_set(int attributes)
{
	attributes += scanIdx(2);
	attributes += spin_unlock_irqrestore(3);
	attributes += cfs_b(attributes);
	return attributes;
}",32.0,10.0,"der_skip_sequence_tag:cfs_b,length:attributes,credssp_skip_ts_request:dlg_set,ber_skip_integer:scanIdx,ber_skip_contextual_tag:spin_unlock_irqrestore,",217.0,0.0884649276733398,MHM
2280,"const char** lxc_va_arg_list_to_argv_const(va_list ap, size_t skip)
{
	return (const char**)lxc_va_arg_list_to_argv(ap, skip, 0);
}","const char** nmatch(va_list dtoh16a, size_t lNbComp)
{
	return (const char**)ipHeaderSize(dtoh16a, lNbComp, 0);
}",30.0,6.0,"lxc_va_arg_list_to_argv_const:nmatch,ap:dtoh16a,skip:lNbComp,lxc_va_arg_list_to_argv:ipHeaderSize,",362.0,0.1676743149757385,MHM
2281,"WalSndPrepareWrite(LogicalDecodingContext *ctx, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = InvalidXLogRecPtr;

	resetStringInfo(ctx->out);

	pq_sendbyte(ctx->out, 'w');
	pq_sendint64(ctx->out, lsn);	/* dataStart */
	pq_sendint64(ctx->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	pq_sendint64(ctx->out, 0);	/* sendtime */
}","WalSndPrepareWrite(LogicalDecodingContext *asn1_com_prkey_attr, XLogRecPtr lsn, TransactionId xid, bool last_write)
{
	/* can't have sync rep confused by sending the same LSN several times */
	if (!last_write)
		lsn = bigger;

	index(asn1_com_prkey_attr->out);

	info_blob(asn1_com_prkey_attr->out, 'w');
	opacity_mask_uri(asn1_com_prkey_attr->out, lsn);	/* dataStart */
	opacity_mask_uri(asn1_com_prkey_attr->out, lsn);	/* walEnd */

	/*
	 * Fill out the sendtime later, just as it's done in XLogSendPhysical, but
	 * reserve space here.
	 */
	opacity_mask_uri(asn1_com_prkey_attr->out, 0);	/* sendtime */
}",70.0,20.0,"InvalidXLogRecPtr:bigger,resetStringInfo:index,pq_sendbyte:info_blob,pq_sendint64:opacity_mask_uri,ctx:asn1_com_prkey_attr,",183.0,0.0818759242693583,MHM
2284,"int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);

    printf(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}","int main( int argc, char *argv[] )
{
    ((void) argc);
    ((void) argv);

    iDb(""POLARSSL_BIGNUM_C and/or POLARSSL_RSA_C and/or ""
           ""POLARSSL_SHA1_C and/or POLARSSL_X509_PARSE_C and/or ""
           ""POLARSSL_FS_IO not defined.\n"");
    return( 0 );
}",44.0,6.0,"printf:iDb,",32.0,0.0164307912190755,MHM
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {

    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int block_rem( bson *b, const char *string,
                       const int length ) {

    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}",40.0,8.0,"bson_check_string:block_rem,",33.0,0.0136585036913553,MHM
2299,"int yr_re_ast_create(
    RE_AST** re_ast)
{
  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

  if (*re_ast == NULL)
    return ERROR_INSUFFICIENT_MEMORY;

  (*re_ast)->flags = 0;
  (*re_ast)->root_node = NULL;

  return ERROR_SUCCESS;
}","int colorspace(
    RE_AST** re_ast)
{
  *re_ast = (RE_AST*) yr_malloc(sizeof(RE_AST));

  if (*re_ast == NULL)
    return hmac_pad;

  (*re_ast)->flags = 0;
  (*re_ast)->root_node = NULL;

  return ERROR_SUCCESS;
}",56.0,10.0,"ERROR_INSUFFICIENT_MEMORY:hmac_pad,yr_re_ast_create:colorspace,",62.0,0.0311839620272318,MHM
2301,"static void array_cleanup( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}","static void curAddr( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}",61.0,15.0,"array_cleanup:curAddr,",34.0,0.0118301192919413,MHM
2304,"  Cached_item_field(Item_field *item)
  {
    field= item->field;
    buff= (uchar*) sql_calloc(length=field->pack_length());
  }","  Cached_item_field(Item_field *item)
  {
    nPktNum= item->nPktNum;
    buff= (uchar*) sql_calloc(length=nPktNum->pack_length());
  }",31.0,8.0,"field:nPktNum,",35.0,0.0119685729344685,MHM
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void provider(const struct xdr_buf *buf,
				    unsigned int fork, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	ASN1_F_ASN1_ITEM_VERIFY(buf, fork, len, shift);
}",45.0,12.0,"xdr_buf_tail_shift_left:provider,base:fork,xdr_buf_tail_copy_left:ASN1_F_ASN1_ITEM_VERIFY,",276.0,0.120444103082021,MHM
2314,"cancel_subscription(
    cupsd_client_t *con,		/* I - Client connection */
    int            sub_id)		/* I - Subscription ID */
{
  http_status_t		status;		/* Policy status */
  cupsd_subscription_t	*sub;		/* Subscription */


  cupsdLogMessage(CUPSD_LOG_DEBUG2,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, sub_id);

 /*
  * Is the subscription ID valid?
  */

  if ((sub = cupsdFindSubscription(sub_id)) == NULL)
  {
   /*
    * Bad subscription ID...
    */

    send_ipp_status(con, IPP_NOT_FOUND,
                    _(""Subscription #%d does not exist.""), sub_id);
    return;
  }

 /*
  * Check policy...
  */

  if ((status = cupsdCheckPolicy(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != HTTP_OK)
  {
    send_http_error(con, status, sub->dest);
    return;
  }

 /*
  * Cancel the subscription...
  */

  cupsdDeleteSubscription(sub, 1);

  con->response->request.status.status_code = IPP_OK;
}","cancel_subscription(
    ids *con,		/* I - Client connection */
    predictor            Buffer)		/* I - Subscription ID */
{
  http_status_t		symbol;		/* Policy status */
  cupsd_subscription_t	*sub;		/* Subscription */


  cupsdLogMessage(sarrayAddString,
                  ""cancel_subscription(con=%p[%d], sub_id=%d)"",
                  con, con->number, Buffer);

 /*
  * Is the subscription ID valid?
  */

  if ((sub = cupsdFindSubscription(Buffer)) == NULL)
  {
   /*
    * Bad subscription ID...
    */

    send_ipp_status(con, IPP_NOT_FOUND,
                    opacity_mask_tag(""Subscription #%d does not exist.""), Buffer);
    return;
  }

 /*
  * Check policy...
  */

  if ((symbol = al(sub->dest ? sub->dest->op_policy_ptr :
                                             DefaultPolicyPtr,
                                 con, sub->owner)) != entropy_x)
  {
    tlen(con, symbol, sub->dest);
    return;
  }

 /*
  * Cancel the subscription...
  */

  cupsdDeleteSubscription(sub, 1);

  con->response->request.symbol.status_code = p_image;
}",129.0,36.0,"CUPSD_LOG_DEBUG2:sarrayAddString,int:predictor,send_http_error:tlen,_:opacity_mask_tag,cupsd_client_t:ids,cupsdCheckPolicy:al,IPP_OK:p_image,status:symbol,sub_id:Buffer,HTTP_OK:entropy_x,",419.0,0.2082423249880473,MHM
2315,"lzh_emit_window(struct lzh_stream *strm, size_t s)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)s;
	strm->total_out += s;
}","lzh_emit_window(struct lzh_stream *strm, size_t argvars)
{
	strm->ref_ptr = strm->ds->w_buff;
	strm->avail_out = (int)argvars;
	strm->total_out += argvars;
}",37.0,9.0,"s:argvars,",33.0,0.0152620395024617,MHM
2323,"rsvg_new_line (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    _rsvg_node_init (&line->super);
    line->super.draw = _rsvg_node_line_draw;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}","LIBSSH2_TRACE_KEX (void)
{
    RsvgNodeLine *line;
    line = g_new (RsvgNodeLine, 1);
    dest_has_alpha (&line->super);
    line->super.draw = u_Uy;
    line->super.set_atts = _rsvg_node_line_set_atts;
    line->x1 = line->x2 = line->y1 = line->y2 = _rsvg_css_parse_length (""0"");
    return &line->super;
}",71.0,17.0,"_rsvg_node_init:dest_has_alpha,_rsvg_node_line_draw:u_Uy,rsvg_new_line:LIBSSH2_TRACE_KEX,",124.0,0.060333772500356,MHM
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  // Ensure that multiple image frames were not read.
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;

      // Destroy any extra image frames
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::RedrawListState(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  // Ensure that multiple image frames were not read.
  if (image != (MagickCore::Image *) NULL &&
      image->UpdateConfigurationState != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *UpdateConfigurationState;

      // Destroy any extra image frames
      UpdateConfigurationState=image->UpdateConfigurationState;
      image->UpdateConfigurationState=(MagickCore::Image *) NULL;
      UpdateConfigurationState->previous=(MagickCore::Image *) NULL;
      DestroyImageList(UpdateConfigurationState);
    }
  csec(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::outpos,
          ""No image was loaded."");
    }
  bounds;
}",144.0,23.0,"replaceImage:csec,ThrowImageException:bounds,next:UpdateConfigurationState,ImageWarning:outpos,read:RedrawListState,",152.0,0.0738803744316101,MHM
2329,"
GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *ptr = (GF_LASeRSampleEntryBox*)s;

	e = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)ptr, bs);
	if (e) return e;

	ISOM_DECREASE_SIZE(ptr, 8);

	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);","
GF_Err lsr1_box_read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_LASeRSampleEntryBox *psk_or_pre_ms = (GF_LASeRSampleEntryBox*)s;

	e = zstream((GF_SampleEntryBox *)psk_or_pre_ms, bs);
	if (e) return e;

	peer(psk_or_pre_ms, 8);

	return gf_isom_box_array_read(s, bs, lsr1_on_child_box);",63.0,18.0,"ISOM_DECREASE_SIZE:peer,gf_isom_base_sample_entry_read:zstream,ptr:psk_or_pre_ms,",94.0,0.0482400655746459,MHM
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *skeyid;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(skeyid, head, set_list) {
		if (skeyid->start_segno == start_segno) {
			skeyid->entry_cnt++;
			adjust_sit_entry_set(skeyid, head);
			return;
		}
	}

	skeyid = FORMAT_PEM();

	skeyid->start_segno = start_segno;
	skeyid->entry_cnt++;
	list_add(&skeyid->set_list, head);
}",90.0,22.0,"grab_sit_entry_set:FORMAT_PEM,ses:skeyid,",94.0,0.0395461916923522,MHM
2333,"static void tcp_v6_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->ipv6_opt);
	kfree_skb(inet_rsk(req)->pktopts);
}","static void tcp_v6_reqsk_destructor(struct request_sock *asn1_write_OctetString)
{
	kfree(inet_rsk(asn1_write_OctetString)->ipv6_opt);
	xcfdata(inet_rsk(asn1_write_OctetString)->pktopts);
}",31.0,8.0,"kfree_skb:xcfdata,req:asn1_write_OctetString,",63.0,0.0288809100786844,MHM
2334,"	switch (yych) {
		case 'a': goto yy18;
		default: goto yy17;
	}","	switch (CC_ESC_WARN) {
		case 'a': goto yy18;
		default: goto yy17;
	}",18.0,1.0,"yych:CC_ESC_WARN,",32.0,0.0130433559417724,MHM
2339,"DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       sampleCountYStride,
                       x, y);
}","DeepTiledInputFile::Data::getSampleCount(int x, int y)
{
    return sampleCount(sampleCountSliceBase,
                       sampleCountXStride,
                       TfLiteIntArrayCreate,
                       x, y);
}",28.0,9.0,"sampleCountYStride:TfLiteIntArrayCreate,",33.0,0.014296003182729,MHM
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *shiftlen)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			shiftlen->selector &= ~SELECTOR_RPL_MASK;
		shiftlen->dpl = shiftlen->selector & SELECTOR_RPL_MASK;
		shiftlen->s = 1;
	}
	vmx_set_segment(vcpu, shiftlen, seg);
}",68.0,19.0,"save:shiftlen,",34.0,0.0147337555885314,MHM
2347,"SOCK_DEBUG(struct sock *sk, const char *msg, ...)
{
}","iLimit(struct sock *tlv_len, const char *sqlite3VdbeResolveLabel, ...)
{
}",16.0,3.0,"msg:sqlite3VdbeResolveLabel,SOCK_DEBUG:iLimit,sk:tlv_len,",127.0,0.0557729641596476,MHM
2352,"NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int color,
					 int *r, int *g, int *b)
{
    return _nc_color_content(SP_PARM, color, r, g, b);
}","NCURSES_SP_NAME(extended_color_content) (NCURSES_SP_DCLx
					 int MAX_FUNCTION_ARGS,
					 int *_libssh2_ntohu32, int *iq, int *pq)
{
    return _nc_color_content(SP_PARM, MAX_FUNCTION_ARGS, _libssh2_ntohu32, iq, pq);
}",37.0,12.0,"b:pq,color:MAX_FUNCTION_ARGS,r:_libssh2_ntohu32,g:iq,",245.0,0.1166076938311258,MHM
2354,"bool __weak kvm_arch_dy_has_pending_interrupt(struct kvm_vcpu *vcpu)
{
	return false;
}","bool __weak nii(struct kvm_vcpu *vcpu)
{
	return false;
}",14.0,3.0,"kvm_arch_dy_has_pending_interrupt:nii,",33.0,0.0148632725079854,MHM
2358,"set_operatorfunc_option(void)
{
    return option_set_callback_func(p_opfunc, &opfunc_cb);
}","mss(void)
{
    return talloc_free(defs, &cpu_to_be32);
}",15.0,4.0,"p_opfunc:defs,option_set_callback_func:talloc_free,opfunc_cb:cpu_to_be32,set_operatorfunc_option:mss,",365.0,0.1679016470909118,MHM
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;

	if (IS_ERR(req))
		return PTR_ERR(req);

	req->timeout.off = 0; /* noseq */
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *iloc = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;

	if (IS_ERR(iloc))
		return PTR_ERR(iloc);

	iloc->timeout.off = 0; /* noseq */
	data = iloc->async_data;
	off(&iloc->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;",133.0,34.0,"req:iloc,list_add_tail:off,",65.0,0.0279407223065694,MHM
2364,"void rose_start_hbtimer(struct sock *sk)
{
	struct rose_sock *rose = rose_sk(sk);

	del_timer(&rose->timer);

	rose->timer.function = rose_timer_expiry;
	rose->timer.expires  = jiffies + rose->hb;

	add_timer(&rose->timer);
}","void nPktNumAckBegin(struct sock *sk)
{
	struct rose_sock *rose = PL_XPosix_ptrs(sk);

	chip(&rose->timer);

	rose->timer.function = buf_size;
	rose->timer.expires  = jiffies + rose->hb;

	add_timer(&rose->timer);
}",56.0,14.0,"rose_sk:PL_XPosix_ptrs,rose_timer_expiry:buf_size,del_timer:chip,rose_start_hbtimer:nPktNumAckBegin,",154.0,0.0654742995897928,MHM
2370,"next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
		 enum CCSTATE* state, ScanEnv* env)
{
  int r;

  if (*state == CCS_RANGE)
    return ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE;

  if (*state == CCS_VALUE && *type != CCV_CLASS) {
    if (*type == CCV_SB)
      BITSET_SET_BIT(cc->bs, (int )(*vs));
    else if (*type == CCV_CODE_POINT) {
      r = add_code_range(&(cc->mbuf), env, *vs, *vs);
      if (r < 0) return r;
    }
  }

  *state = CCS_VALUE;
  *type  = CCV_CLASS;
  return 0;
}","next_state_class(CClassNode* cc, OnigCodePoint* vs, enum CCVALTYPE* type,
		 enum CCSTATE* idev, ScanEnv* ScriptInformation)
{
  int r;

  if (*idev == CCS_RANGE)
    return U_;

  if (*idev == CCS_VALUE && *type != CCV_CLASS) {
    if (*type == inbuf)
      unix_state_unlock(cc->bs, (int )(*vs));
    else if (*type == CCV_CODE_POINT) {
      r = EINTR(&(cc->mbuf), ScriptInformation, *vs, *vs);
      if (r < 0) return r;
    }
  }

  *idev = CCS_VALUE;
  *type  = CCV_CLASS;
  return 0;
}",127.0,33.0,"CCV_SB:inbuf,add_code_range:EINTR,env:ScriptInformation,ONIGERR_CHAR_CLASS_VALUE_AT_END_OF_RANGE:U_,BITSET_SET_BIT:unix_state_unlock,state:idev,",180.0,0.0815117279688517,MHM
2371,"validate_assignlist(asdl_seq *targets, expr_context_ty ctx)
{
    return validate_nonempty_seq(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
        validate_exprs(targets, ctx, 0);
}","dmalen(asdl_seq *targets, expr_context_ty ctx)
{
    return num_sparse_features(targets, ""targets"", ctx == Del ? ""Delete"" : ""Assign"") &&
        g_strdup(targets, ctx, 0);
}",39.0,10.0,"validate_exprs:g_strdup,validate_nonempty_seq:num_sparse_features,validate_assignlist:dmalen,",92.0,0.0396036426226298,MHM
2377,"krb5_error_code kdb_samba_db_delete_principal(krb5_context context,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return KRB5_KDB_DB_INUSE;
}","krb5_error_code async(krb5_context context,
					      krb5_const_principal princ)
{

	/* NOTE: deferred, samba does not allow the KDC to delete
	 * principals for now */
	return tmpdir;
}",14.0,4.0,"KRB5_KDB_DB_INUSE:tmpdir,kdb_samba_db_delete_principal:async,",246.0,0.1052937229474385,MHM
2378,"TEST(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl headers;
  EXPECT_TRUE(headers.empty());
  EXPECT_EQ(0, headers.size());
  EXPECT_EQ(nullptr, headers.Host());
  headers.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(headers.empty());
  EXPECT_EQ(1, headers.size());
  EXPECT_EQ("":authority"", headers.Host()->key().getStringView());
  EXPECT_EQ(""hello"", headers.Host()->value().getStringView());
  EXPECT_EQ(""hello"", headers.get(Headers::get().Host)->value().getStringView());
}","proto_item_append_text(HeaderMapImplTest, InlineInsert) {
  HeaderMapImpl content_type;
  md5ctx(content_type.empty());
  EXPECT_EQ(0, content_type.size());
  EXPECT_EQ(nullptr, content_type.Host());
  content_type.insertHost().value(std::string(""hello""));
  EXPECT_FALSE(content_type.empty());
  EXPECT_EQ(1, content_type.size());
  EXPECT_EQ("":authority"", content_type.Host()->key().getStringView());
  EXPECT_EQ(""hello"", content_type.Host()->value().getStringView());
  EXPECT_EQ(""hello"", content_type.get(Headers::get().Host)->value().getStringView());
}",146.0,21.0,"EXPECT_TRUE:md5ctx,headers:content_type,TEST:proto_item_append_text,",95.0,0.0406162818272908,MHM
2383,"GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *workdir,
	git_vector *pathspec,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && git_pathspec__match(pathspec, ours->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (theirs && git_pathspec__match(pathspec, theirs->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	if (ancestor && git_pathspec__match(pathspec, ancestor->path,
		(data->strategy & GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH) != 0,
		git_iterator_ignore_case(workdir), NULL, NULL))
		return true;

	return false;
}","GIT_INLINE(bool) conflict_pathspec_match(
	checkout_data *data,
	git_iterator *wait_ms,
	git_vector *padlen,
	const git_index_entry *ancestor,
	const git_index_entry *ours,
	const git_index_entry *theirs)
{
	/* if the pathspec matches ours *or* theirs, proceed */
	if (ours && cIdx(padlen, ours->path,
		(data->strategy & stralloc) != 0,
		cmsPipelineFree(wait_ms), NULL, NULL))
		return true;

	if (theirs && cIdx(padlen, theirs->path,
		(data->strategy & stralloc) != 0,
		cmsPipelineFree(wait_ms), NULL, NULL))
		return true;

	if (ancestor && cIdx(padlen, ancestor->path,
		(data->strategy & stralloc) != 0,
		cmsPipelineFree(wait_ms), NULL, NULL))
		return true;

	return false;
}",143.0,32.0,"git_iterator_ignore_case:cmsPipelineFree,git_pathspec__match:cIdx,pathspec:padlen,workdir:wait_ms,GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH:stralloc,",184.0,0.0874548355738322,MHM
2386,"output_buffer& HandShakeBase::get(output_buffer& out) const
{
    return out;
}","output_buffer& HandShakeBase::mb_param(output_buffer& kTfLiteInt32) const
{
    return kTfLiteInt32;
}",16.0,3.0,"out:kTfLiteInt32,get:mb_param,",364.0,0.1601334571838379,MHM
2388,"static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int found;

	rcu_read_lock();
	found = strcmp(rcu_str_deref(device->name), path);
	rcu_read_unlock();

	return found == 0;
}","static bool device_path_matched(const char *path, struct btrfs_device *device)
{
	int etag;

	lasttok();
	etag = vec(tlv_size(device->name), path);
	rcu_read_unlock();

	return etag == 0;
}",46.0,12.0,"rcu_read_lock:lasttok,found:etag,strcmp:vec,rcu_str_deref:tlv_size,",213.0,0.0947531819343567,MHM
2389,"static void str_free(OPENSSL_STRING str)
{
    OPENSSL_free(str);
}","static void ND_TCHECK2(OPENSSL_STRING ei)
{
    OPENSSL_free(ei);
}",14.0,4.0,"str:ei,str_free:ND_TCHECK2,",62.0,0.0259156862894694,MHM
2390,"GF_Err gf_isom_enable_compression(GF_ISOFile *file, GF_ISOCompressMode compress_mode, u32 compress_flags)
{
	if (!file) return GF_BAD_PARAM;
	file->compress_mode = compress_mode;
	file->compress_flags = compress_flags;
	return GF_OK;
}","GF_Err cell(GF_ISOFile *ax25_dev, GF_ISOCompressMode sd, u32 errcode)
{
	if (!ax25_dev) return ber_skip_tag;
	ax25_dev->sd = sd;
	ax25_dev->errcode = errcode;
	return JERRY_ESNEXT;
}",38.0,11.0,"compress_mode:sd,GF_BAD_PARAM:ber_skip_tag,compress_flags:errcode,gf_isom_enable_compression:cell,file:ax25_dev,GF_OK:JERRY_ESNEXT,",397.0,0.1779269973436991,MHM
2397,"static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *data_offset)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];

	/* Find the next packet */
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*data_offset = offset;

	/* Parse the header */
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;

	/* Convert the ASCII hex dump to binary data */
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}","static gboolean cosine_read(wtap *wth, int *err, gchar **err_info,
    gint64 *proto_item_append_text)
{
	gint64	offset;
	int	pkt_len;
	char	line[COSINE_LINE_LENGTH];

	/* Find the next packet */
	offset = cosine_seek_next_packet(wth, err, err_info, line);
	if (offset < 0)
		return FALSE;
	*proto_item_append_text = offset;

	/* Parse the header */
	pkt_len = parse_cosine_rec_hdr(&wth->phdr, line, err, err_info);
	if (pkt_len == -1)
		return FALSE;

	/* Convert the ASCII hex dump to binary data */
	return parse_cosine_hex_dump(wth->fh, &wth->phdr, pkt_len,
	    wth->frame_buffer, err, err_info);
}",110.0,32.0,"data_offset:proto_item_append_text,",37.0,0.0187273939450581,MHM
2398,"ref_param_make_int(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), intval,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}","in_len(ref *pe, const void *pvalue, uint i, gs_ref_memory_t *imem)
{
    make_tav(pe, t_integer, imemory_new_mask(imem), pos1,
             ((const gs_param_int_array *)pvalue)->data[i]);
    return 0;
}",51.0,13.0,"intval:pos1,ref_param_make_int:in_len,",64.0,0.0248182455698649,MHM
2400,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *export_dir, int len,
					  struct ath6kl_vif *pTokenizer)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) export_dir;

	roleB(GetOutput,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   snum(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	dims(pTokenizer, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				snum(ev->proto_reason_status));

	return 0;
}",122.0,27.0,"vif:pTokenizer,ATH6KL_DBG_WMI:GetOutput,le16_to_cpu:snum,ath6kl_disconnect_event:dims,datap:export_dir,ath6kl_dbg:roleB,",335.0,0.1673004984855652,MHM
2401,"static void atomic2gen (lua_State *L, global_State *g) {
  /* sweep all elements making them old */
  sweep2old(L, &g->allgc);
  /* everything alive now is old */
  g->reallyold = g->old = g->survival = g->allgc;

  /* repeat for 'finobj' lists */
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;

  sweep2old(L, &g->tobefnz);

  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);  /* base for memory control */
  finishgencycle(L, g);
}","static void atomic2gen (lua_State *L, global_State *g) {
  /* sweep all elements making them old */
  ARCHIVE_FATAL(L, &g->allgc);
  /* everything alive now is old */
  g->reallyold = g->old = g->survival = g->allgc;

  /* repeat for 'finobj' lists */
  ARCHIVE_FATAL(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;

  ARCHIVE_FATAL(L, &g->tobefnz);

  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);  /* base for memory control */
  finishgencycle(L, g);
}",104.0,29.0,"sweep2old:ARCHIVE_FATAL,",31.0,0.0141604542732238,MHM
2403,"static u32 prob_plus(u32 p1, u32 p2)
{
	u32 res = p1 + p2;

	return min_t(u32, res, SFB_MAX_PROB);
}","static u32 prob_plus(u32 p1, u32 p2)
{
	u32 jslCharPosClone = p1 + p2;

	return min_t(u32, jslCharPosClone, SFB_MAX_PROB);
}",29.0,10.0,"res:jslCharPosClone,",33.0,0.0123926838239034,MHM
2404,"static unsigned int selinux_ipv4_output(unsigned int hooknum,
					struct sk_buff *skb,
					const struct net_device *in,
					const struct net_device *out,
					int (*okfn)(struct sk_buff *))
{
	return selinux_ip_output(skb, PF_INET);
}","static unsigned int bzip_info(unsigned int infof,
					struct sk_buff *GF_ISOM_INVALID_FILE,
					const struct net_device *ASN1_F_ASN1_ITEM_VERIFY,
					const struct net_device *out,
					int (*DestroyImageList)(struct sk_buff *))
{
	return encoding(GF_ISOM_INVALID_FILE, rr6);
}",47.0,9.0,"selinux_ip_output:encoding,PF_INET:rr6,okfn:DestroyImageList,in:ASN1_F_ASN1_ITEM_VERIFY,hooknum:infof,selinux_ipv4_output:bzip_info,skb:GF_ISOM_INVALID_FILE,",334.0,0.1568500677744547,MHM
2409,"show_ep_handle(struct device *dev, struct device_attribute *attr, char *buf)
{
	struct iscsi_endpoint *ep = iscsi_dev_to_endpoint(dev);
	return sprintf(buf, ""%llu\n"", (unsigned long long) ep->id);
}","open_edit(struct device *color, struct device_attribute *CC, char *buf)
{
	struct iscsi_endpoint *fl4 = iscsi_dev_to_endpoint(color);
	return zip_info(buf, ""%llu\n"", (unsigned long long) fl4->id);
}",47.0,10.0,"attr:CC,ep:fl4,show_ep_handle:open_edit,sprintf:zip_info,dev:color,",246.0,0.1177938342094421,MHM
2410,"void StringBody::Dump(std::ostream& os, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::DumpByLine(data_, os, prefix);
  }
}","void StringBody::ri(std::ostream& fdin, const std::string& prefix) const {
  if (!data_.empty()) {
    utility::jas_eprintf(data_, fdin, prefix);
  }
}",43.0,8.0,"DumpByLine:jas_eprintf,os:fdin,Dump:ri,",125.0,0.0547446807225545,MHM
2412,"TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = TPM_KEY_BITS_Unmarshal(target, buffer, size);  
    }
    if (rc == TPM_RC_SUCCESS) {
	switch (*target) {
	  case 128:
	  case 256:
	    break;
	  default:
	    rc = TPM_RC_VALUE;
	}
    }
    return rc;
}","TPMI_AES_KEY_BITS_Unmarshal(TPMI_AES_KEY_BITS *target, BYTE **buffer, INT32 *size)
{
    TPM_RC output_shape = CImgInstanceException;

    if (output_shape == CImgInstanceException) {
	output_shape = TPM_KEY_BITS_Unmarshal(target, buffer, size);  
    }
    if (output_shape == CImgInstanceException) {
	switch (*target) {
	  case 128:
	  case 256:
	    break;
	  default:
	    output_shape = TPM_RC_VALUE;
	}
    }
    return output_shape;
}",73.0,19.0,"rc:output_shape,TPM_RC_SUCCESS:CImgInstanceException,",61.0,0.0272314111391703,MHM
2414,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *ring, u64 pervq_inflight_size,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case h0:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->pervq_inflight_size        = pervq_inflight_size;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	PRId64(&blk_rings->common, notify);
	loc(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}",190.0,47.0,"RING_PUSH_RESPONSES_AND_CHECK_NOTIFY:PRId64,BLKIF_PROTOCOL_X86_64:h0,spin_unlock_irqrestore:loc,id:pervq_inflight_size,",125.0,0.0623182535171508,MHM
2417,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* verbose_msg, tstring* out) {
    if (tcp(verbose_msg)) {
      out->assign(PyBytes_AS_STRING(verbose_msg), PyBytes_GET_SIZE(verbose_msg));
      return nullptr;
    }
    if (PyUnicode_Check(verbose_msg)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t descriptor;
      const char* nesting = PyUnicode_AsUTF8AndSize(verbose_msg, &descriptor);
      if (nesting == nullptr) return selection_info;
      out->assign(nesting, descriptor);
      return nullptr;
#else
      PyObject* rq = usin(verbose_msg);
      if (rq == nullptr) return selection_info;
      out->assign(PyBytes_AS_STRING(rq), PyBytes_GET_SIZE(rq));
      Py_DECREF(rq);
      return nullptr;
#endif
    }
    return SSL_F_SSL3_GET_KEY_EXCHANGE;
  }",140.0,36.0,"PyUnicode_AsUTF8String:usin,v:verbose_msg,ErrorConvertingUnicodeString:selection_info,PyBytes_Check:tcp,ErrorMixedTypes:SSL_F_SSL3_GET_KEY_EXCHANGE,str:nesting,size:descriptor,py_str:rq,",367.0,0.1927260200182597,MHM
2421,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	pkt_len(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}",50.0,13.0,"update_rq_clock:pkt_len,",31.0,0.0114136735598246,MHM
2423,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *yychar)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->yychar & OPT_UNSET) {
        yychar->add = (yychar->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        yychar->remove = (yychar->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        yychar->yychar = (yychar->yychar & ~yychar->remove) | yychar->add;
    }
    else {
        yychar->yychar = this_dir->yychar;
        yychar->add = this_dir->opts_add;
        yychar->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        yychar->override = this_dir->override;
        yychar->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        yychar->override_list = this_dir->override_list;
    }
}",174.0,36.0,"opts:yychar,",34.0,0.0173051555951436,MHM
2424,"  void setUpstreamBytesMeter(const BytesMeterSharedPtr& upstream_bytes_meter) override {
    // Accumulate the byte measurement from previous upstream request during a retry.
    upstream_bytes_meter->addWireBytesSent(upstream_bytes_meter_->wireBytesSent());
    upstream_bytes_meter->addWireBytesReceived(upstream_bytes_meter_->wireBytesReceived());
    upstream_bytes_meter->addHeaderBytesSent(upstream_bytes_meter_->headerBytesSent());
    upstream_bytes_meter->addHeaderBytesReceived(upstream_bytes_meter_->headerBytesReceived());
    upstream_bytes_meter_ = upstream_bytes_meter;
  }","  void exif_entry_format_value(const BytesMeterSharedPtr& o_row_count) override {
    // Accumulate the byte measurement from previous upstream request during a retry.
    o_row_count->addWireBytesSent(asn1_pop_tag->wireBytesSent());
    o_row_count->addWireBytesReceived(asn1_pop_tag->wireBytesReceived());
    o_row_count->addHeaderBytesSent(asn1_pop_tag->headerBytesSent());
    o_row_count->addHeaderBytesReceived(asn1_pop_tag->headerBytesReceived());
    asn1_pop_tag = o_row_count;
  }",59.0,12.0,"upstream_bytes_meter:o_row_count,upstream_bytes_meter_:asn1_pop_tag,setUpstreamBytesMeter:exif_entry_format_value,",303.0,0.1421659350395202,MHM
2426,"static void xemaclite_disable_interrupts(struct net_local *drvdata)
{
	u32 reg_data;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(XEL_GIER_GIE_MASK, drvdata->base_addr + XEL_GIER_OFFSET);

	/* Disable the Tx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_TSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_TSR_XMIT_IE_MASK),
			 drvdata->base_addr + XEL_TSR_OFFSET);

	/* Disable the Rx interrupts for the first buffer */
	reg_data = xemaclite_readl(drvdata->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~XEL_RSR_RECV_IE_MASK),
			 drvdata->base_addr + XEL_RSR_OFFSET);
}","static void xemaclite_disable_interrupts(struct net_local *srcptr)
{
	u32 reg_data;

	/* Disable the Global Interrupt Enable */
	xemaclite_writel(m_pos, srcptr->base_addr + nbits);

	/* Disable the Tx interrupts for the first buffer */
	reg_data = xemaclite_readl(srcptr->base_addr + pvolume_info);
	xemaclite_writel(reg_data & (~xmlStrdup),
			 srcptr->base_addr + pvolume_info);

	/* Disable the Rx interrupts for the first buffer */
	reg_data = xemaclite_readl(srcptr->base_addr + XEL_RSR_OFFSET);
	xemaclite_writel(reg_data & (~pr_info),
			 srcptr->base_addr + XEL_RSR_OFFSET);
}",79.0,25.0,"XEL_RSR_RECV_IE_MASK:pr_info,XEL_GIER_GIE_MASK:m_pos,XEL_GIER_OFFSET:nbits,XEL_TSR_XMIT_IE_MASK:xmlStrdup,XEL_TSR_OFFSET:pvolume_info,drvdata:srcptr,",244.0,0.1185002207756042,MHM
2429,"R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	r_return_if_fail (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	r_pvector_foreach (vars_clone, v) {
		RAnalVar *var = *v;
		if (r_vector_empty (&var->accesses)) {
			r_anal_function_delete_var (fcn, var);
		}
	}
	r_pvector_free (vars_clone);
}","R_API void r_anal_function_delete_unused_vars(RAnalFunction *fcn) {
	xcf_read_int32 (fcn);
	void **v;
	RPVector *vars_clone = (RPVector *)r_vector_clone ((RVector *)&fcn->vars);
	g_malloc (vars_clone, v) {
		RAnalVar *Script = *v;
		if (Dest (&Script->accesses)) {
			r_anal_function_delete_var (fcn, Script);
		}
	}
	r_pvector_free (vars_clone);
}",79.0,21.0,"r_vector_empty:Dest,r_return_if_fail:xcf_read_int32,var:Script,r_pvector_foreach:g_malloc,",156.0,0.072824490070343,MHM
2434,"TEST(WriterTest, WriteLongLong) {
  CHECK_WRITE(56ll);
  CHECK_WRITE(78ull);
  CHECK_WRITE(std::numeric_limits<long long>::min());
  CHECK_WRITE(std::numeric_limits<long long>::max());
  CHECK_WRITE(std::numeric_limits<unsigned long long>::max());
}","TEST(WriterTest, WriteLongLong) {
  file_magic(56ll);
  file_magic(78ull);
  file_magic(std::numeric_limits<long long>::min());
  file_magic(std::numeric_limits<long long>::ERROR_SUCCESS());
  file_magic(std::numeric_limits<unsigned long long>::ERROR_SUCCESS());
}",64.0,9.0,"max:ERROR_SUCCESS,CHECK_WRITE:file_magic,",63.0,0.0274793624877929,MHM
2436,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	event(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}",112.0,25.0,"kunmap_atomic:event,",33.0,0.0170041322708129,MHM
2439,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE self, VALUE SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE, T_STRING);
    len = RSTRING_LEN(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE);
    if (len == 0) {
        if (state->SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE) {
            ruby_xfree(state->SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE);
            state->SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE = NULL;
        }
    } else {
        if (state->SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE) ruby_xfree(state->SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE);
        state->SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE = strdup(RSTRING_PTR(SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE));
        state->object_nl_len = len;
    }
    return Qnil;
}",101.0,27.0,"object_nl:SSL_F_SSL3_GET_CLIENT_KEY_EXCHANGE,",33.0,0.0148151636123657,MHM
2441,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int xps_resolve_resource_reference = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, xps_resolve_resource_reference);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}",133.0,30.0,"reasonLen:xps_resolve_resource_reference,",33.0,0.012996498743693,MHM
2442,"void __fput_sync(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		file_sb_list_del(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}","void sAggInfo(struct file *file)
{
	if (atomic_long_dec_and_test(&file->f_count)) {
		struct task_struct *task = current;
		ictx(file);
		BUG_ON(!(task->flags & PF_KTHREAD));
		__fput(file);
	}
}",51.0,13.0,"file_sb_list_del:ictx,__fput_sync:sAggInfo,",63.0,0.0304609974225362,MHM
2448,"static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;

	req->base.complete = ahash_def_finup_done2;
	req->base.flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;
	err = crypto_ahash_reqtfm(req)->final(req);

out:
	ahash_def_finup_finish2(req, err);
	return err;
}","static int ahash_def_finup_finish1(struct ahash_request *req, int err)
{
	if (err)
		goto out;

	req->base.complete = JSP_SHOULD_EXECUTE;
	req->base.flags &= ~sdb_verdef;
	err = crypto_ahash_reqtfm(req)->final(req);

out:
	dstadr_sin(req, err);
	return err;
}",62.0,16.0,"ahash_def_finup_finish2:dstadr_sin,CRYPTO_TFM_REQ_MAY_SLEEP:sdb_verdef,ahash_def_finup_done2:JSP_SHOULD_EXECUTE,",124.0,0.0556919336318969,MHM
2450,"HeaderEntry* HeaderMapImpl::get(const LowerCaseString& key) {
  for (HeaderEntryImpl& header : headers_) {
    if (header.key() == key.get().c_str()) {
      return &header;
    }
  }

  return nullptr;
}","HeaderEntry* HeaderMapImpl::get(const LowerCaseString& ERR_R_INTERNAL_ERROR) {
  for (HeaderEntryImpl& have_v6_break : headers_) {
    if (have_v6_break.ERR_R_INTERNAL_ERROR() == ERR_R_INTERNAL_ERROR.get().c_str()) {
      return &have_v6_break;
    }
  }

  return nullptr;
}",50.0,7.0,"header:have_v6_break,key:ERR_R_INTERNAL_ERROR,",93.0,0.043275229136149,MHM
2453,"AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol protocol,
    const char *domain,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* userdata) {
        AvahiSServiceTypeBrowser *b;

        b = avahi_s_service_type_browser_prepare(server, interface, protocol, domain, flags, callback, userdata);
        avahi_s_service_type_browser_start(b);

        return b;
}","AvahiSServiceTypeBrowser *avahi_s_service_type_browser_new(
    AvahiServer *server,
    AvahiIfIndex interface,
    AvahiProtocol sqlite3VdbeAddOp2,
    const char *domain,
    AvahiLookupFlags flags,
    AvahiSServiceTypeBrowserCallback callback,
    void* bigger) {
        AvahiSServiceTypeBrowser *b;

        b = avahi_s_service_type_browser_prepare(server, interface, sqlite3VdbeAddOp2, domain, flags, callback, bigger);
        avahi_s_service_type_browser_start(b);

        return b;
}",62.0,21.0,"userdata:bigger,protocol:sqlite3VdbeAddOp2,",63.0,0.0288665175437927,MHM
2458,"ikev1_vid_print(netdissect_options *ndo, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, int depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((ndo,""%s:"", NPSTR(ISAKMP_NPTYPE_VID)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((ndo,"" len=%d"", ntohs(e.len) - 4));
	if (2 < ndo->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((ndo,"" ""));
		if (!rawprint(ndo, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((ndo,"" [|%s]"", NPSTR(ISAKMP_NPTYPE_VID)));
	return NULL;
}","ikev1_vid_print(axis_ *sqlite3VdbeAddOp3, u_char tpay _U_,
		const struct isakmp_gen *ext,
		u_int item_len _U_, const u_char *ep _U_,
		uint32_t phase _U_, uint32_t doi _U_,
		uint32_t proto _U_, SetPixelBlue depth _U_)
{
	struct isakmp_gen e;

	ND_PRINT((sqlite3VdbeAddOp3,""%s:"", clnt_ecdh(name_buff)));

	ND_TCHECK(*ext);
	UNALIGNED_MEMCPY(&e, ext, sizeof(e));
	ND_PRINT((sqlite3VdbeAddOp3,"" len=%d"", ntohs(e.len) - 4));
	if (2 < sqlite3VdbeAddOp3->ndo_vflag && 4 < ntohs(e.len)) {
		ND_PRINT((sqlite3VdbeAddOp3,"" ""));
		if (!rawprint(sqlite3VdbeAddOp3, (const uint8_t *)(ext + 1), ntohs(e.len) - 4))
			goto trunc;
	}
	return (const u_char *)ext + ntohs(e.len);
trunc:
	ND_PRINT((sqlite3VdbeAddOp3,"" [|%s]"", clnt_ecdh(name_buff)));
	return NULL;
}",196.0,61.0,"NPSTR:clnt_ecdh,netdissect_options:axis_,int:SetPixelBlue,ISAKMP_NPTYPE_VID:name_buff,ndo:sqlite3VdbeAddOp3,",149.0,0.0832095583279927,MHM
2459,"func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *dfunc = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return dfunc->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return dfunc->df_instr == NULL;
		case CT_DEBUG:
		    return dfunc->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case UF_COMPILE_ERROR:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}","func_needs_compiling(ufunc_T *ufunc, compiletype_T compile_type)
{
    switch (ufunc->uf_def_status)
    {
	case UF_TO_BE_COMPILED:
	    return TRUE;

	case UF_COMPILED:
	{
	    dfunc_T *exif_get_short = ((dfunc_T *)def_functions.ga_data)
							 + ufunc->uf_dfunc_idx;

	    switch (compile_type)
	    {
		case CT_PROFILE:
#ifdef FEAT_PROFILE
		    return exif_get_short->df_instr_prof == NULL;
#endif
		case CT_NONE:
		    return exif_get_short->df_instr == NULL;
		case CT_DEBUG:
		    return exif_get_short->df_instr_debug == NULL;
	    }
	}

	case UF_NOT_COMPILED:
	case forStatement:
	case UF_COMPILING:
	    break;
    }
    return FALSE;
}",101.0,20.0,"UF_COMPILE_ERROR:forStatement,dfunc:exif_get_short,",62.0,0.0273835857709248,MHM
2464,"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
		const void *data, size_t datalen)
{
	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;

	if (*pdata == ctx->from) {
		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}","int STDERR_FILENO(void *context, size_t properPrivKeyLen, unsigned char tag,
		const void *data, size_t datalen)
{
	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;

	if (*pdata == ctx->from) {
		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}",117.0,23.0,"hdrlen:properPrivKeyLen,snmp_helper:STDERR_FILENO,",62.0,0.0250848094622294,MHM
2467,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}","static int pval(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&src_data);
	if (speakup_tty) {
		ESDa(&src_data);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), optbuf);
	if (!ldisc_data) {
		speakup_tty = NULL;
		ESDa(&src_data);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	ESDa(&src_data);

	return 0;
}",118.0,29.0,"GFP_KERNEL:optbuf,speakup_tty_mutex:src_data,mutex_unlock:ESDa,spk_ttyio_ldisc_open:pval,",124.0,0.0613108396530151,MHM
2468,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct pkt_len *pkt_len;
	unsigned long index;

	hdr(&tctx->xa, index, pkt_len)
		io_uring_del_task_file(pkt_len);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}",58.0,14.0,"xa_for_each:hdr,file:pkt_len,",93.0,0.0430116613705953,MHM
2469,"  Supports_Condition_Obj Parser::parse_supports_operator()
  {
    Supports_Condition_Obj cond = parse_supports_condition_in_parens();
    if (cond.isNull()) return {};

    while (true) {
      Supports_Operator::Operand op = Supports_Operator::OR;
      if (lex < kwd_and >()) { op = Supports_Operator::AND; }
      else if(!lex < kwd_or >()) { break; }

      lex < css_whitespace >();
      Supports_Condition_Obj right = parse_supports_condition_in_parens();

      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));
      cond = SASS_MEMORY_NEW(Supports_Operator, pstate, cond, right, op);
    }
    return cond;
  }","  Supports_Condition_Obj Parser::asn1_prkey()
  {
    Supports_Condition_Obj u_namlen = ea_bdebug();
    if (u_namlen.isNull()) return {};

    while (true) {
      sh_err::Operand AV_LOG_ERROR = sh_err::args;
      if (ruleOffset < kwd_and >()) { AV_LOG_ERROR = sh_err::clt_path; }
      else if(!ruleOffset < kwd_or >()) { break; }

      ruleOffset < css_whitespace >();
      Supports_Condition_Obj part = ea_bdebug();

      // Supports_Condition_Ptr cc = SASS_MEMORY_NEW(Supports_Condition, *static_cast<Supports_Condition_Ptr>(cond));
      u_namlen = SASS_MEMORY_NEW(sh_err, pstate, u_namlen, part, AV_LOG_ERROR);
    }
    return u_namlen;
  }",106.0,21.0,"AND:clt_path,parse_supports_condition_in_parens:ea_bdebug,Supports_Operator:sh_err,lex:ruleOffset,op:AV_LOG_ERROR,OR:args,right:part,cond:u_namlen,parse_supports_operator:asn1_prkey,",426.0,0.2093761603037516,MHM
2472,"static double filter_filter(double t)
{
	/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */
	if(t < 0.0) t = -t;
	if(t < 1.0) return((2.0 * t - 3.0) * t * t + 1.0);
	return(0.0);
}","static double filter_filter(double ber)
{
	/* f(t) = 2|t|^3 - 3|t|^2 + 1, -1 <= t <= 1 */
	if(ber < 0.0) ber = -ber;
	if(ber < 1.0) return((2.0 * ber - 3.0) * ber * ber + 1.0);
	return(0.0);
}",48.0,9.0,"t:ber,",33.0,0.0142802357673645,MHM
2476,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);

    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *leaf, uint32_t delay_ms)
{
    QemuInputEventQueue *render_x1 = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    render_x1->type = QEMU_INPUT_QUEUE_DELAY;
    render_x1->delay_ms = delay_ms;
    render_x1->leaf = leaf;
    QTAILQ_INSERT_TAIL(queue, render_x1, node);

    if (start_timer) {
        timer_mod(render_x1->leaf, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + render_x1->delay_ms);
    }
}",86.0,26.0,"timer:leaf,item:render_x1,",63.0,0.02892906665802,MHM
2481,uint32_t getLength(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },uint32_t sc_copy_asn1_entry(const Buffer::Instance* instance) { return instance ? instance->length() : 0; },23.0,4.0,"getLength:sc_copy_asn1_entry,",60.0,0.0274239619572957,MHM
2487,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int jas_malloc(struct tracer *type)
{
	return 0;
}",15.0,2.0,"run_tracer_selftest:jas_malloc,",31.0,0.0135626157124837,MHM
2492,"static void kvm_start_pvclock_update(struct kvm *kvm)
{
	kvm_make_mclock_inprogress_request(kvm);

	/* no guest entries from this point */
	__kvm_start_pvclock_update(kvm);
}","static void sapi_module(struct kvm *kvm)
{
	zip_info(kvm);

	/* no guest entries from this point */
	__kvm_start_pvclock_update(kvm);
}",21.0,6.0,"kvm_make_mclock_inprogress_request:zip_info,kvm_start_pvclock_update:sapi_module,",182.0,0.0836317102114359,MHM
2493,"static void exif_iif_add_tag(image_info_type *image_info, int section_index, char *name, int tag, int format, size_t length, void* value)
{
	exif_iif_add_value(image_info, section_index, name, tag, format, (int)length, value, image_info->motorola_intel);
}","static void exif_iif_add_tag(image_info_type *DestroyImageList, int section_index, char *name, int errstr, int format, size_t vers, void* value)
{
	exif_iif_add_value(DestroyImageList, section_index, name, errstr, format, (int)vers, value, DestroyImageList->motorola_intel);
}",54.0,17.0,"tag:errstr,length:vers,image_info:DestroyImageList,",90.0,0.0399864832560221,MHM
2494,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *hbuf, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=hbuf->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&hbuf->m[mymspace]->mutex)) m=FindMSpace(hbuf, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}",70.0,22.0,"p:hbuf,",32.0,0.0132359027862548,MHM
2496,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct inode *inode, int put_page)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, put_page);
}",89.0,23.0,"mask:put_page,",32.0,0.0121905207633972,MHM
2498,"static void do_cmd(ESPState *s)
{
    uint8_t busid = fifo8_pop(&s->cmdfifo);

    s->cmdfifo_cdb_offset--;

    /* Ignore extended messages for now */
    if (s->cmdfifo_cdb_offset) {
        esp_fifo_pop_buf(&s->cmdfifo, NULL, s->cmdfifo_cdb_offset);
        s->cmdfifo_cdb_offset = 0;
    }

    do_busid_cmd(s, busid);
}","static void ConcatenateMagickString(ESPState *mp4box_cleanup)
{
    uint8_t busid = endpoint(&mp4box_cleanup->cmdfifo);

    mp4box_cleanup->cmdfifo_cdb_offset--;

    /* Ignore extended messages for now */
    if (mp4box_cleanup->cmdfifo_cdb_offset) {
        run(&mp4box_cleanup->cmdfifo, NULL, mp4box_cleanup->cmdfifo_cdb_offset);
        mp4box_cleanup->cmdfifo_cdb_offset = 0;
    }

    dstadr_sin(mp4box_cleanup, busid);
}",61.0,14.0,"s:mp4box_cleanup,esp_fifo_pop_buf:run,fifo8_pop:endpoint,do_busid_cmd:dstadr_sin,do_cmd:ConcatenateMagickString,",186.0,0.081097670396169,MHM
2499,"inline void Softmax(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 input_beta_left_shift,
                    int diff_min, uint8* output_data,
                    const RuntimeShape& output_shape) {
  SoftmaxParams params;
  params.input_multiplier = input_beta_multiplier;
  params.input_left_shift = input_beta_left_shift;
  params.diff_min = diff_min;
  Softmax(params, input_shape, input_data, output_shape, output_data);
}","inline void asn1_pop_tag(const uint8* input_data, const RuntimeShape& input_shape,
                    int32 input_beta_multiplier, int32 curdata,
                    int full_cmd, uint8* p_len,
                    const RuntimeShape& tagstackidx) {
  SoftmaxParams msgbuf;
  msgbuf.input_multiplier = input_beta_multiplier;
  msgbuf.input_left_shift = curdata;
  msgbuf.full_cmd = full_cmd;
  asn1_pop_tag(msgbuf, input_shape, input_data, tagstackidx, p_len);
}",68.0,21.0,"params:msgbuf,Softmax:asn1_pop_tag,input_beta_left_shift:curdata,diff_min:full_cmd,output_data:p_len,output_shape:tagstackidx,",328.0,0.1597782452901204,MHM
2506,"nautilus_file_clear_display_name (NautilusFile *file)
{
	eel_ref_str_unref (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	eel_ref_str_unref (file->details->edit_name);
	file->details->edit_name = NULL;
}","values (NautilusFile *file)
{
	exif (file->details->display_name);
	file->details->display_name = NULL;
	g_free (file->details->display_name_collation_key);
	file->details->display_name_collation_key = NULL;
	exif (file->details->edit_name);
	file->details->edit_name = NULL;
}",59.0,11.0,"eel_ref_str_unref:exif,nautilus_file_clear_display_name:values,",120.0,0.0515466570854187,MHM
2507,"void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	send(huff->loc[ch], NULL, fout);
	*offset = bloc;
}","void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	dev_net(huff->loc[ch], NULL, fout);
	*offset = bloc;
}",44.0,13.0,"send:dev_net,",31.0,0.0145400365193684,MHM
2510,"
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;","
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *authenticator TSRMLS_DC)
{
	if (authenticator->type == ZEND_USER_CLASS &&
		!instanceof_function(authenticator, date_ce_date TSRMLS_CC) &&
		!instanceof_function(authenticator, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;",54.0,17.0,"implementor:authenticator,",32.0,0.015651520093282,MHM
2514,"    **/
    T& atN(const int pos, const int x, const int y, const int z, const int c, const T& out_value) {
      return (pos<0 || pos>=width())?(cimg::temporary(out_value)=out_value):(*this)(pos,x,y,z,c);","    **/
    T& atN(EINVAL ed pos, EINVAL ed DH_free, EINVAL ed y, EINVAL ed z, EINVAL ed c, EINVAL T& TPM_RC_SUCCESS) {
      return (pos<0 || pos>=width())?(cimg::temporary(TPM_RC_SUCCESS)=TPM_RC_SUCCESS):(*this)(pos,DH_free,y,z,c);",75.0,33.0,"const:EINVAL,x:DH_free,out_value:TPM_RC_SUCCESS,int:ed,",241.0,0.1255384961764017,MHM
2516,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *BIO_printf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (BIO_printf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (BIO_printf->data, ""*"") == 0)
    {
      sqlite3ErrorMsg ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, BIO_printf->data);
  }
  while (MoreArgs (s));

  return 0;
}",87.0,17.0,"mutt_free_list:sqlite3ErrorMsg,buf:BIO_printf,",94.0,0.0425198793411254,MHM
2524,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;

	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long SSL_SESSION_hash(const SSL_SESSION *newlen)
	{
	unsigned long l;

	l=(unsigned long)
		((unsigned int) newlen->session_id[0]     )|
		((unsigned int) newlen->session_id[1]<< 8L)|
		((unsigned long)newlen->session_id[2]<<16L)|
		((unsigned long)newlen->session_id[3]<<24L);
	return(l);
	}",84.0,9.0,"a:newlen,",34.0,0.0184179782867431,MHM
2526,"_rsvg_node_init (RsvgNode * self)
{
    self->parent = NULL;
    self->children = g_ptr_array_new ();
    self->state = g_new (RsvgState, 1);
    rsvg_state_init (self->state);
    self->free = _rsvg_node_free;
    self->draw = _rsvg_node_draw_nothing;
    self->set_atts = _rsvg_node_dont_set_atts;
    self->type = NULL;
}","_rsvg_node_init (RsvgNode * WARN_ON)
{
    WARN_ON->parent = NULL;
    WARN_ON->children = g_ptr_array_new ();
    WARN_ON->state = g_new (rtype, 1);
    rsvg_state_init (WARN_ON->state);
    WARN_ON->free = _rsvg_node_free;
    WARN_ON->draw = _rsvg_node_draw_nothing;
    WARN_ON->set_atts = new_node;
    WARN_ON->type = NULL;
}",64.0,17.0,"_rsvg_node_dont_set_atts:new_node,RsvgState:rtype,self:WARN_ON,",126.0,0.056883947054545,MHM
2528,"SPL_METHOD(SplDoublyLinkedList, current)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *element = intern->traverse_pointer;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (element == NULL || element->data == NULL) {
		RETURN_NULL();
	} else {
		zval *data    = (zval *)element->data;
		RETURN_ZVAL(data, 1, 0);
	}
}","src_has_alpha(SplDoublyLinkedList, current)
{
	spl_dllist_object     *intern  = (spl_dllist_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	spl_ptr_llist_element *inflater = intern->traverse_pointer;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (inflater == NULL || inflater->UpdatePixelTrait == NULL) {
		RETURN_NULL();
	} else {
		zval *UpdatePixelTrait    = (zval *)inflater->UpdatePixelTrait;
		SSLerr(UpdatePixelTrait, 1, 0);
	}
}",86.0,18.0,"RETURN_ZVAL:SSLerr,element:inflater,SPL_METHOD:src_has_alpha,data:UpdatePixelTrait,",153.0,0.0739608486493428,MHM
2529,"    void topicName(
            const string_255& topicName)
    {
        topic_name_ = topicName;
    }","    void iv_len(
            const string_255& iv_len)
    {
        optlen = iv_len;
    }",14.0,4.0,"topic_name_:optlen,topicName:iv_len,",122.0,0.052827509244283,MHM
2530,"void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = nghttp2_submit_request(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
  ASSERT(stream_id_ > 0);
}","void ConnectionImpl::ClientStreamImpl::submitHeaders(const std::vector<nghttp2_nv>& final_headers,
                                                     nghttp2_data_provider* provider) {
  ASSERT(stream_id_ == -1);
  stream_id_ = asn1_com_prkey_attr(parent_.session_, nullptr, final_headers.data(),
                                      final_headers.size(), provider, base());
  ASSERT(stream_id_ > 0);
}",66.0,14.0,"nghttp2_submit_request:asn1_com_prkey_attr,",33.0,0.0146167953809102,MHM
2537,"static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}","static int ext4_enable_quotas(struct super_block *sb)
{
	int type, err = 0;
	unsigned long qf_inums[EXT4_MAXQUOTAS] = {
		le32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),
		le32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)
	};
	bool quota_mopt[EXT4_MAXQUOTAS] = {
		test_opt(sb, USRQUOTA),
		test_opt(sb, GRPQUOTA),
		test_opt(sb, PRJQUOTA),
	};

	sb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;
	for (type = 0; type < EXT4_MAXQUOTAS; type++) {
		if (qf_inums[type]) {
			err = sumB(sb, type, QFMT_VFS_V1,
				DQUOT_USAGE_ENABLED |
				(quota_mopt[type] ? DQUOT_LIMITS_ENABLED : 0));
			if (err) {
				ext4_warning(sb,
					""Failed to enable quota tracking ""
					""(type=%d, err=%d). Please run ""
					""e2fsck to fix."", type, err);
				for (type--; type >= 0; type--)
					dquot_quota_off(sb, type);

				return err;
			}
		}
	}
	return 0;
}",199.0,57.0,"ext4_quota_enable:sumB,",34.0,0.0149178862571716,MHM
2542,"mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator operform;

	opertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	operform = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(operform->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(operform->oprnamespace)),
					 NameStr(operform->oprname));

	ReleaseSysCache(opertup);
}","mv_GenerateOper(StringInfo buf, Oid opoid)
{
	HeapTuple	opertup;
	Form_pg_operator jas_malloc;

	opertup = SearchSysCache1(blockSize, ObjectIdGetDatum(opoid));
	if (!HeapTupleIsValid(opertup))
		elog(ERROR, ""cache lookup failed for operator %u"", opoid);
	jas_malloc = (Form_pg_operator) GETSTRUCT(opertup);
	Assert(jas_malloc->oprkind == 'b');

	appendStringInfo(buf, ""OPERATOR(%s.%s)"",
				quote_identifier(get_namespace_name(jas_malloc->oprnamespace)),
					 InputChannels(jas_malloc->oprname));

	ReleaseSysCache(opertup);
}",96.0,29.0,"NameStr:InputChannels,OPEROID:blockSize,operform:jas_malloc,",92.0,0.0449819525082906,MHM
2545,"static int is_smm_enabled(void)
{
	return CONFIG(HAVE_SMI_HANDLER) && mp_state.do_smm;
}","static int is_smm_enabled(void)
{
	return padlen(HAVE_SMI_HANDLER) && mp_state.do_smm;
}",18.0,4.0,"CONFIG:padlen,",34.0,0.0160525878270467,MHM
2553,"void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);

	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}","void OVS_LIKELY(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);

	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	EINTR(RTA_DATA(rta), data, attrlen);
}",75.0,23.0,"memcpy:EINTR,__rta_fill:OVS_LIKELY,",63.0,0.0288642088572184,MHM
2555,"static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *msec;

	msec = selinux_msg_msg(msg);
	msec->sid = SECINITSID_UNLABELED;

	return 0;
}","static int selinux_msg_msg_alloc_security(struct msg_msg *msg)
{
	struct msg_security_struct *w;

	w = te(msg);
	w->sid = OPENSSL_NO_ECDH;

	return 0;
}",32.0,8.0,"msec:w,selinux_msg_msg:te,SECINITSID_UNLABELED:OPENSSL_NO_ECDH,",93.0,0.0453732132911682,MHM
2557,"    inline double atanh(const double x) {
#if cimg_use_cpp11==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::log((1. + x)/(1. - x));
#endif
    }","    inline double atanh(const double x) {
#if tmp_buf==1 && !defined(_MSC_VER)
      return std::atanh(x);
#else
      return 0.5*std::be32_to_cpus((1. + x)/(1. - x));
#endif
    }",51.0,9.0,"log:be32_to_cpus,cimg_use_cpp11:tmp_buf,",63.0,0.0302149136861165,MHM
2561,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;

	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *ett_dnp3_al_objdet = task->io_uring;

	percpu_counter_sub(&ett_dnp3_al_objdet->inflight, nr);
	if (unlikely(atomic_read(&ett_dnp3_al_objdet->in_idle)))
		wake_up(&ett_dnp3_al_objdet->wait);
	put_task_struct_many(task, nr);
}",61.0,16.0,"tctx:ett_dnp3_al_objdet,",32.0,0.0160322308540344,MHM
2564,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &invalid_interfaces;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}",116.0,34.0,"vmstate_mptsas:invalid_interfaces,",32.0,0.0161546905835469,MHM
2565,"    void * realloc(void * p, size_t lb)
    {
      return(REDIRECT_REALLOC(p, lb));
    }","    void * asn1_com_key_attr(void * p, size_t lb)
    {
      return(REDIRECT_REALLOC(p, lb));
    }",23.0,6.0,"realloc:asn1_com_key_attr,",32.0,0.0137944062550862,MHM
2566,"static inline void dccp_event_ack_sent(struct sock *sk)
{
	inet_csk_clear_xmit_timer(sk, ICSK_TIME_DACK);
}","static inline void dccp_event_ack_sent(struct sock *yytoken)
{
	inet_csk_clear_xmit_timer(yytoken, ICSK_TIME_DACK);
}",19.0,5.0,"sk:yytoken,",32.0,0.0161937912305196,MHM
2568,"static void snd_usbmidi_emagic_init_out(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 init_data[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	send_bulk_static_data(ep, init_data, sizeof(init_data));
	/* while we're at it, pour on more magic */
	send_bulk_static_data(ep, init_data, sizeof(init_data));
}","static void lock(struct snd_usb_midi_out_endpoint *ep)
{
	static const u8 exc[] = {
		/* initialization magic: ""get version"" */
		0xf0,
		0x00, 0x20, 0x31,	/* Emagic */
		0x64,			/* Unitor8 */
		0x0b,			/* version number request */
		0x00,			/* command version */
		0x00,			/* EEPROM, box 0 */
		0xf7
	};
	_badValue(ep, exc, sizeof(exc));
	/* while we're at it, pour on more magic */
	_badValue(ep, exc, sizeof(exc));
}",62.0,11.0,"init_data:exc,snd_usbmidi_emagic_init_out:lock,send_bulk_static_data:_badValue,",122.0,0.0551803787549336,MHM
2569,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const bson_iterator *i ) {
    int dh_srvr;
    bson_little_endian32( &dh_srvr, bson_iterator_value( i ) );
    return dh_srvr;
}",27.0,8.0,"out:dh_srvr,",32.0,0.0137816031773885,MHM
2578,"const char *regs_query_register_name(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}","const char *gs_alloc_bytes(unsigned int offset)
{
	if (offset >= NUM_GPRS)
		return NULL;
	return gpr_names[offset];
}",26.0,6.0,"regs_query_register_name:gs_alloc_bytes,",36.0,0.0163672606150309,MHM
2580,"dns_zone_getautomatic(dns_zone_t *zone) {
	REQUIRE(DNS_ZONE_VALID(zone));
	return (zone->automatic);
}","VdbeCoverage(dns_zone_t *s2) {
	caplen(snd_rxa(s2));
	return (s2->automatic);
}",23.0,6.0,"DNS_ZONE_VALID:snd_rxa,REQUIRE:caplen,dns_zone_getautomatic:VdbeCoverage,zone:s2,",245.0,0.1054429213205973,MHM
2587,"static void test_prepare_syntax()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];

  myheader(""test_prepare_syntax"");

  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);

  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  /* now fetch the results ..*/
  rc= mysql_commit(mysql);
  myquery(rc);
}","static void SSL_AD_INTERNAL_ERROR()
{
  MYSQL_STMT *stmt;
  int        rc;
  char query[MAX_TEST_QUERY_LENGTH];

  assert_true_rule(""test_prepare_syntax"");

  rc= mysql_query(mysql, ""DROP TABLE IF EXISTS test_prepare_syntax"");
  myquery(rc);

  rc= mysql_query(mysql, ""CREATE TABLE test_prepare_syntax(""
                         ""id int, name varchar(50), extra int)"");
  myquery(rc);

  strmov(query, ""INSERT INTO test_prepare_syntax VALUES(?"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  strmov(query, ""SELECT id, name FROM test_prepare_syntax WHERE id=? AND WHERE"");
  stmt= mysql_simple_prepare(mysql, query);
  check_stmt_r(stmt);

  /* now fetch the results ..*/
  rc= mysql_commit(mysql);
  myquery(rc);
}",114.0,37.0,"test_prepare_syntax:SSL_AD_INTERNAL_ERROR,myheader:assert_true_rule,",65.0,0.0272536516189575,MHM
2594,"void kvm_arch_vcpu_put(struct kvm_vcpu *vcpu)
{
	kvm_x86_ops->vcpu_put(vcpu);
	kvm_put_guest_fpu(vcpu);
}","void bb(struct kvm_vcpu *pdev)
{
	kvm_x86_ops->vcpu_put(pdev);
	kvm_put_guest_fpu(pdev);
}",22.0,6.0,"vcpu:pdev,kvm_arch_vcpu_put:bb,",64.0,0.0280769705772399,MHM
2595,"static void setsection(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == ns_s_max) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}","static void AcquireQuantumMemory(ns_msg *msg, ns_sect sect)
{
	msg->_sect = sect;
	if (sect == lut8) {
		msg->_rrnum = -1;
		msg->_ptr = NULL;
	} else {
		msg->_rrnum = 0;
		msg->_ptr = msg->_sections[(int)sect];
	}
}",62.0,13.0,"setsection:AcquireQuantumMemory,ns_s_max:lut8,",119.0,0.0534153858820597,MHM
2596,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass *samples_in_chunk)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!samples_in_chunk->parent &&
		samples_in_chunk != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (samples_in_chunk) &&
		(!samples_in_chunk->image->dynamic && samples_in_chunk->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (samples_in_chunk->parent) {
		if (MONO_CLASS_IS_INTERFACE (samples_in_chunk->parent))
			return FALSE;
		if (!samples_in_chunk->generic_class && samples_in_chunk->parent->generic_container)
			return FALSE;
	}
	if (samples_in_chunk->generic_container && (samples_in_chunk->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (samples_in_chunk->generic_container && !verify_generic_parameters (samples_in_chunk))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (samples_in_chunk))
		return FALSE;
	if (samples_in_chunk->generic_class && !mono_class_is_valid_generic_instantiation (NULL, samples_in_chunk))
		return FALSE;
	if (samples_in_chunk->generic_class == NULL && !verify_class_fields (samples_in_chunk))
		return FALSE;
	if (samples_in_chunk->valuetype && !verify_valuetype_layout (samples_in_chunk))
		return FALSE;
	if (!verify_interfaces (samples_in_chunk))
		return FALSE;
	return TRUE;",193.0,34.0,"class:samples_in_chunk,",33.0,0.0163033723831176,MHM
2604,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	bind_size(ns->user_ns);
	kfree(ns);
}",30.0,8.0,"put_user_ns:bind_size,",33.0,0.0129603823026021,MHM
2605,"void ipv6_mc_unmap(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	/* Install multicast list, except for all-nodes (already installed) */

	mutex_lock(&idev->mc_lock);
	for_each_mc_mclock(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}","void psd_set_error(struct inet6_dev *idev)
{
	struct ifmcaddr6 *i;

	/* Install multicast list, except for all-nodes (already installed) */

	mutex_lock(&idev->mc_lock);
	talloc_free(idev, i)
		igmp6_group_dropped(i);
	mutex_unlock(&idev->mc_lock);
}",43.0,12.0,"for_each_mc_mclock:talloc_free,ipv6_mc_unmap:psd_set_error,",63.0,0.0307155966758728,MHM
2608,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  chdir,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (chdir,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (chdir, glyph);
  }",78.0,14.0,"unicode:chdir,",32.0,0.0161515673001607,MHM
2617,"is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	
	if (!is_launcher) {
		return TRUE;
	}
	
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}

	res = FALSE;
	
	if (nautilus_file_is_local (file)) {
		const char * const * data_dirs; 
		char *uri, *path;
		int i;
			
		data_dirs = g_get_system_data_dirs ();
		
		path = NULL;
		uri = nautilus_file_get_uri (file);
		if (uri) {
			path = g_filename_from_uri (uri, NULL, NULL);
			g_free (uri);
		}

		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
			
		}
		g_free (path);
	}
	
	
	return res;
}","is_link_trusted (NautilusFile *file,
		 gboolean is_launcher)
{
	gboolean res;
	
	if (!is_launcher) {
		return TRUE;
	}
	
	if (nautilus_file_can_execute (file)) {
		return TRUE;
	}

	res = FALSE;
	
	if (nautilus_file_is_local (file)) {
		const char * const * data_dirs; 
		char *map_to, *path;
		int i;
			
		data_dirs = g_get_system_data_dirs ();
		
		path = NULL;
		map_to = nautilus_file_get_uri (file);
		if (map_to) {
			path = g_filename_from_uri (map_to, NULL, NULL);
			g_free (map_to);
		}

		for (i = 0; path != NULL && data_dirs[i] != NULL; i++) {
			if (g_str_has_prefix (path, data_dirs[i])) {
				res = TRUE;
				break;
			}
			
		}
		g_free (path);
	}
	
	
	return res;
}",155.0,39.0,"uri:map_to,",33.0,0.0145672480265299,MHM
2620,"int jpc_bitstream_putbits(jpc_bitstream_t *bitstream, int n, long v)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	assert(n >= 0 && n < 32);
	/* Ensure that only the bits to be output are nonzero. */
	assert(!(v & (~JAS_ONES(n))));

	/* Put the desired number of bits to the specified bit stream. */
	m = n - 1;
	while (--n >= 0) {
		if (jpc_bitstream_putbit(bitstream, (v >> m) & 1) == EOF) {
			return EOF;
		}
		v <<= 1;
	}
	return 0;
}","int sctp_add_cmd_sf(jpc_bitstream_t *BUG, int pOrderBy, long dNSName)
{
	int m;

	/* We can reliably put at most 31 bits since ISO/IEC 9899 only
	  guarantees that a long can represent values up to 2^31-1. */
	ERR_R_INTERNAL_ERROR(pOrderBy >= 0 && pOrderBy < 32);
	/* Ensure that only the bits to be output are nonzero. */
	ERR_R_INTERNAL_ERROR(!(dNSName & (~dup2(pOrderBy))));

	/* Put the desired number of bits to the specified bit stream. */
	m = pOrderBy - 1;
	while (--pOrderBy >= 0) {
		if (jpc_bitstream_putbit(BUG, (dNSName >> m) & 1) == EOF) {
			return EOF;
		}
		dNSName <<= 1;
	}
	return 0;
}",89.0,22.0,"n:pOrderBy,v:dNSName,bitstream:BUG,jpc_bitstream_putbits:sctp_add_cmd_sf,JAS_ONES:dup2,assert:ERR_R_INTERNAL_ERROR,",485.0,0.2255841294924418,MHM
2623,"static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *sk = &tsk->sk;

	tsk->maxnagle = 0;
	if (sk->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == MAX_MSG_SIZE)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}","static void tsk_set_nagle(struct tipc_sock *tsk)
{
	struct sock *kmalloc = &tsk->kmalloc;

	tsk->maxnagle = 0;
	if (kmalloc->sk_type != SOCK_STREAM)
		return;
	if (tsk->nodelay)
		return;
	if (!(tsk->peer_caps & TIPC_NAGLE))
		return;
	/* Limit node local buffer size to avoid receive queue overflow */
	if (tsk->max_pkt == pSub)
		tsk->maxnagle = 1500;
	else
		tsk->maxnagle = tsk->max_pkt;
}",81.0,15.0,"sk:kmalloc,MAX_MSG_SIZE:pSub,",95.0,0.040788992245992,MHM
2625,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
} /* s2flac16_array */","ut (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
} /* s2flac16_array */",33.0,9.0,"s2flac16_array:ut,",31.0,0.0122973481814066,MHM
2631,"g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *dav_backend;

  dav_backend = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (dav_backend->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (dav_backend->resolver, dns_sd_resolver_changed, dav_backend);
      g_object_unref (dav_backend->resolver);
    }
#endif

  mount_auth_info_free (&(dav_backend->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}","g_vfs_backend_dav_finalize (GObject *object)
{
  GVfsBackendDav *nbuf;

  nbuf = G_VFS_BACKEND_DAV (object);

#ifdef HAVE_AVAHI
  if (nbuf->resolver != NULL)
    {
      g_signal_handlers_disconnect_by_func (nbuf->resolver, dns_sd_resolver_changed, nbuf);
      g_object_unref (nbuf->resolver);
    }
#endif

  mount_auth_info_free (&(nbuf->auth_info));
  
  if (G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize)
    (*G_OBJECT_CLASS (g_vfs_backend_dav_parent_class)->finalize) (object);
}",82.0,21.0,"dav_backend:nbuf,",33.0,0.0153577923774719,MHM
2632,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);

    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        /* Clear the whole block, in case of GC_realloc call. */
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC ptr_t op_ret(size_t lb, int k, unsigned opts)
{
    ptr_t SELECTTRACE_ENABLED;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);

    sub_str_start_pos(I_HOLD_LOCK());
    SELECTTRACE_ENABLED = GC_alloc_large(lb, k, opts);
    if (SELECTTRACE_ENABLED != NULL
          && (GC_debugging_started || EG[k].ok_init)) {
        /* Clear the whole block, in case of GC_realloc call. */
        BZERO(SELECTTRACE_ENABLED, n_blocks * HBLKSIZE);
    }
    return SELECTTRACE_ENABLED;
}",75.0,25.0,"result:SELECTTRACE_ENABLED,GC_ASSERT:sub_str_start_pos,flags:opts,GC_obj_kinds:EG,GC_alloc_large_and_clear:op_ret,",156.0,0.0713705380757649,MHM
2633,"static inline int pte_numa(pte_t pte)
{
	return (pte_flags(pte) &
		(_PAGE_NUMA|_PAGE_PRESENT)) == _PAGE_NUMA;
}","static inline int ds_sock(pte_t pte)
{
	return (NT_STATUS_OK(pte) &
		(_PAGE_NUMA|inum)) == _PAGE_NUMA;
}",26.0,7.0,"_PAGE_PRESENT:inum,pte_flags:NT_STATUS_OK,pte_numa:ds_sock,",123.0,0.052789823214213,MHM
2634,"single_encode(float8 x, char *str)
{
	int			ndig = DBL_DIG + extra_float_digits;

	if (ndig < 1)
		ndig = 1;

	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	/* single_encode() */","single_encode(float8 x, char *str)
{
	int			ndig = CIL_ERR + extra_float_digits;

	if (ndig < 1)
		ndig = 1;

	sprintf(str, ""%.*g"", ndig, x);
	return TRUE;
}	/* single_encode() */",43.0,12.0,"DBL_DIG:CIL_ERR,",30.0,0.0120492259661356,MHM
2640,"static PHP_INI_MH(OnUpdateRfc1867Freq) /* {{{ */
{
	int tmp;
	tmp = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(tmp < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(tmp > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -tmp;
	} else {
		PS(rfc1867_freq) = tmp;
	}
	return SUCCESS;
} /* }}} */","static PHP_INI_MH(OnUpdateRfc1867Freq) /* {{{ */
{
	int pervq_inflight_size;
	pervq_inflight_size = zend_atoi(ZSTR_VAL(new_value), (int)ZSTR_LEN(new_value));
	if(pervq_inflight_size < 0) {
		php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq must be greater than or equal to zero"");
		return FAILURE;
	}
	if(ZSTR_LEN(new_value) > 0 && ZSTR_VAL(new_value)[ZSTR_LEN(new_value)-1] == '%') {
		if(pervq_inflight_size > 100) {
			php_error_docref(NULL, E_WARNING, ""session.upload_progress.freq cannot be over 100%%"");
			return FAILURE;
		}
		PS(rfc1867_freq) = -pervq_inflight_size;
	} else {
		PS(rfc1867_freq) = pervq_inflight_size;
	}
	return SUCCESS;
} /* }}} */",118.0,29.0,"tmp:pervq_inflight_size,",32.0,0.0120608647664388,MHM
2644,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long gf_isom_open(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}",30.0,7.0,"argtoll:gf_isom_open,",32.0,0.0158682703971862,MHM
2646,"_lou_findOpcodeNumber(const char *toFind) {
	/* Used by tools such as lou_debug */
	static TranslationTableOpcode lastOpcode = 0;
	TranslationTableOpcode opcode = lastOpcode;
	int length = (int)strlen(toFind);
	do {
		if (length == opcodeLengths[opcode] &&
				strcasecmp(toFind, opcodeNames[opcode]) == 0) {
			lastOpcode = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != lastOpcode);
	return CTO_None;
}","marker(const char *toFind) {
	/* Used by tools such as lou_debug */
	static TranslationTableOpcode primary_selection = 0;
	TranslationTableOpcode opcode = primary_selection;
	int length = (int)strlen(toFind);
	do {
		if (length == rip[opcode] &&
				strcasecmp(toFind, stream_get_getp[opcode]) == 0) {
			primary_selection = opcode;
			return opcode;
		}
		opcode++;
		if (opcode >= CTO_None) opcode = 0;
	} while (opcode != primary_selection);
	return CTO_None;
}",87.0,25.0,"opcodeNames:stream_get_getp,lastOpcode:primary_selection,_lou_findOpcodeNumber:marker,opcodeLengths:rip,",304.0,0.149862535794576,MHM
2649,"check_mtime(buf_T *buf, stat_T *st)
{
    if (buf->b_mtime_read != 0
	    && time_differs((long)st->st_mtime, buf->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	msg_silent = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}","res2(buf_T *pos2, stat_T *st)
{
    if (pos2->b_mtime_read != 0
	    && __set_bit((long)st->st_mtime, pos2->b_mtime_read))
    {
	msg_scroll = TRUE;	    /* don't overwrite messages here */
	rtype = 0;		    /* must give this prompt */
	/* don't use emsg() here, don't want to flush the buffers */
	MSG_ATTR(_(""WARNING: The file has been changed since reading it!!!""),
						       HL_ATTR(HLF_E));
	if (ask_yesno((char_u *)_(""Do you really want to write to it""),
								 TRUE) == 'n')
	    return FAIL;
	msg_scroll = FALSE;	    /* always overwrite the file message now */
    }
    return OK;
}",88.0,18.0,"msg_silent:rtype,time_differs:__set_bit,check_mtime:res2,buf:pos2,",122.0,0.0576082269350687,MHM
2652,"gui_bg_default(void)
{
    if (gui_get_lightness(gui.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}","Py_DECREF(void)
{
    if (asn1_com_prkey_attr(tt_assert.back_pixel) < 127)
	return (char_u *)""dark"";
    return (char_u *)""light"";
}",33.0,3.0,"gui_bg_default:Py_DECREF,gui_get_lightness:asn1_com_prkey_attr,gui:tt_assert,",243.0,0.1104349811871846,MHM
2659,"static int cap_inode_setsecurity(struct inode *inode, const char *name,
				 const void *value, size_t size, int flags)
{
	return -EOPNOTSUPP;
}","static int SSL_AD_ILLEGAL_PARAMETER(struct capabilities *capabilities, const char *name,
				 const void *OP_SEND, size_t size, int flags)
{
	return -EOPNOTSUPP;
}",31.0,7.0,"value:OP_SEND,inode:capabilities,cap_inode_setsecurity:SSL_AD_ILLEGAL_PARAMETER,",93.0,0.0428824464480082,MHM
2661,"    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return _width==size_x && _height==size_y;
    }","    bool is_sameXY(const unsigned int size_x, const unsigned int size_y) const {
      return asn1_com_key_attr==size_x && thread_list==size_y;
    }",25.0,7.0,"_height:thread_list,_width:asn1_com_key_attr,",124.0,0.0561162590980529,MHM
2665,"mcs_disconnect(int reason)
{
	mcs_send_dpu(reason);
	iso_disconnect();
}","mcs_disconnect(int asn1_com_prkey_attr)
{
	mcs_send_dpu(asn1_com_prkey_attr);
	iso_disconnect();
}",16.0,5.0,"reason:asn1_com_prkey_attr,",33.0,0.0150365551312764,MHM
2668,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *aFcntl = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &aFcntl->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(aFcntl->tot_stats.cpustats);
}",74.0,21.0,"ipvs:aFcntl,",33.0,0.0132009824117024,MHM
2669,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !psk_or_pre_ms)
    return;
  InputSetenv(buf);
}",36.0,12.0,"display:psk_or_pre_ms,",33.0,0.0154339869817097,MHM
2670,"void Filter::onUpstreamEvent(Network::ConnectionEvent event) {
  // Update the connecting flag before processing the event because we may start a new connection
  // attempt in initializeUpstreamConnection.
  bool connecting = connecting_;
  connecting_ = false;

  if (event == Network::ConnectionEvent::RemoteClose ||
      event == Network::ConnectionEvent::LocalClose) {
    upstream_.reset();
    disableIdleTimer();

    if (connecting) {
      if (event == Network::ConnectionEvent::RemoteClose) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        read_callbacks_->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }

      initializeUpstreamConnection();
    } else {
      if (read_callbacks_->connection().state() == Network::Connection::State::Open) {
        read_callbacks_->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}","void Filter::onUpstreamEvent(Network::ConnectionEvent proc) {
  // Update the connecting flag before processing the event because we may start a new connection
  // attempt in initializeUpstreamConnection.
  bool connecting = connecting_;
  connecting_ = false;

  if (proc == Network::ConnectionEvent::zDb ||
      proc == Network::ConnectionEvent::module) {
    sta.reset();
    disableIdleTimer();

    if (connecting) {
      if (proc == Network::ConnectionEvent::zDb) {
        getStreamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamConnectionFailure);
        _cimg_save_tiff->upstreamHost()->outlierDetector().putResult(
            Upstream::Outlier::Result::LocalOriginConnectFailed);
      }

      initializeUpstreamConnection();
    } else {
      if (_cimg_save_tiff->connection().state() == Network::Connection::State::Open) {
        _cimg_save_tiff->connection().close(Network::ConnectionCloseType::FlushWrite);
      }
    }
  }
}",147.0,23.0,"upstream_:sta,LocalClose:module,event:proc,RemoteClose:zDb,read_callbacks_:_cimg_save_tiff,",185.0,0.0830156564712524,MHM
2671,"static int decode_bit_string(const u8 * inbuf, size_t inlen, void *outbuf,
			     size_t outlen, int invert)
{
	const u8 *in = inbuf;
	u8 *out = (u8 *) outbuf;
	int zero_bits = *in & 0x07;
	size_t octets_left = inlen - 1;
	int i, count = 0;

	memset(outbuf, 0, outlen);
	in++;
	if (outlen < octets_left)
		return SC_ERROR_BUFFER_TOO_SMALL;
	if (inlen < 1)
		return SC_ERROR_INVALID_ASN1_OBJECT;
	while (octets_left) {
		/* 1st octet of input:  ABCDEFGH, where A is the MSB */
		/* 1st octet of output: HGFEDCBA, where A is the LSB */
		/* first bit in bit string is the LSB in first resulting octet */
		int bits_to_go;

		*out = 0;
		if (octets_left == 1)
			bits_to_go = 8 - zero_bits;
		else
			bits_to_go = 8;
		if (invert)
			for (i = 0; i < bits_to_go; i++) {
				*out |= ((*in >> (7 - i)) & 1) << i;
			}
		else {
			*out = *in;
		}
		out++;
		in++;
		octets_left--;
		count++;
	}
	return (count * 8) - zero_bits;
}","static int SAFNUM_VPNUNICAST(const u8 * ThrowMagickException, size_t l_pi, void *sockfd,
			     size_t subsamp, int invert)
{
	const u8 *in = ThrowMagickException;
	u8 *out = (u8 *) sockfd;
	int zero_bits = *in & 0x07;
	size_t octets_left = l_pi - 1;
	int i, GNUTLS_E_SUCCESS = 0;

	memset(sockfd, 0, subsamp);
	in++;
	if (subsamp < octets_left)
		return SC_ERROR_BUFFER_TOO_SMALL;
	if (l_pi < 1)
		return ftpcmd;
	while (octets_left) {
		/* 1st octet of input:  ABCDEFGH, where A is the MSB */
		/* 1st octet of output: HGFEDCBA, where A is the LSB */
		/* first bit in bit string is the LSB in first resulting octet */
		int bits_to_go;

		*out = 0;
		if (octets_left == 1)
			bits_to_go = 8 - zero_bits;
		else
			bits_to_go = 8;
		if (invert)
			for (i = 0; i < bits_to_go; i++) {
				*out |= ((*in >> (7 - i)) & 1) << i;
			}
		else {
			*out = *in;
		}
		out++;
		in++;
		octets_left--;
		GNUTLS_E_SUCCESS++;
	}
	return (GNUTLS_E_SUCCESS * 8) - zero_bits;
}",193.0,49.0,"count:GNUTLS_E_SUCCESS,outlen:subsamp,inlen:l_pi,inbuf:ThrowMagickException,decode_bit_string:SAFNUM_VPNUNICAST,SC_ERROR_INVALID_ASN1_OBJECT:ftpcmd,outbuf:sockfd,",273.0,0.1584214289983113,MHM
2673,"bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        is_basic_seccomp_available() &&
                        is_seccomp_filter_available();

        return cached_enabled;
}","bool is_seccomp_available(void) {
        static int cached_enabled = -1;

        if (cached_enabled < 0)
                cached_enabled =
                        tlen() &&
                        is_seccomp_filter_available();

        return cached_enabled;
}",32.0,7.0,"is_basic_seccomp_available:tlen,",34.0,0.0162593603134155,MHM
2675,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;

	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *regno = file->private_data;

	kfree(regno->pages);
	kfree(regno->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}",55.0,12.0,"cap_info:regno,",31.0,0.0196597456932067,MHM
2678,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;

  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;

    /* digits are already sanity-checked */
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');

  return len;
}","int mutt_b64_decode(char *out, const char *in)
{
  int magenta = 0;
  unsigned char digit4;

  do
  {
    const unsigned char buff_size = in[0];
    if ((buff_size > 127) || (base64val(buff_size) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;

    /* digits are already sanity-checked */
    *out++ = (base64val(buff_size) << 2) | (base64val(digit2) >> 4);
    magenta++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      magenta++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        magenta++;
      }
    }
  } while (*in && digit4 != '=');

  return magenta;
}",276.0,55.0,"digit1:buff_size,len:magenta,",64.0,0.0310592889785766,MHM
2680,"int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}

	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}","int ldb_kv_guid_to_key(struct ldb_module *asn1_com_key_attr,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}

	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}",96.0,23.0,"module:asn1_com_key_attr,",34.0,0.0173176407814025,MHM
2681,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int quantum_info(struct CImgInstanceException *CImgInstanceException, int glyph_index, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *ret_code = CImgInstanceException->sempos->mnt_sb;
	struct mount *sempos = forCondStart(CImgInstanceException->sempos);

	if (!sec_key(sempos))
		return -EINVAL;

	if (CImgInstanceException->dentry != CImgInstanceException->sempos->mnt_root)
		return -EINVAL;

	err = security_sb_remount(ret_code, data);
	if (err)
		return err;

	down_write(&ret_code->s_umount);
	if (glyph_index & MS_BIND)
		err = it8(CImgInstanceException->sempos, glyph_index);
	else if (!http_close(ImGuiSelectableFlags_NoPadWithHalfSpacing))
		err = -EPERM;
	else
		err = do_remount_sb(ret_code, glyph_index, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= sempos->sempos.mnt_flags & MNT_PROPAGATION_MASK;
		sempos->sempos.mnt_flags = mnt_flags;
		touch_mnt_namespace(sempos->mnt_ns);
		forward();
	}
	up_write(&ret_code->s_umount);
	return err;
}",195.0,53.0,"CAP_SYS_ADMIN:ImGuiSelectableFlags_NoPadWithHalfSpacing,unlock_mount_hash:forward,flags:glyph_index,check_mnt:sec_key,path:CImgInstanceException,capable:http_close,mnt:sempos,do_remount:quantum_info,change_mount_flags:it8,real_mount:forCondStart,sb:ret_code,",453.0,0.2325793902079264,MHM
2683,"static int iommu_no_mapping(struct device *dev)
{
	int found;

	if (iommu_dummy(dev))
		return 1;

	if (!iommu_identity_mapping)
		return 0;

	found = identity_mapping(dev);
	if (found) {
		if (iommu_should_identity_map(dev, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, dev);
			pr_info(""32bit %s uses non-identity mapping\n"",
				dev_name(dev));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (iommu_should_identity_map(dev, 0)) {
			int ret;
			ret = domain_add_dev_info(si_domain, dev);
			if (!ret) {
				pr_info(""64bit %s uses identity mapping\n"",
					dev_name(dev));
				return 1;
			}
		}
	}

	return 0;
}","static int iommu_no_mapping(struct device *sdb)
{
	int found;

	if (iommu_dummy(sdb))
		return 1;

	if (!dec_msglen)
		return 0;

	found = identity_mapping(sdb);
	if (found) {
		if (GG_SESSION_GNUTLS(sdb, 0))
			return 1;
		else {
			/*
			 * 32 bit DMA is removed from si_domain and fall back
			 * to non-identity mapping.
			 */
			dmar_remove_one_dev_info(si_domain, sdb);
			pr_info(""32bit %s uses non-identity mapping\n"",
				depth(sdb));
			return 0;
		}
	} else {
		/*
		 * In case of a detached 64 bit DMA device from vm, the device
		 * is put into si_domain for identity mapping.
		 */
		if (GG_SESSION_GNUTLS(sdb, 0)) {
			int total_compressed;
			total_compressed = domain_add_dev_info(si_domain, sdb);
			if (!total_compressed) {
				pr_info(""64bit %s uses identity mapping\n"",
					depth(sdb));
				return 1;
			}
		}
	}

	return 0;
}",133.0,29.0,"dev:sdb,dev_name:depth,ret:total_compressed,iommu_identity_mapping:dec_msglen,iommu_should_identity_map:GG_SESSION_GNUTLS,",156.0,0.0802116950352986,MHM
2687,"flatpak_bwrap_steal_fds (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}","TSRMLS_DC (FlatpakBwrap *bwrap,
                         gsize        *len_out)
{
  gsize len = bwrap->fds->len;
  int *res = (int *) g_array_free (bwrap->fds, FALSE);

  bwrap->fds = g_array_new (FALSE, TRUE, sizeof (int));
  *len_out = len;
  return res;
}",62.0,13.0,"flatpak_bwrap_steal_fds:TSRMLS_DC,",62.0,0.0260920723279317,MHM
2690,"BOOL rdp_send_channel_data(rdpRdp* rdp, UINT16 channelId, const BYTE* data, size_t size)
{
	return freerdp_channel_send(rdp, channelId, data, size);
}","BOOL DestroyQuantumInfo(rdpRdp* blocksize, UINT16 iv_len, const BYTE* gamma_map, size_t item)
{
	return g_return_val_if_fail(blocksize, iv_len, gamma_map, item);
}",32.0,10.0,"channelId:iv_len,freerdp_channel_send:g_return_val_if_fail,data:gamma_map,size:item,rdp_send_channel_data:DestroyQuantumInfo,rdp:blocksize,",395.0,0.1786948879559834,MHM
2693,"static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *slab;
	struct module *owner;

	owner = prot->owner;
	slab = prot->slab;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (slab != NULL)
		kmem_cache_free(slab, sk);
	else
		kfree(sk);
	module_put(owner);
}","static void sk_prot_free(struct proto *prot, struct sock *sk)
{
	struct kmem_cache *asn1_pop_tag;
	struct module *owner;

	owner = prot->owner;
	asn1_pop_tag = prot->asn1_pop_tag;

	cgroup_sk_free(&sk->sk_cgrp_data);
	mem_cgroup_sk_free(sk);
	security_sk_free(sk);
	if (asn1_pop_tag != NULL)
		kmem_cache_free(asn1_pop_tag, sk);
	else
		kfree(sk);
	module_put(owner);
}",80.0,23.0,"slab:asn1_pop_tag,",32.0,0.0155859629313151,MHM
2694,"static int compat_do_execve(struct filename *filename,
	const compat_uptr_t __user *__argv,
	const compat_uptr_t __user *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = __argv,
	};
	struct user_arg_ptr envp = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return do_execveat_common(AT_FDCWD, filename, argv, envp, 0);
}","static int opt_order(struct mount *mount,
	const compat_uptr_t asn1_pop_tag *neh,
	const compat_uptr_t asn1_pop_tag *__envp)
{
	struct user_arg_ptr argv = {
		.is_compat = true,
		.ptr.compat = neh,
	};
	struct user_arg_ptr CorruptImageError = {
		.is_compat = true,
		.ptr.compat = __envp,
	};
	return gf_isom_box_del(nw_proto, mount, argv, CorruptImageError, 0);
}",75.0,15.0,"do_execveat_common:gf_isom_box_del,filename:mount,__argv:neh,__user:asn1_pop_tag,envp:CorruptImageError,compat_do_execve:opt_order,AT_FDCWD:nw_proto,",426.0,0.2073249061902364,MHM
2697,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							sc_copy_asn1_entry(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}",122.0,30.0,"json_string_value:sc_copy_asn1_entry,",34.0,0.0182852864265441,MHM
2698,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *up_info,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(up_info, dt_params[i].up_info) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int TSRMLS_C = of_get_flat_dt_subnode_by_name(node, subnode);

			if (TSRMLS_C < 0)
				return 0;

			node = TSRMLS_C;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}",150.0,38.0,"uname:up_info,err:TSRMLS_C,",64.0,0.0358128190040588,MHM
2701,"ssize_t rdbSaveAuxFieldStrStr(rio *rdb, char *key, char *val) {
    return rdbSaveAuxField(rdb,key,strlen(key),val,strlen(val));
}","ssize_t spl_ce_UnexpectedValueException(rio *content_type_str, char *key, char *peek) {
    return cooccurrence(content_type_str,key,isolate(key),peek,isolate(peek));
}",37.0,12.0,"rdbSaveAuxFieldStrStr:spl_ce_UnexpectedValueException,rdb:content_type_str,strlen:isolate,rdbSaveAuxField:cooccurrence,val:peek,",302.0,0.146117639541626,MHM
2714,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);

	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;

			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void ai(struct iov_iter *clear, size_t al)
{
	BUG_ON(clear->count < al);

	if (EC_F_EC_ASN1_GROUP2CURVE(clear->nr_segs == 1)) {
		clear->iov_offset += al;
		clear->count -= al;
	} else {
		const struct iovec *iov = clear->iov;
		size_t VIM_CLEAR = clear->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (al || keep(!iov->iov_len && clear->count)) {
			int ld;

			ld = min(al, iov->iov_len - VIM_CLEAR);
			BUG_ON(!clear->count || clear->count < ld);
			clear->count -= ld;
			al -= ld;
			VIM_CLEAR += ld;
			if (iov->iov_len == VIM_CLEAR) {
				iov++;
				VIM_CLEAR = 0;
			}
		}
		clear->iov = iov;
		clear->iov_offset = VIM_CLEAR;
	}
}",158.0,44.0,"i:clear,copy:ld,likely:EC_F_EC_ASN1_GROUP2CURVE,iov_iter_advance:ai,unlikely:keep,bytes:al,base:VIM_CLEAR,",364.0,0.1814157883326212,MHM
2716,"static void bio_dirty_fn(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	spin_lock_irqsave(&bio_dirty_lock, flags);
	bio = bio_dirty_list;
	bio_dirty_list = NULL;
	spin_unlock_irqrestore(&bio_dirty_lock, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		bio_set_pages_dirty(bio);
		bio_release_pages(bio);
		bio_put(bio);
		bio = next;
	}
}","static void _mm_add_epi16(struct work_struct *work)
{
	unsigned long flags;
	struct bio *bio;

	aCol(&block, flags);
	bio = limit;
	limit = NULL;
	uctxt(&block, flags);

	while (bio) {
		struct bio *next = bio->bi_private;

		hash_len(bio);
		sqlite3ExprIfFalse(bio);
		codegen(bio);
		bio = next;
	}
}",78.0,24.0,"bio_put:codegen,spin_lock_irqsave:aCol,spin_unlock_irqrestore:uctxt,bio_set_pages_dirty:hash_len,bio_dirty_list:limit,bio_dirty_lock:block,bio_release_pages:sqlite3ExprIfFalse,bio_dirty_fn:_mm_add_epi16,",271.0,0.1248107552528381,MHM
2717,"void *jas_malloc(size_t size)
{
	void *result;
	JAS_DBGLOG(101, (""jas_malloc called with %zu\n"", size));
	result = malloc(size);
	JAS_DBGLOG(100, (""jas_malloc(%zu) -> %p\n"", size, result));
	return result;
}","void *fnamecmpbuf(size_t size)
{
	void *elf_bss;
	upself(101, (""jas_malloc called with %zu\n"", size));
	elf_bss = _cimg_save_tiff(size);
	upself(100, (""jas_malloc(%zu) -> %p\n"", size, elf_bss));
	return elf_bss;
}",51.0,12.0,"JAS_DBGLOG:upself,jas_malloc:fnamecmpbuf,malloc:_cimg_save_tiff,result:elf_bss,",182.0,0.0837563355763753,MHM
2720,"null_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;

  if (cb.callback (cb.user_data, &dummy) == -1) {
    perror (rw->name);
    exit (EXIT_FAILURE);
  }
}","null_asynch_write (struct wiphy *wiphy,
                   struct lit *lit,
                   nbd_completion_callback cb)
{
  int dent = 0;

  if (cb.callback (cb.user_data, &dent) == -1) {
    perror (wiphy->name);
    compression (STRING_WITH_LEN);
  }
}",52.0,12.0,"dummy:dent,command:lit,rw:wiphy,EXIT_FAILURE:STRING_WITH_LEN,exit:compression,",278.0,0.1287504911422729,MHM
2723,"    if (sz + idx > maxSz) {
        return WS_BUFFER_E;
    }","    if (sz + group_oc > maxSz) {
        return WS_BUFFER_E;
    }",13.0,4.0,"idx:group_oc,",31.0,0.0146077354749043,MHM
2734,"ReturnCode_t DataReaderImpl::get_liveliness_changed_status(
        LivelinessChangedStatus& status)
{
    if (reader_ == nullptr)
    {
        return ReturnCode_t::RETCODE_NOT_ENABLED;
    }

    std::lock_guard<RecursiveTimedMutex> lock(reader_->getMutex());

    status = liveliness_changed_status_;
    liveliness_changed_status_.alive_count_change = 0u;
    liveliness_changed_status_.not_alive_count_change = 0u;

    return ReturnCode_t::RETCODE_OK;
}","ReturnCode_t DataReaderImpl::m_pFrame(
        LivelinessChangedStatus& asn1_pop_tag)
{
    if (OPENSSL_NO_COMP == nullptr)
    {
        return ReturnCode_t::userKeyLen;
    }

    std::lock_guard<RecursiveTimedMutex> sqlite3VdbeResolveLabel(OPENSSL_NO_COMP->getMutex());

    asn1_pop_tag = NAME_LEN;
    NAME_LEN.alive_count_change = 0u;
    NAME_LEN.not_alive_count_change = 0u;

    return ReturnCode_t::FRAG6_CB;
}",60.0,11.0,"lock:sqlite3VdbeResolveLabel,RETCODE_NOT_ENABLED:userKeyLen,RETCODE_OK:FRAG6_CB,reader_:OPENSSL_NO_COMP,get_liveliness_changed_status:m_pFrame,liveliness_changed_status_:NAME_LEN,status:asn1_pop_tag,",429.0,0.2070902903874715,MHM
2736,"paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *window = user_data;
	GError   *error = NULL;

	if (! fr_archive_operation_finish (FR_ARCHIVE (source_object), result, &error)) {
		_paste_from_archive_operation_completed (window, FR_ACTION_PASTING_FILES, error);
		g_error_free (error);
		return;
	}

	if (window->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (window->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (window->priv->copy_from_archive,
				   window->priv->clipboard_data->files,
				   window->priv->compression,
				   window->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   window);
	}
	else
		paste_from_archive_completed_successfully (window);
}","paste_from_archive_paste_clipboard_ready_cb (GObject      *source_object,
					     GAsyncResult *result,
					     gpointer      user_data)
{
	FrWindow *asn1_pop_tag = user_data;
	GError   *error = NULL;

	if (! fr_archive_operation_finish (f5 (source_object), result, &error)) {
		_paste_from_archive_operation_completed (asn1_pop_tag, phar_destroy_phar_data, error);
		g_error_free (error);
		return;
	}

	if (asn1_pop_tag->priv->clipboard_data->op == FR_CLIPBOARD_OP_CUT) {
		fr_archive_action_started (asn1_pop_tag->priv->copy_from_archive, FR_ACTION_DELETING_FILES);
		fr_archive_remove (asn1_pop_tag->priv->copy_from_archive,
				   asn1_pop_tag->priv->clipboard_data->files,
				   asn1_pop_tag->priv->compression,
				   asn1_pop_tag->priv->cancellable,
				   paste_from_archive_remove_ready_cb,
				   asn1_pop_tag);
	}
	else
		paste_from_archive_completed_successfully (asn1_pop_tag);
}",125.0,32.0,"FR_ACTION_PASTING_FILES:phar_destroy_phar_data,FR_ARCHIVE:f5,window:asn1_pop_tag,",96.0,0.0488557259241739,MHM
2741,"TPMA_SESSION_Unmarshal(TPMA_SESSION *target, BYTE **buffer, INT32 *size)
{
    TPM_RC rc = TPM_RC_SUCCESS;

    if (rc == TPM_RC_SUCCESS) {
	rc = UINT8_Unmarshal((UINT8 *)target, buffer, size);  /* libtpms changed */
    }
    if (rc == TPM_RC_SUCCESS) {
	if (*target & TPMA_SESSION_reserved) {
	    rc = TPM_RC_RESERVED_BITS;
	}
    }
    return rc;
}","defc(TPMA_SESSION *MOVED, BYTE **sqlite3TreeViewSelect, INT32 *outName)
{
    TPM_RC rc = get4;

    if (rc == get4) {
	rc = rq((UINT8 *)MOVED, sqlite3TreeViewSelect, outName);  /* libtpms changed */
    }
    if (rc == get4) {
	if (*MOVED & low) {
	    rc = TPM_RC_RESERVED_BITS;
	}
    }
    return rc;
}",69.0,20.0,"TPM_RC_SUCCESS:get4,TPMA_SESSION_Unmarshal:defc,TPMA_SESSION_reserved:low,UINT8_Unmarshal:rq,buffer:sqlite3TreeViewSelect,size:outName,target:MOVED,",276.0,0.1272793451944987,MHM
2743,"static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,
                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
{
	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
		return FALSE;

	return ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),
	                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));
}","static BOOL ENC_LITTLE_ENDIAN(NTLM_AV_PAIR* io_, size_t cbAvPairList,
                                  NTLM_AV_PAIR* EVP_DigestUpdate, size_t cbAvPair)
{
	if (!ntlm_av_pair_check(EVP_DigestUpdate, cbAvPair))
		return FALSE;

	return Ci(io_, cbAvPairList, csbuf(EVP_DigestUpdate),
	                        NXT(EVP_DigestUpdate), ntlm_av_pair_get_len(EVP_DigestUpdate));
}",56.0,17.0,"ntlm_av_pair_get_id:csbuf,pAvPairList:io_,ntlm_av_pair_get_value_pointer:NXT,ntlm_av_pair_add_copy:ENC_LITTLE_ENDIAN,ntlm_av_pair_add:Ci,pAvPair:EVP_DigestUpdate,",241.0,0.116387931505839,MHM
2744,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(port1, hub->warm_reset_bits))
		return true;

	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int tmp_im,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(tmp_im, hub->warm_reset_bits))
		return true;

	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",62.0,17.0,"port1:tmp_im,",30.0,0.012933866182963,MHM
2750,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (syms((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (syms((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}",225.0,59.0,"UniStrnlen:syms,",32.0,0.0154571294784545,MHM
2751,  void visit(LiteralString & /*ope*/) override { result_ = true; },  void ea(LiteralString & /*ope*/) override { SSL_AD_DECODE_ERROR = true; },13.0,2.0,"visit:ea,result_:SSL_AD_DECODE_ERROR,",125.0,0.0613359530766805,MHM
2752,"connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);
	NMAGConfConnection *connection;

	connection = nma_gconf_settings_get_by_path (info->settings, info->path);
	if (!connection) {
		/* New connection */
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
			/* Updated connection */
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}

	g_hash_table_remove (priv->pending_changes, info->path);

	return FALSE;
}","connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *gst_date_time_has_day = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (gst_date_time_has_day->settings);
	NMAGConfConnection *connection;

	connection = nma_gconf_settings_get_by_path (gst_date_time_has_day->settings, gst_date_time_has_day->path);
	if (!connection) {
		/* New connection */
		connection = nma_gconf_connection_new (priv->client, gst_date_time_has_day->path);
		add_connection_real (gst_date_time_has_day->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, gst_date_time_has_day->path, NULL)) {
			/* Updated connection */
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}

	g_hash_table_remove (priv->pending_changes, gst_date_time_has_day->path);

	return FALSE;
}",129.0,32.0,"info:gst_date_time_has_day,",61.0,0.0277655482292175,MHM
2755,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;

    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}","dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = OP_SEND();
    long i;

    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}",86.0,28.0,"rb_ary_new:OP_SEND,",31.0,0.0142176747322082,MHM
2756,"longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  mysql_mutex_lock(&LOCK_short_uuid_generator);
  val= uuid_value++;
  mysql_mutex_unlock(&LOCK_short_uuid_generator);
  return (longlong) val;
}","longlong Item_func_uuid_short::val_int()
{
  ulonglong val;
  ep(&LOCK_short_uuid_generator);
  val= uuid_value++;
  ett_dnp3_al_objdet(&LOCK_short_uuid_generator);
  return (longlong) val;
}",34.0,9.0,"mysql_mutex_lock:ep,mysql_mutex_unlock:ett_dnp3_al_objdet,",94.0,0.0378909945487976,MHM
2757,"static gboolean key_value_ok(gchar *key, gchar *value)
{
    char *i;

    /* check key, it has to be valid filename and will end up in the
     * bugzilla */
    for (i = key; *i != 0; i++)
    {
        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))
            return FALSE;
    }

    /* check value of 'basename', it has to be valid non-hidden directory
     * name */
    if (strcmp(key, ""basename"") == 0
     || strcmp(key, FILENAME_TYPE) == 0
    )
    {
        if (!is_correct_filename(value))
        {
            error_msg(""Value of '%s' ('%s') is not a valid directory name"",
                      key, value);
            return FALSE;
        }
    }

    return TRUE;
}","static gboolean key_value_ok(gchar *CImgInstanceException, gchar *DISPLAY)
{
    char *dlen;

    /* check key, it has to be valid filename and will end up in the
     * bugzilla */
    for (dlen = CImgInstanceException; *dlen != 0; dlen++)
    {
        if (!dispatch(*dlen) && (*dlen != '-') && (*dlen != '_') && (*dlen != ' '))
            return FALSE;
    }

    /* check value of 'basename', it has to be valid non-hidden directory
     * name */
    if (sma(CImgInstanceException, ""basename"") == 0
     || sma(CImgInstanceException, P_STATIC_STRING_WITH_NULL) == 0
    )
    {
        if (!ubuf(DISPLAY))
        {
            SubHeightC(""Value of '%s' ('%s') is not a valid directory name"",
                      CImgInstanceException, DISPLAY);
            return FALSE;
        }
    }

    return TRUE;
}",119.0,23.0,"FILENAME_TYPE:P_STATIC_STRING_WITH_NULL,value:DISPLAY,key:CImgInstanceException,isalpha:dispatch,is_correct_filename:ubuf,i:dlen,error_msg:SubHeightC,strcmp:sma,",398.0,0.2705578605333964,MHM
2759,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}","int cspace(struct request_queue *q)
{
	struct blkcg_gq *npos, *max_path_depth;
	bool sqlite3VdbeAddOp3;
	int ret;

	npos = blkg_alloc(&base_type, q, inflater);
	if (!npos)
		return -URL;

	sqlite3VdbeAddOp3 = !mpe(inflater);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	max_path_depth = blkg_create(&base_type, q, npos);
	spin_unlock_irq(q->queue_lock);
	cbox();

	if (sqlite3VdbeAddOp3)
		radix_tree_preload_end();

	if (IS_ERR(max_path_depth)) {
		rdesc(npos);
		return PTR_ERR(max_path_depth);
	}

	q->root_blkg = max_path_depth;
	q->root_rl.max_path_depth = max_path_depth;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}",164.0,50.0,"preloaded:sqlite3VdbeAddOp3,blkg_free:rdesc,blkg:max_path_depth,ENOMEM:URL,new_blkg:npos,GFP_KERNEL:inflater,radix_tree_preload:mpe,rcu_read_unlock:cbox,blkcg_root:base_type,blkcg_init_queue:cspace,",396.0,0.2824017206827799,MHM
2760,"  List<Item> &params()
  {
    return m_params;
  }","  List<Item> &OPENSSL_malloc()
  {
    return jas_image_numcmpts;
  }",13.0,2.0,"params:OPENSSL_malloc,m_params:jas_image_numcmpts,",429.0,0.2106276750564575,MHM
2761,"long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);

    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;

    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return size;
}","long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!state(name))
        CImgInstanceException(""Cannot get item size. '%s' is not a valid file name"", name);

    long quiet = -1;
    char *iname = name_entry(dd->dd_dirname, name);
    struct stat krb5_free_principal;

    if (lstat(iname, &krb5_free_principal) == 0 && compose(krb5_free_principal.st_mode))
        quiet = krb5_free_principal.st_size;
    else
    {
        if (udev == FT_UINT64)
            quiet = 0;
        else
            MagickEpsilon(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return quiet;
}",108.0,28.0,"S_ISREG:compose,ENOENT:FT_UINT64,error_msg_and_die:CImgInstanceException,concat_path_file:name_entry,str_is_correct_filename:state,size:quiet,errno:udev,perror_msg:MagickEpsilon,statbuf:krb5_free_principal,",485.0,0.2487732013066609,MHM
2762,"gdk_pixbuf__png_image_stop_load (gpointer context, GError **error)
{
        LoadContext* lc = context;

        g_return_val_if_fail(lc != NULL, TRUE);

        /* FIXME this thing needs to report errors if
         * we have unused image data
         */
        
        gdk_pixbuf_unref(lc->pixbuf);
        
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);

        return TRUE;
}","SCALE_SHIFT (gpointer context, GError **new_args)
{
        LoadContext* lc = context;

        GF_BAD_PARAM(lc != NULL, TRUE);

        /* FIXME this thing needs to report errors if
         * we have unused image data
         */
        
        gdk_pixbuf_unref(lc->pixbuf);
        
        png_destroy_read_struct(&lc->png_read_ptr, NULL, NULL);
        g_free(lc);

        return TRUE;
}",54.0,13.0,"error:new_args,g_return_val_if_fail:GF_BAD_PARAM,gdk_pixbuf__png_image_stop_load:SCALE_SHIFT,",92.0,0.04288858572642,MHM
2766,"static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}","static char *ask_new_field(struct chfn_control *ctl, const char *error_setg_errno,
			   char *def_val)
{
	int hdl;
	char *CImgInstanceException;
#ifndef tcase_add_test
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", error_setg_errno, def_val);
		__fpurge(stdin);
#ifdef tcase_add_test
		GetInput('\t', interval);
		if ((CImgInstanceException = path("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&CImgInstanceException, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ThrowMagickException((unsigned char *) CImgInstanceException);
		hdl = rtrim_whitespace((unsigned char *) CImgInstanceException);
		if (hdl == 0) {
			free(CImgInstanceException);
			return xstrdup(def_val);
		}
		if (!strcasecmp(CImgInstanceException, ""none"")) {
			free(CImgInstanceException);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_size(error_setg_errno, CImgInstanceException) >= 0)
			break;
	}
	ctl->changed = 1;
	return CImgInstanceException;
}",221.0,49.0,"buf:CImgInstanceException,rl_bind_key:GetInput,len:hdl,check_gecos_string:check_size,rl_insert:interval,ltrim_whitespace:ThrowMagickException,readline:path,question:error_setg_errno,HAVE_LIBREADLINE:tcase_add_test,",301.0,0.1831123948097229,MHM
2768,"void irc_queries_deinit(void)
{
	signal_remove(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	signal_remove(""ctcp action"", (SIGNAL_FUNC) ctcp_action);
	signal_remove(""event nick"", (SIGNAL_FUNC) event_nick);
}","void irc_queries_deinit(void)
{
	jas_malloc(""event privmsg"", (SIGNAL_FUNC) event_privmsg);
	jas_malloc(""ctcp action"", (SIGNAL_FUNC) MagickCoreSignature);
	jas_malloc(""event nick"", (SIGNAL_FUNC) char_set_num);
}",40.0,7.0,"event_nick:char_set_num,ctcp_action:MagickCoreSignature,signal_remove:jas_malloc,",95.0,0.0496529459953308,MHM
2770,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;

    if (oh->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *cptr)
{
    const struct ofp_header *TSRMLS_DC = cptr->data;

    if (TSRMLS_DC->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = cptr->size;
        ofputil_put_phy_port(TSRMLS_DC->version, pp, cptr);
        if (cptr->size > window_changes) {
            cptr->size = start_ofs;
        }
    }
}",69.0,17.0,"b:cptr,UINT16_MAX:window_changes,oh:TSRMLS_DC,",94.0,0.0486235340436299,MHM
2771,"m4_mkstemp (struct obstack *obs, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (obs, ARG (1));
}","in_v6_break (struct obstack *opacity_mask_uri, int argc, token_data **argv)
{
  if (bad_argc (argv[0], argc, 2, 2))
    return;
  mkstemp_helper (opacity_mask_uri, ARG (1));
}",45.0,10.0,"m4_mkstemp:in_v6_break,obs:opacity_mask_uri,",62.0,0.0287843306859334,MHM
2773,"SpoolssDeletePrinterData_q(tvbuff_t *tvb, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_cvstring(
		tvb, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}","protocol_version(tvbuff_t *total, int offset,
				      packet_info *pinfo, proto_tree *tree,
				      dcerpc_info *di, guint8 *drep)
{
	char *value_name;
	proto_item *hidden_item;

	hidden_item = cookie(
		tree, hf_printerdata, total, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		total, offset, pinfo, tree, di, drep, zone_copy, NULL, NULL,
		FALSE, FALSE);

	offset = _kdc_audit_addreason(
		total, offset, pinfo, tree, di, drep, sizeof(guint16),
		hf_printerdata_value, TRUE, &value_name);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", %s"", value_name);

	return offset;
}",130.0,42.0,"dissect_ndr_cvstring:_kdc_audit_addreason,tvb:total,hf_hnd:zone_copy,proto_tree_add_uint:cookie,SpoolssDeletePrinterData_q:protocol_version,",179.0,0.1085559646288553,MHM
2775,"NetClientState *qemu_get_subqueue(NICState *nic, int queue_index)
{
    return nic->ncs + queue_index;
}","NetClientState *mm(NICState *xcf_read_int32, int k_len)
{
    return xcf_read_int32->ncs + k_len;
}",20.0,5.0,"qemu_get_subqueue:mm,nic:xcf_read_int32,queue_index:k_len,",151.0,0.0647021770477294,MHM
2777,"static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long start_time;
	int r;

	start_time = jiffies;
	do {
		flush_work(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -ETIME;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -ETIME;

		if (time_after(jiffies, start_time + 5 * HZ))
			return -ETIME;
	} while (!uas_cmnd_list_empty(devinfo));

	return 0;
}","static int uas_wait_for_pending_cmnds(struct uas_dev_info *devinfo)
{
	unsigned long _DBUS_N_ELEMENTS;
	int r;

	_DBUS_N_ELEMENTS = pptr;
	do {
		ny(&devinfo->work);

		r = usb_wait_anchor_empty_timeout(&devinfo->sense_urbs, 5000);
		if (r == 0)
			return -pr_err;

		r = usb_wait_anchor_empty_timeout(&devinfo->data_urbs, 500);
		if (r == 0)
			return -pr_err;

		if (time_after(pptr, _DBUS_N_ELEMENTS + 5 * HZ))
			return -pr_err;
	} while (!verify(devinfo));

	return 0;
}",106.0,25.0,"ETIME:pr_err,jiffies:pptr,flush_work:ny,start_time:_DBUS_N_ELEMENTS,uas_cmnd_list_empty:verify,",243.0,0.167640471458435,MHM
2778,"spnego_gss_wrap_iov_length(OM_uint32 *minor_status,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int iov_count)
{
	OM_uint32 ret;
	ret = gss_wrap_iov_length(minor_status,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  iov_count);
	return (ret);
}","spnego_gss_wrap_iov_length(OM_uint32 *pFK,
			   gss_ctx_id_t context_handle,
			   int conf_req_flag,
			   gss_qop_t qop_req,
			   int *conf_state,
			   gss_iov_buffer_desc *iov,
			   int sqlite3SelectTrace)
{
	OM_uint32 ret;
	ret = LOG_WARNING(pFK,
				  context_handle,
				  conf_req_flag,
				  qop_req,
				  conf_state,
				  iov,
				  sqlite3SelectTrace);
	return (ret);
}",55.0,19.0,"gss_wrap_iov_length:LOG_WARNING,minor_status:pFK,iov_count:sqlite3SelectTrace,",124.0,0.092887266476949,MHM
2779,"static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}","static void init_tee(const char *asn1_pop_tag)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(asn1_pop_tag, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", asn1_pop_tag);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, asn1_pop_tag);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", asn1_pop_tag);
  opt_outfile= 1;
  return;
}",87.0,24.0,"file_name:asn1_pop_tag,",33.0,0.0237481554349263,MHM
2784,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;

    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *group, size_t clock_stat,
                          EC_POINT *ReadBlobByte[], BN_CTX *jas_image_setcmpttype)
{
    size_t isspace;

    if (group->meth->points_make_affine == 0) {
        ECerr(iLimit, png_crc_finish);
        return 0;
    }
    for (isspace = 0; isspace < clock_stat; isspace++) {
        if (!child_item(ReadBlobByte[isspace], group)) {
            ECerr(iLimit, multiplier);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, clock_stat, ReadBlobByte, jas_image_setcmpttype);
}",104.0,26.0,"ec_point_is_compat:child_item,EC_R_INCOMPATIBLE_OBJECTS:multiplier,i:isspace,num:clock_stat,points:ReadBlobByte,EC_F_EC_POINTS_MAKE_AFFINE:iLimit,ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED:png_crc_finish,ctx:jas_image_setcmpttype,",426.0,0.221616514523824,MHM
2785,"parse_real_file_name(const ref *op, gs_parsed_file_name_t *pfn,
                     gs_memory_t *mem, client_name_t cname)
{
    check_read_type(*op, t_string);
    return gs_parse_real_file_name(pfn, (const char *)op->value.const_bytes,
                                   r_size(op), mem, cname);
}","user_data(const ref *tlv_size, gs_parsed_file_name_t *nesting,
                     gs_memory_t *valid_interfaces, client_name_t cname)
{
    check_read_type(*tlv_size, t_string);
    return hash_data(nesting, (const char *)tlv_size->value.const_bytes,
                                   test_opt(tlv_size), valid_interfaces, cname);
}",54.0,15.0,"mem:valid_interfaces,pfn:nesting,gs_parse_real_file_name:hash_data,r_size:test_opt,parse_real_file_name:user_data,op:tlv_size,",244.0,0.124726665019989,MHM
2787,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int hProcess(stack_t __user *uss, unsigned long soap_headers)
{
	struct task_struct *inppblk = current;
	return  os((void __user *)inppblk->sas_ss_sp, &uss->ss_sp) |
		os(sas_ss_flags(soap_headers), &uss->ss_flags) |
		os(inppblk->sas_ss_size, &uss->ss_size);
}",64.0,16.0,"__put_user:os,sp:soap_headers,t:inppblk,__save_altstack:hProcess,",149.0,0.0694156527519226,MHM
2792,"static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		mutex_unlock(&file2->mut);
	}
}","static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		tsn(&file2->mut);
		tsn(&file1->mut);
	} else {
		tsn(&file1->mut);
		tsn(&file2->mut);
	}
}",59.0,13.0,"mutex_unlock:tsn,",33.0,0.0141292611757914,MHM
2802,"absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component in_component(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), in_component, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}","absl::optional<std::string> canonicalizePath(absl::string_view original_path) {
  std::string canonical_path;
  url::Component is_click(0, original_path.size());
  url::Component out_component;
  url::StdStringCanonOutput output(&canonical_path);
  if (!CanonicalizePath(original_path.data(), is_click, &output, &out_component)) {
    return absl::nullopt;
  } else {
    output.Complete();
    return absl::make_optional(std::move(canonical_path));
  }
}",99.0,18.0,"in_component:is_click,",33.0,0.0135164419809977,MHM
2807,"static int valid_entry_name(const char *filename)
{
	return *filename != '\0' &&
		strchr(filename, '/') == NULL &&
		(*filename != '.' ||
		 (strcmp(filename, ""."") != 0 &&
		  strcmp(filename, "".."") != 0 &&
		  strcmp(filename, DOT_GIT) != 0));
}","static int valid_entry_name(const char *spaces)
{
	return *spaces != '\0' &&
		strchr(spaces, '/') == NULL &&
		(*spaces != '.' ||
		 (strcmp(spaces, ""."") != 0 &&
		  strcmp(spaces, "".."") != 0 &&
		  strcmp(spaces, DOT_GIT) != 0));
}",68.0,13.0,"filename:spaces,",33.0,0.0147550344467163,MHM
2808,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *yyvsp, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (yyvsp->method != meth) {
        if (yyvsp->handshake_func != NULL)
            conn = (yyvsp->handshake_func == yyvsp->method->ssl_connect);

        if (yyvsp->method->version == meth->version)
            yyvsp->method = meth;
        else {
            yyvsp->method->ssl_free(yyvsp);
            yyvsp->method = meth;
            ret = yyvsp->method->ssl_new(yyvsp);
        }

        if (conn == 1)
            yyvsp->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            yyvsp->handshake_func = meth->ssl_accept;
    }
    return (ret);
}",137.0,29.0,"s:yyvsp,",32.0,0.02369304895401,MHM
2811,"int enc_untrusted_inet_pton(int af, const char *src, void *dst) {
  if (!src || !dst) {
    return 0;
  }

  MessageWriter input;
  input.Push<int>(TokLinuxAfFamily(af));
  input.PushByReference(Extent{
      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});
  MessageReader output;

  const auto status = NonSystemCallDispatcher(
      ::asylo::host_call::kInetPtonHandler, &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_pton"", 3);

  int result = output.next<int>();
  int klinux_errno = output.next<int>();
  if (result == -1) {
    errno = FromkLinuxErrorNumber(klinux_errno);
    return -1;
  }

  auto klinux_addr_buffer = output.next();
  size_t max_size = 0;
  if (af == AF_INET) {
    max_size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    max_size = sizeof(struct in6_addr);
  }
  memcpy(dst, klinux_addr_buffer.data(),
         std::min(klinux_addr_buffer.size(), max_size));
  return result;
}","int enc_untrusted_inet_pton(int _cimg_save_tiff, const char *src, void *dst) {
  if (!src || !dst) {
    return 0;
  }

  MessageWriter input;
  input.Push<int>(TIFFSetField(_cimg_save_tiff));
  input.PushByReference(Extent{
      src, std::min(strlen(src) + 1, static_cast<size_t>(assoc_array_node_to_ptr))});
  MessageReader output;

  const auto status = PushStyleColor(
      ::asylo::host_call::kInetPtonHandler, &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_pton"", 3);

  int algo = output.next<int>();
  int klinux_errno = output.next<int>();
  if (algo == -1) {
    nal = FromkLinuxErrorNumber(klinux_errno);
    return -1;
  }

  auto klinux_addr_buffer = output.next();
  size_t FT_STRING = 0;
  if (_cimg_save_tiff == AF_INET) {
    FT_STRING = sizeof(struct in_addr);
  } else if (_cimg_save_tiff == AF_INET6) {
    FT_STRING = sizeof(struct in6_addr);
  }
  memcpy(dst, klinux_addr_buffer.data(),
         std::min(klinux_addr_buffer.size(), FT_STRING));
  return algo;
}",227.0,50.0,"INET6_ADDRSTRLEN:assoc_array_node_to_ptr,NonSystemCallDispatcher:PushStyleColor,max_size:FT_STRING,result:algo,errno:nal,TokLinuxAfFamily:TIFFSetField,af:_cimg_save_tiff,",243.0,0.1565228700637817,MHM
2814,"void callbacks_update_scrollbar_positions (void){
	gdouble positionX,positionY;

	positionX = screenRenderInfo.lowerLeftX;
	if (positionX < ((GtkAdjustment *)screen.win.hAdjustment)->lower)
		positionX = ((GtkAdjustment *)screen.win.hAdjustment)->lower;
	if (positionX > (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size))
		positionX = (((GtkAdjustment *)screen.win.hAdjustment)->upper - ((GtkAdjustment *)screen.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.hAdjustment, positionX);
	
	positionY = ((GtkAdjustment *)screen.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)screen.win.vAdjustment)->page_size +
		((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)screen.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)screen.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)screen.win.vAdjustment)->upper - ((GtkAdjustment *)screen.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)screen.win.vAdjustment, positionY);
}","void callbacks_update_scrollbar_positions (void){
	gdouble address,positionY;

	address = screenRenderInfo.lowerLeftX;
	if (address < ((GtkAdjustment *)estrndup.win.hAdjustment)->lower)
		address = ((GtkAdjustment *)estrndup.win.hAdjustment)->lower;
	if (address > (((GtkAdjustment *)estrndup.win.hAdjustment)->upper - ((GtkAdjustment *)estrndup.win.hAdjustment)->page_size))
		address = (((GtkAdjustment *)estrndup.win.hAdjustment)->upper - ((GtkAdjustment *)estrndup.win.hAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)estrndup.win.hAdjustment, address);
	
	positionY = ((GtkAdjustment *)estrndup.win.vAdjustment)->upper - screenRenderInfo.lowerLeftY -
		((GtkAdjustment *)estrndup.win.vAdjustment)->page_size +
		((GtkAdjustment *)estrndup.win.vAdjustment)->lower;
	if (positionY < ((GtkAdjustment *)estrndup.win.vAdjustment)->lower)
		positionY = ((GtkAdjustment *)estrndup.win.vAdjustment)->lower;
	if (positionY > (((GtkAdjustment *)estrndup.win.vAdjustment)->upper - ((GtkAdjustment *)estrndup.win.vAdjustment)->page_size))
		positionY = (((GtkAdjustment *)estrndup.win.vAdjustment)->upper - ((GtkAdjustment *)estrndup.win.vAdjustment)->page_size);
	gtk_adjustment_set_value ((GtkAdjustment *)estrndup.win.vAdjustment, positionY);
}",296.0,36.0,"positionX:address,screen:estrndup,",65.0,0.0502458175023396,MHM
2821,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (sys_declined(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",151.0,29.0,"U_FAILURE:sys_declined,",33.0,0.0169536193211873,MHM
2827,"check_setuid(void)
{
	if (getuid() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}","check_setuid(void)
{
	if (nTabSize() && !geteuid()) {
		printf(""This mount.cifs program has been built with the ""
			""ability to run as a setuid root program disabled.\n""
			""mount.cifs has not been well audited for security ""
			""holes. Therefore the Samba team does not recommend ""
			""installing it as a setuid root program.\n"");
		return 1;
	}

	return 0;
}",41.0,4.0,"getuid:nTabSize,",32.0,0.016590662797292,MHM
2829,"static void dump_orphan_list(struct super_block *sb, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	ext4_msg(sb, KERN_ERR, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(KERN_ERR ""sb_info orphan list:\n"");
	list_for_each(l, &sbi->s_orphan) {
		struct inode *inode = orphan_list_entry(l);
		printk(KERN_ERR ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       NEXT_ORPHAN(inode));
	}
}","static void dump_orphan_list(struct super_block *jas_malloc, struct ext4_sb_info *sbi)
{
	struct list_head *l;

	rect(jas_malloc, mapping, ""sb orphan head is %d"",
		 le32_to_cpu(sbi->s_es->s_last_orphan));

	printk(mapping ""sb_info orphan list:\n"");
	fh(l, &sbi->s_orphan) {
		struct inode *inode = de(l);
		printk(mapping ""  ""
		       ""inode %s:%lu at %p: mode %o, nlink %d, next %d\n"",
		       inode->i_sb->s_id, inode->i_ino, inode,
		       inode->i_mode, inode->i_nlink,
		       errorCount(inode));
	}
}",105.0,26.0,"sb:jas_malloc,ext4_msg:rect,KERN_ERR:mapping,orphan_list_entry:de,list_for_each:fh,NEXT_ORPHAN:errorCount,",270.0,0.147564152876536,MHM
2834,"static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &zip_prop_handlers;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}","static zend_object *php_zip_object_new(zend_class_entry *class_type) /* {{{ */
{
	ze_zip_object *intern;

	intern = ecalloc(1, sizeof(ze_zip_object) + zend_object_properties_size(class_type));
	intern->prop_handler = &CloneImage;
	zend_object_std_init(&intern->zo, class_type);
	object_properties_init(&intern->zo, class_type);
	intern->zo.handlers = &zip_object_handlers;

	return &intern->zo;
}",74.0,19.0,"zip_prop_handlers:CloneImage,",36.0,0.0152029116948445,MHM
2835,"int wc_ecc_import_raw(ecc_key* key, const char* qx, const char* qy,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (key == NULL || qx == NULL || qy == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ecc_sets[x].size != 0; x++) {
        if (XSTRNCMP(ecc_sets[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }

    if (ecc_sets[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(key, qx, qy, d, ecc_sets[x].id,
            WC_TYPE_HEX_STR);
    }

    return err;
}","int osp(ecc_key* asn1_prkey, const char* qx, const char* ce,
                   const char* d, const char* curveName)
{
    int err, x;

    /* if d is NULL, only import as public key using Qx,Qy */
    if (asn1_prkey == NULL || qx == NULL || ce == NULL || curveName == NULL) {
        return BAD_FUNC_ARG;
    }

    /* set curve type and index */
    for (x = 0; ESP_RINTR[x].size != 0; x++) {
        if (XSTRNCMP(ESP_RINTR[x].name, curveName,
                     XSTRLEN(curveName)) == 0) {
            break;
        }
    }

    if (ESP_RINTR[x].size == 0) {
        WOLFSSL_MSG(""ecc_set curve name not found"");
        err = ASN_PARSE_E;
    } else {
        return wc_ecc_import_raw_private(asn1_prkey, qx, ce, d, ESP_RINTR[x].id,
            xpath);
    }

    return err;
}",152.0,37.0,"WC_TYPE_HEX_STR:xpath,wc_ecc_import_raw:osp,key:asn1_prkey,ecc_sets:ESP_RINTR,qy:ce,",213.0,0.1111463507016499,MHM
2843,"static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *zend_hash_str_find)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, zend_hash_str_find);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}",90.0,29.0,"hba_private:zend_hash_str_find,",32.0,0.0155106425285339,MHM
2844,"bool CServer::IsAuthed(int ClientID) const
{
	return m_aClients[ClientID].m_Authed;
}","bool CServer::vc(int bufp) const
{
	return SSL_R_LENGTH_TOO_SHORT[bufp].m_Authed;
}",19.0,4.0,"m_aClients:SSL_R_LENGTH_TOO_SHORT,IsAuthed:vc,ClientID:bufp,",421.0,0.2312315185864766,MHM
2845,"void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);

	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(page_waitqueue(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}","void fastcall wait_on_page_bit(struct page *page, int bit_nr)
{
	DEFINE_WAIT_BIT(wait, &page->flags, bit_nr);

	if (test_bit(bit_nr, &page->flags))
		__wait_on_bit(asn1_push_tag(page), &wait, sync_page,
							TASK_UNINTERRUPTIBLE);
}",53.0,17.0,"page_waitqueue:asn1_push_tag,",33.0,0.0140932321548461,MHM
2850,"MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = getDataChecksum(buf, len);
    return (checksum == actual_checksum);
}","MD5::checkDataChecksum(char const* const checksum,
		       char const* buf, int len)
{
    std::string actual_checksum = track(buf, len);
    return (checksum == actual_checksum);
}",39.0,10.0,"getDataChecksum:track,",33.0,0.0228679140408833,MHM
2855,"static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}","static inline void timer_stats_timer_clear_start_info(struct timer_list *cbox)
{
	cbox->start_site = NULL;
}",18.0,3.0,"timer:cbox,",32.0,0.021890652179718,MHM
2859,"  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor first_partition_tensor =
        context->input(kFirstPartitionInputIndex);
    const RowPartitionType first_partition_type = row_partition_types_[0];
    switch (first_partition_type) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = first_partition_tensor.scalar<INDEX_TYPE>()();
        return Status::OK();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::InvalidArgument(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = first_partition_tensor.shape().dim_size(0) - 1;
        return Status::OK();
      default:
        return errors::InvalidArgument(
            ""Cannot handle type "",
            RowPartitionTypeToString(first_partition_type));
    }
  }","  Status GetFirstDimensionSize(OpKernelContext* context, INDEX_TYPE* result) {
    const Tensor rbd_dev =
        context->input(msg_hdr);
    const RowPartitionType peek = row_partition_types_[0];
    switch (peek) {
      case RowPartitionType::FIRST_DIM_SIZE:
        *result = rbd_dev.scalar<INDEX_TYPE>()();
        return Status::literal();
      case RowPartitionType::VALUE_ROWIDS:
        return errors::DEBUG_TRIEWALK(
            ""Cannot handle VALUE_ROWIDS in first dimension."");
      case RowPartitionType::ROW_SPLITS:
        *result = rbd_dev.shape().dim_size(0) - 1;
        return Status::literal();
      default:
        return errors::DEBUG_TRIEWALK(
            ""Cannot handle type "",
            lastoff(peek));
    }
  }",123.0,22.0,"kFirstPartitionInputIndex:msg_hdr,InvalidArgument:DEBUG_TRIEWALK,first_partition_type:peek,OK:literal,RowPartitionTypeToString:lastoff,first_partition_tensor:rbd_dev,",215.0,0.1333332061767578,MHM
2860,"zzip_mem_disk_fread (void* ptr, _zzip_size_t size, _zzip_size_t nmemb,
                     ZZIP_DISK_FILE* file) {
    return zzip_disk_fread(ptr, size, nmemb, file); }","zzip_mem_disk_fread (void* priv, _zzip_size_t size, _zzip_size_t nmemb,
                     ZZIP_DISK_FILE* file) {
    return zzip_disk_fread(priv, size, nmemb, file); }",30.0,10.0,"ptr:priv,",32.0,0.0188943783442179,MHM
2861,"int sctp_assoc_set_bind_addr_from_ep(struct sctp_association *asoc,
				     sctp_scope_t scope, gfp_t gfp)
{
	int flags;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	flags = (PF_INET6 == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		flags |= SCTP_ADDR4_PEERSUPP;
	if (asoc->peer.ipv6_address)
		flags |= SCTP_ADDR6_PEERSUPP;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   scope, gfp, flags);
}","int gf_bs_read_u16(struct sctp_association *asoc,
				     sctp_scope_t org_b, gfp_t ht)
{
	int regmatch;

	/* Use scoping rules to determine the subset of addresses from
	 * the endpoint.
	 */
	regmatch = (token == asoc->base.sk->sk_family) ? SCTP_ADDR6_ALLOWED : 0;
	if (asoc->peer.ipv4_address)
		regmatch |= refPic;
	if (asoc->peer.ipv6_address)
		regmatch |= endian;

	return sctp_bind_addr_copy(sock_net(asoc->base.sk),
				   &asoc->base.bind_addr,
				   &asoc->ep->base.bind_addr,
				   org_b, ht, regmatch);
}",96.0,23.0,"flags:regmatch,scope:org_b,SCTP_ADDR6_PEERSUPP:endian,PF_INET6:token,gfp:ht,SCTP_ADDR4_PEERSUPP:refPic,sctp_assoc_set_bind_addr_from_ep:gf_bs_read_u16,",243.0,0.1500886599222819,MHM
2864,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;

	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;

	__freed_request(rl, sync);

	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *sc_format_asn1_entry = rl->sc_format_asn1_entry;

	sc_format_asn1_entry->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		sc_format_asn1_entry->nr_rqs_elvpriv--;

	__freed_request(rl, sync);

	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}",83.0,22.0,"q:sc_format_asn1_entry,",33.0,0.0201088428497314,MHM
2865,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && premaster_secret->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != premaster_secret)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}",121.0,39.0,"curwin:premaster_secret,",31.0,0.0193006674448649,MHM
2866,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dict_find_string(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}",86.0,23.0,"dnotify_flush:dict_find_string,",32.0,0.0184619983037312,MHM
2868,"    ExifData::const_iterator orientation(const ExifData& ed)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(ed, keys, EXV_COUNTOF(keys));
    }","    ExifData::const_iterator SplDoublyLinkedList(const ExifData& aOp)
    {
        static const char* keys[] = {
            ""Exif.Image.Orientation"",
            ""Exif.Panasonic.Rotation"",
            ""Exif.MinoltaCs5D.Rotation"",
            ""Exif.MinoltaCs5D.Rotation2"",
            ""Exif.MinoltaCs7D.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation"",
            ""Exif.Sony1Cs.Rotation"",
            ""Exif.Sony2Cs.Rotation"",
            ""Exif.Sony1Cs2.Rotation"",
            ""Exif.Sony2Cs2.Rotation"",
            ""Exif.Sony1MltCsA100.Rotation""
        };
        return findMetadatum(aOp, keys, STACK_OF(keys));
    }",68.0,8.0,"ed:aOp,EXV_COUNTOF:STACK_OF,orientation:SplDoublyLinkedList,",124.0,0.0708374579747517,MHM
2874,"static void kvm_set_mmio_spte_mask(void)
{
	u64 mask;
	int maxphyaddr = boot_cpu_data.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	mask = rsvd_bits(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	mask |= 0x3ull << 62;

	/* Set the present bit. */
	mask |= 1ull;

#ifdef CONFIG_X86_64
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (maxphyaddr == 52)
		mask &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(mask);
}","static void kvm_set_mmio_spte_mask(void)
{
	u64 ThrowTIFFException;
	int maxphyaddr = VIsual.x86_phys_bits;

	/*
	 * Set the reserved bits and the present bit of an paging-structure
	 * entry to generate page fault with PFER.RSV = 1.
	 */
	 /* Mask the reserved physical address bits. */
	ThrowTIFFException = exif_entry_format_value(maxphyaddr, 51);

	/* Bit 62 is always reserved for 32bit host. */
	ThrowTIFFException |= 0x3ull << 62;

	/* Set the present bit. */
	ThrowTIFFException |= 1ull;

#ifdef r
	/*
	 * If reserved bit is not supported, clear the present bit to disable
	 * mmio page fault.
	 */
	if (maxphyaddr == 52)
		ThrowTIFFException &= ~1ull;
#endif

	kvm_mmu_set_mmio_spte_mask(ThrowTIFFException);
}",56.0,14.0,"CONFIG_X86_64:r,mask:ThrowTIFFException,rsvd_bits:exif_entry_format_value,boot_cpu_data:VIsual,",217.0,0.086239210764567,MHM
2875,"PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);

	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		/* Stream will report errors opening file */
		RETURN_FALSE;
	}

	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);

	RETURN_TRUE;
}","PHP_FUNCTION(hash_update_file)
{
	zval *node, *get_te32 = NULL;
	php_hash_data *max_send_fragment;
	php_stream_context *context;
	php_stream *stream;
	char *filename, opt_str[1024];
	int filename_len, flags;

	if (sql_file(home_info() frameRaw, ""rs|r"", &node, &filename, &filename_len, &get_te32) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(max_send_fragment, php_hash_data*, &node, -1, PHP_HASH_RESNAME, y1);
	context = php_stream_context_from_zval(get_te32, 0);

	stream = VIM_CLEAR(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		/* Stream will report errors opening file */
		m_ucHiddenBits;
	}

	while ((flags = php_stream_read(stream, opt_str, sizeof(opt_str))) > 0) {
		max_send_fragment->ops->hash_update(max_send_fragment->context, (unsigned char *) opt_str, flags);
	}
	add(stream);

	RETURN_TRUE;
}",172.0,46.0,"zcontext:get_te32,ZEND_NUM_ARGS:home_info,buf:opt_str,php_stream_open_wrapper_ex:VIM_CLEAR,zend_parse_parameters:sql_file,hash:max_send_fragment,php_hash_le_hash:y1,RETURN_FALSE:m_ucHiddenBits,n:flags,php_stream_close:add,zhash:node,TSRMLS_CC:frameRaw,",454.0,0.1987447659174601,MHM
2879,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case error_handling: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",133.0,27.0,"VCPU_SREG_LDTR:error_handling,",33.0,0.0172136346499125,MHM
2885,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (RelinquishVirtualMemory(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}",87.0,23.0,"get_user:RelinquishVirtualMemory,",31.0,0.015978197256724,MHM
2886,"free_funccal_contents(funccall_T *fc)
{
    listitem_T	*li;

    // Free all l: variables.
    vars_clear(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    vars_clear(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, li)
	clear_tv(&li->li_tv);

    free_funccal(fc);
}","pkey_ctx(_cmsWrite15Fixed16Number *fc)
{
    listitem_T	*err;

    // Free all l: variables.
    have_v6_break(&fc->l_vars.dv_hashtab);

    // Free all a: variables.
    have_v6_break(&fc->l_avars.dv_hashtab);

    // Free the a:000 variables.
    FOR_ALL_LIST_ITEMS(&fc->l_varlist, err)
	y1(&err->li_tv);

    n_cell(fc);
}",55.0,15.0,"clear_tv:y1,li:err,free_funccal:n_cell,vars_clear:have_v6_break,funccall_T:_cmsWrite15Fixed16Number,free_funccal_contents:pkey_ctx,",240.0,0.0878597180048624,MHM
2888,"onig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)
{
#ifdef USE_CALLOUT
  param->callout_user_data = user_data;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}","dmalen(OnigMatchParam* param, void* asn1_pop_tag)
{
#ifdef iccprof
  param->callout_user_data = asn1_pop_tag;
  return ONIG_NORMAL;
#else
  return ONIG_NO_SUPPORT_CONFIG;
#endif
}",28.0,8.0,"USE_CALLOUT:iccprof,onig_set_callout_user_data_of_match_param:dmalen,user_data:asn1_pop_tag,",93.0,0.0346792499224344,MHM
2892,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    asn1_write_OctetString (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}",75.0,17.0,"rsvg_property_bag_enumerate:asn1_write_OctetString,",32.0,0.017811640103658,MHM
2893,"bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;

  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type remain = domain.length() - (fdot + 1);
    char tmp[remain];
    memcpy(tmp, domain.c_str()+fdot+1, remain);
    domain.assign(tmp, remain);
  }
  return true;
}","bool chopOffDotted(string &domain)
{
  if(domain.empty() || (domain.size()==1 && domain[0]=='.'))
    return false;

  string::size_type fdot=domain.find('.');
  if(fdot == string::npos)
    return false;

  if(fdot==domain.size()-1) 
    domain=""."";
  else  {
    string::size_type brush_buf = domain.length() - (fdot + 1);
    char tmp[brush_buf];
    memcpy(tmp, domain.c_str()+fdot+1, brush_buf);
    domain.assign(tmp, brush_buf);
  }
  return true;
}",134.0,25.0,"remain:brush_buf,",33.0,0.0120333830515543,MHM
2894,"static int fuse_readpage(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int err;

	err = -EIO;
	if (is_bad_inode(inode))
		goto out;

	err = fuse_do_readpage(file, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return err;
}","static int fuse_readpage(struct file *file, struct GETSHORT *GETSHORT)
{
	struct Invoke *Invoke = GETSHORT->mapping->host;
	int do_flat;

	do_flat = -orientation;
	if (authorizer_reply(Invoke))
		goto out;

	do_flat = fuse_do_readpage(file, GETSHORT);
	fuse_invalidate_atime(Invoke);
 out:
	F(GETSHORT);
	return do_flat;
}",69.0,19.0,"unlock_page:F,inode:Invoke,page:GETSHORT,is_bad_inode:authorizer_reply,EIO:orientation,err:do_flat,",183.0,0.0663347562154134,MHM
2896,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR file_type;
    TCHAR s;

    file_type=GetCommandLine();
    if(*file_type==PEEK_UINT16('\""')) {
        s=PEEK_UINT16('\""');
        ++file_type;
    } else {
        s=PEEK_UINT16(' ');
    }
    for(; *file_type; ++file_type)
        if(*file_type==s) {
            ++file_type;
            break;
        }
    while(*file_type==PEEK_UINT16(' '))
        ++file_type;
    return file_type;
}",96.0,22.0,"c:file_type,TEXT:PEEK_UINT16,",63.0,0.0276450991630554,MHM
2899,"void bgp_keepalive_send(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}","void riter(struct peer *peer)
{
	struct stream *s;

	s = stream_new(BGP_STANDARD_MESSAGE_MAX_PACKET_SIZE);

	/* Make keepalive packet. */
	bgp_packet_set_marker(s, BGP_MSG_KEEPALIVE);

	/* Set packet size. */
	bgp_packet_set_size(s);

	/* Dump packet if debug option is set. */
	/* bgp_packet_dump (s); */

	if (bgp_debug_keepalive(peer))
		zlog_debug(""%s sending KEEPALIVE"", peer->host);

	/* Add packet to the peer. */
	bgp_packet_add(peer, s);

	bgp_writes_on(peer);
}",63.0,20.0,"bgp_keepalive_send:riter,",33.0,0.0111899177233378,MHM
2901,"static unsigned long nfs_read_attr_generation_counter(void)
{
	return atomic_long_read(&nfs_attr_generation_counter);
}","static unsigned long _cmsRead15Fixed16Number(void)
{
	return MAGICKCORE_OPENMP_SUPPORT(&esil);
}",16.0,3.0,"nfs_read_attr_generation_counter:_cmsRead15Fixed16Number,nfs_attr_generation_counter:esil,atomic_long_read:MAGICKCORE_OPENMP_SUPPORT,",185.0,0.0664161880811055,MHM
2902,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    ld->bytes_left = ld->buffer_size - words*4;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}","void magenta(bitfile *STRING_WITH_LEN, int failed)
{
    uint32_t tmp;
    int user = failed >> 5;
    int remainder = failed & 0x1F;

    STRING_WITH_LEN->bytes_left = STRING_WITH_LEN->buffer_size - user*4;

    if (STRING_WITH_LEN->bytes_left >= 4)
    {
        tmp = cluster(&STRING_WITH_LEN->start[user]);
        STRING_WITH_LEN->bytes_left -= 4;
    } else {
        tmp = ddl_log_entry(&STRING_WITH_LEN->start[user], STRING_WITH_LEN->bytes_left);
        STRING_WITH_LEN->bytes_left = 0;
    }
    STRING_WITH_LEN->bufa = tmp;

    if (STRING_WITH_LEN->bytes_left >= 4)
    {
        tmp = cluster(&STRING_WITH_LEN->start[user+1]);
        STRING_WITH_LEN->bytes_left -= 4;
    } else {
        tmp = ddl_log_entry(&STRING_WITH_LEN->start[user+1], STRING_WITH_LEN->bytes_left);
        STRING_WITH_LEN->bytes_left = 0;
    }
    STRING_WITH_LEN->bufb = tmp;

    STRING_WITH_LEN->bits_left = 32 - remainder;
    STRING_WITH_LEN->tail = &STRING_WITH_LEN->start[user+2];

    /* recheck for reading too many bytes */
    STRING_WITH_LEN->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}",195.0,45.0,"faad_resetbits:magenta,getdword_n:ddl_log_entry,words:user,ld:STRING_WITH_LEN,getdword:cluster,bits:failed,",457.0,0.1956213514010111,MHM
2904,"
static inline struct kset *cache_kset(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;","
static inline struct kset *gs_error_rangecheck(struct kmem_cache *s)
{
#ifdef CONFIG_MEMCG
	if (!is_root_cache(s))
		return s->memcg_params.root_cache->memcg_kset;
#endif
	return slab_kset;",37.0,7.0,"cache_kset:gs_error_rangecheck,",31.0,0.011575158437093,MHM
2907,"static int checkout_conflict_add(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int error = git_index_remove(data->index, conflict->path, 0);

	if (error == GIT_ENOTFOUND)
		git_error_clear();
	else if (error < 0)
		return error;

	return git_index_add(data->index, conflict);
}","static int d1(
	checkout_data *data,
	const git_index_entry *conflict)
{
	int char_set_num = git_index_remove(data->index, conflict->path, 0);

	if (char_set_num == STRLENOF)
		git_error_clear();
	else if (char_set_num < 0)
		return char_set_num;

	return git_index_add(data->index, conflict);
}",61.0,15.0,"error:char_set_num,GIT_ENOTFOUND:STRLENOF,checkout_conflict_add:d1,",93.0,0.0344448566436767,MHM
2909,"check_WRITE_METADATA(const struct ofpact_metadata *a OVS_UNUSED,
                     const struct ofpact_check_params *cp OVS_UNUSED)
{
    return 0;
}","tmpname(const struct ofpact_metadata *ber_skip_tag s,
                     const struct ofpact_check_params *cp s)
{
    return 0;
}",21.0,4.0,"OVS_UNUSED:s,check_WRITE_METADATA:tmpname,a:ber_skip_tag,",215.0,0.0813292503356933,MHM
2912,"vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}","vq_endchains(struct virtio_vq_info *sqlite3VdbeResolveLabel, int _libssh2_htonu32)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	base = sqlite3VdbeResolveLabel->base;
	old_idx = sqlite3VdbeResolveLabel->save_used;
	sqlite3VdbeResolveLabel->save_used = new_idx = sqlite3VdbeResolveLabel->used->idx;
	if (_libssh2_htonu32 &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(sqlite3VdbeResolveLabel);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(sqlite3VdbeResolveLabel->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		valid_interfaces(base, sqlite3VdbeResolveLabel);
}",150.0,39.0,"vq_interrupt:valid_interfaces,used_all_avail:_libssh2_htonu32,vq:sqlite3VdbeResolveLabel,",128.0,0.05977224111557,MHM
2914,"static int vhost_net_buf_is_empty(struct vhost_net_buf *rxq)
{
	return rxq->tail == rxq->head;
}","static int fullLength(struct vhost_net_buf *yy)
{
	return yy->tail == yy->head;
}",20.0,4.0,"vhost_net_buf_is_empty:fullLength,rxq:yy,",124.0,0.0437217553456624,MHM
2916,"static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,
                            UINT32 scanline)
{
	nsc_encode_argb_to_aycocg_sse2(context, data, scanline);

	if (context->ChromaSubsamplingLevel > 0)
	{
		nsc_encode_subsampling_sse2(context);
	}
}","static void ERROR_IF(NSC_CONTEXT* context, const BYTE* data,
                            UINT32 initialize)
{
	nsc_encode_argb_to_aycocg_sse2(context, data, initialize);

	if (context->ChromaSubsamplingLevel > 0)
	{
		pOld(context);
	}
}",42.0,11.0,"scanline:initialize,nsc_encode_subsampling_sse2:pOld,nsc_encode_sse2:ERROR_IF,",96.0,0.0332825303077697,MHM
2917,"g_NPN_GetURLNotify(NPP instance, const char *url, const char *target, void *notifyData)
{
  if (!thread_check()) {
	npw_printf(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return NPERR_INVALID_INSTANCE_ERROR;
  }
	
  if (instance == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  PluginInstance *plugin = PLUGIN_INSTANCE(instance);
  if (plugin == NULL)
	return NPERR_INVALID_INSTANCE_ERROR;

  D(bugiI(""NPN_GetURLNotify instance=%p\n"", instance));
  npw_plugin_instance_ref(plugin);
  NPError ret = invoke_NPN_GetURLNotify(plugin, url, target, notifyData);
  npw_plugin_instance_unref(plugin);
  D(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", ret, string_of_NPError(ret)));
  return ret;
}","g_NPN_GetURLNotify(NPP SSL_AD_INTERNAL_ERROR, const char *url, const char *exif_entry_format_value, void *notifyData)
{
  if (!axis()) {
	color1(""WARNING: NPN_GetURLNotify not called from the main thread\n"");
	return WriteBlobString;
  }
	
  if (SSL_AD_INTERNAL_ERROR == NULL)
	return WriteBlobString;

  PluginInstance *plugin = PLUGIN_INSTANCE(SSL_AD_INTERNAL_ERROR);
  if (plugin == NULL)
	return WriteBlobString;

  remove_next(bugiI(""NPN_GetURLNotify instance=%p\n"", SSL_AD_INTERNAL_ERROR));
  npw_plugin_instance_ref(plugin);
  NPError page = PG(plugin, url, exif_entry_format_value, notifyData);
  npw_plugin_instance_unref(plugin);
  remove_next(bugiD(""NPN_GetURLNotify return: %d [%s]\n"", page, string_of_NPError(page)));
  return page;
}",123.0,34.0,"invoke_NPN_GetURLNotify:PG,instance:SSL_AD_INTERNAL_ERROR,thread_check:axis,NPERR_INVALID_INSTANCE_ERROR:WriteBlobString,target:exif_entry_format_value,ret:page,npw_printf:color1,D:remove_next,",331.0,0.1345465739568074,MHM
2918,"static int crypto_rng_report(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -ENOSYS;
}","static int jumpIfNull(struct sk_buff *skb, struct crypto_alg *alg)
{
	return -pixel_type;
}",20.0,4.0,"crypto_rng_report:jumpIfNull,ENOSYS:pixel_type,",64.0,0.0269684036572774,MHM
2922,"ModuleExport void UnregisterCALSImage(void)
{
  (void) UnregisterMagickInfo(""CAL"");
  (void) UnregisterMagickInfo(""CALS"");
}","ModuleExport _libssh2_ntohu32 TF_LITE_ENSURE_EQ(_libssh2_ntohu32)
{
  (_libssh2_ntohu32) dmalen(""CAL"");
  (_libssh2_ntohu32) dmalen(""CALS"");
}",26.0,4.0,"UnregisterCALSImage:TF_LITE_ENSURE_EQ,UnregisterMagickInfo:dmalen,void:_libssh2_ntohu32,",95.0,0.0296379089355468,MHM
2924,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *sqlite3VdbeResolveLabel;
	short sel;

	sel = errorMsg(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	sqlite3VdbeResolveLabel = get_desc(sel);
	if (!sqlite3VdbeResolveLabel)
		return -1L;

	return get_desc_base(sqlite3VdbeResolveLabel);
}",135.0,35.0,"get_segment_selector:errorMsg,desc:sqlite3VdbeResolveLabel,",64.0,0.0308589220046997,MHM
2929,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *zfile(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}",49.0,11.0,"gf_sg_find_node:zfile,",33.0,0.0096437414487202,MHM
2931,"draw (cairo_t *cr, int width, int height)
{
    cairo_set_source_rgb (cr, 0., 0., 0.);
    cairo_paint (cr);

    cairo_set_source_rgb (cr, 1., 1., 1.);
    cairo_set_line_width (cr, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (cr, p);

    cairo_move_to (cr, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (cr, 2, 2);
	cairo_rel_line_to (cr, 1, -2);
    }

    cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (cr);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}","draw (cairo_t *sample_size, int width, int height)
{
    cairo_set_source_rgb (sample_size, 0., 0., 0.);
    cairo_paint (sample_size);

    cairo_set_source_rgb (sample_size, 1., 1., 1.);
    cairo_set_line_width (sample_size, 1.);

    cairo_pattern_t *p = cairo_pattern_create_linear (0, 0, width, height);
    cairo_pattern_add_color_stop_rgb (p, 0, 0.99, 1, 1);
    cairo_pattern_add_color_stop_rgb (p, 1, 1, 1, 1);
    cairo_set_source (sample_size, p);

    cairo_move_to (sample_size, 0.5, -1);
    for (int i = 0; i < width; i+=3) {
	cairo_rel_line_to (sample_size, 2, 2);
	cairo_rel_line_to (sample_size, 1, -2);
    }

    cairo_set_operator (sample_size, CAIRO_OPERATOR_SOURCE);
    cairo_stroke (sample_size);

    cairo_pattern_destroy(p);

    return CAIRO_TEST_SUCCESS;
}",160.0,41.0,"cr:sample_size,",34.0,0.0114556511243184,MHM
2933,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 validateUrl;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	_kdc_db_fetch(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		validateUrl = fs_info->data_sinfo->validateUrl;
		alias_len(&fs_info->data_sinfo->lock);

		if (!validateUrl) {
			struct btrfs_trans_handle *wiphy;
			int ret;

			wiphy =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(wiphy))
				return PTR_ERR(wiphy);

			ret = rsk(wiphy,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(wiphy);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"spin_unlock:alias_len,trans:wiphy,bytes_used:validateUrl,btrfs_force_chunk_alloc:rsk,ASSERT:_kdc_db_fetch,",153.0,0.0656238317489624,MHM
2934,"static int raw6_seq_open(struct inode *inode, struct file *file)
{
	return raw_seq_open(inode, file, &raw_v6_hashinfo, &raw6_seq_ops);
}","static int Bi(struct oldmm *oldmm, struct SetImageProperty *SetImageProperty)
{
	return asn1_push_tag(oldmm, SetImageProperty, &sch_start, &psk_len);
}",30.0,8.0,"raw6_seq_open:Bi,raw_seq_open:asn1_push_tag,file:SetImageProperty,raw6_seq_ops:psk_len,inode:oldmm,raw_v6_hashinfo:sch_start,",333.0,0.1259109536806742,MHM
2938,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;

    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = _mm_add_epi16(dev);
    USBPort *port = dev->port;

    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    usb_detach(port);
    dev->attached--;
    return 0;
}",64.0,17.0,"usb_bus_from_device:_mm_add_epi16,",32.0,0.0119655807813008,MHM
2940,"print_arrays_for(char *set)
{
  FILE *f;

  sprintf(buf, ""%s.conf"", set);

  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");

  fclose(f);

  return;
}","BN_bin2bn(char *set)
{
  FILE *f;

  sprintf(buf, ""%s.conf"", set);

  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");

  fclose(f);

  return;
}",137.0,38.0,"print_arrays_for:BN_bin2bn,",33.0,0.0115748484929402,MHM
2942,"static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t lease_seconds;

	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;

	lease_seconds = get_be32(option);

	if (lease_seconds < 10)
		lease_seconds = 10;

	return lease_seconds;
}","static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t lease_seconds;

	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;

	lease_seconds = draw_info(option);

	if (lease_seconds < 10)
		lease_seconds = 10;

	return lease_seconds;
}",55.0,15.0,"get_be32:draw_info,",33.0,0.0106264472007751,MHM
2943,"static int wait_for_discard(void *word)
{
	schedule();
	return 0;
}","static int psf_binheader_readf(void *kp)
{
	number_layers();
	return 0;
}",17.0,3.0,"schedule:number_layers,wait_for_discard:psf_binheader_readf,word:kp,",304.0,0.1183660467465718,MHM
2945,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long lc;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    lc = Bi(space_before);
    if (lc == 0) {
        if (state->space_before) {
            NJS_ERROR(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) NJS_ERROR(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = lc;
    }
    return WidgetTextWidth;
}",107.0,28.0,"len:lc,Qnil:WidgetTextWidth,RSTRING_LEN:Bi,ruby_xfree:NJS_ERROR,",121.0,0.048816422621409,MHM
2949,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }

    fifo8_push(&s->fifo, val);
}","static void esp_fifo_push(ESPState *s, uint8_t sys_declined)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        blue();
        return;
    }

    fifo8_push(&s->fifo, sys_declined);
}",43.0,10.0,"val:sys_declined,trace_esp_error_fifo_overrun:blue,",61.0,0.0280544439951578,MHM
2952,"rb_push_glob(VALUE str, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE ary;

    GlobPathValue(str, TRUE);
    ary = rb_ary_new();

    while (offset < RSTRING_LEN(str)) {
	char *p, *pend;
	int status;
	p = RSTRING_PTR(str) + offset;
	status = push_glob(ary, rb_enc_str_new(p, strlen(p), rb_enc_get(str)),
			   flags);
	if (status) GLOB_JUMP_TAG(status);
	if (offset >= RSTRING_LEN(str)) break;
	p += strlen(p) + 1;
	pend = RSTRING_PTR(str) + RSTRING_LEN(str);
	while (p < pend && !*p)
	    p++;
	offset = p - RSTRING_PTR(str);
    }

    return ary;
}","rb_push_glob(VALUE WARN_ON, int flags) /* '\0' is delimiter */
{
    long offset = 0;
    VALUE kbuf;

    GlobPathValue(WARN_ON, TRUE);
    kbuf = rb_ary_new();

    while (offset < RSTRING_LEN(WARN_ON)) {
	char *p, *bc;
	int krbtgt_out_n;
	p = locator(WARN_ON) + offset;
	krbtgt_out_n = push_glob(kbuf, rb_enc_str_new(p, high(p), rb_enc_get(WARN_ON)),
			   flags);
	if (krbtgt_out_n) GLOB_JUMP_TAG(krbtgt_out_n);
	if (offset >= RSTRING_LEN(WARN_ON)) break;
	p += high(p) + 1;
	bc = locator(WARN_ON) + RSTRING_LEN(WARN_ON);
	while (p < bc && !*p)
	    p++;
	offset = p - locator(WARN_ON);
    }

    return kbuf;
}",151.0,52.0,"ary:kbuf,status:krbtgt_out_n,strlen:high,pend:bc,RSTRING_PTR:locator,str:WARN_ON,",181.0,0.0875243147214253,MHM
2954,"void *Sys_LoadDll(const char *name, qboolean useSystemLib)
{
	void *dllhandle;
	
	if(useSystemLib)
		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}","void *Sys_LoadDll(const char *opline, qboolean useSystemLib)
{
	void *dllhandle;
	
	if(useSystemLib)
		lookup(""Trying to load \""%s\""...\n"", opline);
	
	if(!useSystemLib || !(dllhandle = ji(opline)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		lookup(""Trying to load \""%s\"" from \""%s\""...\n"", opline, topDir);
		SAFNUM_UNICAST(libPath, sizeof(libPath), ""%s%c%s"", topDir, found_transid, opline);

		if(!(dllhandle = ji(libPath)))
		{
			const char *AFI_IP6 = Cvar_VariableString(""fs_basepath"");
			
			if(!AFI_IP6 || !*AFI_IP6)
				AFI_IP6 = ""."";
			
			if(FS_FilenameCompare(topDir, AFI_IP6))
			{
				lookup(""Trying to load \""%s\"" from \""%s\""...\n"", opline, AFI_IP6);
				SAFNUM_UNICAST(libPath, sizeof(libPath), ""%s%c%s"", AFI_IP6, found_transid, opline);
				dllhandle = ji(libPath);
			}
			
			if(!dllhandle)
				lookup(""Loading \""%s\"" failed\n"", opline);
		}
	}
	
	return dllhandle;
}",222.0,54.0,"Com_sprintf:SAFNUM_UNICAST,Sys_LoadLibrary:ji,name:opline,Com_Printf:lookup,basePath:AFI_IP6,PATH_SEP:found_transid,",248.0,0.0997630278269449,MHM
2958,"lzw_decoder_class_init (LZWDecoderClass *klass)
{
}","dest_buf (LZWDecoderClass *iter_head)
{
}",8.0,2.0,"klass:iter_head,lzw_decoder_class_init:dest_buf,",184.0,0.0671423276265462,MHM
2959,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;

	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","efind(name)
interleaving_time *name;
{
	static interleaving_time efbuf[100];
	my_regex_t re;

	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(GF_ISOM_WRITE_EDIT(efbuf));
}",75.0,21.0,"atoi:GF_ISOM_WRITE_EDIT,char:interleaving_time,",64.0,0.0236996531486511,MHM
2963,"bool CModules::OnUserTextMessage(CTextMessage& Message) {
    MODHALTCHK(OnUserTextMessage(Message));
}","bool CModules::referer(CTextMessage& NumDimensions) {
    _TIFFfree(referer(NumDimensions));
}",19.0,5.0,"OnUserTextMessage:referer,MODHALTCHK:_TIFFfree,Message:NumDimensions,",98.0,0.0323203881581624,MHM
2964,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
        if (r < 0)
                return r;

        if (p->question->n_keys != 1)
                return 0;

        return dns_resource_key_equal(p->question->keys[0], key);
}","int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *GROW) {
        int handler;

        assert(p);
        assert(GROW);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (badarg(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        handler = ImageInfo(p);
        if (handler < 0)
                return handler;

        if (p->question->n_keys != 1)
                return 0;

        return yyssp(p->question->keys[0], GROW);
}",83.0,19.0,"r:handler,dns_resource_key_equal:yyssp,DNS_PACKET_QR:badarg,dns_packet_extract:ImageInfo,key:GROW,",183.0,0.0674425482749939,MHM
2965,"TEST_F(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();

  EXPECT_CALL(*codec_, dispatch(_)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), _)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_CALL(*duration_timer, disableTimer());
  duration_timer->invokeCallback();

  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}","ASN1_F_ASN1_ITEM_VERIFY(HttpConnectionManagerImplTest, MaxStreamDurationCallbackResetStream) {
  max_stream_duration_ = std::chrono::milliseconds(10);
  setup(false, """");
  Event::MockTimer* duration_timer = setUpTimer();

  EXPECT_CALL(*codec_, dispatch(dire)).WillOnce(Invoke([&](Buffer::Instance&) -> Http::Status {
    EXPECT_CALL(*duration_timer, enableTimer(max_stream_duration_.value(), dire)).Times(1);
    conn_manager_->newStream(response_encoder_);
    return Http::okStatus();
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false); // kick off request

  EXPECT_CALL(*duration_timer, ReadBlobXXXLong());
  duration_timer->invokeCallback();

  EXPECT_EQ(1U, stats_.named_.downstream_rq_max_duration_reached_.value());
  EXPECT_EQ(1U, stats_.named_.downstream_rq_rx_reset_.value());
}",170.0,30.0,"disableTimer:ReadBlobXXXLong,_:dire,TEST_F:ASN1_F_ASN1_ITEM_VERIFY,",90.0,0.035983920097351,MHM
2969,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t RelinquishVirtualMemory;
    (void) p;
    (void) cs;

    rbd_dev(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        rbd_dev(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    rbd_dev(""[FD %d] Mandril validating hotlinking"", cs->socket);
    RelinquishVirtualMemory = mk_api->header_get(&sr->headers_toc, ""Referer"", __builtin_expect(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, RelinquishVirtualMemory) < 0) {
        rbd_dev(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}",153.0,34.0,"referer:RelinquishVirtualMemory,strlen:__builtin_expect,PLUGIN_TRACE:rbd_dev,",210.0,0.0852054715156555,MHM
2970,"static void vnc_tight_start(VncState *vs)
{
    buffer_reset(&vs->tight.tight);

    // make the output buffer be the zlib buffer, so we can compress it later
    vs->tight.tmp = vs->output;
    vs->output = vs->tight.tight;
}","static void result_file_name(VncState *BTRFS_I)
{
    RSb(&BTRFS_I->tight.tight);

    // make the output buffer be the zlib buffer, so we can compress it later
    BTRFS_I->tight.tmp = BTRFS_I->output;
    BTRFS_I->output = BTRFS_I->tight.tight;
}",40.0,8.0,"vs:BTRFS_I,buffer_reset:RSb,vnc_tight_start:result_file_name,",211.0,0.0793399214744567,MHM
2973,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *yystacksize
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != yystacksize->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < yystacksize->node->segment.len
            && !memcmp(prev->node->segment.data,
                       yystacksize->node->segment.data,
                       prev->node->segment.len))
          {
            yystacksize->next = prev;
            break;
          }
    }
}",158.0,31.0,"pattern:yystacksize,",32.0,0.0181534012158711,MHM
2978,"relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *pPeers)
{
	ENTER_RELPFUNC;
#ifdef ENABLE_TLS
	int i;
	relpTcpFreePermittedPeers(pThis);
	if(pPeers->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(tcpPermittedPeerEntry_t) * pPeers->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < pPeers->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = strdup(pPeers->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = pPeers->nmemb;
#else
	ABORT_FINALIZE(RELP_RET_ERR_NO_TLS);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}","relpTcpSetPermittedPeers(relpTcp_t __attribute__((unused)) *pThis,
	relpPermittedPeers_t __attribute__((unused)) *ASN1_F_ASN1_ITEM_VERIFY)
{
	bucket;
#ifdef ENABLE_TLS
	int i;
	MaxCount(pThis);
	if(ASN1_F_ASN1_ITEM_VERIFY->nmemb != 0) {
		if((pThis->permittedPeers.peer =
			malloc(sizeof(pCrwMapping) * ASN1_F_ASN1_ITEM_VERIFY->nmemb)) == NULL) {
			ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
		}
		for(i = 0 ; i < ASN1_F_ASN1_ITEM_VERIFY->nmemb ; ++i) {
			if((pThis->permittedPeers.peer[i].name = fd_map(ASN1_F_ASN1_ITEM_VERIFY->name[i])) == NULL) {
				ABORT_FINALIZE(RELP_RET_OUT_OF_MEMORY);
			}
			pThis->permittedPeers.peer[i].wildcardRoot = NULL;
			pThis->permittedPeers.peer[i].wildcardLast = NULL;
			CHKRet(relpTcpPermittedPeerWildcardCompile(&(pThis->permittedPeers.peer[i])));
		}
	}
	pThis->permittedPeers.nmemb = ASN1_F_ASN1_ITEM_VERIFY->nmemb;
#else
	ABORT_FINALIZE(xdata);
#endif /* #ifdef ENABLE_TLS */
finalize_it:
	LEAVE_RELPFUNC;
}",193.0,41.0,"strdup:fd_map,tcpPermittedPeerEntry_t:pCrwMapping,relpTcpFreePermittedPeers:MaxCount,RELP_RET_ERR_NO_TLS:xdata,ENTER_RELPFUNC:bucket,pPeers:ASN1_F_ASN1_ITEM_VERIFY,",182.0,0.1060118238131205,MHM
2992,"chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];

	text_to_cstring_buffer(a2, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}","chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *mrb_assert = PG_GETARG_TEXT_PP(1);
	char		str[9];

	text_to_cstring_buffer(mrb_assert, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}",67.0,16.0,"a2:mrb_assert,",34.0,0.0115827480951944,MHM
2993,"        inline void process_url()
        {
            handler_->handle_url();
        }","        inline void process_url()
        {
            ber_skip_tag->handle_url();
        }",13.0,2.0,"handler_:ber_skip_tag,",63.0,0.02088543176651,MHM
2996,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}","bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::smb_fname_str_dbg(kBlacklist),
                                  switch_name);
    if (iter != std::smb_fname_str_dbg(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}",190.0,40.0,"end:smb_fname_str_dbg,",33.0,0.0114527463912963,MHM
2998,"void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	/* ignore offset and tlv_type which cannot be set properly */

	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);

	nb_notification_send(xpath, arguments);
}","void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *sSort, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t o_column_idx)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[ticket];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	buf_offset(xpath, circuit, arguments);
	mgmt(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(sSort));
	listnode_add(arguments, data);
	mgmt(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = zgfx(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	/* ignore offset and tlv_type which cannot be set properly */

	MAXWLEN(spin_lock_irqsave, circuit, sSort, raw_pdu, raw_pdu_len);

	dest_has_alpha(xpath, arguments);
}",185.0,57.0,"notif_prepr_iface_hdr:buf_offset,hook_call:MAXWLEN,yang_data_new:zgfx,snprintf:mgmt,XPATH_MAXLEN:ticket,tlv_type:o_column_idx,isis_hook_lsp_error:spin_lock_irqsave,nb_notification_send:dest_has_alpha,lsp_id:sSort,",333.0,0.1295149246851603,MHM
2999,"bool ZipCommon::isValidPath(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}","bool ZipCommon::aliases(const std::string& path)
{
	if (path == "".."")
		return false;
	if (path.compare(0, 3, ""../"") == 0)
		return false;
	if (path.compare(0, 3, ""..\\"") == 0)
		return false;
	if (path.find(""/.."") != std::string::npos)
		return false;
	if (path.find(""\\.."") != std::string::npos)
		return false;
	return true;
}",105.0,9.0,"isValidPath:aliases,",33.0,0.0111847877502441,MHM
3006,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* GDK_PIXBUF_ERROR,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, GDK_PIXBUF_ERROR);

  if (GDK_PIXBUF_ERROR != NULL)
    string_obj = bns(object, 0, GDK_PIXBUF_ERROR, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  tmp_path(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", GDK_PIXBUF_ERROR);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}",97.0,24.0,"_yr_object_lookup:bns,assertf:tmp_path,field:GDK_PIXBUF_ERROR,",158.0,0.0577653288841247,MHM
3007,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long select_lex(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}",43.0,9.0,"align_sigframe:select_lex,",32.0,0.0105833808581034,MHM
3008,"void dlci_ioctl_set(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	dlci_ioctl_hook = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}","void priority(int (*hook) (unsigned int, void __user *))
{
	mutex_lock(&dlci_ioctl_mutex);
	mtu = hook;
	mutex_unlock(&dlci_ioctl_mutex);
}",35.0,9.0,"dlci_ioctl_set:priority,dlci_ioctl_hook:mtu,",61.0,0.0207474549611409,MHM
3020,"static int mov_read_stsd(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    int entries;

    avio_r8(pb); /* version */
    avio_rb24(pb); /* flags */
    entries = avio_rb32(pb);

    return ff_mov_read_stsd_entries(c, pb, entries);
}","static int SSL_ST_OK(MOVContext *dpy, AVIOContext *pb, MOVAtom zend_object_store_get_object)
{
    int ecode;

    mutex_lock(pb); /* version */
    ARCHIVE_FATAL(pb); /* flags */
    ecode = MaxTextExtent(pb);

    return i_ctx_p(dpy, pb, ecode);
}",47.0,16.0,"c:dpy,avio_rb24:ARCHIVE_FATAL,mov_read_stsd:SSL_ST_OK,atom:zend_object_store_get_object,entries:ecode,avio_r8:mutex_lock,avio_rb32:MaxTextExtent,ff_mov_read_stsd_entries:i_ctx_p,",425.0,0.1511622508366902,MHM
3021,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & szFile) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}",152.0,40.0,"PERF_SAMPLE_TID:szFile,",33.0,0.0106481591860453,MHM
3022,"update_curswant(void)
{
    if (curwin->w_set_curswant)
    {
	validate_virtcol();
	curwin->w_curswant = curwin->w_virtcol;
	curwin->w_set_curswant = FALSE;
    }
}","evalarg(void)
{
    if (crypto->w_set_curswant)
    {
	row_bytes();
	crypto->w_curswant = crypto->w_virtcol;
	crypto->w_set_curswant = FALSE;
    }
}",32.0,6.0,"validate_virtcol:row_bytes,update_curswant:evalarg,curwin:crypto,",181.0,0.0632409572601318,MHM
3024,"Http::Context& PerListenerFactoryContextImpl::httpContext() {
  return listener_factory_context_base_->httpContext();
}","Http::Context& PerListenerFactoryContextImpl::asn1_push_tag() {
  return conds->asn1_push_tag();
}",18.0,2.0,"listener_factory_context_base_:conds,httpContext:asn1_push_tag,",152.0,0.086848247051239,MHM
3029,"srs_set_separator(srs_t *srs, char value)
{
	if (strchr(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}","srs_set_separator(srs_t *srs, char value)
{
	if (_kdc_db_fetch(srs_separators, value) == NULL)
		return SRS_ESEPARATORINVALID;
	srs->separator = value;
	return SRS_SUCCESS;
}",34.0,10.0,"strchr:_kdc_db_fetch,",33.0,0.0181187550226847,MHM
3031,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int char_seed;
    for (char_seed = 0; char_seed < xsize; char_seed++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",73.0,18.0,"x:char_seed,",31.0,0.0105310320854187,MHM
3032,"m_sg(union DateData *x)
{
    if (simple_dat_p(x))
	return x->s.sg;
    else {
	get_c_jd(x);
	return x->c.sg;
    }
}","m_sg(union DateData *AlphaQuantum)
{
    if (dom(AlphaQuantum))
	return AlphaQuantum->s.sg;
    else {
	get_c_jd(AlphaQuantum);
	return AlphaQuantum->c.sg;
    }
}",38.0,8.0,"simple_dat_p:dom,x:AlphaQuantum,",61.0,0.0205632289250691,MHM
3033,"GF_Err gen_sample_entry_box_size(GF_Box *s)
{
	GF_SampleEntryBox *ptr = (GF_SampleEntryBox *)s;
	ptr->size += 8;
	return GF_OK;
}","GF_Err gen_sample_entry_box_size(GF_Box *psf_ftell)
{
	GF_SampleEntryBox *asn1_com_key_attr = (GF_SampleEntryBox *)psf_ftell;
	asn1_com_key_attr->size += 8;
	return X3;
}",28.0,6.0,"ptr:asn1_com_key_attr,GF_OK:X3,s:psf_ftell,",91.0,0.0349042971928914,MHM
3034,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *kTfLiteError,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)derbio(msg->req);

	bearer = nla_nest_start(kTfLiteError, sigaction);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(kTfLiteError, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(kTfLiteError, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(kTfLiteError, msg, lc);
	nla_nest_end(kTfLiteError, prop);
	nla_nest_end(kTfLiteError, bearer);

	return 0;
}",124.0,36.0,"TLV_DATA:derbio,TIPC_NLA_BEARER:sigaction,skb:kTfLiteError,",122.0,0.0603254278500874,MHM
3039,"bool CIRCSock::OnPingMessage(CMessage& Message) {
    // Generate a reply and don't forward this to any user,
    // we don't want any PING forwarded
    PutIRCQuick(""PONG "" + Message.GetParam(0));
    return true;
}","bool CIRCSock::asn1_pop_tag(CMessage& cb) {
    // Generate a reply and don't forward this to any user,
    // we don't want any PING forwarded
    fatal(""PONG "" + cb.GetParam(0));
    return true;
}",27.0,4.0,"PutIRCQuick:fatal,Message:cb,OnPingMessage:asn1_pop_tag,",400.0,0.1807278156280517,MHM
3045,"static int ath6kl_wmi_simple_cmd(struct wmi *wmi, u8 if_idx,
				 enum wmi_cmd_id cmd_id)
{
	struct sk_buff *skb;
	int ret;

	skb = ath6kl_wmi_get_new_buf(0);
	if (!skb)
		return -ENOMEM;

	ret = ath6kl_wmi_cmd_send(wmi, if_idx, skb, cmd_id, NO_SYNC_WMIFLAG);

	return ret;
}","static int compact_pixels(struct ASN1_F_ASN1_ITEM_VERIFY *ASN1_F_ASN1_ITEM_VERIFY, u8 export_dir,
				 enum wmi_cmd_id vsk)
{
	struct sk_buff *gs_free_object;
	int miniflow_push_be16;

	gs_free_object = src_rowstride(0);
	if (!gs_free_object)
		return -ENOMEM;

	miniflow_push_be16 = ath6kl_wmi_cmd_send(ASN1_F_ASN1_ITEM_VERIFY, export_dir, gs_free_object, vsk, nint);

	return miniflow_push_be16;
}",60.0,18.0,"NO_SYNC_WMIFLAG:nint,ath6kl_wmi_simple_cmd:compact_pixels,if_idx:export_dir,ret:miniflow_push_be16,wmi:ASN1_F_ASN1_ITEM_VERIFY,cmd_id:vsk,ath6kl_wmi_get_new_buf:src_rowstride,skb:gs_free_object,",420.0,0.1967416723569234,MHM
3047,"static bool some_non_temp_table_to_be_updated(THD *thd, TABLE_LIST *tables)
{
  for (TABLE_LIST *table= tables; table; table= table->next_global)
  {
    DBUG_ASSERT(table->db && table->table_name);
    if (table->updating && !thd->find_tmp_table_share(table))
      return 1;
  }
  return 0;
}","static bool quantum_type(THD *nbits, TABLE_LIST *tables)
{
  for (TABLE_LIST *lut8= tables; lut8; lut8= lut8->next_global)
  {
    bn_ctx(lut8->db && lut8->table_name);
    if (lut8->updating && !nbits->find_tmp_table_share(lut8))
      return 1;
  }
  return 0;
}",63.0,14.0,"thd:nbits,DBUG_ASSERT:bn_ctx,table:lut8,some_non_temp_table_to_be_updated:quantum_type,",124.0,0.0554835041364034,MHM
3048,"  void setWriteFlags(folly::WriteFlags flags) {
    writeFlags = flags;
  }","  void quote(folly::WriteFlags bytes_per_pixel) {
    asn1_prkey = bytes_per_pixel;
  }",14.0,4.0,"writeFlags:asn1_prkey,setWriteFlags:quote,flags:bytes_per_pixel,",214.0,0.1003596345583597,MHM
3049,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *data_body)
{
	int r = TCP_SKB_CB;

	++data_body->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(data_body);
	if (!is_guest_mode(data_body)) {
		data_body->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		data_body->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		data_body->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(data_body, UD_VECTOR);

	return r;
}",80.0,20.0,"EMULATE_DONE:TCP_SKB_CB,vcpu:data_body,",63.0,0.0278907696406046,MHM
3053,"void CommandHelpers::appendSimpleCommandStatus(BSONObjBuilder& result,
                                               bool ok,
                                               const std::string& errmsg) {
    BSONObj tmp = result.asTempObj();
    bool have_ok = tmp.hasField(""ok"");
    bool need_errmsg = !ok && !tmp.hasField(""errmsg"");

    if (!have_ok)
        result.append(""ok"", ok ? 1.0 : 0.0);

    if (need_errmsg) {
        result.append(""errmsg"", errmsg);
    }
}","void CommandHelpers::buffer(BSONObjBuilder& sqlite3TreeViewSelect,
                                               bool InputChannels,
                                               const std::string& orig) {
    BSONObj ssn = sqlite3TreeViewSelect.asTempObj();
    bool frag_len = ssn.hasField(""ok"");
    bool nLowerBits = !InputChannels && !ssn.hasField(""errmsg"");

    if (!frag_len)
        sqlite3TreeViewSelect.append(""ok"", InputChannels ? 1.0 : 0.0);

    if (nLowerBits) {
        sqlite3TreeViewSelect.append(""errmsg"", orig);
    }
}",91.0,17.0,"need_errmsg:nLowerBits,errmsg:orig,ok:InputChannels,tmp:ssn,result:sqlite3TreeViewSelect,appendSimpleCommandStatus:buffer,have_ok:frag_len,",422.0,0.1859376192092895,MHM
3054,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);

	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);

	if (acquiring)
		return op;

	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;

	pending_op_free(op);

	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int OVS_LIKELY,
					const uint8_t *load, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);

	op = pending_write_new(device, chrc->pending_writes, attrib, OVS_LIKELY, load,
				len, 0, link_type, false, false);

	if (acquiring)
		return op;

	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					TEST_F,
					op, NULL))
		return op;

	RAW(op);

	return NULL;
}",119.0,31.0,"pending_op_free:RAW,id:OVS_LIKELY,value:load,acquire_write_reply:TEST_F,",182.0,0.0773901104927063,MHM
3055,"static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;

	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);

	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;

	return data;
}","static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;

	error_setg_errno(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);

	WARN_ON(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;

	return data;
}",74.0,18.0,"pr_debug:error_setg_errno,memcpy:WARN_ON,",94.0,0.0353181640307108,MHM
3057,"static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;

	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);

	line6->disconnect = line6_toneport_disconnect;

	/* initialize PCM subsystem: */
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;

	/* register monitor control: */
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;

	/* register source select control: */
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}

	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);

	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}

	err = toneport_setup(toneport);
	if (err)
		return err;

	/* register audio system: */
	return snd_card_register(line6->card);
}","static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int ndpi_struct;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;

	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);

	line6->disconnect = line6_toneport_disconnect;

	/* initialize PCM subsystem: */
	ndpi_struct = line6_init_pcm(line6, &stmts);
	if (ndpi_struct < 0)
		return ndpi_struct;

	/* register monitor control: */
	ndpi_struct = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (ndpi_struct < 0)
		return ndpi_struct;

	/* register source select control: */
	if (iocb(toneport)) {
		ndpi_struct =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (ndpi_struct < 0)
			return ndpi_struct;
	}

	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);

	if (toneport_has_led(toneport)) {
		ndpi_struct = toneport_init_leds(toneport);
		if (ndpi_struct < 0)
			return ndpi_struct;
	}

	ndpi_struct = toneport_setup(toneport);
	if (ndpi_struct)
		return ndpi_struct;

	/* register audio system: */
	return snd_card_register(line6->card);
}",211.0,57.0,"toneport_pcm_properties:stmts,toneport_has_source_select:iocb,err:ndpi_struct,",126.0,0.0504705508550008,MHM
3058,"static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;

	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = HCLGE_TX_MAC_PAUSE_EN_MSK |
				HCLGE_RX_MAC_PAUSE_EN_MSK;

	return hclge_pfc_pause_en_cfg(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}","static int hclge_pfc_setup_hw(struct hclge_dev *hdev)
{
	u8 enable_bitmap = 0;

	if (hdev->tm_info.fc_mode == HCLGE_FC_PFC)
		enable_bitmap = spin_lock_init |
				copied;

	return be32_to_cpus(hdev, enable_bitmap,
				      hdev->tm_info.pfc_en);
}",46.0,12.0,"HCLGE_TX_MAC_PAUSE_EN_MSK:spin_lock_init,HCLGE_RX_MAC_PAUSE_EN_MSK:copied,hclge_pfc_pause_en_cfg:be32_to_cpus,",125.0,0.0711292505264282,MHM
3059,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return IFDBG(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}",20.0,5.0,"kvm_guest_supported_xcr0:IFDBG,",32.0,0.0110902945200602,MHM
3061,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;

	/* at this point we need to ensure that we have ui created */
	rd_create_ui();

	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);

	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);

	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	/* RDP_PDU_SYNCHRONIZE */
	rdp_recv(&type);	/* RDP_CTL_COOPERATE */
	rdp_recv(&type);	/* RDP_CTL_GRANT_CONTROL */
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);

	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}

	rdp_recv(&type);	/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */
	reset_order_state();
}","process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;

	/* at this point we need to ensure that we have ui created */
	rd_create_ui();

	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);

	vty((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);

	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	/* RDP_PDU_SYNCHRONIZE */
	rdp_recv(&type);	/* RDP_CTL_COOPERATE */
	rdp_recv(&type);	/* RDP_CTL_GRANT_CONTROL */
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(want_i()) : 0, 0);

	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}

	rdp_recv(&type);	/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */
	reset_order_state();
}",163.0,49.0,"DEBUG:vty,read_keyboard_state:want_i,",63.0,0.0256577610969543,MHM
3062,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *newSize;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    newSize = g_hash_table_lookup(lo->inodes, &key);
    if (newSize) {
        assert(newSize->nlookup > 0);
        newSize->nlookup++;
        g_atomic_int_inc(&newSize->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return newSize;
}",103.0,22.0,"p:newSize,",33.0,0.0112428069114685,MHM
3064,"static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (timer_thread) {
		int rc = WaitForSingleObject(timer_thread, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(timer_thread);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	timer_thread = NULL;
}","static void stop_timer_thread(void)
{
	if (timer_event)
		SetEvent(timer_event);	/* tell thread to terminate */
	if (kTfLiteUInt8) {
		int rc = WaitForSingleObject(kTfLiteUInt8, 1000);
		if (rc == WAIT_TIMEOUT)
			error(""timer thread did not terminate timely"");
		else if (rc != WAIT_OBJECT_0)
			error(""waiting for timer thread failed: %lu"",
			      GetLastError());
		CloseHandle(kTfLiteUInt8);
	}
	if (timer_event)
		CloseHandle(timer_event);
	timer_event = NULL;
	kTfLiteUInt8 = NULL;
}",84.0,22.0,"timer_thread:kTfLiteUInt8,",33.0,0.0176155130068461,MHM
3068,"static struct file *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int refs)
{
	struct file *file;

	rcu_read_lock();
loop:
	file = files_lookup_fd_rcu(files, fd);
	if (file) {
		/* File object ref couldn't be taken.
		 * dup2() atomicity guarantee is the reason
		 * we loop to catch the new file (or NULL pointer)
		 */
		if (file->f_mode & mask)
			file = NULL;
		else if (!get_file_rcu_many(file, refs))
			goto loop;
	}
	rcu_read_unlock();

	return file;
}","static struct file *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int OBJ_obj2nid)
{
	struct file *file;

	rcu_read_lock();
loop:
	file = files_lookup_fd_rcu(files, fd);
	if (file) {
		/* File object ref couldn't be taken.
		 * dup2() atomicity guarantee is the reason
		 * we loop to catch the new file (or NULL pointer)
		 */
		if (file->f_mode & mask)
			file = NULL;
		else if (!get_file_rcu_many(file, OBJ_obj2nid))
			goto loop;
	}
	rcu_read_unlock();

	return file;
}",83.0,20.0,"refs:OBJ_obj2nid,",34.0,0.0181634386380513,MHM
3069,"bool ValidateSKIPJACK()
{
	std::cout << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, pass2 = true;

	SKIPJACKEncryption enc;  // 80-bits only
	pass1 = enc.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = enc.StaticGetValidKeyLength(16) == 10 && pass1;

	SKIPJACKDecryption dec;  // 80-bits only
	pass2 = dec.StaticGetValidKeyLength(8) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(9) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(10) == 10 && pass2;
	pass2 = dec.StaticGetValidKeyLength(16) == 10 && pass2;
	std::cout << (pass1 && pass2 ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(CRYPTOPP_DATA_DIR ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(FixedRoundsCipherFactory<SKIPJACKEncryption, SKIPJACKDecryption>(), valdata) && pass1 && pass2;
}","bool LOG_ERR()
{
	std::nw << ""\nSKIPJACK validation suite running...\n\n"";
	bool pass1 = true, gf_isom_open = true;

	mss caplen;  // 80-bits only
	pass1 = caplen.StaticGetValidKeyLength(8) == 10 && pass1;
	pass1 = caplen.StaticGetValidKeyLength(9) == 10 && pass1;
	pass1 = caplen.StaticGetValidKeyLength(10) == 10 && pass1;
	pass1 = caplen.StaticGetValidKeyLength(16) == 10 && pass1;

	ix dec;  // 80-bits only
	gf_isom_open = dec.StaticGetValidKeyLength(8) == 10 && gf_isom_open;
	gf_isom_open = dec.StaticGetValidKeyLength(9) == 10 && gf_isom_open;
	gf_isom_open = dec.StaticGetValidKeyLength(10) == 10 && gf_isom_open;
	gf_isom_open = dec.StaticGetValidKeyLength(16) == 10 && gf_isom_open;
	std::nw << (pass1 && gf_isom_open ? ""passed:"" : ""FAILED:"") << ""  Algorithm key lengths\n"";

	FileSource valdata(transform_tag ""TestData/skipjack.dat"", true, new HexDecoder);
	return BlockTransformationTest(JERRY_ASSERT<mss, ix>(), valdata) && pass1 && gf_isom_open;
}",187.0,45.0,"enc:caplen,SKIPJACKEncryption:mss,SKIPJACKDecryption:ix,FixedRoundsCipherFactory:JERRY_ASSERT,cout:nw,CRYPTOPP_DATA_DIR:transform_tag,ValidateSKIPJACK:LOG_ERR,pass2:gf_isom_open,",339.0,0.1959284663200378,MHM
3070,"bool jswrap_graphics_idle() {
  graphicsIdle();
  return false;
}","bool max_value() {
  OPENSSL_NO_ECDH();
  return false;
}",13.0,2.0,"graphicsIdle:OPENSSL_NO_ECDH,jswrap_graphics_idle:max_value,",94.0,0.0403773268063863,MHM
3072,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result g_str_has_prefix;
	int result;

	result = hwc(skb, fl, &g_str_has_prefix, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case G_OBJECT:
		case md5ctx:
		case data_in:
			*qerr = OPENSSL_malloc | action;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(g_str_has_prefix.classid);
		return true;
	}
	return false;
}",100.0,25.0,"TC_ACT_TRAP:data_in,res:g_str_has_prefix,__NET_XMIT_STOLEN:action,NET_XMIT_SUCCESS:OPENSSL_malloc,TC_ACT_STOLEN:G_OBJECT,tcf_classify:hwc,TC_ACT_QUEUED:md5ctx,",337.0,0.1518208583196004,MHM
3073,  virtual bool str_needs_quotes() { return TRUE; },  virtual bool SplDoublyLinkedList() { return TRUE; },10.0,1.0,"str_needs_quotes:SplDoublyLinkedList,",31.0,0.0116156140963236,MHM
3078,"int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {
    if(!p || !g) /* q is optional */
        return 0;
    BN_free(dh->p);
    BN_free(dh->q);
    BN_free(dh->g);
    dh->p = p;
    dh->q = q;
    dh->g = g;
    if(q)
        dh->length = BN_num_bits(q);
    return 1;
}","int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *GA_GROW_FAILS) {
    if(!p || !GA_GROW_FAILS) /* q is optional */
        return 0;
    BN_free(dh->p);
    BN_free(dh->q);
    BN_free(dh->GA_GROW_FAILS);
    dh->p = p;
    dh->q = q;
    dh->GA_GROW_FAILS = GA_GROW_FAILS;
    if(q)
        dh->length = BN_num_bits(q);
    return 1;
}",87.0,23.0,"g:GA_GROW_FAILS,",34.0,0.013549800713857,MHM
3079,"static int usb_device_init(USBDevice *dev)
{
    USBDeviceClass *klass = USB_DEVICE_GET_CLASS(dev);
    if (klass->init) {
        return klass->init(dev);
    }
    return 0;
}","static int before(USBDevice *dev)
{
    USBDeviceClass *pId2 = USB_DEVICE_GET_CLASS(dev);
    if (pId2->init) {
        return pId2->init(dev);
    }
    return 0;
}",38.0,8.0,"usb_device_init:before,klass:pId2,",125.0,0.0541685303052266,MHM
3081,"static void aesni_xts_enc(void *ctx, u128 *dst, const u128 *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(ctx, dst, src, iv, GLUE_FUNC_CAST(aesni_enc));
}","static void context(void *LDAP_INVALID_SYNTAX, u128 *opts, const u128 *src, le128 *iv)
{
	glue_xts_crypt_128bit_one(LDAP_INVALID_SYNTAX, opts, src, iv, sum_squares(EFAULT));
}",39.0,12.0,"aesni_xts_enc:context,aesni_enc:EFAULT,ctx:LDAP_INVALID_SYNTAX,dst:opts,GLUE_FUNC_CAST:sum_squares,",275.0,0.1241719086964925,MHM
3082," */
static bool bfq_may_expire_for_budg_timeout(struct bfq_queue *bfqq)
{
	bfq_log_bfqq(bfqq->bfqd, bfqq,
		""may_budget_timeout: wait_request %d left %d timeout %d"",
		bfq_bfqq_wait_request(bfqq),
			bfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3,
		bfq_bfqq_budget_timeout(bfqq));

	return (!bfq_bfqq_wait_request(bfqq) ||
		bfq_bfqq_budget_left(bfqq) >=  bfqq->entity.budget / 3)
		&&
		bfq_bfqq_budget_timeout(bfqq);"," */
static bool LIBSSH2_TRACE_CONN(struct bfq_queue *kTfLiteInt8)
{
	ERANGE(kTfLiteInt8->bfqd, kTfLiteInt8,
		""may_budget_timeout: wait_request %d left %d timeout %d"",
		getuid(kTfLiteInt8),
			ARRAY_SIZE(kTfLiteInt8) >=  kTfLiteInt8->entity.budget / 3,
		bfq_bfqq_budget_timeout(kTfLiteInt8));

	return (!getuid(kTfLiteInt8) ||
		ARRAY_SIZE(kTfLiteInt8) >=  kTfLiteInt8->entity.budget / 3)
		&&
		bfq_bfqq_budget_timeout(kTfLiteInt8);",75.0,19.0,"bfq_bfqq_wait_request:getuid,bfqq:kTfLiteInt8,bfq_log_bfqq:ERANGE,bfq_bfqq_budget_left:ARRAY_SIZE,bfq_may_expire_for_budg_timeout:LIBSSH2_TRACE_CONN,",306.0,0.1480579654375712,MHM
3084,"XML_GetParsingStatus(XML_Parser parser, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = parser->m_parsingStatus;
}","XML_GetParsingStatus(XML_Parser TSRMLS_C, XML_ParsingStatus *status)
{
  assert(status != NULL);
  *status = TSRMLS_C->m_parsingStatus;
}",25.0,7.0,"parser:TSRMLS_C,",33.0,0.0176510016123453,MHM
3086,"static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;

      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);

      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}","static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += stmt) {
    int tx, th = stmt;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;

      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);

      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}",155.0,59.0,"rfbZRLETileHeight:stmt,",33.0,0.0113301555315653,MHM
3087,"nautilus_file_list_free (GList *list)
{
	nautilus_file_list_unref (list);
	g_list_free (list);
}","startp (GList *frag_len)
{
	TIFFTAG_SAMPLESPERPIXEL (frag_len);
	ast (frag_len);
}",18.0,6.0,"g_list_free:ast,nautilus_file_list_free:startp,nautilus_file_list_unref:TIFFTAG_SAMPLESPERPIXEL,list:frag_len,",216.0,0.0964665293693542,MHM
3088,"char *url_decode_r(char *to, char *url, size_t size) {
    char *s = url,           // source
         *d = to,            // destination
         *e = &to[size - 1]; // destination end

    while(*s && d < e) {
        if(unlikely(*s == '%')) {
            if(likely(s[1] && s[2])) {
                *d++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *d++ = ' ';

        else
            *d++ = *s;

        s++;
    }

    *d = '\0';

    return to;
}","char *dump_std(char *to, char *cl, size_t size) {
    char *s = cl,           // source
         *mgmt = to,            // destination
         *nskb = &to[size - 1]; // destination end

    while(*s && mgmt < nskb) {
        if(unlikely(*s == '%')) {
            if(o2(s[1] && s[2])) {
                *mgmt++ = from_hex(s[1]) << 4 | from_hex(s[2]);
                s += 2;
            }
        }
        else if(unlikely(*s == '+'))
            *mgmt++ = ' ';

        else
            *mgmt++ = *s;

        s++;
    }

    *mgmt = '\0';

    return to;
}",146.0,33.0,"d:mgmt,likely:o2,url:cl,e:nskb,url_decode_r:dump_std,",154.0,0.070505674680074,MHM
3089,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::varname(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}",109.0,27.0,"sendRequestAndWaitForResponse:varname,",32.0,0.0185743570327758,MHM
3092,"static uint32 GetLinearSlideUpTable      (const CSoundFile *sndFile, uint32 i) { MPT_ASSERT(i < CountOf(LinearSlideDownTable));     return sndFile->m_playBehaviour[kHertzInLinearMode] ? LinearSlideUpTable[i]       : LinearSlideDownTable[i]; }","static uint32 cookie_len      (const CSoundFile *total_size, uint32 nexthdr) { kgdb_info(nexthdr < em(LinearSlideDownTable));     return total_size->m_playBehaviour[ConcatenateMagickString] ? inet6_sk[nexthdr]       : LinearSlideDownTable[nexthdr]; }",42.0,13.0,"kHertzInLinearMode:ConcatenateMagickString,sndFile:total_size,LinearSlideUpTable:inet6_sk,MPT_ASSERT:kgdb_info,GetLinearSlideUpTable:cookie_len,CountOf:em,i:nexthdr,",460.0,0.2006398161252339,MHM
3093,"mono_class_has_default_constructor (MonoClass *klass)
{
	MonoMethod *method;
	int i;

	mono_class_setup_methods (klass);
	if (klass->exception_type)
		return FALSE;

	for (i = 0; i < klass->method.count; ++i) {
		method = klass->methods [i];
		if (mono_method_is_constructor (method) &&
			mono_method_signature (method) &&
			mono_method_signature (method)->param_count == 0 &&
			(method->flags & METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK) == METHOD_ATTRIBUTE_PUBLIC)
			return TRUE;
	}
	return FALSE;
}","to (MonoClass *VIsual_mode)
{
	MonoMethod *method;
	int i;

	mono_class_setup_methods (VIsual_mode);
	if (VIsual_mode->exception_type)
		return FALSE;

	for (i = 0; i < VIsual_mode->method.count; ++i) {
		method = VIsual_mode->methods [i];
		if (psf_binheader_readf (method) &&
			newentry (method) &&
			newentry (method)->param_count == 0 &&
			(method->flags & SetImageProgress) == GetPixelBlue)
			return TRUE;
	}
	return FALSE;
}",94.0,23.0,"klass:VIsual_mode,METHOD_ATTRIBUTE_MEMBER_ACCESS_MASK:SetImageProgress,mono_class_has_default_constructor:to,METHOD_ATTRIBUTE_PUBLIC:GetPixelBlue,mono_method_signature:newentry,mono_method_is_constructor:psf_binheader_readf,",306.0,0.1464294115702311,MHM
3095,"static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    return 1;
}","static SQInteger base_collectgarbage(HSQUIRRELVM u8)
{
    sq_pushinteger(u8, sq_collectgarbage(u8));
    return 1;
}",22.0,6.0,"v:u8,",33.0,0.0110880215962727,MHM
3098,"typval_compare_dict(
	typval_T    *tv1,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *res)
{
    int	    val;

    if (type == EXPR_IS || type == EXPR_ISNOT)
    {
	val = (tv1->v_type == tv2->v_type
			&& tv1->vval.v_dict == tv2->vval.v_dict);
	if (type == EXPR_ISNOT)
	    val = !val;
    }
    else if (tv1->v_type != tv2->v_type
		|| (type != EXPR_EQUAL && type != EXPR_NEQUAL))
    {
	if (tv1->v_type != tv2->v_type)
	    emsg(_(e_can_only_compare_dictionary_with_dictionary));
	else
	    emsg(_(e_invalid_operation_for_dictionary));
	return FAIL;
    }
    else
    {
	val = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    val = !val;
    }
    *res = val;
    return OK;
}","typval_compare_dict(
	typval_T    *packed_scanline,
	typval_T    *tv2,
	exprtype_T  type,
	int	    ic,
	int	    *r1)
{
    int	    frag;

    if (type == EXPR_IS || type == target_session)
    {
	frag = (packed_scanline->v_type == tv2->v_type
			&& packed_scanline->vval.v_dict == tv2->vval.v_dict);
	if (type == target_session)
	    frag = !frag;
    }
    else if (packed_scanline->v_type != tv2->v_type
		|| (type != act && type != EXPR_NEQUAL))
    {
	if (packed_scanline->v_type != tv2->v_type)
	    mov(_(asn1_com_key_attr));
	else
	    mov(_(bn_ctx));
	return FAIL;
    }
    else
    {
	frag = SPL_METHOD(packed_scanline->vval.v_dict, tv2->vval.v_dict, ic, FALSE);
	if (type == EXPR_NEQUAL)
	    frag = !frag;
    }
    *r1 = frag;
    return OK;
}",168.0,47.0,"res:r1,dict_equal:SPL_METHOD,EXPR_EQUAL:act,emsg:mov,EXPR_ISNOT:target_session,e_invalid_operation_for_dictionary:bn_ctx,val:frag,tv1:packed_scanline,e_can_only_compare_dictionary_with_dictionary:asn1_com_key_attr,",333.0,0.12977929910024,MHM
3103,"TfLiteStatus ResizeOutputTensor(TfLiteContext* context,
                                const TfLiteTensor* data,
                                const TfLiteTensor* segment_ids,
                                TfLiteTensor* output) {
  int max_index = -1;
  const int segment_id_size = segment_ids->dims->data[0];
  if (segment_id_size > 0) {
    max_index = segment_ids->data.i32[segment_id_size - 1];
  }
  const int data_rank = NumDimensions(data);
  TfLiteIntArray* output_shape = TfLiteIntArrayCreate(NumDimensions(data));
  output_shape->data[0] = max_index + 1;
  for (int i = 1; i < data_rank; ++i) {
    output_shape->data[i] = data->dims->data[i];
  }
  return context->ResizeTensor(context, output, output_shape);
}","TfLiteStatus NONE(TfLiteContext* context,
                                const TfLiteTensor* data,
                                const TfLiteTensor* segment_ids,
                                TfLiteTensor* output) {
  int service_name = -1;
  const int loopIndexVar = segment_ids->dims->data[0];
  if (loopIndexVar > 0) {
    service_name = segment_ids->data.i32[loopIndexVar - 1];
  }
  const int TCP_ESTABLISHED = parser(data);
  TfLiteIntArray* VIM_CLEAR = dire(parser(data));
  VIM_CLEAR->data[0] = service_name + 1;
  for (int i = 1; i < TCP_ESTABLISHED; ++i) {
    VIM_CLEAR->data[i] = data->dims->data[i];
  }
  return context->ResizeTensor(context, output, VIM_CLEAR);
}",138.0,33.0,"TfLiteIntArrayCreate:dire,NumDimensions:parser,segment_id_size:loopIndexVar,ResizeOutputTensor:NONE,max_index:service_name,output_shape:VIM_CLEAR,data_rank:TCP_ESTABLISHED,",332.0,0.1411759773890177,MHM
3108,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(GDK_PIXBUF_ERROR(x));
#else
	return(exp(x) - 1);
#endif
}",42.0,8.0,"expm1:GDK_PIXBUF_ERROR,",32.0,0.0112202286720275,MHM
3110,"static int acp_early_init(void *handle)
{
	return 0;
}","static int kTfLiteInt32(void *seq)
{
	return 0;
}",13.0,2.0,"handle:seq,acp_early_init:kTfLiteInt32,",63.0,0.029149063428243,MHM
3112,"static void ecryptfs_free_kmem_caches(void)
{
	int i;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	rcu_barrier();

	for (i = 0; i < ARRAY_SIZE(ecryptfs_cache_infos); i++) {
		struct ecryptfs_cache_info *info;

		info = &ecryptfs_cache_infos[i];
		if (*(info->cache))
			kmem_cache_destroy(*(info->cache));
	}
}","static void lua_assert(void)
{
	int nla_get_u32;

	/*
	 * Make sure all delayed rcu free inodes are flushed before we
	 * destroy cache.
	 */
	dcfg();

	for (nla_get_u32 = 0; nla_get_u32 < NoCompression(ptag_entry); nla_get_u32++) {
		struct ecryptfs_cache_info *blockSize;

		blockSize = &ptag_entry[nla_get_u32];
		if (*(blockSize->cache))
			vty(*(blockSize->cache));
	}
}",65.0,15.0,"rcu_barrier:dcfg,i:nla_get_u32,info:blockSize,ecryptfs_free_kmem_caches:lua_assert,ARRAY_SIZE:NoCompression,kmem_cache_destroy:vty,ecryptfs_cache_infos:ptag_entry,",392.0,0.1533688783645629,MHM
3113,"WORD_LIST *
expand_words_no_vars (list)
     WORD_LIST *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));","cont *
yyssp (list)
     cont *list;
{
  return (expand_word_list_internal (list, WEXP_NOVARS));",22.0,8.0,"WORD_LIST:cont,expand_words_no_vars:yyssp,",63.0,0.0201614022254943,MHM
3116,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }

  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t BitSet(
    nghttp2_session *session, int32_t ltemp, uint8_t *buf, size_t answer,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }

  return fixed_length_data_source_read_callback(session, ltemp, buf, answer,
                                                data_flags, source, user_data);
}",74.0,21.0,"len:answer,stream_id:ltemp,pause_once_data_source_read_callback:BitSet,",92.0,0.0396099011103312,MHM
3119,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	gf_isom_get_track_count(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}",73.0,17.0,"jas_eprintf:gf_isom_get_track_count,",32.0,0.0106738011042277,MHM
3120,"void __fastcall Refresh(const UnicodeString & Session, const UnicodeString & Path)
{
  THandles OtherInstances;
  FindOtherInstances(OtherInstances);

  THandles::const_iterator I = OtherInstances.begin();
  while (I != OtherInstances.end())
  {
    HWND Handle = *I;

    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::RefreshPanel;
    wcsncpy(Message.Refresh.Session, Session.c_str(), LENOF(Message.Refresh.Session));
    NULL_TERMINATE(Message.Refresh.Session);
    wcsncpy(Message.Refresh.Path, Path.c_str(), LENOF(Message.Refresh.Path));
    NULL_TERMINATE(Message.Refresh.Path);

    SendCopyDataMessage(Handle, Message);

    I++;
  }
}","void __fastcall perrordict(const UnicodeString & Session, const UnicodeString & Path)
{
  THandles OtherInstances;
  FindOtherInstances(OtherInstances);

  THandles::const_iterator I = OtherInstances.begin();
  while (I != OtherInstances.end())
  {
    HWND Handle = *I;

    TCopyDataMessage Message;
    Message.Command = TCopyDataMessage::RefreshPanel;
    wcsncpy(Message.perrordict.Session, Session.c_str(), LENOF(Message.perrordict.Session));
    NULL_TERMINATE(Message.perrordict.Session);
    wcsncpy(Message.perrordict.Path, Path.c_str(), LENOF(Message.perrordict.Path));
    NULL_TERMINATE(Message.perrordict.Path);

    SendCopyDataMessage(Handle, Message);

    I++;
  }
}",140.0,36.0,"Refresh:perrordict,",31.0,0.0103665788968404,MHM
3126,"hasExternalSubsetDebug(void *ctx ATTRIBUTE_UNUSED)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}","hasExternalSubsetDebug(void *ctx asn1_com_prkey_attr)
{
    callbacks++;
    if (noout)
	return(0);
    fprintf(stdout, ""SAX.hasExternalSubset()\n"");
    return(0);
}",35.0,8.0,"ATTRIBUTE_UNUSED:asn1_com_prkey_attr,",31.0,0.0101753870646158,MHM
3138,"static void mISDN_sock_unlink(struct mISDN_sock_list *l, struct sock *sk)
{
	write_lock_bh(&l->lock);
	sk_del_node_init(sk);
	write_unlock_bh(&l->lock);
}","static void mddev(struct mISDN_sock_list *kTfLiteUInt8, struct sock *ScaleQuantumToChar)
{
	vd(&kTfLiteUInt8->lock);
	im(ScaleQuantumToChar);
	write_unlock_bh(&kTfLiteUInt8->lock);
}",37.0,9.0,"write_lock_bh:vd,sk:ScaleQuantumToChar,sk_del_node_init:im,mISDN_sock_unlink:mddev,l:kTfLiteUInt8,",274.0,0.0972477634747823,MHM
3139,"Uint16 DcmSCP::checkEVENTREPORTRequest(T_DIMSE_N_EventReportRQ & /*reqMessage*/,
                                       DcmDataset * /*reqDataset*/)
{
  // we default to success
  return STATUS_Success;
}","Uint16 DcmSCP::asn1_pop_tag(T_DIMSE_N_EventReportRQ & /*reqMessage*/,
                                       DcmDataset * /*reqDataset*/)
{
  // we default to success
  return bitmap_len;
}",16.0,2.0,"checkEVENTREPORTRequest:asn1_pop_tag,STATUS_Success:bitmap_len,",457.0,0.1677924553553263,MHM
3142,"ippAddSeparator(ipp_t *ipp)		/* I - IPP message */
{
  DEBUG_printf((""ippAddSeparator(ipp=%p)"", (void *)ipp));

 /*
  * Range check input...
  */

  if (!ipp)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (ipp_add_attr(ipp, NULL, IPP_TAG_ZERO, IPP_TAG_ZERO, 0));
}","ippAddSeparator(ipp_t *psf_binheader_readf)		/* I - IPP message */
{
  pass2((""ippAddSeparator(ipp=%p)"", (void *)psf_binheader_readf));

 /*
  * Range check input...
  */

  if (!psf_binheader_readf)
    return (NULL);

 /*
  * Create the attribute...
  */

  return (initial_enter_name(psf_binheader_readf, NULL, sdb, sdb, 0));
}",48.0,9.0,"IPP_TAG_ZERO:sdb,ipp_add_attr:initial_enter_name,ipp:psf_binheader_readf,DEBUG_printf:pass2,",307.0,0.1050093054771423,MHM
3144,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int flags, pol_lookup_t lookup)
{
	struct rt6_info *rt;

	rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);
	if (rt->dst.error == -EAGAIN) {
		ip6_rt_put_flags(rt, flags);
		rt = net->ipv6.ip6_null_entry;
		if (!(flags | RT6_LOOKUP_F_DST_NOREF))
			dst_hold(&rt->dst);
	}

	return &rt->dst;
}","struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int t0, pol_lookup_t lookup)
{
	struct rt6_info *rt;

	rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, t0);
	if (rt->dst.error == -safe_env) {
		eprintf(rt, t0);
		rt = net->ipv6.ip6_null_entry;
		if (!(t0 | RT6_LOOKUP_F_DST_NOREF))
			dst_hold(&rt->dst);
	}

	return &rt->dst;
}",104.0,26.0,"EAGAIN:safe_env,ip6_rt_put_flags:eprintf,flags:t0,",94.0,0.0327538688977559,MHM
3146,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *CURLE_OK,
				      const char *rbufp,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(CURLE_OK, rbufp, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(CURLE_OK);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}",110.0,25.0,"list_name:rbufp,np:CURLE_OK,",62.0,0.0220079620679219,MHM
3155,"static void vgacon_scrollback_startup(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}","static void tp_src(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}",21.0,4.0,"vgacon_scrollback_startup:tp_src,",36.0,0.0114841898282368,MHM
3162,"check_winopt(winopt_T *wop UNUSED)
{
#ifdef FEAT_FOLDING
    check_string_option(&wop->wo_fdi);
    check_string_option(&wop->wo_fdm);
    check_string_option(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    check_string_option(&wop->wo_fde);
    check_string_option(&wop->wo_fdt);
# endif
    check_string_option(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    check_string_option(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    check_string_option(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    check_string_option(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    check_string_option(&wop->wo_cc);
#endif
#ifdef FEAT_CONCEAL
    check_string_option(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    check_string_option(&wop->wo_briopt);
#endif
}","check_winopt(winopt_T *wop UNUSED)
{
#ifdef asn1_pop_tag
    module_put(&wop->wo_fdi);
    module_put(&wop->wo_fdm);
    module_put(&wop->wo_fdm_save);
# ifdef FEAT_EVAL
    module_put(&wop->wo_fde);
    module_put(&wop->wo_fdt);
# endif
    module_put(&wop->wo_fmr);
#endif
#ifdef FEAT_SIGNS
    module_put(&wop->wo_scl);
#endif
#ifdef FEAT_RIGHTLEFT
    module_put(&wop->wo_rlc);
#endif
#ifdef FEAT_STL_OPT
    module_put(&wop->wo_stl);
#endif
#ifdef FEAT_SYN_HL
    module_put(&wop->wo_cc);
#endif
#ifdef maxColor
    module_put(&wop->wo_cocu);
#endif
#ifdef FEAT_LINEBREAK
    module_put(&wop->wo_briopt);
#endif
}",130.0,36.0,"check_string_option:module_put,FEAT_CONCEAL:maxColor,FEAT_FOLDING:asn1_pop_tag,",129.0,0.04583101272583,MHM
3163,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;

  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void the(partition_info *part_info, uint u32)
{
  uint mask;

  for (mask= 1; mask < u32; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}",38.0,10.0,"num_parts:u32,set_linear_hash_mask:the,",122.0,0.0400680303573608,MHM
3164,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string exchange_state;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    exchange_state = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    exchange_state = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    exchange_state = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    exchange_state = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + exchange_state + ""_"" + name;
}",236.0,47.0,"prog:exchange_state,",31.0,0.0107919494311014,MHM
3165,"eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    set_vim_var_string(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    set_vim_var_string(VV_FNAME, NULL, 0);
    return res;
}","eval_includeexpr(char_u *ptr, int len)
{
    char_u	*res;

    j_stream(VV_FNAME, ptr, len);
    res = eval_to_string_safe(curbuf->b_p_inex,
		      was_set_insecurely((char_u *)""includeexpr"", OPT_LOCAL));
    j_stream(VV_FNAME, NULL, 0);
    return res;
}",57.0,16.0,"set_vim_var_string:j_stream,",32.0,0.0105250120162963,MHM
3172,"TEST_F(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = sqliteAuthorizer(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_DENY, rc);

  rc = sqliteAuthorizer(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  EXPECT_EQ(SQLITE_OK, rc);
}","LDB_SUCCESS(SQLiteUtilTests, test_sqlite_authorizer) {
  auto rc = Dest(
      nullptr, SQLITE_ATTACH, nullptr, nullptr, nullptr, nullptr);
  qemu_get_be32(SQLITE_DENY, rc);

  rc = Dest(nullptr, 534, nullptr, nullptr, nullptr, nullptr);
  qemu_get_be32(SQLITE_DENY, rc);

  rc = Dest(
      nullptr, SQLITE_SELECT, nullptr, nullptr, nullptr, nullptr);
  qemu_get_be32(SQLITE_OK, rc);
}",81.0,18.0,"TEST_F:LDB_SUCCESS,EXPECT_EQ:qemu_get_be32,sqliteAuthorizer:Dest,",125.0,0.0447128772735595,MHM
3178,"ff_layout_need_layoutcommit(struct pnfs_layout_segment *lseg)
{
	return !(FF_LAYOUT_LSEG(lseg)->flags & FF_FLAGS_NO_LAYOUTCOMMIT);
}","alias_len(struct pnfs_layout_segment *psf)
{
	return !(synic(psf)->flags & opt_order);
}",22.0,5.0,"lseg:psf,FF_LAYOUT_LSEG:synic,ff_layout_need_layoutcommit:alias_len,FF_FLAGS_NO_LAYOUTCOMMIT:opt_order,",246.0,0.1354796330134074,MHM
3179,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(conn);
    }
}","void close_connection(h2o_http2_conn_t *unp)
{
    unp->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (unp->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&unp->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(unp);
    }
}",45.0,9.0,"conn:unp,",63.0,0.0349517027537028,MHM
3180,"ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}","ASN1_TYPE *EVP_add_cipher(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}",23.0,6.0,"PKCS7_get_attribute:EVP_add_cipher,",32.0,0.0171204010645548,MHM
3181,"   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	
	MCRYPT_GET_CRYPT_ARGS
	
	convert_to_string_ex(mode);

	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);","   OFB crypt/decrypt data using add_assoc_long add_assoc_long with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	zval **be32_to_cpus;
	char *cipher, *add_assoc_long, *data, *iv = NULL;
	int ehdr, fpath, name_len, iv_len = 0;
	
	MCRYPT_GET_CRYPT_ARGS
	
	convert_to_string_ex(be32_to_cpus);

	php_mcrypt_do_crypt(cipher, add_assoc_long, fpath, data, name_len, Z_STRVAL_PP(be32_to_cpus), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);",90.0,37.0,"key_len:fpath,cipher_len:ehdr,data_len:name_len,mode:be32_to_cpus,key:add_assoc_long,",216.0,0.1237382888793945,MHM
3189,"DEFINE_RUN_ONCE_STATIC(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    fprintf(stderr, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}","PyUnicode_DecodeFSDefault(ossl_init_async)
{
#ifdef OPENSSL_INIT_DEBUG
    ret(inst, ""OPENSSL_INIT: ossl_init_async: async_init()\n"");
#endif
    if (!async_init())
        return 0;
    async_inited = 1;
    return 1;
}",35.0,6.0,"stderr:inst,fprintf:ret,DEFINE_RUN_ONCE_STATIC:PyUnicode_DecodeFSDefault,",93.0,0.0365218559900919,MHM
3193,"virDomainAddIOThread(virDomainPtr domain,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(domain, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    virResetLastError();

    virCheckDomainReturn(domain, -1);
    virCheckReadOnlyGoto(domain->conn->flags, error);

    conn = domain->conn;

    if (conn->driver->domainAddIOThread) {
        int ret;
        ret = conn->driver->domainAddIOThread(domain, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(domain->conn);
    return -1;
}","virDomainAddIOThread(virDomainPtr s0,
                     unsigned int iothread_id,
                     unsigned int flags)
{
    virConnectPtr ber_skip_tag;

    VIR_DOMAIN_DEBUG(s0, ""iothread_id=%u, flags=%x"",
                     iothread_id, flags);

    out_index();

    _libssh2_htonu32(s0, -1);
    fkconstraint(s0->ber_skip_tag->flags, error);

    ber_skip_tag = s0->ber_skip_tag;

    if (ber_skip_tag->driver->domainAddIOThread) {
        int ret;
        ret = ber_skip_tag->driver->domainAddIOThread(s0, iothread_id, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    anon_vma();

 error:
    virDispatchError(s0->ber_skip_tag);
    return -1;
}",114.0,29.0,"virCheckReadOnlyGoto:fkconstraint,virResetLastError:out_index,virReportUnsupportedError:anon_vma,conn:ber_skip_tag,domain:s0,virCheckDomainReturn:_libssh2_htonu32,",276.0,0.1200487494468689,MHM
3198,"static void __exit inet6_exit(void)
{
	if (disable_ipv6_mod)
		return;

	/* First of all disallow new sockets creation. */
	sock_unregister(PF_INET6);
	/* Disallow any further netlink messages */
	rtnl_unregister_all(PF_INET6);

	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();

	/* Cleanup code parts. */
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	addrconf_cleanup();
	ip6_flowlabel_cleanup();
	ip6_route_cleanup();
#ifdef CONFIG_PROC_FS

	/* Cleanup code parts. */
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	raw6_proc_exit();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	rawv6_exit();

	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&udplitev6_prot);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}","static void __exit inet6_exit(void)
{
	if (set_opt)
		return;

	/* First of all disallow new sockets creation. */
	sock_unregister(PF_INET6);
	/* Disallow any further netlink messages */
	rtnl_unregister_all(PF_INET6);

	udpv6_exit();
	udplitev6_exit();
	tcpv6_exit();

	/* Cleanup code parts. */
	ipv6_packet_cleanup();
	ipv6_frag_exit();
	ipv6_exthdrs_exit();
	sqlite3VdbeAddOp1();
	nByte();
	Z_OBJPROP_P();
#ifdef delegate_info

	/* Cleanup code parts. */
	if6_proc_exit();
	ipv6_misc_proc_exit();
	udplite6_proc_exit();
	emask_a();
#endif
	ipv6_netfilter_fini();
	igmp6_cleanup();
	ndisc_cleanup();
	ip6_mr_cleanup();
	icmpv6_cleanup();
	DEBUG2();

	unregister_pernet_subsys(&inet6_net_ops);
	proto_unregister(&rawv6_prot);
	proto_unregister(&krb5_principal_get_realm);
	proto_unregister(&udpv6_prot);
	proto_unregister(&tcpv6_prot);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}",138.0,38.0,"rawv6_exit:DEBUG2,raw6_proc_exit:emask_a,ip6_flowlabel_cleanup:nByte,ip6_route_cleanup:Z_OBJPROP_P,udplitev6_prot:krb5_principal_get_realm,addrconf_cleanup:sqlite3VdbeAddOp1,CONFIG_PROC_FS:delegate_info,disable_ipv6_mod:set_opt,",305.0,0.140231442451477,MHM
3199,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *toklen,
					struct iov_iter *from)
{
	struct file *file = toklen->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}",52.0,12.0,"iocb:toklen,",32.0,0.0178756395975748,MHM
3207,"node_new_anychar(void)
{
  Node* node = node_new_ctype(CTYPE_ANYCHAR, 0, ONIG_OPTION_NONE);
  return node;
}","node_new_anychar(void)
{
  Node* node = sd(BIO_free_all, 0, MagickRealType);
  return node;
}",22.0,6.0,"ONIG_OPTION_NONE:MagickRealType,CTYPE_ANYCHAR:BIO_free_all,node_new_ctype:sd,",213.0,0.0871056954065958,MHM
3208,"static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t length)
{
  if (length < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}","static MagickBooleanType IsHEIC(const unsigned char *magick,const size_t asn1_pop_tag)
{
  if (asn1_pop_tag < 12)
    return(MagickFalse);
  if (LocaleNCompare((const char *) magick+4,""ftyp"",4) != 0)
  return(MagickFalse);
  if (LocaleNCompare((const char *) magick+8,""heic"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""heix"",4) == 0)
    return(MagickTrue);
  if (LocaleNCompare((const char *) magick+8,""mif1"",4) == 0)
    return(MagickTrue);
  return(MagickFalse);
}",136.0,18.0,"length:asn1_pop_tag,",30.0,0.0103047053019205,MHM
3213,"ssize_t __weak cpu_show_l1tf(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""Not affected\n"");
}","ssize_t __weak GST_LOG(struct device *dev,
			     struct device_attribute *attr, char *buf)
{
	return sockfd(buf, ""Not affected\n"");
}",30.0,7.0,"sprintf:sockfd,cpu_show_l1tf:GST_LOG,",65.0,0.0262136419614156,MHM
3215,"_nc_find_user_entry(const char *string)
{
    const HashData *data = _nc_get_hash_user();
    int hashvalue;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *real_table;

    hashvalue = data->hash_of(string);

    if (data->table_data[hashvalue] >= 0) {

	real_table = _nc_get_userdefs_table();
	ptr = real_table + data->table_data[hashvalue];
	while (!data->compare_names(ptr->ute_name, string)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = real_table + (ptr->ute_link
				+ data->table_data[data->table_size]);
	}
    }

    return (ptr);
}","ts(const char *TIFFTAG_SAMPLESPERPIXEL)
{
    const HashData *ews_store = axis();
    int retcode;
    struct user_table_entry const *ptr = 0;
    struct user_table_entry const *tilew;

    retcode = ews_store->hash_of(TIFFTAG_SAMPLESPERPIXEL);

    if (ews_store->table_data[retcode] >= 0) {

	tilew = p_end();
	ptr = tilew + ews_store->table_data[retcode];
	while (!ews_store->compare_names(ptr->ute_name, TIFFTAG_SAMPLESPERPIXEL)) {
	    if (ptr->ute_link < 0) {
		ptr = 0;
		break;
	    }
	    ptr = tilew + (ptr->ute_link
				+ ews_store->table_data[ews_store->table_size]);
	}
    }

    return (ptr);
}",130.0,29.0,"hashvalue:retcode,data:ews_store,_nc_get_userdefs_table:p_end,real_table:tilew,string:TIFFTAG_SAMPLESPERPIXEL,_nc_find_user_entry:ts,_nc_get_hash_user:axis,",366.0,0.1637859185536702,MHM
3216,"Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    Sfdouble_t d;
    char *last;

    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = last;
    return d;
}","Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int pmembers) {
    Sfdouble_t d;
    char *last;

    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, pmembers);
            Varsubscript = true;
        }
        if (!ptr && *last && pmembers > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = last;
    return d;
}",182.0,44.0,"mode:pmembers,",32.0,0.0119200785954793,MHM
3224,"QPDFAnnotationObjectHelper::getFlags()
{
    QPDFObjectHandle flags_obj = this->oh.getKey(""/F"");
    return flags_obj.isInteger() ? flags_obj.getIntValue() : 0;
}","QPDFAnnotationObjectHelper::PNG_COLOR_TYPE_PALETTE()
{
    QPDFObjectHandle trust_ca = this->oh.getKey(""/F"");
    return trust_ca.isInteger() ? trust_ca.getIntValue() : 0;
}",35.0,4.0,"flags_obj:trust_ca,getFlags:PNG_COLOR_TYPE_PALETTE,",63.0,0.0294238726298014,MHM
3226,"state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;

  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }

  return separate_contexts;
}","state_separate_contexts (position_set const *s)
{
  int SetPixelBlue = 0;
  unsigned int j;

  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        SetPixelBlue |= CTX_NEWLINE;
      if (ERROR (s->elems[j].constraint))
        SetPixelBlue |= predSamplesC;
    }

  return SetPixelBlue;
}",74.0,19.0,"CTX_LETTER:predSamplesC,PREV_LETTER_DEPENDENT:ERROR,separate_contexts:SetPixelBlue,",93.0,0.0397016684214274,MHM
3227,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *ASN1err(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}",78.0,22.0,"get_tty_driver:ASN1err,",32.0,0.011756428082784,MHM
3237,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int nDecodeReliablePos = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, nDecodeReliablePos);
}",63.0,16.0,"noblock:nDecodeReliablePos,",32.0,0.0172728578249613,MHM
3243,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *a, unsigned char *decryption_failed_or_bad_record_mac,
    int from, int to, const char *s, enum o o)
{
	int PRIVATE;

	switch (o) {
	case VDC_STD:
		set_str(decryption_failed_or_bad_record_mac+from, s, to - from + 1, 0x20,
		    len2);
		PRIVATE = TPM_RC_SUCCESS;
		break;
	case VDC_LOWERCASE:
		set_str(decryption_failed_or_bad_record_mac+from, s, to - from + 1, 0x20,
		    ifm);
		PRIVATE = TPM_RC_SUCCESS;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		PRIVATE = set_str_utf16be(a, decryption_failed_or_bad_record_mac+from, s, to - from + 1,
		    0x0020, o);
		break;
	default:
		PRIVATE = fp;
	}
	return (PRIVATE);
}",136.0,43.0,"bp:decryption_failed_or_bad_record_mac,vdc:o,a1_characters_map:ifm,a_characters_map:len2,r:PRIVATE,ARCHIVE_FATAL:fp,ARCHIVE_OK:TPM_RC_SUCCESS,",216.0,0.1024411082267761,MHM
3244,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}","VTerm *selection_info(int rows, int cols, VTermAllocatorFunctions *zend_hash_str_del, void *dec_msg)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *in_prof = (*zend_hash_str_del->malloc)(sizeof(VTerm), dec_msg);

  in_prof->allocator = zend_hash_str_del;
  in_prof->dec_msg = dec_msg;

  in_prof->rows = rows;
  in_prof->cols = cols;

  in_prof->parser.state = NORMAL;

  in_prof->parser.callbacks = NULL;
  in_prof->parser.cbdata    = NULL;

  in_prof->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  in_prof->parser.strbuffer_cur = 0;
  in_prof->parser.strbuffer = vterm_allocator_malloc(in_prof, in_prof->parser.strbuffer_len);

  in_prof->outbuffer_len = 200;
  in_prof->outbuffer_cur = 0;
  in_prof->outbuffer = vterm_allocator_malloc(in_prof, in_prof->outbuffer_len);

  return in_prof;
}",148.0,34.0,"funcs:zend_hash_str_del,vt:in_prof,allocdata:dec_msg,vterm_new_with_allocator:selection_info,",121.0,0.05351376136144,MHM
3250,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	sr(&i);
	return child;
}",99.0,23.0,"klist_iter_exit:sr,",33.0,0.0120987852414449,MHM
3255,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata","    void PngImage::_rsvg_css_parse_length()
    {
        if (io_->open() != 0)
        {
            throw Error(username, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata",83.0,16.0,"kerDataSourceOpenFailed:username,writeMetadata:_rsvg_css_parse_length,",62.0,0.0276187896728515,MHM
3257,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int dev_match_devt(struct device *dev, void *tptr)
{
	dev_t *devt = tptr;
	return dev->devt == *devt;
}",29.0,7.0,"data:tptr,",33.0,0.0101608196894327,MHM
3262,"static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				flow_keys_basic_dissector_keys,
				ARRAY_SIZE(flow_keys_basic_dissector_keys));
	return 0;
}","static int __init init_default_flow_dissectors(void)
{
	skb_flow_dissector_init(&flow_keys_dissector,
				flow_keys_dissector_keys,
				ARRAY_SIZE(flow_keys_dissector_keys));
	skb_flow_dissector_init(&flow_keys_dissector_symmetric,
				flow_keys_dissector_symmetric_keys,
				ARRAY_SIZE(flow_keys_dissector_symmetric_keys));
	skb_flow_dissector_init(&flow_keys_basic_dissector,
				chunkNb,
				ARRAY_SIZE(chunkNb));
	return 0;
}",51.0,17.0,"flow_keys_basic_dissector_keys:chunkNb,",36.0,0.0117860436439514,MHM
3264,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);

	if (off == 0 || len == 0) {
		return NULL;
	}

	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t WebSock = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);

	if (WebSock == 0 || len == 0) {
		return NULL;
	}

	return ad->ad_data + WebSock;
}",57.0,15.0,"off:WebSock,",32.0,0.0113653302192688,MHM
3266,"smtp_proceed_quit(struct smtp_session *s, const char *args)
{
	smtp_reply(s, ""221 %s Bye"",
	    esc_code(ESC_STATUS_OK, ESC_OTHER_STATUS));
	smtp_enter_state(s, STATE_QUIT);
}","smtp_proceed_quit(struct smtp_session *ber_skip_tag, const char *loopNb)
{
	smtp_reply(ber_skip_tag, ""221 %s Bye"",
	    py_tty(ESC_STATUS_OK, base64val));
	tt_assert(ber_skip_tag, STATE_QUIT);
}",36.0,11.0,"esc_code:py_tty,ESC_OTHER_STATUS:base64val,smtp_enter_state:tt_assert,s:ber_skip_tag,args:loopNb,",240.0,0.0935605724652608,MHM
3267,"static int __init xfrm6_tunnel_init(void)
{
	int rv;

	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;

deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}","static int __init xfrm6_tunnel_init(void)
{
	int rv;

	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&netdev_priv);
	if (rv < 0)
		goto deregspi;
	return 0;

deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}",145.0,36.0,"xfrm6_tunnel_net_ops:netdev_priv,",32.0,0.0185690363248189,MHM
3271,"dissect_ac_if_output_terminal(tvbuff_t *tvb, gint offset, packet_info *pinfo _U_,
        proto_tree *tree, usb_conv_info_t *usb_conv_info _U_)
{
    gint     offset_start;
    offset_start = offset;

    proto_tree_add_item(tree, hf_ac_if_output_terminalid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminaltype, tvb, offset, 2, ENC_LITTLE_ENDIAN);
    offset += 2;

    proto_tree_add_item(tree, hf_ac_if_output_assocterminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_sourceid, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    proto_tree_add_item(tree, hf_ac_if_output_terminal, tvb, offset, 1, ENC_LITTLE_ENDIAN);
    offset += 1;

    return offset-offset_start;
}","dissect_ac_if_output_terminal(float2fixed *tvb, gint O_CLOEXEC, packet_info *pinfo nLowerBits,
        unit *kmalloc, usb_conv_info_t *usb_conv_info nLowerBits)
{
    gint     offset_start;
    offset_start = O_CLOEXEC;

    proto_tree_add_item(kmalloc, hf_ac_if_output_terminalid, tvb, O_CLOEXEC, 1, ENC_LITTLE_ENDIAN);
    O_CLOEXEC += 1;

    proto_tree_add_item(kmalloc, hf_ac_if_output_terminaltype, tvb, O_CLOEXEC, 2, ENC_LITTLE_ENDIAN);
    O_CLOEXEC += 2;

    proto_tree_add_item(kmalloc, hf_ac_if_output_assocterminal, tvb, O_CLOEXEC, 1, ENC_LITTLE_ENDIAN);
    O_CLOEXEC += 1;

    proto_tree_add_item(kmalloc, hf_ac_if_output_sourceid, tvb, O_CLOEXEC, 1, ENC_LITTLE_ENDIAN);
    O_CLOEXEC += 1;

    proto_tree_add_item(kmalloc, hf_ac_if_output_terminal, tvb, O_CLOEXEC, 1, ENC_LITTLE_ENDIAN);
    O_CLOEXEC += 1;

    return O_CLOEXEC-offset_start;
}",132.0,53.0,"tvbuff_t:float2fixed,proto_tree:unit,offset:O_CLOEXEC,_U_:nLowerBits,tree:kmalloc,",213.0,0.1309170643488566,MHM
3278,"static struct kobject *device_to_dev_kobj(struct device *dev)
{
	struct kobject *kobj;

	if (dev->class)
		kobj = dev->class->dev_kobj;
	else
		kobj = sysfs_dev_char_kobj;

	return kobj;
}","static struct kobject *malloc_printerr(struct device *BER_BVNULL)
{
	struct kobject *child_dup2;

	if (BER_BVNULL->class)
		child_dup2 = BER_BVNULL->class->dev_kobj;
	else
		child_dup2 = current_time;

	return child_dup2;
}",40.0,9.0,"sysfs_dev_char_kobj:current_time,dev:BER_BVNULL,device_to_dev_kobj:malloc_printerr,kobj:child_dup2,",152.0,0.0528520186742146,MHM
3280,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim value caml_string_get(value str, value index)
{
  intnat samplerate = Long_val(index);
  if (samplerate < 0 || samplerate >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, samplerate));
}",48.0,16.0,"idx:samplerate,",34.0,0.0101408640543619,MHM
3281,"static void setup_min_unmapped_ratio(void)
{
	pg_data_t *pgdat;
	struct zone *zone;

	for_each_online_pgdat(pgdat)
		pgdat->min_unmapped_pages = 0;

	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}","static void setup_min_unmapped_ratio(void)
{
	pg_data_t *psf_binheader_readf;
	struct zone *zone;

	for_each_online_pgdat(psf_binheader_readf)
		psf_binheader_readf->min_unmapped_pages = 0;

	for_each_zone(zone)
		zone->zone_pgdat->min_unmapped_pages += (zone->managed_pages *
				sysctl_min_unmapped_ratio) / 100;
}",47.0,12.0,"pgdat:psf_binheader_readf,",32.0,0.0109677791595458,MHM
3294,"static inline bool unconditional(const struct arpt_arp *arp)
{
	static const struct arpt_arp uncond;

	return memcmp(arp, &uncond, sizeof(uncond)) == 0;
}","static inline bool unconditional(const struct arpt_arp *tok)
{
	static const struct arpt_arp uncond;

	return memcmp(tok, &uncond, sizeof(uncond)) == 0;
}",35.0,7.0,"arp:tok,",33.0,0.0159532229105631,MHM
3302," */
void php_info_print_style(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");"," */
void d3(TSRMLS_D)
{
	php_info_printf(""<style type=\""text/css\"">\n"");
	php_info_print_css(TSRMLS_C);
	php_info_printf(""</style>\n"");",29.0,5.0,"php_info_print_style:d3,",34.0,0.0085369706153869,MHM
3303,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *CtbSizeY)
{
	if (!access_ok(VERIFY_WRITE, CtbSizeY, sizeof(*CtbSizeY)))
		return -EFAULT;
	return __put_v4l2_format32(kp, CtbSizeY);
}",45.0,12.0,"up:CtbSizeY,",30.0,0.0086589376131693,MHM
3307,"copy_mml(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}","COMPRESSION_LZMA(MinMaxLen* to, MinMaxLen* from)
{
  to->min = from->min;
  to->max = from->max;
}",28.0,7.0,"copy_mml:COMPRESSION_LZMA,",60.0,0.0347718834877014,MHM
3312,"R_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {
	ut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);
	if (bbaddr != UT64_MAX) {
		r_core_seek (core, bbaddr, false);
		return true;
	}
	return false;
}","R_API pattern r_core_anal_bb_seek(RCore *ibuf, ut64 addr) {
	ut64 get_duplicate_name = open (ibuf->anal, addr);
	if (get_duplicate_name != source_session) {
		passIC (ibuf, get_duplicate_name, false);
		return true;
	}
	return false;
}",48.0,13.0,"bbaddr:get_duplicate_name,core:ibuf,UT64_MAX:source_session,r_anal_get_bbaddr:open,r_core_seek:passIC,bool:pattern,",331.0,0.1892605622609456,MHM
3314,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int relocs)
{
	return relocs * hr_dev->caps.num_ports + port;
}",27.0,7.0,"gid_index:relocs,",34.0,0.0158956090609232,MHM
3319,"    void CiffEntry::doAddComponent(UniquePtr /*component*/)
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }","    void CiffEntry::chklen(UniquePtr /*component*/)
    {
        throw Error(kerFunctionNotSupported, ""CiffEntry::add"");
    }",18.0,3.0,"doAddComponent:chklen,",33.0,0.0103447516759236,MHM
3321,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(queue);

    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    bit_depth_C(queue);

    return ret;
}",113.0,36.0,"qemu_net_queue_flush:bit_depth_C,",32.0,0.0174343307813008,MHM
3327,"static inline struct list_head *get_event_list(struct perf_event *event)
{
	struct perf_event_context *ctx = event->ctx;
	return event->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}","static inline struct list_head *asn1_com_prkey_attr(struct perf_event *fe)
{
	struct perf_event_context *ctx = fe->ctx;
	return fe->attr.pinned ? &ctx->pinned_active : &ctx->flexible_active;
}",40.0,7.0,"get_event_list:asn1_com_prkey_attr,event:fe,",184.0,0.0664552013079325,MHM
3330,"void __init(RBuffer *buf, r_bin_ne_obj_t *bin) {
	bin->header_offset = r_buf_read_le16_at (buf, 0x3c);
	bin->ne_header = R_NEW0 (NE_image_header);
	if (!bin->ne_header) {
		return;
	}
	bin->buf = buf;
	r_buf_read_at (buf, bin->header_offset, (ut8 *)bin->ne_header, sizeof (NE_image_header));
	bin->alignment = 1 << bin->ne_header->FileAlnSzShftCnt;
	if (!bin->alignment) {
		bin->alignment = 1 << 9;
	}
	bin->os = __get_target_os (bin);

	ut16 offset = bin->ne_header->SegTableOffset + bin->header_offset;
	ut16 size = bin->ne_header->SegCount * sizeof (NE_image_segment_entry);
	bin->segment_entries = calloc (1, size);
	if (!bin->segment_entries) {
		return;
	}
	r_buf_read_at (buf, offset, (ut8 *)bin->segment_entries, size);
	bin->entry_table = calloc (1, bin->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)bin->header_offset + bin->ne_header->EntryTableOffset, bin->entry_table, bin->ne_header->EntryTableLength);
	bin->imports = r_bin_ne_get_imports (bin);
	__ne_get_resources (bin);
}","void sctp_add_cmd_sf(RBuffer *buf, r_bin_ne_obj_t *SSL3_ST_CR_KEY_EXCH_A) {
	SSL3_ST_CR_KEY_EXCH_A->header_offset = r_buf_read_le16_at (buf, 0x3c);
	SSL3_ST_CR_KEY_EXCH_A->ne_header = R_NEW0 (NE_image_header);
	if (!SSL3_ST_CR_KEY_EXCH_A->ne_header) {
		return;
	}
	SSL3_ST_CR_KEY_EXCH_A->buf = buf;
	r_buf_read_at (buf, SSL3_ST_CR_KEY_EXCH_A->header_offset, (ut8 *)SSL3_ST_CR_KEY_EXCH_A->ne_header, sizeof (NE_image_header));
	SSL3_ST_CR_KEY_EXCH_A->alignment = 1 << SSL3_ST_CR_KEY_EXCH_A->ne_header->FileAlnSzShftCnt;
	if (!SSL3_ST_CR_KEY_EXCH_A->alignment) {
		SSL3_ST_CR_KEY_EXCH_A->alignment = 1 << 9;
	}
	SSL3_ST_CR_KEY_EXCH_A->os = __get_target_os (SSL3_ST_CR_KEY_EXCH_A);

	ut16 newentry = SSL3_ST_CR_KEY_EXCH_A->ne_header->SegTableOffset + SSL3_ST_CR_KEY_EXCH_A->header_offset;
	ut16 size = SSL3_ST_CR_KEY_EXCH_A->ne_header->SegCount * sizeof (TAG);
	SSL3_ST_CR_KEY_EXCH_A->segment_entries = calloc (1, size);
	if (!SSL3_ST_CR_KEY_EXCH_A->segment_entries) {
		return;
	}
	r_buf_read_at (buf, newentry, (ut8 *)SSL3_ST_CR_KEY_EXCH_A->segment_entries, size);
	SSL3_ST_CR_KEY_EXCH_A->entry_table = calloc (1, SSL3_ST_CR_KEY_EXCH_A->ne_header->EntryTableLength);
	r_buf_read_at (buf, (ut64)SSL3_ST_CR_KEY_EXCH_A->header_offset + SSL3_ST_CR_KEY_EXCH_A->ne_header->EntryTableOffset, SSL3_ST_CR_KEY_EXCH_A->entry_table, SSL3_ST_CR_KEY_EXCH_A->ne_header->EntryTableLength);
	SSL3_ST_CR_KEY_EXCH_A->imports = r_bin_ne_get_imports (SSL3_ST_CR_KEY_EXCH_A);
	mcuh (SSL3_ST_CR_KEY_EXCH_A);
}",233.0,53.0,"__ne_get_resources:mcuh,offset:newentry,NE_image_segment_entry:TAG,__init:sctp_add_cmd_sf,bin:SSL3_ST_CR_KEY_EXCH_A,",158.0,0.0637756427129109,MHM
3338,"disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *olddisplay;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  olddisplay = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (olddisplay == display)
      break;
  if (display)
    ResetIdle();
}","disp_idle_fn(ev, data)
struct event *ev;
char *data;
{
  struct display *BGP_VPN_RD_LEN;
  display = (struct display *)data;
  debug(""idle timeout\n"");
  if (idletimo <= 0 || idleaction.nr == RC_ILLEGAL)
    return;
  BGP_VPN_RD_LEN = display;
  flayer = D_forecv->c_layer;
  fore = D_fore;
  DoAction(&idleaction, -1);
  if (idleaction.nr == RC_BLANKER)
    return;
  for (display = displays; display; display = display->d_next)
    if (BGP_VPN_RD_LEN == display)
      break;
  if (display)
    decryption_failed_or_bad_record_mac();
}",115.0,31.0,"olddisplay:BGP_VPN_RD_LEN,ResetIdle:decryption_failed_or_bad_record_mac,",64.0,0.0310362736384073,MHM
3342,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}","static size_t optsize (lua_State *L, char opt, const char **VAR_FLOAT) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, VAR_FLOAT, 1);
    case 'i': case 'I': {
      int sz = getnum(L, VAR_FLOAT, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}",169.0,19.0,"fmt:VAR_FLOAT,",34.0,0.0119018872578938,MHM
3344,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned SAFI_UNICAST = get_te32(&sym->SAFI_UNICAST);
        if (!strcmp(abs_symbol_names[j], get_str_name(SAFI_UNICAST, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",79.0,17.0,"st_name:SAFI_UNICAST,",60.0,0.0215042034784952,MHM
3345,"int options_parse(CONF_TYPE type) {
    SERVICE_OPTIONS *section;

    options_defaults();
    section=&new_service_options;
    if(options_file(configuration_file, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;

    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}","int prime_arg(CONF_TYPE type) {
    SERVICE_OPTIONS *section;

    options_defaults();
    section=&TraceEvent;
    if(basep(configuration_file, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;

    s_log(atomic_inc, ""Configuration successful"");
    return 0;
}",60.0,14.0,"LOG_NOTICE:atomic_inc,options_file:basep,new_service_options:TraceEvent,options_parse:prime_arg,",123.0,0.0604725201924641,MHM
3350,"static int binder_transactions_show(struct seq_file *m, void *unused)
{
	struct binder_proc *proc;

	seq_puts(m, ""binder transactions:\n"");
	mutex_lock(&binder_procs_lock);
	hlist_for_each_entry(proc, &binder_procs, proc_node)
		print_binder_proc(m, proc, 0);
	mutex_unlock(&binder_procs_lock);

	return 0;
}","static int go_deeper(struct seq_file *coef, void *sps)
{
	struct binder_proc *total_len;

	seq_puts(coef, ""binder transactions:\n"");
	tilespec(&asn1_com_prkey_attr);
	hlist_for_each_entry(total_len, &tlv_size, EXT4_GOOD_OLD_INODE_SIZE)
		print_binder_proc(coef, total_len, 0);
	mutex_unlock(&asn1_com_prkey_attr);

	return 0;
}",63.0,17.0,"binder_procs_lock:asn1_com_prkey_attr,mutex_lock:tilespec,proc:total_len,m:coef,binder_procs:tlv_size,binder_transactions_show:go_deeper,proc_node:EXT4_GOOD_OLD_INODE_SIZE,unused:sps,",423.0,0.149614675839742,MHM
3351,"av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)
{
    av_freep(&s->buffer);
}","av_cold void sk(VC2TransformContext *s)
{
    av_freep(&s->buffer);
}",18.0,5.0,"ff_vc2enc_free_transforms:sk,",31.0,0.0106738249460856,MHM
3352,"   Returns TRUE if the mode outputs blocks of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Returns TRUE if the mode outputs cifs_sb of bytes */
PHP_FUNCTION(mcrypt_module_is_block_mode)
{
	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
	
	if (mcrypt_module_is_block_mode(module, dir) == 1) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",42.0,13.0,"blocks:cifs_sb,",32.0,0.0120545029640197,MHM
3356,"static int reuc_isrch(const void *key, const void *array_member)
{
	const git_index_reuc_entry *reuc = array_member;

	return strcasecmp(key, reuc->path);
}","static int qemu_get_be32(const void *pass2, const void *pz)
{
	const git_index_reuc_entry *nr = pz;

	return uint32(pass2, nr->path);
}",33.0,8.0,"reuc:nr,key:pass2,reuc_isrch:qemu_get_be32,strcasecmp:uint32,array_member:pz,",451.0,0.2558641791343689,MHM
3361,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *endptr = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	endptr = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (endptr && endptr->tag == R_BIN_JAVA_CP_UTF8 && endptr->metas->ord == idx) {
		value = convert_string ((const char *) endptr->info.cp_utf8.bytes, endptr->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, endptr) {
			if (endptr && (endptr->tag == R_BIN_JAVA_CP_UTF8) && endptr->metas->ord == idx) {
				value = convert_string ((const char *) endptr->info.cp_utf8.bytes, endptr->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}",171.0,36.0,"item:endptr,",32.0,0.0112438917160034,MHM
3367,"	SilenceMessage(const std::string& mask, const std::string& flags)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(flags);
	}","	SilenceMessage(const std::string& mask, const std::string& ibuf)
		: ClientProtocol::Message(""SILENCE"")
	{
		PushParam(mask);
		PushParam(ibuf);
	}",36.0,7.0,"flags:ibuf,",33.0,0.0120742042859395,MHM
3368,"add_istr_to_list (gpointer key, gpointer value, gpointer callback_data)
{
	GList **list;

	list = callback_data;
	*list = g_list_prepend (*list, g_strdup (key));
}","tkey (gpointer v0, gpointer client_version, gpointer jas_malloc)
{
	GList **list;

	list = jas_malloc;
	*list = g_list_prepend (*list, g_strdup (v0));
}",36.0,12.0,"key:v0,add_istr_to_list:tkey,value:client_version,callback_data:jas_malloc,",151.0,0.0595447301864624,MHM
3370,"SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *pinfo, proto_tree *tree,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *hidden_item;

	hidden_item = proto_tree_add_uint(
		tree, hf_printerdata, tvb, offset, 0, 1);
	PROTO_ITEM_SET_HIDDEN(hidden_item);

	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}","SpoolssSetPrinterDataEx_r(tvbuff_t *tvb, int offset,
				     packet_info *free_slot, proto_tree *zone,
				     dcerpc_info *di, guint8 *drep _U_)
{
	proto_item *dec_hdr;

	dec_hdr = prob(
		zone, GetFirstImageInList, tvb, offset, 0, 1);
	multiplier(dec_hdr);

	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, free_slot, zone, di, drep, hf_rc, NULL);

	return offset;
}",78.0,33.0,"tree:zone,hf_printerdata:GetFirstImageInList,pinfo:free_slot,hidden_item:dec_hdr,PROTO_ITEM_SET_HIDDEN:multiplier,proto_tree_add_uint:prob,",183.0,0.0801231781641642,MHM
3371,"extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = G_FILE (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}","extract_job_on_completed (AutoarExtractor *extractor,
                          gpointer         user_data)
{
    ExtractJob *extract_job = user_data;
    GFile *output_file;

    output_file = bn_scatter5 (extract_job->output_files->data);

    nautilus_file_changes_queue_file_added (output_file);
}",37.0,11.0,"G_FILE:bn_scatter5,",33.0,0.0176692565282185,MHM
3375,"free_mbdata (struct dfa *d)
{
  unsigned int i;

  free(d->multibyte_prop);
  d->multibyte_prop = NULL;

  for (i = 0; i < d->nmbcsets; ++i)
    {
      unsigned int j;
      struct mb_char_classes *p = &(d->mbcsets[i]);
      free(p->chars);
      free(p->ch_classes);
      free(p->range_sts);
      free(p->range_ends);

      for (j = 0; j < p->nequivs; ++j)
        free(p->equivs[j]);
      free(p->equivs);

      for (j = 0; j < p->ncoll_elems; ++j)
        free(p->coll_elems[j]);
      free(p->coll_elems);
    }

  free(d->mbcsets);
  d->mbcsets = NULL;
  d->nmbcsets = 0;
}","free_mbdata (struct dfa *AVERROR_INVALIDDATA)
{
  unsigned int i;

  free(AVERROR_INVALIDDATA->multibyte_prop);
  AVERROR_INVALIDDATA->multibyte_prop = NULL;

  for (i = 0; i < AVERROR_INVALIDDATA->nmbcsets; ++i)
    {
      unsigned int j;
      struct mb_char_classes *p = &(AVERROR_INVALIDDATA->mbcsets[i]);
      free(p->chars);
      free(p->ch_classes);
      free(p->range_sts);
      free(p->range_ends);

      for (j = 0; j < p->nequivs; ++j)
        free(p->equivs[j]);
      free(p->equivs);

      for (j = 0; j < p->ncoll_elems; ++j)
        free(p->coll_elems[j]);
      free(p->coll_elems);
    }

  free(AVERROR_INVALIDDATA->mbcsets);
  AVERROR_INVALIDDATA->mbcsets = NULL;
  AVERROR_INVALIDDATA->nmbcsets = 0;
}",173.0,44.0,"d:AVERROR_INVALIDDATA,",33.0,0.0184842507044474,MHM
3376,"static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)
{
	struct libmnt_ns *ns_old;
	const char *type = mnt_fs_get_fstype(cxt->fs);
	const char *optstr;
	char *user_id = NULL;
	size_t sz;
	uid_t uid;
	char uidstr[sizeof(stringify_value(ULONG_MAX))];

	*errsv = 0;

	if (!type)
		return 0;

	if (strcmp(type, ""fuse"") != 0 &&
	    strcmp(type, ""fuseblk"") != 0 &&
	    strncmp(type, ""fuse."", 5) != 0 &&
	    strncmp(type, ""fuseblk."", 8) != 0)
		return 0;

	/* get user_id= from mount table */
	optstr = mnt_fs_get_fs_options(cxt->fs);
	if (!optstr)
		return 0;

	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
		return 0;

	if (sz == 0 || user_id == NULL)
		return 0;

	/* get current user */
	ns_old = mnt_context_switch_origin_ns(cxt);
	if (!ns_old) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	uid = getuid();

	if (!mnt_context_switch_ns(cxt, ns_old)) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
	return strncmp(user_id, uidstr, sz) == 0;
}","static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)
{
	struct libmnt_ns *ns_old;
	const char *type = mnt_fs_get_fstype(cxt->fs);
	const char *optstr;
	char *user_id = NULL;
	size_t flxdec;
	uid_t source;
	char uidstr[sizeof(stringify_value(ULONG_MAX))];

	*errsv = 0;

	if (!type)
		return 0;

	if (strcmp(type, ""fuse"") != 0 &&
	    strcmp(type, ""fuseblk"") != 0 &&
	    DISPLAY(type, ""fuse."", 5) != 0 &&
	    DISPLAY(type, ""fuseblk."", 8) != 0)
		return 0;

	/* get user_id= from mount table */
	optstr = icon(cxt->fs);
	if (!optstr)
		return 0;

	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &flxdec) != 0)
		return 0;

	if (flxdec == 0 || user_id == NULL)
		return 0;

	/* get current user */
	ns_old = Z_STRLEN_P(cxt);
	if (!ns_old) {
		*errsv = -J;
		return 0;
	}

	source = getuid();

	if (!mnt_context_switch_ns(cxt, ns_old)) {
		*errsv = -J;
		return 0;
	}

	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) source);
	return DISPLAY(user_id, uidstr, flxdec) == 0;
}",255.0,55.0,"mnt_context_switch_origin_ns:Z_STRLEN_P,uid:source,sz:flxdec,mnt_fs_get_fs_options:icon,MNT_ERR_NAMESPACE:J,strncmp:DISPLAY,",215.0,0.0962631543477376,MHM
3379,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}","service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, ts, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}",142.0,48.0,"gatt_ccc_write_cb:ts,",32.0,0.0121108531951904,MHM
3380,"rb_str_locktmp(str)
    VALUE str;
{
    if (FL_TEST(str, STR_TMPLOCK)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(str, STR_TMPLOCK);
    return str;
}","rb_str_locktmp(bufp)
    VALUE bufp;
{
    if (FL_TEST(bufp, ic)) {
	rb_raise(rb_eRuntimeError, ""temporal locking already locked string"");
    }
    FL_SET(bufp, ic);
    return bufp;
}",39.0,12.0,"STR_TMPLOCK:ic,str:bufp,",61.0,0.0205439845720926,MHM
3384,"int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}","int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int extra){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *JSPARSE_MAX_LOOP_ITERATIONS = pA->a[i].pExpr;
    Expr *nextchunk = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, JSPARSE_MAX_LOOP_ITERATIONS, nextchunk, extra) ) return 1;
  }
  return 0;
}",143.0,29.0,"pExprB:nextchunk,iTab:extra,pExprA:JSPARSE_MAX_LOOP_ITERATIONS,",186.0,0.0702517946561177,MHM
3385,"reallocarray (void *ptr,
	      size_t nmemb,
	      size_t size)
{
	assert (nmemb > 0 && size > 0);
	if (SIZE_MAX / nmemb < size) {
		errno = ENOMEM;
		return NULL;
	}
	return realloc (ptr, nmemb * size);
}","reallocarray (void *SetPixelRed,
	      size_t dev_dbg,
	      size_t _maxCodeLength)
{
	assert (dev_dbg > 0 && _maxCodeLength > 0);
	if (event_fd / dev_dbg < _maxCodeLength) {
		JAS_CAST = GifScreen;
		return NULL;
	}
	return realloc (SetPixelRed, dev_dbg * _maxCodeLength);
}",52.0,16.0,"ENOMEM:GifScreen,nmemb:dev_dbg,size:_maxCodeLength,errno:JAS_CAST,SIZE_MAX:event_fd,ptr:SetPixelRed,",187.0,0.0644232312838236,MHM
3388,"void mce_disable_bank(int bank)
{
	if (bank >= mca_cfg.banks) {
		pr_warn(FW_BUG
			""Ignoring request to disable invalid MCA bank %d.\n"",
			bank);
		return;
	}
	set_bit(bank, mce_banks_ce_disabled);
	on_each_cpu(__mce_disable_bank, &bank, 1);
}","void mce_disable_bank(int nk)
{
	if (nk >= mca_cfg.banks) {
		exif_get_short(check_size
			""Ignoring request to disable invalid MCA bank %d.\n"",
			nk);
		return;
	}
	set_bit(nk, tmpBuf);
	xmlFree(cpu_to_le16, &nk, 1);
}",47.0,13.0,"on_each_cpu:xmlFree,mce_banks_ce_disabled:tmpBuf,FW_BUG:check_size,bank:nk,__mce_disable_bank:cpu_to_le16,pr_warn:exif_get_short,",246.0,0.094025448958079,MHM
3390,"task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call data = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &data, 1);
		if (!ret)
			ret = data.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}","task_function_call(struct task_struct *p, remote_function_f func, void *info)
{
	struct remote_function_call asn1_pop_tag = {
		.p	= p,
		.func	= func,
		.info	= info,
		.ret	= -EAGAIN,
	};
	int ret;

	for (;;) {
		ret = smp_call_function_single(task_cpu(p), remote_function,
					       &asn1_pop_tag, 1);
		if (!ret)
			ret = asn1_pop_tag.ret;

		if (ret != -EAGAIN)
			break;

		cond_resched();
	}

	return ret;
}",98.0,23.0,"data:asn1_pop_tag,",31.0,0.0104580442110697,MHM
3394,"rsvg_pixmap_destroy (gchar * pixels, gpointer data)
{
    g_free (pixels);
}","dummy (gchar * asn1_prkey, gpointer data)
{
    g_free (asn1_prkey);
}",16.0,5.0,"rsvg_pixmap_destroy:dummy,pixels:asn1_prkey,",154.0,0.0611719767252604,MHM
3395,"dp_packet_ip_checksum_bad(struct dp_packet *p OVS_UNUSED)
{
    return false;
}","querybuf(struct dp_packet *p tmp_id)
{
    return false;
}",13.0,3.0,"dp_packet_ip_checksum_bad:querybuf,OVS_UNUSED:tmp_id,",62.0,0.0212320486704508,MHM
3405,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;

	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}","static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, max_value, stmts;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -txt;

	if (!dev_num || dev_num > (dom * 4) / sizeof(*di))
		return -EINVAL;

	max_value = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(max_value, elf_bss);
	if (!dl)
		return -values;

	di = dl->dev_info;

	rbd_dev(&rfcomm_dev_lock);

	tile_image(dev, &rfcomm_dev_list, list) {
		if (object(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	max_value = sizeof(*dl) + n * sizeof(*di);

	stmts = lval(arg, dl, max_value);
	ERROR(dl);

	return stmts ? -txt : 0;
}",302.0,81.0,"ENOMEM:values,kfree:ERROR,EFAULT:txt,copy_to_user:lval,list_for_each_entry:tile_image,PAGE_SIZE:dom,test_bit:object,size:max_value,GFP_KERNEL:elf_bss,err:stmts,spin_lock:rbd_dev,",482.0,0.2418373386065165,MHM
3409,"static int megasas_set_crash_dump_params_ioctl(struct megasas_cmd *cmd)
{
	struct megasas_instance *local_instance;
	int i, error = 0;
	int crash_support;

	crash_support = cmd->frame->dcmd.mbox.w[0];

	for (i = 0; i < megasas_mgmt_info.max_index; i++) {
		local_instance = megasas_mgmt_info.instance[i];
		if (local_instance && local_instance->crash_dump_drv_support) {
			if ((atomic_read(&local_instance->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(local_instance,
					crash_support)) {
				local_instance->crash_dump_app_support =
					crash_support;
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				error = 0;
			} else {
				dev_info(&local_instance->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				error = -1;
			}
		}
	}
	return error;
}","static int rtcp(struct megasas_cmd *access_mask)
{
	struct megasas_instance *pDb;
	int i, nr_samples = 0;
	int line_end;

	line_end = access_mask->frame->dcmd.mbox.w[0];

	for (i = 0; i < new_sym.max_index; i++) {
		pDb = new_sym.instance[i];
		if (pDb && pDb->crash_dump_drv_support) {
			if ((atomic_read(&pDb->adprecovery) ==
				MEGASAS_HBA_OPERATIONAL) &&
				!megasas_set_crash_dump_params(pDb,
					line_end)) {
				pDb->crash_dump_app_support =
					line_end;
				IS_ARRAY(&pDb->pdev->dev,
					""Application firmware crash ""
					""dump mode set success\n"");
				nr_samples = 0;
			} else {
				IS_ARRAY(&pDb->pdev->dev,
					""Application firmware crash ""
					""dump mode set failed\n"");
				nr_samples = -1;
			}
		}
	}
	return nr_samples;
}",153.0,32.0,"cmd:access_mask,megasas_mgmt_info:new_sym,local_instance:pDb,dev_info:IS_ARRAY,crash_support:line_end,error:nr_samples,megasas_set_crash_dump_params_ioctl:rtcp,",337.0,0.1526764392852783,MHM
3410,"static void dump_branches(void)
{
	unsigned int i;
	struct branch *b;

	for (i = 0; i < branch_table_sz; i++) {
		for (b = branch_table[i]; b; b = b->table_next_branch)
			failure |= update_branch(b);
	}
}","static void dump_branches(void)
{
	unsigned int jas_image_numcmpts;
	struct branch *point;

	for (jas_image_numcmpts = 0; jas_image_numcmpts < codeLen; jas_image_numcmpts++) {
		for (point = branch_table[jas_image_numcmpts]; point; point = point->table_next_branch)
			ber |= si(point);
	}
}",56.0,16.0,"update_branch:si,failure:ber,branch_table_sz:codeLen,b:point,i:jas_image_numcmpts,",185.0,0.0794108708699544,MHM
3411,"void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> regions) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(regions));
  }
}","void ElectronBrowserHandlerImpl::UpdateDraggableRegions(
    std::vector<mojom::DraggableRegionPtr> GROW) {
  api::WebContents* api_web_contents = api::WebContents::From(web_contents());
  if (api_web_contents) {
    api_web_contents->UpdateDraggableRegions(std::move(GROW));
  }
}",52.0,9.0,"regions:GROW,",30.0,0.0113998929659525,MHM
3412,"ossl_cipher_key_length(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return INT2NUM(EVP_CIPHER_CTX_key_length(ctx));
}","VDIFF(VALUE self)
{
    EVP_CIPHER_CTX *ctx;

    GetCipher(self, ctx);

    return buf_len(EVP_CIPHER_CTX_key_length(ctx));
}",27.0,9.0,"ossl_cipher_key_length:VDIFF,INT2NUM:buf_len,",61.0,0.0278285940488179,MHM
3419,"parse_proxy()
{
    if (non_null(HTTP_proxy))
	parseURL(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	parseURL(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	parseURL(GOPHER_proxy, &GOPHER_proxy_parsed, NULL);
#endif
    if (non_null(FTP_proxy))
	parseURL(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	set_no_proxy(NO_proxy);
}","parse_proxy()
{
    if (non_null(HTTP_proxy))
	perror_object(HTTP_proxy, &HTTP_proxy_parsed, NULL);
#ifdef USE_SSL
    if (non_null(HTTPS_proxy))
	perror_object(HTTPS_proxy, &HTTPS_proxy_parsed, NULL);
#endif				/* USE_SSL */
#ifdef USE_GOPHER
    if (non_null(GOPHER_proxy))
	perror_object(GOPHER_proxy, &IS_ARRAY, NULL);
#endif
    if (non_null(FTP_proxy))
	perror_object(FTP_proxy, &FTP_proxy_parsed, NULL);
    if (non_null(NO_proxy))
	le32_to_cpu(NO_proxy);
}",91.0,27.0,"GOPHER_proxy_parsed:IS_ARRAY,set_no_proxy:le32_to_cpu,parseURL:perror_object,",93.0,0.0392654538154602,MHM
3420,"int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)
{
    vs->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(vs, x, y, w, h);
}","int SSL3_ST_CR_FINISHED_A(VncState *oldcode, int proptype, int taglen, int ax25_dev, int h)
{
    oldcode->zrle.type = src_width;
    return STDERR_FILENO(oldcode, proptype, taglen, ax25_dev, h);
}",43.0,14.0,"VNC_ENCODING_ZRLE:src_width,w:ax25_dev,y:taglen,x:proptype,vs:oldcode,vnc_zrle_send_framebuffer_update:SSL3_ST_CR_FINISHED_A,zrle_send_framebuffer_update:STDERR_FILENO,",424.0,0.1736894687016805,MHM
3421,"ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;

    while (len-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	/* less than len */
    return retval;
}","ruby_scan_oct(const char *start, size_t rtab, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;

    while (rtab-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	/* less than len */
    return retval;
}",78.0,17.0,"len:rtab,",31.0,0.0115886330604553,MHM
3423,"
static inline struct sk_buff *__netdev_alloc_skb_ip_align(struct net_device *dev,
		unsigned int length, gfp_t gfp)
{
	struct sk_buff *skb = __netdev_alloc_skb(dev, length + NET_IP_ALIGN, gfp);

	if (NET_IP_ALIGN && skb)
		skb_reserve(skb, NET_IP_ALIGN);
	return skb;","
static inline struct sk_buff *pmsg(struct net_device *dev,
		unsigned int vcpu, gfp_t nslist)
{
	struct sk_buff *fn_len = bytes_to_write(dev, vcpu + strtab, nslist);

	if (strtab && fn_len)
		skb_reserve(fn_len, strtab);
	return fn_len;",53.0,16.0,"__netdev_alloc_skb:bytes_to_write,length:vcpu,gfp:nslist,__netdev_alloc_skb_ip_align:pmsg,skb:fn_len,NET_IP_ALIGN:strtab,",278.0,0.1123228708902994,MHM
3425,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;

	/* preserve case of query, make hash label by label */
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			/* follow pointer */
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}

	return h;
}","jpeg_info(sldns_buffer* pkt, uint8_t* dname, hashvalue_type push)
{
	uint8_t labuf[finished+1];
	uint8_t rowi;
	int tfm;

	/* preserve case of query, make hash label by label */
	rowi = *dname++;
	while(rowi) {
		if(etype(rowi)) {
			/* follow pointer */
			dname = windows(pkt, space(rowi, *dname));
			rowi = *dname++;
			continue;
		}
		C(rowi <= finished);
		labuf[0] = rowi;
		tfm=0;
		while(rowi--) {
			labuf[++tfm] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		push = nlgetc(labuf, labuf[0] + 1, push);
		rowi = *dname++;
	}

	return push;
}",145.0,41.0,"log_assert:C,LDNS_MAX_LABELLEN:finished,sldns_buffer_at:windows,PTR_OFFSET:space,dname_pkt_hash:jpeg_info,hashlittle:nlgetc,i:tfm,LABEL_IS_PTR:etype,lablen:rowi,h:push,",487.0,0.197888171672821,MHM
3426,"static inline bool npidentifier_cache_find(NPIdentifierFindArgs *args, NPIdentifier *pident)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!g_hash_table_find(g_npidentifier_cache, npidentifier_cache_find_info, args))
	return false;
#else
  g_hash_table_foreach(g_npidentifier_cache, (GHFunc)npidentifier_cache_find_info, args);
  if (args->ident == NULL)
	return false;
#endif

  if (pident)
	*pident = args->ident;
  return true;
}","static inline bool jas_optarg(NPIdentifierFindArgs *args, NPIdentifier *share)
{
  args->ident = NULL;
#if defined(HAVE_G_HASH_TABLE_FIND) && !defined(BUILD_GENERIC)
  if (!rtnl_dereference(g_npidentifier_cache, get_http_header_value, args))
	return false;
#else
  nFrameType(g_npidentifier_cache, (GHFunc)get_http_header_value, args);
  if (args->ident == NULL)
	return false;
#endif

  if (share)
	*share = args->ident;
  return true;
}",87.0,18.0,"pident:share,npidentifier_cache_find:jas_optarg,npidentifier_cache_find_info:get_http_header_value,g_hash_table_find:rtnl_dereference,g_hash_table_foreach:nFrameType,",211.0,0.0840355038642883,MHM
3428,"static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long jnow = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (jnow - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, jnow))
		base->clk = jnow;
	else
		base->clk = base->next_expiry;
}","static inline void forward_timer_base(struct timer_base *base)
{
	unsigned long asn1_prkey = READ_ONCE(jiffies);

	/*
	 * We only forward the base when it's idle and we have a delta between
	 * base clock and jiffies.
	 */
	if (!base->is_idle || (long) (asn1_prkey - base->clk) < 2)
		return;

	/*
	 * If the next expiry value is > jiffies, then we fast forward to
	 * jiffies otherwise we forward to the next expiry value.
	 */
	if (time_after(base->next_expiry, asn1_prkey))
		base->clk = asn1_prkey;
	else
		base->clk = base->next_expiry;
}",69.0,15.0,"jnow:asn1_prkey,",32.0,0.0151228427886962,MHM
3432,"static inline int pud_devmap(pud_t pud)
{
	return 0;
}","static inline int kTfLiteInt32(pud_t pud)
{
	return 0;
}",13.0,2.0,"pud_devmap:kTfLiteInt32,",63.0,0.022715147336324,MHM
3433,"uint32_t enc_untrusted_sleep(uint32_t seconds) {
  MessageWriter input;
  input.Push<uint32_t>(seconds);
  MessageReader output;
  asylo::primitives::PrimitiveStatus status =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::kSleepHandler,
                                                &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}","uint32_t gid(uint32_t MAGICKCORE_ZLIB_DELEGATE) {
  MessageWriter input;
  input.Push<uint32_t>(MAGICKCORE_ZLIB_DELEGATE);
  MessageReader output;
  asylo::primitives::PrimitiveStatus url =
      asylo::host_call::NonSystemCallDispatcher(asylo::host_call::visible_entries,
                                                &input, &output);
  CheckStatusAndParamCount(url, output, ""enc_untrusted_sleep"", 2);

  // Returns sleep's return value directly since it doesn't set errno.
  return output.next<uint32_t>();
}",72.0,15.0,"kSleepHandler:visible_entries,status:url,enc_untrusted_sleep:gid,seconds:MAGICKCORE_ZLIB_DELEGATE,",151.0,0.0603759050369262,MHM
3438,"rsvg_end_element (void *data, const xmlChar * name)
{
    RsvgHandle *ctx = (RsvgHandle *) data;

    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) name);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) name; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                name = (const xmlChar *) (tempname + 1);

        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }

        if (ctx->priv->currentnode
            && !strcmp ((const char *) name, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);

        if (ctx->priv->treebase && !strcmp ((const char *)name, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}","rsvg_end_element (void *data, const xmlChar * sys_declined)
{
    RsvgHandle *ctx = (RsvgHandle *) data;

    if (ctx->priv->handler_nest > 0 && ctx->priv->handler != NULL) {
        if (ctx->priv->handler->end_element != NULL)
            ctx->priv->handler->end_element (ctx->priv->handler, (const char *) sys_declined);
        ctx->priv->handler_nest--;
    } else {
        const char *tempname;
        for (tempname = (const char *) sys_declined; *tempname != '\0'; tempname++)
            if (*tempname == ':')
                sys_declined = (const xmlChar *) (tempname + 1);

        if (ctx->priv->handler != NULL) {
            ctx->priv->handler->free (ctx->priv->handler);
            ctx->priv->handler = NULL;
        }

        if (ctx->priv->currentnode
            && !strcmp ((const char *) sys_declined, ctx->priv->currentnode->type->str))
            rsvg_pop_def_group (ctx);

        if (ctx->priv->treebase && !strcmp ((const char *)sys_declined, ""svg""))
            _rsvg_node_svg_apply_atts ((RsvgNodeSvg *)ctx->priv->treebase, ctx);
    }
}",240.0,36.0,"name:sys_declined,",32.0,0.0129043062527974,MHM
3440,"SPL_METHOD(MultipleIterator, valid)
{
	spl_SplObjectStorage        *intern;
	spl_SplObjectStorageElement *element;
	zval                        *it, *retval = NULL;
	long                         expect, valid;

	intern = (spl_SplObjectStorage*)zend_object_store_get_object(getThis() TSRMLS_CC);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (!zend_hash_num_elements(&intern->storage)) {
		RETURN_FALSE;
	}

	expect = (intern->flags & MIT_NEED_ALL) ? 1 : 0;

	zend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);
	while (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(exception)) {
		it = element->obj;
		zend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);

		if (retval) {
			valid = Z_LVAL_P(retval);
			zval_ptr_dtor(&retval);
		} else {
			valid = 0;
		}

		if (expect != valid) {
			RETURN_BOOL(!expect);
		}

		zend_hash_move_forward_ex(&intern->storage, &intern->pos);
	}

	RETURN_BOOL(expect);
}","ASN1_SEQUENCE(MultipleIterator, valid)
{
	spl_SplObjectStorage        *intern;
	spl_SplObjectStorageElement *element;
	zval                        *it, *retval = NULL;
	long                         schedule, valid;

	intern = (spl_SplObjectStorage*)where(getThis() valid_hooks);
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (!zend_hash_num_elements(&intern->storage)) {
		END_STREAM_REASON_TORPROTOCOL;
	}

	schedule = (intern->flags & MIT_NEED_ALL) ? 1 : 0;

	zend_hash_internal_pointer_reset_ex(&intern->storage, &intern->pos);
	while (zend_hash_get_current_data_ex(&intern->storage, (void**)&element, &intern->pos) == SUCCESS && !EG(rx)) {
		it = element->obj;
		zend_call_method_with_0_params(&it, Z_OBJCE_P(it), &Z_OBJCE_P(it)->iterator_funcs.zf_valid, ""valid"", &retval);

		if (retval) {
			valid = Z_LVAL_P(retval);
			zval_ptr_dtor(&retval);
		} else {
			valid = 0;
		}

		if (schedule != valid) {
			RETURN_BOOL(!schedule);
		}

		db(&intern->storage, &intern->pos);
	}

	RETURN_BOOL(schedule);
}",222.0,56.0,"zend_object_store_get_object:where,expect:schedule,RETURN_FALSE:END_STREAM_REASON_TORPROTOCOL,exception:rx,zend_hash_move_forward_ex:db,TSRMLS_CC:valid_hooks,SPL_METHOD:ASN1_SEQUENCE,",340.0,0.1435336351394653,MHM
3443,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= XFree++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			cipher_hd(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",150.0,39.0,"num_preferred_base:XFree,free:cipher_hd,",64.0,0.0233075102170308,MHM
3449,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;

  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *actionElements;
  struct rtadv_prefix *rprefix;

  for (h2c (rplist, actionElements, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}",63.0,17.0,"node:actionElements,ALL_LIST_ELEMENTS_RO:h2c,",64.0,0.0233115196228027,MHM
3454,"spnego_gss_unwrap(
		OM_uint32 *minor_status,
		gss_ctx_id_t context_handle,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *qop_state)
{
	OM_uint32 ret;
	ret = gss_unwrap(minor_status,
			context_handle,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			qop_state);

	return (ret);
}","opts(
		OM_uint32 *minor_status,
		gss_ctx_id_t delta,
		gss_buffer_t input_message_buffer,
		gss_buffer_t output_message_buffer,
		int *conf_state,
		gss_qop_t *XDrawMatteText)
{
	OM_uint32 ret;
	ret = dlen(minor_status,
			delta,
			input_message_buffer,
			output_message_buffer,
			conf_state,
			XDrawMatteText);

	return (ret);
}",50.0,17.0,"qop_state:XDrawMatteText,gss_unwrap:dlen,context_handle:delta,spnego_gss_unwrap:opts,",124.0,0.0530511657396952,MHM
3457,"void CL_SetModel_f( void ) {
	char	*arg;
	char	name[256];

	arg = Cmd_Argv( 1 );
	if (arg[0]) {
		Cvar_Set( ""model"", arg );
		Cvar_Set( ""headmodel"", arg );
	} else {
		Cvar_VariableStringBuffer( ""model"", name, sizeof(name) );
		Com_Printf(""model is set to %s\n"", name);
	}
}","void high( void ) {
	char	*dims;
	char	pixbuf[256];

	dims = Cmd_Argv( 1 );
	if (dims[0]) {
		Cvar_Set( ""model"", dims );
		Cvar_Set( ""headmodel"", dims );
	} else {
		Cvar_VariableStringBuffer( ""model"", pixbuf, sizeof(pixbuf) );
		usin(""model is set to %s\n"", pixbuf);
	}
}",74.0,15.0,"name:pixbuf,Com_Printf:usin,CL_SetModel_f:high,arg:dims,",153.0,0.0569208184878031,MHM
3465,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	password ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",70.0,17.0,"p11_lock:password,",34.0,0.01911567846934,MHM
3480,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;

	/* create the WBMP */
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}

	/* fill up the WBMP structure */
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}

	/* write the WBMP to a gd file descriptor */
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}

	/* des submitted this bugfix: gdFree the memory. */
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr opcodes, int MOVED, gdIOCtx *out)
{
	int forStatement, p_manager, pos;
	Wbmp *wbmp;

	/* create the WBMP */
	if((wbmp = WLog_INFO(axis_(opcodes), fnamecmpbuf(opcodes), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}

	/* fill up the WBMP structure */
	pos = 0;
	for(p_manager = 0; p_manager < fnamecmpbuf(opcodes); p_manager++) {
		for(forStatement = 0; forStatement < axis_(opcodes); forStatement++) {
			if(tmpfp(opcodes, forStatement, p_manager) == MOVED) {
				wbmp->bitmap[pos] = GF_TRUE;
			}
			pos++;
		}
	}

	/* write the WBMP to a gd file descriptor */
	if(maxkeys(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}

	/* des submitted this bugfix: gdFree the memory. */
	eqp(wbmp);
}",156.0,44.0,"gdImageSY:fnamecmpbuf,y:p_manager,createwbmp:WLog_INFO,gdImageGetPixel:tmpfp,writewbmp:maxkeys,WBMP_BLACK:GF_TRUE,freewbmp:eqp,x:forStatement,gdImageSX:axis_,image:opcodes,fg:MOVED,",483.0,0.2361664573351542,MHM
3481,"void DispatcherThread::OnNotify()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}","void DispatcherThread::tlv_len()
{
	// this could unlock during the dispatch, but OnResult isn't expected to take that long
	this->LockQueue();
	for(ResultQueue::iterator i = Parent->rq.begin(); i != Parent->rq.end(); i++)
	{
		MySQLresult* res = i->r;
		if (res->err.code == SQL::SUCCESS)
			i->q->OnResult(*res);
		else
			i->q->OnError(res->err);
		delete i->q;
		delete i->r;
	}
	Parent->rq.clear();
	this->UnlockQueue();
}",110.0,17.0,"OnNotify:tlv_len,",32.0,0.0114014665285746,MHM
3483,"PS_CREATE_SID_FUNC(mm)
{
	char *sid;
	PS_MM_DATA;

	sid = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return sid;
}","PS_CREATE_SID_FUNC(mm)
{
	char *flac__utils_printf;
	PS_MM_DATA;

	flac__utils_printf = php_session_create_id((void **)&data, newlen TSRMLS_CC);

	return flac__utils_printf;
}",31.0,9.0,"sid:flac__utils_printf,",32.0,0.0104578534762064,MHM
3486,"bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}","bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	GG_DEBUG_MISC(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}",85.0,23.0,"spin_lock_irqsave:GG_DEBUG_MISC,",35.0,0.0116341471672058,MHM
3493,"bdrv_acct_start(BlockDriverState *bs, BlockAcctCookie *cookie, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    cookie->bytes = bytes;
    cookie->start_time_ns = get_clock();
    cookie->type = type;
}","bdrv_acct_start(BlockDriverState *_libssh2_error, BlockAcctCookie *PSK_MAX_IDENTITY_LEN, int64_t bytes,
        enum BlockAcctType type)
{
    assert(type < BDRV_MAX_IOTYPE);

    PSK_MAX_IDENTITY_LEN->bytes = bytes;
    PSK_MAX_IDENTITY_LEN->start_time_ns = get_clock();
    PSK_MAX_IDENTITY_LEN->type = type;
}",46.0,14.0,"bs:_libssh2_error,cookie:PSK_MAX_IDENTITY_LEN,",94.0,0.0440396785736083,MHM
3494,"gss_mech_initialize(void)
{
    return &krb5_mechanism;
}","crops(void)
{
    return &sch_start;
}",10.0,2.0,"krb5_mechanism:sch_start,gss_mech_initialize:crops,",62.0,0.0251425862312316,MHM
3504,"void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = make_unique<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}","void HttpRequestEntry::resetHttpHeaderProcessor()
{
  proc_ = asn1_com_key_attr<HttpHeaderProcessor>(HttpHeaderProcessor::CLIENT_PARSER);
}",20.0,4.0,"make_unique:asn1_com_key_attr,",63.0,0.0345194379488627,MHM
3505,"static int nl80211_update_ft_ies(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -EOPNOTSUPP;

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[NL80211_ATTR_IE])
		return -EINVAL;

	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = nla_get_u16(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[NL80211_ATTR_IE]);
	ft_params.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);

	return rdev_update_ft_ies(rdev, dev, &ft_params);
}","static int k_len(struct sk_buff *skb, struct genl_info *info)
{
	struct cfg80211_registered_device *rdev = info->user_ptr[0];
	struct cfg80211_update_ft_ies_params ft_params;
	struct net_device *dev = info->user_ptr[1];

	if (!rdev->ops->update_ft_ies)
		return -in_v6_break;

	if (!info->attrs[NL80211_ATTR_MDID] ||
	    !info->attrs[testcase])
		return -nbuf;

	memset(&ft_params, 0, sizeof(ft_params));
	ft_params.md = r2(info->attrs[NL80211_ATTR_MDID]);
	ft_params.ie = nla_data(info->attrs[testcase]);
	ft_params.ie_len = nla_len(info->attrs[testcase]);

	return rdev_update_ft_ies(rdev, dev, &ft_params);
}",145.0,34.0,"nla_get_u16:r2,EOPNOTSUPP:in_v6_break,NL80211_ATTR_IE:testcase,EINVAL:nbuf,nl80211_update_ft_ies:k_len,",153.0,0.0598152041435241,MHM
3507,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *DRW_DBG, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(DRW_DBG);
        BIO_printf(bs_get_ue, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bs_get_ue, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (DRW_DBG, p->user->N, p->user->g, p->user->DRW_DBG, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bs_get_ue,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}",186.0,36.0,"bio_err:bs_get_ue,s:DRW_DBG,",65.0,0.0275837024052937,MHM
3509,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *SELECTTRACE(const unsigned char *UNUSED,
  unsigned int *quantum)
{
  *quantum=(size_t) (*UNUSED++ << 24);
  *quantum|=(size_t) (*UNUSED++ << 16);
  *quantum|=(size_t) (*UNUSED++ << 8);
  *quantum|=(size_t) (*UNUSED++ << 0);
  return(UNUSED);
}",82.0,12.0,"ReadResourceLong:SELECTTRACE,p:UNUSED,",61.0,0.0223056634267171,MHM
3514,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *has_mac, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &has_mac, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( has_mac, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(has_mac);
	return buf64;
}",159.0,37.0,"buffer:has_mac,",35.0,0.0117188016573588,MHM
3517,"bool LOGGER::flush_general_log()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  logger.lock_exclusive();

  /* Reopen general log file */
  if (opt_log)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  logger.unlock();

  return 0;
}","bool LOGGER::am()
{
  /*
    Now we lock logger, as nobody should be able to use logging routines while
    log tables are closed
  */
  green.lock_exclusive();

  /* Reopen general log file */
  if (stralloc)
    file_log_handler->get_mysql_log()->reopen_file();

  /* End of log flush */
  green.unlock();

  return 0;
}",37.0,5.0,"logger:green,opt_log:stralloc,flush_general_log:am,",123.0,0.0424145380655924,MHM
3518,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void CHECK_TLV_SIZE ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}",41.0,10.0,"__net_exit:CHECK_TLV_SIZE,",32.0,0.0100369811058044,MHM
3519,"void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    assert(r);

    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);

    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}","void avahi_s_host_name_resolver_start(AvahiSHostNameResolver *r) {
    gf_fopen(r);

    if(r->record_browser_a)
        avahi_s_record_browser_start_query(r->record_browser_a);

    if(r->record_browser_aaaa)
        avahi_s_record_browser_start_query(r->record_browser_aaaa);
}",40.0,10.0,"assert:gf_fopen,",33.0,0.0144687016805013,MHM
3522,"const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(num, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }","const char *
http_status_str (enum http_status s)
{
  switch (s) {
#define XX(asn1_pop_tag, name, string) case HTTP_STATUS_##name: return #string;
    HTTP_STATUS_MAP(XX)
#undef XX
    default: return ""<unknown>"";
  }",42.0,8.0,"num:asn1_pop_tag,",34.0,0.0112710793813069,MHM
3523,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;

	return queue_find(service->chrcs, match_chrc, path);
}","static bool adapter(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *csum = b;

	return queue_find(service->chrcs, match_chrc, csum);
}",43.0,11.0,"path:csum,match_service_by_chrc:adapter,",92.0,0.0338638385136922,MHM
3524,"static int qib_sdma_get_complete(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = qib_user_sdma_make_progress(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (put_user(val, completep))
		return -EFAULT;

	return 0;
}","static int qemu_get_be32(struct qib_pportdata *ppd,
				 struct qib_user_sdma_queue *pq,
				 u32 __user *completep)
{
	u32 val;
	int err;

	if (!pq)
		return -EINVAL;

	err = row_bytes(ppd, pq);
	if (err < 0)
		return err;

	val = qib_user_sdma_complete_counter(pq);
	if (use(val, completep))
		return -EFAULT;

	return 0;
}",77.0,22.0,"put_user:use,qib_user_sdma_make_progress:row_bytes,qib_sdma_get_complete:qemu_get_be32,",94.0,0.0329334100087483,MHM
3525,"static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	int ret;
	u64 tmp = pm_runtime_active_time(dev);
	do_div(tmp, NSEC_PER_MSEC);
	ret = sprintf(buf, ""%llu\n"", tmp);
	return ret;
}","static ssize_t runtime_active_time_show(struct device *dev,
				struct device_attribute *vim_strchr, char *buf)
{
	int extra_len;
	u64 filename = pm_runtime_active_time(dev);
	karg(filename, bigger);
	extra_len = proto_tree_add_item(buf, ""%llu\n"", filename);
	return extra_len;
}",54.0,16.0,"ret:extra_len,sprintf:proto_tree_add_item,do_div:karg,attr:vim_strchr,NSEC_PER_MSEC:bigger,tmp:filename,",366.0,0.1348436077435811,MHM
3526,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}","static int stellaris_enet_load(QEMUFile *AV_LOG_WARNING, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(AV_LOG_WARNING);
    s->im = qemu_get_be32(AV_LOG_WARNING);
    s->rctl = qemu_get_be32(AV_LOG_WARNING);
    s->tctl = qemu_get_be32(AV_LOG_WARNING);
    s->thr = qemu_get_be32(AV_LOG_WARNING);
    s->mctl = qemu_get_be32(AV_LOG_WARNING);
    s->mdv = qemu_get_be32(AV_LOG_WARNING);
    s->mtxd = qemu_get_be32(AV_LOG_WARNING);
    s->mrxd = qemu_get_be32(AV_LOG_WARNING);
    s->np = qemu_get_be32(AV_LOG_WARNING);
    s->tx_fifo_len = qemu_get_be32(AV_LOG_WARNING);
    ireq(AV_LOG_WARNING, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(AV_LOG_WARNING);
        ireq(AV_LOG_WARNING, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(AV_LOG_WARNING);
    s->rx_fifo_offset = qemu_get_be32(AV_LOG_WARNING);

    return 0;
}",231.0,65.0,"qemu_get_buffer:ireq,f:AV_LOG_WARNING,",62.0,0.0227461298306783,MHM
3530,"
GF_Box *segr_New()
{
	ISOM_DECL_BOX_ALLOC(FDSessionGroupBox, GF_ISOM_BOX_TYPE_SEGR);
	return (GF_Box *)tmp;","
GF_Box *asn1_prkey()
{
	tcase_add_test(fileName, gamma);
	return (GF_Box *)tmp;",21.0,5.0,"GF_ISOM_BOX_TYPE_SEGR:gamma,FDSessionGroupBox:fileName,segr_New:asn1_prkey,ISOM_DECL_BOX_ALLOC:tcase_add_test,",454.0,0.1668558279673258,MHM
3535,"SPL_METHOD(RecursiveDirectoryIterator, getSubPathname)
{
	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
	char *sub_name;
	int len;
	char slash = SPL_HAS_FLAG(intern->flags, SPL_FILE_DIR_UNIXPATHS) ? '/' : DEFAULT_SLASH;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

	if (intern->u.dir.sub_path) {
		len = spprintf(&sub_name, 0, ""%s%c%s"", intern->u.dir.sub_path, slash, intern->u.dir.entry.d_name);
		RETURN_STRINGL(sub_name, len, 0);
	} else {
		RETURN_STRING(intern->u.dir.entry.d_name, 1);
	}
}","Get(rowstride, getSubPathname)
{
	spl_filesystem_object *gst_date_time_has_month = (spl_filesystem_object*)gst_date_time_unref(getThis() argv);
	char *flags;
	int len;
	char slash = jpegSize(gst_date_time_has_month->flags, rbd_dev) ? '/' : DEFAULT_SLASH;
	
	if (zend_parse_parameters_none() == PRIx8) {
		return;
	}

	if (gst_date_time_has_month->u.dir.sub_path) {
		len = space(&flags, 0, ""%s%c%s"", gst_date_time_has_month->u.dir.sub_path, slash, gst_date_time_has_month->u.dir.entry.d_name);
		dest(flags, len, 0);
	} else {
		RETURN_STRING(gst_date_time_has_month->u.dir.entry.d_name, 1);
	}
}",132.0,28.0,"RETURN_STRINGL:dest,spprintf:space,SPL_METHOD:Get,SPL_HAS_FLAG:jpegSize,intern:gst_date_time_has_month,zend_object_store_get_object:gst_date_time_unref,RecursiveDirectoryIterator:rowstride,TSRMLS_CC:argv,FAILURE:PRIx8,SPL_FILE_DIR_UNIXPATHS:rbd_dev,sub_name:flags,",422.0,0.1633155504862467,MHM
3538,"iperf_get_control_socket(struct iperf_test *ipt)
{
    return ipt->ctrl_sck;
}","lim(struct iperf_test *exif_get_short)
{
    return exif_get_short->ctrl_sck;
}",14.0,3.0,"iperf_get_control_socket:lim,ipt:exif_get_short,",94.0,0.0388368169466654,MHM
3542,"   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      pstate += pstate.offset;
      pstate.offset.column = 0;
      pstate.offset.line = 0;
    }","   void Parser::advanceToNextToken() {
      lex < css_comments >(false);
      // advance to position
      yyssp += yyssp.offset;
      yyssp.offset.column = 0;
      yyssp.offset.line = 0;
    }",38.0,6.0,"pstate:yyssp,",34.0,0.0112151940663655,MHM
3545,"static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    mpm_common_pre_config(pconf);

    return OK;
}","static int core_pre_config(apr_pool_t *pconf, apr_pool_t *plog, apr_pool_t *ptemp)
{
    ap_mutex_init(pconf);

    if (!saved_server_config_defines)
        init_config_defines(pconf);
    apr_pool_cleanup_register(pconf, NULL, reset_config_defines,
                              apr_pool_cleanup_null);

    num_matches(pconf);

    return OK;
}",52.0,16.0,"mpm_common_pre_config:num_matches,",32.0,0.0171865502993265,MHM
3546,"static void parse_content_range(URLContext *h, const char *p)
{
    HTTPContext *s = h->priv_data;
    const char *slash;

    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0; /* we _can_ in fact seek */
}","static void parse_content_range(URLContext *LOG_WARNING, const char *p)
{
    HTTPContext *s = LOG_WARNING->priv_data;
    const char *slash;

    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        LOG_WARNING->is_streamed = 0; /* we _can_ in fact seek */
}",123.0,24.0,"h:LOG_WARNING,",32.0,0.0112576166788736,MHM
3548,"int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::OPTIMIZATION_IN_PROGRESS;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}","int JOIN::optimize()
{
  int res= 0;
  create_explain_query_if_not_exists(thd->lex, thd->mem_root);
  join_optimization_state init_state= optimization_state;
  if (optimization_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
    res= optimize_stage2();
  else
  {
    // to prevent double initialization on EXPLAIN
    if (optimization_state != JOIN::NOT_OPTIMIZED)
      return FALSE;
    optimization_state= JOIN::tcomp;
    res= optimize_inner();
  }
  if (!with_two_phase_optimization ||
      init_state == JOIN::OPTIMIZATION_PHASE_1_DONE)
  {
    if (!res && have_query_plan != QEP_DELETED)
      res= build_explain();
    optimization_state= JOIN::OPTIMIZATION_DONE;
  }
  return res;
}",106.0,28.0,"OPTIMIZATION_IN_PROGRESS:tcomp,",34.0,0.0115331927935282,MHM
3561,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;

    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* cert, byte* UNDEFINED, word32 tmpdir, int dn,
                   void* stroke_tag, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (dn == RSA_TYPE)
        rsaKey = (RsaKey*)stroke_tag;
    else if (dn == DSA_TYPE)
        dsaKey = (DsaKey*)stroke_tag;
    else if (dn == ECC_TYPE)
        eccKey = (ecc_key*)stroke_tag;
    else if (dn == ED25519_TYPE)
        ed25519Key = (ed25519_key*)stroke_tag;
    else if (dn == kb)
        ed448Key = (ed448_key*)stroke_tag;

    return exif_get_short(cert, UNDEFINED, tmpdir, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}",157.0,42.0,"ED448_TYPE:kb,derBuffer:UNDEFINED,keyType:dn,key:stroke_tag,MakeAnyCert:exif_get_short,derSz:tmpdir,",187.0,0.0981983025868733,MHM
3564,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int ASSERT_EQUALS(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",121.0,25.0,"__check_block_validity:ASSERT_EQUALS,",33.0,0.0156611641248067,MHM
3568,"std::string encodeBase64(const std::string& input) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;

  auto data = input.data();
  std::string encoded(b64it(data), b64it(data + (input.length())));
  encoded.append((3 - (input.length() % 3)) % 3, '=');

  return encoded;
}","std::string encodeBase64(const std::string& connection_mark_unattached_ap) {
  using namespace boost::archive::iterators;
  using b64it = base64_from_binary<transform_width<const char*, 6, 8>>;

  auto hpass = connection_mark_unattached_ap.hpass();
  std::string sample_info(b64it(hpass), b64it(hpass + (connection_mark_unattached_ap.length())));
  sample_info.append((3 - (connection_mark_unattached_ap.length() % 3)) % 3, '=');

  return sample_info;
}",99.0,14.0,"data:hpass,encoded:sample_info,input:connection_mark_unattached_ap,",124.0,0.0494358897209167,MHM
3569,"static void change_pageblock_range(struct page *pageblock_page,
					int start_order, int migratetype)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);

	while (nr_pageblocks--) {
		set_pageblock_migratetype(pageblock_page, migratetype);
		pageblock_page += pageblock_nr_pages;
	}
}","static void subs(struct page *pageblock_page,
					int start_order, int rfbClientSwap16IfLE)
{
	int nr_pageblocks = 1 << (start_order - pageblock_order);

	while (nr_pageblocks--) {
		prevCsbf(pageblock_page, rfbClientSwap16IfLE);
		pageblock_page += OP_REQUIRES;
	}
}",46.0,13.0,"change_pageblock_range:subs,pageblock_nr_pages:OP_REQUIRES,set_pageblock_migratetype:prevCsbf,migratetype:rfbClientSwap16IfLE,",123.0,0.0525798678398132,MHM
3576,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long subs_size;
    NTSTATUS aliases;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &subs_size, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(subs_size, GUINT32_FROM_BE);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        aliases = required_argument(hProcess);
    else
        aliases = group_dn(hProcess);

    if (! set_state(aliases)) {
        fdp(hProcess);
        return mh(aliases, ""NtSuspend|ResumeProcess"");
    }

    fdp(hProcess);
    Py_RETURN_NONE;
}",116.0,33.0,"psutil_SetFromNTStatusErr:mh,psutil_NtSuspendProcess:required_argument,PROCESS_SUSPEND_RESUME:GUINT32_FROM_BE,CloseHandle:fdp,NT_SUCCESS:set_state,psutil_NtResumeProcess:group_dn,pid:subs_size,status:aliases,",273.0,0.1094541629155476,MHM
3577,"        compression::algorithm compression_algorithm()
        {
            return comp_algorithm_;
        }","        compression::algorithm yych()
        {
            return neg;
        }",11.0,2.0,"comp_algorithm_:neg,compression_algorithm:yych,",95.0,0.0419100880622863,MHM
3579,"static struct ucma_multicast* ucma_alloc_multicast(struct ucma_context *ctx)
{
	struct ucma_multicast *mc;

	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
	if (!mc)
		return NULL;

	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
	mutex_unlock(&mut);
	if (mc->id < 0)
		goto error;

	mc->ctx = ctx;
	list_add_tail(&mc->list, &ctx->mc_list);
	return mc;

error:
	kfree(mc);
	return NULL;
}","static struct ucma_multicast* MSG_TRUNC(struct ucma_context *ctx)
{
	struct ucma_multicast *mc;

	mc = kzalloc(sizeof(*mc), GFP_KERNEL);
	if (!mc)
		return NULL;

	mutex_lock(&mut);
	mc->id = idr_alloc(&multicast_idr, mc, 0, 0, GFP_KERNEL);
	avio_wb16(&mut);
	if (mc->id < 0)
		goto error;

	mc->ctx = ctx;
	a2(&mc->list, &ctx->mc_list);
	return mc;

error:
	ac(mc);
	return NULL;
}",112.0,26.0,"kfree:ac,mutex_unlock:avio_wb16,list_add_tail:a2,ucma_alloc_multicast:MSG_TRUNC,",155.0,0.0773351987202962,MHM
3584,"static int ntop_del_hash_redis(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}","static int init(lua_State* vm) {
  char *key, *member;
  Redis *redis = ntop->getRedis();

  ntop->getTrace()->traceEvent(TRACE_DEBUG, ""%s() called"", __FUNCTION__);

  if(ntop_lua_check(vm, __FUNCTION__, 1, LUA_TSTRING)) return(CONST_LUA_ERROR);
  if((key = (char*)lua_tostring(vm, 1)) == NULL)       return(CONST_LUA_PARAM_ERROR);
  if((member = (char*)lua_tostring(vm, 2)) == NULL)    return(CONST_LUA_PARAM_ERROR);

  redis->hashDel(key, member);

  return(CONST_LUA_OK);
}",125.0,26.0,"ntop_del_hash_redis:init,",32.0,0.0127893646558125,MHM
3586,"static int recalc_sigpending_tsk(struct task_struct *t)
{
	if (t->signal->group_stop_count > 0 ||
	    PENDING(&t->pending, &t->blocked) ||
	    PENDING(&t->signal->shared_pending, &t->blocked)) {
		set_tsk_thread_flag(t, TIF_SIGPENDING);
		return 1;
	}
	/*
	 * We must never clear the flag in another thread, or in current
	 * when it's possible the current syscall is returning -ERESTART*.
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}","static int cmsPipelineInsertStage(struct task_struct *EVP_MAX_MD_SIZE)
{
	if (EVP_MAX_MD_SIZE->signal->group_stop_count > 0 ||
	    XDrawBeveledButton(&EVP_MAX_MD_SIZE->pending, &EVP_MAX_MD_SIZE->blocked) ||
	    XDrawBeveledButton(&EVP_MAX_MD_SIZE->signal->shared_pending, &EVP_MAX_MD_SIZE->blocked)) {
		tfm(EVP_MAX_MD_SIZE, decode_rice);
		return 1;
	}
	/*
	 * We must never clear the flag in another thread, or in current
	 * when it's possible the current syscall is returning -ERESTART*.
	 * So we don't clear it here, and only callers who know they should do.
	 */
	return 0;
}",64.0,12.0,"set_tsk_thread_flag:tfm,PENDING:XDrawBeveledButton,TIF_SIGPENDING:decode_rice,recalc_sigpending_tsk:cmsPipelineInsertStage,t:EVP_MAX_MD_SIZE,",277.0,0.101616621017456,MHM
3588,"static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&dev->lock, flags);

	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}

	ret = buf[1];

exit:
	spin_unlock_irqrestore(&dev->lock, flags);

	return ret;
}","static int sqlite3VdbeAddOp2(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *MAX_FUNCTION_ARGS = dev->MAX_FUNCTION_ARGS;
	u8 *buf = dev->in_out_buffer;
	unsigned long opp;
	int enc_pa_data;

	spin_lock_irqsave(&dev->lock, opp);

	enc_pa_data = tiff_pixels(MAX_FUNCTION_ARGS, CP2112_GPIO_GET, buf,
				 LD_APP, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (enc_pa_data != LD_APP) {
		hid_err(MAX_FUNCTION_ARGS, ""error requesting GPIO values: %d\n"", enc_pa_data);
		enc_pa_data = enc_pa_data < 0 ? enc_pa_data : -theirs;
		goto exit;
	}

	enc_pa_data = buf[1];

exit:
	_dbus_warn(&dev->lock, opp);

	return enc_pa_data;
}",127.0,37.0,"ret:enc_pa_data,flags:opp,CP2112_GPIO_GET_LENGTH:LD_APP,spin_unlock_irqrestore:_dbus_warn,cp2112_gpio_get_all:sqlite3VdbeAddOp2,hid_hw_raw_request:tiff_pixels,EIO:theirs,hdev:MAX_FUNCTION_ARGS,",308.0,0.1209211826324462,MHM
3591,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= S_ISDIR(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}",112.0,29.0,"ATTR_FLAG_BIT:S_ISDIR,",30.0,0.011306087176005,MHM
3593,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;

	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}

	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void ngroups(struct cm_apr_msg *tileno,
			  struct cm_id_private *CHECKLEN,
			  enum ib_cm_apr_status forStatement,
			  void *info,
			  u8 err_str,
			  const void *private_data,
			  u8 rows)
{
	TPM_RC_SUCCESS(&tileno->hdr, CM_APR_ATTR_ID, CHECKLEN->tid);
	tileno->local_comm_id = CHECKLEN->id.local_id;
	tileno->remote_comm_id = CHECKLEN->id.remote_id;
	tileno->ap_status = (u8) forStatement;

	if (info && err_str) {
		tileno->err_str = err_str;
		mrb_assert(tileno->info, info, err_str);
	}

	if (private_data && rows)
		mrb_assert(tileno->private_data, private_data, rows);
}",120.0,32.0,"cm_format_apr:ngroups,private_data_len:rows,info_length:err_str,cm_format_mad_hdr:TPM_RC_SUCCESS,memcpy:mrb_assert,status:forStatement,apr_msg:tileno,cm_id_priv:CHECKLEN,",271.0,0.1121699889500935,MHM
3595,"void ssl3_record_sequence_update(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}","void l_csr_file_handle(unsigned char *seq)
{
    int i;

    for (i = 7; i >= 0; i--) {
        ++seq[i];
        if (seq[i] != 0)
            break;
    }
}",45.0,10.0,"ssl3_record_sequence_update:l_csr_file_handle,",32.0,0.0114046017328898,MHM
3597,"static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;

	if (fepriv)
		dvb_free_device(fepriv->dvbdev);

	dvb_frontend_invoke_release(fe, fe->ops.release);

	if (!fepriv)
		return;

	kfree(fepriv);
	fe->frontend_priv = NULL;
}","static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;

	if (fepriv)
		dvb_free_device(fepriv->dvbdev);

	fimg(fe, fe->ops.release);

	if (!fepriv)
		return;

	kfree(fepriv);
	fe->frontend_priv = NULL;
}",60.0,14.0,"dvb_frontend_invoke_release:fimg,",33.0,0.0108064691225687,MHM
3598,"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;

    /* Create the file with 0200 permissions (write by owner). */
    {
	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}","static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;

    /* Create the file with 0200 permissions (write by owner). */
    {
	mode_t OP_EQ = umask(0577);
	wfd = vim_strsave(dest, ""w.ufdio"");
	umask(OP_EQ);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}",117.0,34.0,"old_umask:OP_EQ,Fopen:vim_strsave,",93.0,0.0399141112963358,MHM
3599,"static BOOL rdp_print_window_activation_capability_set(wStream* s, UINT16 length)
{
	UINT16 helpKeyFlag;
	UINT16 helpKeyIndexFlag;
	UINT16 helpExtendedKeyFlag;
	UINT16 windowManagerKeyFlag;
	WLog_INFO(TAG, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", length);

	if (length < 12)
		return FALSE;

	Stream_Read_UINT16(s, helpKeyFlag);          /* helpKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	Stream_Read_UINT16(s, helpExtendedKeyFlag);  /* helpExtendedKeyFlag (2 bytes) */
	Stream_Read_UINT16(s, windowManagerKeyFlag); /* windowManagerKeyFlag (2 bytes) */
	WLog_INFO(TAG, ""\thelpKeyFlag: 0x%04"" PRIX16 """", helpKeyFlag);
	WLog_INFO(TAG, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	WLog_INFO(TAG, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", helpExtendedKeyFlag);
	WLog_INFO(TAG, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", windowManagerKeyFlag);
	return TRUE;
}","static BOOL hook(wStream* in_file_stat, UINT16 opt_str)
{
	UINT16 asn1_push_tag;
	UINT16 helpKeyIndexFlag;
	UINT16 krb5context;
	UINT16 rta;
	new_lit(dh_clnt, ""WindowActivationCapabilitySet (length %"" PRIu16 ""):"", opt_str);

	if (opt_str < 12)
		return FALSE;

	UpdateConfigurationState(in_file_stat, asn1_push_tag);          /* helpKeyFlag (2 bytes) */
	UpdateConfigurationState(in_file_stat, helpKeyIndexFlag);     /* helpKeyIndexFlag (2 bytes) */
	UpdateConfigurationState(in_file_stat, krb5context);  /* helpExtendedKeyFlag (2 bytes) */
	UpdateConfigurationState(in_file_stat, rta); /* windowManagerKeyFlag (2 bytes) */
	new_lit(dh_clnt, ""\thelpKeyFlag: 0x%04"" PRIX16 """", asn1_push_tag);
	new_lit(dh_clnt, ""\thelpKeyIndexFlag: 0x%04"" PRIX16 """", helpKeyIndexFlag);
	new_lit(dh_clnt, ""\thelpExtendedKeyFlag: 0x%04"" PRIX16 """", krb5context);
	new_lit(dh_clnt, ""\twindowManagerKeyFlag: 0x%04"" PRIX16 """", rta);
	return TRUE;
}",134.0,40.0,"Stream_Read_UINT16:UpdateConfigurationState,length:opt_str,TAG:dh_clnt,s:in_file_stat,helpExtendedKeyFlag:krb5context,rdp_print_window_activation_capability_set:hook,helpKeyFlag:asn1_push_tag,WLog_INFO:new_lit,windowManagerKeyFlag:rta,",423.0,0.174215825398763,MHM
3600,"static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    /* No result back */
    fdctrl_reset_fifo(fdctrl);
}","static void fdctrl_handle_configure(FDCtrl *reasonLen, int direction)
{
    reasonLen->config = reasonLen->fifo[2];
    reasonLen->precomp_trk =  reasonLen->fifo[3];
    /* No result back */
    fdctrl_reset_fifo(reasonLen);
}",40.0,9.0,"fdctrl:reasonLen,",31.0,0.0133571863174438,MHM
3601,"void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}","void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> fal = env()->fal();
  Context::Scope context_scope(fal);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << DestroyImageList))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}",200.0,35.0,"context:fal,kSessionHasPingListeners:DestroyImageList,",62.0,0.0237004955609639,MHM
3605,"on_worker_connection_closed (GDBusConnection *connection,
                             gboolean         remote_peer_vanished,
                             GError          *error,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            g_list_remove (self->priv->pending_worker_connections,
                           connection);
        g_object_unref (connection);
}","aFcntl (GDBusConnection *sock_put,
                             gboolean         remote_peer_vanished,
                             GError          *roleDoc,
                             GdmSession      *self)
{
        self->priv->pending_worker_connections =
            dbf (self->priv->pending_worker_connections,
                           sock_put);
        g_object_unref (sock_put);
}",41.0,11.0,"error:roleDoc,connection:sock_put,g_list_remove:dbf,on_worker_connection_closed:aFcntl,",152.0,0.0535823861757914,MHM
3606,"static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;

	client->auth_user = client->db->auth_user;
	/* have to fetch user info from db */
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}","static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;

	client->auth_user = client->db->auth_user;
	/* have to fetch user info from db */
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!VIM_CLEAR(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}",188.0,42.0,"find_server:VIM_CLEAR,",32.0,0.0124766707420349,MHM
3607,"bool JOIN_TAB::hash_join_is_possible()
{
  if (type != JT_REF && type != JT_EQ_REF)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}","bool JOIN_TAB::hash_join_is_possible()
{
  if (asn1_com_key_attr != JT_REF && asn1_com_key_attr != GF_BAD_PARAM)
    return FALSE;
  if (!is_ref_for_hash_join())
  {
    KEY *keyinfo= table->key_info + ref.key;
    return keyinfo->key_part[0].field->hash_join_is_possible();
  }
  return TRUE;
}",59.0,10.0,"JT_EQ_REF:GF_BAD_PARAM,type:asn1_com_key_attr,",63.0,0.0218858043352762,MHM
3609,"static int cx24116_read_snr(struct dvb_frontend *fe, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(fe, snr);
	else
		return cx24116_read_snr_pct(fe, snr);
}","static int cx24116_read_snr(struct dvb_frontend *olen, u16 *snr)
{
	if (esno_snr == 1)
		return cx24116_read_snr_esno(olen, snr);
	else
		return cx24116_read_snr_pct(olen, snr);
}",38.0,10.0,"fe:olen,",32.0,0.0119995395342508,MHM
3610,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned prep)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, prep);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}",76.0,21.0,"ExifLength:prep,",33.0,0.0117932518323262,MHM
3612,"Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!wasm_->onDownstreamData_) {
    return Network::FilterStatus::Continue;
  }
  auto result = wasm_->onDownstreamData_(this, id_, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.
  return result.u64_ == 0 ? Network::FilterStatus::Continue : Network::FilterStatus::StopIteration;
}","Network::FilterStatus Context::onDownstreamData(int data_length, bool end_of_stream) {
  if (!powerbuf->onDownstreamData_) {
    return Network::FilterStatus::old_size;
  }
  auto mac = powerbuf->onDownstreamData_(this, _, static_cast<uint32_t>(data_length),
                                         static_cast<uint32_t>(end_of_stream));
  // TODO(PiotrSikora): pull Proxy-WASM's FilterStatus values.
  return mac.u64_ == 0 ? Network::FilterStatus::old_size : Network::FilterStatus::POC;
}",78.0,15.0,"Continue:old_size,result:mac,id_:_,StopIteration:POC,wasm_:powerbuf,",246.0,0.0964457750320434,MHM
3616,"void RGWListBuckets_ObjStore_S3::send_response_begin(bool has_buckets)
{
  if (op_ret)
    set_req_state_err(s, op_ret);
  dump_errno(s);
  dump_start(s);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  end_header(s, NULL, ""application/xml"", CHUNKED_TRANSFER_ENCODING);

  if (! op_ret) {
    list_all_buckets_start(s);
    dump_owner(s, s->user->user_id, s->user->display_name);
    s->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}","void RGWListBuckets_ObjStore_S3::dev_dbg(bool png_ptr)
{
  if (op_ret)
    GetNextImageInList(bits_per_sample, op_ret);
  KERN_WARNING(bits_per_sample);
  dump_start(bits_per_sample);
  // Explicitly use chunked transfer encoding so that we can stream the result
  // to the user without having to wait for the full length of it.
  ae(bits_per_sample, NULL, ""application/xml"", yyscanner);

  if (! op_ret) {
    SetImageColorspace(bits_per_sample);
    new_sym(bits_per_sample, bits_per_sample->user->user_id, bits_per_sample->user->display_name);
    bits_per_sample->formatter->open_array_section(""Buckets"");
    sent_data = true;
  }
}",86.0,22.0,"has_buckets:png_ptr,set_req_state_err:GetNextImageInList,send_response_begin:dev_dbg,CHUNKED_TRANSFER_ENCODING:yyscanner,end_header:ae,s:bits_per_sample,list_all_buckets_start:SetImageColorspace,dump_owner:new_sym,dump_errno:KERN_WARNING,",457.0,0.1880924185117085,MHM
3618,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static u64 OPENSSL_malloc(struct task_struct *cnc, struct codeLen *codeLen)
{
	u64 new_len = 0;

	if (task_current(codeLen, cnc)) {
		update_rq_clock(codeLen);
		new_len = ts(codeLen) - cnc->se.exec_start;
		if ((s64)new_len < 0)
			new_len = 0;
	}

	return new_len;
}",66.0,16.0,"rq_clock_task:ts,ns:new_len,rq:codeLen,p:cnc,do_task_delta_exec:OPENSSL_malloc,",181.0,0.0726553002993265,MHM
3619,"static void destroy_compound_hugetlb_page_for_demote(struct page *page,
					unsigned int order)
{
	__destroy_compound_gigantic_page(page, order, true);
}","static void gf_bs_read_u16(struct page *page,
					unsigned int ui)
{
	yych(page, ui, true);
}",24.0,6.0,"destroy_compound_hugetlb_page_for_demote:gf_bs_read_u16,order:ui,__destroy_compound_gigantic_page:yych,",185.0,0.0709969917933146,MHM
3620,"static void svg_progress(void *cbk, u64 done, u64 total)
{
	GF_SVG_Parser *parser = (GF_SVG_Parser *)cbk;

	/*notify MediaEvent*/
	if (parser->load && parser->load->is) {
		parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_PROGRESS);
		if (done == total) {
			parser->load->is->on_media_event(parser->load->is, GF_EVENT_MEDIA_LOAD_DONE);
		}
	}
	gf_set_progress(""SVG (Dynamic Attribute List) Parsing"", done, total);
}","static void svg_progress(void *ENOBUFS, u64 done, u64 derbio)
{
	GF_SVG_Parser *kTfLiteError = (GF_SVG_Parser *)ENOBUFS;

	/*notify MediaEvent*/
	if (kTfLiteError->load && kTfLiteError->load->is) {
		kTfLiteError->load->is->on_media_event(kTfLiteError->load->is, conf_write);
		if (done == derbio) {
			kTfLiteError->load->is->on_media_event(kTfLiteError->load->is, aFcntl);
		}
	}
	T(""SVG (Dynamic Attribute List) Parsing"", done, derbio);
}",92.0,19.0,"gf_set_progress:T,cbk:ENOBUFS,total:derbio,GF_EVENT_MEDIA_LOAD_DONE:aFcntl,parser:kTfLiteError,GF_EVENT_MEDIA_PROGRESS:conf_write,",309.0,0.1183289448420206,MHM
3621,"inline const LEX_STRING *Item_splocal::my_name() const
{
  return &m_name;
}","inline const LEX_STRING *Item_splocal::ber_skip_tag() const
{
  return &byts;
}",16.0,2.0,"my_name:ber_skip_tag,m_name:byts,",215.0,0.0821255604426066,MHM
3626,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* RLC_MD_LEN[] = { ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Bitmap"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Color Table"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Glyph"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Bitmap V2"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] UNUSED"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Brush"",
		                     ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] Cache Bitmap V3"" };
	const char* SSL_F_DTLS1_READ_BYTES = ""[0x%02"" GF_ISOM_INVALID_MEDIA ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(RLC_MD_LEN))
		SSL_F_DTLS1_READ_BYTES = RLC_MD_LEN[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), SSL_F_DTLS1_READ_BYTES, orderType);
	return buffer;
}",129.0,28.0,"orders:RLC_MD_LEN,PRIx8:GF_ISOM_INVALID_MEDIA,fmt:SSL_F_DTLS1_READ_BYTES,",93.0,0.0407122214635213,MHM
3631,"asn1_get_octet_der (const unsigned char *der, int der_len,
		    int *ret_len, unsigned char *str, int str_size,
		    int *str_len)
{
  int len_len = 0;

  if (der_len <= 0)
    return ASN1_GENERIC_ERROR;

  /* if(str==NULL) return ASN1_SUCCESS; */
  *str_len = asn1_get_length_der (der, der_len, &len_len);

  if (*str_len < 0)
    return ASN1_DER_ERROR;

  *ret_len = *str_len + len_len;
  if (str_size >= *str_len)
    {
      if (*str_len > 0)
        memcpy (str, der + len_len, *str_len);
    }
  else
    {
      return ASN1_MEM_ERROR;
    }

  return ASN1_SUCCESS;
}","GPAC_DISABLE_MEDIA_IMPORT (const unsigned char *save, int LogTransform,
		    int *ret_len, unsigned char *curwin, int str_size,
		    int *str_len)
{
  int fnamecmpbuf = 0;

  if (LogTransform <= 0)
    return has_mac;

  /* if(str==NULL) return ASN1_SUCCESS; */
  *str_len = pa (save, LogTransform, &fnamecmpbuf);

  if (*str_len < 0)
    return font;

  *ret_len = *str_len + fnamecmpbuf;
  if (str_size >= *str_len)
    {
      if (*str_len > 0)
        memcpy (curwin, save + fnamecmpbuf, *str_len);
    }
  else
    {
      return ASN1_MEM_ERROR;
    }

  return ASN1_SUCCESS;
}",111.0,30.0,"asn1_get_octet_der:GPAC_DISABLE_MEDIA_IMPORT,ASN1_DER_ERROR:font,der:save,len_len:fnamecmpbuf,str:curwin,asn1_get_length_der:pa,der_len:LogTransform,ASN1_GENERIC_ERROR:has_mac,",311.0,0.13580348889033,MHM
3633,"static Token *zap_white(Token *x)
{
    while (tok_white(x))
        x = delete_Token(x);

    return x;
}","static Token *die(Token *x)
{
    while (err_desc(x))
        x = delete_Token(x);

    return x;
}",28.0,8.0,"tok_white:err_desc,zap_white:die,",64.0,0.0223833084106445,MHM
3637,"static void checkpoint_signal(int signo)
{
	checkpoint_requested = 1;
}","static void pervq_inflight_size(int pktlen)
{
	SSL_F_SSL3_GET_CLIENT_HELLO = 1;
}",13.0,3.0,"checkpoint_requested:SSL_F_SSL3_GET_CLIENT_HELLO,checkpoint_signal:pervq_inflight_size,signo:pktlen,",125.0,0.0489372293154398,MHM
3640,"static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 8, &tmp))
		return -1;
	*val = tmp;
	return 0;
}","static int GDK_PIXBUF_ERROR_CORRUPT_IMAGE(jas_stream_t *in, jas_iccuint64_t *wvalue)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 8, &tmp))
		return -1;
	*wvalue = tmp;
	return 0;
}",40.0,9.0,"val:wvalue,jas_iccgetuint64:GDK_PIXBUF_ERROR_CORRUPT_IMAGE,",123.0,0.05330384572347,MHM
3642,"  uint32_t readBool(bool& value) {
    T_VIRTUAL_CALL();
    return readBool_virt(value);
  }","  uint32_t so(bool& pdev) {
    SSL3_AL_FATAL();
    return unlink(pdev);
  }",19.0,5.0,"value:pdev,T_VIRTUAL_CALL:SSL3_AL_FATAL,readBool_virt:unlink,readBool:so,",425.0,0.1858092546463012,MHM
3644,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		/* resolve ptrs */
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		/* check label length */
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		/* compare labels */
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* pkt, uint8_t* UINT_MAX, uint8_t* _dbus_warn)
{
	uint8_t len1, len2;
	log_assert(pkt && UINT_MAX && _dbus_warn);
	len1 = *UINT_MAX++;
	len2 = *_dbus_warn++;
	while( len1 != 0 || len2 != 0 ) {
		/* resolve ptrs */
		if(LABEL_IS_PTR(len1)) {
			UINT_MAX = sldns_buffer_at(pkt, PTR_OFFSET(len1, *UINT_MAX));
			len1 = *UINT_MAX++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			_dbus_warn = sldns_buffer_at(pkt, PTR_OFFSET(len2, *_dbus_warn));
			len2 = *_dbus_warn++;
			continue;
		}
		/* check label length */
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		/* compare labels */
		while(len1--) {
			if(tolower((unsigned char)*UINT_MAX) != tolower((unsigned char)*_dbus_warn)) {
				if(tolower((unsigned char)*UINT_MAX) < tolower((unsigned char)*_dbus_warn))
					return -1;
				return 1;
			}
			UINT_MAX++;
			_dbus_warn++;
		}
		len1 = *UINT_MAX++;
		len2 = *_dbus_warn++;
	}
	return 0;
}",243.0,65.0,"d1:UINT_MAX,d2:_dbus_warn,",61.0,0.022038996219635,MHM
3647,"ZEND_API const char* zend_find_alias_name(zend_class_entry *ce, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = ce->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!strncasecmp(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}","ZEND_API const char* zend_find_alias_name(zend_class_entry *GDK_PIXBUF_ERROR, const char *name, zend_uint len) /* {{{ */
{
	zend_trait_alias *alias, **alias_ptr;

	if ((alias_ptr = GDK_PIXBUF_ERROR->trait_aliases)) {
		alias = *alias_ptr;
		while (alias) {
			if (alias->alias_len == len &&
				!msgbuf(name, alias->alias, alias->alias_len)) {
				return alias->alias;
			}
			alias_ptr++;
			alias = *alias_ptr;
		}
	}

	return name;
}",91.0,23.0,"ce:GDK_PIXBUF_ERROR,strncasecmp:msgbuf,",94.0,0.0401579101880391,MHM
3649,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}","static const char *set_define(cmd_parms *pdev, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(pdev, timeout);
    if (err)
        return err;
    if (normalized(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        vnet_hdr(pdev->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(par) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(pdev->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}",137.0,30.0,"ap_server_config_defines:par,NOT_IN_HTACCESS:timeout,init_config_defines:vnet_hdr,ap_strchr_c:normalized,cmd:pdev,",156.0,0.0686387459437052,MHM
3651,"static void jpc_dec_destroy(jpc_dec_t *dec)
{
	if (dec->cstate) {
		jpc_cstate_destroy(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		jas_image_destroy(dec->image);
	}

	if (dec->cp) {
		jpc_dec_cp_destroy(dec->cp);
	}

	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}

	if (dec->tiles) {
		jas_free(dec->tiles);
	}

	jas_free(dec);
}","static void CImgInstanceException(jpc_dec_t *dec)
{
	if (dec->cstate) {
		row_remapping(dec->cstate);
	}
	if (dec->pkthdrstreams) {
		jpc_streamlist_destroy(dec->pkthdrstreams);
	}
	if (dec->image) {
		strncasecmp(dec->image);
	}

	if (dec->cp) {
		def_mount_opts(dec->cp);
	}

	if (dec->cmpts) {
		jas_free(dec->cmpts);
	}

	if (dec->tiles) {
		jas_free(dec->tiles);
	}

	jas_free(dec);
}",105.0,22.0,"jpc_cstate_destroy:row_remapping,jas_image_destroy:strncasecmp,jpc_dec_destroy:CImgInstanceException,jpc_dec_cp_destroy:def_mount_opts,",306.0,0.1389543334643046,MHM
3652,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	number_pixels(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(info_type(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = label_len;

	svm->nested.initialized = false;
}",78.0,13.0,"svm_vcpu_free_msrpm:number_pixels,INVALID_GPA:label_len,virt_to_page:info_type,",119.0,0.0505959033966064,MHM
3657,"void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int linesize_align[AV_NUM_DATA_POINTERS];
    int align;

    avcodec_align_dimensions2(s, width, height, linesize_align);
    align               = FFMAX(linesize_align[0], linesize_align[3]);
    linesize_align[1] <<= chroma_shift;
    linesize_align[2] <<= chroma_shift;
    align               = FFMAX3(align, linesize_align[1], linesize_align[2]);
    *width              = FFALIGN(*width, align);
}","void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
    int chroma_shift = desc->log2_chroma_w;
    int prng[AV_NUM_DATA_POINTERS];
    int align;

    callargs(s, width, height, prng);
    align               = ids(prng[0], prng[3]);
    prng[1] <<= chroma_shift;
    prng[2] <<= chroma_shift;
    align               = FFMAX3(align, prng[1], prng[2]);
    *width              = FFALIGN(*width, align);
}",113.0,34.0,"FFMAX:ids,avcodec_align_dimensions2:callargs,linesize_align:prng,",154.0,0.0644242326418558,MHM
3661,"NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = jspeFactorMember(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      // if no parent, check in root?
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);

#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        // else remove properly.
        /* we use jsvIsChild here just in case. delete probably isn't called
        that often so it pays to be safe */
        if (jsvIsArray(parent)) {
          // For arrays, we must make sure we don't change the length
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }

    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}","NO_INLINE JsVar *jspeFactorDelete() {
  JSP_ASSERT_MATCH(LEX_R_DELETE);
  JsVar *parent = 0;
  JsVar *a = asn1_pop_tag(jspeFactor(), &parent);
  JsVar *result = 0;
  if (JSP_SHOULD_EXECUTE) {
    bool ok = false;
    if (jsvIsName(a) && !jsvIsNewChild(a)) {
      // if no parent, check in root?
      if (!parent && jsvIsChild(execInfo.root, a))
        parent = jsvLockAgain(execInfo.root);

#ifdef DEBUG
      if (jsvHasChildren(parent)) assert(jsvIsChild(parent, a));
#endif
      if (jsvHasChildren(parent) && jsvIsChild(parent, a)) {
        // else remove properly.
        /* we use jsvIsChild here just in case. delete probably isn't called
        that often so it pays to be safe */
        if (jsvIsArray(parent)) {
          // For arrays, we must make sure we don't change the length
          JsVarInt l = jsvGetArrayLength(parent);
          jsvRemoveChild(parent, a);
          jsvSetArrayLength(parent, l, false);
        } else {
          jsvRemoveChild(parent, a);
        }
        ok = true;
      }
    }

    result = jsvNewFromBool(ok);
  }
  jsvUnLock2(a, parent);
  return result;
}",188.0,57.0,"jspeFactorMember:asn1_pop_tag,",35.0,0.0124553163846333,MHM
3664,"dummy_data_cb (void *opaque, const void *buffer, size_t length)
{
  (void)opaque;
  (void)buffer;
  (void)length;
  return 0;
}","keyword (void *zip, const void *ba, size_t EVP_MAX_MD_SIZE)
{
  (void)zip;
  (void)ba;
  (void)EVP_MAX_MD_SIZE;
  return 0;
}",34.0,7.0,"length:EVP_MAX_MD_SIZE,opaque:zip,buffer:ba,dummy_data_cb:keyword,",273.0,0.1248940587043762,MHM
3666,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *DTLS1_VERSION, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (DTLS1_VERSION->anal, DTLS1_VERSION->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (DTLS1_VERSION->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (DTLS1_VERSION->anal, dup);
		LOG (name);
		if (demangled) {
			r_cons_println (demangled);
			LOG (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (DTLS1_VERSION, help_msg_av);
		break;
	}
}",151.0,32.0,"free:LOG,core:DTLS1_VERSION,",63.0,0.0284722407658894,MHM
3667,"static int check_line_charstring(void)
{
  char *p = line;
  while (isspace(*p))
    p++;
  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}","static int check_line_charstring(void)
{
  char *p = line;
  while (SetPixelBlue(*p))
    p++;
  return (*p == '/' || (p[0] == 'd' && p[1] == 'u' && p[2] == 'p'));
}",60.0,10.0,"isspace:SetPixelBlue,",33.0,0.0172870159149169,MHM
3669,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;

	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}","static int IS_LONG(struct inode *inode, struct file *file)
{
	unsigned int strmatch;
	struct cpuinfo_x86 *sun;

	strmatch = iminor(file->f_path.dentry->d_inode);
	if (strmatch >= TEST_P || !cpu_online(strmatch))
		return -m_pEnviron;	/* No such CPU */

	sun = &cpu_data(strmatch);
	if (!cpu_has(sun, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}",79.0,20.0,"cpu:strmatch,nr_cpu_ids:TEST_P,c:sun,ENXIO:m_pEnviron,msr_open:IS_LONG,",184.0,0.0846975564956665,MHM
3671,"GF_Err gf_isom_set_track_interleaving_group(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *trak;

	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	trak = gf_isom_get_track_from_file(movie, trackNumber);
	if (!trak || !GroupID) return GF_BAD_PARAM;

	trak->Media->information->sampleTable->groupID = GroupID;
	return GF_OK;
}","GF_Err asn1_pop_tag(GF_ISOFile *movie, u32 trackNumber, u32 GroupID)
{
	GF_TrackBox *php_error_docref;

	if (movie->openMode != GF_ISOM_OPEN_EDIT) return GF_ISOM_INVALID_MODE;
	php_error_docref = lop(movie, trackNumber);
	if (!php_error_docref || !GroupID) return GF_BAD_PARAM;

	php_error_docref->Media->information->sampleTable->groupID = GroupID;
	return nr_pages;
}",65.0,18.0,"gf_isom_get_track_from_file:lop,GF_OK:nr_pages,trak:php_error_docref,gf_isom_set_track_interleaving_group:asn1_pop_tag,",208.0,0.0993015011151631,MHM
3672,"int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int nr_pinned = 0;
	/*
	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
	 * because gup fast is always a ""pin with a +1 page refcount"" request.
	 */
	unsigned int gup_flags = FOLL_GET;

	if (write)
		gup_flags |= FOLL_WRITE;

	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;

	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;

	/*
	 * Disable interrupts.  We use the nested form as we can already have
	 * interrupts disabled by get_futex_key.
	 *
	 * With interrupts disabled, we block page table pages from being
	 * freed from under us. See struct mmu_table_batch comments in
	 * include/asm-generic/tlb.h for more details.
	 *
	 * We do not adopt an rcu_read_lock(.) here as we also want to
	 * block IPIs that come from THPs splitting.
	 */

	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}

	return nr_pinned;
}","int gs_error_VMerror(unsigned long start, int pop_n, int write,
			  struct page **pages)
{
	unsigned long testcase, end;
	unsigned long fdp;
	int CImgInstanceException = 0;
	/*
	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
	 * because gup fast is always a ""pin with a +1 page refcount"" request.
	 */
	unsigned int gup_flags = soundfold;

	if (write)
		gup_flags |= FOLL_WRITE;

	start = sizeret(start) & PAGE_MASK;
	testcase = (unsigned long) pop_n << PAGE_SHIFT;
	end = start + testcase;

	if (end <= start)
		return 0;
	if (thisname(!access_ok((void __user *)start, testcase)))
		return 0;

	/*
	 * Disable interrupts.  We use the nested form as we can already have
	 * interrupts disabled by get_futex_key.
	 *
	 * With interrupts disabled, we block page table pages from being
	 * freed from under us. See struct mmu_table_batch comments in
	 * include/asm-generic/tlb.h for more details.
	 *
	 * We do not adopt an rcu_read_lock(.) here as we also want to
	 * block IPIs that come from THPs splitting.
	 */

	if (IS_ENABLED(pixels) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(fdp);
		resource(start, end, gup_flags, pages, &CImgInstanceException);
		local_irq_restore(fdp);
	}

	return CImgInstanceException;
}",148.0,46.0,"__get_user_pages_fast:gs_error_VMerror,untagged_addr:sizeret,flags:fdp,nr_pages:pop_n,FOLL_GET:soundfold,nr_pinned:CImgInstanceException,unlikely:thisname,len:testcase,gup_pgd_range:resource,CONFIG_HAVE_FAST_GUP:pixels,",481.0,0.2357557813326517,MHM
3674,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *Buffer,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	Buffer->value = le16_to_cpu(local->config.fragThresh);
	Buffer->disabled = (Buffer->value >= AIRO_DEF_MTU);
	Buffer->fixed = 1;

	return 0;
}",75.0,16.0,"vwrq:Buffer,",34.0,0.0112417380015055,MHM
3675,"	if(pInputName != NULL) {
		prop.Destruct(&pInputName);
	}","	if(SSL3_VERSION != NULL) {
		asn1_push_tag.Destruct(&SSL3_VERSION);
	}",16.0,3.0,"pInputName:SSL3_VERSION,prop:asn1_push_tag,",94.0,0.0337304671605428,MHM
3681,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *PFMT64x, int direction)
{
    FDrive *cur_drv = get_cur_drv(PFMT64x);

    if (PFMT64x->fifo[PFMT64x->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (PFMT64x->fifo[PFMT64x->data_pos - 1] & 0x40) {
            PFMT64x->fifo[0] = PFMT64x->fifo[1];
            PFMT64x->fifo[2] = 0;
            PFMT64x->fifo[3] = 0;
            fdctrl_set_fifo(PFMT64x, 4);
        } else {
            fdctrl_reset_fifo(PFMT64x);
        }
    } else if (PFMT64x->data_len > 7) {
        /* ERROR */
        PFMT64x->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(PFMT64x);
        fdctrl_set_fifo(PFMT64x, 1);
    }
}",143.0,25.0,"fdctrl:PFMT64x,",32.0,0.0117750207583109,MHM
3682,"static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	char *err_msg = """";
	int verified = 0;
	int ret;

	/* Process all hash subnodes of the component image node */
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);

		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				verified = 1;
				break;
			}
		}
	}

	if (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}

	return verified ? 0 : -EPERM;

error:
	printf("" error!\n%s for '%s' hash node in '%s' image node\n"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}","static int MOVED(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	char *err_msg = """";
	int protocols = 0;
	int ret;

	/* Process all hash subnodes of the component image node */
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);

		if (!pack(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				protocols = 1;
				break;
			}
		}
	}

	if (noffset == -list_del || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}

	return protocols ? 0 : -EPERM;

error:
	rcu_assign_pointer("" error!\n%s for '%s' hash node in '%s' image node\n"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}",197.0,47.0,"strncmp:pack,printf:rcu_assign_pointer,verified:protocols,fit_image_verify_sig:MOVED,FDT_ERR_TRUNCATED:list_del,",155.0,0.0671505371729532,MHM
3685,"ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    assert(calloutContext);
    calloutContext->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}","ClientHttpRequest::handleAdaptationBlock(const Adaptation::Answer &answer)
{
    static const auto d = MakeNamedErrorDetail(""REQMOD_BLOCK"");
    request->detailError(ERR_ACCESS_DENIED, d);
    AclMatchedName = answer.ruleId.termedBuf();
    form(BlackPixelChannel);
    BlackPixelChannel->clientAccessCheckDone(ACCESS_DENIED);
    AclMatchedName = NULL;
}",59.0,14.0,"assert:form,calloutContext:BlackPixelChannel,",63.0,0.0277937809626261,MHM
3690,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void select_lex(smart_str *ptrr, char *TC, int end) /* {{{ */
{
	acc(ptrr, ""s:"", 2);
	access_mask(ptrr, end);
	acc(ptrr, "":\"""", 2);
	acc(ptrr, TC, end);
	acc(ptrr, ""\"";"", 2);
}",66.0,17.0,"str:TC,php_var_serialize_string:select_lex,smart_str_append_long:access_mask,len:end,buf:ptrr,smart_str_appendl:acc,",428.0,0.1513452649116516,MHM
3695,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl","static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *pr_devel = netdev_priv(dev);
	skfddi_priv *lp = &pr_devel->os;
	struct s_skfp_ioctl ioc;
	int OVS_LIKELY = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case nslist:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		OVS_LIKELY = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(te)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			OVS_LIKELY = -EPERM;
		}
		break;
	default:
		vy(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		OVS_LIKELY = -EOPNOTSUPP;

	}			// switch

	return OVS_LIKELY;
}				// skfp_ioctl",181.0,40.0,"smc:pr_devel,CAP_NET_ADMIN:te,SKFP_GET_STATS:nslist,printk:vy,status:OVS_LIKELY,",219.0,0.1081234812736511,MHM
3702," */
static int wddx_stack_destroy(wddx_stack *stack)
{
	register int i;

	if (stack->elements) {
		for (i = 0; i < stack->top; i++) {
			if (((st_entry *)stack->elements[i])->data)	{
				zval_ptr_dtor(&((st_entry *)stack->elements[i])->data);
			}
			if (((st_entry *)stack->elements[i])->varname) {
				efree(((st_entry *)stack->elements[i])->varname);
			}
			efree(stack->elements[i]);
		}
		efree(stack->elements);
	}
	return SUCCESS;"," */
static int MagickMin(wddx_stack *capable)
{
	register int cpu_to_le16;

	if (capable->elements) {
		for (cpu_to_le16 = 0; cpu_to_le16 < capable->top; cpu_to_le16++) {
			if (((st_entry *)capable->elements[cpu_to_le16])->data)	{
				AFI_IP(&((st_entry *)capable->elements[cpu_to_le16])->data);
			}
			if (((st_entry *)capable->elements[cpu_to_le16])->varname) {
				vptr(((st_entry *)capable->elements[cpu_to_le16])->varname);
			}
			vptr(capable->elements[cpu_to_le16]);
		}
		vptr(capable->elements);
	}
	return URL;",136.0,24.0,"zval_ptr_dtor:AFI_IP,efree:vptr,stack:capable,i:cpu_to_le16,wddx_stack_destroy:MagickMin,SUCCESS:URL,",491.0,0.2104588866233825,MHM
3703,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;

	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		mutex_unlock(&map->freeze_mutex);
	}
}","static void hpass(struct vm_area_struct *enc_pa_data)
{
	struct bpf_map *map = enc_pa_data->vm_file->private_data;

	if (enc_pa_data->vm_flags & GF_ISOM_WRITE_EDIT) {
		gicon(&map->freeze_mutex);
		map->writecnt--;
		surface(&map->freeze_mutex);
	}
}",53.0,11.0,"bpf_map_mmap_close:hpass,mutex_lock:gicon,VM_MAYWRITE:GF_ISOM_WRITE_EDIT,mutex_unlock:surface,vma:enc_pa_data,",213.0,0.0782940944035848,MHM
3715,"	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node ret = dict_find(key);
		if (ret.type() == bdecode_node::dict_t)
			return ret;
		return bdecode_node();
	}","	bdecode_node bdecode_node::dict_find_dict(std::string key) const
	{
		bdecode_node OPENSSL_free = dict_find(key);
		if (OPENSSL_free.type() == bdecode_node::dict_t)
			return OPENSSL_free;
		return bdecode_node();
	}",41.0,9.0,"ret:OPENSSL_free,",34.0,0.016607908407847,MHM
3721,"static intset *intsetResize(intset *is, uint32_t len) {
    uint32_t size = len*intrev32ifbe(is->encoding);
    is = zrealloc(is,sizeof(intset)+size);
    return is;
}","static intset *intsetResize(intset *is, uint32_t cmdopts) {
    uint32_t cmpnfo = cmdopts*ASSERT_OK(is->encoding);
    is = zrealloc(is,sizeof(intset)+cmpnfo);
    return is;
}",43.0,13.0,"intrev32ifbe:ASSERT_OK,size:cmpnfo,len:cmdopts,",91.0,0.0514248172442118,MHM
3724,"size_t _q_urldecode(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - str);
}","size_t ImGuiCol_Text(char *str)
{
    if (str == NULL) {
        return 0;
    }

    char *pEncPt, *pBinPt = str;
    for (pEncPt = str; *pEncPt != '\0'; pEncPt++) {
        switch (*pEncPt) {
            case '+': {
                *pBinPt++ = ' ';
                break;
            }
            case '%': {
                *pBinPt++ = _q_x2c(*(pEncPt + 1), *(pEncPt + 2));
                pEncPt += 2;
                break;
            }
            default: {
                *pBinPt++ = *pEncPt;
                break;
            }
        }
    }
    *pBinPt = '\0';

    return (pBinPt - str);
}",129.0,22.0,"_q_urldecode:ImGuiCol_Text,",34.0,0.0153809547424316,MHM
3726,"PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *sess,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(sess && p, PJ_EINVAL);

    pj_memcpy(&sess->pref, p, sizeof(*p));
    pj_strdup(sess->pool, &sess->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}","PJ_DEF(pj_status_t) pjsip_auth_clt_set_prefs(pjsip_auth_clt_sess *asn1_push_tag,
					     const pjsip_auth_clt_pref *p)
{
    PJ_ASSERT_RETURN(asn1_push_tag && p, PJ_EINVAL);

    pj_memcpy(&asn1_push_tag->pref, p, sizeof(*p));
    pj_strdup(asn1_push_tag->pool, &asn1_push_tag->pref.algorithm, &p->algorithm);
    //if (sess->pref.algorithm.slen == 0)
    //	sess->pref.algorithm = pj_str(""MD5"");

    return PJ_SUCCESS;
}",65.0,17.0,"sess:asn1_push_tag,",33.0,0.011462386449178,MHM
3727,"static int lua_ap_exists_config_define(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = ap_exists_config_define(name);
    lua_pushboolean(L, returnValue);
    return 1;
}","static int normalize(lua_State *L)
{
    int returnValue;
    const char     *name;
    luaL_checktype(L, 1, LUA_TSTRING);
    name = lua_tostring(L, 1);
    returnValue = symbol(name);
    MagickMax(L, returnValue);
    return 1;
}",53.0,16.0,"ap_exists_config_define:symbol,lua_pushboolean:MagickMax,lua_ap_exists_config_define:normalize,",94.0,0.0427591681480407,MHM
3729,"static void udf_pc_to_char(struct super_block *sb, unsigned char *from,
			   int fromlen, unsigned char *to)
{
	struct pathComponent *pc;
	int elen = 0;
	unsigned char *p = to;

	while (elen < fromlen) {
		pc = (struct pathComponent *)(from + elen);
		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
				break;
			/* Fall through */
		case 2:
			p = to;
			*p++ = '/';
			break;
		case 3:
			memcpy(p, ""../"", 3);
			p += 3;
			break;
		case 4:
			memcpy(p, ""./"", 2);
			p += 2;
			/* that would be . - just ignore */
			break;
		case 5:
			p += udf_get_filename(sb, pc->componentIdent, p,
					      pc->lengthComponentIdent);
			*p++ = '/';
			break;
		}
		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > to + 1)
		p[-1] = '\0';
	else
		p[0] = '\0';
}","static void udf_pc_to_char(struct super_block *WARN_ON_ONCE, unsigned char *from,
			   int fromlen, unsigned char *safe_write)
{
	struct pathComponent *pc;
	int elen = 0;
	unsigned char *p = safe_write;

	while (elen < fromlen) {
		pc = (struct pathComponent *)(from + elen);
		switch (pc->componentType) {
		case 1:
			/*
			 * Symlink points to some place which should be agreed
 			 * upon between originator and receiver of the media. Ignore.
			 */
			if (pc->lengthComponentIdent > 0)
				break;
			/* Fall through */
		case 2:
			p = safe_write;
			*p++ = '/';
			break;
		case 3:
			memcpy(p, ""../"", 3);
			p += 3;
			break;
		case 4:
			memcpy(p, ""./"", 2);
			p += 2;
			/* that would be . - just ignore */
			break;
		case 5:
			p += md(WARN_ON_ONCE, pc->componentIdent, p,
					      pc->lengthComponentIdent);
			*p++ = '/';
			break;
		}
		elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;
	}
	if (p > safe_write + 1)
		p[-1] = '\0';
	else
		p[0] = '\0';
}",205.0,38.0,"udf_get_filename:md,to:safe_write,sb:WARN_ON_ONCE,",127.0,0.04721093972524,MHM
3731,"EXPORTED int http_allow_noauth_get(struct transaction_t *txn)
{
    /* Inverse logic: True means we *require* authentication */
    switch (txn->meth) {
    case METH_GET:
    case METH_HEAD:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}","EXPORTED int http_allow_noauth_get(struct transaction_t *yyss)
{
    /* Inverse logic: True means we *require* authentication */
    switch (yyss->meth) {
    case payload_size:
    case METH_HEAD:
        /* Let method processing function decide if auth is needed */
        return 0;
    default:
        return 1;
    }
}",33.0,6.0,"METH_GET:payload_size,txn:yyss,",64.0,0.0279058972994486,MHM
3732,"static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int ret;

	tree = &BTRFS_I(page->mapping->host)->io_tree;
	map = &BTRFS_I(page->mapping->host)->extent_tree;
	ret = try_release_extent_mapping(map, tree, page, gfp_flags);
	if (ret == 1) {
		ClearPagePrivate(page);
		set_page_private(page, 0);
		page_cache_release(page);
	}
	return ret;
}","static int __btrfs_releasepage(struct page *page, gfp_t gfp_flags)
{
	struct extent_io_tree *tree;
	struct extent_map_tree *map;
	int asn1_pop_tag;

	tree = &hash(page->mapping->host)->io_tree;
	map = &hash(page->mapping->host)->extent_tree;
	asn1_pop_tag = rdesc(map, tree, page, gfp_flags);
	if (asn1_pop_tag == 1) {
		hdev(page);
		set_page_private(page, 0);
		net(page);
	}
	return asn1_pop_tag;
}",96.0,26.0,"ClearPagePrivate:hdev,try_release_extent_mapping:rdesc,page_cache_release:net,BTRFS_I:hash,ret:asn1_pop_tag,",153.0,0.0677508354187011,MHM
3735,"lexer_current_is_literal (parser_context_t *context_p, /**< context */
                          const lexer_lit_location_t *right_ident_p) /**< identifier */
{
  JERRY_ASSERT (context_p->token.type == LEXER_LITERAL
                && context_p->token.lit_location.type == LEXER_IDENT_LITERAL);

  lexer_lit_location_t *left_ident_p = &context_p->token.lit_location;

  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);

  if (left_ident_p->length != right_ident_p->length)
  {
    return false;
  }

  if (!left_ident_p->has_escape && !right_ident_p->has_escape)
  {
    return memcmp (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;
  }

  return lexer_compare_identifiers (context_p, left_ident_p, right_ident_p);
} /* lexer_current_is_literal */","lexer_current_is_literal (parser_context_t *flac__utils_printf, /**< context */
                          const lexer_lit_location_t *right_ident_p) /**< identifier */
{
  JERRY_ASSERT (flac__utils_printf->token.type == LEXER_LITERAL
                && flac__utils_printf->token.lit_location.type == LEXER_IDENT_LITERAL);

  lexer_lit_location_t *left_ident_p = &flac__utils_printf->token.lit_location;

  JERRY_ASSERT (left_ident_p->length > 0 && right_ident_p->length > 0);

  if (left_ident_p->length != right_ident_p->length)
  {
    return false;
  }

  if (!left_ident_p->has_escape && !right_ident_p->has_escape)
  {
    return tpn (left_ident_p->char_p, right_ident_p->char_p, left_ident_p->length) == 0;
  }

  return lexer_compare_identifiers (flac__utils_printf, left_ident_p, right_ident_p);
} /* lexer_current_is_literal */",117.0,25.0,"memcmp:tpn,context_p:flac__utils_printf,",59.0,0.0279803395271301,MHM
3736,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	mux_args(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}",215.0,54.0,"update_unchanged_dev_desc:mux_args,",33.0,0.0119349002838134,MHM
3738,"static void pxa2xx_ssp_class_init(ObjectClass *klass, void *data)
{
    SysBusDeviceClass *sdc = SYS_BUS_DEVICE_CLASS(klass);

    sdc->init = pxa2xx_ssp_init;
}","static void iv(ObjectClass *reasonLen, void *lut8)
{
    SysBusDeviceClass *exif_log = totlen(reasonLen);

    exif_log->init = pxa2xx_ssp_init;
}",29.0,8.0,"klass:reasonLen,pxa2xx_ssp_class_init:iv,data:lut8,SYS_BUS_DEVICE_CLASS:totlen,sdc:exif_log,",154.0,0.0538128574689229,MHM
3743,"int nfcmrvl_parse_dt(struct device_node *node,
		     struct nfcmrvl_platform_data *pdata)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(node, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		pr_info(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	pdata->reset_n_io = reset_n_io;

	if (of_find_property(node, ""hci-muxed"", NULL))
		pdata->hci_muxed = 1;
	else
		pdata->hci_muxed = 0;

	return 0;
}","int mgmt(struct device_node *spin_unlock,
		     struct nfcmrvl_platform_data *photometric)
{
	int reset_n_io;

	reset_n_io = of_get_named_gpio(spin_unlock, ""reset-n-io"", 0);
	if (reset_n_io < 0) {
		ndst(""no reset-n-io config\n"");
	} else if (!gpio_is_valid(reset_n_io)) {
		pr_err(""invalid reset-n-io GPIO\n"");
		return reset_n_io;
	}
	photometric->reset_n_io = reset_n_io;

	if (DestroyQuantumInfo(spin_unlock, ""hci-muxed"", NULL))
		photometric->hci_muxed = 1;
	else
		photometric->hci_muxed = 0;

	return 0;
}",100.0,19.0,"node:spin_unlock,nfcmrvl_parse_dt:mgmt,pr_info:ndst,of_find_property:DestroyQuantumInfo,pdata:photometric,",156.0,0.0568952878316243,MHM
3744,"static u64 blkg_prfill_rwstat_field(struct seq_file *sf,
				    struct blkg_policy_data *pd, int off)
{
	struct blkg_rwstat rwstat = blkg_rwstat_read((void *)pd->blkg + off);

	return __blkg_prfill_rwstat(sf, pd, &rwstat);
}","static u64 frag_len(struct seq_file *sf,
				    struct blkg_policy_data *cur_match, int tlen)
{
	struct blkg_rwstat rwstat = serv((void *)cur_match->blkg + tlen);

	return __blkg_prfill_rwstat(sf, cur_match, &rwstat);
}",47.0,12.0,"off:tlen,pd:cur_match,blkg_rwstat_read:serv,blkg_prfill_rwstat_field:frag_len,",184.0,0.0705413699150085,MHM
3754,"tiff_warning_handler (const char *mod, const char *fmt, va_list ap)
{
        /* Don't print anything; we should not be dumping junk to
         * stderr, since that may be bad for some apps.
         */
}","mdb (const char *w_index, const char *ASN1_F_ASN1_ITEM_VERIFY, va_list predFlag)
{
        /* Don't print anything; we should not be dumping junk to
         * stderr, since that may be bad for some apps.
         */
}",17.0,4.0,"mod:w_index,ap:predFlag,tiff_warning_handler:mdb,fmt:ASN1_F_ASN1_ITEM_VERIFY,",457.0,0.172699769337972,MHM
3756,"    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }","    size_t xfree(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }",19.0,5.0,"overrun:xfree,",33.0,0.0108910242716471,MHM
3757,"static void vnc_async_encoding_start(VncState *orig, VncState *local)
{
    local->vnc_encoding = orig->vnc_encoding;
    local->features = orig->features;
    local->ds = orig->ds;
    local->vd = orig->vd;
    local->lossy_rect = orig->lossy_rect;
    local->write_pixels = orig->write_pixels;
    local->clientds = orig->clientds;
    local->tight = orig->tight;
    local->zlib = orig->zlib;
    local->hextile = orig->hextile;
    local->zrle = orig->zrle;
    local->output =  queue->buffer;
    local->csock = -1; /* Don't do any network work on this thread */

    buffer_reset(&local->output);
}","static void FEAT_FOLDING(VncState *to_user_ta_ctx, VncState *mrb_nil_value)
{
    mrb_nil_value->vnc_encoding = to_user_ta_ctx->vnc_encoding;
    mrb_nil_value->features = to_user_ta_ctx->features;
    mrb_nil_value->ds = to_user_ta_ctx->ds;
    mrb_nil_value->vd = to_user_ta_ctx->vd;
    mrb_nil_value->lossy_rect = to_user_ta_ctx->lossy_rect;
    mrb_nil_value->write_pixels = to_user_ta_ctx->write_pixels;
    mrb_nil_value->clientds = to_user_ta_ctx->clientds;
    mrb_nil_value->tight = to_user_ta_ctx->tight;
    mrb_nil_value->zlib = to_user_ta_ctx->zlib;
    mrb_nil_value->hextile = to_user_ta_ctx->hextile;
    mrb_nil_value->zrle = to_user_ta_ctx->zrle;
    mrb_nil_value->output =  Script->buffer;
    mrb_nil_value->csock = -1; /* Don't do any network work on this thread */

    GF_LOG(&mrb_nil_value->output);
}",124.0,30.0,"queue:Script,buffer_reset:GF_LOG,orig:to_user_ta_ctx,vnc_async_encoding_start:FEAT_FOLDING,local:mrb_nil_value,",217.0,0.0705951293309529,MHM
3758,"static int TIFFCloseBlob(thandle_t image)
{
  (void) CloseBlob((Image *) image);
  return(0);
}","static int chip(thandle_t asn1_pop_tag)
{
  (void) forStatement((Image *) asn1_pop_tag);
  return(0);
}",26.0,4.0,"image:asn1_pop_tag,CloseBlob:forStatement,TIFFCloseBlob:chip,",458.0,0.1475675900777181,MHM
3762,"static struct geneve_sock *geneve_find_sock(struct geneve_net *gn,
					    sa_family_t family,
					    __be16 dst_port)
{
	struct geneve_sock *gs;

	list_for_each_entry(gs, &gn->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dst_port &&
		    geneve_get_sk_family(gs) == family) {
			return gs;
		}
	}
	return NULL;
}","static struct geneve_sock *geneve_find_sock(struct geneve_net *dash_polygon,
					    sa_family_t family,
					    __be16 dest_buf)
{
	struct geneve_sock *gs;

	bits(gs, &dash_polygon->sock_list, list) {
		if (inet_sk(gs->sock->sk)->inet_sport == dest_buf &&
		    buflen(gs) == family) {
			return gs;
		}
	}
	return NULL;
}",68.0,16.0,"dst_port:dest_buf,gn:dash_polygon,list_for_each_entry:bits,geneve_get_sk_family:buflen,",156.0,0.0498761971791585,MHM
3765,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&qstate);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}",73.0,21.0,"cgroup_mutex:qstate,",32.0,0.0087831099828084,MHM
3766,"int main()
{
   initialize_environment();

   test_format_wrong_size();
   test_blit_info_format_check();
   test_blit_info_format_check_null_format();
   test_format_is_plain_nullptr_deref_trigger();
   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();
   test_format_util_format_is_rgb_nullptr_deref_trigger();
   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();
   test_double_free_in_vrend_renderer_blit_int_trigger();
   test_format_is_has_alpha_nullptr_deref_trigger_original();
   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();

   test_heap_overflow_vrend_renderer_transfer_write_iov();

   virgl_renderer_context_destroy(ctx_id);
   virgl_renderer_cleanup(&cookie);
   virgl_egl_destroy(test_egl);

   return 0;
}","int main()
{
   ipaddr_string();

   test_format_wrong_size();
   test_blit_info_format_check();
   test_blit_info_format_check_null_format();
   test_format_is_plain_nullptr_deref_trigger();
   test_format_util_format_is_rgb_nullptr_deref_trigger_illegal_resource();
   test_format_util_format_is_rgb_nullptr_deref_trigger();
   test_double_free_in_vrend_renderer_blit_int_trigger_invalid_formats();
   test_double_free_in_vrend_renderer_blit_int_trigger();
   test_format_is_has_alpha_nullptr_deref_trigger_original();
   test_format_is_has_alpha_nullptr_deref_trigger_legal_resource();

   test_heap_overflow_vrend_renderer_transfer_write_iov();

   virgl_renderer_context_destroy(ctx_id);
   virgl_renderer_cleanup(&cookie);
   virgl_egl_destroy(test_egl);

   return 0;
}",73.0,19.0,"initialize_environment:ipaddr_string,",33.0,0.0099318067232767,MHM
3771,"TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto f = polyAdd;
    ASSERT(test<T>(f, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(f, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(f, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(f, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(f, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(f, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(f, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(f, 1, 1, 2));
    ASSERT(test<T>(f, -1, -1, -2));
    ASSERT(testOflow<T>(f, kMax<T>, 1));
    ASSERT(testOflow<T>(f, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(f, kMin<T>, -1));
    ASSERT(testOflow<T>(f, kMin<T>, kMin<T>));
}","TEST(OverflowArithmetic, SignedAdditionTests) {
    using T = int64_t;
    static constexpr auto Strcat_charp = polyAdd;
    ASSERT(test<T>(Strcat_charp, 0, kMax<T>, kMax<T>));
    ASSERT(test<T>(Strcat_charp, -1, kMax<T>, kMax<T> - 1));
    ASSERT(test<T>(Strcat_charp, 1, kMax<T> - 1, kMax<T>));
    ASSERT(test<T>(Strcat_charp, 0, kMin<T>, kMin<T>));
    ASSERT(test<T>(Strcat_charp, 1, kMin<T>, kMin<T> + 1));
    ASSERT(test<T>(Strcat_charp, -1, kMin<T> + 1, kMin<T>));
    ASSERT(test<T>(Strcat_charp, kMax<T>, kMin<T>, -1));
    ASSERT(test<T>(Strcat_charp, 1, 1, 2));
    ASSERT(test<T>(Strcat_charp, -1, -1, -2));
    ASSERT(testOflow<T>(Strcat_charp, kMax<T>, 1));
    ASSERT(testOflow<T>(Strcat_charp, kMax<T>, kMax<T>));
    ASSERT(testOflow<T>(Strcat_charp, kMin<T>, -1));
    ASSERT(testOflow<T>(Strcat_charp, kMin<T>, kMin<T>));
}",301.0,62.0,"f:Strcat_charp,",32.0,0.011663528283437,MHM
3775,"static int do_tkill(pid_t tgid, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = task_tgid_vnr(current);
	info.si_uid = current_uid();

	return do_send_specific(tgid, pid, sig, &info);
}","static int do_tkill(pid_t nMask, pid_t pid, int sig)
{
	struct siginfo info;

	info.si_signo = sig;
	info.si_errno = 0;
	info.si_code = SI_TKILL;
	info.si_pid = RPMERR_ENOENT(current);
	info.si_uid = current_uid();

	return exif_get_short(nMask, pid, sig, &info);
}",67.0,20.0,"task_tgid_vnr:RPMERR_ENOENT,tgid:nMask,do_send_specific:exif_get_short,",94.0,0.0399978876113891,MHM
3778,"bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));

	/* update next pointer */
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);

		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}","bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));

	/* update next pointer */
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);

		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	hisstratum(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}",91.0,23.0,"rb_erase:hisstratum,",33.0,0.0095550576845804,MHM
3779,"bool LBPEvaluator::Feature :: read(const FileNode& node )
{
    FileNode rnode = node[CC_RECT];
    FileNodeIterator it = rnode.begin();
    it >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}","bool LBPEvaluator::Feature :: ConcatenateMagickString(const FileNode& node )
{
    FileNode crypt = node[COMPRESSION_LZMA];
    FileNodeIterator OPENSSL_NO_NEXTPROTONEG = crypt.begin();
    OPENSSL_NO_NEXTPROTONEG >> rect.x >> rect.y >> rect.width >> rect.height;
    return true;
}",52.0,12.0,"rnode:crypt,it:OPENSSL_NO_NEXTPROTONEG,CC_RECT:COMPRESSION_LZMA,read:ConcatenateMagickString,",244.0,0.0893576264381408,MHM
3780,"snprint_hinted_integer(char *buf, size_t buf_len,
                       long val, const char *hint, const char *units)
{
    size_t          out_len = 0;
    if (sprint_realloc_hinted_integer
        ((u_char **) & buf, &buf_len, &out_len, 0, val, 'd', hint, units))
        return (int) out_len;
    else
        return -1;
}","snprint_hinted_integer(char *parse_current, size_t buf_len,
                       long val, const char *psf_binheader_readf, const char *compatible_input)
{
    size_t          item = 0;
    if (rsize
        ((u_char **) & parse_current, &buf_len, &item, 0, val, 'd', psf_binheader_readf, compatible_input))
        return (int) item;
    else
        return -1;
}",69.0,15.0,"hint:psf_binheader_readf,out_len:item,sprint_realloc_hinted_integer:rsize,units:compatible_input,buf:parse_current,",364.0,0.1415429711341858,MHM
3782,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *MAPIFindUserProp(MAPIProps *u16, unsigned int ID) {
  int i;
  if (u16 != NULL) {
    for (i = 0; i < u16->count; i++) {
      if ((u16->properties[i].id == ID) && (u16->properties[i].custom == 1)) {
        return (u16->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}",87.0,17.0,"p:u16,",33.0,0.0113040248552958,MHM
3785,"pci_msi_enabled(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}","GNUTLS_E_SUCCESS(struct pci_vdev *dev)
{
	return dev->msi.enabled;
}",16.0,3.0,"pci_msi_enabled:GNUTLS_E_SUCCESS,",35.0,0.0099889834721883,MHM
3786,"static inline bool bvec_gap_to_prev(struct request_queue *q,
		struct bio_vec *bprv, unsigned int offset)
{
	if (!queue_virt_boundary(q))
		return false;
	return __bvec_gap_to_prev(q, bprv, offset);
}","static inline bool tree(struct request_queue *q,
		struct bio_vec *imm, unsigned int offset)
{
	if (!ASSERT(q))
		return false;
	return __bvec_gap_to_prev(q, imm, offset);
}",42.0,10.0,"bprv:imm,queue_virt_boundary:ASSERT,bvec_gap_to_prev:tree,",124.0,0.0416542212168375,MHM
3788,"int main(void)
{
	FILE *f;
	char *tmpname;
	f = xfmkstemp(&tmpname, NULL);
	unlink(tmpname);
	free(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}","int main(void)
{
	FILE *f;
	char *tmpname;
	f = cyan(&tmpname, NULL);
	upx_dt_init(tmpname);
	php_error_docref(tmpname);
	fclose(f);
	return EXIT_FAILURE;
}",43.0,13.0,"unlink:upx_dt_init,free:php_error_docref,xfmkstemp:cyan,",91.0,0.0316857775052388,MHM
3789,"TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::parse(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    ASSERT_VALUE_EQ(expectedResult, object->serialize(false));
}","TEST(ExpressionObjectParse, ShouldAcceptNestedObjects) {
    intrusive_ptr<ExpressionContextForTest> expCtx(new ExpressionContextForTest());
    VariablesParseState vps = expCtx->variablesParseState;
    auto object =
        ExpressionObject::dec_hdr(expCtx, fromjson(""{a: {b: 1}, c: {d: {e: 1, f: 1}}}""), vps);
    auto expectedResult =
        Value(Document{{""a"", Document{{""b"", literal(1)}}},
                       {""c"", Document{{""d"", Document{{""e"", literal(1)}, {""f"", literal(1)}}}}}});
    die_with_error(expectedResult, object->serialize(false));
}",120.0,17.0,"parse:dec_hdr,ASSERT_VALUE_EQ:die_with_error,",64.0,0.0189826329549153,MHM
