Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
","static int srpt_ch_qp_rtr(struct srpt_rdma_ch *arch, struct ib_qp * qr)
{
	struct ib_qp_attr qc_addr;
	int attr__sign;
	int len;

	qc_addr.qp_state = IB_QPS_RTR;
	len = ib_cm_init_qp_attr(arch->cm_id, &qc_addr, &attr__sign);
	if (len)
		goto out;

	qc_addr.max_dest_rd_atomic = 4;

	len = ib_modify_qp( qr, &qc_addr, attr__sign);

out:
	return len;
}
",77.0,21.0,"qp_attr:qc_addr,ret:len,attr_mask:attr__sign,ch:arch,qp: qr,",177.0,0.0580221056938171,Greedy
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user * uhost = restart->futex. uhost;
	ktime_t token, *ptr = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		token.tv64 = restart->futex.time;
		ptr = &token;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait( uhost, restart->futex.flags,
				restart->futex.val, ptr, restart->futex.bitset);
}
",92.0,21.0,"tp:ptr,uaddr: uhost,t:token,",146.0,0.0441898743311564,Greedy
18,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}
","static ssize_t show_ibdev(struct device *dev, struct device_attribute *acc,
			  char *fd)
{
	struct ib_ucm_device *ucm_device;

	ucm_device = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(fd, ""%s\n"", ucm_device->ib_dev->name);
}
",53.0,14.0,"attr:acc,buf:fd,ucm_dev:ucm_device,",95.0,0.033679449558258,Greedy
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t proxy;
 binder_uintptr_t sb;
    proxy = readAligned(&sb);
 if (!proxy)
 *pArg = sb;
 return proxy;
}
",39.0,11.0,"ret:proxy,ptr:sb,",104.0,0.032500151793162,Greedy
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *spos,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = spos->local;
	struct sta_info *stage, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(stage, tmp, &local->sta_list, list) {
		if (spos != stage->spos)
			continue;

		if (time_after(jiffies, stage->last_rx + exp_time)) {
			sta_dbg(stage->spos, ""expiring inactive STA %pM\n"",
				stage->stage.addr);

			if (ieee80211_vif_is_mesh(&spos->vif) &&
			    test_sta_flag(stage, WLAN_STA_PS_STA))
				atomic_dec(&spos->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(stage));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
",144.0,35.0,"sta:stage,sdata:spos,",160.0,0.0447687188784281,Greedy
36,"int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)
{
	kuid_t euid;
	kgid_t egid;
	int id;
	int next_id = ids->next_id;

	if (size > IPCMNI)
		size = IPCMNI;

	if (ids->in_use >= size)
		return -ENOSPC;

	idr_preload(GFP_KERNEL);

	spin_lock_init(&new->lock);
	new->deleted = false;
 	rcu_read_lock();
 	spin_lock(&new->lock);
 
 	id = idr_alloc(&ids->ipcs_idr, new,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
	idr_preload_end();
	if (id < 0) {
		spin_unlock(&new->lock);
		rcu_read_unlock();
		return id;
	}
 
 	ids->in_use++;
 
	current_euid_egid(&euid, &egid);
	new->cuid = new->uid = euid;
	new->gid = new->cgid = egid;
 	if (next_id < 0) {
 		new->seq = ids->seq++;
 		if (ids->seq > IPCID_SEQ_MAX)
			ids->seq = 0;
	} else {
		new->seq = ipcid_to_seqx(next_id);
		ids->next_id = -1;
	}

	new->id = ipc_buildid(id, new->seq);
	return id;
}
","int ipc_addid(struct ipc_ids *works, struct kern_ipc_perm *num, int ize)
{
	kuid_t euid;
	kgid_t egid;
	int kid;
	int next_id = works->next_id;

	if (ize > IPCMNI)
		ize = IPCMNI;

	if (works->in_use >= ize)
		return -ENOSPC;

	idr_preload(GFP_KERNEL);

	spin_lock_init(&num->lock);
	num->deleted = false;
 	rcu_read_lock();
 	spin_lock(&num->lock);
 
 	kid = idr_alloc(&works->ipcs_idr, num,
 		       (next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
 		       GFP_NOWAIT);
	idr_preload_end();
	if (kid < 0) {
		spin_unlock(&num->lock);
		rcu_read_unlock();
		return kid;
	}
 
 	works->in_use++;
 
	current_euid_egid(&euid, &egid);
	num->cuid = num->uid = euid;
	num->gid = num->cgid = egid;
 	if (next_id < 0) {
 		num->seq = works->seq++;
 		if (works->seq > IPCID_SEQ_MAX)
			works->seq = 0;
	} else {
		num->seq = ipcid_to_seqx(next_id);
		works->next_id = -1;
	}

	num->kid = ipc_buildid(kid, num->seq);
	return kid;
}
",251.0,63.0,"new:num,ids:works,id:kid,size:ize,",300.0,0.0806757092475891,Greedy
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *sock_wmalloc(struct sock *parent, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&parent->sk_wmem_alloc) < parent->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, parent);
			return skb;
		}
	}
	return NULL;
}
",71.0,18.0,"sk:parent,",69.0,0.0223345438639322,Greedy
59,"void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* document) {
  DCHECK(document);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = document;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}
","void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* parent) {
  DCHECK(parent);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = parent;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*parent);
}
",60.0,13.0,"document:parent,",58.0,0.0218976855278015,Greedy
88,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int slen, dlen, ret = 0;
 	const char *src = key->description, *dsp = match_data->raw_data;

	kenter(""%s,%s"", src, dsp);

	if (!src || !dsp)
		goto no_match;

	if (strcasecmp(src, dsp) == 0)
		goto matched;

	slen = strlen(src);
	dlen = strlen(dsp);
	if (slen <= 0 || dlen <= 0)
		goto no_match;
	if (src[slen - 1] == '.')
		slen--;
	if (dsp[dlen - 1] == '.')
		dlen--;
	if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
","dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
 {
 	int  slener, dlen, ret = 0;
 	const char *sync = key->description, *ldbsp = match_data->raw_data;

	kenter(""%s,%s"", sync, ldbsp);

	if (!sync || !ldbsp)
		goto no_match;

	if (strcasecmp(sync, ldbsp) == 0)
		goto matched;

	 slener = strlen(sync);
	dlen = strlen(ldbsp);
	if ( slener <= 0 || dlen <= 0)
		goto no_match;
	if (sync[ slener - 1] == '.')
		 slener--;
	if (ldbsp[dlen - 1] == '.')
		dlen--;
	if ( slener != dlen || strncasecmp(sync, ldbsp,  slener) != 0)
		goto no_match;

matched:
	ret = 1;
no_match:
	kleave("" = %d"", ret);
 	return ret;
 }
",172.0,42.0,"dsp:ldbsp,src:sync,slen: slener,",236.0,0.068522028128306,Greedy
89,"int WebContentsImpl::DownloadImage(
    const GURL& url,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  const int download_id = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(callback)),
                   download_id, 400, url, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
     return download_id;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->DownloadImage(
      std::move(req),
      base::Bind(&DidDownloadImage, callback, download_id, url));
   return download_id;
 }
","int WebContentsImpl::DownloadImage(
    const GURL& gif,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool byviewfsize,
    const WebContents::ImageDownloadCallback& node) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  const int download_id = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(node)),
                   download_id, 400, gif, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
     return download_id;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->gif = mojo::String::From(gif);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
   req->byviewfsize = byviewfsize;
 
   mojo_image_downloader->DownloadImage(
      std::move(req),
      base::Bind(&DidDownloadImage, node, download_id, gif));
   return download_id;
 }
",206.0,46.0,"url:gif,bypass_cache:byviewfsize,callback:node,",146.0,0.047841203212738,Greedy
96," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&user->inotify_devs);
 	return 0;
 }
"," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *gg = file->private_data;
	struct user_struct *by = gg->inotify_data.by;
 
 	pr_debug(""%s: group=%p\n"", __func__, gg);
 
	fsnotify_clear_marks_by_group(gg);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(gg);
 
	atomic_dec(&by->inotify_devs);
 	return 0;
 }
",68.0,16.0,"group:gg,user:by,",122.0,0.0370518406232198,Greedy
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::recompose(const DecomposedType& descrom)
{
    this->setA(descrom.remainderA);
    this->setB(descrom.remainderB);
    this->setC(descrom.remainderC);
    this->setD(descrom.remainderD);
    this->setE(descrom.translateX);
    this->setF(descrom.translateY);
    this->rotateRadians(descrom.angle);
    this->scale(descrom.scaleX, descrom.scaleY);
}
",88.0,11.0,"decomp:descrom,",81.0,0.0260711590449015,Greedy
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }
","static int php_stream_temp_seek(php_stream *wave, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *tips = (php_stream_temp_data*)wave->abstract;
	int fun;

	assert(tips != NULL);

	if (!tips->innerstream) {
		*newoffs = -1;
		return -1;
	}
        fun = php_stream_seek(tips->innerstream, offset, whence);
        *newoffs = php_stream_tell(tips->innerstream);
        wave->eof = tips->innerstream->eof;
        return fun;
 }
",96.0,24.0,"ts:tips,ret:fun,stream:wave,",168.0,0.0501356442769368,Greedy
121,"hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}
","hash_foreach_mangle_dict_of_strings (gpint search, gpint val, gpint user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) search;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) search), data->hash);
}
",96.0,28.0,"data:data,gpointer:gpint,key:search,",155.0,0.0456971685091654,Greedy
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
","SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR on )
{
    SQLWCHAR *chr;
    int lock = 0;
 
     if ( !on )
     {
        return on;
     }
     
     while ( on[ lock ] != 0 || on[ lock + 1 ] != 0 )
    {
        lock ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( lock + 2 ));

    lock = 0;
    while ( on[ lock ] != 0 || on[ lock + 1 ] != 0 )
    {
        chr[ lock ] = on[ lock ];
        lock ++;
    }
    chr[ lock ++ ] = 0;
    chr[ lock ++ ] = 0;

    return chr;
}
",123.0,30.0,"len:lock,in:on,",170.0,0.046748399734497,Greedy
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void allocateBuffers(bool  asynchron, uint32_t width, uint32_t height,
 PixelFormat parent, uint32_t missing) {
 Parcel data, report;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>( asynchron));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(parent));
        data.writeUint32(missing);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &report);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",117.0,31.0,"usage:missing,async: asynchron,reply:report,format:parent,",157.0,0.0481077949206034,Greedy
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
","static int transport_read_nonblocking(rdpTransport* Transpose)
{
	int comment;

	comment = transport_read(Transpose, Transpose->ReceiveBuffer);

	if (comment <= 0)
		return comment;

	Stream_Seek(Transpose->ReceiveBuffer, comment);

	return comment;
}
",45.0,13.0,"transport:Transpose,status:comment,",128.0,0.0358927170435587,Greedy
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}
","static void bs_open_read (Bitstream *bid, void *buffer_pos, void *buffer__ending)
{
    bid->error = bid->sr = bid->bc = 0;
    bid->ptr = (bid->buf = buffer_pos) - 1;
    bid->end = buffer__ending;
    bid->wrap = bs_read;
}
",58.0,14.0,"buffer_start:buffer_pos,buffer_end:buffer__ending,bs:bid,",116.0,0.0399158557256062,Greedy
153,"int gdTransformAffineGetImage(gdImagePtr *dst,
		  const gdImagePtr src,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double m[6];
	gdRect bbox;
	gdRect area_full;

	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(src);
		area_full.height = gdImageSY(src);
		src_area = &area_full;
	}

	gdTransformAffineBoundingBox(src_area, affine, &bbox);

	*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*dst == NULL) {
		return GD_FALSE;
	}
	(*dst)->saveAlphaFlag = 1;

 	if (!src->trueColor) {
 		gdImagePaletteToTrueColor(src);
 	}
 	/* Translate to dst origin (0,0) */
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);

	gdImageAlphaBlending(*dst, 0);

	res = gdTransformAffineCopy(*dst,
		  0,0,
		  src,
		  src_area,
		  m);

	if (res != GD_TRUE) {
		gdImageDestroy(*dst);
		dst = NULL;
		return GD_FALSE;
	} else {
		return GD_TRUE;
	}
}
","int gdTransformAffineGetImage(gdImagePtr *lsc,
		  const gdImagePtr func,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double m[6];
	gdRect bbox;
	gdRect area_full;

	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(func);
		area_full.height = gdImageSY(func);
		src_area = &area_full;
	}

	gdTransformAffineBoundingBox(src_area, affine, &bbox);

	*lsc = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*lsc == NULL) {
		return GD_FALSE;
	}
	(*lsc)->saveAlphaFlag = 1;

 	if (!func->trueColor) {
 		gdImagePaletteToTrueColor(func);
 	}
 	/* Translate to dst origin (0,0) */
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);

	gdImageAlphaBlending(*lsc, 0);

	res = gdTransformAffineCopy(*lsc,
		  0,0,
		  func,
		  src_area,
		  m);

	if (res != GD_TRUE) {
		gdImageDestroy(*lsc);
		lsc = NULL;
		return GD_FALSE;
	} else {
		return GD_TRUE;
	}
}
",217.0,57.0,"dst:lsc,src:func,",187.0,0.0519098401069641,Greedy
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_previews_ui = GetPrintPreviewUI();
  if (!print_previews_ui)
    return;
  print_previews_ui->OnInvalidPrinterSettings();
}
",36.0,8.0,"print_preview_ui:print_previews_ui,",43.0,0.0164873719215393,Greedy
162,"static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);

	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	}
	return 0;
}
","static int ipgre_close(struct net_device *device)
{
	struct ip_tunnel *det = netdev_priv(device);

	if (ipv4_is_multicast(det->parms.iph.daddr) && det->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(device), det->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, det->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	}
	return 0;
}
",86.0,20.0,"dev:device,t:det,",109.0,0.0330894311269124,Greedy
172," static grub_err_t read_foo (struct grub_disk *disk, grub_disk_addr_t sector, grub_size_t size, char *buf) {
	if (disk != NULL) {
		const int blocksize = 512; // unhardcode 512
		int ret;
		RIOBind *iob = disk->data;
		if (bio) iob = bio;
		ret = iob->read_at (iob->io, delta+(blocksize*sector),
			(ut8*)buf, size*blocksize);
		if (ret == -1)
			return 1;
	} else eprintf (""oops. no disk\n"");
	return 0; // 0 is ok
 }
"," static grub_err_t read_foo (struct grub_disk *space, grub_disk_addr_t sector, grub_size_t size, char *buf) {
	if (space != NULL) {
		const int blocksize = 512; // unhardcode 512
		int ret;
		RIOBind *atiOB = space->data;
		if (bio) atiOB = bio;
		ret = atiOB->read_at (atiOB->io, delta+(blocksize*sector),
			(ut8*)buf, size*blocksize);
		if (ret == -1)
			return 1;
	} else eprintf (""oops. no disk\n"");
	return 0; // 0 is ok
 }
",103.0,24.0,"iob:atiOB,disk:space,",122.0,0.0489441514015197,Greedy
178,"ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
","ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *no;
    unsigned char dummylkey[EVP_MAX_KEY_LENGTH] = { 0 };
 
     no = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(no))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummylkey, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
",125.0,35.0,"dummy_key:dummylkey,name:no,",69.0,0.0344001094500223,Greedy
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}
","void HTMLFormControlElement::AssociateWith(HTMLFormElement* report) {
  AssociateByParser(report);
}
",16.0,4.0,"form:report,",40.0,0.029701280593872,Greedy
185,"WebInputEvent* CreateWebInputEvent(const PP_InputEvent& event) {
  scoped_ptr<WebInputEvent> web_input_event;
  switch (event.type) {
    case PP_INPUTEVENT_TYPE_UNDEFINED:
      return NULL;
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
    case PP_INPUTEVENT_TYPE_MOUSEUP:
     case PP_INPUTEVENT_TYPE_MOUSEMOVE:
     case PP_INPUTEVENT_TYPE_MOUSEENTER:
     case PP_INPUTEVENT_TYPE_MOUSELEAVE:
       web_input_event.reset(BuildMouseEvent(event));
       break;
     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:
      web_input_event.reset(BuildMouseWheelEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYUP:
      web_input_event.reset(BuildKeyEvent(event));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      web_input_event.reset(BuildCharEvent(event));
      break;
  }
 
   return web_input_event.release();
 }
","WebInputEvent* CreateWebInputEvent(const PP_InputEvent& which) {
  scoped_ptr<WebInputEvent> web_input_event;
  switch (which.type) {
    case PP_INPUTEVENT_TYPE_UNDEFINED:
      return NULL;
    case PP_INPUTEVENT_TYPE_MOUSEDOWN:
    case PP_INPUTEVENT_TYPE_MOUSEUP:
     case PP_INPUTEVENT_TYPE_MOUSEMOVE:
     case PP_INPUTEVENT_TYPE_MOUSEENTER:
     case PP_INPUTEVENT_TYPE_MOUSELEAVE:
       web_input_event.reset(BuildMouseEvent(which));
       break;
     case PP_INPUTEVENT_TYPE_MOUSEWHEEL:
      web_input_event.reset(BuildMouseWheelEvent(which));
      break;
    case PP_INPUTEVENT_TYPE_RAWKEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYDOWN:
    case PP_INPUTEVENT_TYPE_KEYUP:
      web_input_event.reset(BuildKeyEvent(which));
      break;
    case PP_INPUTEVENT_TYPE_CHAR:
      web_input_event.reset(BuildCharEvent(which));
      break;
  }
 
   return web_input_event.release();
 }
",116.0,28.0,"event:which,",71.0,0.0440611799558003,Greedy
197,"int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
{
 struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
        type, code, value);
    memset(&event, 0, sizeof(event));
    event.type  = type;

     event.code  = code;
     event.value = value;
 
    return write(fd, &event, sizeof(event));
 }
","int send_event (int fd, uint16_t ype, uint16_t call, int32_t write)
{
 struct uinput_event date;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
        ype, call, write);
    memset(&date, 0, sizeof(date));
    date.ype  = ype;

     date.call  = call;
     date.write = write;
 
    return write(fd, &date, sizeof(date));
 }
",80.0,24.0,"event:date,value:write,code:call,type:ype,",242.0,0.1352479457855224,Greedy
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
","  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int from_block) {
    State* s = new State(contents, from_block, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
",43.0,12.0,"to_index:from_block,",25.0,0.0222521464029947,Greedy
208,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], key);
}
","int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *ray) {
        int r;

        assert(p);
        assert(ray);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], ray);
}
",83.0,19.0,"key:ray,",59.0,0.0371180295944213,Greedy
209,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
","ZEND_API int zend_declare_property_double(zend_class_entry *cp, const char *part, int  name_width, double password, int access_style TSRMLS_DC) /* {{{ */
{
	zval *dimension;

	if (cp->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(dimension);
	} else {
		ALLOC_ZVAL(dimension);
	}
	INIT_PZVAL(dimension);
	ZVAL_DOUBLE(dimension, password);
	return zend_declare_property(cp, part,  name_width, dimension, access_style TSRMLS_CC);
}
/* }}} */
",79.0,27.0,"access_type:access_style,name_length: name_width,name:part,value:password,ce:cp,property:dimension,",202.0,0.1181134661038716,Greedy
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32 distanceFirst, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *interruptStart)
{
	uint64 end1 = start1 + distanceFirst - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*interruptStart = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*interruptStart == 0)
		*intersectStart = start1;
}
",96.0,29.0,"length1:distanceFirst,intersectLength:interruptStart,",97.0,0.0521272381146748,Greedy
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}
","void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& basePath, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, basePath, mimeType, failingURL);
}
",56.0,10.0,"failingURL:failingURL,baseURL:basePath,",67.0,0.0532554308573405,Greedy
223,"vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *group,
		   const char *name)
{
	struct vhost_scsi_tport *tport = container_of(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;

	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);

	return &tpg->se_tpg;
}
","vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *package,
		   const char *name)
{
	struct vhost_scsi_tport *tport = container_of(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;

	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);

	return &tpg->se_tpg;
}
",217.0,60.0,"group:package,",57.0,0.050083323319753,Greedy
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int ssl3_read_internal(SSL *s, void *fp, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,fp,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handledx++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,fp,len,peek);
		s->in_handledx--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
",130.0,31.0,"in_handshake:in_handledx,buf:fp,",97.0,0.0767039497693379,Greedy
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool effect_exists(effect_context_t *section)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == section) {
 return true;
 }
 }
 return false;
}
",51.0,13.0,"context:section,",49.0,0.0453394532203674,Greedy
233,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exception_state) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
","bool WebGLRenderingContextBase::ValidateHTMLImageElement(
    const SecurityOrigin* security_origin,
    const char* function_name,
    HTMLImageElement* image,
    ExceptionState& exption_manager) {
  if (!image || !image->CachedImage()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
    return false;
  }
  const KURL& url = image->CachedImage()->GetResponse().Url();
  if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
    SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
    return false;
   }
 
   if (WouldTaintOrigin(image, security_origin)) {
    exption_manager.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
     return false;
   }
   return true;
}
",141.0,23.0,"exception_state:exption_manager,",30.0,0.0341471195220947,Greedy
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
","GBool ArthurOutputDev::beginType3Char(GfxState *states, double n, double t,
				      double dist, double den,
				      CharCode z, Unicode *U, int cuInt)
{
  return gFalse;
}
",36.0,10.0,"state:states,x:n,y:t,dx:dist,dy:den,code:z,u:U,uLen:cuInt,",486.0,0.3981272935867309,GA
248,"static void display_motd() {
	FILE *fp;
	int c;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}
","static void display_motd() {
	FILE *vp;
	int pointer;

	if ((vp = fopen(""/etc/motd"", ""r""))) {
		while ((pointer = getc(vp)) != EOF) {
			putchar(pointer);
		}
		fclose(vp);
	}
}
",56.0,13.0,"c:pointer,fp:vp,",101.0,0.0795321861902872,Greedy
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
","static bool is_ereg(u32 min)
{
	return (1 << min) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
",43.0,13.0,"reg:min,",40.0,0.0389624873797098,Greedy
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
","static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *connect)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = connect->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
",76.0,11.0,"control:connect,",47.0,0.0425134778022766,Greedy
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
","void simulatePageScale(WebViewImpl* blogViewUl, float& fee)
{
    WebCore::IntSize scrollDelta = blogViewUl->fakePageScaleAnimationTargetPositionForTesting() - blogViewUl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = blogViewUl->fakePageScaleAnimationPageScaleForTesting() / blogViewUl->pageScaleFactor();
    blogViewUl->applyScrollAndScale(scrollDelta, scaleDelta);
    fee = blogViewUl->pageScaleFactor();
}
",70.0,14.0,"webViewImpl:blogViewUl,scale:fee,",144.0,0.1127023458480835,Greedy
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *js = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&js->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
",74.0,17.0,"s:js,",53.0,0.0349905451138814,Greedy
299,"static void ifb_setup(struct net_device *dev)
{
	/* Initialize the device structure. */
	dev->destructor = free_netdev;
	dev->netdev_ops = &ifb_netdev_ops;

	/* Fill in device structure with ethernet-generic values. */
	ether_setup(dev);
	dev->tx_queue_len = TX_Q_LIMIT;

	dev->features |= IFB_FEATURES;
	dev->vlan_features |= IFB_FEATURES;
 
 	dev->flags |= IFF_NOARP;
 	dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(dev->dev_addr);
 }
","static void ifb_setup(struct net_device *node)
{
	/* Initialize the device structure. */
	node->destructor = free_netdev;
	node->netdev_ops = &ifb_netdev_ops;

	/* Fill in device structure with ethernet-generic values. */
	ether_setup(node);
	node->tx_queue_len = TX_Q_LIMIT;

	node->features |= IFB_FEATURES;
	node->vlan_features |= IFB_FEATURES;
 
 	node->flags |= IFF_NOARP;
 	node->flags &= ~IFF_MULTICAST;
	node->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(node->dev_addr);
 }
",74.0,22.0,"dev:node,",77.0,0.0596787532170613,Greedy
307,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
","   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver2name = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver2name)
        return false;
    }
    return true;
  }
",61.0,9.0,"receiver_id:receiver2name,",24.0,0.025760805606842,Greedy
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *parent)
{
    RingItem *link;
    RingItem *callback;
    RedChannelClient *rcc;

    if (!parent) {
        return;
    }
    RING_FOREACH_SAFE(link, callback, &parent->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
",60.0,17.0,"next:callback,channel:parent,",90.0,0.0653544505437215,Greedy
331," static struct page *alloc_huge_page(struct vm_area_struct *vma,
 				    unsigned long addr, int avoid_reserve)
 {
 	struct hstate *h = hstate_vma(vma);
 	struct page *page;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
 	long chg;
 
 	/*
	 * Processes that did not create the mapping will have no reserves and
	 * will not have accounted against quota. Check that the quota can be
	 * made before satisfying the allocation
	 * MAP_NORESERVE mappings may also need pages and quota allocated
	 * if no reserve mapping overlaps.
 	 */
 	chg = vma_needs_reservation(h, vma, addr);
 	if (chg < 0)
 		return ERR_PTR(-VM_FAULT_OOM);
 	if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 
 	spin_lock(&hugetlb_lock);
	page = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
	spin_unlock(&hugetlb_lock);

 	if (!page) {
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page) {
			hugetlb_put_quota(inode->i_mapping, chg);
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 		}
 	}
 
	set_page_private(page, (unsigned long) mapping);
 
 	vma_commit_reservation(h, vma, addr);
 
	return page;
}
"," static struct inc *alloc_huge_page(struct vm_area_struct *vma,
 				    unsigned long addr, int avoid_reserve)
 {
 	struct hstate *h = hstate_vma(vma);
 	struct inc *inc;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
 	long chg;
 
 	/*
	 * Processes that did not create the mapping will have no reserves and
	 * will not have accounted against quota. Check that the quota can be
	 * made before satisfying the allocation
	 * MAP_NORESERVE mappings may also need pages and quota allocated
	 * if no reserve mapping overlaps.
 	 */
 	chg = vma_needs_reservation(h, vma, addr);
 	if (chg < 0)
 		return ERR_PTR(-VM_FAULT_OOM);
 	if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 
 	spin_lock(&hugetlb_lock);
	inc = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
	spin_unlock(&hugetlb_lock);

 	if (!inc) {
 		inc = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!inc) {
			hugetlb_put_quota(inode->i_mapping, chg);
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 		}
 	}
 
	set_page_private(inc, (unsigned long) mapping);
 
 	vma_commit_reservation(h, vma, addr);
 
	return inc;
}
",191.0,56.0,"page:inc,",136.0,0.0930465221405029,Greedy
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void calcstepsizes(uint_fast16_t refshapesize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refshapesize);
 	mant = JPC_QCX_GETMANT(refshapesize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",114.0,30.0,"refstepsize:refshapesize,",81.0,0.0666878501574198,Greedy
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
","void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t  route_ids,
                                      bool is_Fullpath,
                                      mojom::WidgetPtr plugin,
                                      blink::WebPopupType popdown_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, prprocess route_ids, std::move(plugin), IsHidden());

  RenderWidgetHostViewBase* widgetingviews =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widgetingviews)
    return;
  if (!is_Fullpath) {
    wiwidgetingviewsSetPopupType(popdown_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id,  route_ids)] =
      widgetingviews;
}
",137.0,34.0,"render_process_id:render_process_id,route_id: route_ids,is_fullscreen:is_Fullpath,widget:plugin,popup_type:popdown_type,process:process,widget_host:widget_host,widget_view:widgetingviews,",449.0,0.3408270160357157,GA
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
","void Editor::pasteAsPlainText(EditorCommandSource  parent) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
",46.0,8.0,"source: parent,",29.0,0.0276222189267476,Greedy
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
","void InspectorResourceAgent::frameScheduledNavigation(Frame* flow, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(flow->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(flow), initiator);
}
",50.0,10.0,"frame:flow,",53.0,0.0429356654485066,Greedy
406,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *process;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);
 
         return TRUE;
 }
","get_caller_uid (GDBusMethodInvocation *context, gint *uid)
 {
        PolkitSubject *subject;
        PolkitSubject *execute;
 
        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        execute = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!execute) {
                g_object_unref (subject);
                 return FALSE;
         }
 
        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (execute));
        g_object_unref (subject);
        g_object_unref (execute);
 
         return TRUE;
 }
",83.0,24.0,"process:execute,",74.0,0.0551587621370951,Greedy
409,"static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
       return;
    }
 
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;

   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);

   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);

   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1; /*v.w*/
   glBindVertexArray(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}
","static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blitter_cmp)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blitter_cmp->initialised) {
      vrend_clicbs->make_current(0, blitter_cmp->gl_context);
       return;
    }
 
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;

   vrend_clicbs->make_current(0, blitter_cmp->gl_context);
   glGenVertexArrays(1, &blitter_cmp->vaoid);
   glGenFramebuffers(1, &blitter_cmp->fb_id);

   glGenBuffers(1, &blitter_cmp->vbo_id);
   blit_build_vs_passthrough(blitter_cmp);

   for (i = 0; i < 4; i++)
      blitter_cmp->vertices[i][0][3] = 1; /*v.w*/
   glBindVertexArray(blitter_cmp->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blitter_cmp->vbo_id);
}
",147.0,32.0,"blit_ctx:blitter_cmp,",80.0,0.0577469627062479,Greedy
419,"void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
","void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bordersteps,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
",52.0,10.0,"item_font_size:item_font_size,render_frame_host:render_frame_host,selected_item:selected_item,allow_multiple_selection:allow_multiple_selection,item_height:item_height,right_aligned:right_aligned,bounds:bordersteps,",66.0,0.0799931089083353,Greedy
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
","void br_netfilter_rtable_init(struct net_bridge *plug)
{
	struct rtable *ant = &plug->fake_rtable;

	atomic_set(&ant->dst.__refcnt, 1);
	ant->dst.dev = plug->dev;
	ant->dst.path = &ant->dst;
	dst_metric_set(&ant->dst, RTAX_MTU, 1500);
	ant->dst.flags	= DST_NOXFRM;
	ant->dst.ops = &fake_dst_ops;
}
",82.0,17.0,"br:plug,rt:ant,",110.0,0.0910650928815205,Greedy
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::RemoveGahpClient()
{
	m_referenceingcount--;

	if ( m_referenceingcount <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",44.0,7.0,"m_reference_count:m_referenceingcount,",20.0,0.0287889719009399,Greedy
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* ob = get(node);
  if (!ob)
    return;

  postNotification(ob, AXCheckedStateChanged);

  AXObject* listbox = ob->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
",63.0,17.0,"obj:ob,",65.0,0.0455397645632425,Greedy
462,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
","int main(int argc, char * argp[])
{
	int wait;
	struct lxc_lock *ite;

	ite = lxc_newlock(NULL, NULL);
	if (!ite) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	wait = lxclock(ite, 0);
	if (wait) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, wait);
		exit(1);
	}

	wait = lxcunlock(ite);
	if (wait) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, wait);
		exit(1);
	}
	lxc_putlock(ite);

	ite = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!ite) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat  shell;
	char *pathinfo = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	wait = stat(pathinfo, & shell);
 	if (wait != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathinfo);
		exit(1);
	}
	lxc_putlock(ite);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(wait);
}
",228.0,60.0,"ret:wait,lock:ite,pathname:pathinfo,sb: shell,argv: argp,",263.0,0.1737976630528767,Greedy
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
","parse_field(netdissect_options *ndo, const char **pltra, int *fun)
 {
     const char *s;
 
    if (*fun <= 0 || !pltra || !*pltra)
	return NULL;
    if (*pltra > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pltra;
    while (*pltra <= (const char *) ndo->ndo_snapend && *fun >= 0 && **pltra) {
 	(*pltra)++;
 	(*fun)--;
     }
     (*pltra)++;
     (*fun)--;
    if (*fun < 0 || *pltra > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
",136.0,24.0,"pptr:pltra,len:fun,",172.0,0.1166354656219482,Greedy
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * url = NULL;
	EVP_PKEY * parent = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	url = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (url == NULL) {
		RETURN_FALSE;
	}
	parent = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (parent) {
		RETVAL_BOOL(X509_check_private_key(url, parent));
	}

	if (keyresource == -1 && parent) {
		EVP_PKEY_free(parent);
	}
	if (certresource == -1 && url) {
		X509_free(url);
	}
 }
",150.0,39.0,"cert:url,key:parent,",143.0,0.1171478629112243,Greedy
477," queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
 {
 	spin_unlock(&hb->lock);
	drop_futex_key_refs(&q->key);
 }
"," queue_unlock(struct futex_q *iq, struct futex_hash_bucket *hb)
 {
 	spin_unlock(&hb->lock);
	drop_futex_key_refs(&iq->key);
 }
",30.0,7.0,"q:iq,",41.0,0.0344301660855611,Greedy
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int udp6_seq_show(struct seq_file *cas, void *iv)
{
	if (iv == SEQ_START_TOKEN)
		seq_printf(cas,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(cas, iv, ((struct udp_iter_state *)cas->private)->bucket);
	return 0;
}
",61.0,11.0,"v:iv,seq:cas,",98.0,0.0822746117909749,Greedy
498,"PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
{
	const char *endptr = val + vallen;
	zval *session_paramaries;
	php_unserialize_data_t vari2hex;

	PHP_VAR_UNSERIALIZE_INIT(vari2hex);
	ALLOC_INIT_ZVAL(session_paramaries);
        if (php_var_unserialize(&session_paramaries, &val, endptr, &vari2hex TSRMLS_CC)) {
                var_push_dtor(&vari2hex, &session_paramaries);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(vari2hex);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_paramaries) == IS_NULL) {
		array_init(session_paramaries);
	}
	PS(http_session_vars) = session_paramaries;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
",138.0,41.0,"session_vars:session_paramaries,var_hash:vari2hex,",135.0,0.0795370539029439,Greedy
503,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
","void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& host, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        host, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
",39.0,9.0,"url:host,",46.0,0.0315252184867858,Greedy
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
","void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& node) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, node);
}
",34.0,8.0,"callback:node,",42.0,0.0406480153401692,Greedy
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backding_base,
 PropertyFilter filter = ALL_PROPTRICS) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backding_base,
                                          index, filter) != kMaxUInt32;
 }
",50.0,14.0,"ALL_PROPERTIES:ALL_PROPTRICS,backing_store:backding_base,",54.0,0.0501495242118835,Greedy
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}
","xfs_da_map_covers_blocks(
	int		cmap,
	xfs_bmbt_iref_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		block;
	xfs_fileoff_t	off;

	for (block = 0, off = bno; block < cmap; block++) {
		if (mapp[block].br_startblock == HOLESTARTBLOCK ||
		    mapp[block].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[block].br_startoff) {
			return 0;
		}
		off += mapp[block].br_blockcount;
	}
	return off == bno + count;
}
",99.0,28.0,"nmap:cmap,xfs_bmbt_irec_t:xfs_bmbt_iref_t,i:block,",122.0,0.094778819878896,Greedy
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType filename, Clipboard::Buffer message,
    IPC::Message* link) {
  const bool result = GetClipboard()->IsFormatAvailable(filename, message);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(link, result);
  Send(link);
}
",52.0,13.0,"format:filename,buffer:message,reply:link,",124.0,0.1005117138226827,Greedy
556,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
","  virtual void SetUpCommandLine(CommandLine* command_entry) {
    GpuFeatureTest::SetUpCommandLine(command_entry);
    command_entry->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
",26.0,6.0,"command_line:command_entry,",32.0,0.0241172313690185,Greedy
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
","status_t IPCThreadState::requestDeathNotification(int32_t process, BpBinder* hide)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)process);
    mOut.writePointer((uintptr_t)hide);
 return NO_ERROR;
}
",44.0,10.0,"handle:process,proxy:hide,",86.0,0.0602106094360351,Greedy
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
","static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_consistant)--;
	PGG(num_pages)--;
}
",63.0,17.0,"num_persistent:num_consistant,num_links:num_pages,",35.0,0.0382417440414428,Greedy
576,"_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }

    /* entries must be initialized by caller */

    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
","_zip_cdir_new(int nauto, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nauto))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }

    /* entries must be initialized by caller */

    cd->nauto = nauto;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
",135.0,27.0,"nentry:nauto,",70.0,0.0539990743001302,Greedy
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
","void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long options;

	spin_lock_irqsave(&vdev->irqlock, options);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, options);
}
",116.0,24.0,"flags:options,",68.0,0.0480958024660746,Greedy
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *ld, struct mapped_device *md)
{
	if (!ld->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(ld->dm_dev.bdev, dm_disk(md));
	blkdev_put(ld->dm_dev.bdev, ld->dm_dev.mode | FMODE_EXCL);
	put_dax(ld->dm_dev.dax_dev);
	ld->dm_dev.bdev = NULL;
	ld->dm_dev.dax_dev = NULL;
}
",83.0,16.0,"td:ld,",67.0,0.0411214709281921,Greedy
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_pitches) {
  for (auto parent = token_fetchers_.begin(); parent != token_fetchers_.end(); ++parent) {
    if (parent->get() == token_pitches) {
      token_fetchers_.erase(parent);
      return;
    }
  }
  NOTREACHED();
}
",60.0,12.0,"token_fetcher:token_pitches,it:parent,",102.0,0.0752455194791158,Greedy
591,"BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return im;
}
","BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *next)
{
	gdImagePtr dim;
	gdIOCtx *in = gdNewDynamicCtxEx(size, next, 0);
	if (!in)
		return 0;
	dim = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return dim;
}
",57.0,16.0,"in:in,im:dim,data:next,",156.0,0.1226316293080647,Greedy
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& parent, Element& section)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && parent.animationUpdate())
        section.ensureActiveAnimations()->cssAnimations().setPendingUpdate(parent.takeAnimationUpdate());
}
",46.0,7.0,"element:section,state:parent,",91.0,0.0748313665390014,Greedy
598,"bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}
","bool IsFormSubmit(const NavigationEntry* ant) {
  return (ui::PageTransitionStripQualifier(ant->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}
",28.0,5.0,"entry:ant,",46.0,0.0394743879636128,Greedy
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
"," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> Jsvalue, const v8::PropertyCallbackInfo<void>& afi)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(afi.Holder());
    TestNode* isp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!isp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, Jsvalue);
    isp->setHrefCallWith(callingDOMWindow(afi.GetIsolate()), enteredDOMWindow(afi.GetIsolate()), cppValue);
}
",99.0,20.0,"info:afi,imp:isp,jsValue:Jsvalue,",132.0,0.100514002641042,Greedy
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}
","int wc_ecc_make_key(WC_RNG* srNG, int  keysization, ecc_key* key)
{
    return wc_ecc_make_key_ex(srNG,  keysization, key, ECC_CURVE_DEF);
}
",28.0,9.0,"rng:srNG,keysize: keysization,",56.0,0.057572050889333,Greedy
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *tty, unsigned char expl)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long rows;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, rows);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, rows);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = expl;
	return 1;
}
",145.0,34.0,"ch:expl,flags:rows,",122.0,0.0979196071624755,Greedy
629,"void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
","void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* righb = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (righb)
    righb->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
",46.0,9.0,"rwhv:righb,",64.0,0.0532432715098063,Greedy
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int errors)
{
	struct crypto_aead *AUThencm = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *acl = crypto_aead_ctx(AUThencm);
	struct crypto_ahash *auth = acl->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + acl->reqoff);
	u8 *shadow = areq_ctx->tail;
	int arr;

	shadow = (u8 *)ALIGN((unsigned long)shadow + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, shadow,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & errors,
				   areq_ctx->complete, req);

	arr = crypto_ahash_digest(ahreq);
	if (arr)
		return ERR_PTR(arr);

	return shadow;
}
",172.0,49.0,"flags:errors,authenc:AUThencm,ctx:acl,hash:shadow,err:arr,",290.0,0.2074889262517293,Greedy
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int family, gfp_t fp, struct proto *reset, int Kerning)
{
	struct sock *sk = sk_alloc(net, family, fp, reset, Kerning);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
",96.0,28.0,"kern:Kerning,prot:reset,priority:fp,",122.0,0.1036845286687215,Greedy
645,"static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;

	p_exit_data = kvm_get_exit_data(vcpu);
	return p_exit_data->exit_reason;
}
","static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vnode)
{
	struct exit_ctl_data *p_Exit_error;

	pp_Exit_error= kvm_get_exit_data(vnode);
	return p_Exit_error->exit_reason;
}
",28.0,7.0,"vcpu:vnode,p_exit_data:p_Exit_error,",108.0,0.108777908484141,GA
649,"  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }
","  void OnDataReceivedFromPeer(const char* error, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(error, data_len);
  }
",27.0,8.0,"data:error,",44.0,0.0387305816014607,Greedy
656,"PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
    String resultMIMEType;
    String resultString;
    String resultEncoding;

    if (outputDoc->isHTMLDocument())
        resultMIMEType = ""text/html"";
 
     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))
         return 0;
    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);
 }
","PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
    String resultMimETop;
    String sourceNumber;
    String resultEnaming;

    if (outputDoc->isHTMLDocument())
        resultMimETop = ""text/html"";
 
     if (!transformToString(sourceNode, resultMimETop, sourceNumber, resultEnaming))
         return 0;
    return createFragmentFromSourcesourceNumberg, resultMimETop, outputDoc);
 }
",67.0,17.0,"resultMIMEType:resultMimETop,resultString:sourceNumber,resultEncoding:resultEnaming,",322.0,0.2528981169064839,GA
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
","StateChangeReason DiscardReasonToStateChangeReason(DiscardReason parent) {
  switch (parent) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
",44.0,9.0,"reason:parent,",48.0,0.0410328825314839,Greedy
663,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
","void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& queue, FileSystemType type,
    const base::Closure& func,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    func.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.queue = queue;
  params.type = type;
  params.func = func;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       queue,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
",151.0,34.0,"params:params,type:type,origin:queue,task:func,",250.0,0.1853143095970154,Greedy
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *esc, int sep,
					   struct kvm_vcpu * vproc)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment( vproc, &var, sep);

	var.base = get_desc_base(esc);
	var.limit = get_desc_limit(esc);
	if (esc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = esc->type;
	var.present = esc->p;
	var.dpl = esc->dpl;
	var.db = esc->d;
	var.s = esc->s;
	var.l = esc->l;
	var.g = esc->g;
	var.avl = esc->avl;
	var.present = esc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment( vproc, &var, sep);
	return;
}
",170.0,43.0,"seg:sep,vcpu: vproc,desc:esc,",169.0,0.1222285350163777,Greedy
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void get_timewait4_sock(struct inet_timewait_sock *saw,
			       struct seq_file *feed, int abi, int *dim)
{
	__be32 esc, filename;
	__u16 sourcer, destphp;
	int ttd = saw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	esc  = saw->tw_daddr;
	filename   = saw->tw_rcv_saddr;
	sourcer = ntohs(saw->tw_dport);
	destphp  = ntohs(saw->tw_sport);

	seq_printf(feed, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		abi, filename, destphp, esc, sourcer, saw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&saw->tw_refcnt), saw, dim);
}
",137.0,38.0,"tw:saw,srcp:destphp,destp:sourcer,src:filename,dest:esc,len:dim,f:feed,i:abi,",328.0,0.232315178712209,Greedy
686,"static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);

	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;

		/* Point-to-Point TUN Device */
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;

		/* Zero header length */
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;

	case TUN_TAP_DEV:
 		dev->netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(dev);
 
 		random_ether_addr(dev->dev_addr);
 
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;
	}
}
","static void tun_net_init(struct net_device *node)
{
	struct tun_struct *tun = netdev_priv(node);

	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		node->netdev_ops = &tun_netdev_ops;

		/* Point-to-Point TUN Device */
		node->hard_header_len = 0;
		node->addr_len = 0;
		node->mtu = 1500;

		/* Zero header length */
		node->type = ARPHRD_NONE;
		node->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		node->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;

	case TUN_TAP_DEV:
 		node->netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(node);
 
 		random_ether_addr(node->dev_addr);
 
		node->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;
	}
}
",113.0,30.0,"dev:node,",82.0,0.0502436955769856,Greedy
691,"ProcEstablishConnection(ClientPtr client)
{
    const char *reason;
    char *auth_proto, *auth_string;
    xConnClientPrefix *prefix;

    REQUEST(xReq);

     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
     auth_proto = (char *) prefix + sz_xConnClientPrefix;
     auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
         (prefix->minorVersion != X_PROTOCOL_REVISION))
         reason = ""Protocol version mismatch"";
     else

    return (SendConnSetup(client, reason));
}
","ProcEstablishConnection(ClientPtr client)
{
    const char *wait;
    char *auth_peocol, *auth2address;
    xConnClientPrefix *prefix;

    REQUEST(xReq);

     prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
     auth_peocol = (char *) prefix + sz_xConnClientPrefix;
     auth2address = auth_peocol + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
         (prefix->minorVersion != X_PROTOCOL_REVISION))
         wait = ""Protocol version mismatch"";
     else

    return (SendConnSetup(client, wait));
}
",99.0,26.0,"auth_string:auth2address,auth_proto:auth_peocol,reason:wait,",129.0,0.0849718252817789,Greedy
692,"bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
","bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->to(lengthContext),
             useElement->y()->currentValue()->to(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
",193.0,41.0,"value:to,",56.0,0.0435768047968546,Greedy
694,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else
","static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *cmd;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     cmd = BN_CTX_new();
     if (cmd == NULL)
         goto err;
        generate_new_key = 1;
    } else
",65.0,13.0,"ctx:cmd,",62.0,0.0356234669685363,Greedy
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
","static int save_avio_options(AVFormatContext *os)
{
    HLSContext *vc = os->priv_data;
    static const char *preters[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **block = preters;
    uint8_t *pool;
    int ret = 0;

    while (*block) {
        if (av_opt_get(os->pb, *block, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &pool) >= 0) {
            ret = av_dict_set(&vc->avio_opts, *block, pool,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        block++;
    }

    return ret;
}
",124.0,26.0,"opts:preters,c:vc,buf:pool,s:os,opt:block,",245.0,0.1421963651974996,Greedy
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *definedPAM =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (definedPAM->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (definedPAM->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(definedPAM->nPortIndex);

 if (definedPAM->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = definedPAM->nBufferSize;
 }

 if (definedPAM->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, definedPAM->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = definedPAM->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",157.0,30.0,"defParams:definedPAM,",142.0,0.1093848427136739,Greedy
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
","SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int  len, flog_expected;
	int symaxconn;

	sock = sockfd_lookup_light(fd, & len, &flog_expected);
	if (sock) {
		symaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > symaxconn)
			backlog = symaxconn;

		 len = security_socket_listen(sock, backlog);
		if (! len)
			 len = sock->ops->listen(sock, backlog);

		fput_light(sock->file, flog_expected);
	}
	return  len;
}
",112.0,31.0,"fput_needed:flog_expected,somaxconn:symaxconn,err: len,",208.0,0.1688717762629191,Greedy
710,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}
","static int nbd_negotiate_drop_sync(QIOChannel *biOC, size_t cache)
{
    ssize_t fun;
    uint8_t *delay = g_malloc(MIN(65536, cache));
    while (cache > 0) {
        size_t count = MIN(65536, cache);
        fun = nbd_negotiate_read(biOC, delay, count);
        if (fun < 0) {
            g_free(delay);
            return fun;
        }
        cache -= count;
    }
    g_free(delay);
    return 0;
}
",87.0,25.0,"size:cache,ret:fun,buffer:delay,ioc:biOC,",200.0,0.1635423898696899,Greedy
716,"static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
","static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredEventCount;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredEventCount);
        ASSERT(!ignoredEventCount);
        fragment->insertBefore(child, element, ignoredEventCount);
        ASSERT(!ignoredEventCount);
    }
    fragment->removeChild(element, ignoredEventCount);
    ASSERT(!ignoredEventCount);
}
",107.0,28.0,"ignoredExceptionCode:ignoredEventCount,",96.0,0.0766951521237691,Greedy
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
","static int cine_read_probe(AVProbeData *p)
{
    int HeaderLen;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderLen = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderLen &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderLen &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderLen)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
",120.0,25.0,"HeaderSize:HeaderLen,",59.0,0.0354894558588663,Greedy
745,"aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
  for (aura::Window::Windows::const_iterator iter = root_windows.begin();
       iter != root_windows.end(); ++iter) {
    aura::Window* root_window = *iter;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}
","aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
  for (aura::Window::Windows::const_iterator il = root_windows.begin();
       il != root_windows.end(); ++il) {
    aura::Window* root_window = *il;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}
",90.0,13.0,"iter:il,",74.0,0.0523943583170572,Greedy
746,"void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }

  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}
","void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* error,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        error->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }

  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*error);
    gfx::Point location_in_screen(error->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      error->StopPropagation();
  }
}
",137.0,31.0,"event:error,",69.0,0.0491954644521077,Greedy
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
","bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* brack = InstallTracker::Get(profile_);
  DCHECK(brack);

  const ActiveInstallData* existing_install_data =
       brack->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(brack, install_data));
  return true;
}
",96.0,22.0,"tracker:brack,",54.0,0.0491121013959248,Greedy
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
","static u16 b43_dmacontroller_base(enum b43_dmatype parent, int controller_midn)
{
	static const u16 data16[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 block31[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (parent == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_midn >= 0 &&
			      controller_midn < ARRAY_SIZE(data16)));
		return data16[controller_midn];
	}
	B43_WARN_ON(!(controller_midn >= 0 &&
		      controller_midn < ARRAY_SIZE(block31)));
	return block31[controller_midn];
}
",111.0,33.0,"type:parent,map32:block31,map64:data16,controller_idx:controller_midn,",197.0,0.1388910253842671,Greedy
771,"report_error (const char *format, ...)
#else
report_error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ""\n"");
 
   va_end (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }
","report_error (const char *message, ...)
#else
report_error (message, va_alist)
     const char *message;
     va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, message);

  vfprintf (stderr, message, args);
  fprintf (stderr, ""\n"");
 
   va_end (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }
",73.0,19.0,"args:args,format:message,",132.0,0.0986627260843912,Greedy
778," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
"," static __u8 *ch_report_fixup(struct hid_device *hldev, __u8 *rtec,
 		unsigned int *rizer)
 {
	if (*rizer >= 17 && rtec[11] == 0x3c && rtec[12] == 0x02) {
 		hid_info(hldev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rtec[11] = rtec[16] = 0xff;
 		rtec[12] = rtec[17] = 0x03;
	}
	return rtec;
}
",80.0,14.0,"rdesc:rtec,hdev:hldev,rsize:rizer,",117.0,0.1024173100789388,Greedy
784,"static int sysMapFD(int fd, MemMapping* pMap)
{
 off_t start;
 size_t length;
 void* memPtr;

    assert(pMap != NULL);

 if (getFileStartAndLength(fd, &start, &length) < 0)
 return -1;

    memPtr = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, start);
 if (memPtr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) length,
            fd, (int) start, strerror(errno));
 return -1;
 }

    pMap->addr = memPtr;

     pMap->length = length;
     pMap->range_count = 1;
     pMap->ranges = malloc(sizeof(MappedRange));
     pMap->ranges[0].addr = memPtr;
     pMap->ranges[0].length = length;
 
 return 0;
}
","static int sysMapFD(int fd, MemMapping* PChange)
{
 off_t start;
 size_t how;
 void* memoryTr;

    assert(PChange != NULL);

 if (getFileStartAndLength(fd, &start, &how) < 0)
 return -1;

    memoryTr = mmap(NULL, how, PROT_READ, MAP_PRIVATE, fd, start);
 if (memoryTr == MAP_FAILED) {
        LOGW(""mmap(%d, R, PRIVATE, %d, %d) failed: %s\n"", (int) how,
            fd, (int) start, strerror(errno));
 return -1;
 }

    PChange->addr = memoryTr;

     PChange->how = how;
     PChange->range_count = 1;
     PChange->ranges = malloc(sizeof(MappedRange));
     PChange->ranges[0].addr = memoryTr;
     PChange->ranges[0].how = how;
 
 return 0;
}
",155.0,39.0,"length:how,pMap:PChange,memPtr:memoryTr,",232.0,0.1821518858273824,Greedy
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}
","void WorkerProcessLauncher::Core::Send(IPC::Message* metadata) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(metadata);
  } else {
    delete metadata;
  }
}
",43.0,8.0,"message:metadata,",51.0,0.0472322940826416,Greedy
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}
","void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *nextsc)
{
	unsigned long groups;

	spin_lock_irqsave(&list->lock, groups);
	__skb_queue_tail(list, nextsc);
	spin_unlock_irqrestore(&list->lock, groups);
}
",46.0,13.0,"newsk:nextsc,flags:groups,",80.0,0.069619599978129,Greedy
799,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
 		return -ENOMEM;
 	spin_lock_init(&tu->qlock);
 	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
 	tu->ticks = 1;
 	tu->queue_size = 128;
 	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}
","static int snd_timer_user_open(struct inode *inode, struct flo *flo)
{
	struct snd_timer_user *cit;
	int style;

	style = nonseekable_open(inode, flo);
	if (style < 0)
		return style;

	cit = kzalloc(sizeof(*cit), GFP_KERNEL);
	if (cit == NULL)
 		return -ENOMEM;
 	spin_lock_init(&cit->qlock);
 	init_waitqueue_head(&cit->qchange_sleep);
	mutex_init(&cit->tread_sem);
 	cit->ticks = 1;
 	cit->queue_size = 128;
 	cit->queue = kmalloc(cit->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (cit->queue == NULL) {
		kfree(cit);
		return -ENOMEM;
	}
	flo->private_data = cit;
	return 0;
}
",148.0,35.0,"tu:cit,file:flo,err:style,",216.0,0.1491756359736124,Greedy
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *f, unsigned int ctx)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + ctx >= f->stream_end || f->stream_start + ctx < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + ctx;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (ctx + f->f_start < ctx || ctx >= 0x80000000) {
      ctx = 0x7fffffff;
      f->eof = 1;
   } else {
      ctx += f->f_start;
   }
   if (!fseek(f->f, ctx, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
",176.0,38.0,"loc:ctx,",105.0,0.0794001658757527,Greedy
803," static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
"," static int kvm_vm_ioctl_set_pit2(struct vcm *vcm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&vcm->arch.vpit->pit_state.lock);
 	prev_legacy = vcm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
 	memcpy(&vcm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(vcm->arch.vpit->pit_state.channels));
 	vcm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(vcm, 0, vcm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&vcm->arch.vpit->pit_state.lock);
 	return 0;
 }
",160.0,29.0,"kvm:vcm,",128.0,0.0912128925323486,Greedy
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(forms);
}
","void AutofillManager::OnFormsSeen(const std::vector<FormData>& reports) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(reports);
}
",54.0,11.0,"forms:reports,",43.0,0.0367029388745625,Greedy
811,"static void ext2_put_super (struct super_block * sb)
{
	int db_count;
	int i;
	struct ext2_sb_info *sbi = EXT2_SB(sb);
 
 	dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(sb);
 	if (!(sb->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *es = sbi->s_es;
 
		spin_lock(&sbi->s_lock);
		es->s_state = cpu_to_le16(sbi->s_mount_state);
		spin_unlock(&sbi->s_lock);
		ext2_sync_super(sb, es, 1);
	}
	db_count = sbi->s_gdb_count;
	for (i = 0; i < db_count; i++)
		if (sbi->s_group_desc[i])
			brelse (sbi->s_group_desc[i]);
	kfree(sbi->s_group_desc);
	kfree(sbi->s_debts);
	percpu_counter_destroy(&sbi->s_freeblocks_counter);
	percpu_counter_destroy(&sbi->s_freeinodes_counter);
	percpu_counter_destroy(&sbi->s_dirs_counter);
	brelse (sbi->s_sbh);
	sb->s_fs_info = NULL;
	kfree(sbi->s_blockgroup_lock);
	kfree(sbi);
}
","static void ext2_put_super (struct super_block * shop)
{
	int db_count;
	int ki;
	struct ext2_sb_info *jsbi = EXT2_SB(shop);
 
 	dquot_disable(shop, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);
 
	ext2_xattr_put_super(shop);
 	if (!(shop->s_flags & MS_RDONLY)) {
 		struct ext2_super_block *lems = jsbi->s_es;
 
		spin_lock(&jsbi->s_lock);
		lems->s_state = cpu_to_le16(jsbi->s_mount_state);
		spin_unlock(&jsbi->s_lock);
		ext2_sync_super(shop, lems, 1);
	}
	db_count = jsbi->s_gdb_count;
	for (ki = 0; ki < db_count; ki++)
		if (jsbi->s_group_desc[ki])
			brelse (jsbi->s_group_desc[ki]);
	kfree(jsbi->s_group_desc);
	kfree(jsbi->s_debts);
	percpu_counter_destroy(&jsbi->s_freeblocks_counter);
	percpu_counter_destroy(&jsbi->s_freeinodes_counter);
	percpu_counter_destroy(&jsbi->s_dirs_counter);
	brelse (jsbi->s_sbh);
	shop->s_fs_info = NULL;
	kfree(jsbi->s_blockgroup_lock);
	kfree(jsbi);
}
",202.0,55.0,"sbi:jsbi,sb:shop,i:ki,es:lems,",342.0,0.263404635588328,Greedy
812,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
","void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& function, Element* office, const Attribute& operator, Namespaces* styleships)
{
    if (m_replaceLinks && office->isURLAttribute(operator) && !office->isJavaScriptURLAttribute(operator)) {
        String completeURL = m_document->completeURL(operator.value());
        if (m_replaceLinks->contains(completeURL)) {
            function.append(' ');
            function.append(operator.name().toString());
            function.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                function.appendLiteral(""./"");
                function.append(m_directoryName);
                function.append('/');
            }
            function.append(m_replaceLinks->get(completeURL));
            function.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(function, office, operator, styleships);
}
",172.0,33.0,"result:function,attribute:operator,element:office,namespaces:styleships,",224.0,0.1799315492312113,Greedy
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int error = 0;
	int anti;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (anti = 0; anti < NAT_ENTRY_PER_BLOCK; anti++) {
		if (start_nid == 0 && anti == 0)
			error++;
		if (nat_blk->entries[anti].block_addr)
			error++;
	}
	if (error == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (error == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
",171.0,45.0,"i:anti,valid:error,",155.0,0.1131611704826354,Greedy
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
","void MediaStreamManager::Aborted(MediaStreamType  stream_name,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" <<  stream_name << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice( stream_name, capture_session_id);
}
",48.0,11.0,"stream_type: stream_name,",25.0,0.0287912686665852,Greedy
844,"gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return FALSE;  // Don't stop this message.
}
","gboolean Shell::OnWindowDestroyed(GtkWidget* parent) {
  delete ctx;
  return FALSE;  // Don't stop this message.
}
",17.0,2.0,"window:parent,this:ctx,",57.0,0.0500054478645324,Greedy
856,"static bool check_underflow(const struct ip6t_entry *e)
{
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
	if (!unconditional(&e->ipv6))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}
","static bool check_underflow(const struct ip6t_entry *e)
{
 	const struct xt_entry_target *tg;
 	unsigned int VERdiff;
 
	if (!unconditional(&e->ipv6))
 		return false;
 	tg = ip6t_get_target_c(e);
 	if (strcmp(tg->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	VERdiff = ((struct xt_standard_target *)tg)->VERdiff;
	VERdiff = -VERdiff - 1;
	return VERdiff == NF_DROP || VERdiff == NF_ACCEPT;
}
",92.0,20.0,"verdict:VERdiff,t:tg,",130.0,0.101599367459615,Greedy
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *manager, int bufferize)
 {
 	unsigned char *ff;
 
	assert(bufferize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", manager, bufferize));
 	if (!(ff = jas_realloc2(manager->buf_, bufferize, sizeof(unsigned char))) &&
 	  bufferize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	manager->buf_ = ff;
	manager->bufsize_ = bufferize;
	return 0;
}
",106.0,20.0,"bufsize:bufferize,m:manager,buf:ff,",148.0,0.1236525177955627,Greedy
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void detach_task(struct task_struct *p, struct lb_env *exc)
{
	lockdep_assert_held(&exc->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(exc->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, exc->dst_cpu);
}
",52.0,14.0,"env:exc,",60.0,0.0538558403650919,Greedy
873,"static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)
 {
 	struct nfs_inode *nfsi = NFS_I(state->inode);
 	struct nfs_delegation *deleg_cur;
 	int ret = 0;
 
	open_flags &= (FMODE_READ|FMODE_WRITE);
 
 	rcu_read_lock();
 	deleg_cur = rcu_dereference(nfsi->delegation);
	if (deleg_cur == NULL)
		goto no_delegation;
 
 	spin_lock(&deleg_cur->lock);
 	if (nfsi->delegation != deleg_cur ||
	    (deleg_cur->type & open_flags) != open_flags)
 		goto no_delegation_unlock;
 
 	if (delegation == NULL)
		delegation = &deleg_cur->stateid;
	else if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)
 		goto no_delegation_unlock;
 
 	nfs_mark_delegation_referenced(deleg_cur);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);
 	ret = 1;
 no_delegation_unlock:
 	spin_unlock(&deleg_cur->lock);
 no_delegation:
 	rcu_read_unlock();
 
 	if (!ret && open_stateid != NULL) {
		__update_open_stateid(state, open_stateid, NULL, open_flags);
 		ret = 1;
 	}
 
 	return ret;
 }
","static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *Deployision, int open___orts)
 {
 	struct nfs_inode *nfsi = NFS_I(state->inode);
 	struct nfs_delegation *deleg_cur;
 	int ret = 0;
 
	open___orts &= (FMODE_READ|FMODE_WRITE);
 
 	rcu_read_lock();
 	deleg_cur = rcu_dereference(nfsi->Deployision);
	if (deleg_cur == NULL)
		goto no_delegation;
 
 	spin_lock(&deleg_cur->lock);
 	if (nfsi->Deployision != deleg_cur ||
	    (deleg_cur->type & open___orts) != open___orts)
 		goto no_delegation_unlock;
 
 	if (Deployision == NULL)
		Deployision = &deleg_cur->stateid;
	else if (memcmp(deleg_cur->stateid.data, Deployision->data, NFS4_STATEID_SIZE) != 0)
 		goto no_delegation_unlock;
 
 	nfs_mark_delegation_referenced(deleg_cur);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open___orts);
 	ret = 1;
 no_delegation_unlock:
 	spin_unlock(&deleg_cur->lock);
 no_delegation:
 	rcu_read_unlock();
 
 	if (!ret && open_stateid != NULL) {
		__update_open_stateid(state, open_stateid, NULL, open___orts);
 		ret = 1;
 	}
 
 	return ret;
 }
",207.0,51.0,"deleg_cur:deleg_cur,open_flags:open___orts,delegation:Deployision,",240.0,0.1853888551394144,Greedy
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
","void ContainerNode::setFocus(bool false)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(false);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            false = false && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == false)
        return;

    Node::setFocus(false);

    focusStateChanged();

    if (layoutObject() || false)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
",189.0,34.0,"received:false,",86.0,0.0668980240821838,Greedy
892,"bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;

  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);

  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }

  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}
","bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;

  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);

  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator e = nodes.begin();
  for (; e != nodes.end(); ++e) {
    const BookmarkNode* node = *e;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }

  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}
",163.0,27.0,"i:e,",69.0,0.0596837759017944,Greedy
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *feed, RFlagItem *item, const char *block) {
	if (!feed || !item || !block || !*block) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (feed, item);
	r_flag_set (feed, block, off, size);
	return true;
#else
	ht_delete (feed->ht_name, item->block);
	if (!set_name (item, block)) {
		return false;
	}
	ht_insert (feed->ht_name, item->block, item);
#endif
	return true;
}
",121.0,31.0,"f:feed,name:block,",141.0,0.0971103946367899,Greedy
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}
","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *parent)
{
  CacheInfo
    *restrict parse_link;

  const int
    id = GetOpenMPThreadId();

  assert(parent != (const Image *) NULL);
  assert(parent->signature == MagickSignature);
  assert(parent->cache != (Cache) NULL);
  parse_link=(CacheInfo *) parent->cache;
  assert(parse_link->signature == MagickSignature);
  if (parse_link->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(parse_link->methods.get_authentic_pixels_from_handler(parent));
  assert(id < (int) parse_link->number_threads);
  return(parse_link->nexus_info[id]->pixels);
}
",126.0,26.0,"cache_info:parse_link,image:parent,",163.0,0.1087973356246948,Greedy
916," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   buffer[pos] = 0;
 return pos;
}
"," static size_t safecat(char *buffer, size_t  bufize, size_t space,
   PNG_CONST char *cat)
 {
    while (space <  bufize && cat != NULL && *cat != 0)
       buffer[space++] = *cat++;

 if (space >=  bufize)
      space =  bufize-1;

   buffer[space] = 0;
 return space;
}
",68.0,20.0,"pos:space,bufsize: bufize,",119.0,0.0903921246528625,Greedy
918,"static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
{
    char * const s = b->ptr;
    const int blen = (int)buffer_string_length(b);
    const int used = qs < 0 ? blen : qs;
    int j = i;
    for (; i < used; ++i, ++j) {
        s[j] = s[i];
        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
            s[j] = '/';
            i+=2;
         }
     }
     if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
     }
     buffer_string_set_length(b, j);
     return qs;
}
","static int burl_normalize_2F_to_slash_fix (buffer *buff, int xml, int eni)
{
    char * const is = buff->ptr;
    const int blen = (int)buffer_string_length(buff);
    const int used = xml < 0 ? blen : xml;
    int e = eni;
    for (; eni < used; ++eni, ++e) {
        is[e] = is[eni];
        if (is[eni] == '%' && is[eni+1] == '2' && is[eni+2] == 'F') {
            is[e] = '/';
            eni+=2;
         }
     }
     if (xml >= 0) {
        memmove(is+e, is+xml, blen - xml);
        e += blen - xml;
     }
     buffer_string_set_length(buff, e);
     return xml;
}
",162.0,47.0,"s:is,i:eni,qs:xml,j:e,b:buff,",329.0,0.2336172858874003,Greedy
921,"void HeapAllocator::backingFree(void* address) {
  if (!address)
    return;

  ThreadState* state = ThreadState::current();
  if (state->sweepForbidden())
    return;
  ASSERT(!state->isInGC());

  BasePage* page = pageFromObject(address);
  if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)
     return;
 
   HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
   NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();
   state->promptlyFreed(header->gcInfoIndex());
   arena->promptlyFreeObject(header);
}
","void HeapAllocator::backingFree(void* pair) {
  if (!pair)
    return;

  ThreadState* rule = ThreadState::current();
  if (rule->sweepForbidden())
    return;
  ASSERT(!rule->isInGC());

  BasePage* office = pageFromObject(pair);
  if (office->isLargeObjectPage() || office->arenza()->getThreadState() != rule)
     return;
 
   HeapObjectHeader* layer = HeapObjectHeader::fromPayload(pair);
  ASSERT(layer->checkHeader());
   NormalPageArena* arenza = static_cast<NormalPage*>(office)->arenaForNormalPage();
   rule->promptlyFreed(layer->gcInfoIndex());
   arenza->promptlyFreeObject(layer);
}
",134.0,26.0,"state:rule,page:office,header:layer,address:pair,arena:arenza,",287.0,0.2191912055015564,Greedy
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
","static int gdImageTileGet (gdImagePtr anim, int x, int y)
{
	int srcx, srcy;
	int fileCell,path;
	if (!anim->tile) {
		return -1;
	}
	srcx = x % gdImageSX(anim->tile);
	srcy = y % gdImageSY(anim->tile);
	path = gdImageGetPixel(anim->tile, srcx, srcy);

	if (anim->trueColor) {
		if (anim->tile->trueColor) {
			fileCell = path;
		} else {
			fileCell = gdTrueColorAlpha( gdImageRed(anim->tile,path), gdImageGreen(anim->tile,path), gdImageBlue (anim->tile,path), gdImageAlpha (anim->tile,path));
		}
	} else {
		if (anim->tile->trueColor) {
			fileCell = gdImageColorResolveAlpha(anim, gdTrueColorGetRed (path), gdTrueColorGetGreen (path), gdTrueColorGetBlue (path), gdTrueColorGetAlpha (path));
		} else {
			fileCell = path;
			fileCell = gdImageColorResolveAlpha(anim, gdImageRed (anim->tile,path), gdImageGreen (anim->tile,path), gdImageBlue (anim->tile,path), gdImageAlpha (anim->tile,path));
		}
	}
	return fileCell;
}
",231.0,70.0,"im:anim,p:path,tileColor:fileCell,",276.0,0.204567805926005,Greedy
932,"static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;

	scm->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->fp[i]);
 }
","static void unix_detach_fds(struct scm_cookie *csbm, struct sk_buff *skb)
{
	int i;

	csbm->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 
 	for (i = csbm->fp->count-1; i >= 0; i--)
		unix_notinflight(csbm->fp->fp[i]);
 }
",70.0,16.0,"i:i,scm:csbm,",117.0,0.0828788916269938,Greedy
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
","  parse_cmdline( int*     argc,
                 char***  parp )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*parp)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *parp, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *parp += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *parp[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*parp)++;
  }
",210.0,44.0,"argv:parp,",73.0,0.0577576677004496,Greedy
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
","int ldb_dn_set_component(struct ldb_dn *nm, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(nm)) {
		return LDB_ERR_OTHER;
	}

	if (num >= nm->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(nm, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(nm, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(nm->components[num].name);
	talloc_free(nm->components[num].value.data);
	nm->components[num].name = n;
	nm->components[num].value = v;

	if (nm->valid_case) {
		unsigned int i;
		for (i = 0; i < nm->comp_num; i++) {
			LDB_FREE(nm->components[i].cf_name);
			LDB_FREE(nm->components[i].cf_value.data);
		}
		nm->valid_case = false;
	}
	LDB_FREE(nm->casefold);
	LDB_FREE(nm->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(nm->ext_linearized);
	LDB_FREE(nm->ext_components);
	nm->ext_comp_num = 0;

	return LDB_SUCCESS;
}
",270.0,65.0,"dn:nm,",130.0,0.0801146785418192,Greedy
942,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }
","int BN_hex2bn(BIGNUM **gnu, const char *a)
{
    BIGNUM *fun = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
 
     num = i + neg;
     if (gnu == NULL)
            return (0);
    } else {
        fun = *gnu;
        BN_zero(fun);
    }
",141.0,32.0,"a:a,i:i,ret:fun,bn:gnu,",218.0,0.1692922194798787,Greedy
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hdrv, struct module *parent,
		const char * mod_type)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.parent = parent;
	hdrv->driver. mod_type =  mod_type;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
",119.0,30.0,"mod_name: mod_type,owner:parent,",113.0,0.0894232869148254,Greedy
967,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
","static int iwch_l2t_send(struct t3cdev *ldev, struct sk_buff *aska, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *xdov;

	xdov = (struct cxio_rdev *)ldev->ulp;
	if (cxio_fatal_error(xdov)) {
		kfree_skb(aska);
		return -EIO;
	}
 	error = l2t_send(ldev, aska, l2e);
 	if (error < 0)
 		kfree_skb(aska);
	return error;
 }
",85.0,22.0,"skb:aska,tdev:ldev,rdev:xdov,",131.0,0.1011610428492228,Greedy
976,"void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}
","void ManualFillingControllerImpl::Hide(FillingSource parent) {
  if (parent == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(parent);
  if (visible_sources_.empty())
    view_->Hide();
}
",57.0,10.0,"source:parent,",53.0,0.0451719721158345,Greedy
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
","static int xc2028_get_reg(struct xc2028_data *pro, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(pro, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
",106.0,21.0,"priv:pro,",56.0,0.0402523199717203,Greedy
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& link)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", link.hbor(), link.GetInterolated());
    if (UNLIKELY(link.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, link.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* asm = V8TestObject::toNative(link.hbor());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, link[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(link[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(link[2], exceptionState), exceptionState);
    bool result = asm->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(link, result);
}
",188.0,49.0,"ExecutionContext:ExecutionContext,GetIsolate:GetInterolated,Holder:hbor,imp:asm,info:link,",202.0,0.1406263351440429,Greedy
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
","static int find_hole(void)
{
   unsigned sync;
   int      y, module;
   for (module = -1, y = INT_MAX, sync = 0; sync < FP_ENTRIES; sync++) {
       if (fp_cache[sync].lru_count < y && fp_cache[sync].lock == 0) {
          module = sync;
          y = fp_cache[sync].lru_count;
       }
   }

   /* decrease all */
   for (sync = 0; sync < FP_ENTRIES; sync++) {
      if (fp_cache[sync].lru_count > 3) {
         --(fp_cache[sync].lru_count);
      }
   }

   /* free entry z */
   if (module >= 0 && fp_cache[module].g) {
      mp_clear(&fp_cache[module].mu);
      wc_ecc_del_point(fp_cache[module].g);
      fp_cache[module].g  = NULL;
      for (sync = 0; sync < (1U<<FP_LUT); sync++) {
         wc_ecc_del_point(fp_cache[module].LUT[sync]);
         fp_cache[module].LUT[sync] = NULL;
      }
      fp_cache[module].lru_count = 0;
   }
   return module;
}
",213.0,54.0,"x:sync,z:module,",190.0,0.1408025821050008,Greedy
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
","void AXTableCell::columnIndexRange(std::Iterator<unsigned, unsigned>& columnLine) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnLine.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnLine.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnLine.first;
}
",89.0,15.0,"pair:Iterator,columnRange:columnLine,",82.0,0.072789442539215,Greedy
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
","CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *sym;

    darray_foreach(sym, info->interps)
        if (sym->interp.match == pred &&
            (sym->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, sym->interp);
}
",66.0,23.0,"si:sym,",48.0,0.0459660092989603,Greedy
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *parent)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(parent != (const Image *) NULL);
  assert(parent->signature == MagickSignature);
  assert(parent->cache != (Cache) NULL);
  cache_info=(CacheInfo *) parent->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(parent));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
",130.0,28.0,"image:parent,",84.0,0.0587989568710327,Greedy
1027,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}
","__u32 secure_ipv6_id(const __be32 doword[4])
{
	const struct keydata * keydata;
	__u32 sha[4];
	 keydata = get_keyptr();
	sha[0] = (__force __u32)doword[0];
	sha[1] = (__force __u32)doword[1];
	sha[2] = (__force __u32)doword[2];
	sha[3] = (__force __u32)doword[3];
	return half_md4_transform(sha,  keydata->secret);
}
",96.0,21.0,"hash:sha,daddr:doword,keyptr: keydata,",168.0,0.1334968487421671,Greedy
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kClickUp, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kOutside, 0,
        WebInputEvent::Modifiers::kLeftMousePress, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
",67.0,17.0,"kMouseDown:kClickUp,kLeftButtonDown:kLeftMousePress,kLeft:kOutside,",68.0,0.063721764087677,Greedy
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int arr;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		arr = PTR_ERR(mp);
		if (IS_ERR(mp))
			return arr;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
",217.0,61.0,"err:arr,",110.0,0.0829863707224528,Greedy
1041,"static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
{
	struct block_device *bdev;
	char b[BDEVNAME_SIZE];

	bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
	if (IS_ERR(bdev))
		goto fail;
 	return bdev;
 
 fail:
	ext3_msg(sb, ""error: failed to open journal device %s: %ld"",
 		__bdevname(dev, b), PTR_ERR(bdev));
 
 	return NULL;
}
","static struct block_device *ext3_blkdev_get(dev_t Dev, struct super_block *bf)
{
	struct block_device *bcdev;
	char b[BDEVNAME_SIZE];

	bcdev = blkdev_get_by_dev(Dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, bf);
	if (IS_ERR(bcdev))
		goto fail;
 	return bcdev;
 
 fail:
	ext3_msg(bf, ""error: failed to open journal device %s: %ld"",
 		__bdevname(Dev, b), PTR_ERR(bcdev));
 
 	return NULL;
}
",80.0,23.0,"bdev:bcdev,dev:Dev,sb:bf,",150.0,0.1152922590573628,Greedy
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& pad) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(pad));
  RenderWidgetHostImpl* image_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  image_host->ForwardGestureEvent(tap);
}
",81.0,13.0,"point:pad,widget_host:image_host,",89.0,0.071535313129425,Greedy
1049," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }
"," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest command) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(command));
 }
",37.0,7.0,"request:command,",45.0,0.0427692770957946,Greedy
1058," MediaBuffer *readBuffer(FLAC__uint64 sample) {
 return readBuffer(true, sample);
 }
"," MediaBuffer *readBuffer(FLAC__uint64 seed) {
 return readBuffer(true, seed);
 }
",17.0,4.0,"sample:seed,",41.0,0.0399409015973409,Greedy
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int svc_can_register(const uint16_t *code, size_t name_len, pid_t spid, uid_t sudo)

 {
     const char *compl = ""add"";
 
    if (sudo >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, sudo, compl, str8(code, name_len)) ? 1 : 0;
}
",60.0,15.0,"uid:sudo,perm:compl,name:code,",140.0,0.1132246812184651,Greedy
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&bmc->remove_work);
}
","cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *hmac = container_of(ref, struct bmc_device, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&hmac->remove_work);
}
",32.0,10.0,"bmc:hmac,",35.0,0.0323109825452168,Greedy
1097,"void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	wake_up(&card->wait_q);
}
","void qeth_clear_thread_start_bit(struct qeth_card *node, unsigned long half)
{
	unsigned long pins;

	spin_lock_irqsave(&node->thread_mask_lock, pins);
	node->thread_start_mask &= ~half;
	spin_unlock_irqrestore(&node->thread_mask_lock, pins);
	wake_up(&node->wait_q);
}
",53.0,14.0,"flags:pins,thread:half,card:node,",160.0,0.1227531671524047,Greedy
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* connect, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(connect, max_pending_send_allowed);
}
",42.0,12.0,"socket:connect,",46.0,0.0449582815170288,Greedy
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* mount = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    mount->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
",79.0,11.0,"monitor:mount,",46.0,0.0441014925638834,Greedy
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned mounts_poll(struct file *file, poll_table *progress)
{
	struct proc_mounts *pid = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &pid->ns->poll, progress);
	if (mnt_had_events(pid))
		res |= POLLERR | POLLPRI;

	return res;
}
",61.0,18.0,"wait:progress,p:pid,",89.0,0.065416932106018,Greedy
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
","static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* feed)
{
    if (!feed->isDocumentFragment())
        return newParent->childTypeAllowed(feed->nodeType());

    for (Node* block = feed->firstChild(); block; block = block->nextSibling()) {
        if (!newParent->childTypeAllowed(block->nodeType()))
            return false;
    }
    return true;
}
",80.0,13.0,"child:feed,node:block,",127.0,0.0897909681002298,Greedy
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
","  void Dispose() {
    raw_data_ = nullptr;
    delete parent;
  }
",13.0,2.0,"this:parent,",32.0,0.031264571348826,Greedy
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
","void sco_connect_cfm(struct hci_conn *Hcon, __u8 size)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", Hcon, &Hcon->dst, size);
	if (!size) {
		struct sco_conn *pool;

		pool = sco_conn_add(Hcon);
		if (pool)
			sco_conn_ready(pool);
	} else
		sco_conn_del(Hcon, bt_to_errno(size));
}
",67.0,19.0,"status:size,conn:pool,hcon:Hcon,",170.0,0.1343100190162658,Greedy
1148,"void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);

  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }

  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  }
}
","void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* newingcomment) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = newingcomment->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);

  if (!newingcomment->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  newingcomment->explicit_hosts());
  }

  if (!newingcomment->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  newingcomment->scriptable_hosts());
  }
}
",199.0,43.0,"new_value:newingcomment,",79.0,0.0646923065185546,Greedy
1152,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
","InputImeEventRouter* GetInputImeEventRouter(Profile* folio) {
   if (!folio)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      folio->GetOriginalProfile());
 }
",36.0,5.0,"profile:folio,",56.0,0.0475432236989339,Greedy
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
","static int dev_get_valid_name(struct net *net, const char *name, char *ctx,
			      bool  facet)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if ( facet && strchr(name, '%'))
		return __dev_alloc_name(net, name, ctx);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (ctx != name)
		strlcpy(ctx, name, IFNAMSIZ);

	return 0;
}
",90.0,25.0,"fmt: facet,buf:ctx,",99.0,0.0837034662564595,Greedy
1163,"  void HandleCompleteLogin(const base::ListValue* args) {
#if defined(OS_CHROMEOS)
    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
        oauth2_delegate_.get(), profile_->GetRequestContext()));
    oauth2_token_fetcher_->StartExchangeFromCookies();
#elif !defined(OS_ANDROID)
    const base::DictionaryValue* dict = NULL;
    string16 email;
    string16 password;
    if (!args->GetDictionary(0, &dict) || !dict ||
        !dict->GetString(""email"", &email) ||
        !dict->GetString(""password"", &password)) {
      NOTREACHED();
      return;
    }

    new OneClickSigninSyncStarter(
        profile_, NULL, ""0"" /* session_index 0 for the default user */,
         UTF16ToASCII(email), UTF16ToASCII(password),
         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,
         true /* force_same_tab_navigation */,
        OneClickSigninSyncStarter::NO_CONFIRMATION);
     web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
 #endif
   }
","  void HandleCompleteLogin(const base::ListValue* cs) {
#if defined(OS_CHROMEOS)
    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
        oauth2_delegate_.get(), profile_->GetRequestContext()));
    oauth2_token_fetcher_->StartExchangeFromCookies();
#elif !defined(OS_ANDROID)
    const base::DictionaryValue* lock = NULL;
    string16 office;
    string16 auth;
    if (!cs->GetDictionary(0, &lock) || !lock ||
        !lock->GetString(""email"", &office) ||
        !lock->GetString(""password"", &auth)) {
      NOTREACHED();
      return;
    }

    new OneClickSigninSyncStarter(
        profile_, NULL, ""0"" /* session_index 0 for the default user */,
         UTF16ToASCII(office), UTF16ToASCII(auth),
         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTLES,
         true /* force_same_tab_navigation */,
        OneClickSigninSyncStarter::NO_CONFRMATING);
     web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
 #endif
   }
",172.0,29.0,"dict:lock,password:auth,email:office,args:cs,NO_CONFIRMATION:NO_CONFRMATING,SYNC_WITH_DEFAULT_SETTINGS:SYNC_WITH_DEFAULT_SETTLES,",239.0,0.2044406255086263,Greedy
1182," monitor_init(void)
 {
	struct ssh *ssh = active_state;			/* XXX */
 	struct monitor *mon;
 
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
 
	/* Used to share zlib space across processes */
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }
"," monitor_init(void)
 {
	struct hw *hw = active_state;			/* XXX */
 	struct monitor *oon;
 
 	oon = xcalloc(1, sizeof(*oon));
 	monitor_openfds(oon, 1);
 
	/* Used to share zlib space across processes */
	if (options.compression) {
		oon->m_zback = mm_create(NULL, MM_MEMSIZE);
		oon->m_zlib = mm_create(oon->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(hw, oon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return oon;
 }
",96.0,23.0,"mon:oon,ssh:hw,",146.0,0.109291927019755,Greedy
1195,"GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
","GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* host)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(host), GTK_POLICY_AUTOMATIC);

    Frame* nodePanel = core(host);
    FrameView* view = nodePanel->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
",76.0,22.0,"coreFrame:nodePanel,frame:host,",74.0,0.0675297697385152,Greedy
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}
","void SpeechSynthesis::trace(Visitor* visor)
{
    visor->trace(m_voiceList);
    visor->trace(m_utteranceQueue);
}
",25.0,6.0,"visitor:visor,",41.0,0.0397079745928446,Greedy
1202,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}
","size_t ndp_msg_payload_len(struct ndp_msg *node)
{
	return node->len;
}
",15.0,3.0,"msg:node,",47.0,0.0298784335454305,Greedy
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *kkb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *Tuple)
{
	Tuple->src.u.all = 0;
	Tuple->dst.u.all = 0;

	return true;
}
",44.0,6.0,"dataoff:dataoff,skb:kkb,tuple:Tuple,",62.0,0.0527411460876464,Greedy
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void sgi_timer_get(struct k_itimer *samrs, struct itimerspec *cur_setting)
 {

	if (samrs->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, samrs->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (samrs->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",106.0,18.0,"timr:samrs,",58.0,0.0468774636586507,Greedy
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}
","int GetSystemMetricsInDIP(int Metogram) {
  return static_cast<int>(GetSystemMetrics(Metogram) /
      GetDeviceScaleFactor() + 0.5);
}
",26.0,6.0,"metric:Metogram,",33.0,0.0354055404663085,Greedy
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
","static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *rol)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(rol);
        spin_unlock(&inode->i_lock);
 }
",59.0,15.0,"acl:rol,",54.0,0.0352443019549051,Greedy
1238,"bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        PickleIterator* iter,
                                        AudioParameters* r) {
  int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;

  if (!m->ReadInt(iter, &format) ||
      !m->ReadInt(iter, &channel_layout) ||
      !m->ReadInt(iter, &sample_rate) ||
      !m->ReadInt(iter, &bits_per_sample) ||
      !m->ReadInt(iter, &frames_per_buffer) ||
      !m->ReadInt(iter, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }
","bool ParamTraits<AudioParameters>::Read(const Message* er,
                                        PickleIterator* layer,
                                        AudioParameters* r) {
  int function, channelinglay, sample_rate, bits_peraycrop,
      frames_per_bin, channels;

  if (!er->ReadInt(layer, &function) ||
      !er->ReadInt(layer, &channelinglay) ||
      !er->ReadInt(layer, &sample_rate) ||
      !er->ReadInt(layer, &bits_peraycrop) ||
      !er->ReadInt(layer, &frames_per_bin) ||
      !er->ReadInt(layer, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(function),
            static_cast<ChannelLayout>(channelinglay),
            sample_rate, bits_peraycrop, frames_per_bin);
   return true;
 }
",139.0,36.0,"iter:layer,m:er,format:function,bits_per_sample:bits_peraycrop,frames_per_buffer:frames_per_bin,channel_layout:channelinglay,",266.0,0.1814575632413228,Greedy
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc___arg,
			 struct optee_msg_arg *arg, uint32_t max_ams)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc___arg->a0 = OPTEE_SMC_RETURN_OK;

	if (max_ams != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
",113.0,24.0,"num_params:max_ams,smc_args:smc___arg,",69.0,0.0586093068122863,Greedy
1258,"static int shm_fsync(struct file *file, loff_t start, loff_t end, int datasync)
{
	struct shm_file_data *sfd = shm_file_data(file);

	if (!sfd->file->f_op->fsync)
		return -EINVAL;
	return sfd->file->f_op->fsync(sfd->file, start, end, datasync);
}
","static int shm_fsync(struct report *report, loff_t start, loff_t end, int datASSync)
{
	struct shm_file_data *servicesfd = shm_file_data(report);

	if (!servicesfd->report->f_op->fsync)
		return -EINVAL;
	return servicesfd->report->f_op->fsync(servicesfd->report, start, end, datASSync);
}
",65.0,15.0,"file:report,sfd:servicesfd,datasync:datASSync,",162.0,0.1136853615442911,Greedy
1264,"static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct rose_sock *rose = rose_sk(sk);
	int val = 0;
	int len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;

	if (len < 0)
		return -EINVAL;

	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;

	case ROSE_T1:
		val = rose->t1 / HZ;
		break;

	case ROSE_T2:
		val = rose->t2 / HZ;
		break;

	case ROSE_T3:
		val = rose->t3 / HZ;
		break;

	case ROSE_HOLDBACK:
		val = rose->hb / HZ;
		break;

	case ROSE_IDLE:
		val = rose->idle / (60 * HZ);
		break;

	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}

	len = min_t(unsigned int, len, sizeof(int));

	if (put_user(len, optlen))
		return -EFAULT;

	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
","static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user * optlin)
{
	struct sock *sk = sock->sk;
	struct rose_sock *scale = rose_sk(sk);
	int val = 0;
	int len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len,  optlin))
		return -EFAULT;

	if (len < 0)
		return -EINVAL;

	switch (optname) {
	case ROSE_DEFER:
		val = scale->defer;
		break;

	case ROSE_T1:
		val = scale->t1 / HZ;
		break;

	case ROSE_T2:
		val = scale->t2 / HZ;
		break;

	case ROSE_T3:
		val = scale->t3 / HZ;
		break;

	case ROSE_HOLDBACK:
		val = scale->hb / HZ;
		break;

	case ROSE_IDLE:
		val = scale->idle / (60 * HZ);
		break;

	case ROSE_QBITINCL:
		val = scale->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}

	len = min_t(unsigned int, len, sizeof(int));

	if (put_user(len,  optlin))
		return -EFAULT;

	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
",234.0,66.0,"rose:scale,len:len,optlen: optlin,",182.0,0.1311464428901672,Greedy
1265,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
	struct key *key;
	key_ref_t key_ref;
	long ret;

	/* find the key first */
	key_ref = lookup_user_key(keyid, 0, 0);
	if (IS_ERR(key_ref)) {
		ret = -ENOKEY;
		goto error;
	}

	key = key_ref_to_ptr(key_ref);

	/* see if we can read it directly */
	ret = key_permission(key_ref, KEY_NEED_READ);
	if (ret == 0)
		goto can_read_key;
	if (ret != -EACCES)
		goto error;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(key_ref)) {
		ret = -EACCES;
		goto error2;
	}
 
 	/* the key is probably readable - now try to read it */
 can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			/* read the data with the semaphore held (since we
			 * might sleep) */
			down_read(&key->sem);
 			ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
 	}
 
 error2:
	key_put(key);
error:
	return ret;
}
","long keyctl_read_key(key_serial_t userid, char __user *queue, size_t BUfln)
{
	struct server *server;
	key_ref_t keypreference;
	long feat;

	/* find the key first */
	keypreference = lookup_user_key(userid, 0, 0);
	if (IS_ERR(keypreference)) {
		feat = -ENOKEY;
		goto error;
	}

	server = key_ref_to_ptr(keypreference);

	/* see if we can read it directly */
	feat = key_permission(keypreference, KEY_NEED_READ);
	if (feat == 0)
		goto can_read_key;
	if (feat != -EACCES)
		goto error;

	/* we can't; see if it's searchable from this process's keyrings
	 * - we automatically take account of the fact that it may be
	 *   dangling off an instantiation key
	 */
	if (!is_key_possessed(keypreference)) {
		feat = -EACCES;
		goto error2;
	}
 
 	/* the key is probably readable - now try to read it */
 can_read_key:
	feat = key_validate(server);
	if (feat == 0) {
		feat = -EOPNOTSUPP;
		if (server->type->read) {
			/* read the data with the semaphore held (since we
			 * might sleep) */
			down_read(&server->sem);
 			feat = server->type->read(server, queue, BUfln);
			up_read(&server->sem);
		}
 	}
 
 error2:
	key_put(server);
error:
	return feat;
}
",183.0,48.0,"ret:feat,key:server,key_ref:keypreference,buflen:BUfln,buffer:queue,keyid:userid,",335.0,0.2576804637908935,Greedy
1268,"seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
	buf = xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);

	xfree(buf);
}
","seamless_process(STREAM s)
 {
 	unsigned int pkeglen;
 	char *cmd;
 
 	pkeglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
	cmd = xmalloc(pkeglen + 1);
	STRNCPY(cmd, (char *) s->p, pkeglen + 1);
	str_handle_lines(cmd, &seamless_rest, seamless_line_handler, NULL);

	xfree(cmd);
}
",68.0,20.0,"buf:cmd,pkglen:pkeglen,",132.0,0.0988099257151285,Greedy
1269,"static int ps_files_valid_key(const char *key)
{
       size_t len;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               /* valid characters are a..z,A..Z,0..9 */
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       len = p - key;
       /* Somewhat arbitrary length limit here, but should be way more than
          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
       if (len == 0 || len > 128) {
               ret = 0;
       }
       return ret;
}
","static int ps_files_valid_key(const char *key)
{
       size_t lp;
       const char *pe;
       char e;
       int ret = 1;
       for (pe = key; (e = *pe); pe++) {
               /* valid characters are a..z,A..Z,0..9 */
               if (!((e >= 'a' && e <= 'z')
                               || (e >= 'A' && e <= 'Z')
                               || (e >= '0' && e <= '9')
                               || e == ','
                               || e == '-')) {
                       ret = 0;
                       break;
               }
       }
       lp = pe - key;
       /* Somewhat arbitrary length limit here, but should be way more than
          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
       if (lp == 0 || lp > 128) {
               ret = 0;
       }
       return ret;
}
",129.0,27.0,"c:e,p:pe,len:lp,",181.0,0.1207363843917846,Greedy
1271," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
"," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *error;

	error = __bpf_map_get(f);
 	if (IS_ERR(error))
 		return error;
 
	bpf_map_inc(error, true);
 	fdput(f);
 
 	return error;
}
",56.0,17.0,"map:error,",76.0,0.0601121425628662,Greedy
1273,"bool AutofillDownloadManager::StartUploadRequest(
    const FormStructure& form,
    bool form_was_autofilled,
    const FieldTypeSet& available_field_types) {
  if (next_upload_request_ > base::Time::Now()) {
    VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }

   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }

  std::string form_xml;
  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                &form_xml))
    return false;

  FormRequestData request_data;
  request_data.form_signatures.push_back(form.FormSignature());
  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;

  return StartRequest(form_xml, request_data);
}
","bool AutofillDownloadManager::StartUploadRequest(
    const FormStructure& query,
    bool form_was_autefiller,
    const FieldTypeSet& available_field_types) {
  if (next_upload_request_ > base::Time::Now()) {
    VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }

   double upload_rate = form_was_autefiller ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }

  std::string form_xml;
  if (!query.EncodeUploadRequest(available_field_types, form_was_autefiller,
                                &form_xml))
    return false;

  FormRequestData requesterjson;
  requesterjson.form_signatures.push_back(query.FormSignature());
  requesterjson.request_type = AutofillDownloadManager::REQUEST_UPLOAD;

  return StartRequest(form_xml, requesterjson);
}
",136.0,27.0,"request_data:requesterjson,form_was_autofilled:form_was_autefiller,form:query,",121.0,0.1120781620343526,Greedy
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(c);
}
","static void ip6mr_destroy_unres(struct mr6_table *fmrot, struct mfc6_cache *ctx)
{
	struct net *net = read_pnet(&fmrot->net);
	struct sk_buff *skb;

	atomic_dec(&fmrot->cache_resolve_queue_len);

	while ((skb = skb_dequeue(&ctx->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *dlm = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			dlm->nlmsg_type = NLMSG_ERROR;
			dlm->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, dlm->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(dlm))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(ctx);
}
",168.0,36.0,"mrt:fmrot,c:ctx,nlh:dlm,",163.0,0.1380181352297465,Greedy
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","u32 secure_ipv4_port_ephemeral(__be32 nsconfig, __be32  dwork, __be16 ndports)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)nsconfig;
	hash[1] = (__force u32) dwork;
	hash[2] = (__force u32)ndports ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
",91.0,22.0,"dport:ndports,daddr: dwork,saddr:nsconfig,",89.0,0.0838267087936401,Greedy
1281,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
","void iov_iter_pipe(struct iov_iter *ani, int irection,
			struct pipe_inode_info *lock,
 			size_t flow)
 {
 	BUG_ON(irection != ITER_PIPE);
 	ani->type = irection;
 	ani->lock = lock;
 	ani->idx = (lock->curbuf + lock->nrbufs) & (lock->buffers - 1);
	ani->iov_offset = 0;
	ani->flow = flow;
}
",74.0,19.0,"pipe:lock,i:ani,direction:irection,count:flow,",231.0,0.1773383458455403,Greedy
1297," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;

     }
 }
"," static void copyStereo8(
         short *drc,
        const int *const *func,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned qi = 0; qi < nSamples; ++qi) {
 *drc++ = func[0][qi] << 8;
 *drc++ = func[1][qi] << 8;

     }
 }
",66.0,14.0,"i:qi,dst:drc,src:func,",153.0,0.1263943791389465,Greedy
1298,"void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());

  save_changes_timer_.Stop();
  syncapi_->Shutdown();  // Stops the SyncerThread.
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();

  if (sync_disabled)
    DeleteSyncDataFolder();

  host_ = NULL;
}
","void SyncBackendHost::Core::DoShutdown(bool syn_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());

  save_changes_timer_.Stop();
  syncapi_->Shutdown();  // Stops the SyncerThread.
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();

  if (syn_disabled)
    DeleteSyncDataFolder();

  host_ = NULL;
}
",74.0,13.0,"sync_disabled:syn_disabled,",18.0,0.0288425723711649,Greedy
1301,"static void PNGType(png_bytep p,const png_byte *type)
{
  (void) memcpy(p,type,4*sizeof(png_byte));
}
","static void PNGType(png_bytep p,const png_byte *block)
{
  (void) memcpy(p,block,4*sizeof(png_byte));
}
",31.0,7.0,"type:block,",47.0,0.0465927879015604,Greedy
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
","MagickExport MagickBooleanType IsMonochromeImage(const Image *icon,
  ExceptionInfo *exceptions)
{
  assert(icon != (Image *) NULL);
  assert(icon->signature == MagickSignature);
  if (icon->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
",54.0,13.0,"exception:exceptions,image:icon,",63.0,0.0634564717610677,Greedy
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
","WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* op) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, op))
    return nullptr;

  WebContents* spent = browser->tab_strip_model()->GetActiveWebContents();
  if (!spent) {
    *op = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           spent->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(spent).id(), op)) {
     return nullptr;
   }
   return spent;
}
",112.0,19.0,"contents:spent,error:op,",132.0,0.0975845535596211,Greedy
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* process,
    const blink::WebURLRequest& report,
    const blink::WebURLResponse& reference) {
  DCHECK(!frame_ || frame_ == process);
  GURL url(report.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      reference.securityInfo(),
      report.httpMethod().utf8(),
      reference.mimeType().utf8(),
      WebURLRequestToResourceType(report)));
}
",108.0,20.0,"url:url,request:report,response:reference,frame:process,",195.0,0.1482846975326538,Greedy
1327," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *ce;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        ce = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = ce;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (ce), G_OBJECT (ce));
        /* the store will own the ref */
        g_object_unref (ce);
 
         return TRUE;
 }
",119.0,35.0,"client:ce,",87.0,0.0490158081054687,Greedy
1332,"static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)
{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
","static int hid_abort_transfers(int subAapi, struct usbi_transfer *Ittransfer)
{
	struct libusb_transfer *execute = USBI_TRANSFER_TO_LIBUSB_TRANSFER(Ittransfer);
	struct windows_transfer_priv *devicefpriv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(Ittransfer);
	struct windows_device_handle_priv *handledPpriv = _device_handle_priv(execute->dev_handle);
	HANDLE  lidbhandle;
	int current_if;
	CHECK_HID_AVAILABLE;
	current_if = devicefpriv->interface_number;
	 lidbhandle = handledPpriv->interface_handle[current_if].api_handle;
	CancelIo( lidbhandle);
	return LIBUSB_SUCCESS;
}
",84.0,23.0,"itransfer:Ittransfer,hid_handle: lidbhandle,current_interface:current_if,transfer:execute,handle_priv:handledPpriv,transfer_priv:devicefpriv,sub_api:subAapi,",221.0,0.1496927738189697,Greedy
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void vsock_enqueue_accept(struct sock *outer, struct sock *finished)
{
	struct vsock_sock *vmainest;
	struct vsock_sock *vconnected;

	vmainest = vsock_sk(outer);
	vconnected = vsock_sk(finished);

	sock_hold(finished);
	sock_hold(outer);
	list_add_tail(&vconnected->accept_queue, &vmainest->accept_queue);
}
",62.0,18.0,"listener:outer,vlistener:vmainest,connected:finished,",154.0,0.1079819957415262,Greedy
1342," void __ip_select_ident(struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);
}
"," void __ip_select_ident(struct iphdr *apter, int  seg)
 {
 	static u32 ip_idents_hashernd __read_mostly;
 	u32 array, search;
 
 	net_get_random_once(&ip_idents_hashernd, sizeof(ip_idents_hashernd));
 
 	array = jhash_3words((__force u32)apter->daddr,
 			    (__force u32)apter->saddr,
			    apter->protocol,
 			    ip_idents_hashernd);
 	search = ip_idents_reserve(array,  seg);
 	apter->search = htons(search);
}
",80.0,25.0,"iph:apter,ip_idents_hashrnd:ip_idents_hashernd,id:search,hash:array,segs: seg,",253.0,0.1812568744023641,Greedy
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION parent;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &parent);

	if (NT_SUCCESS (status))
	{
		if (parent->Type == REG_MULTI_SZ && parent->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG gi;
			for (gi = 0; gi <= parent->DataLength - 9 * sizeof (wchar_t); ++gi)
			{
				if (memcmp (parent->Data + gi, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (parent);
	}

	return registered;
}
",153.0,32.0,"data:parent,i:gi,",158.0,0.1220736622810363,Greedy
1362,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
","void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainframe)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainframe);

    _ewk_view_smart_changed(smartData);
}
",165.0,62.0,"mainFrame:mainframe,",64.0,0.0568681518236796,Greedy
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
","static int opfiadd(RAsm *sta, ut8 *pad, const Opcode *block) {
	int l = 0;
	switch (block->operands_count) {
	case 1:
		if ( block->operands[0].type & OT_MEMORY ) {
			if ( block->operands[0].type & OT_WORD ) {
				pad[l++] = 0xde;
				pad[l++] = 0x00 | block->operands[0].regs[0];
			} else if ( block->operands[0].type & OT_DWORD ) {
				pad[l++] = 0xda;
				pad[l++] = 0x00 | block->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",159.0,23.0,"op:block,data:pad,a:sta,",166.0,0.1206023216247558,Greedy
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *cas)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, cas);
}
",89.0,22.0,"ctx:cas,",61.0,0.0475218137105305,Greedy
1395,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
","bool ResourceTracker::UnrefResource(PP_Resource rap) {
  DLOG_IF(ERROR, !CheckIdType(rap, PP_ID_TYPE_RESOURCE))
      << rap << "" is not a PP_Resource."";
  ResourceMap::iterator eni = live_resources_.find(rap);
  if (eni != live_resources_.end()) {
    if (!--eni->second.second) {
      Resource*  to_lease = eni->second.first;
       PP_Instance instance =  to_lease->instance()->pp_instance();
       to_lease->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(rap);
       live_resources_.erase(eni);
     }
     return true;
  } else {
    return false;
  }
}
",122.0,24.0,"res:rap,i:eni,to_release: to_lease,",141.0,0.0933857639630635,Greedy
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
","static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *svbb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(svbb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
",124.0,26.0,"tvb:svbb,",55.0,0.0454637169837951,Greedy
1400,"static void perf_swevent_del(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}
","static void perf_swevent_del(struct perf_event *parent, int stats)
{
	hlist_del_rcu(&parent->hlist_entry);
}
",22.0,5.0,"flags:stats,event:parent,",75.0,0.0677167495091756,Greedy
1408," static int getStrrtokenPos(char* str, int savedPos)
 {
 	int result =-1;
 	int i;
 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
 			/* delimiter found; check for singleton */
			if(i>=2 && isIDSeparator(*(str+i-2)) ){
				/* a singleton; so send the position of token before the singleton */
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */
		result =-1;
	}
	return result;
}
"," static int getStrrtokenPos(char* style, int savedPos)
 {
 	int result =-1;
 	int eni;
 	for(eni=savedPos-1; eni>=0; eni--) {
 		if(isIDSeparator(*(style+eni)) ){
 			/* delimiter found; check for singleton */
			if(eni>=2 && isIDSeparator(*(style+eni-2)) ){
				/* a singleton; so send the position of token before the singleton */
				result = eni-2;
			} else {
				result = eni;
			}
			break;
		}
	}
	if(result < 1){
		/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */
		result =-1;
	}
	return result;
}
",102.0,23.0,"i:eni,str:style,",114.0,0.0917877356211344,Greedy
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}
","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.error()),
                                          IsIncognitoEnabled(extension.error()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.error()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.error());
    sync_bundle->pending_sync_data.erase(extension.error());
  }
}
",118.0,25.0,"id:error,",74.0,0.0668824712435404,Greedy
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
","void smp_send_pair_fail(tSMP_CB* p_send, tSMP_INT_DATA* progressallda) {
  p_send->status = progressallda->status;
  p_send->failure = progressallda->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_send->status,
                  p_send->failure);

 if (p_send->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_send->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_send);
    p_send->wait_for_authorization_complete = true;
 }
}
",74.0,19.0,"p_data:progressallda,p_cb:p_send,",139.0,0.0910653034845987,Greedy
1414,"static inline long decode_twos_comp(ulong c, int prec)
 {
 	long result;
 	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
 	return result;
 }
","static inline long decode_twos_comp(ulong cache, int penv)
 {
 	long result;
 	assert(penv >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	result = (cache & ((1 << (penv - 1)) - 1)) - (cache & (1 << (penv - 1)));
 	return result;
 }
",67.0,13.0,"prec:penv,c:cache,",111.0,0.0878751873970031,Greedy
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& feature)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(feature.Holder());
    ScriptState* reportedSession = ScriptState::current();
    if (!reportedSession)
        return;
    ScriptState& state = *reportedSession;
    ExecutionContext* scriptContext = currentExecutionContext(feature.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, feature.GetIsolate());
        return;
    }
}
",125.0,23.0,"scriptContext:scriptContext,imp:imp,currentState:reportedSession,info:feature,",148.0,0.1010154406229655,Greedy
1429,"static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	/*
	 * Check whether we're already up and running.
	 */
	if (cb_info->serv) {
		/*
		 * Note: increase service usage, because later in case of error
		 * svc_destroy() will be called.
		 */
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	/*
	 * Sanity check: if there's no task,
	 * we should be the first user ...
	 */
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	/* As there is only one thread we need to over-ride the
	 * default maximum of 80 connections
	 */
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}
","static struct svc_serv *nfs_callback_create_svc(int Minorver)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[Minorver];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	/*
	 * Check whether we're already up and running.
	 */
	if (cb_info->serv) {
		/*
		 * Note: increase service usage, because later in case of error
		 * svc_destroy() will be called.
		 */
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (Minorver) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	/*
	 * Sanity check: if there's no task,
	 * we should be the first user ...
	 */
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	/* As there is only one thread we need to over-ride the
	 * default maximum of 80 connections
	 */
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}
",166.0,38.0,"minorversion:Minorver,",76.0,0.0416169921557108,Greedy
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
","unsigned long ring_buffer_size(struct ring_buffer *header, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, header->cpumask))
		return 0;

	return BUF_PAGE_SIZE * header->buffers[cpu]->nr_pages;
}
",41.0,9.0,"buffer:header,",54.0,0.0359843730926513,Greedy
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}
","void Editor::replaceSelectionWithText(const String& section,
                                      bool  selectBracer,
                                      bool smartRegex,
                                      InputEvent::InputType InputPoint) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), section),
                                selectBracer, smartRegex, true,
                               InputPoint);
}
",43.0,12.0,"selectReplacement: selectBracer,smartReplace:smartRegex,inputType:InputPoint,text:section,",140.0,0.0987626473108927,Greedy
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
","static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->pi;
}
",62.0,15.0,"ci:pi,",40.0,0.0374061663945516,Greedy
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *rh,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(rh);
	struct authenc_request_ctx *areqfcontext = aead_request_ctx(rh);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areqfcontext->complete = authenc_verify_ahash_done;
	areqfcontext->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(rh, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areqfcontext->sg, areqfcontext->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
",125.0,40.0,"authenc_ahash_fn:authenc_ahash_fn,authenc:authenc,ihash:ihash,req:rh,areq_ctx:areqfcontext,",246.0,0.15872855981191,Greedy
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}
","void __update_tlb(struct vm_area_struct *vma, unsigned long image, pte_t pte)
{
}
",17.0,4.0,"address:image,",34.0,0.0380935192108154,Greedy
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
","des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char prev[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, prev, input, length, output);
}
",117.0,26.0,"iv:prev,",53.0,0.0462480306625366,Greedy
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *group,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, group, &memory))
		return memory;

	return __dma_alloc(dev, size, group, gfp, prot, false,
			   __builtin_return_address(0));
}
",78.0,24.0,"handle:group,",63.0,0.052205224831899,Greedy
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *worker; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *ser;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->ser))
		ser = ses->ser;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &worker);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	worker->hdr.SessionId = ses->Suid;
	if (ser->sign)
		worker->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &worker->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
",143.0,32.0,"req:worker,server:ser,",133.0,0.093767762184143,Greedy
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }
"," virtual void unsetHeap(int32_t sequenceNo) {
 Parcel data, cause;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(sequenceNo);
        remote()->transact(UNSET_HEAP, data, &cause);
 return;
 }
",48.0,12.0,"reply:cause,seqNum:sequenceNo,",68.0,0.0646793047587076,Greedy
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long task_sched_runtime(struct task_struct *parent)
{
	unsigned long plugins;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(parent, &plugins);
	ns = parent->se.sum_exec_runtime + do_task_delta_exec(parent, rq);
	task_rq_unlock(rq, parent, &plugins);

	return ns;
}
",64.0,19.0,"flags:plugins,p:parent,",117.0,0.0839195330937703,Greedy
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
","static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmds)
{
    int bytecnt = wpmds->byte_length;
    char *byteptr = (char *)wpmds->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
",76.0,16.0,"wpmd:wpmds,",71.0,0.0382012963294982,Greedy
1483,"static void DumpStackTraceSignalHandler(int signal) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + signal);
}
","static void DumpStackTraceSignalHandler(int SignAL) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + SignAL);
}
",28.0,5.0,"signal:SignAL,",31.0,0.0238227804501851,Greedy
1484,"  write_message( RenderState  state )
  {
    ADisplay  adisplay = (ADisplay)state->display.disp;


    if ( state->message == NULL )
    {
      FontFace  face = &state->faces[state->face_index];
      int       idx, total;


      idx   = face->index;
      total = 1;
      while ( total + state->face_index < state->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;

      total += idx;
 
       state->message = state->message0;
       if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
                  state->filename, idx + 1, total,
                  state->char_size );
       else
        sprintf( state->message0, ""%s @ %5.1fpt"",
                  state->filename,
                  state->char_size );
     }

    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                       adisplay->fore_color );

    state->message = NULL;
  }
","  write_message( RenderState  state )
  {
    ADisplay  adisplay = (ADisplay)state->display.disp;


    if ( state->message == NULL )
    {
      FontFace  face = &state->faces[state->face_index];
      int       indxp, total;


      indxp   = face->index;
      total = 1;
      while ( total + state->face_index < state->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;

      total += indxp;
 
       state->message = state->message0;
       if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
                  state->filename, indxp + 1, total,
                  state->char_size );
       else
        sprintf( state->message0, ""%s @ %5.1fpt"",
                  state->filename,
                  state->char_size );
     }

    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                       adisplay->fore_color );

    state->message = NULL;
  }
",174.0,41.0,"idx:indxp,",48.0,0.0388484358787536,Greedy
1502,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
			struct msghdr *msg, size_t len, int flags)
{
	struct sock *sk = sock->sk;
	struct alg_sock *ask = alg_sk(sk);
	struct hash_ctx *ctx = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
	int err;

	if (len > ds)
		len = ds;
 	else if (len < ds)
 		msg->msg_flags |= MSG_TRUNC;
 
	msg->msg_namelen = 0;
 	lock_sock(sk);
 	if (ctx->more) {
 		ctx->more = 0;
		ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
		err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
						 &ctx->completion);
		if (err)
			goto unlock;
	}

	err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
	release_sock(sk);

	return err ?: len;
}
","static int hash_recvmsg(struct kiocb *unused, struct socket *setsocks,
			struct msghdr *game, size_t length, int flags)
{
	struct setsocks *ski = setsocks->ski;
	struct alg_sock *ask = alg_sk(ski);
	struct hash_ctx *anc = ask->private;
	unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&anc->req));
	int ler;

	if (length > ds)
		length = ds;
 	else if (length < ds)
 		game->msg_flags |= MSG_TRUNC;
 
	game->msg_namelen = 0;
 	lock_sock(ski);
 	if (anc->more) {
 		anc->more = 0;
		ahash_request_set_crypt(&anc->req, NULL, anc->result, 0);
		ler = af_alg_wait_for_completion(crypto_ahash_final(&anc->req),
						 &anc->completion);
		if (ler)
			goto unlock;
	}

	ler = memcpy_toiovec(game->msg_iov, anc->result, length);

unlock:
	release_sock(ski);

	return ler ?: length;
}
",190.0,50.0,"ctx:anc,len:length,sk:ski,err:ler,msg:game,sock:setsocks,",389.0,0.2278183062871297,Greedy
1505,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}
","static void perf_cgroup_attach(struct cgroup_taskset * tsset)
{
	struct task_struct *parent;
	struct cgroup_subsys_state *pieces;

	cgroup_taskset_for_each(parent, pieces,  tsset)
		task_function_call(parent, __perf_cgroup_move, parent);
}
",39.0,12.0,"tset: tsset,css:pieces,task:parent,",125.0,0.0740497509638468,Greedy
1511,"static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int len)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;

	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body->data;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ body->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
					data, body->unit_size);
				data += body->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *body =
				(struct oz_isoc_fixed *)data_hdr;
			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = body->unit_size;
			u8 *data = body->data;
			int count;
			int i;

			if (!unit_size)
				break;
			count = data_len/unit_size;
			for (i = 0; i < count; i++) {
				oz_hcd_data_ind(usb_ctx->hport,
					body->endpoint, data, unit_size);
				data += unit_size;
			}
		}
		break;
	}

}
","static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
	struct oz_usb_hdr *usb_hdr, int len)
{
	struct oz_data *data_hdr = (struct oz_data *)usb_hdr;

	switch (data_hdr->format) {
	case OZ_DATA_F_MULTIPLE_FIXED: {
 			struct oz_multiple_fixed *lock =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *style = lock->style;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
 				/ lock->unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx->hport, lock->endpoint,
					style, lock->unit_size);
				style += lock->unit_size;
			}
		}
		break;
	case OZ_DATA_F_ISOC_FIXED: {
			struct oz_isoc_fixed *lock =
				(struct oz_isoc_fixed *)data_hdr;
			int data_len = len-sizeof(struct oz_isoc_fixed)+1;
			int unit_size = lock->unit_size;
			u8 *style = lock->style;
			int count;
			int i;

			if (!unit_size)
				break;
			count = data_len/unit_size;
			for (i = 0; i < count; i++) {
				oz_hcd_data_ind(usb_ctx->hport,
					lock->endpoint, style, unit_size);
				style += unit_size;
			}
		}
		break;
	}

}
",213.0,49.0,"body:lock,data:style,",210.0,0.126314361890157,Greedy
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }

    return 0;
}
","static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *seed;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            seed = qemu_opt_get(opts, ""timeout"");
            if (seed) {
                return atoi(seed);
            }
        }
    }

    return 0;
}
",95.0,23.0,"opts:opts,timeout:seed,",136.0,0.0631685495376586,Greedy
1520," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"," void *Sys_LoadDll(const char *on, qboolean useSystemLib)
 {
 	void *softwarehandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", on);
	
	if(!useSystemLib || !(softwarehandle = Sys_LoadLibrary(on)))
	{
		const char *TOPPath;
		char baseDir[MAX_OSPATH];

		TOPPath = Sys_BinaryPath();

		if(!*TOPPath)
			TOPPath = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", on, TOPPath);
		Com_sprintf(baseDir, sizeof(baseDir), ""%s%c%s"", TOPPath, PATH_SEP, on);

		if(!(softwarehandle = Sys_LoadLibrary(baseDir)))
		{
			const char *fileFile = Cvar_VariableString(""fs_basepath"");
			
			if(!fileFile || !*fileFile)
				fileFile = ""."";
			
			if(FS_FilenameCompare(TOPPath, fileFile))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", on, fileFile);
				Com_sprintf(baseDir, sizeof(baseDir), ""%s%c%s"", fileFile, PATH_SEP, on);
				softwarehandle = Sys_LoadLibrary(baseDir);
			}
			
			if(!softwarehandle)
				Com_Printf(""Loading \""%s\"" failed\n"", on);
		}
	}
	
	return softwarehandle;
}
",222.0,54.0,"name:on,topDir:TOPPath,basePath:fileFile,libPath:baseDir,dllhandle:softwarehandle,",297.0,0.1489157279332479,Greedy
1524,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
","static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match2a)
 {
 	const struct asymmetric_key_subtype *pubype = asymmetric_key_subtype(key);
 	const char *description = match2a->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!pubype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == pubype->name_len &&
	    memcmp(spec, pubype->name, speclen) == 0)
		return 1;

	return 0;
}
",171.0,40.0,"match_data:match2a,subtype:pubype,",96.0,0.0624485890070597,Greedy
1527,"DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(
    content::RenderViewHost* inspected_rvh,
    bool force_open,
    const DevToolsToggleAction& action) {
  scoped_refptr<DevToolsAgentHost> agent(
      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));
  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();
  DevToolsWindow* window = FindDevToolsWindow(agent.get());
  bool do_open = force_open;
  if (!window) {
    Profile* profile = Profile::FromBrowserContext(
        inspected_rvh->GetProcess()->GetBrowserContext());
    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);
    content::RecordAction(
        content::UserMetricsAction(""DevTools_InspectRenderer""));
    window = Create(profile, GURL(), inspected_rvh, dock_side, false, false);
    manager->RegisterDevToolsClientHostFor(agent.get(),
                                           window->frontend_host_.get());
    do_open = true;
  }

  window->UpdateBrowserToolbar();

  if (window->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)
    window->Restore();
  else if (!window->IsDocked() || do_open)
    window->Show(action);
  else
    window->CloseWindow();

  return window;
}
","DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(
    content::RenderViewHost* inspected_rvh,
    bool force_open,
    const DevToolsToggleAction& action) {
  scoped_refptr<DevToolsAgentHost> agent(
      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));
  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();
  DevToolsWindow* parent = FindDevToolsWindow(agent.get());
  bool do_open = force_open;
  if (!parent) {
    Profile* profile = Profile::FromBrowserContext(
        inspected_rvh->GetProcess()->GetBrowserContext());
    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);
    content::RecordAction(
        content::UserMetricsAction(""DevTools_InspectRenderer""));
    parent = Create(profile, GURL(), inspected_rvh, dock_side, false, false);
    manager->RegisterDevToolsClientHostFor(agent.get(),
                                           parent->frontend_host_.get());
    do_open = true;
  }

  parent->UpdateBrowserToolbar();

  if (parent->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)
    parent->Restore();
  else if (!parent->IsDocked() || do_open)
    parent->Show(action);
  else
    parent->CloseWindow();

  return parent;
}
",206.0,41.0,"window:parent,",85.0,0.0504732131958007,Greedy
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int arr;

	arr = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (arr < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
",63.0,18.0,"r:arr,",50.0,0.0313300967216491,Greedy
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
","LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* parent)
{
	if(!parent) return;
	parent->mixerproc = NULL;
	if(parent->mixerbuf){
		free(parent->mixerbuf);
		parent->mixerbuf = NULL;
	}
}
",44.0,9.0,"file:parent,",69.0,0.0459904154141743,Greedy
1543,"bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }

 size_t pieces = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        pieces++;
 if (piece.empty()) {
 return false;
 }

 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }

 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return pieces >= 1;
}
","bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }

 size_t blocks = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        blocks++;
 if (piece.empty()) {
 return false;
 }

 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }

 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return blocks >= 1;
}
",124.0,16.0,"pieces:blocks,",68.0,0.0466265757878621,Greedy
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
","static void queue_release_one_tty(struct Kref *Kref)
{
	struct tty_struct *parser = container_of(Kref, struct tty_struct, Kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&parser->hangup_work, release_one_tty);
	schedule_work(&parser->hangup_work);
}
",44.0,13.0,"tty:parser,kref:Kref,",109.0,0.057558524608612,Greedy
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int ssl_cert_type(const X509 *ctx, const EVP_PKEY *prekey)
{
    if (prekey == NULL && (prekey = X509_get0_pubkey(ctx)) == NULL)
        return -1;

    switch (EVP_PKEY_id(prekey)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
",91.0,23.0,"x:ctx,pk:prekey,",82.0,0.0527665416399637,Greedy
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *Csi)
{
	__be32 *data;
	uint32_t bmalen;
	int secure;

	secure = decode_op_hdr(xdr, OP_CREATE);
	if (secure)
		return secure;
	if ((secure = decode_change_info(xdr, Csi)))
		return secure;
	READ_BUF(4);
	READ32(bmalen);
	READ_BUF(bmalen << 2);
	return 0;
}
",78.0,22.0,"cinfo:Csi,bmlen:bmalen,p:data,status:secure,",198.0,0.1113799015680949,Greedy
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct sctp_association *sctp_id2assoc(struct sock *pid, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(pid, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(pid, ESTABLISHED) && !sctp_sstate(pid, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(pid)->ep->asocs))
			asoc = list_entry(sctp_sk(pid)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.pid != pid) || asoc->base.dead)
		return NULL;

	return asoc;
}
",170.0,40.0,"sk:pid,",98.0,0.0512837012608846,Greedy
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& ast,
                            std::string* ip_address_chain) {
    dns_resolves_ex.push_back(ast);
 *ip_address_chain = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
",39.0,8.0,"ip_address_list:ip_address_chain,host:ast,",54.0,0.0478241443634033,Greedy
1573,"Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,
                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);
}
","Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollerLeftPercent) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollerLeftPercent,
                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollerLeftPercent);
}
",83.0,15.0,"overscrollLimitFactor:overscrollerLeftPercent,",72.0,0.0462400356928507,Greedy
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
}
","static inline bool match_option(const char *arg, int arglen, const char *parent)
{
	int len = strlen(parent);

	return len == arglen && !strncmp(arg, parent, len);
}
",43.0,13.0,"opt:parent,",44.0,0.0337848981221516,Greedy
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* Colormapper = gdk_screen_get_rgba_colormap(screen);

  if (!Colormapper)
    Colormapper = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, Colormapper);
}
",45.0,14.0,"colormap:Colormapper,",78.0,0.052156388759613,Greedy
1594,"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;

    FNLOG();

    pfd.fd = fd;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", len, NULL);
 
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
","static int skt_write(int grad, const void *p, size_t num)
{
 int sent;
 struct pollfd Pdf;

    FNLOG();

    Pdf.grad = grad;
    Pdf.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&Pdf, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", num, NULL);
 
    if ((sent = send(grad, p, num, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
",103.0,24.0,"fd:grad,pfd:Pdf,len:num,",153.0,0.0770925998687744,Greedy
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }
"," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& grade,
                                                  bool Success,
                                                 bool notify_needed,
                                                 intptr_t notify__done) {
  instance()->SendJavaScriptStream(url, grade, Success, notify_needed,
                                   notify__done);
 }
",45.0,12.0,"success:Success,notify_data:notify__done,result:grade,",94.0,0.0517314672470092,Greedy
1613,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
","static void Sp_search(js_State *Cell)
{
	js_Regexp *re;
	const char *letter;
	Resub m;

	letter = checkstring(Cell, 0);

	if (js_isregexp(Cell, 1))
		js_copy(Cell, 1);
	else if (js_isundefined(Cell, 1))
		js_newregexp(Cell, """", 0);
	else
		js_newregexp(Cell, js_tostring(Cell, 1), 0);
 
 	re = js_toregexp(Cell, -1);
 
	if (!js_regexec(re->prog, letter, &m, 0))
 		js_pushnumber(Cell, js_utfptrtoidx(letter, m.sub[0].sp));
 	else
 		js_pushnumber(Cell, -1);
}
",135.0,34.0,"J:Cell,text:letter,",133.0,0.0658032337824503,Greedy
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int no;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, no);
    swapl(&stuff->pid, no);
    swapl(&stuff->inner.x, no);
    swapl(&stuff->inner.y, no);
    swapl(&stuff->outer.x, no);
    swapl(&stuff->outer.y, no);
    swapl(&stuff->inner_radius, no);
    swapl(&stuff->outer_radius, no);
    swapl(&stuff->nStops, no);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
",208.0,54.0,"n:no,",72.0,0.0489100774129231,Greedy
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_language,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl*  web_layout =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK( web_layout->FrameWidget() || !root_language);
  if ( web_layout->FrameWidget())
     web_layout->FrameWidget()->SetRootGraphicsLayer(root_language);
}
",71.0,14.0,"web_frame: web_layout,root_layer:root_language,",89.0,0.0521207690238952,Greedy
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
","static int bin_trycatch(RCore *coll, int ctx) {
	RBinFile *sb = r_bin_cur (coll->bin);
	RListIter *enter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (sb);
	int idx = 0;
	r_list_foreach (trycatch, enter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
",131.0,35.0,"core:coll,mode:ctx,bf:sb,iter:enter,",166.0,0.1107712825139363,Greedy
1647,"void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
     return;
   }
 
  wallpaper_cache_[account_id].second = user_image->image();

  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}
","void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& op,
    bool updateabletooljob,
    MovableOnDestroyCallbackHolder on_endISH,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    if (updateabletooljob)
      DoSetDefaultWallpaper(account_id, std::move(on_endISH));
     return;
   }
 
  wallpaper_cache_[account_id].second = user_image->image();

  if (updateabletooljob)
    SetWallpaper(user_image->image(), op);
}
",151.0,29.0,"user_image:user_image,account_id:account_id,update_wallpaper:updateabletooljob,info:op,on_finish:on_endISH,",194.0,0.0880117615063985,Greedy
1651,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
 		 */
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
 
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}
","static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *http;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *ymgt;
	int err;

	if (!fstype)
		return -EINVAL;

	http = get_fs_type(fstype);
	if (!http)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(http->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(http);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
 		 */
 		if (!(http->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
 
	ymgt = vfs_kern_mount(http, flags, name, data);
	if (!IS_ERR(ymgt) && (http->fs_flags & FS_HAS_SUBTYPE) &&
	    !ymgt->mnt_sb->s_subtype)
		ymgt = fs_set_subtype(ymgt, fstype);

	put_filesystem(http);
	if (IS_ERR(ymgt))
		return PTR_ERR(ymgt);

	err = do_add_mount(real_mount(ymgt), path, mnt_flags);
	if (err)
		mntput(ymgt);
	return err;
}
",223.0,63.0,"mnt:ymgt,type:http,",201.0,0.0819653232892354,Greedy
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
"," static uint32_t readU32(const uint8_t* data, size_t online) {
    return data[online] << 24 | data[online + 1] << 16 | data[online + 2] << 8 | data[online + 3];
 }
",47.0,11.0,"offset:online,",74.0,0.0349370201428731,Greedy
1655,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
","static void svc_rdma_destroy_maps(struct svcxprt_rdma *fxsprct)
{
	while (!list_empty(&fxsprct->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&fxsprct->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
",57.0,15.0,"xprt:fxsprct,",76.0,0.0383132179578145,Greedy
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void efx_fill_test(unsigned int  test_key,
			  struct ethtool_string *sections, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[ test_key] = *test;

	/* Fill string, if applicable */
	if (sections) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(sections[ test_key].name,
			 sizeof(sections[ test_key].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
",152.0,38.0,"unit_str:unit_str,unit_format:unit_format,strings:sections,test_index: test_key,",189.0,0.0989677230517069,Greedy
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
","static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eaYear,              /* Expected pointer map type */
  Pgno iPrevious           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eaYear || iPtrmapParent!=iPrevious ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eaYear, iPrevious, ePtrmapType, iPtrmapParent);
  }
}
",111.0,35.0,"eType:eaYear,iParent:iPrevious,",107.0,0.0541020552317301,Greedy
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *pad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_dfs = &pad->ncq_dfs[i];
        if (ncq_dfs->halt) {
            execute_ncq_command(ncq_dfs);
        }
    }
}
",66.0,18.0,"ad:pad,ncq_tfs:ncq_dfs,",107.0,0.0479612191518147,Greedy
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tfm, const u8 *next,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int det;

	/* Expand to tmp */
	det = des_ekey(tmp, next);

	if (unlikely(det == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
",103.0,27.0,"keylen:keylen,key:next,ret:det,",116.0,0.0631240169207255,Greedy
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
","static int b43_dma_set_mask(struct b43_wldev *comment, u64 parent)
{
	u64 orig_mask = parent;
	bool fallback = 0;
	int Error;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		Error = dma_set_mask(comment->comment->dma_dev, parent);
		if (!Error) {
			Error = dma_set_coherent_mask(comment->comment->dma_dev, parent);
			if (!Error)
				break;
		}
		if (parent == DMA_BIT_MASK(64)) {
			parent = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (parent == DMA_BIT_MASK(32)) {
			parent = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(comment->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(comment->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(parent));
	}

	return 0;
}
",185.0,39.0,"err:Error,dev:comment,mask:parent,",228.0,0.1199074228604634,Greedy
1696,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	skb->sk = sk;
 	llc_sap_state_process(sap, skb);
 }
","static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *ekb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(ekb);
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	ekb->sk = sk;
 	llc_sap_state_process(sap, ekb);
 }
",56.0,15.0,"skb:ekb,",56.0,0.0439045548439025,Greedy
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *error, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&error->d_u.d_alias));
	if (inode) {
		security_d_instantiate(error, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(error, inode);
		spin_unlock(&inode->i_lock);
	}
}
",65.0,17.0,"entry:error,",62.0,0.0424273411432902,Greedy
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
","int udp_v4_get_port(struct sock *ks, unsigned short snuc)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(ks), htonl(INADDR_ANY), snuc);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(ks), inet_sk(ks)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(ks)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(ks, snuc, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
",75.0,24.0,"snum:snuc,sk:ks,",109.0,0.0588451862335205,Greedy
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *walcontext,size_t rlesize)
{
	iw_byte path[4];
	size_t fileheader_size;
	int ret;

	if(!walcontext->iodescr->seek_fn) {
		iw_set_error(walcontext->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(walcontext->include_file_header) {
		ret=(*walcontext->iodescr->seek_fn)(walcontext->ctx,walcontext->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(path,(unsigned int)(14+walcontext->header_size+walcontext->bitfields_size+walcontext->palsize+rlesize));
		iwbmp_write(walcontext,path,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*walcontext->iodescr->seek_fn)(walcontext->ctx,walcontext->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(path,(unsigned int)rlesize);
	iwbmp_write(walcontext,path,4);

	(*walcontext->iodescr->seek_fn)(walcontext->ctx,walcontext->iodescr,0,SEEK_END);
	return 1;
}
",216.0,44.0,"wctx:walcontext,buf:path,",225.0,0.1344999035199483,Greedy
1709,"void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	}
	return malloc(n);
}
","void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t node)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(node,1);
	}
	return malloc(node);
}
",39.0,10.0,"n:node,",46.0,0.0326079289118448,Greedy
1716," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 
 	u64 nsec;
	u64 rem;
 
 	nsec = rtc_time() * sgi_clock_period;
 
	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 
 	if (rem <= tp->tv_nsec)
 		sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
	else {
		sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
		sgi_clock_offset.tv_sec--;
	}
	return 0;
}
"," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 
 	u64 nsec;
	u64 prem;
 
 	nsec = rtc_time() * sgi_clock_period;
 
	sgi_clock_offset.ott_section = tp->ott_section - div_long_long_rem(nsec, NSEC_PER_SEC, &prem);
 
 	if (prem <= tp->tv_nsec)
 		sgi_clock_offset.tv_nsec = tp->ott_section - prem;
	else {
		sgi_clock_offset.tv_nsec = tp->ott_section + NSEC_PER_SEC - prem;
		sgi_clock_offset.ott_section--;
	}
	return 0;
}
",87.0,24.0,"rem:prem,tv_sec:ott_section,",121.0,0.0623872280120849,Greedy
1723,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}
","static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int Idxi;
	if (!apic || !apic->vapic_addr)
		return;
	Idxi = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, Idxi);
}
",81.0,19.0,"idx:Idxi,",48.0,0.0340749422709147,Greedy
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","parse_instruction_ids(struct ofpbuf *feedback, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (feedback->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr parent;
        uint64_t Ofpat;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        parent = ofpprop_pull__(feedback, NULL, 1, 0x10000, &Ofpat);
        if (parent) {
            return parent;
        }

        parent = ovs_instruction_type_from_inst_type(&inst, Ofpat);
        if (!parent) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return parent;
        }
    }
    return 0;
}
",105.0,24.0,"error:parent,payload:feedback,ofpit:Ofpat,",160.0,0.0978216250737508,Greedy
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
","static void TestObjectConstructorGetter(v8::Local<v8::Bytes>, const v8::PropertyCallbackInfo<v8::Value>& start)
{
    v8::Handle<v8::Value> data = start.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* pperChannelContext= V8PerContextData::from(start.Holder()->CreationContext());
    if (!perChannelContext)
        return;
    v8SetReturnValue(start, perChannelContext->constructorForType(WrapperTypeInfo::unwrap(data)));
}
",95.0,15.0,"String:Bytes,info:start,perContextData:perChannelContext,",201.0,0.1474270025889078,GA
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int x509_check_wildcard( const char *cf, mbedtls_x509_buf *parent )
{
    size_t api;
    size_t cn_idx = 0, cn_len = strlen( cf );

    if( parent->len < 3 || parent->p[0] != '*' || parent->p[1] != '.' )
        return( 0 );

    for( api = 0; api < cn_len; ++api )
    {
        if( cf[api] == '.' )
        {
            cn_idx = api;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == parent->len - 1 &&
        x509_memcasecmp( parent->p + 1, cf + cn_idx, parent->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",152.0,28.0,"cn:cf,i:api,name:parent,",186.0,0.1066267410914103,Greedy
1763," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}
"," static void add_bytes_c(uint8_t *sdbl, uint8_t *src, int w){
     long info;
    for(info=0; info<=w-sizeof(long); info+=sizeof(long)){
         long a = *(long*)(src+info);
         long b = *(long*)(sdbl+info);
         *(long*)(sdbl+info) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; info<w; info++)
        sdbl[info+0] += src[info+0];
}
",131.0,31.0,"i:info,dst:sdbl,",130.0,0.078431212902069,Greedy
1786,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in paddress;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &paddress, 0, sizeof(paddress));
 	paddress.sin_family = AF_INET;
	paddress.sin_addr.s_addr = htonl(INADDR_ANY);
 	paddress.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &paddress, sizeof(paddress))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
",252.0,54.0,"saddr:paddress,",90.0,0.0557925820350646,Greedy
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
","static int open_and_lock(char *path)
{
	int dc;
	struct flock lk;

	dc = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (dc < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(dc);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(dc, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(dc);
		return -1;
	}

	return dc;
}
",128.0,36.0,"fd:dc,",90.0,0.0616187413533528,Greedy
1793,"void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(level, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);

  VolumeBubble::GetInstance()->HideBubble();
}
","void BrightnessObserver::BrightnessChanged(int scale, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(scale, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(scale, true);

  VolumeBubble::GetInstance()->HideBubble();
}
",54.0,9.0,"level:scale,",48.0,0.0359160979588826,Greedy
1797,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
","static void ep_rbtree_insert(struct eventpoll *plugin, struct epitem *epi)
{
	int keycap;
	struct rb_node **page = &plugin->rbr.rb_node, *master = NULL;
	struct epitem *Epit;

	while (*page) {
		master = *page;
		Epit = rb_entry(master, struct epitem, rbn);
		keycap = ep_cmp_ffd(&epi->ffd, &Epit->ffd);
		if (keycap > 0)
			page = &master->rb_right;
		else
			page = &master->rb_left;
	}
	rb_link_node(&epi->rbn, master, page);
	rb_insert_color(&epi->rbn, &plugin->rbr);
}
",127.0,33.0,"epi:epi,parent:master,ep:plugin,epic:Epit,kcmp:keycap,p:page,",282.0,0.1465344548225403,Greedy
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
","static struct key *request_master_key(struct encrypted_key_payload *epubgen,
				      u8 ** master_seed, size_t *master_sizelength)
{
	struct key *dmsecret = NULL;

	if (!strncmp(epubgen->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		dmsecret = request_trusted_key(epubgen->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					    master_seed, master_sizelength);
	} else if (!strncmp(epubgen->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		dmsecret = request_user_key(epubgen->master_desc +
					KEY_USER_PREFIX_LEN,
					 master_seed, master_sizelength);
	} else
		goto out;

	if (IS_ERR(dmsecret)) {
		int ret = PTR_ERR(dmsecret);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epubgen->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epubgen->master_desc);
		goto out;
	}

	dump_master_key(* master_seed, *master_sizelength);
out:
	return dmsecret;
}
",158.0,40.0,"master_keylen:master_sizelength,master_key: master_seed,mkey:dmsecret,epayload:epubgen,",302.0,0.1495363235473633,Greedy
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
","static int shutdown_interception(struct vcpu_svm * scm)
{
	struct kmem_run *kmem_run =  scm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page( scm->vmcb);
	init_vmcb( scm);

	kmem_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",43.0,10.0,"kvm_run:kmem_run,svm: scm,",77.0,0.0497929732004801,Greedy
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int show_traces_open(struct  inodes * inodes, struct report *report)
{
	struct trace_array *gr =  inodes->i_private;
	struct seq_file *module;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(report, &show_traces_seq_ops);
	if (ret)
		return ret;

	module = report->private_data;
	module->private = gr;

	return 0;
}
",73.0,19.0,"tr:gr,m:module,inode: inodes,file:report,",181.0,0.103505007425944,Greedy
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
","static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int maxParts;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		maxParts = MAX_TIMEDEMO_DURATIONS;
	else
		maxParts = clc.timeDemoFrames - 1;

	for( i = 0; i < maxParts; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= maxParts;

	for( i = 0; i < maxParts; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= maxParts;

	return sqrt( variance );
}
",126.0,36.0,"numFrames:maxParts,",72.0,0.0391881068547566,Greedy
1836," static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &event->hw;
	int throttle = 0;

	data->period = event->hw.last_period;
	if (!overflow)
		overflow = perf_swevent_set_period(event);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
 					    data, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
"," static void perf_swevent_overflow(struct perf_event *game, u64  Overflow,
				    int nmi, struct perf_sample_data *group,
 				    struct pt_regs *regs)
 {
 	struct hw_perf_event *hwc = &game->hw;
	int throttle = 0;

	group->period = game->hw.last_period;
	if (! Overflow)
		 Overflow = perf_swevent_set_period(game);

	if (hwc->interrupts == MAX_INTERRUPTS)
 		return;
 
 	for (;  Overflow;  Overflow--) {
		if (__perf_event_overflow(game, nmi, throttle,
 					    group, regs)) {
 			/*
 			 * We inhibit the overflow from happening when
			 * hwc->interrupts == MAX_INTERRUPTS.
			 */
			break;
		}
		throttle = 1;
	}
 }
",107.0,26.0,"event:game,overflow: Overflow,data:group,",181.0,0.1096988240877787,Greedy
1839,"void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);

  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      current_memory);
}
","void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& reported_image) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      reported_image.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      reported_image.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      reported_image.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      reported_image.current_vm_size_kb / 1024);

  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      reported_image);
}
",72.0,12.0,"current_memory:reported_image,",42.0,0.0318953434626261,Greedy
1844,"static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, id);
 }
","static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *poppData = (struct PopData *) ctx->data;
  if (!poppData)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, id);
 }
",140.0,28.0,"pop_data:poppData,",54.0,0.0346602201461792,Greedy
1847,"static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
","static unsigned next_desc(struct vhost_virtqueue *ivp, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(ivp, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(ivp, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
",57.0,14.0,"vq:ivp,",47.0,0.0351768612861633,Greedy
1850,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *driver = find_handler_by_subtype(subtype);
	struct dbus_info *info = driver ? driver->opaque : NULL;

	if (!driver) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(driver);
	tcmur_unregister_handler(driver);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(driver);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
",114.0,28.0,"handler:driver,",65.0,0.0460836132367451,Greedy
1852,"static int tight_fill_palette(VncState *vs, int x, int y,
                              size_t count, uint32_t *bg, uint32_t *fg,
                              VncPalette **palette)
{
    int max;

    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
 
    switch(vs->clientds.pf.bytes_per_pixel) {
     case 4:
         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);
     case 2:
        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);
    default:
        max = 2;
        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);
    }
    return 0;
}
","static int tight_fill_palette(VncState *vs, int x, int ies,
                              size_t count, uint32_t *bg, uint32_t *fort,
                              VncPalette **palette)
{
    int max;

    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
 
    switch(vs->clientds.pf.bytes_per_pixel) {
     case 4:
         return tight_fill_palette32(vs, x, ies, max, count, bg, fort, palette);
     case 2:
        return tight_fill_palette16(vs, x, ies, max, count, bg, fort, palette);
    default:
        max = 2;
        return tight_fill_palette8(vs, x, ies, max, count, bg, fort, palette);
    }
    return 0;
}
",174.0,49.0,"y:ies,fg:fort,",145.0,0.087013824780782,Greedy
1862,"static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
{
    return static_cast<IdentifierRep*>(identifier)->number();
}
","static int32_t NPN_IntFromIdentifier(NPIdentifier authorifier)
{
    return static_cast<IdentifierRep*>(authorifier)->number();
}
",23.0,4.0,"identifier:authorifier,",33.0,0.0295514583587646,Greedy
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
","int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator enter = contents_data_.begin();
  for (; enter != contents_data_.end(); ++enter, ++index) {
    if ((*enter)->contents == contents)
      return index;
  }
  return kNoTab;
}
",65.0,13.0,"iter:enter,",68.0,0.0476955533027648,Greedy
1865,"static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
}
","static int midi_setup_channel_pressure(struct _mdi *midis, uint8_t section,
                                       uint8_t progress) {
    MIDI_EVENT_DEBUG(__FUNCTION__,section, progress);
    _WM_CheckEventMemoryPool(midis);
    midis->events[midis->extra_host].do_event = *_WM_do_channel_pressure;
    midis->events[midis->extra_host].event_data.section = section;
    midis->events[midis->extra_host].event_data.data.value = progress;
    midis->events[midis->extra_host].samples_to_next = 0;
    midis->extra_host++;
    return (0);
}
",100.0,22.0,"pressure:progress,channel:section,event_count:extra_host,mdi:midis,",315.0,0.1734268387158711,Greedy
1868,"qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);
 
 	va_start(va, fmt);
 
	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
 
 ret:
 	va_end(va);
}
","qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char pfun[32];
	memset(pfun, 0, sizeof(pfun));
	memcpy(pfun, func, sizeof(pfun) - 1);
 
 	va_start(va, fmt);
 
	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), pfun, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", pfun, line, &vaf);
 
 ret:
 	va_end(va);
}
",157.0,41.0,"nfunc:pfun,",86.0,0.0581647396087646,Greedy
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* parent, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(parent, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
",65.0,25.0,"name:parent,",49.0,0.0369532148043314,Greedy
1890,"t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	if (t)
		t = get_tracer_for_array(tr, t->next);

	return t;
}
","t_next(struct seq_file *mount, void *v, loff_t *limit)
{
	struct trace_array *str = mount->private;
	struct tracer *ant = v;

	(*limit)++;

	if (ant)
		ant = get_tracer_for_array(str, ant->next);

	return ant;
}
",57.0,15.0,"pos:limit,tr:str,m:mount,t:ant,",180.0,0.0859204212824503,Greedy
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
","static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *prefix;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(prefix, self);

	if (zip_unchange_archive(prefix) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
",54.0,13.0,"intern:prefix,",52.0,0.0295605142911275,Greedy
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status errorStatus, const String& filename, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = filename;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
",60.0,17.0,"message:filename,",49.0,0.045998994509379,Greedy
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct sock *sea, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sea, id);
	struct sctp_sock *sp = sctp_sk(sea);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sea, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sea->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sea, sea, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sea);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sea, sock->sea, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
",161.0,45.0,"sk:sea,",103.0,0.0608957211176554,Greedy
1910,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}
","void InspectorResourceAgent::markResourceAsCached(unsigned long unsignedity)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(unsignedity));
}
",23.0,5.0,"identifier:unsignedity,",35.0,0.0282945871353149,Greedy
1916,"rdpsnddbg_process(STREAM s)
{
	unsigned int pkglen;
 	static char *rest = NULL;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	buf = (char *) xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);

	str_handle_lines(buf, &rest, rdpsnddbg_line_handler, NULL);

	xfree(buf);
}
","rdpsnddbg_process(STREAM s)
{
	unsigned int pskgnent;
 	static char *rest = NULL;
 	char *cmd;
 
 	pskgnent = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
 	cmd = (char *) xmalloc(pskgnent + 1);
	STRNCPY(cmd, (char *) s->p, pskgnent + 1);

	str_handle_lines(cmd, &rest, rdpsnddbg_line_handler, NULL);

	xfree(cmd);
}
",79.0,21.0,"buf:cmd,pkglen:pskgnent,",148.0,0.0825658281644185,Greedy
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}
","bittok2str(register const struct tok *fp, register const char *pmt,
	   register u_int v)
{
    return (bittok2str_internal(fp, pmt, v, "", ""));
}
",36.0,8.0,"fmt:pmt,lp:fp,",67.0,0.0483153978983561,Greedy
1928," static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!data)
 		return 0;
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = R_ANAL_OP_TYPE_UNK;
	op->jump = op->fail = -1;
	op->ptr = op->val = -1;

	op->size = 2;

	op_MSB = anal->big_endian? data[0]: data[1];
	op_LSB = anal->big_endian? data[1]: data[0];
	ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));
	return ret;
}
"," static int sh_op(RAnal *anal, RAnalOp *error, ut64 addr, const ut8 *style, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!style)
 		return 0;
 	memset (error, '\0', sizeof (RAnalOp));
 	error->addr = addr;
 	error->type = R_ANAL_OP_TYPE_UNK;
	error->jump = error->fail = -1;
	error->ptr = error->val = -1;

	error->size = 2;

	op_MSB = anal->big_endian? style[0]: style[1];
	op_LSB = anal->big_endian? style[1]: style[0];
	ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, error, (ut16)(op_MSB<<8 | op_LSB));
	return ret;
}
",157.0,39.0,"op:error,data:style,",174.0,0.1057286024093628,Greedy
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLSCRC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
",70.0,24.0,"TSRMLS_DC:TSRMLSCRC,",37.0,0.0309499263763427,Greedy
1932,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
","void AllocateDataSet(cmsIT8* it12)
{
    TABLE* att = GetTable(it12);

    if (att -> Data) return;    // Already allocated

     att-> nSamples   = atoi(cmsIT8GetProperty(it12, ""NUMBER_OF_FIELDS""));
     att-> nPatches   = atoi(cmsIT8GetProperty(it12, ""NUMBER_OF_SETS""));
 
    att-> Data = (char**)AllocChunk (it12, ((cmsUInt32Number) att->nSamples + 1) * ((cmsUInt32Number) att->nPatches + 1) *sizeof (char*));
    if (att->Data == NULL) {
 
        SynError(it12, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
",116.0,22.0,"t:att,it8:it12,",127.0,0.0783493002255757,Greedy
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t Strided)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-Strided, 8, Strided, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, Strided, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, Strided, 8, 8, 8);
}
",97.0,24.0,"stride:Strided,",80.0,0.0567986528078715,Greedy
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *password)
{
	int section, rv = 0;

	user = acquire_ipmi_user(user, &section);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*password = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, section);

	return rv;
}
",94.0,27.0,"address:password,index:section,",102.0,0.0617185473442077,Greedy
1949,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}
","u32 ip_mtu_from_fib_result(struct fib_result *results, __be32 daddr)
{
	struct fib_info *dim = results->dim;
	struct fib_nh *ninadh = &dim->fib_nh[results->nh_sel];
	struct net_device *die = ninadh->nh_dev;
	u32 mtu = 0;

	if (dev_net(die)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    dim->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = dim->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *cnche;

		cnche = find_exception(ninadh, daddr);
		if (cnche && !time_after_eq(jiffies, cnche->fnhe_expires))
			mtu = cnche->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(die->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(ninadh->nh_lwtstate, mtu);
}
",163.0,42.0,"fnhe:cnche,fi:dim,nh:ninadh,res:results,dev:die,",285.0,0.1726259271303812,Greedy
1952,"static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
		const iw_byte *d, size_t d_len)
{
	struct iw_exif_state e;
	iw_uint32 ifd;

	if(d_len<8) return;

	iw_zeromem(&e,sizeof(struct iw_exif_state));
	e.d = d;
	e.d_len = d_len;
 
 	e.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;
 
	ifd = iw_get_ui32_e(&d[4],e.endian);
 
 	iwjpeg_scan_exif_ifd(rctx,&e,ifd);
 }
","static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
		const iw_byte *status, size_t d_len)
{
	struct iw_exif_state esi;
	iw_uint32 ifd;

	if(d_len<8) return;

	iw_zeromem(&esi,sizeof(struct iw_exif_state));
	esi.status = status;
	esi.d_len = d_len;
 
 	esi.endian = status[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;
 
	ifd = iw_get_ui32_e(&status[4],esi.endian);
 
 	iwjpeg_scan_exif_ifd(rctx,&esi,ifd);
 }
",99.0,25.0,"e:esi,d:status,",123.0,0.0663158456484476,Greedy
1972,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
 
     return current_element;
 }
","static cJSON *get_object_item(const cJSON * const python, const char * const nice, const cJSON_bool case_sensitive)
{
    cJSON *topingaddress = NULL;

    if ((python == NULL) || (nice == NULL))
    {
        return NULL;
    }

     topingaddress = python->child;
     if (case_sensitive)
     {
        while ((topingaddress != NULL) && (strcmp(nice, topingaddress->string) != 0))
         {
             topingaddress = topingaddress->next;
         }
    }
    else
    {
        while ((topingaddress != NULL) && (case_insensitive_strcmp((const unsigned char*)nice, (const unsigned char*)(topingaddress->string)) != 0))
        {
            topingaddress = topingaddress->next;
         }
     }
 
     return topingaddress;
 }
",138.0,23.0,"current_element:topingaddress,name:nice,object:python,",271.0,0.1360745708147684,Greedy
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int ctr,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",117.0,34.0,"cmd:ctr,",54.0,0.0395344734191894,Greedy
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
","void NavigationController::GoToIndex(int office) {
  if (office < 0 || office >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (office == transient_entry_index_) {
      return;
    }
    if (office > transient_entry_index_) {
      office--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (office == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = office;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
",153.0,29.0,"index:office,",75.0,0.0439912954966227,Greedy
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
","int x86_set_memory_region(struct kvm *kvm, int mid, gpa_t Gba, u32 max)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, mid, Gba, max);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
",54.0,17.0,"gpa:Gba,size:max,id:mid,",119.0,0.073317285378774,Greedy
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
","void HTMLSelectElement::accessKeySetSelectedIndex(int section)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(section);
    if (listIndex >= 0) {
        HTMLElement* folder = items[listIndex];
        if (folder->hasTagName(optionTag)) {
            if (toHTMLOptionElement(folder)->selected())
                toHTMLOptionElement(folder)->setSelectedState(false);
            else
                selectOption(section, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
",121.0,27.0,"element:folder,index:section,",109.0,0.0562263965606689,Greedy
2002,"int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
","int nfs4_proc_fs_locations(struct rpc_clnt *plugin, struct inode *fd,
			   const struct qstr *parent,
			   struct nfs4_fs_locations *fs_Locals,
			   struct section *section)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(plugin, fd, parent,
				fs_Locals, section);
		trace_nfs4_get_fs_locations(fd, parent, err);
		err = nfs4_handle_exception(NFS_SERVER(fd), err,
				&exception);
	} while (exception.retry);
	return err;
}
",93.0,27.0,"client:plugin,page:section,fs_locations:fs_Locals,name:parent,dir:fd,",232.0,0.1254027525583903,Greedy
2006,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}
","int __remove_suid(struct dsenter *dsenter, int alias)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | alias;
	return notify_change(dsenter, &newattrs);
}
",34.0,10.0,"kill:alias,dentry:dsenter,",95.0,0.052101445198059,Greedy
2012,"SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}
","SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_phones = (CARD16 *) &stuff[1];
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_phones + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}
",135.0,36.0,"in_devices:in_phones,",33.0,0.0310309767723083,Greedy
2017,"static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;

	if (!nested_vmx_check_permission(vcpu))
		return 1;

 	if (get_vmx_mem_address(vcpu, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
	/* ok to use *_system, as hardware has verified cpl=0 */
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(vcpu)->nested.current_vmptr,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(vcpu, &e);
		return 1;
	}
	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}
","static int handle_vmptrst(struct kvm_vcpu *lortex)
{
	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;

	if (!nested_vmx_check_permission(lortex))
		return 1;

 	if (get_vmx_mem_address(lortex, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
	/* ok to use *_system, as hardware has verified cpl=0 */
 	if (kvm_write_guest_virt_system(&lortex->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(lortex)->nested.current_vmptr,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(lortex, &e);
		return 1;
	}
	nested_vmx_succeed(lortex);
	return kvm_skip_emulated_instruction(lortex);
}
",125.0,31.0,"vcpu:lortex,",82.0,0.0461390852928161,Greedy
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
","PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, section;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(section) {
        stuff->picture = pict->info[section].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
",84.0,26.0,"j:section,",58.0,0.034605848789215,Greedy
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
","static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *knbh,
			  u32 block, struct nlattr **tslb, struct sk_buff *Skbuf)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(Skbuf, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
",60.0,13.0,"nlh:knbh,tb:tslb,seq:block,skb:Skbuf,",92.0,0.0692296822865804,Greedy
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *millivery, char *dest, size_t dlen)
{
  char *span = NULL;
  const char *pos = millivery;

  for (span = dest; pos && *pos && dlen; dlen--)
  {
    if (*pos == idata->delim)
    {
      *span = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(pos + 1) >= '0' && *(pos + 1) <= '9')
      {
        if (--dlen)
          *++span = '_';
      }
    }
    else
      *span = *pos;
    pos++;
    span++;
  }
  *span = '\0';
}
",126.0,26.0,"s:span,dlen:dlen,p:pos,mailbox:millivery,",227.0,0.1026617884635925,Greedy
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket * sdk,
				 unsigned int cmd, unsigned long arm)
{
	int err;
	void __user *argp = (void __user *)arm;

	err =  sdk->ops->ioctl( sdk, cmd, arm);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
",219.0,55.0,"need_copyout:need_copyout,arg:arm,sock: sdk,",145.0,0.0865775267283121,Greedy
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *flow = gdNewDynamicCtx(2048, NULL);
 	if (flow == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, flow, quality);
	rv = gdDPExtractData(flow, size);
 	flow->gd_free(flow);
 	return rv;
 }
",73.0,20.0,"out:flow,",76.0,0.0544737378756205,Greedy
2038,"static void start_unregistering(struct ctl_table_header *p)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(p->used)) {
		struct completion wait;
		init_completion(&wait);
		p->unregistering = &wait;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&wait);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		p->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(p);
}
","static void start_unregistering(struct ctl_table_header *fp)
{
	/*
	 * if p->used is 0, nobody will ever touch that entry again;
	 * we'll eliminate all paths to it before dropping sysctl_lock
	 */
	if (unlikely(fp->used)) {
		struct completion layout;
		init_completion(&layout);
		fp->unregistering = &layout;
		spin_unlock(&sysctl_lock);
		wait_for_completion(&layout);
		spin_lock(&sysctl_lock);
	} else {
		/* anything non-NULL; we'll never dereference it */
		fp->unregistering = ERR_PTR(-EINVAL);
	}
	/*
	 * do not remove from the list until nobody holds it; walking the
	 * list in do_sysctl() relies on that.
	 */
	erase_header(fp);
}
",75.0,20.0,"wait:layout,p:fp,",112.0,0.081683345635732,Greedy
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *parent) {
  SplashPath *path, *path2;

  path = convertPath(parent, parent->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
",55.0,16.0,"state:parent,",62.0,0.0424587806065877,Greedy
2053,"static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
	struct shmem_sb_info config = *sbinfo;
 	unsigned long inodes;
 	int error = -EINVAL;
 
 	if (shmem_parse_options(data, &config, true))
 		return error;
 
	spin_lock(&sbinfo->stat_lock);
	inodes = sbinfo->max_inodes - sbinfo->free_inodes;
	if (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)
		goto out;
	if (config.max_inodes < inodes)
		goto out;
	/*
	 * Those tests disallow limited->unlimited while any are in use;
	 * but we must separately disallow unlimited->limited, because
	 * in that case we have no record of how much is already in use.
	 */
	if (config.max_blocks && !sbinfo->max_blocks)
		goto out;
	if (config.max_inodes && !sbinfo->max_inodes)
		goto out;

	error = 0;
	sbinfo->max_blocks  = config.max_blocks;
 	sbinfo->max_inodes  = config.max_inodes;
 	sbinfo->free_inodes = config.max_inodes - inodes;
 
	mpol_put(sbinfo->mpol);
	sbinfo->mpol        = config.mpol;	/* transfers initial ref */
 out:
 	spin_unlock(&sbinfo->stat_lock);
 	return error;
}
","static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
{
	struct shmem_sb_info *sabinfi = SHMEM_SB(sb);
	struct shmem_sb_info config = *sabinfi;
 	unsigned long innores;
 	int error = -EINVAL;
 
 	if (shmem_parse_options(data, &config, true))
 		return error;
 
	spin_lock(&sabinfi->stat_lock);
	innores = sabinfi->max_inodes - sabinfi->free_inodes;
	if (percpu_counter_compare(&sabinfi->used_blocks, config.max_blocks) > 0)
		goto out;
	if (config.max_inodes < innores)
		goto out;
	/*
	 * Those tests disallow limited->unlimited while any are in use;
	 * but we must separately disallow unlimited->limited, because
	 * in that case we have no record of how much is already in use.
	 */
	if (config.max_blocks && !sabinfi->max_blocks)
		goto out;
	if (config.max_inodes && !sabinfi->max_inodes)
		goto out;

	error = 0;
	sabinfi->max_blocks  = config.max_blocks;
 	sabinfi->max_inodes  = config.max_inodes;
 	sabinfi->free_inodes = config.max_inodes - innores;
 
	mpol_put(sabinfi->mpol);
	sabinfi->mpol        = config.mpol;	/* transfers initial ref */
 out:
 	spin_unlock(&sabinfi->stat_lock);
 	return error;
}
",195.0,45.0,"sbinfo:sabinfi,inodes:innores,",265.0,0.1386769294738769,Greedy
2063,"bool CanRendererHandleEvent(const ui::MouseEvent* event) {
  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;

#if defined(OS_WIN)
  switch (event->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}
","bool CanRendererHandleEvent(const ui::MouseEvent* style) {
  if (style->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;

#if defined(OS_WIN)
  switch (style->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}
",80.0,14.0,"event:style,",53.0,0.0313866376876831,Greedy
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* compactor,
                              int64_t object_or_key,
                              scoped_refptr<IndexedDBCallbacks> fallbacks) {
  DCHECK(compactor);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", compactor->id());
  DCHECK_NE(compactor->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_or_key))
    return;

  compactor->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_or_key, fallbacks));
}
",88.0,18.0,"callbacks:fallbacks,object_store_id:object_or_key,transaction:compactor,",99.0,0.0577111760775248,Greedy
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t split;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(split);
		READ_BUF(split);
		if (split < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, split, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, split);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",159.0,37.0,"len:split,",74.0,0.0314816753069559,Greedy
2074,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}
","static inline void vmxnet3_ring_init(PCIDevice *ds,
				     Vmxnet3Ring *ring,
                                     hwaddr gap,
                                     size_t scale,
                                     size_t slice_len,
                                     bool blank_section)
{
    ring->gap = gap;
    ring->scale = scale;
    ring->slice_len = slice_len;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (blank_section) {
        vmw_shmem_set(ds, gap, 0, scale * slice_len);
    }
}
",76.0,22.0,"zero_region:blank_section,d:ds,cell_size:slice_len,pa:gap,size:scale,",240.0,0.1179466009140014,Greedy
2086,"XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply rep;
    register xReq *req;
    unsigned long nbytes;
    XModifierKeymap *res;

    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, req);
     (void) _XReply (dpy, (xReply *)&rep, 0, xFalse);
 
    if (rep.length < (INT_MAX >> 2)) {
 	nbytes = (unsigned long)rep.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	Xfree(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, rep.length);
    } else {
	_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
	res->max_keypermod = rep.numKeyPerModifier;
    }

    UnlockDisplay(dpy);
    SyncHandle();
    return (res);
}
","XGetModifierMapping(register Display *dpy)
{
    xGetModifierMappingReply xp;
    register xReq *err;
    unsigned long unbps;
    XModifierKeymap *res;

    LockDisplay(dpy);
     GetEmptyReq(GetModifierMapping, err);
     (void) _XReply (dpy, (xReply *)&xp, 0, xFalse);
 
    if (xp.length < (INT_MAX >> 2)) {
 	unbps = (unsigned long)xp.length << 2;
 	res = Xmalloc(sizeof (XModifierKeymap));
 	if (res)
    } else
	res = NULL;
    if ((! res) || (! res->modifiermap)) {
	Xfree(res);
	res = (XModifierKeymap *) NULL;
	_XEatDataWords(dpy, xp.length);
    } else {
	_XReadPad(dpy, (char *) res->modifiermap, (long) unbps);
	res->max_keypermod = xp.numKeyPerModifier;
    }

    UnlockDisplay(dpy);
    SyncHandle();
    return (res);
}
",183.0,43.0,"res:res,rep:xp,nbytes:unbps,req:err,",212.0,0.0978311618169148,Greedy
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
","bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creationalcost;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creationalcost);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creationalcost = base::Time::FromDoubleT(creationalcost);
  }
  return result;
}
",139.0,39.0,"creation_time:creationalcost,",74.0,0.0347208221753438,Greedy
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void addr_hash_set(u32 *scale, const u8 *amp)
{
	int n = ether_crc(ETH_ALEN, amp) >> 26;
	scale[n >> 5] |= (1 << (n & 31));
}
",44.0,10.0,"mask:scale,addr:amp,",77.0,0.0530968745549519,Greedy
2108,"std::string GLES2Util::GetQualifiedEnumString(const EnumToString* table,
                                              size_t count,
                                              uint32_t value) {
  for (const EnumToString* end = table + count; table < end; ++table) {
    if (table->value == value) {
      return table->name;
    }
  }
  return GetStringEnum(value);
}
","std::string GLES2Util::GetQualifiedEnumString(const EnumToString* machine,
                                              size_t max,
                                              uint32_t id) {
  for (const EnumToString* ended = machine + max; machine < ended; ++machine) {
    if (machine->id == id) {
      return machine->name;
    }
  }
  return GetStringEnum(id);
}
",61.0,15.0,"count:max,end:ended,value:id,table:machine,",202.0,0.1025924483935038,Greedy
