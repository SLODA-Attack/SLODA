Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *desc, uint8_t *dst, long num_tips, const uint8_t *pixelette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_tips; i++)

	{

		//FIXME slow?

		dst[0]= pixelette[ desc[i]*4+0 ];

		dst[1]= pixelette[ desc[i]*4+1 ];

		dst[2]= pixelette[ desc[i]*4+2 ];

		dst+= 3;

	}

}
",95.0,23.0,"num_pixels:num_tips,src:desc,palette:pixelette,",164.0,0.0484796484311421,Greedy
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *ist = avformat_new_stream(s, NULL);

    if (!ist)

        return NULL;

    ist->codec->codec_tag   = 0;

    ist->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        ist->codec->width  = (80<<3);

        ist->codec->height = (25<<4);

    }



    avpriv_set_pts_info(ist, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(ist->time_base) * bin->chars_per_frame, 1);



    return ist;

}
",129.0,24.0,"st:ist,",89.0,0.0272694905598958,Greedy
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *pullowed, uint64_t *phai, int64_t lb)

{

    int pa, sb;

    pa = ((int64_t)*phai < 0);

    if (pa)

        neg128(pullowed, phai);

    sb = (lb < 0);

    if (sb)

        lb = -lb;

    div64(pullowed, phai, lb);

    if (pa ^ sb)

        *pullowed = - *pullowed;

    if (pa)

        *phai = - *phai;

}
",95.0,28.0,"sa:pa,phigh:phai,plow:pullowed,b:lb,",242.0,0.0658450047175089,Greedy
78,"static void tap_receive(void *opaque, const uint8_t *buf, size_t size)

{

    TAPState *s = opaque;

    int ret;

    for(;;) {

        ret = write(s->fd, buf, size);

        if (ret < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
","static void tap_receive(void *ropaque, const uint8_t *bag, size_t size)

{

    TAPState *sym = ropaque;

    int usr;

    for(;;) {

        usr = write(sym->fd, bag, size);

        if (usr < 0 && (errno == EINTR || errno == EAGAIN)) {

        } else {

            break;

        }

    }

}
",70.0,17.0,"ret:usr,s:sym,buf:bag,opaque:ropaque,",165.0,0.0501616239547729,Greedy
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
","static char *enumerate_cpus(unsigned long *cpus, int max_cpuores)

{

    int currency;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (currency = find_first_bit(cpus, max_cpuores);

        currency < max_cpuores;

        currency = find_next_bit(cpus, max_cpuores, currency + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", currency);

        first = false;

    }

    return g_string_free(s, FALSE);

}
",92.0,25.0,"cpu:currency,max_cpus:max_cpuores,",126.0,0.0371673464775085,Greedy
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *p,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return p->vhost_ops->vhost_send_device_iotlb_msg(p, &imsg);

}
",51.0,14.0,"dev:p,",71.0,0.0239241083463033,Greedy
111,"void qemu_cpu_kick(void *env)

{

    return;

}
","void qemu_cpu_kick(void *iv)

{

    return;

}
",11.0,2.0,"env:iv,",32.0,0.0161380728085835,Greedy
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void temp_allocate_frame(TCGContext *sym, int tmp)

{

    TCGTemp *test;

    test = &sym->temps[tmp];

    sym->current_frame_offset = (sym->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (sym->current_frame_offset + sizeof(tcg_target_long) > sym->frame_end)

        tcg_abort();

    test->mem_offset = sym->current_frame_offset;

    test->mem_reg = sym->frame_reg;

    test->mem_allocated = 1;

    sym->current_frame_offset += sizeof(tcg_target_long);

}
",104.0,22.0,"s:sym,ts:test,temp:tmp,",180.0,0.0530277172724405,Greedy
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
","static inline void RENAME(rgb32ToY)(uint8_t * dtd, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		 dtd[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
",128.0,28.0,"dst: dtd,",43.0,0.0188418348630269,Greedy
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t vids = 0;



    while (vids <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(vids)) {

            return vids;

        }



        if (vids == ZPCI_MAX_FID) {

            break;

        }



        vids++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",61.0,13.0,"fid:vids,",73.0,0.0234418074289957,Greedy
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *menu)

{

    Coroutine *business;



    business = QSIMPLEQ_FIRST(&menu->entries);

    if (!business) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&menu->entries, co_queue_next);

    qemu_coroutine_enter(business, NULL);

    return true;

}
",53.0,12.0,"next:business,queue:menu,",107.0,0.0328204115231831,Greedy
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long monitor_get_reg(const struct MonitorDef *md, int pl)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[pl];

}
",39.0,8.0,"val:pl,",46.0,0.0260467966397603,Greedy
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
","static av_cold int png_dec_end(AVCodecContext *afconfig)

{

    PNGDecContext *s = afconfig->priv_data;



    ff_thread_release_buffer(afconfig, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(afconfig, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(afconfig, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138.0,32.0,"avctx:afconfig,",68.0,0.0238272428512573,Greedy
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
","static int ftp_file_size(FTPContext *sym)

{

    char attribute[CONTROL_BUFFER_SIZE];

    char *rev = NULL;

    const int size___errors[] = {213, 0};



    snprintf(attribute, sizeof(attribute), ""SIZE %s\r\n"", sym->path);

    if (ftp_send_command(sym, attribute, size___errors, &rev)) {

        sym->filesize = strtoll(&rev[4], NULL, 10);

    } else {

        sym->filesize = -1;

        av_free(rev);

        return AVERROR(EIO);

    }



    av_free(rev);

    return 0;

}
",114.0,25.0,"s:sym,res:rev,command:attribute,size_codes:size___errors,",193.0,0.0567662874857584,Greedy
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtoll_whitespace(void)

{

    const char *spec = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int iter;



    iter = qemu_strtoll(spec, &endptr, 0, &res);



    g_assert_cmpint(iter, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == spec);

}
",81.0,19.0,"err:iter,str:spec,",107.0,0.0351604501406351,Greedy
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
","int ff_schro_queue_push_back(FFSchroQueue *delay, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!delay->p_head)

        delay->p_head = p_new;

    else

        delay->p_tail->next = p_new;

    delay->p_tail = p_new;



    ++delay->size;

    return 0;

}
",75.0,17.0,"queue:delay,",77.0,0.0277042984962463,Greedy
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *dev, Property *prop, const char *spec)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *cfformat;



    /* accept both hex and decimal */

    cfformat = strncasecmp(spec, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(spec, cfformat, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"fmt:cfformat,str:spec,",85.0,0.029100477695465,Greedy
186,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
","static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int STRided, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, STRided, block);



    return 0;

}
",139.0,37.0,"stride:STRided,",59.0,0.0221509853998819,Greedy
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *mr;



    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(mr)) {

        return false;

    } else {

        return true;

    }

}
","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)

{

    MemoryRegion *wr;



    wr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);

    if (memory_region_is_mapped(wr)) {

        return false;

    } else {

        return true;

    }

}
",47.0,11.0,"mr:wr,",58.0,0.0210125764211018,Greedy
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int cpu_gdb_index(CPUState *fc)

{

#if defined(CONFIG_USER_ONLY)

    return fc->host_tid;

#else

    return fc->cpu_index + 1;

#endif

}
",31.0,5.0,"cpu:fc,",49.0,0.0185014923413594,Greedy
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned eff)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)eff >> 31) << 1));

    eff <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)eff >> 31) << 1));

    eff <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)eff >> 31) << 1));

    eff <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)eff >> 31) << 1));



    return dst + 4;

}
",178.0,28.0,"sign:eff,",92.0,0.0281053980191548,Greedy
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysc, const uint8_t *usrc, const uint8_t *wources, uint8_t *dst,

                                         long width, long images,

                                         long lumStride, long chromStride, long dstRestrip)

{

    RENAME(yuvPlanartouyvy)(ysc, usrc, wources, dst, width, images, lumStride, chromStride, dstRestrip, 1);

}
",70.0,21.0,"chromStride:chromStride,height:images,dstStride:dstRestrip,vsrc:wources,ysrc:ysc,",183.0,0.0586573044459025,Greedy
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
","static av_cold int init_bundles(BinkContext *c)

{

    int bw, ih, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    ih = (c->avctx->height + 7) >> 3;

    blocks = bw * ih;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
",129.0,31.0,"bh:ih,",72.0,0.024508249759674,Greedy
226,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
","static inline void t_gen_mov_preg_TN(DisasContext *dc, int rg, TCGv tn)

{

    if (rg < 0 || rg > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", rg);

    }

    if (rg == PR_BZ || rg == PR_WZ || rg == PR_DZ) {

        return;

    } else if (rg == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[rg], tn, 3);

    } else {

        if (rg == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && rg == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (rg == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[rg], tn);

    }

}
",143.0,40.0,"r:rg,",92.0,0.0295949975649515,Greedy
231,"static void scsi_read_data(SCSIDevice *d, uint32_t tag)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);

    SCSIDiskReq *r;



    r = scsi_find_request(s, tag);

    if (!r) {

        BADF(""Bad read tag 0x%x\n"", tag);

        /* ??? This is the wrong error.  */

        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);

        return;

    }



    /* No data transfer may already be in progress */

    assert(r->req.aiocb == NULL);



    scsi_read_request(r);

}
","static void scsi_read_data(SCSIDevice *i, uint32_t test)

{

    SCSIDiskState *ds = DO_UPCAST(SCSIDiskState, qdev, i);

    SCSIDiskReq *br;



    br = scsi_find_request(ds, test);

    if (!br) {

        BADF(""Bad read tag 0x%x\n"", test);

        /* ??? This is the wrong error.  */

        scsi_command_complete(br, CHECK_CONDITION, HARDWARE_ERROR);

        return;

    }



    /* No data transfer may already be in progress */

    assert(br->req.aiocb == NULL);



    scsi_read_request(br);

}
",82.0,24.0,"r:br,tag:test,s:ds,d:i,",192.0,0.0575751066207885,Greedy
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t err;

    int base;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&err);

    pthread_attr_setdetachstate(&err, PTHREAD_CREATE_DETACHED);

    base = pthread_create(&thread_id, &err, aio_thread, NULL);

    pthread_attr_destroy(&err);



    return base;

}
",58.0,18.0,"attr:err,ret:base,",116.0,0.0446850935618082,Greedy
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,

                                ChardevReturn *ret, Error **errp)

{

    return vc_handler(backend->u.vc, errp);

}
","static CharDriverState *vc_init(const char *rid, ChardevBackend *Backen,

                                ChardevReturn *ret, Error **aceP)

{

    return vc_handler(Backen->u.vc, aceP);

}
",37.0,8.0,"errp:aceP,backend:Backen,id:rid,",76.0,0.029987366994222,Greedy
250,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,

                   uint8_t *properties)

{

    int compno;



    if (s->buf_end - s->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&s->buf);



    c      += compno;

    c->csty = bytestream_get_byte(&s->buf);

    get_cox(s, c);



    properties[compno] |= HAD_COC;

    return 0;

}
","static int get_coc(Jpeg2000DecoderContext *ssl, Jpeg2000CodingStyle *C,

                   uint8_t *properties)

{

    int compno;



    if (ssl->buf_end - ssl->buf < 2)

        return AVERROR(EINVAL);



    compno = bytestream_get_byte(&ssl->buf);



    C      += compno;

    C->csty = bytestream_get_byte(&ssl->buf);

    get_cox(ssl, C);



    properties[compno] |= HAD_COC;

    return 0;

}
",82.0,23.0,"s:ssl,c:C,",125.0,0.0469510197639465,Greedy
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
","static int get_uint16_equal(QEMUFile *f, void *Pvt, size_t size)

{

    uint16_t *v = Pvt;

    uint16_t V1;

    qemu_get_be16s(f, &V1);



    if (*v == V1) {

        return 0;

    }

    return -EINVAL;

}
",50.0,13.0,"v2:V1,pv:Pvt,",54.0,0.029668112595876,Greedy
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)

{

    *q_ptr = num / den;

    return num % den;

}
","uint32_t div32(uint32_t *p_pt, uint64_t num, uint32_t flow)

{

    *p_pt = num / flow;

    return num % flow;

}
",27.0,9.0,"q_ptr:p_pt,den:flow,",72.0,0.0293839216232299,Greedy
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
","static void gen_check_sr(DisasContext *director, uint32_t spr, unsigned address)

{

    if (!xtensa_option_bits_enabled(director->config, sregnames[spr].opt_bits)) {

        if (sregnames[spr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[spr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", spr);

        }

        gen_exception_cause(director, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[spr].address & address)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(address < ARRAY_SIZE(access_text) && access_text[address]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[spr].name,

                access_text[address]);

        gen_exception_cause(director, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
",170.0,39.0,"sr:spr,access:address,dc:director,",198.0,0.06869531472524,Greedy
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t HELPER(shr_cc)(CPUM68KState *txt, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    txt->cc_c = (temp >> 31) & 1;

    txt->cc_n = result;

    txt->cc_z = result;

    txt->cc_v = 0;

    txt->cc_x = shift ? txt->cc_c : txt->cc_x;



    return result;

}
",92.0,24.0,"env:txt,",97.0,0.0347023010253906,Greedy
307,"void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vaddr;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vaddr = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vaddr);

#endif

}
","void helper_tlb_update(uint32_t T0)

{

#if !defined(CONFIG_USER_ONLY)

	uint32_t vhost;

	uint32_t srs = env->pregs[PR_SRS];



	if (srs != 1 && srs != 2)

		return;



	vhost = cris_mmu_tlb_latest_update(env, T0);

	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vhost, 

		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));

	tlb_flush_page(env, vhost);

#endif

}
",80.0,23.0,"vaddr:vhost,",46.0,0.0184942563374837,Greedy
309,"static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int x, y;

    float ssim = 0.0;

    int (*sum0)[4] = temp;

    int (*sum1)[4] = sum0 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, sum0, sum1);

            for (x = 0; x < width; x+=2)

                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,

                                &ref[4 * (x + z * ref_stride)], ref_stride,

                                &sum0[x]);

        }



        ssim += ssim_endn(sum0, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
","static float ssim_plane(uint8_t *main, int main_stride,

                        uint8_t *ref, int ref_stride,

                        int width, int height, void *temp)

{

    int z = 0;

    int lex, y;

    float ssim = 0.0;

    int (*dim2)[4] = temp;

    int (*sum1)[4] = dim2 + (width >> 2) + 3;



    width >>= 2;

    height >>= 2;



    for (y = 1; y < height; y++) {

        for (; z <= y; z++) {

            FFSWAP(void*, dim2, sum1);

            for (lex = 0; lex < width; lex+=2)

                ssim_4x4x2_core(&main[4 * (lex + z * main_stride)], main_stride,

                                &ref[4 * (lex + z * ref_stride)], ref_stride,

                                &dim2[lex]);

        }



        ssim += ssim_endn(dim2, sum1, width - 1);

    }



    return ssim / ((height - 1) * (width - 1));

}
",205.0,54.0,"x:lex,sum0:dim2,",119.0,0.0399873693784077,Greedy
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
","static void hScale8To15_c(SwsContext *c, int16_t *dst, int DSTC, const uint8_t *src,

                          const int16_t *support, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<DSTC; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*support[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127.0,34.0,"filter:support,dstW:DSTC,",117.0,0.0390351732571919,Greedy
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv ret)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(ret, cpu_cc_src, 11);

    tcg_gen_andi_tl(ret, ret, 1);

}
",36.0,11.0,"reg:ret,",62.0,0.0243677377700805,Greedy
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t read_ts(char **lf, int *duration)

{

    int64_t pad, address;



    if (sscanf(*lf, ""%""SCNd64"",%""SCNd64, &pad, &address) == 2) {

        *lf += strcspn(*lf, ""\"""") + 1;

        *duration = address - pad;

        return pad;

    }

    return AV_NOPTS_VALUE;

}
",73.0,19.0,"start:pad,line:lf,end:address,",157.0,0.0486414670944213,Greedy
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
","static void raven_class_init(ObjectClass *oklass, void *raw)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(oklass);

    DeviceClass *dc = DEVICE_CLASS(oklass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
",82.0,22.0,"data:raw,klass:oklass,",75.0,0.030007266998291,Greedy
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv boot;

    boot = new_tmp();

    tcg_gen_trunc_i64_i32(boot, val);

    store_reg(s, rlow, boot);

    boot = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(boot, val);

    store_reg(s, rhigh, boot);

}
",75.0,27.0,"tmp:boot,",87.0,0.0287530382474263,Greedy
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int lan)

{

    int ret = 0;



    assert(lan > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->lan - s->current_bulk_in->pos, lan);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->lan) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, lan, ret);

    }

    if (ret != USB_RET_NAK && ret < lan) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, lan);

    }

    return ret;

}
",175.0,45.0,"len:lan,",93.0,0.0319130142529805,Greedy
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)

{

    VirtIONet *n = opaque;

    VirtIODevice *vdev = VIRTIO_DEVICE(n);



    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(vdev, f, version_id);

}
","static int virtio_net_load(QEMUFile *v, void * oponymous, int ver_sid)

{

    VirtIONet *i =  oponymous;

    VirtIODevice *pDev = VIRTIO_DEVICE(i);



    if (ver_sid < 2 || ver_sid > VIRTIO_NET_VM_VERSION)

        return -EINVAL;



    return virtio_load(pDev, v, ver_sid);

}
",56.0,17.0,"version_id:ver_sid,vdev:pDev,opaque: oponymous,f:v,n:i,",169.0,0.0601100762685139,Greedy
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
","static int32_t parse_gain(const char *gain)

{

    char *lfractions;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int fb;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    fb = strtol(gain, &lfractions, 0);

    if (*lfractions++ == '.') {

        while (av_isdigit(*lfractions) && scale) {

            mb += scale * (*lfractions - '0');

            scale /= 10;

            lfractions++;

        }

    }



    if (abs(fb) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return fb * 100000 + sign * mb;

}
",145.0,35.0,"db:fb,fraction:lfractions,",125.0,0.0393805662790934,Greedy
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)

{

    BlockDriverState *bs = opaque;

    int ret = 0;



    if (bdrv_set_key(bs, password) != 0) {

        monitor_printf(mon, ""invalid password\n"");

        ret = -EPERM;

    }

    if (mon->password_completion_cb)

        mon->password_completion_cb(mon->password_opaque, ret);



    monitor_read_command(mon, 1);

}
","static void bdrv_password_cb(Monitor *sym, const char *attribute, void *opque)

{

    BlockDriverState *bs = opque;

    int ret = 0;



    if (bdrv_set_key(bs, attribute) != 0) {

        monitor_printf(sym, ""invalid password\n"");

        ret = -EPERM;

    }

    if (sym->password_completion_cb)

        sym->password_completion_cb(sym->password_opaque, ret);



    monitor_read_command(sym, 1);

}
",81.0,20.0,"mon:sym,password:attribute,opaque:opque,",143.0,0.0467301646868387,Greedy
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *nv;



    vlan = qemu_find_vlan(vlan_id);



   for(nv = vlan->first_client; nv != NULL; nv = nv->next)

        if (!strcmp(nv->name, device))

            break;



    if (!nv) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(nv);

}
",89.0,23.0,"vc:nv,",80.0,0.0274480779965718,Greedy
444,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
","static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int rar;



    rar = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(rar, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",59.0,12.0,"err:rar,",51.0,0.0226758360862731,Greedy
447,"static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    CharDriverState *chr;

    ChardevCommon *common = backend->u.null;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    chr->chr_write = null_chr_write;

    chr->explicit_be_open = true;

    return chr;

}
","static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *Backend,

                                           ChardevReturn *ret,

                                           Error **err)

{

    CharDriverState *cherr;

    ChardevCommon *shared = Backend->u.null;



    cherr = qemu_chr_alloc(shared, err);

    if (!cherr) {

        return NULL;

    }

    cherr->chr_write = null_chr_write;

    cherr->explicit_be_open = true;

    return cherr;

}
",73.0,17.0,"chr:cherr,common:shared,backend:Backend,errp:err,",164.0,0.0528279741605122,Greedy
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)

{

    int i;

    for(i=0; i<4 && tags[i]; i++){

        enum CodecID id= codec_get_id(tags[i], tag);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
","enum CodecID av_codec_get_id(const AVCodecTag *users[4], unsigned int length)

{

    int uri;

    for(uri=0; uri<4 && users[uri]; uri++){

        enum CodecID id= codec_get_id(users[uri], length);

        if(id!=CODEC_ID_NONE) return id;

    }

    return CODEC_ID_NONE;

}
",67.0,18.0,"i:uri,tags:users,tag:length,",152.0,0.0574711362520853,Greedy
461,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
","static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bitfscale;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bitfscale = ctx->bitfscale;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bitfscale = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bitfscale;

        break;

    default:

        bitfscale = 0;

        break;

    }

    return bitfscale;

}
",87.0,23.0,"bit_rate:bitfscale,",69.0,0.0280737916628519,Greedy
465,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
","static inline int mirror(int uv, int m){

    if     (uv<0) return -uv;

    else if(uv>m) return 2*m-uv;

    else         return uv;

}
",41.0,10.0,"v:uv,",63.0,0.0237897038459777,Greedy
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);



    k->init = bonito_pcihost_initfn;

    dc->no_user = 1;

}
","static void bonito_pcihost_class_init(ObjectClass *oklasses, void *data)

{

    DeviceClass *cp = DEVICE_CLASS(oklasses);

    SysBusDeviceClass *kick = SYS_BUS_DEVICE_CLASS(oklasses);



    kick->init = bonito_pcihost_initfn;

    cp->no_user = 1;

}
",44.0,12.0,"k:kick,klass:oklasses,dc:cp,",110.0,0.0518943905830383,Greedy
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *loc, int Striden){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= loc[i-Striden];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(loc+i*Striden))[0]=

        ((uint32_t*)(loc+i*Striden))[1]= dc0;

    }

}
",110.0,25.0,"src:loc,stride:Striden,",127.0,0.0507344047228495,Greedy
491,"static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)

{

    rtl8139_do_receive(opaque, buf, size, 1);

}
","static void rtl8139_receive(void *opque, const uint8_t *cur, size_t large)

{

    rtl8139_do_receive(opque, cur, large, 1);

}
",29.0,8.0,"buf:cur,size:large,opaque:opque,",107.0,0.0452296217282613,Greedy
500,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}","static bool do_modify_softint(CPUSPARCState *esp, uint32_t value)

{

    if (esp->softint != value) {

        esp->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(esp)) {


            cpu_check_irqs(esp);


        }

#endif

        return true;

    }

    return false;

}",57.0,12.0,"env:esp,",70.0,0.0317662398020426,Greedy
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double d;

    char *ptr;

    FdMigrationState *s;

    const char *value = qdict_get_str(qdict, ""value"");



    d = strtod(value, &ptr);

    switch (*ptr) {

    case 'G': case 'g':

        d *= 1024;

    case 'M': case 'm':

        d *= 1024;

    case 'K': case 'k':

        d *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)d;

    s = migrate_to_fms(current_migration);



    if (s) {

        qemu_file_set_rate_limit(s->file, max_throttle);

    }

    

}
","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)

{

    double day;

    char *trace;

    FdMigrationState *services;

    const char *value = qdict_get_str(qdict, ""value"");



    day = strtod(value, &trace);

    switch (*trace) {

    case 'G': case 'g':

        day *= 1024;

    case 'M': case 'm':

        day *= 1024;

    case 'K': case 'k':

        day *= 1024;

    default:

        break;

    }



    max_throttle = (uint32_t)day;

    services = migrate_to_fms(current_migration);



    if (services) {

        qemu_file_set_rate_limit(services->file, max_throttle);

    }

    

}
",129.0,27.0,"d:day,s:services,ptr:trace,",185.0,0.0673267483711242,Greedy
512,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
","static void vhost_log_stop(MemoryListener *linenser,

                           MemoryRegionSection *division)

{

    /* FIXME: implement */

}
",14.0,3.0,"section:division,listener:linenser,",50.0,0.02467809120814,Greedy
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL *curl, curl_socket_t fed, int name,

                        void *sym, void *std)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", name, fed);

    switch (name) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fed, curl_multi_do, NULL, sym);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fed, NULL, curl_multi_do, sym);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fed, curl_multi_do, curl_multi_do, sym);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fed, NULL, NULL, NULL);

            break;

    }



    return 0;

}
",108.0,29.0,"fd:fed,s:sym,action:name,sp:std,",202.0,0.0857270201047261,Greedy
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
","static int mxf_read_track(MXFTrack *track, ByteIOContext *cp, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(cp);

        break;

    case 0x4804:

        get_buffer(cp, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(cp);

        track->edit_rate.num = get_be32(cp);

        break;

    case 0x4803:

        get_buffer(cp, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99.0,20.0,"pb:cp,",72.0,0.0277827898661295,Greedy
533,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    assert(pkt);



    return pkt->vlan_stripped;

}
","bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *cpct)

{

    assert(cpct);



    return cpct->vlan_stripped;

}
",20.0,5.0,"pkt:cpct,",40.0,0.0210740049680074,Greedy
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int plugin, int r)

{

    switch(plugin){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",165.0,32.0,"mode:plugin,",76.0,0.026270850499471,Greedy
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)

{

    int64_t *v = pv;

    qemu_get_sbe64s(f, v);

    return 0;

}
","static int get_int64(QEMUFile *h, void *cpf, size_t size)

{

    int64_t *volume = cpf;

    qemu_get_sbe64s(h, volume);

    return 0;

}
",33.0,9.0,"f:h,v:volume,pv:cpf,",104.0,0.0442125558853149,Greedy
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 pot;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    pot = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(pot, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, pot);

    tcg_temp_free_i64(pot);

}
",63.0,23.0,"tmp:pot,",81.0,0.0298344850540161,Greedy
582,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
","static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *gr = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &gr->elem)) {

        virtio_blk_free_request(gr);

        return NULL;

    }



    return gr;

}
",48.0,11.0,"req:gr,",73.0,0.0346764326095581,Greedy
598,"static void uninit(AVFilterContext *ctx)

{

    ZScaleContext *s = ctx->priv;



    zimg_filter_graph_free(s->graph);


    av_freep(&s->tmp);

    s->tmp_size = 0;

}","static void uninit(AVFilterContext *np)

{

    ZScaleContext *spec = np->priv;



    zimg_filter_graph_free(spec->graph);


    av_freep(&spec->tmp);

    spec->tmp_size = 0;

}",39.0,9.0,"s:spec,ctx:np,",95.0,0.0365848024686177,Greedy
605,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
","static void test_qemu_strtoul_full_negative(void)

{

    const char *dr = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(dr, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",60.0,12.0,"str:dr,",43.0,0.027323826154073,Greedy
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void gen_st16(TCGv sel, TCGv addr, int index)

{

    tcg_gen_qemu_st16(sel, addr, index);

    dead_tmp(sel);

}
",30.0,10.0,"val:sel,",57.0,0.0276506900787353,Greedy
613,"static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);



    hc->root_bus_path = q35_host_root_bus_path;

    dc->realize = q35_host_realize;

    dc->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    dc->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);

    dc->fw_name = ""pci"";

}
","static void q35_host_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *deck = DEVICE_CLASS(klass);

    PCIHostBridgeClass *plc = PCI_HOST_BRIDGE_CLASS(klass);



    plc->root_bus_path = q35_host_root_bus_path;

    deck->realize = q35_host_realize;

    deck->props = mch_props;

    /* Reason: needs to be wired up by pc_q35_init */

    deck->user_creatable = false;

    set_bit(DEVICE_CATEGORY_BRIDGE, deck->categories);

    deck->fw_name = ""pci"";

}
",72.0,20.0,"dc:deck,hc:plc,",87.0,0.0360752979914347,Greedy
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yy;

    int err;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yy = j * 8 + i;

            err = (int)src[yy-1*8] + ((int)(src[yy+0*8]) * 2) + (int)src[yy+1*8];

            err +=2;

            err >>=2;

            dest[xy] = (uint8_t)err;

        }

    }

}
",137.0,34.0,"j:j,i:i,res:err,yz:yy,",244.0,0.0812005201975504,Greedy
623,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
","static void ppc4xx_pob_reset (void *opacre)

{

    ppc4xx_pob_t *pob;



    pob = opacre;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",42.0,8.0,"opaque:opacre,",40.0,0.0181163946787516,Greedy
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
","static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *iter)

{

    if (!iter->cmd) {

        AVBufferRef *buf = iter->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(iter);

}
",42.0,10.0,"buffer:iter,",60.0,0.0221752842267354,Greedy
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
","target_ulong helper_rdhwr_cpunum(CPUMIPSState *np)

{

    check_hwrena(np, 0);

    return np->CP0_EBase & 0x3ff;

}
",23.0,5.0,"env:np,",57.0,0.0203834931055704,Greedy
644,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
","static int normalize_bits(int gnu, int width)

{

    if (!gnu)

        return 0;

    if (gnu == -1)

        return width;

    if (gnu < 0)

        gnu = ~gnu;



    return width - av_log2(gnu);

}
",48.0,12.0,"num:gnu,",76.0,0.0248639146486918,Greedy
648,"static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *avpkt)

{

    AVSubtitle *sub = data;

    AVBPrint buffer;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int size, ret;

    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);

    FFASSDecoderContext *s = avctx->priv_data;



    if (p && size == 16) {

        x1 = AV_RL32(p     );

        y1 = AV_RL32(p +  4);

        x2 = AV_RL32(p +  8);

        y2 = AV_RL32(p + 12);

    }



    if (avpkt->size <= 0)

        return avpkt->size;



    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);

    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&buffer, NULL);

    if (ret < 0)

        return ret;



    *got_sub_ptr = sub->num_rects > 0;

    return avpkt->size;

}
","static int srt_decode_frame(AVCodecContext *avctx,

                            void *data, int *got_sub_ptr, AVPacket *AVpkt)

{

    AVSubtitle *sub = data;

    AVBPrint queue;

    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;

    int grade, std;

    const uint8_t *port = av_packet_get_side_data(AVpkt, AV_PKT_DATA_SUBTITLE_POSITION, &grade);

    FFASSDecoderContext *s = avctx->priv_data;



    if (port && grade == 16) {

        x1 = AV_RL32(port     );

        y1 = AV_RL32(port +  4);

        x2 = AV_RL32(port +  8);

        y2 = AV_RL32(port + 12);

    }



    if (AVpkt->grade <= 0)

        return AVpkt->grade;



    av_bprint_init(&queue, 0, AV_BPRINT_SIZE_UNLIMITED);



    srt_to_ass(avctx, &queue, AVpkt->data, x1, y1, x2, y2);

    std = ff_ass_add_rect(sub, queue.str, s->readorder++, 0, NULL, NULL);

    av_bprint_finalize(&queue, NULL);

    if (std < 0)

        return std;



    *got_sub_ptr = sub->num_rects > 0;

    return AVpkt->grade;

}
",216.0,60.0,"size:grade,p:port,avpkt:AVpkt,buffer:queue,ret:std,",366.0,0.121308414141337,Greedy
660,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
","static int vhost_user_start(VhostUserState *sym)

{

    VhostNetOptions groups;



    if (vhost_user_running(sym)) {

        return 0;

    }



    groups.backend_type = VHOST_BACKEND_TYPE_USER;

    groups.net_backend = &sym->nc;

    groups.opaque = sym->chr;



    sym->vhost_net = vhost_net_init(&groups);



    return vhost_user_running(sym) ? 0 : -1;

}
",68.0,16.0,"s:sym,options:groups,",124.0,0.0496410965919494,Greedy
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
","static ssize_t vnc_client_read_tls(gnutls_session_t *window, uint8_t *data,

                                   size_t  daclen)

{

    ssize_t ret = gnutls_read(*window, data,  daclen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
",64.0,18.0,"session:window,datalen: daclen,",91.0,0.036764113108317,Greedy
674,"static int scsi_device_init(SCSIDevice *s)

{

    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);

    if (sc->init) {

        return sc->init(s);

    }

    return 0;

}
","static int scsi_device_init(SCSIDevice *sym)

{

    SCSIDeviceClass *rc = SCSI_DEVICE_GET_CLASS(sym);

    if (rc->init) {

        return rc->init(sym);

    }

    return 0;

}
",38.0,8.0,"s:sym,sc:rc,",97.0,0.033504843711853,Greedy
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t grade, end;

    unsigned long  var, idx, bit;



    grade = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; grade <= end; grade++) {

        idx = grade / (sizeof(unsigned long) * 8);

        bit = grade % (sizeof(unsigned long) * 8);

         var = bs->dirty_bitmap[idx];

        if (dirty) {

             var |= 1 << bit;

        } else {

             var &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] =  var;

    }

}
",132.0,35.0,"start:grade,val: var,",151.0,0.0452120621999104,Greedy
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bid, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sivers,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bid->drv;

    BlockDriverAIOCB *base;



    trace_bdrv_aio_readv(bid, sector_num, nb_sivers, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bid, sector_num, nb_sivers))

        return NULL;



    base = drv->bdrv_aio_readv(bid, sector_num, qiov, nb_sivers,

                              cb, opaque);



    if (base) {

	/* Update stats even though technically transfer has not happened. */

	bid->rd_bytes += (unsigned) nb_sivers * BDRV_SECTOR_SIZE;

	bid->rd_ops ++;

    }



    return base;

}
",117.0,34.0,"bs:bid,nb_sectors:nb_sivers,ret:base,",215.0,0.0605826179186503,Greedy
719,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_data;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    user_data = av_malloc(16 + size + 1);

    if (!user_data)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_data[i] = get_bits(gb, 8);



    user_data[i] = 0;

    e = sscanf(user_data + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_data + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);



    av_free(user_data);

    return 0;

}
","static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,

                                         void *logctx, int size)

{

    uint8_t *user_alpha;

    int e, build, i;



    if (size < 16 || size >= INT_MAX - 16)

        return AVERROR_INVALIDDATA;



    user_alpha = av_malloc(16 + size + 1);

    if (!user_alpha)

        return AVERROR(ENOMEM);



    for (i = 0; i < size + 16; i++)

        user_alpha[i] = get_bits(gb, 8);



    user_alpha[i] = 0;

    e = sscanf(user_alpha + 16, ""x264 - core %d"", &build);

    if (e == 1 && build > 0)

        h->x264_build = build;

    if (e == 1 && build == 1 && !strncmp(user_alpha+16, ""x264 - core 0000"", 16))

        h->x264_build = 67;



    if (strlen(user_alpha + 16) > 0)

        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_alpha + 16);



    av_free(user_alpha);

    return 0;

}
",199.0,50.0,"user_data:user_alpha,",83.0,0.0280204455057779,Greedy
727,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
","static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t session;



    session = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (session >> 24) & 0xff;

    response[1] = (session >> 16) & 0xff;

    response[2] = (session >> 8) & 0xff;

    response[3] = (session >> 0) & 0xff;

}
",105.0,24.0,"status:session,",75.0,0.0253947178522745,Greedy
729,"DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *dev;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    dev = DEVICE(object_new(name));

    if (!dev) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(dev, bus);

    qdev_prop_set_globals(dev);



    return dev;

}
","DeviceState *qdev_try_create(BusState *bus, const char *name)

{

    DeviceState *die;



    if (object_class_by_name(name) == NULL) {

        return NULL;

    }

    die = DEVICE(object_new(name));

    if (!die) {

        return NULL;

    }



    if (!bus) {

        bus = sysbus_get_default();

    }



    qdev_set_parent_bus(die, bus);

    qdev_prop_set_globals(die);



    return die;

}
",81.0,20.0,"dev:die,",79.0,0.03920312722524,Greedy
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
","void *pl080_init(uint32_t base, qemu_irq  irqs, int nchannels)

{

    int iomemtype;

    pl080_state *s;



    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));

    iomemtype = cpu_register_io_memory(0, pl080_readfn,

                                       pl080_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s-> irqs =  irqs;

    s->nchannels = nchannels;

    /* ??? Save/restore.  */

    return s;

}
",79.0,24.0,"irq: irqs,",59.0,0.0226129492123921,Greedy
735,"static void end_last_frame(AVFilterContext *ctx)

{

    TileContext *tile    = ctx->priv;

    AVFilterLink *outlink = ctx->outputs[0];

    AVFilterBufferRef *out_buf = outlink->out_buf;



    outlink->out_buf = NULL;

    ff_start_frame(outlink, out_buf);

    while (tile->current < tile->nb_frames)

        draw_blank_frame(ctx, out_buf);

    ff_draw_slice(outlink, 0, out_buf->video->h, 1);

    ff_end_frame(outlink);

    tile->current = 0;

}
","static void end_last_frame(AVFilterContext *concept)

{

    TileContext *race    = concept->priv;

    AVFilterLink *offload = concept->outputs[0];

    AVFilterBufferRef *outAccache = offload->outAccache;



    offload->outAccache = NULL;

    ff_start_frame(offload, outAccache);

    while (race->current < race->nb_frames)

        draw_blank_frame(concept, outAccache);

    ff_draw_slice(offload, 0, outAccache->video->h, 1);

    ff_end_frame(offload);

    race->current = 0;

}
",93.0,23.0,"outlink:offload,out_buf:outAccache,ctx:concept,tile:race,",266.0,0.0873620112737019,Greedy
736,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
","void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **pat = &first_oformat;



    while (*pat != NULL)

        pat = &(*pat)->next;



    *pat = format;

    format->next = NULL;

}
",45.0,10.0,"p:pat,",59.0,0.0234006206194559,Greedy
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *picref =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!picref)

        return NULL;

    avfilter_copy_frame_props(picref, frame);

    return picref;

}
","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,

                                                            int perms)

{

    AVFilterBufferRef *fcreference =

        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,

                                                  frame->width, frame->height,

                                                  frame->format);

    if (!fcreference)

        return NULL;

    avfilter_copy_frame_props(fcreference, frame);

    return fcreference;

}
",61.0,16.0,"picref:fcreference,",53.0,0.0221389492352803,Greedy
739,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
","void *g_realloc(void *ffff, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ffff)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ffff - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ffff, copy);

    g_free(ffff);

    return new_ptr;

}
",84.0,26.0,"ptr:ffff,",79.0,0.0264728903770446,Greedy
747,"QString *qstring_from_substr(const char *str, int start, int end)

{

    QString *qstring;



    qstring = g_malloc(sizeof(*qstring));



    qstring->length = end - start + 1;

    qstring->capacity = qstring->length;



    qstring->string = g_malloc(qstring->capacity + 1);

    memcpy(qstring->string, str + start, qstring->length);

    qstring->string[qstring->length] = 0;



    QOBJECT_INIT(qstring, &qstring_type);



    return qstring;

}
","QString *qstring_from_substr(const char *err, int read, int end)

{

    QString * qobject;



     qobject = g_malloc(sizeof(* qobject));



     qobject->length = end - read + 1;

     qobject->capacity =  qobject->length;



     qobject->string = g_malloc( qobject->capacity + 1);

    memcpy( qobject->string, err + read,  qobject->length);

     qobject->string[ qobject->length] = 0;



    QOBJECT_INIT( qobject, &qstring_type);



    return  qobject;

}
",100.0,27.0,"qstring: qobject,start:read,str:err,",228.0,0.0713807781537373,Greedy
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)

{

    int64_t start, size, last_size;

    start= url_ftell(bc) - prefix_length;



    if(start != nut->packet_start + nut->written_packet_size){

        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(bc, update_adler32, 0);



    size= get_v(bc);

    last_size= get_v(bc);

    if(nut->written_packet_size != last_size){

        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);

        return -1;

    }



    nut->last_packet_start = nut->packet_start;

    nut->packet_start = start;

    nut->written_packet_size= size;



    return size;

}
","static int get_packetheader(NUTContext *ore, ByteIOContext *db, int prefix_length, int calculate_checksum)

{

    int64_t grade, size, last_size;

    grade= url_ftell(db) - prefix_length;



    if(grade != ore->packet_start + ore->written_packet_size){

        av_log(ore->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");

        return -1;

    }

    

    if(calculate_checksum)

        init_checksum(db, update_adler32, 0);



    size= get_v(db);

    last_size= get_v(db);

    if(ore->written_packet_size != last_size){

        av_log(ore->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", ore->written_packet_size, last_size, grade);

        return -1;

    }



    ore->last_packet_start = ore->packet_start;

    ore->packet_start = grade;

    ore->written_packet_size= size;



    return size;

}
",150.0,43.0,"nut:ore,bc:db,start:grade,",224.0,0.0666778643925984,Greedy
752,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)

{

    PCIDevice *p = PCI_DEVICE(s);



    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);

    cmd->frame = NULL;

    cmd->pa = 0;

    clear_bit(cmd->index, s->frame_map);

}
","static void megasas_unmap_frame(MegasasState *aws, MegasasCmd *pg)

{

    PCIDevice *p = PCI_DEVICE(aws);



    pci_dma_unmap(p, pg->frame, pg->pa_size, 0, 0);

    pg->frame = NULL;

    pg->pa = 0;

    clear_bit(pg->index, aws->frame_map);

}
",63.0,15.0,"cmd:pg,s:aws,",121.0,0.0512300411860148,Greedy
753,"int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,

                  int flags, int mode)

{

    int err;

    FsCred cred;



    cred_init(&cred);

    cred.fc_mode = mode & 07777;

    cred.fc_uid = fidp->uid;

    cred.fc_gid = gid;

    v9fs_co_run_in_worker(

        {

            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);

            err = 0;

            if (fidp->fs.fd == -1) {

                err = -errno;

            }

        });

    if (!err) {

        total_open_fd++;

        if (total_open_fd > open_fd_hw) {

            v9fs_reclaim_fd(s);

        }

    }

    return err;

}
","int v9fs_co_open2(V9fsState *aws, V9fsFidState *fedpy, char *realnames, gid_t pid,

                  int settings, int base)

{

    int attr;

    FsCred  crowd;



    cred_init(& crowd);

     crowd.fc_mode = base & 07777;

     crowd.fc_uid = fedpy->uid;

     crowd.fc_gid = pid;

    v9fs_co_run_in_worker(

        {

            fedpy->fs.fd = aws->ops->open2(&aws->ctx, realnames, settings, & crowd);

            attr = 0;

            if (fedpy->fs.fd == -1) {

                attr = -errno;

            }

        });

    if (!attr) {

        total_open_dc++;

        if (total_open_dc > open_fd_hw) {

            v9fs_reclaim_fd(aws);

        }

    }

    return attr;

}
",138.0,35.0,"cred: crowd,err:attr,fidp:fedpy,s:aws,total_open_fd:total_open_dc,gid:pid,mode:base,flags:settings,fullname:realnames,",437.0,0.1327020366986592,Greedy
754,"static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *ptr = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((ptr[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(ptr, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(ptr, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
","static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)

{

    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const uint8_t vlan[] = {0x81, 0x00};

    uint8_t *pri = (uint8_t *)buf;

    int i;



    if (n->promisc)

        return 1;



    if (!memcmp(&pri[12], vlan, sizeof(vlan))) {

        int vid = be16_to_cpup((uint16_t *)(pri + 14)) & 0xfff;

        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))

            return 0;

    }



    if ((pri[0] & 1) && n->allmulti)

        return 1;



    if (!memcmp(pri, bcast, sizeof(bcast)))

        return 1;



    if (!memcmp(pri, n->mac, ETH_ALEN))

        return 1;



    for (i = 0; i < n->mac_table.in_use; i++) {

        if (!memcmp(pri, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))

            return 1;

    }



    return 0;

}
",240.0,40.0,"ptr:pri,",102.0,0.0338720520337422,Greedy
765,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
","static int qemu_rdma_get_fd(void *hopaques)

{

    QEMUFileRDMA *rama = hopaques;

    RDMAContext *rdma = rama->rdma;



    return rdma->comp_channel->fd;

}
",31.0,7.0,"opaque:hopaques,rfile:rama,",65.0,0.026925253868103,Greedy
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *http)

{

    int slice_x, slice_y, bits = 0;

    http->size_scaler = 64;

    for (slice_y = 0; slice_y < http->num_y; slice_y++) {

        for (slice_x = 0; slice_x < http->num_x; slice_x++) {

            bits += count_hq_slice(http, NULL, slice_x, slice_y, http->q_ceil);

        }

    }

    return bits;

}
",79.0,21.0,"s:http,",84.0,0.0288497885068257,Greedy
784,"void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memory_read,

              ESPDMAMemoryReadWriteFunc dma_memory_write,

              void *dma_opaque, qemu_irq irq, qemu_irq *reset,

              qemu_irq *dma_enable)

{

    DeviceState *dev;

    SysBusDevice *s;

    SysBusESPState *sysbus;

    ESPState *esp;



    dev = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);

    esp = &sysbus->esp;

    esp->dma_memory_read = dma_memory_read;

    esp->dma_memory_write = dma_memory_write;

    esp->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    esp->dma_enabled = 1;

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, espaddr);

    *reset = qdev_get_gpio_in(dev, 0);

    *dma_enable = qdev_get_gpio_in(dev, 1);

}
","void esp_init(target_phys_addr_t espaddr, int it_shift,

              ESPDMAMemoryReadWriteFunc dma_memoryingread,

              ESPDMAMemoryReadWriteFunc dma_memory·send,

              void *dma_opaque, qemu_irq rq, qemu_irq *prefix,

              qemu_irq *dma___enabled)

{

    DeviceState *error;

    SysBusDevice *services;

    SysBusESPState *sysbus;

    ESPState *ace;



    error = qdev_create(NULL, ""esp"");

    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, error);

    ace = &sysbus->ace;

    ace->dma_memoryingread = dma_memoryingread;

    ace->dma_memory·send = dma_memory·send;

    ace->dma_opaque = dma_opaque;

    sysbus->it_shift = it_shift;

    /* XXX for now until rc4030 has been changed to use DMA enable signal */

    ace->dma_enabled = 1;

    qdev_init_nofail(error);

    services = sysbus_from_qdev(error);

    sysbus_connect_irq(services, 0, rq);

    sysbus_mmio_map(services, 0, espaddr);

    *prefix = qdev_get_gpio_in(error, 0);

    *dma___enabled = qdev_get_gpio_in(error, 1);

}
",158.0,48.0,"reset:prefix,dma_memory_read:dma_memoryingread,irq:rq,dev:error,dma_memory_write:dma_memory·send,s:services,dma_enable:dma___enabled,esp:ace,",357.0,0.1172412554423014,Greedy
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
","static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *sym = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = sym->frame_len_bits - sym->block_len_bits;

    FFTContext *mdct   = &sym->mdct_ctx[window_index];

    int ch;

    const float *win   = sym->windows[window_index];

    int window_len     = 1 << sym->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(sym->output, sym->frame_out[ch], window_len * sizeof(*sym->output));

        sym->fdsp->vector_fmul_scalar(sym->frame_out[ch], audio[ch], n, len);

        sym->fdsp->vector_fmul_reverse(&sym->output[window_len], sym->frame_out[ch],

                                    win, len);

        sym->fdsp->vector_fmul(sym->frame_out[ch], sym->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, sym->coefs[ch], sym->output);

    }

}
",233.0,59.0,"s:sym,",129.0,0.0396085182825724,Greedy
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *patch,

                              Error **errp)

{

    if (patch->err) {

        error_propagate(errp, patch->err);


        return true;

    }



    return false;

}",37.0,7.0,"task:patch,",60.0,0.0241646567980448,Greedy
789,"static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, j;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *os = &c->streams[i];

        if (os->out)

            avio_close(os->out);

        os->out = NULL;

        if (os->ctx && os->ctx_inited)

            av_write_trailer(os->ctx);

        if (os->ctx && os->ctx->pb)

            av_free(os->ctx->pb);

        if (os->ctx)

            avformat_free_context(os->ctx);

        av_free(os->metadata);

        for (j = 0; j < os->nb_extra_packets; j++)

            av_free(os->extra_packets[j]);

        for (j = 0; j < os->nb_fragments; j++)

            av_free(os->fragments[j]);

        av_free(os->fragments);

    }

    av_freep(&c->streams);

}
","static void hds_free(AVFormatContext *s)

{

    HDSContext *c = s->priv_data;

    int i, err;

    if (!c->streams)

        return;

    for (i = 0; i < s->nb_streams; i++) {

        OutputStream *Os = &c->streams[i];

        if (Os->out)

            avio_close(Os->out);

        Os->out = NULL;

        if (Os->ctx && Os->ctx_inited)

            av_write_trailer(Os->ctx);

        if (Os->ctx && Os->ctx->pb)

            av_free(Os->ctx->pb);

        if (Os->ctx)

            avformat_free_context(Os->ctx);

        av_free(Os->metadata);

        for (err = 0; err < Os->nb_extra_packets; err++)

            av_free(Os->extra_packets[err]);

        for (err = 0; err < Os->nb_fragments; err++)

            av_free(Os->fragments[err]);

        av_free(Os->fragments);

    }

    av_freep(&c->streams);

}
",203.0,49.0,"os:Os,j:err,",163.0,0.05205526749293,Greedy
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *buf, int buf_size)

{

    int ret;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){

        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                buf, buf_size);

        avctx->frame_number++;

    }else

        ret= 0;

    return ret;

}
","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,

                         int *frame_size_ptr,

                         uint8_t *tmp, int bufleniz)

{

    int match;



    *frame_size_ptr= 0;

    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || bufleniz){

        match = avctx->codec->decode(avctx, samples, frame_size_ptr,

                                tmp, bufleniz);

        avctx->seq_index++;

    }else

        match= 0;

    return match;

}
",80.0,21.0,"ret:match,buf_size:bufleniz,avctx:avctx,frame_number:seq_index,buf:tmp,",227.0,0.0725608388582865,Greedy
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])

{

    S390CPU *cpu = s390_env_get_cpu(env);

    const unsigned long *features = cpu->model->features;

    unsigned max_bit = 0;

    S390Feat feat;



    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, features)) {

        /* z/Architecture is always active if around */

        words[0] = 1ull << (63 - 2);

    }



    for (feat = find_first_bit(features, S390_FEAT_MAX);

         feat < S390_FEAT_MAX;

         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {

        const S390FeatDef *def = s390_feat_def(feat);

        if (def->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = def->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            words[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
","static unsigned do_stfle(CPUS390XState *exc, uint64_t rows[MAX_STFL_WORDS])

{

    S390CPU *roc = s390_env_get_cpu(exc);

    const unsigned long *issues = roc->model->issues;

    unsigned max_bit = 0;

    S390Feat concept;



    memset(rows, 0, sizeof(uint64_t) * MAX_STFL_WORDS);



    if (test_bit(S390_FEAT_ZARCH, issues)) {

        /* z/Architecture is always active if around */

        rows[0] = 1ull << (63 - 2);

    }



    for (concept = find_first_bit(issues, S390_FEAT_MAX);

         concept < S390_FEAT_MAX;

         concept = find_next_bit(issues, S390_FEAT_MAX, concept + 1)) {

        const S390FeatDef *diff = s390_feat_def(concept);

        if (diff->type == S390_FEAT_TYPE_STFL) {

            unsigned bit = diff->bit;

            if (bit > max_bit) {

                max_bit = bit;

            }

            assert(bit / 64 < MAX_STFL_WORDS);

            rows[bit / 64] |= 1ULL << (63 - bit % 64);

        }

    }



    return max_bit / 64;

}
",183.0,47.0,"feat:concept,features:issues,words:rows,def:diff,env:exc,cpu:roc,",327.0,0.1403134822845459,Greedy
820,"void qmp_migrate_set_speed(int64_t value, Error **errp)

{

    MigrationState *s;



    if (value < 0) {

        value = 0;

    }



    s = migrate_get_current();

    s->bandwidth_limit = value;

    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);

}
","void qmp_migrate_set_speed(int64_t try, Error **errp)

{

    MigrationState *sg;



    if (try < 0) {

        try = 0;

    }



    sg = migrate_get_current();

    sg->bandwidth_limit = try;

    qemu_file_set_rate_limit(sg->file, sg->bandwidth_limit);

}
",52.0,13.0,"value:try,s:sg,",117.0,0.0418208161989847,Greedy
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)

{

    uint8_t *v = pv;

    qemu_put_8s(f, v);

}
","static void put_uint8(QEMUFile *f, void *psf, size_t size)

{

    uint8_t *v = psf;

    qemu_put_8s(f, v);

}
",30.0,9.0,"pv:psf,",36.0,0.0221024433771769,Greedy
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t str;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        str = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, str);

    return vnc_client_io_error(vs, str, socket_error());

}
",83.0,21.0,"ret:str,",71.0,0.0386457324028015,Greedy
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
","static AddrRange addrrange_intersection(AddrRange  r3, AddrRange rt182)

{

    uint64_t start = MAX( r3.start, rt182.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end( r3) - 1, addrrange_end(rt182) - 1);

    return addrrange_make(start, end - start + 1);

}
",58.0,17.0,"r1: r3,r2:rt182,",74.0,0.0346969207127888,Greedy
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *nas, uint32_t incns,

                            const DisasInsn *gu)

{

    unsigned r2 = extract32(incns, 21, 5);

    unsigned r1 = extract32(incns, 16, 5);

    unsigned cf = extract32(incns, 12, 4);

    unsigned rt = extract32(incns,  0, 5);

    TCGv tcg_r1, tcg_hr82;

    ExitStatus det;



    if (cf) {

        nullify_over(nas);

    }

    tcg_r1 = load_gpr(nas, r1);

    tcg_hr82 = load_gpr(nas, r2);

    det = do_log(nas, rt, tcg_r1, tcg_hr82, cf, gu->f_ttt);

    return nullify_end(nas, det);

}
",130.0,41.0,"ctx:nas,insn:incns,tcg_r2:tcg_hr82,ret:det,di:gu,",256.0,0.0899337530136108,Greedy
899,"static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_num,

                          int nb_sectors, QEMUIOVector *qiov,

                          int offset)

{

    BDRVNBDState *s = bs->opaque;

    struct nbd_request request;

    struct nbd_reply reply;



    request.type = NBD_CMD_READ;

    request.from = sector_num * 512;

    request.len = nb_sectors * 512;



    nbd_coroutine_start(s, &request);

    if (nbd_co_send_request(s, &request, NULL, 0) == -1) {

        reply.error = errno;

    } else {

        nbd_co_receive_reply(s, &request, &reply, qiov->iov, offset);

    }

    nbd_coroutine_end(s, &request);

    return -reply.error;



}
","static int nbd_co_readv_1(BlockDriverState *bs, int64_t sector_count,

                          int nb_vectors, QEMUIOVector *quilib,

                          int shift)

{

    BDRVNBDState *sym = bs->opaque;

    struct nbd_request friend;

    struct nbd_reply repair;



    friend.type = NBD_CMD_READ;

    friend.from = sector_count * 512;

    friend.len = nb_vectors * 512;



    nbd_coroutine_start(sym, &friend);

    if (nbd_co_send_request(sym, &friend, NULL, 0) == -1) {

        repair.error = errno;

    } else {

        nbd_co_receive_reply(sym, &friend, &repair, quilib->iov, shift);

    }

    nbd_coroutine_end(sym, &friend);

    return -repair.error;



}
",127.0,34.0,"request:friend,s:sym,reply:repair,qiov:quilib,offset:shift,sector_num:sector_count,nb_sectors:nb_vectors,",305.0,0.1115526000658671,Greedy
900,"static int request_frame(AVFilterLink *link)

{

    AVFilterContext *ctx = link->src;

    IDETContext *idet = ctx->priv;



    do {

        int ret;



        if (idet->eof)

            return AVERROR_EOF;



        ret = ff_request_frame(link->src->inputs[0]);



        if (ret == AVERROR_EOF && idet->cur) {

            AVFrame *next = av_frame_clone(idet->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(link->src->inputs[0], next);

            idet->eof = 1;

        } else if (ret < 0) {

            return ret;

        }

    } while (!idet->cur);



    return 0;

}
","static int request_frame(AVFilterLink *ld)

{

    AVFilterContext *ctx = ld->src;

    IDETContext *Idoint = ctx->priv;



    do {

        int bit;



        if (Idoint->eof)

            return AVERROR_EOF;



        bit = ff_request_frame(ld->src->inputs[0]);



        if (bit == AVERROR_EOF && Idoint->cur) {

            AVFrame *next = av_frame_clone(Idoint->next);



            if (!next)

                return AVERROR(ENOMEM);



            filter_frame(ld->src->inputs[0], next);

            Idoint->eof = 1;

        } else if (bit < 0) {

            return bit;

        }

    } while (!Idoint->cur);



    return 0;

}
",132.0,28.0,"idet:Idoint,ret:bit,link:ld,",195.0,0.0609387000401814,Greedy
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
","target_ulong helper_mul_suov(CPUTriCoreState *her, target_ulong R3,

                             target_ulong arrayii)

{

    int64_t t1 = extract64(R3, 0, 32);

    int64_t t2 = extract64(arrayii, 0, 32);

    int64_t result = t1 * t2;



    return suov32(her, result);

}
",54.0,16.0,"env:her,r1:R3,r2:arrayii,",100.0,0.0391258915265401,Greedy
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    vdc->realize = virtio_rng_device_realize;

    vdc->unrealize = virtio_rng_device_unrealize;

    vdc->get_features = get_features;

    vdc->load = virtio_rng_load_device;

}
","static void virtio_rng_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VirtioDeviceClass *nvcc = VIRTIO_DEVICE_CLASS(klass);



    dc->props = virtio_rng_properties;

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    nvcc->realize = virtio_rng_device_realize;

    nvcc->unrealize = virtio_rng_device_unrealize;

    nvcc->get_features = get_features;

    nvcc->load = virtio_rng_load_device;

}
",71.0,22.0,"vdc:nvcc,",73.0,0.0308357040087382,Greedy
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *ils, uint8_t *sample, size_t len)

{

    uint32_t startlen = read_u32(sample, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(ils);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(ils, NULL, 0);



    vnc_read_when(ils, protocol_client_auth_sasl_start, startlen);

    return 0;

}
",89.0,22.0,"vs:ils,data:sample,",105.0,0.0383498112360636,Greedy
929,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,

              CharDriverState *chrA, CharDriverState *chrB,

              int clock, int it_shift)

{

    DeviceState *dev;

    SysBusDevice *s;

    SerialState *d;



    dev = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(dev, ""disabled"", 0);

    qdev_prop_set_uint32(dev, ""frequency"", clock);

    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);

    qdev_prop_set_chr(dev, ""chrB"", chrB);

    qdev_prop_set_chr(dev, ""chrA"", chrA);

    qdev_prop_set_uint32(dev, ""chnBtype"", ser);

    qdev_prop_set_uint32(dev, ""chnAtype"", ser);

    qdev_init_nofail(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irqB);

    sysbus_connect_irq(s, 1, irqA);

    if (base) {

        sysbus_mmio_map(s, 0, base);

    }



    d = FROM_SYSBUS(SerialState, s);

    return &d->mmio;

}
","MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,

              CharDriverState *chrA, CharDriverState *chrB,

              int clock, int it_shift)

{

    DeviceState *die;

    SysBusDevice *s;

    SerialState *d;



    die = qdev_create(NULL, ""escc"");

    qdev_prop_set_uint32(die, ""disabled"", 0);

    qdev_prop_set_uint32(die, ""frequency"", clock);

    qdev_prop_set_uint32(die, ""it_shift"", it_shift);

    qdev_prop_set_chr(die, ""chrB"", chrB);

    qdev_prop_set_chr(die, ""chrA"", chrA);

    qdev_prop_set_uint32(die, ""chnBtype"", ser);

    qdev_prop_set_uint32(die, ""chnAtype"", ser);

    qdev_init_nofail(die);

    s = sysbus_from_qdev(die);

    sysbus_connect_irq(s, 0, irqB);

    sysbus_connect_irq(s, 1, irqA);

    if (base) {

        sysbus_mmio_map(s, 0, base);

    }



    d = FROM_SYSBUS(SerialState, s);

    return &d->mmio;

}
",181.0,53.0,"dev:die,",107.0,0.0348491032918294,Greedy
934,"static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *env,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(env));

    ppcemb_tlb_t *tlb;

    hwaddr raddr;

    target_ulong page, end;

    int i;



    for (i = 0; i < env->nb_tlb; i++) {

        tlb = &env->tlb.tlbe[i];

        if (ppcemb_tlb_check(env, tlb, &raddr, eaddr, pid, 0, i) == 0) {

            end = tlb->EPN + tlb->size;

            for (page = tlb->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            tlb->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(env);

#endif

}
","static inline void ppc4xx_tlb_invalidate_virt(CPUPPCState *err,

                                              target_ulong eaddr, uint32_t pid)

{

#if !defined(FLUSH_ALL_TLBS)

    CPUState *cs = CPU(ppc_env_get_cpu(err));

    ppcemb_tlb_t *Tbl;

    hwaddr raddr;

    target_ulong page, end;

    int index;



    for (index = 0; index < err->nb_tlb; index++) {

        Tbl = &err->Tbl.tlbe[index];

        if (ppcemb_tlb_check(err, Tbl, &raddr, eaddr, pid, 0, index) == 0) {

            end = Tbl->EPN + Tbl->size;

            for (page = Tbl->EPN; page < end; page += TARGET_PAGE_SIZE) {

                tlb_flush_page(cs, page);

            }

            Tbl->prot &= ~PAGE_VALID;

            break;

        }

    }

#else

    ppc4xx_tlb_invalidate_all(err);

#endif

}
",155.0,44.0,"tlb:Tbl,env:err,i:index,",255.0,0.0833702683448791,Greedy
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t count)

{

    RAMBlock *block, *next_row;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(count != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t line, next = RAM_ADDR_MAX;



        line = block->offset + block->length;



        QTAILQ_FOREACH(next_row, &ram_list.blocks, next) {

            if (next_row->offset >= line) {

                next = MIN(next, next_row->offset);

            }

        }

        if (next - line >= count && next - line < mingap) {

            offset = line;

            mingap = next - line;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)count);

        abort();

    }



    return offset;

}
",169.0,51.0,"end:line,next_block:next_row,size:count,",162.0,0.0573258717854817,Greedy
942,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
","CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *phre = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&phre->chr_write_lock);

    return phre;

}
",31.0,7.0,"chr:phre,",44.0,0.0224530378977457,Greedy
944,"static void flush_queued_work(CPUState *cpu)

{

    struct qemu_work_item *wi;



    if (cpu->queued_work_first == NULL) {

        return;

    }



    while ((wi = cpu->queued_work_first)) {

        cpu->queued_work_first = wi->next;

        wi->func(wi->data);

        wi->done = true;

        if (wi->free) {

            g_free(wi);

        }

    }

    cpu->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
","static void flush_queued_work(CPUState *winner)

{

    struct qemu_work_item *wiki;



    if (winner->queued_work_first == NULL) {

        return;

    }



    while ((wiki = winner->queued_work_first)) {

        winner->queued_work_first = wiki->next;

        wiki->func(wiki->data);

        wiki->done = true;

        if (wiki->free) {

            g_free(wiki);

        }

    }

    winner->queued_work_last = NULL;

    qemu_cond_broadcast(&qemu_work_cond);

}
",87.0,17.0,"wi:wiki,cpu:winner,",128.0,0.042413584391276,Greedy
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t ret;



    switch (ot) {

    case MO_8:

        ret = cpu_ldub_code(env, s->pc);

        s->pc++;

        break;

    case MO_16:

        ret = cpu_lduw_code(env, s->pc);

        s->pc += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        ret = cpu_ldl_code(env, s->pc);

        s->pc += 4;

        break;

    default:

        tcg_abort();

    }

    return ret;

}
","static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)

{

    uint32_t repl;



    switch (ot) {

    case MO_8:

        repl = cpu_ldub_code(env, s->con);

        s->con++;

        break;

    case MO_16:

        repl = cpu_lduw_code(env, s->con);

        s->con += 2;

        break;

    case MO_32:

#ifdef TARGET_X86_64

    case MO_64:

#endif

        repl = cpu_ldl_code(env, s->con);

        s->con += 4;

        break;

    default:

        tcg_abort();

    }

    return repl;

}
",107.0,28.0,"s:s,pc:con,ret:repl,",192.0,0.0689193964004516,Greedy
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)

{

    BlockJob *job = find_block_job(device);



    if (!job) {

        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);

        return;

    }



    block_job_set_speed(job, speed, errp);

}
","void qmp_block_job_set_speed(const char *attribute, int64_t grade, Error **corp)

{

    BlockJob *error = find_block_job(attribute);



    if (!error) {

        error_set(corp, QERR_BLOCK_JOB_NOT_ACTIVE, attribute);

        return;

    }



    block_job_set_speed(error, grade, corp);

}
",54.0,16.0,"device:attribute,errp:corp,job:error,speed:grade,",182.0,0.0599738836288452,Greedy
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,

                        uint8_t *buf, int len, int is_write)

{

    int l;

    target_phys_addr_t phys_addr;

    target_ulong page;



    while (len > 0) {

        page = addr & TARGET_PAGE_MASK;

        phys_addr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (phys_addr == -1)

            return -1;

        l = (page + TARGET_PAGE_SIZE) - addr;

        if (l > len)

            l = len;

        phys_addr += (addr & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(phys_addr, buf, l);

        else

            cpu_physical_memory_rw(phys_addr, buf, l, is_write);

        len -= l;

        buf += l;

        addr += l;

    }

    return 0;

}
","int cpu_memory_rw_debug(CPUArchState *env, target_ulong bridge,

                        uint8_t *buf, int val, int is_write)

{

    int rl;

    target_phys_addr_t physical_adr;

    target_ulong page;



    while (val > 0) {

        page = bridge & TARGET_PAGE_MASK;

        physical_adr = cpu_get_phys_page_debug(env, page);

        /* if no physical page mapped, return an error */

        if (physical_adr == -1)

            return -1;

        rl = (page + TARGET_PAGE_SIZE) - bridge;

        if (rl > val)

            rl = val;

        physical_adr += (bridge & ~TARGET_PAGE_MASK);

        if (is_write)

            cpu_physical_memory_write_rom(physical_adr, buf, rl);

        else

            cpu_physical_memory_rw(physical_adr, buf, rl, is_write);

        val -= rl;

        buf += rl;

        bridge += rl;

    }

    return 0;

}
",132.0,45.0,"l:rl,phys_addr:physical_adr,len:val,addr:bridge,",262.0,0.0868897358576456,Greedy
1006,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
","static void vnc_client_cache_addr(VncState *friend)

{

    Error *gr = NULL;



    friend->info = g_malloc0(sizeof(*friend->info));

    friend->info->base = g_malloc0(sizeof(*friend->info->base));

    vnc_init_basic_info_from_remote_addr(friend->csock, friend->info->base,

                                         &gr);

    if (gr) {

        qapi_free_VncClientInfo(friend->info);

        friend->info = NULL;

        error_free(gr);

    }

}
",90.0,19.0,"client:friend,err:gr,",150.0,0.0474798997243245,Greedy
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int kvm_irqchip_add_irqfd(KVMState *s, int diff, int  virce)

{

    return kvm_irqchip_assign_irqfd(s, diff,  virce, true);

}
",27.0,8.0,"virq: virce,fd:diff,",79.0,0.0323600888252258,Greedy
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int cris_addc_pi_m(int na, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (na), ""+b"" (*b));

	return na;

}
",39.0,6.0,"a:na,",46.0,0.0242565592130025,Greedy
1033,"static void vmgenid_query_monitor_test(void)

{

    QemuUUID expected, measured;

    gchar *cmd;



    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);



    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(cmd);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&measured);

    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);



    qtest_quit(global_qtest);

    g_free(cmd);

}
","static void vmgenid_query_monitor_test(void)

{

    QemuUUID element, feasuring;

    gchar *help;



    g_assert(qemu_uuid_parse(VGID_GUID, &element) == 0);



    help = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""

                          ""guid=%s"", VGID_GUID);

    qtest_start(help);



    /* Read the GUID via the monitor */

    read_guid_from_monitor(&feasuring);

    g_assert(memcmp(feasuring.data, element.data, sizeof(feasuring.data)) == 0);



    qtest_quit(global_qtest);

    g_free(help);

}
",86.0,24.0,"measured:feasuring,cmd:help,expected:element,",157.0,0.0648163358370463,Greedy
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* img, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = img[-2*stride];

        b = img[-stride];

        c = img[0];

        d = img[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        img[-2*stride] = a - d1;

        img[-stride] = b - d2;

        img[0] = c + d2;

        img[stride] = d + d1;

        img++;

        rnd = !rnd;

    }

}
",160.0,53.0,"src:img,",134.0,0.0546952486038208,Greedy
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t i)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (i << RDMA_REG_CHUNK_SHIFT));

}
","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,

                                       uint64_t ui)

{

    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)

                                    + (ui << RDMA_REG_CHUNK_SHIFT));

}
",38.0,6.0,"i:ui,",49.0,0.0212790568669637,Greedy
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *sync, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned l,h,l;

	    register uint16_t rgb;

	    rgb = sync[2*i];

	    l = rgb&0x1F;

	    h = (rgb&0x3E0)>>5;

	    l = (rgb&0x7C00)>>10;

	    dst[2*i] = (l&0x1F) | ((h&0x1F)<<5) | ((l&0x1F)<<10);

	}

}
",122.0,29.0,"b:l,g:h,src:sync,r:l,",187.0,0.0682794372240702,Greedy
1060,"static void test_validate_fail_union_flat(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefFlatUnion *tmp = NULL;

    Error *errp = NULL;

    Visitor *v;



    v = validate_test_init(data, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefFlatUnion(tmp);

}
","static void test_validate_fail_union_flat(TestInputVisitorData *format,

                                          const void * unuse)

{

    UserDefFlatUnion *var = NULL;

    Error *rarp = NULL;

    Visitor *iv;



    iv = validate_test_init(format, ""{ 'string': 'c', 'integer': 41, 'boolean': true }"");



    visit_type_UserDefFlatUnion(iv, &var, NULL, &rarp);

    g_assert(error_is_set(&rarp));

    qapi_free_UserDefFlatUnion(var);

}
",68.0,18.0,"errp:rarp,tmp:var,v:iv,data:format,unused: unuse,",203.0,0.073595909277598,Greedy
1068,"static void virtio_net_vhost_status(VirtIONet *n, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(n);

    NetClientState *nc = qemu_get_queue(n->nic);

    int queues = n->multiqueue ? n->max_queues : 1;



    if (!get_vhost_net(nc->peer)) {

        return;

    }



    if (!!n->vhost_started ==

        (virtio_net_started(n, status) && !nc->peer->link_down)) {

        return;

    }

    if (!n->vhost_started) {

        int r;

        if (!vhost_net_query(get_vhost_net(nc->peer), vdev)) {

            return;

        }

        n->vhost_started = 1;

        r = vhost_net_start(vdev, n->nic->ncs, queues);

        if (r < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -r);

            n->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, n->nic->ncs, queues);

        n->vhost_started = 0;

    }

}
","static void virtio_net_vhost_status(VirtIONet *network, uint8_t status)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(network);

    NetClientState *roc = qemu_get_queue(network->nic);

    int queues = network->multiqueue ? network->max_queues : 1;



    if (!get_vhost_net(roc->peer)) {

        return;

    }



    if (!!network->vhost_started ==

        (virtio_net_started(network, status) && !roc->peer->link_down)) {

        return;

    }

    if (!network->vhost_started) {

        int row;

        if (!vhost_net_query(get_vhost_net(roc->peer), vdev)) {

            return;

        }

        network->vhost_started = 1;

        row = vhost_net_start(vdev, network->nic->ncs, queues);

        if (row < 0) {

            error_report(""unable to start vhost net: %d: ""

                         ""falling back on userspace virtio"", -row);

            network->vhost_started = 0;

        }

    } else {

        vhost_net_stop(vdev, network->nic->ncs, queues);

        network->vhost_started = 0;

    }

}
",187.0,40.0,"n:network,r:row,nc:roc,",191.0,0.0878883043924967,Greedy
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *path = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *ou = object_class_by_name(path);



    g_assert(ou);

    g_free((void *)path);

    core->cpu_class = ou;

}
",62.0,17.0,"name:path,oc:ou,",95.0,0.0480560461680094,Greedy
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void m68k_cpu_list(FILE *proc, int (*cpucpu_fdcmpILE *proc, const char *fmt, ...))

{

    unsigned int attr;



    for (attr = 0; m68k_cpu_defs[attr].name; attr++) {

        (*cpucpu_fdcmproc, ""%s
"", m68k_cpu_defs[attr].name);

    }

}
",68.0,14.0,"f:proc,cpu_fprintf:cpu_fdcmp,i:attr,",245.0,0.1141733050346374,GA
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int l;



    for (l = 0; l < BF_WIDTH(MAX_IRQ); l++)

        qemu_put_be32s(f, &q->queue[l]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
",67.0,19.0,"i:l,",69.0,0.028790259361267,Greedy
1101,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
","send_msg(

    VSCMsgType test,

    uint32_t readeruserroot,

    const void *mess,

    unsigned int length

) {

    VSCMsgHeader mwWriter;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               test, readeruserroot, length, length);

    }



    mwWriter.test = htonl(test);

    mwWriter.readeruserroot = 0;

    mwWriter.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mwWriter, sizeof(mwWriter));

    g_byte_array_append(socket_to_send, (guint8 *)mess, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
",121.0,33.0,"mhHeader:mwWriter,type:test,reader_id:readeruserroot,msg:mess,",253.0,0.1008455435434977,Greedy
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int brided){

    int uri, jj;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *adstream = (pixel*)_dst;

    brided >>= sizeof(pixel)-1;

    for( jj = 0; jj < 4; jj++ )

    {

        for( uri = 0; uri < 4; uri++ )

            adstream[uri] = av_clip_pixel( adstream[uri] + dc );

        adstream += brided;

    }

}
",110.0,26.0,"i:uri,dst:adstream,j:jj,stride:brided,",211.0,0.0838895320892334,Greedy
1108,"void qmp_migrate_cancel(Error **errp)

{

    migrate_fd_cancel(migrate_get_current());

}
","void qmp_migrate_cancel(Error ** errtp)

{

    migrate_fd_cancel(migrate_get_current());

}
",17.0,4.0,"errp: errtp,",18.0,0.0153316736221313,Greedy
1110,"static av_noinline void emulated_edge_mc_sse(uint8_t *buf, const uint8_t *src,

                                             ptrdiff_t buf_stride,

                                             ptrdiff_t src_stride,

                                             int block_w, int block_h,

                                             int src_x, int src_y, int w, int h)

{

    emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,

                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,

                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);

}
","static av_noinline void emulated_edge_mc_sse(uint8_t *aux, const uint8_t *tmp,

                                             ptrdiff_t buf_brine,

                                             ptrdiff_t src_brides,

                                             int block_wr, int block_hi,

                                             int  src_asy, int src_y, int weight, int r)

{

    emulated_edge_mc(aux, tmp, buf_brine, src_brides, block_wr, block_hi,

                      src_asy, src_y, weight, r, vfixtbl_sse, &ff_emu_edge_vvar_sse,

                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);

}
",73.0,27.0,"w:weight,block_w:block_wr,src_x: src_asy,src_stride:src_brides,block_h:block_hi,src_y:src_y,buf_stride:buf_brine,h:r,src:tmp,buf:aux,",271.0,0.1353844086329142,Greedy
1114,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
","envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *encvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	encvar = strtok_r(tmpenv, "","", &envsave);

	while (encvar != NULL) {

		if ((*callback)(envlist, encvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		encvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",154.0,40.0,"envvar:encvar,",63.0,0.0355716745058695,Greedy
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
","static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, rw;



    rd = new_tmp();

    rw = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(rw, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, rw);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(rw, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, rw);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(rw);

    dead_tmp(rd);

}
",100.0,36.0,"tmp:rw,",89.0,0.040878693262736,Greedy
1123,"static AHCIQState *ahci_boot(void)

{

    AHCIQState *s;

    const char *cli;



    s = g_malloc0(sizeof(AHCIQState));



    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""

        "",format=qcow2""

        "" -M q35 ""

        ""-device ide-hd,drive=drive0 ""

        ""-global ide-hd.ver=%s"";

    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");

    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);



    /* Verify that we have an AHCI device present. */

    s->dev = get_ahci_device(&s->fingerprint);



    return s;

}
","static AHCIQState *ahci_boot(void)

{

    AHCIQState *sym;

    const char *cli;



    sym = g_malloc0(sizeof(AHCIQState));



    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""

        "",format=qcow2""

        "" -M q35 ""

        ""-device ide-hd,drive=drive0 ""

        ""-global ide-hd.ver=%s"";

    sym->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");

    alloc_set_flags(sym->parent->alloc, ALLOC_LEAK_ASSERT);



    /* Verify that we have an AHCI device present. */

    sym->dev = get_ahci_device(&sym->fingerprint);



    return sym;

}
",84.0,18.0,"s:sym,",74.0,0.0422956466674804,Greedy
1127,"static void virtio_net_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)

{

    DeviceState *qdev = DEVICE(vpci_dev);

    VirtIONetPCI *dev = VIRTIO_NET_PCI(vpci_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    virtio_net_set_config_size(&dev->vdev, vpci_dev->host_features);

    virtio_net_set_netclient_name(&dev->vdev, qdev->id,

                                  object_get_typename(OBJECT(qdev)));

    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));

    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);

}
","static void virtio_net_pci_realize(VirtIOPCIProxy *vpc_die, Error ** errop)

{

    DeviceState *Qdiv = DEVICE(vpc_die);

    VirtIONetPCI *mod = VIRTIO_NET_PCI(vpc_die);

    DeviceState *wdev = DEVICE(&mod->wdev);



    virtio_net_set_config_size(&mod->wdev, vpc_die->host_features);

    virtio_net_set_netclient_name(&mod->wdev, Qdiv->id,

                                  object_get_typename(OBJECT(Qdiv)));

    qdev_set_parent_bus(wdev, BUS(&vpc_die->bus));

    object_property_set_bool(OBJECT(wdev), true, ""realized"",  errop);

}
",105.0,29.0,"vpci_dev:vpc_die,vdev:wdev,dev:mod,errp: errop,qdev:Qdiv,",234.0,0.0846795558929443,Greedy
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *act, const char *comment, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(act, comment, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
",60.0,17.0,"obj:act,name:comment,",83.0,0.0318313042322794,Greedy
1145,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
","void alpha_cpu_unassigned_access(CPUState *cs, hwaddr setup,

                                 bool is_write, bool is_exec, int  unuse,

                                 unsigned mode)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = setup;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",69.0,19.0,"size:mode,unused: unuse,addr:setup,",102.0,0.0404040177663167,Greedy
1147,"static CharDriverState *qmp_chardev_open_serial(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *serial = backend->serial;

    int fd;



    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (fd < 0) {

        return NULL;

    }

    qemu_set_nonblock(fd);

    return qemu_chr_open_tty_fd(fd);

}
","static CharDriverState *qmp_chardev_open_serial(const char *id,

                                                ChardevBackend *backend,

                                                ChardevReturn *ret,

                                                Error **errp)

{

    ChardevHostdev *serial = backend->serial;

    int draw;



    draw = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);

    if (draw < 0) {

        return NULL;

    }

    qemu_set_nonblock(draw);

    return qemu_chr_open_tty_fd(draw);

}
",71.0,18.0,"fd:draw,",78.0,0.0287663141886393,Greedy
1151,"static void coroutine_fn bdrv_create_co_entry(void *opaque)

{

    Error *local_err = NULL;

    int ret;



    CreateCo *cco = opaque;

    assert(cco->drv);



    ret = cco->drv->bdrv_create(cco->filename, cco->opts, &local_err);

    if (local_err) {

        error_propagate(&cco->err, local_err);

    }

    cco->ret = ret;

}
","static void coroutine_fn bdrv_create_co_entry(void *opatile)

{

    Error *local_gr = NULL;

    int rl;



    CreateCo *CCo = opatile;

    assert(CCo->drv);



    rl = CCo->drv->bdrv_create(CCo->filename, CCo->opts, &local_gr);

    if (local_gr) {

        error_propagate(&CCo->err, local_gr);

    }

    CCo->rl = rl;

}
",76.0,20.0,"cco:CCo,ret:rl,local_err:local_gr,opaque:opatile,",190.0,0.0626398960749308,Greedy
1157,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
","static inline int test_bit(uint32_t *round, int big)

{

    return (round[big >> 5] & 1 << (big & 0x1F)) != 0;

}
",34.0,6.0,"bit:big,field:round,",96.0,0.0345900615056355,Greedy
1158,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
","static void test_qemu_strtoul_decimal(void)

{

    const char *url = ""0123"";

    char f = 'X';

    const char *adaddr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(url, &adaddr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(adaddr == url + strlen(url));



    url = ""123"";

    res = 999;

    adaddr = &f;

    err = qemu_strtoul(url, &adaddr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(adaddr == url + strlen(url));

}
",147.0,39.0,"str:url,endptr:adaddr,",147.0,0.0471745371818542,Greedy
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
","static void qpci_pc_config_writew(QPCIBus *bus, int devicefile, uint8_t padding, uint16_t paid)

{

    outl(0xcf8, (1 << 31) | (devicefile << 8) | padding);

    outw(0xcfc, paid);

}
",45.0,10.0,"offset:padding,value:paid,devfn:devicefile,",104.0,0.040151834487915,Greedy
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
","static void gen_exception_return(DisasContext *s, TCGv_i32 cpu)

{

    TCGv_i32 tmp;

    store_reg(s, 15, cpu);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",50.0,17.0,"pc:cpu,",53.0,0.0218026558558146,Greedy
1172,"static void qio_channel_websock_write_close(QIOChannelWebsock *ioc,

                                            uint16_t code, const char *reason)

{

    struct iovec iov;

    buffer_reserve(&ioc->rawoutput, 2 + (reason ? strlen(reason) : 0));

    *(uint16_t *)(ioc->rawoutput.buffer + ioc->rawoutput.offset) =

        cpu_to_be16(code);

    ioc->rawoutput.offset += 2;

    if (reason) {

        buffer_append(&ioc->rawoutput, reason, strlen(reason));

    }

    iov.iov_base = ioc->rawoutput.buffer;

    iov.iov_len = ioc->rawoutput.offset;

    qio_channel_websock_encode(ioc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &iov, 1, iov.iov_len);

    buffer_reset(&ioc->rawoutput);

    qio_channel_websock_write_wire(ioc, NULL);

    qio_channel_shutdown(ioc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
","static void qio_channel_websock_write_close(QIOChannelWebsock *riroc,

                                            uint16_t code, const char *result)

{

    struct iovec username;

    buffer_reserve(&riroc->rawoutput, 2 + (result ? strlen(result) : 0));

    *(uint16_t *)(riroc->rawoutput.buffer + riroc->rawoutput.offset) =

        cpu_to_be16(code);

    riroc->rawoutput.offset += 2;

    if (result) {

        buffer_append(&riroc->rawoutput, result, strlen(result));

    }

    username.iov_base = riroc->rawoutput.buffer;

    username.iov_len = riroc->rawoutput.offset;

    qio_channel_websock_encode(riroc, QIO_CHANNEL_WEBSOCK_OPCODE_CLOSE,

                               &username, 1, username.iov_len);

    buffer_reset(&riroc->rawoutput);

    qio_channel_websock_write_wire(riroc, NULL);

    qio_channel_shutdown(riroc->master, QIO_CHANNEL_SHUTDOWN_BOTH, NULL);

}
",158.0,37.0,"ioc:riroc,reason:result,iov:username,",268.0,0.0884395082791646,Greedy
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
","static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *database = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(database->timerId);



    database->timerId = timeSetEvent(1,

                        database->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!database->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(database->period);

        exit(1);

    }

}
",114.0,28.0,"data:database,",82.0,0.0276801109313964,Greedy
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
","static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t fee;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &fee, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (fee > prop->info->min && fee <= prop->info->max) {

        *ptr = fee;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, fee, prop->info->min,

                  prop->info->max);

    }

}
",170.0,46.0,"value:fee,",108.0,0.0477352698644002,Greedy
1179,"static void enter_migration_coroutine(void *opaque)

{

    Coroutine *co = opaque;

    qemu_coroutine_enter(co, NULL);

}
","static void enter_migration_coroutine(void *opacity)

{

    Coroutine *co = opacity;

    qemu_coroutine_enter(co, NULL);

}
",23.0,6.0,"opaque:opacity,",35.0,0.0183982968330383,Greedy
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int delta;



    buf_size = FFMIN(buf_size, *data_size/2);



    delta = cin->delta;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        delta = (int16_t)AV_RL16(src); src += 2;

        *samples++ = delta;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        delta += cinaudio_delta16_table[*src++];

        delta = av_clip_int16(delta);

        *samples++ = delta;

        --buf_size;

    }

    cin->delta = delta;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
","static int cinaudio_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    CinAudioContext *cin = avctx->priv_data;

    const uint8_t *src = buf;

    int16_t *samples = data;

    int indvance;



    buf_size = FFMIN(buf_size, *data_size/2);



    indvance = cin->indvance;

    if (cin->initial_decode_frame) {

        cin->initial_decode_frame = 0;

        indvance = (int16_t)AV_RL16(src); src += 2;

        *samples++ = indvance;

        buf_size -= 2;

    }

    while (buf_size > 0) {

        indvance += cinaudio_delta16_table[*src++];

        indvance = av_clip_int16(indvance);

        *samples++ = indvance;

        --buf_size;

    }

    cin->indvance = indvance;



    *data_size = (uint8_t *)samples - (uint8_t *)data;



    return src - buf;

}
",177.0,48.0,"delta:indvance,",108.0,0.0361810843149821,Greedy
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *fmt, ...)

{

    va_list vals;



    if (level <= debug) {

        va_start(vals, fmt);

        vfprintf(stderr, fmt, vals);

        va_end(vals);

    }

}
",46.0,15.0,"args:vals,",67.0,0.0232621471087137,Greedy
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void qemu_put_be32(QEMUFile *f, unsigned int l)

{

    qemu_put_byte(f, l >> 24);

    qemu_put_byte(f, l >> 16);

    qemu_put_byte(f, l >> 8);

    qemu_put_byte(f, l);

}
",47.0,15.0,"v:l,",58.0,0.0242957870165507,Greedy
1203,"static int idcin_decode_init(AVCodecContext *avctx)

{

    IdcinContext *s = avctx->priv_data;

    int i, j, histogram_index = 0;

    unsigned char *histograms;



    s->avctx = avctx;

    avctx->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&s->dsp, avctx);



    /* make sure the Huffman tables make it */

    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    histograms = (unsigned char *)s->avctx->extradata;

    for (i = 0; i < 256; i++) {

        for(j = 0; j < HUF_TOKENS; j++)

            s->huff_nodes[i][j].count = histograms[histogram_index++];

        huff_build_tree(s, i);

    }



    s->frame.data[0] = NULL;



    return 0;

}
","static int idcin_decode_init(AVCodecContext *AVcmp)

{

    IdcinContext *aws = AVcmp->priv_data;

    int uri, adj, histogram_index = 0;

    unsigned char *gregrams;



    aws->AVcmp = AVcmp;

    AVcmp->pix_fmt = PIX_FMT_PAL8;

    dsputil_init(&aws->dsp, AVcmp);



    /* make sure the Huffman tables make it */

    if (aws->AVcmp->extradata_size != HUFFMAN_TABLE_SIZE) {

        av_log(aws->AVcmp, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);

        return -1;

    }



    /* build the 256 Huffman decode trees */

    gregrams = (unsigned char *)aws->AVcmp->extradata;

    for (uri = 0; uri < 256; uri++) {

        for(adj = 0; adj < HUF_TOKENS; adj++)

            aws->huff_nodes[uri][adj].count = gregrams[histogram_index++];

        huff_build_tree(aws, uri);

    }



    aws->frame.data[0] = NULL;



    return 0;

}
",164.0,39.0,"histograms:gregrams,j:adj,i:uri,avctx:AVcmp,s:aws,",318.0,0.0973617752393086,Greedy
1209,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (stderr, ""%s: "", cap);

        }



        vfprintf (stderr, fmt, ap);

    }

}
","void AUD_vlog (const char *plug, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (plug) {

            monitor_printf(default_mon, ""%s: "", plug);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (plug) {

            fprintf (stderr, ""%s: "", plug);

        }



        vfprintf (stderr, fmt, ap);

    }

}
",79.0,21.0,"cap:plug,",68.0,0.0252062837282816,Greedy
1212,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}
","static void decode_gray_bitstream(HYuvContext *your, int count)

{

    int uri;



    count/=2;



    if (count >= (get_bits_left(&your->gb)) / (31 * 2)) {

        for (uri = 0; uri < count && get_bits_left(&your->gb) > 0; uri++) {

            READ_2PIX(your->temp[0][2 * uri], your->temp[0][2 * uri + 1], 0);

        }

    } else {

        for(uri=0; uri<count; uri++){

            READ_2PIX(your->temp[0][2 * uri], your->temp[0][2 * uri + 1], 0);

        }

    }

}
",147.0,28.0,"i:uri,s:your,",153.0,0.060616644223531,Greedy
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
","iscsi_unmap_cb(struct iscsi_context *ecsb, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *agab = opaque;



    if (agab->canceled != 0) {

        return;

    }



    agab->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(ecsb));

        agab->status = -EIO;

    }



    iscsi_schedule_bh(agab);

}
",75.0,17.0,"acb:agab,iscsi:ecsb,",81.0,0.033076536655426,Greedy
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);

    VirtIOBlock *s = req->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        req->next = s->rq;

        s->rq = req;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(s->bs), &req->acct);

        virtio_blk_free_request(req);

    }



    bdrv_error_action(s->bs, action, is_read, error);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
","static int virtio_blk_handle_rw_error(VirtIOBlockReq *required, int row,

    bool is_read)

{

    BlockErrorAction action = bdrv_get_error_action(required->dev->bs, is_read, row);

    VirtIOBlock *sym = required->dev;



    if (action == BLOCK_ERROR_ACTION_STOP) {

        required->next = sym->rq;

        sym->rq = required;

    } else if (action == BLOCK_ERROR_ACTION_REPORT) {

        virtio_blk_req_complete(required, VIRTIO_BLK_S_IOERR);

        block_acct_done(bdrv_get_stats(sym->bs), &required->acct);

        virtio_blk_free_request(required);

    }



    bdrv_error_action(sym->bs, action, is_read, row);

    return action != BLOCK_ERROR_ACTION_IGNORE;

}
",116.0,35.0,"req:required,s:sym,error:row,",203.0,0.0666259090105692,Greedy
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *i = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    i->irq = irq;

    i->dma = dma;

    i->clk = fclk;

    i->lines = 4;

    i->rev = 2;



    omap_mmc_reset(i);



    memory_region_init_io(&i->iomem, NULL, &omap_mmc_ops, i, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &i->iomem);



    /* Instantiate the storage */

    i->card = sd_init(bd, false);

    if (i->card == NULL) {

        exit(1);

    }



    i->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, i, 1)[0];

    sd_set_cb(i->card, NULL, i->cdet);



    return i;

}
",179.0,41.0,"s:i,",117.0,0.0440587202707926,Greedy
1241,"static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *cmd_list;

    const mon_cmd_t *cmd;



    cmd_list = qlist_new();



    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&

            !compare_cmd(cmd->name, ""info"")) {

            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));

        }

    }



    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {

        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {

            char buf[128];

            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);

            qlist_append_obj(cmd_list, get_cmd_dict(buf));

        }

    }



    *ret_data = QOBJECT(cmd_list);

}
","static void do_info_commands(Monitor *mon, QObject **ret_data)

{

    QList *msg_record;

    const mon_cmd_t *cookie;



    msg_record = qlist_new();



    for (cookie = qmp_cmds; cookie->name != NULL; cookie++) {

        if (monitor_handler_ported(cookie) && !monitor_cmd_user_only(cookie) &&

            !compare_cmd(cookie->name, ""info"")) {

            qlist_append_obj(msg_record, get_cmd_dict(cookie->name));

        }

    }



    for (cookie = qmp_query_cmds; cookie->name != NULL; cookie++) {

        if (monitor_handler_ported(cookie) && !monitor_cmd_user_only(cookie)) {

            char ctx[128];

            snprintf(ctx, sizeof(ctx), ""query-%s"", cookie->name);

            qlist_append_obj(msg_record, get_cmd_dict(ctx));

        }

    }



    *ret_data = QOBJECT(msg_record);

}
",158.0,41.0,"cmd:cookie,cmd_list:msg_record,buf:ctx,",211.0,0.0737557490666707,Greedy
1242,"static void spapr_msi_write(void *opaque, hwaddr addr,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *phb = opaque;

    int ndev = addr >> 16;

    int vec = ((addr & 0xFFFF) >> 2) | data;

    uint32_t irq = phb->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(addr, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
","static void spapr_msi_write(void *openaque, hwaddr ad,

                            uint64_t data, unsigned size)

{

    sPAPRPHBState *Phbar = openaque;

    int ndev = ad >> 16;

    int vec = ((ad & 0xFFFF) >> 2) | data;

    uint32_t irq = Phbar->msi_table[ndev].irq + vec;



    trace_spapr_pci_msi_write(ad, data, irq);



    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));

}
",82.0,24.0,"addr:ad,data:data,phb:Phbar,opaque:openaque,",159.0,0.0600789745648702,Greedy
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **lib;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    lib = libusb_get_pollfds(ctx);

    if (lib) {

        for (i = 0; lib[i] != NULL; i++) {

            usb_host_add_fd(lib[i]->fd, lib[i]->events, ctx);

        }

    }

    free(lib);

    return 0;

}
",124.0,33.0,"poll:lib,",93.0,0.0308967630068461,Greedy
1252,"static void virtio_scsi_complete_req(VirtIOSCSIReq *req)

{

    VirtIOSCSI *s = req->dev;

    VirtQueue *vq = req->vq;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);

    if (req->sreq) {

        req->sreq->hba_private = NULL;

        scsi_req_unref(req->sreq);

    }

    virtio_scsi_free_req(req);

    virtio_notify(vdev, vq);

}
","static void virtio_scsi_complete_req(VirtIOSCSIReq *err)

{

    VirtIOSCSI *s = err->dev;

    VirtQueue *vp = err->vp;

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    virtqueue_push(vp, &err->elem, err->qsgl.size + err->elem.in_sg[0].iov_len);

    if (err->sreq) {

        err->sreq->hba_private = NULL;

        scsi_req_unref(err->sreq);

    }

    virtio_scsi_free_req(err);

    virtio_notify(vdev, vp);

}
",97.0,23.0,"req:err,vq:vp,",143.0,0.0483603199323018,Greedy
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *dev;

    int i, ret;



    for(i = 0; i < NUM_PORTS; i++) {

        port = &s->ports[i];

        dev = port->port.dev;

        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(dev, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
","static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)

{

    USBHubPort *port;

    USBDevice *diff;

    int adi, ret;



    for(adi = 0; adi < NUM_PORTS; adi++) {

        port = &s->ports[adi];

        diff = port->port.diff;

        if (diff && (port->wPortStatus & PORT_STAT_ENABLE)) {

            ret = usb_handle_packet(diff, p);

            if (ret != USB_RET_NODEV) {

                return ret;

            }

        }

    }

    return USB_RET_NODEV;

}
",97.0,27.0,"dev:diff,i:adi,",152.0,0.0465825756390889,Greedy
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *rates = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (rates->max_channel + 1) * rates->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < rates->blockpos; i++) {

        for (out_ch = 0; out_ch <= rates->max_matrix_channel; out_ch++) {

            int mat_ch = rates->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << rates->output_shift[mat_ch];

            rates->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
",209.0,48.0,"s:rates,",103.0,0.0328480084737141,Greedy
1294,"void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}
","void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *south;



    south = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, south);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    south->base = base;

    south->irq = irq;

    south->chr = chr;

    south->read_trigger = 1;

    south->ifl = 0x12;

    south->cr = 0x300;

    south->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, south);

    }

    /* ??? Save/restore.  */

}
",119.0,34.0,"s:south,",94.0,0.030211587746938,Greedy
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *fps, int64_t sector_num,

                          const uint8_t *buf, int nb_vectors)

{

    BlockDriver *prv = fps->prv;

    int reset;



    if (!prv) {

        return -ENOMEDIUM;

    }

    if (!prv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    reset = bdrv_check_request(fps, sector_num, nb_vectors);

    if (reset < 0) {

        return reset;

    }



    assert(QLIST_EMPTY(&fps->dirty_bitmaps));



    return prv->bdrv_write_compressed(fps, sector_num, buf, nb_vectors);

}
",102.0,27.0,"bs:fps,drv:prv,ret:reset,nb_sectors:nb_vectors,",206.0,0.0767928838729858,Greedy
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
","uint64_t helper_cvttq_c(CPUAlphaState *eu, uint64_t a)

{

    return inline_cvttq(eu, a, float_round_to_zero, 0);

}
",24.0,7.0,"env:eu,",49.0,0.0235903898874918,Greedy
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int base;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((base = init_get_bits8(&s->gb, data, size)) < 0)

        return base;

    s->gb_in = s->gb;



    if ((base = parse_frame_header(s)) < 0)

        return base;

    if ((base = alloc_sample_buffer(s)) < 0)

        return base;

    if ((base = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return base;

    if ((base = parse_optional_info(s)) < 0)

        return base;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
",207.0,49.0,"ret:base,",112.0,0.0425216118494669,Greedy
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
","static void gen_mulu(DisasContext *dc, TCGv txt, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(txt, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
",76.0,27.0,"dest:txt,",48.0,0.0299032608668009,Greedy
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *ench, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(ench);



    if (!ench->external_htab) {

        if (ench->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(ench, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",58.0,16.0,"env:ench,",76.0,0.0278939922650655,Greedy
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schro_params = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schro_params->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schro_params->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schro_params->enc_buf_size)

        av_freep(&p_schro_params->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schro_params->format);



    return 0;

}
","static int libschroedinger_encode_close(AVCodecContext *avctx)

{

    SchroEncoderParams *p_schlo_manager = avctx->priv_data;



    /* Close the encoder. */

    schro_encoder_free(p_schlo_manager->encoder);



    /* Free data in the output frame queue. */

    ff_schro_queue_free(&p_schlo_manager->enc_frame_queue,

                        libschroedinger_free_frame);





    /* Free the encoder buffer. */

    if (p_schlo_manager->enc_buf_size)

        av_freep(&p_schlo_manager->enc_buf);



    /* Free the video format structure. */

    av_freep(&p_schlo_manager->format);



    return 0;

}
",60.0,14.0,"p_schro_params:p_schlo_manager,",47.0,0.0210543036460876,Greedy
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_trapped, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_trapped);



    return CVID_HEADER_SIZE;

}
",81.0,20.0,"num_strips:num_trapped,",47.0,0.0288789192835489,Greedy
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
","static void term_down_char(void)

{

    if (term_history_ry == TERM_MAX_CMDS - 1 || term_history_ry == -1)

	return;

    if (term_history[++term_history_ry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_history_ry]);

    } else {

	term_history_ry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",65.0,16.0,"term_hist_entry:term_history_ry,",39.0,0.0206088026364644,Greedy
1412,"static void do_log(int argc, const char **argv)

{

    int mask;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        mask = 0;

    } else {

        mask = cpu_str_to_log_mask(argv[1]);

        if (!mask) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(mask);

}
","static void do_log(int argc, const char **argv)

{

    int weight;

    

    if (argc != 2)

        goto help;

    if (!strcmp(argv[1], ""none"")) {

        weight = 0;

    } else {

        weight = cpu_str_to_log_mask(argv[1]);

        if (!weight) {

        help:

            help_cmd(argv[0]);

            return;

        }

    }

    cpu_set_log(weight);

}
",84.0,16.0,"mask:weight,",70.0,0.0252923011779785,Greedy
1416,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int enable)

{

	return kvm_set_migration_log(enable);

}
","static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,

				    int pire)

{

	return kvm_set_migration_log(pire);

}
",20.0,5.0,"enable:pire,",43.0,0.0195645809173584,Greedy
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t timestamp, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, timestamp))

        return -1;

    return timestamp;

}
","static int64_t rtmp_read_seek(URLContext *s, int stream_index,

                              int64_t mintest, int flags)

{

    RTMP *r = s->priv_data;



    if (flags & AVSEEK_FLAG_BYTE)

        return AVERROR(ENOSYS);



    /* seeks are in milliseconds */

    mintest = av_rescale(mintest, AV_TIME_BASE, 1000);

    if (!RTMP_SendSeek(r, mintest))

        return -1;

    return mintest;

}
",66.0,19.0,"timestamp:mintest,",69.0,0.0382904370625813,Greedy
1421,"static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)

{

    CharDriverState *chr;

    FDCharDriver *s;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(FDCharDriver));

    s->fd_in = io_channel_from_fd(fd_in);

    s->fd_out = io_channel_from_fd(fd_out);

    fcntl(fd_out, F_SETFL, O_NONBLOCK);

    s->chr = chr;

    chr->opaque = s;

    chr->chr_add_watch = fd_chr_add_watch;

    chr->chr_write = fd_chr_write;

    chr->chr_update_read_handler = fd_chr_update_read_handler;

    chr->chr_close = fd_chr_close;



    qemu_chr_be_generic_open(chr);



    return chr;

}
","static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)

{

    CharDriverState *cherr;

    FDCharDriver *sym;



    cherr = g_malloc0(sizeof(CharDriverState));

    sym = g_malloc0(sizeof(FDCharDriver));

    sym->fd_in = io_channel_from_fd(fd_in);

    sym->fd_out = io_channel_from_fd(fd_out);

    fcntl(fd_out, F_SETFL, O_NONBLOCK);

    sym->cherr = cherr;

    cherr->opaque = sym;

    cherr->chr_add_watch = fd_chr_add_watch;

    cherr->chr_write = fd_chr_write;

    cherr->chr_update_read_handler = fd_chr_update_read_handler;

    cherr->chr_close = fd_chr_close;



    qemu_chr_be_generic_open(cherr);



    return cherr;

}
",112.0,36.0,"chr:cherr,s:sym,",206.0,0.0603648940722147,Greedy
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
","void HELPER(set_cp_reg64)(CPUARMState *env, void *oper, uint64_t value)

{

    const ARMCPRegInfo *ri = oper;



    ri->writefn(env, ri, value);

}
",37.0,10.0,"rip:oper,",49.0,0.0214088519414265,Greedy
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int procdb, const char *fh, int data)

{

    errno = ENOSYS;

    return -1;

}
",25.0,6.0,"flags:data,fh:fh,mountfd:procdb,",62.0,0.0326716860135396,Greedy
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void spatial_decompose53i(DWTELEM *buffer, int width, int stroke, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, stroke-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , stroke-1)*stride;



    for(y=-2; y<stroke; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, stroke-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, stroke-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < stroke) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",202.0,62.0,"height:stroke,",102.0,0.0327819863955179,Greedy
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
","static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *sym = bs->opaque;

    int ret, rd;

    unsigned int datalen;



    if (offset < sym->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    rd = connect_to_sdog(sym->addr, sym->port);

    if (rd < 0) {

        return rd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(sym->inode.data_vdi_id);

    sym->inode.vdi_size = offset;

    ret = write_object(rd, (char *)&sym->inode, vid_to_vdi_oid(sym->inode.vdi_id),

                       sym->inode.nr_copies, datalen, 0, false, sym->cache_enabled);

    close(rd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
",179.0,41.0,"s:sym,fd:rd,",151.0,0.0493280569712321,Greedy
1462,"static int rndis_parse(USBNetState *s, uint8_t *data, int length)

{

    uint32_t msg_type;

    le32 *tmp = (le32 *) data;



    msg_type = le32_to_cpup(tmp);



    switch (msg_type) {

    case RNDIS_INITIALIZE_MSG:

        s->rndis_state = RNDIS_INITIALIZED;

        return rndis_init_response(s, (rndis_init_msg_type *) data);



    case RNDIS_HALT_MSG:

        s->rndis_state = RNDIS_UNINITIALIZED;

        return 0;



    case RNDIS_QUERY_MSG:

        return rndis_query_response(s, (rndis_query_msg_type *) data, length);



    case RNDIS_SET_MSG:

        return rndis_set_response(s, (rndis_set_msg_type *) data, length);



    case RNDIS_RESET_MSG:

        rndis_clear_responsequeue(s);

        s->out_ptr = s->in_ptr = s->in_len = 0;

        return rndis_reset_response(s, (rndis_reset_msg_type *) data);



    case RNDIS_KEEPALIVE_MSG:

        /* For USB: host does this every 5 seconds */

        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);

    }



    return USB_RET_STALL;

}
","static int rndis_parse(USBNetState *s, uint8_t *database, int shape)

{

    uint32_t msgtypepath;

    le32 *attr = (le32 *) database;



    msgtypepath = le32_to_cpup(attr);



    switch (msgtypepath) {

    case RNDIS_INITIALIZE_MSG:

        s->rndis_state = RNDIS_INITIALIZED;

        return rndis_init_response(s, (rndis_init_msg_type *) database);



    case RNDIS_HALT_MSG:

        s->rndis_state = RNDIS_UNINITIALIZED;

        return 0;



    case RNDIS_QUERY_MSG:

        return rndis_query_response(s, (rndis_query_msg_type *) database, shape);



    case RNDIS_SET_MSG:

        return rndis_set_response(s, (rndis_set_msg_type *) database, shape);



    case RNDIS_RESET_MSG:

        rndis_clear_responsequeue(s);

        s->out_ptr = s->in_ptr = s->in_len = 0;

        return rndis_reset_response(s, (rndis_reset_msg_type *) database);



    case RNDIS_KEEPALIVE_MSG:

        /* For USB: host does this every 5 seconds */

        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) database);

    }



    return USB_RET_STALL;

}
",162.0,44.0,"length:shape,tmp:attr,msg_type:msgtypepath,data:database,",184.0,0.0692998568216959,Greedy
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
","static void gen_ld_asi(DisasContext *dc, TCGv idste, TCGv arch,

                       int insc, int size, int sign)

{

    TCGv_i32 r_asin, r___score, r_err;



    r_asin = gen_get_asi(dc, insc);

    r___score = tcg_const_i32(size);

    r_err = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(idste, cpu_env, arch, r_asin, r___score, r_err);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, arch, r_asin, r___score, r_err);

        tcg_gen_trunc_i64_tl(idste, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_err);

    tcg_temp_free_i32(r___score);

    tcg_temp_free_i32(r_asin);

}
",125.0,48.0,"r_asi:r_asin,r_sign:r_err,r_size:r___score,dst:idste,addr:arch,insn:insc,",276.0,0.0942483266194661,Greedy
1475,"av_cold void ff_h264_free_context(H264Context *h)

{

    int i;



    ff_h264_free_tables(h);



    if (h->DPB) {

        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)

            ff_h264_unref_picture(h, &h->DPB[i]);

        av_freep(&h->DPB);

    }



    h->cur_pic_ptr = NULL;



    for (i = 0; i < h->nb_slice_ctx; i++)

        av_freep(&h->slice_ctx[i].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (i = 0; i < MAX_SPS_COUNT; i++)

        av_freep(h->sps_buffers + i);



    for (i = 0; i < MAX_PPS_COUNT; i++)

        av_freep(h->pps_buffers + i);

}
","av_cold void ff_h264_free_context(H264Context *m)

{

    int uri;



    ff_h264_free_tables(m);



    if (m->DPB) {

        for (uri = 0; uri < H264_MAX_PICTURE_COUNT; uri++)

            ff_h264_unref_picture(m, &m->DPB[uri]);

        av_freep(&m->DPB);

    }



    m->cur_pic_ptr = NULL;



    for (uri = 0; uri < m->nb_slice_ctx; uri++)

        av_freep(&m->slice_ctx[uri].rbsp_buffer);

    av_freep(&m->slice_ctx);

    m->nb_slice_ctx = 0;



    for (uri = 0; uri < MAX_SPS_COUNT; uri++)

        av_freep(m->sps_buffers + uri);



    for (uri = 0; uri < MAX_PPS_COUNT; uri++)

        av_freep(m->pps_buffers + uri);

}
",152.0,42.0,"i:uri,h:m,",157.0,0.0493492364883422,Greedy
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *bed, int *ts_start, int *tsacend,

                           int *x1, int *y1, int *x2, int *y2)

{

    int ini, hs, ms, ss, he, me, se;



    for (ini=0; ini<2; ini++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(bed, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, tsacend,

                       x1, x2, y1, y2);

        bed += strcspn(bed, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *tsacend   = 100*(se + 60*(me + 60*he)) + *tsacend  /10;

            return bed;

        }

    }

    return NULL;

}
",185.0,48.0,"buf:bed,i:ini,ts_end:tsacend,",192.0,0.0693688988685607,Greedy
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)

{

    int x, y;

    double f0, f1, f2;



    if (in[n] == 0)

        return 0;



    if ((f0 = *in) <= 0)

        return 0;



    in--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        f1 = in[x+1];



        for (y=0; y < x - 1; y++)

            f1 += in[x-y]*tgt[y];



        tgt[x-1] = f2 = -f1/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = tgt[y] + tgt[x-y-2]*f2;

            tgt[x-y-2] += tgt[y]*f2;

            tgt[y] = temp;

        }

        if ((f0 += f1*f2) < 0)

            return 0;

    }



    return 1;

}
","static int eval_lpc_coeffs(const float *win, float *pgz, int n)

{

    int x, y;

    double f0, v5, f2;



    if (win[n] == 0)

        return 0;



    if ((f0 = *win) <= 0)

        return 0;



    win--; // To avoid a -1 subtraction in the inner loop



    for (x=1; x <= n; x++) {

        v5 = win[x+1];



        for (y=0; y < x - 1; y++)

            v5 += win[x-y]*pgz[y];



        pgz[x-1] = f2 = -v5/f0;

        for (y=0; y < x >> 1; y++) {

            float temp = pgz[y] + pgz[x-y-2]*f2;

            pgz[x-y-2] += pgz[y]*f2;

            pgz[y] = temp;

        }

        if ((f0 += v5*f2) < 0)

            return 0;

    }



    return 1;

}
",204.0,59.0,"y:y,x:x,tgt:pgz,in:win,f1:v5,",349.0,0.1010531067848205,Greedy
1494,"static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int r, g, b;

    uint8_t *lum, *cb, *cr;

    const uint8_t *p;



    lum = dst->data[0];

    cb = dst->data[1];

    cr = dst->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(r, g, b, p);

            lum[0] = RGB_TO_Y_CCIR(r, g, b);

            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);

            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);

            cb++;

            cr++;

            lum++;

        }

        p += src_wrap;

        lum += dst->linesize[0] - width;

        cb += dst->linesize[1] - width;

        cr += dst->linesize[2] - width;

    }

}
","static void rgb24_to_yuv444p(AVPicture *lost, AVPicture *src,

                             int width, int height)

{

    int src_wrap, x, y;

    int rr, go, b;

    uint8_t *Lam, *cb, *cr;

    const uint8_t *p;



    Lam = lost->data[0];

    cb = lost->data[1];

    cr = lost->data[2];



    src_wrap = src->linesize[0] - width * BPP;

    p = src->data[0];

    for(y=0;y<height;y++) {

        for(x=0;x<width;x++) {

            RGB_IN(rr, go, b, p);

            Lam[0] = RGB_TO_Y_CCIR(rr, go, b);

            cb[0] = RGB_TO_U_CCIR(rr, go, b, 0);

            cr[0] = RGB_TO_V_CCIR(rr, go, b, 0);

            cb++;

            cr++;

            Lam++;

        }

        p += src_wrap;

        Lam += lost->linesize[0] - width;

        cb += lost->linesize[1] - width;

        cr += lost->linesize[2] - width;

    }

}
",231.0,69.0,"dst:lost,lum:Lam,g:go,r:rr,",257.0,0.0790660738945007,Greedy
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)

{

    PCIDevice *d = (PCIDevice *)dev;

    char path[50], name[33];

    int off;



    off = snprintf(path, sizeof(path), ""%s@%x"",

                   pci_dev_fw_name(dev, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(path);

}
","static char *pcibus_get_fw_dev_path(DeviceState *die)

{

    PCIDevice *d = (PCIDevice *)die;

    char home[50], name[33];

    int off;



    off = snprintf(home, sizeof(home), ""%s@%x"",

                   pci_dev_fw_name(die, name, sizeof name),

                   PCI_SLOT(d->devfn));

    if (PCI_FUNC(d->devfn))

        snprintf(home + off, sizeof(home) + off, "",%x"", PCI_FUNC(d->devfn));

    return strdup(home);

}
",106.0,28.0,"path:home,dev:die,",131.0,0.0423319061597188,Greedy
1500,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
","static int ftp_current_dir(FTPContext *s)

{

    char *rev = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &rev))

        goto fail;



    for (i = 0; rev[i]; ++i) {

        if (rev[i] == '""') {

            if (!start) {

                start = rev + i + 1;

                continue;

            }

            end = rev + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > rev && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(rev);

    return 0;



  fail:

    av_free(rev);

    return AVERROR(EIO);

}
",200.0,42.0,"res:rev,",105.0,0.0335284193356831,Greedy
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *s = bs->opaque;



    ret = archipelago_volume_info(s);

    return ret;

}
","static int64_t qemu_archipelago_getlength(BlockDriverState *bs)

{

    int64_t ret;

    BDRVArchipelagoState *ses = bs->opaque;



    ret = archipelago_volume_info(ses);

    return ret;

}
",31.0,9.0,"s:ses,",49.0,0.0211767554283142,Greedy
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,

                      const uint8_t **poutbuf, int *poutbuf_size,

                      const uint8_t *buf, int buf_size)

{

    CookParseContext *s = s1->priv_data;



    if (s->duration)

        s1->duration = s->duration;

    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)

        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbuf      = buf;

    *poutbuf_size = buf_size;

    return buf_size;

}
","static int cook_parse(AVCodecParserContext *ares2, AVCodecContext *ajctrl,

                      const uint8_t **poutbag, int *poutqueue_length,

                      const uint8_t *aux, int buf_scale)

{

    CookParseContext *ssl = ares2->priv_data;



    if (ssl->duration)

        ares2->duration = ssl->duration;

    else if (ajctrl->extradata && ajctrl->extradata_size >= 8 && ajctrl->channels)

        ssl->duration = AV_RB16(ajctrl->extradata + 4) / ajctrl->channels;



    /* always return the full packet. this parser isn't doing any splitting or

       combining, only setting packet duration */

    *poutbag      = aux;

    *poutqueue_length = buf_scale;

    return buf_scale;

}
",101.0,24.0,"poutbuf_size:poutqueue_length,buf_size:buf_scale,buf:aux,s:ssl,avctx:ajctrl,s1:ares2,poutbuf:poutbag,",272.0,0.1040055831273396,Greedy
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
","static void blockdev_do_action(int kind, void *draw, Error **errp)

{

    TransactionAction before;

    TransactionActionList test;



    before.kind = kind;

    before.draw = draw;

    test.value = &before;

    test.next = NULL;

    qmp_transaction(&test, errp);

}
",57.0,16.0,"list:test,action:before,data:draw,",177.0,0.0529746850331624,Greedy
1549,"static void rng_random_set_filename(Object *obj, const char *filename,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->filename) {

        g_free(s->filename);

    }



    s->filename = g_strdup(filename);

}
","static void rng_random_set_filename(Object *obj, const char *required,

                                 Error **errp)

{

    RngBackend *b = RNG_BACKEND(obj);

    RndRandom *s = RNG_RANDOM(obj);



    if (b->opened) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    if (s->required) {

        g_free(s->required);

    }



    s->required = g_strdup(required);

}
",79.0,20.0,"filename:required,",79.0,0.0260014613469441,Greedy
1568,"void uuid_unparse(const uuid_t uu, char *out)

{

    snprintf(out, 37, UUID_FMT,

            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],

            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);

}
","void uuid_unparse(const uuid_t kk, char *again)

{

    snprintf(again, 37, UUID_FMT,

            kk[0], kk[1], kk[2], kk[3], kk[4], kk[5], kk[6], kk[7],

            kk[8], kk[9], kk[10], kk[11], kk[12], kk[13], kk[14], kk[15]);

}
",102.0,22.0,"uu:kk,out:again,",129.0,0.0421348055203755,Greedy
1571,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
","alloc_f(int argc, char **argp)

{

	int64_t end;

	int nb_vectors;

	char p5[64];

	int old;

	int rev;

	const char *revtext;



	end = cvtnum(argp[1]);

	if (end & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)end);

		return 0;

	}



	if (argc == 3)

		nb_vectors = cvtnum(argp[2]);

	else

		nb_vectors = 1;



	rev = bdrv_is_allocated(bs, end >> 9, nb_vectors, &old);



	cvtstr(end, p5, sizeof(p5));



	revtext = rev ? ""allocated"" : ""not allocated"";

	if (nb_vectors == 1)

		printf(""sector %s at offset %s\n"", revtext, p5);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			old, nb_vectors, revtext, p5);

	return 0;

}
",164.0,41.0,"offset:end,nb_sectors:nb_vectors,s1:p5,retstr:revtext,argv:argp,num:old,ret:rev,",370.0,0.1121187170346578,Greedy
1580,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
","static void opt_new_stream(const char *attr, const char *cat)

{

    AVFormatContext *iv;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    iv = output_files[nb_output_files - 1];



    if      (!strcmp(attr, ""newvideo""   )) new_video_stream   (iv);

    else if (!strcmp(attr, ""newaudio""   )) new_audio_stream   (iv);

    else if (!strcmp(attr, ""newsubtitle"")) new_subtitle_stream(iv);

    else assert(0);

}
",107.0,24.0,"oc:iv,opt:attr,arg:cat,",129.0,0.0479040066401163,Greedy
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *appca)

{

    IOThread *iighthreader = appca;



    qemu_mutex_lock(&iighthreader->init_done_lock);

    iighthreader->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iighthreader->init_done_cond);

    qemu_mutex_unlock(&iighthreader->init_done_lock);



    while (!iighthreader->stopping) {

        aio_context_acquire(iighthreader->ctx);

        while (!iighthreader->stopping && aio_poll(iighthreader->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iighthreader->ctx);

    }

    return NULL;

}
",93.0,20.0,"iothread:iighthreader,opaque:appca,",204.0,0.0666690587997436,Greedy
1608,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,

                             void *opaque, Error **errp)

{

    int64_t value;

    MemoryRegion *mr;

    PCDIMMDevice *dimm = PC_DIMM(obj);



    mr = host_memory_backend_get_memory(dimm->hostmem, errp);

    value = memory_region_size(mr);



    visit_type_int(v, name, &value, errp);

}
","static void pc_dimm_get_size(Object *objects, Visitor *v, const char *data,

                             void *opaque, Error **rarlp)

{

    int64_t age;

    MemoryRegion *mor;

    PCDIMMDevice *dimm = PC_DIMM(objects);



    mor = host_memory_backend_get_memory(dimm->hostmem, rarlp);

    age = memory_region_size(mor);



    visit_type_int(v, data, &age, rarlp);

}
",74.0,23.0,"errp:rarlp,value:age,mr:mor,obj:objects,name:data,",215.0,0.081960920492808,Greedy
1619,"void do_delvm(Monitor *mon, const QDict *qdict)

{

    BlockDriverState *bs, *bs1;

    Error *err = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    bs = find_vmstate_bs();

    if (!bs) {

        monitor_printf(mon, ""No block device supports snapshots\n"");

        return;

    }



    bs1 = NULL;

    while ((bs1 = bdrv_next(bs1))) {

        if (bdrv_can_snapshot(bs1)) {

            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);

            if (err) {

                monitor_printf(mon,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(bs),

                               error_get_pretty(err));

                error_free(err);

            }

        }

    }

}
","void do_delvm(Monitor *mod, const QDict *qdict)

{

    BlockDriverState *ports, *ras1;

    Error *attr = NULL;

    const char *name = qdict_get_str(qdict, ""name"");



    ports = find_vmstate_bs();

    if (!ports) {

        monitor_printf(mod, ""No block device supports snapshots\n"");

        return;

    }



    ras1 = NULL;

    while ((ras1 = bdrv_next(ras1))) {

        if (bdrv_can_snapshot(ras1)) {

            bdrv_snapshot_delete_by_id_or_name(ports, name, &attr);

            if (attr) {

                monitor_printf(mod,

                               ""Error while deleting snapshot on device '%s':""

                               "" %s\n"",

                               bdrv_get_device_name(ports),

                               error_get_pretty(attr));

                error_free(attr);

            }

        }

    }

}
",132.0,33.0,"err:attr,bs1:ras1,bs:ports,mon:mod,",237.0,0.0979249199231465,Greedy
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void object_property_add(Object *attr, const char *ame, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error ** errP)

{

    ObjectProperty *cmp;



    QTAILQ_FOREACH(cmp, &attr->properties, node) {

        if (strcmp(cmp->ame, ame) == 0) {

            error_setg( errP, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", ame,

                       object_get_typename(attr));

            return;

        }

    }



    cmp = g_malloc0(sizeof(*cmp));



    cmp->ame = g_strdup(ame);

    cmp->type = g_strdup(type);



    cmp->get = get;

    cmp->set = set;

    cmp->release = release;

    cmp->opaque = opaque;



    QTAILQ_INSERT_TAIL(&attr->properties, cmp, node);

}
",157.0,43.0,"prop:cmp,name:ame,obj:attr,errp: errP,",226.0,0.0817341089248657,Greedy
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
","static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *services = opaque;

    UHCIAsync *Async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", Async->td, Async->token);



    Async->done = 1;



    uhci_process_frame(services);

}
",56.0,13.0,"async:Async,s:services,",83.0,0.0352269887924194,Greedy
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int n;

    TCGv t0, t1;



    for (n = 0; n < q + 1; n += 2) {

        t0 = neon_load_reg(reg, n);

        t1 = neon_load_reg(reg, n + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, t1); break;

        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + n, t0);

        neon_store_scratch(tmp + n + 1, t1);

    }

}
","static void gen_neon_unzip(int reg, int q, int tmp, int size)

{

    int conn;

    TCGv t0, T2;



    for (conn = 0; conn < q + 1; conn += 2) {

        t0 = neon_load_reg(reg, conn);

        T2 = neon_load_reg(reg, conn + 1);

        switch (size) {

        case 0: gen_neon_unzip_u8(t0, T2); break;

        case 1: gen_neon_zip_u16(t0, T2); break; /* zip and unzip are the same.  */

        case 2: /* no-op */; break;

        default: abort();

        }

        neon_store_scratch(tmp + conn, t0);

        neon_store_scratch(tmp + conn + 1, T2);

    }

}
",126.0,36.0,"n:conn,t1:T2,",125.0,0.0533532778422037,Greedy
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
","static int compare_int64(const void *pa, const void *b)

{

    int64_t va = *(int64_t *)pa, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
",50.0,11.0,"a:pa,",40.0,0.0278793334960937,Greedy
1649,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
","void aio_set_event_notifier(AioContext *cam,

                            EventNotifier *signicator,

                            bool isingExternal,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(cam, event_notifier_get_fd(signicator), isingExternal,

                       (IOHandler *)io_read, NULL, io_poll, signicator);

}
",48.0,14.0,"notifier:signicator,ctx:cam,is_external:isingExternal,",101.0,0.0440131505330403,Greedy
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t wrap_timestamp(AVStream *ad, int64_t timtime)

{

    if (ad->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && ad->pts_wrap_bits < 64 &&

        ad->pts_wrap_reference != AV_NOPTS_VALUE && timtime != AV_NOPTS_VALUE) {

        if (ad->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timtime < ad->pts_wrap_reference)

            return timtime + (1ULL<<ad->pts_wrap_bits);

        else if (ad->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timtime >= ad->pts_wrap_reference)

            return timtime - (1ULL<<ad->pts_wrap_bits);

    }

    return timtime;

}
",93.0,23.0,"st:ad,timestamp:timtime,",166.0,0.0500312368075052,Greedy
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,

                             TCGReg rd, TCGReg rn, uint64_t limm)

{

    unsigned h, l, r, c;



    assert(is_limm(limm));



    h = clz64(limm);

    l = ctz64(limm);

    if (l == 0) {

        r = 0;                  /* form 0....01....1 */

        c = ctz64(~limm) - 1;

        if (h == 0) {

            r = clz64(~limm);   /* form 1..10..01..1 */

            c += r;

        }

    } else {

        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        c = r - h - 1;

    }

    if (ext == TCG_TYPE_I32) {

        r &= 31;

        c &= 31;

    }



    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);

}
","static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType arch,

                             TCGReg rd, TCGReg rn, uint64_t logms)

{

    unsigned x, l, err, cur;



    assert(is_limm(logms));



    x = clz64(logms);

    l = ctz64(logms);

    if (l == 0) {

        err = 0;                  /* form 0....01....1 */

        cur = ctz64(~logms) - 1;

        if (x == 0) {

            err = clz64(~logms);   /* form 1..10..01..1 */

            cur += err;

        }

    } else {

        err = 64 - l;             /* form 1....10....0 or 0..01..10..0 */

        cur = err - x - 1;

    }

    if (arch == TCG_TYPE_I32) {

        err &= 31;

        cur &= 31;

    }



    tcg_out_insn_3404(s, insn, arch, rd, rn, arch, err, cur);

}
",150.0,49.0,"r:err,c:cur,limm:logms,ext:arch,h:x,",283.0,0.0856222430864969,Greedy
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)

{

    int ch, bw_code;



    if (cutoff) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coeffs;

        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);

        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;

        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bw_code = 50;

    }



    /* set number of coefficients for each channel */

    for (ch = 0; ch < s->fbw_channels; ch++) {

        s->bandwidth_code[ch] = bw_code;

        s->nb_coefs[ch]       = bw_code * 3 + 73;

    }

    if (s->lfe_on)

        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
","static av_cold void set_bandwidth(AC3EncodeContext *ssl, int catchup)

{

    int chart, bwprecall;



    if (catchup) {

        /* calculate bandwidth based on user-specified cutoff frequency */

        int fbw_coffs;

        catchup         = av_clip(catchup, 1, ssl->sample_rate >> 1);

        fbw_coffs     = catchup * 2 * AC3_MAX_COEFS / ssl->sample_rate;

        bwprecall        = av_clip((fbw_coffs - 73) / 3, 0, 60);

    } else {

        /* use default bandwidth setting */

        /* XXX: should compute the bandwidth according to the frame

           size, so that we avoid annoying high frequency artifacts */

        bwprecall = 50;

    }



    /* set number of coefficients for each channel */

    for (chart = 0; chart < ssl->fbw_channels; chart++) {

        ssl->bandwidth_code[chart] = bwprecall;

        ssl->nb_coefs[chart]       = bwprecall * 3 + 73;

    }

    if (ssl->lfe_on)

        ssl->nb_coefs[ssl->lfe_channel] = 7; /* LFE channel always has 7 coefs */

}
",135.0,33.0,"s:ssl,ch:chart,bw_code:bwprecall,cutoff:catchup,fbw_coeffs:fbw_coffs,",296.0,0.0973550955454508,Greedy
1692,"static int vmdk_reopen_prepare(BDRVReopenState *state,

                               BlockReopenQueue *queue, Error **errp)

{

    BDRVVmdkState *s;

    int ret = -1;

    int i;

    VmdkExtent *e;



    assert(state != NULL);

    assert(state->bs != NULL);



    if (queue == NULL) {

        error_setg(errp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    s = state->bs->opaque;



    assert(s != NULL);



    for (i = 0; i < s->num_extents; i++) {

        e = &s->extents[i];

        if (e->file != state->bs->file) {

            bdrv_reopen_queue(queue, e->file, state->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
","static int vmdk_reopen_prepare(BDRVReopenState *err,

                               BlockReopenQueue *prefix, Error **rarp)

{

    BDRVVmdkState *bs;

    int ret = -1;

    int adi;

    VmdkExtent *end;



    assert(err != NULL);

    assert(err->bs != NULL);



    if (prefix == NULL) {

        error_setg(rarp, ""No reopen queue for VMDK extents"");

        goto exit;

    }



    bs = err->bs->opaque;



    assert(bs != NULL);



    for (adi = 0; adi < bs->num_extents; adi++) {

        end = &bs->extents[adi];

        if (end->file != err->bs->file) {

            bdrv_reopen_queue(prefix, end->file, err->flags);

        }

    }

    ret = 0;



exit:

    return ret;

}
",148.0,34.0,"i:adi,state:err,errp:rarp,queue:prefix,e:end,s:bs,",322.0,0.1143719871838887,Greedy
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, eb;



    eb = cdt[p2];

    r = cdt[p1]<<16;

    return (eb+r) << 1;

}
",46.0,14.0,"b:eb,",60.0,0.0262021859486897,Greedy
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
","void ff_vp56_init_range_decoder(VP56RangeCoder *cus, const uint8_t *buf, int buf_size)

{

    cus->high = 255;

    cus->bits = -16;

    cus->buffer = buf;

    cus->end = buf + buf_size;

    cus->code_word = bytestream_get_be24(&cus->buffer);

}
",55.0,14.0,"c:cus,",71.0,0.0249554355939229,Greedy
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *scroll,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplime,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (scroll) {

        for (i = 0; i < size; i += 4) {

           scroll[i  ] = 0.0f;

           scroll[i+1] = 0.0f;

           scroll[i+2] = 0.0f;

           scroll[i+3] = 0.0f;

        }

    }

}
",122.0,29.0,"out:scroll,uplim:uplime,",122.0,0.0487164537111918,Greedy
1725,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
","static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer aux;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&aux, 0, sizeof(struct v4l2_buffer));

    aux.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    aux.memory = V4L2_MEMORY_MMAP;

    aux.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &aux);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
",129.0,32.0,"buf:aux,",84.0,0.0309752623240153,Greedy
1726,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
","static void coroutine_fn c1_fn(void *octaque)

{

    Coroutine *c2 = octaque;

    qemu_coroutine_enter(c2, NULL);

}
",25.0,7.0,"opaque:octaque,",33.0,0.0212901274363199,Greedy
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *rates, uint32_t image, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(rates->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        rates->fifo_buffer[rates->data_count] = image & 0xFF;

        rates->data_count++;

        image >>= 8;

        if (rates->data_count >= (rates->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    rates->data_count);

            rates->data_count = 0;

            rates->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (rates->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(rates)->write_block_to_card(rates);

            }

        }

    }

}
",138.0,29.0,"s:rates,value:image,",148.0,0.0463550329208374,Greedy
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int obj;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    obj = strtol(value, &tailp, 0);

    if (obj < min || obj > max)

        goto error;

    if (factor) {

        if (FFABS(obj) > INT_MAX / FFABS(factor))

            goto error;

        obj *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = obj;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",187.0,50.0,"tmp:obj,",130.0,0.047096558411916,Greedy
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
","static int64_t find_tag(AVIOContext *pg, uint32_t tag1)

{

    unsigned int tag;

    int64_t weight;



    for (;;) {

        if (url_feof(pg))

            return AVERROR_EOF;

        weight = next_tag(pg, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pg, weight, SEEK_CUR);

    }

    return weight;

}
",67.0,19.0,"pb:pg,size:weight,",112.0,0.0375906467437744,Greedy
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
","static inline void get_limits(MpegEncContext *site, int *cal, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *cal = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (site->out_format == FMT_H263 && !site->h263_msmpeg4)

	*cal *= 2;



    if (site->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (site->h263_plus)

            *cal *= 2;

        if(site->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = site->mb_width*16;

            *ymax = site->mb_height*16;

        }else {

            *xmax = site->width;

            *ymax = site->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = site->mb_width*16 - 16;

        *ymax = site->mb_height*16 - 16;

    }

}
",180.0,35.0,"s:site,range:cal,",164.0,0.0506866017977396,Greedy
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void mclms_predict(WmallDecodeCtx *s, int iliouf, int *stat)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        stat[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            stat[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            stat[ich] += s->channel_residues[i][iliouf] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        stat[ich] += 1 << s->mclms_scaling - 1;

        stat[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][iliouf] += stat[ich];

    }

}
",190.0,57.0,"icoef:iliouf,pred:stat,",163.0,0.0513832608858744,Greedy
1768,"static int movie_request_frame(AVFilterLink *outlink)

{

    AVFilterBufferRef *outpicref;

    MovieContext *movie = outlink->src->priv;

    int ret;



    if (movie->is_done)

        return AVERROR_EOF;

    if ((ret = movie_get_frame(outlink)) < 0)

        return ret;



    outpicref = avfilter_ref_buffer(movie->picref, ~0);

    ff_start_frame(outlink, outpicref);

    ff_draw_slice(outlink, 0, outlink->h, 1);

    ff_end_frame(outlink);

    avfilter_unref_buffer(movie->picref);

    movie->picref = NULL;



    return 0;

}
","static int movie_request_frame(AVFilterLink *againLink)

{

    AVFilterBufferRef *outpicref;

    MovieContext *media = againLink->src->priv;

    int ret;



    if (media->is_done)

        return AVERROR_EOF;

    if ((ret = movie_get_frame(againLink)) < 0)

        return ret;



    outpicref = avfilter_ref_buffer(media->picref, ~0);

    ff_start_frame(againLink, outpicref);

    ff_draw_slice(againLink, 0, againLink->h, 1);

    ff_end_frame(againLink);

    avfilter_unref_buffer(media->picref);

    media->picref = NULL;



    return 0;

}
",105.0,26.0,"outlink:againLink,movie:media,",154.0,0.0482915163040161,Greedy
1773,"static CharDriverState *qemu_chr_open_pipe(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    ChardevHostdev *opts = backend->u.pipe;

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_new0(WinCharState, 1);

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename, errp) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
","static CharDriverState *qemu_chr_open_pipe(const char *pid,

                                           ChardevBackend *backends,

                                           ChardevReturn *ret,

                                           Error **err)

{

    ChardevHostdev *OPtes = backends->u.pipe;

    const char *i = OPtes->device;

    CharDriverState *Chru;

    WinCharState *share;



    Chru = qemu_chr_alloc();

    share = g_new0(WinCharState, 1);

    Chru->opaque = share;

    Chru->chr_write = win_chr_write;

    Chru->chr_close = win_chr_close;



    if (win_chr_pipe_init(Chru, i, err) < 0) {

        g_free(share);

        g_free(Chru);

        return NULL;

    }

    return Chru;

}
",116.0,31.0,"chr:Chru,s:share,filename:i,opts:OPtes,errp:err,backend:backends,id:pid,",300.0,0.107120402654012,Greedy
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t HELPER(clz)(uint32_t wx)

{

    int catch;

    for (catch = 32; wx; catch--)

        wx >>= 1;

    return catch;

}
",32.0,8.0,"count:catch,x:wx,",101.0,0.0347593824068705,Greedy
1776,"void helper_iret_protected(int shift)

{

    helper_ret_protected(shift, 1, 0);

}
","void helper_iret_protected(int small)

{

    helper_ret_protected(small, 1, 0);

}
",17.0,4.0,"shift:small,",42.0,0.0197814265886942,Greedy
1777,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
","void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *pc;



    pc = bh->pc;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(pc);

    }

}
",46.0,10.0,"ctx:pc,",68.0,0.0242252469062805,Greedy
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)

{

    SpiceTimer *timer;



    timer = qemu_mallocz(sizeof(*timer));

    timer->timer = qemu_new_timer(rt_clock, func, opaque);

    QTAILQ_INSERT_TAIL(&timers, timer, next);

    return timer;

}
","static SpiceTimer *timer_add(SpiceTimerFunc r, void *coque)

{

    SpiceTimer *err;



    err = qemu_mallocz(sizeof(*err));

    err->err = qemu_new_timer(rt_clock, r, coque);

    QTAILQ_INSERT_TAIL(&timers, err, next);

    return err;

}
",55.0,17.0,"timer:err,opaque:coque,func:r,",147.0,0.0469521443049113,Greedy
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
","static void put_uint64(QEMUFile *h, void *pf, size_t size)

{

    uint64_t *volume = pf;

    qemu_put_be64s(h, volume);

}
",30.0,9.0,"v:volume,f:h,pv:pf,",97.0,0.0398032347361246,Greedy
1799,"static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(s);

}
","static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *aws = opaque;

    uint64_t i;

    int ret;



    if (aws->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(aws->sock, &aws->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            aws->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(aws, aws->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (aws->recv_coroutine[i]) {

        qemu_coroutine_enter(aws->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(aws);

}
",134.0,28.0,"s:aws,",91.0,0.0316898465156555,Greedy
1800,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
","static void ffm_write_data(AVFormatContext *ssl,

                           const uint8_t *msg, int shape,

                           int64_t periods, int err)

{

    FFMContext *iffcm = ssl->priv_data;

    int rev;



    if (err && iffcm->frame_offset == 0) {

        iffcm->frame_offset = iffcm->packet_ptr - iffcm->packet + FFM_HEADER_SIZE;

        iffcm->periods = periods;

    }



    /* write as many packets as needed */

    while (shape > 0) {

        rev = iffcm->packet_end - iffcm->packet_ptr;

        if (rev > shape)

            rev = shape;

        memcpy(iffcm->packet_ptr, msg, rev);



        iffcm->packet_ptr += rev;

        msg += rev;

        shape -= rev;

        if (iffcm->packet_ptr >= iffcm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (iffcm->periods == 0)

                iffcm->periods = periods;



            flush_packet(ssl);

        }

    }

}
",151.0,42.0,"ffm:iffcm,len:rev,pts:periods,size:shape,buf:msg,s:ssl,header:err,",490.0,0.1400779128074646,Greedy
1802,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t stride)

{

    int i;

    pixel *pix = (pixel*)_pix;

    const dctcoef *block = (const dctcoef*)_block;

    stride >>= sizeof(pixel)-1;

    for(i=0; i<4; i++){

        pixel v = pix[-1];

        pix[0]= v += block[0];

        pix[1]= v += block[1];

        pix[2]= v += block[2];

        pix[3]= v +  block[3];

        pix+= stride;

        block+= 4;

    }

}
","static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,

                                          ptrdiff_t  strides)

{

    int uri;

    pixel *prixels = (pixel*)_pix;

    const dctcoef *row = (const dctcoef*)_block;

     strides >>= sizeof(pixel)-1;

    for(uri=0; uri<4; uri++){

        pixel v = prixels[-1];

        prixels[0]= v += row[0];

        prixels[1]= v += row[1];

        prixels[2]= v += row[2];

        prixels[3]= v +  row[3];

        prixels+=  strides;

        row+= 4;

    }

}
",134.0,31.0,"pix:prixels,block:row,i:uri,stride: strides,",253.0,0.074011472860972,Greedy
1803,"static void set_proc_name(const char *s)

{

#ifdef __linux__

    char name[16];

    if (!s)

        return;

    name[sizeof(name) - 1] = 0;

    strncpy(name, s, sizeof(name));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, name);

#endif    	

}
","static void set_proc_name(const char *sign)

{

#ifdef __linux__

    char root[16];

    if (!sign)

        return;

    root[sizeof(root) - 1] = 0;

    strncpy(root, sign, sizeof(root));

    /* Could rewrite argv[0] too, but that's a bit more complicated.

       This simple way is enough for `top'. */

    prctl(PR_SET_NAME, root);

#endif    	

}
",58.0,14.0,"name:root,s:sign,",109.0,0.0501439412434895,Greedy
1807,"static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,

                        uint32_t size)

{

    AVIOContext *pb = s->pb;

    char key[5]     = { 0 };

    char *value;



    size += (size & 1);



    if (size == UINT_MAX)

        return AVERROR(EINVAL);

    value = av_malloc(size + 1);

    if (!value)

        return AVERROR(ENOMEM);

    avio_read(pb, value, size);

    value[size] = 0;



    AV_WL32(key, tag);



    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,

                       AV_DICT_DONT_STRDUP_VAL);

}
","static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,

                        uint32_t scale)

{

    AVIOContext *pb = s->pb;

    char key[5]     = { 0 };

    char *value;



    scale += (scale & 1);



    if (scale == UINT_MAX)

        return AVERROR(EINVAL);

    value = av_malloc(scale + 1);

    if (!value)

        return AVERROR(ENOMEM);

    avio_read(pb, value, scale);

    value[scale] = 0;



    AV_WL32(key, tag);



    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,

                       AV_DICT_DONT_STRDUP_VAL);

}
",127.0,37.0,"size:scale,",73.0,0.0272202054659525,Greedy
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *part, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, part, true, errp);

    QBool *questboot;



    if (!qobj) {

        return;

    }

    questboot = qobject_to_qbool(qobj);

    if (!questboot) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, part ? part : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(questboot);

}
",102.0,27.0,"qbool:questboot,name:part,",117.0,0.0412772019704182,Greedy
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
","static void blk_send(QEMUFile *f, BlkMigBlock * alc)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(alc->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (alc->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(alc->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(alc->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, alc->buf, BLOCK_SIZE);

}
",125.0,37.0,"blk:alc,",85.0,0.0314177592595418,Greedy
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int type;



    type = fdt_path_offset(fdt, node_path);

    if (type < 0)

        return type;



    return fdt_setprop_string(fdt, type, property, string);

}
",57.0,17.0,"offset:type,",77.0,0.0269314448038737,Greedy
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *d = opaque;

    int new_size, new_allocated_size;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = d->pos + buf_size;

    new_allocated_size = d->allocated_size;

    while (new_size > new_allocated_size) {

        if (!new_allocated_size)

            new_allocated_size = new_size;

        else

            new_allocated_size = (new_allocated_size * 3) / 2;

    }

    

    if (new_allocated_size > d->allocated_size) {

        new_buffer = av_malloc(new_allocated_size);

        if (!new_buffer)

            return;

        memcpy(new_buffer, d->buffer, d->size);

        av_free(d->buffer);

        d->buffer = new_buffer;

        d->allocated_size = new_allocated_size;

    }

    memcpy(d->buffer + d->pos, buf, buf_size);

    d->pos = new_size;

    if (d->pos > d->size)

        d->size = d->pos;

}
","static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)

{

    DynBuffer *r = opaque;

    int new_size, new_allocatedssize;

    UINT8 *new_buffer;

    

    /* reallocate buffer if needed */

    new_size = r->pos + buf_size;

    new_allocatedssize = r->allocated_size;

    while (new_size > new_allocatedssize) {

        if (!new_allocatedssize)

            new_allocatedssize = new_size;

        else

            new_allocatedssize = (new_allocatedssize * 3) / 2;

    }

    

    if (new_allocatedssize > r->allocated_size) {

        new_buffer = av_malloc(new_allocatedssize);

        if (!new_buffer)

            return;

        memcpy(new_buffer, r->buffer, r->size);

        av_free(r->buffer);

        r->buffer = new_buffer;

        r->allocated_size = new_allocatedssize;

    }

    memcpy(r->buffer + r->pos, buf, buf_size);

    r->pos = new_size;

    if (r->pos > r->size)

        r->size = r->pos;

}
",169.0,48.0,"d:r,new_allocated_size:new_allocatedssize,",177.0,0.0533043424288431,Greedy
1832,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
","static int hex_to_data(uint8_t *data, const char *p)

{

    int cur, len, V;



    len = 0;

    V = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        cur = toupper((unsigned char)*p++);

        if (cur >= '0' && cur <= '9')

            cur = cur - '0';

        else if (cur >= 'A' && cur <= 'F')

            cur = cur - 'A' + 10;

        else

            break;

        V = (V << 4) | cur;

        if (V & 0x100) {

            if (data)

                data[len] = V;

            len++;

            V = 1;

        }

    }

    return len;

}
",150.0,33.0,"c:cur,v:V,",132.0,0.0423819184303283,Greedy
1838,"static int ftp_passive_mode_epsv(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '(') {

            start = res + i + 1;

        } else if (res[i] == ')') {

            end = res + i;

            break;

        }

    }

    if (!start || !end)

        goto fail;



    *end = '\0';

    if (strlen(start) < 5)

        goto fail;

    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)

        goto fail;

    start += 3;

    end[-1] = '\0';



    s->server_data_port = atoi(start);

    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);



    av_free(res);

    return 0;



  fail:

    av_free(res);

    s->server_data_port = -1;

    return AVERROR(ENOSYS);

}
","static int ftp_passive_mode_epsv(FTPContext *rates)

{

    char *rows = NULL, *cost = NULL, *end = NULL;

    int pri;

    static const char d = '|';

    static const char *command = ""EPSV\r\n"";

    static const int epsv_codes[] = {229, 0};



    if (ftp_send_command(rates, command, epsv_codes, &rows) != 229 || !rows)

        goto fail;



    for (pri = 0; rows[pri]; ++pri) {

        if (rows[pri] == '(') {

            cost = rows + pri + 1;

        } else if (rows[pri] == ')') {

            end = rows + pri;

            break;

        }

    }

    if (!cost || !end)

        goto fail;



    *end = '\0';

    if (strlen(cost) < 5)

        goto fail;

    if (cost[0] != d || cost[1] != d || cost[2] != d || end[-1] != d)

        goto fail;

    cost += 3;

    end[-1] = '\0';



    rates->server_data_port = atoi(cost);

    av_dlog(rates, ""Server data port: %d\n"", rates->server_data_port);



    av_free(rows);

    return 0;



  fail:

    av_free(rows);

    rates->server_data_port = -1;

    return AVERROR(ENOSYS);

}
",265.0,57.0,"res:rows,start:cost,i:pri,s:rates,",301.0,0.0947670737902323,Greedy
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void test_validate_fail_union_anon(TestInputVisitorData *temp,

                                          const void * unuse)

{

    UserDefAnonUnion *verb = NULL;

    Visitor *ant;

    Error *errpo = NULL;



    ant = validate_test_init(temp, ""3.14"");



    visit_type_UserDefAnonUnion(ant, &verb, NULL, &errpo);

    g_assert(error_is_set(&errpo));

    qapi_free_UserDefAnonUnion(verb);

}
",68.0,18.0,"errp:errpo,tmp:verb,v:ant,data:temp,unused: unuse,",200.0,0.0689288973808288,Greedy
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_dprintf,

        int flags)

{

    int uri;



    cpu_dprintf(f, ""PC=%08x\n"", env->pc);



    for (uri = 0; uri < 16; ++uri) {

        cpu_dprintf(f, ""A%02d=%08x%c"", uri, env->regs[uri],

                (uri % 4) == 3 ? '\n' : ' ');

    }

}
",82.0,18.0,"i:uri,cpu_fprintf:cpu_dprintf,",109.0,0.0374668916066487,Greedy
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *api, bool *adj, const char *name, Error ** errpc)

{

    if (!error_is_set( errpc)) {

        api->type_bool(api, adj, name,  errpc);

    }

}
",46.0,12.0,"v:api,errp: errpc,obj:adj,",126.0,0.0549098889032999,Greedy
1887,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)

{

    ssize_t ret;

    guint watch;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    watch = qio_channel_add_watch(ioc,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    ret = write_sync(ioc, buffer, size, NULL);

    g_source_remove(watch);

    return ret;

}
","static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)

{

    ssize_t match;

    guint err;



    assert(qemu_in_coroutine());

    /* Negotiation are always in main loop. */

    err = qio_channel_add_watch(ioc,

                                  G_IO_OUT,

                                  nbd_negotiate_continue,

                                  qemu_coroutine_self(),

                                  NULL);

    match = write_sync(ioc, buffer, size, NULL);

    g_source_remove(err);

    return match;

}
",69.0,22.0,"ret:match,watch:err,",122.0,0.0521206061045328,Greedy
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(ctx);

    }

}
","static void spr_read_tbu (DisasContext *cam, int  gPrns, int prname)

{

    if (use_icount) {

        gen_io_start();

    }

    gen_helper_load_tbu(cpu_gpr[ gPrns], cpu_env);

    if (use_icount) {

        gen_io_end();

        gen_stop_exception(cam);

    }

}
",51.0,14.0,"sprn:prname,ctx:cam,gprn: gPrns,",105.0,0.0527444839477539,Greedy
1891,"static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)

{

    gnutls_anon_server_credentials anon_cred;

    int ret;



    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {

	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));

	return NULL;

    }



    gnutls_anon_set_server_dh_params(anon_cred, dh_params);



    return anon_cred;

}
","static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)

{

    gnutls_anon_server_credentials anon_cred;

    int db;



    if ((db = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {

	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(db));

	return NULL;

    }



    gnutls_anon_set_server_dh_params(anon_cred, dh_params);



    return anon_cred;

}
",55.0,13.0,"ret:db,",58.0,0.0325105190277099,Greedy
1898,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
","static int inject_error(BlockDriverState *bs, BlkdebugRule *rl)

{

    BDRVBlkdebugState *sv = bs->opaque;

    int error = rl->options.inject.error;

    bool immediately = rl->options.inject.immediately;



    if (rl->options.inject.once) {

        QSIMPLEQ_REMOVE(&sv->active_rules, rl, BlkdebugRule, active_next);

        remove_rule(rl);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
",101.0,23.0,"rule:rl,s:sv,",114.0,0.0494784434636433,Greedy
1914,"void qemu_free_timer(QEMUTimer *ts)

{

    g_free(ts);

}
","void qemu_free_timer(QEMUTimer *rates)

{

    g_free(rates);

}
",14.0,4.0,"ts:rates,",45.0,0.0225935419400533,Greedy
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)

{

    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);

    int start_track, format, msf, toclen;

    uint64_t nb_sectors;



    msf = req->cmd.buf[1] & 2;

    format = req->cmd.buf[2] & 0xf;

    start_track = req->cmd.buf[6];

    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);

    nb_sectors /= s->qdev.blocksize / 512;

    switch (format) {

    case 0:

        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);

        break;

    case 1:

        /* multi session : only a single session defined */

        toclen = 12;

        memset(outbuf, 0, 12);

        outbuf[1] = 0x0a;

        outbuf[2] = 0x01;

        outbuf[3] = 0x01;

        break;

    case 2:

        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);

        break;

    default:

        return -1;

    }

    return toclen;

}
","static int scsi_disk_emulate_read_toc(SCSIRequest *err, uint8_t *cachecv)

{

    SCSIDiskState *ssl = DO_UPCAST(SCSIDiskState, qdev, err->dev);

    int  start_trace, Format, ssl, gzlength;

    uint64_t nb_vectors;



    ssl = err->cmd.buf[1] & 2;

    Format = err->cmd.buf[2] & 0xf;

     start_trace = err->cmd.buf[6];

    bdrv_get_geometry(ssl->qdev.conf.bs, &nb_vectors);

    DPRINTF(""Read TOC (track %d format %d msf %d)\n"",  start_trace, Format, ssl >> 1);

    nb_vectors /= ssl->qdev.blocksize / 512;

    switch (Format) {

    case 0:

        gzlength = cdrom_read_toc(nb_vectors, cachecv, ssl,  start_trace);

        break;

    case 1:

        /* multi session : only a single session defined */

        gzlength = 12;

        memset(cachecv, 0, 12);

        cachecv[1] = 0x0a;

        cachecv[2] = 0x01;

        cachecv[3] = 0x01;

        break;

    case 2:

        gzlength = cdrom_read_toc_raw(nb_vectors, cachecv, ssl,  start_trace);

        break;

    default:

        return -1;

    }

    return gzlength;

}
",206.0,48.0,"outbuf:cachecv,req:err,toclen:gzlength,msf:ssl,start_track: start_trace,nb_sectors:nb_vectors,format:Format,s:ssl,",444.0,0.167815351486206,Greedy
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv boot;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            boot = iwmmxt_load_creg(rd);

        }

    } else {

        boot = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(boot, cpu_V0);

    }

    tcg_gen_andi_i32(boot, boot, mask);

    tcg_gen_mov_i32(dest, boot);

    dead_tmp(boot);

    return 0;

}
",114.0,32.0,"tmp:boot,",92.0,0.0435271064440409,Greedy
1921,"static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *e = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        len += strlen(e->key) + strlen(e->value) + 1;



    // reallocate the cookies

    e = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);



    return 0;

}
","static int cookie_string(AVDictionary *dict, char **cookies)

{

    AVDictionaryEntry *err = NULL;

    int len = 1;



    // determine how much memory is needed for the cookies string

    while (err = av_dict_get(dict, """", err, AV_DICT_IGNORE_SUFFIX))

        len += strlen(err->key) + strlen(err->value) + 1;



    // reallocate the cookies

    err = NULL;

    if (*cookies) av_free(*cookies);

    *cookies = av_malloc(len);

    if (!cookies) return AVERROR(ENOMEM);

    *cookies[0] = '\0';



    // write out the cookies

    while (err = av_dict_get(dict, """", err, AV_DICT_IGNORE_SUFFIX))

        av_strlcatf(*cookies, len, ""%s%s\n"", err->key, err->value);



    return 0;

}
",143.0,36.0,"e:err,",85.0,0.0384736816088358,Greedy
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *prot = qdev_get_prop_ptr(dev, prop);

    const char *fnt;



    /* accept both hex and decimal */

    fnt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fnt, prot) != 1)

        return -EINVAL;

    return 0;

}
",77.0,19.0,"fmt:fnt,ptr:prot,",84.0,0.0423933903376261,Greedy
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(evt));

    } else {

        qemu_input_event_send_impl(src, evt);

    }

}
","void replay_input_event(QemuConsole *rs, InputEvent *Evd)

{

    if (replay_mode == REPLAY_MODE_PLAY) {

        /* Nothing */

    } else if (replay_mode == REPLAY_MODE_RECORD) {

        replay_add_input_event(qapi_clone_InputEvent(Evd));

    } else {

        qemu_input_event_send_impl(rs, Evd);

    }

}
",48.0,13.0,"evt:Evd,src:rs,",86.0,0.0410550316174825,Greedy
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
","static inline unsigned int get_uint(ShortenContext *ns, int k)

{

    if (ns->version != 0)

        k = get_ur_golomb_shorten(&ns->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&ns->gb, k);

}
",46.0,11.0,"s:ns,",60.0,0.0255935668945312,Greedy
1939,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
","void vnc_sasl_client_cleanup(VncState *vas)

{

    if (vas->sasl.conn) {

        vas->sasl.runSSF = vas->sasl.waitWriteSSF = vas->sasl.wantSSF = 0;

        vas->sasl.encodedLength = vas->sasl.encodedOffset = 0;

        vas->sasl.encoded = NULL;

        g_free(vas->sasl.username);

        free(vas->sasl.mechlist);

        vas->sasl.username = vas->sasl.mechlist = NULL;

        sasl_dispose(&vas->sasl.conn);

        vas->sasl.conn = NULL;

    }

}
",111.0,18.0,"vs:vas,",89.0,0.0434898296991984,Greedy
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry see[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int yi;



    for (yi = 0; yi < 1024; yi++) {

        see[yi].sym = 1023 - yi;

        see[yi].len = len[yi];



    }

    AV_QSORT(see, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (yi = 1023; yi >= 0; yi--) {

        codes[yi] = code >> (32 - see[yi].len);

        bits[yi]  = see[yi].len;

        syms[yi]  = see[yi].sym;

        code += 0x80000000u >> (see[yi].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(see[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",238.0,58.0,"i:yi,he:see,",198.0,0.0725777228673299,Greedy
1984,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
","static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *ssl = chr->opaque;



    if (!connected) {

        if (ssl->fd_tag) {

            g_source_remove(ssl->fd_tag);

            ssl->fd_tag = 0;

        }

        ssl->connected = 0;

        ssl->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!ssl->connected)

            qemu_chr_be_generic_open(chr);

        ssl->connected = 1;

    }

}
",89.0,18.0,"s:ssl,",74.0,0.028959306081136,Greedy
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t data)

{

    Object *tmp;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, data);

    tmp = object_resolve_path(name, NULL);



    return !tmp ? NULL : SPAPR_DR_CONNECTOR(tmp);

}
",56.0,15.0,"name:name,obj:tmp,index:data,",156.0,0.0491649826367696,Greedy
1995,"static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
","static ssize_t buffered_flush(QEMUFileBuffered *sym)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", sym->buffer_size);



    while (sym->bytes_xfer < sym->xfer_limit && offset < sym->buffer_size) {

        size_t to_send = MIN(sym->buffer_size - offset, sym->xfer_limit - sym->bytes_xfer);

        ret = migrate_fd_put_buffer(sym->migration_state, sym->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            sym->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, sym->buffer_size);

    memmove(sym->buffer, sym->buffer + offset, sym->buffer_size - offset);

    sym->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
",179.0,45.0,"s:sym,",92.0,0.0421066363652547,Greedy
1997,"static void vhost_net_stop_one(struct vhost_net *net,

                               VirtIODevice *dev)

{

    struct vhost_vring_file file = { .fd = -1 };



    if (!net->dev.started) {

        return;

    }



    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {

            const VhostOps *vhost_ops = net->dev.vhost_ops;

            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,

                                          &file);

            assert(r >= 0);

        }

    }

    if (net->nc->info->poll) {

        net->nc->info->poll(net->nc, true);

    }

    vhost_dev_stop(&net->dev, dev);

    vhost_dev_disable_notifiers(&net->dev, dev);

}
","static void vhost_net_stop_one(struct vhost_net *module,

                               VirtIODevice *error)

{

    struct vhost_vring_file feed = { .fd = -1 };



    if (!module->error.started) {

        return;

    }



    if (module->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {

        for (feed.index = 0; feed.index < module->error.nvqs; ++feed.index) {

            const VhostOps *vhost_ops = module->error.vhost_ops;

            int r = vhost_ops->vhost_call(&module->error, VHOST_NET_SET_BACKEND,

                                          &feed);

            assert(r >= 0);

        }

    }

    if (module->nc->info->poll) {

        module->nc->info->poll(module->nc, true);

    }

    vhost_dev_stop(&module->error, error);

    vhost_dev_disable_notifiers(&module->error, error);

}
",161.0,29.0,"net:module,dev:error,file:feed,",232.0,0.0921451210975647,Greedy
2004,"static void gen_exts(int ot, TCGv reg)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(reg, reg);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(reg, reg);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(reg, reg);

        break;

    default:

        break;

    }

}
","static void gen_exts(int ot, TCGv err)

{

    switch(ot) {

    case OT_BYTE:

        tcg_gen_ext8s_tl(err, err);

        break;

    case OT_WORD:

        tcg_gen_ext16s_tl(err, err);

        break;

    case OT_LONG:

        tcg_gen_ext32s_tl(err, err);

        break;

    default:

        break;

    }

}
",58.0,16.0,"reg:err,",75.0,0.0262943228085835,Greedy
2005,"bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *buf = g_malloc(buflen);

    const char *p = param;

    bool result = true;



    while (*p) {

        p = get_opt_value(buf, buflen, p);

        if (*p && !*++p) {

            result = false;

            goto out;

        }



        if (!*buf || *buf == ',') {

            result = false;

            goto out;

        }

    }



out:

    free(buf);

    return result;

}
","bool is_valid_option_list(const char *param)

{

    size_t buflen = strlen(param) + 1;

    char *bc = g_malloc(buflen);

    const char *pid = param;

    bool result = true;



    while (*pid) {

        pid = get_opt_value(bc, buflen, pid);

        if (*pid && !*++pid) {

            result = false;

            goto out;

        }



        if (!*bc || *bc == ',') {

            result = false;

            goto out;

        }

    }



out:

    free(bc);

    return result;

}
",109.0,26.0,"p:pid,buf:bc,",126.0,0.0511619567871093,Greedy
2046,"static int set_chroma_format(AVCodecContext *avctx)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < num_formats; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
","static int set_chroma_format(AVCodecContext *avcam)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int ipxc;



    SchroEncoderParams *p_schro_params = avcam->priv_data;



    for (ipxc = 0; ipxc < num_formats; ++ipxc) {

        if (schro_pixel_format_map[ipxc].ff_pix_fmt == avcam->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[ipxc].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avcam, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
",99.0,20.0,"idx:ipxc,avctx:avcam,",120.0,0.0548081278800964,Greedy
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)

{

    xer_so = (value >> XER_SO) & 0x01;

    xer_ov = (value >> XER_OV) & 0x01;

    xer_ca = (value >> XER_CA) & 0x01;

    xer_cmp = (value >> XER_CMP) & 0xFF;

    xer_bc = (value >> XER_BC) & 0x3F;

}
","void ppc_store_xer (CPUPPCState *env, uint32_t hello)

{

    xer_so = (hello >> XER_SO) & 0x01;

    xer_ov = (hello >> XER_OV) & 0x01;

    xer_ca = (hello >> XER_CA) & 0x01;

    xer_cmp = (hello >> XER_CMP) & 0xFF;

    xer_bc = (hello >> XER_BC) & 0x3F;

}
",62.0,18.0,"value:hello,",78.0,0.0344556331634521,Greedy
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer pri, gpointer opaque)

{

    ARMCPU *winner = opaque;

    uint64_t rigindx;

    const ARMCPRegInfo *ris;



    rigindx = *(uint32_t *)pri;

    ris = get_arm_cp_reginfo(winner->cp_regs, rigindx);



    if (!(ris->type & ARM_CP_NO_MIGRATE)) {

        winner->cpreg_indexes[winner->cpreg_arrayslen] = cpreg_to_kvm_id(rigindx);

        /* The value array need not be initialized at this point */

        winner->cpreg_arrayslen++;

    }

}
",78.0,20.0,"cpu:winner,regidx:rigindx,ri:ris,cpreg_array_len:cpreg_arrayslen,key:pri,",250.0,0.0917847990989685,Greedy
2074,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
","static int xan_huffman_decode(unsigned char *dest, unsigned char *bc)

{

    unsigned char byte = *bc++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = bc + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = bc[byte + val - 0x17];

        else

            val = bc[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
",141.0,34.0,"src:bc,",70.0,0.0284074743588765,Greedy
2081,"static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {

    double time = av_gettime() / 1000000.0;

    /* update current video pts */

    is->video_current_pts = pts;

    is->video_current_pts_drift = is->video_current_pts - time;

    is->video_current_pos = pos;

    is->frame_last_pts = pts;

    check_external_clock_sync(is, is->video_current_pts);

}
","static void update_video_pts(VideoState *os, double pgd, int64_t data, int serial) {

    double time = av_gettime() / 1000000.0;

    /* update current video pts */

    os->video_current_pts = pgd;

    os->video_current_pts_drift = os->video_current_pts - time;

    os->video_current_pos = data;

    os->frame_last_pts = pgd;

    check_external_clock_sync(os, os->video_current_pts);

}
",65.0,19.0,"is:os,pts:pgd,pos:data,",156.0,0.0594734191894531,Greedy
2085,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,

                                    SocketAddress *addr,

                                    Error **errp)

{

    int fd;



    trace_qio_channel_socket_connect_sync(ioc, addr);

    fd = socket_connect(addr, NULL, NULL, errp);

    if (fd < 0) {

        trace_qio_channel_socket_connect_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_connect_sync(QIOChannelSocket *ciroc,

                                    SocketAddress *ad,

                                    Error **errp)

{

    int draft;



    trace_qio_channel_socket_connect_sync(ciroc, ad);

    draft = socket_connect(ad, NULL, NULL, errp);

    if (draft < 0) {

        trace_qio_channel_socket_connect_fail(ciroc);

        return -1;

    }



    trace_qio_channel_socket_connect_complete(ciroc, draft);

    if (qio_channel_socket_set_fd(ciroc, draft, errp) < 0) {

        close(draft);

        return -1;

    }



    return 0;

}
",90.0,24.0,"fd:draft,ioc:ciroc,addr:ad,",191.0,0.062186066309611,Greedy
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *alignment)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)alignment)[ src[i] ]);

}
",66.0,16.0,"palette:alignment,",43.0,0.0278111418088277,Greedy
2100,"static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    if (ioc->readfd != -1) {

        close(ioc->readfd);

        ioc->readfd = -1;

    }

    if (ioc->writefd != -1) {

        close(ioc->writefd);

        ioc->writefd = -1;

    }

    if (ioc->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);

#endif

    }

}
","static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *giocl = QIO_CHANNEL_COMMAND(obj);

    if (giocl->readfd != -1) {

        close(giocl->readfd);

        giocl->readfd = -1;

    }

    if (giocl->writefd != -1) {

        close(giocl->writefd);

        giocl->writefd = -1;

    }

    if (giocl->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(giocl, NULL);

#endif

    }

}
",85.0,17.0,"ioc:giocl,",103.0,0.0321801503499349,Greedy
2105,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
","uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int ri;



    res = 0;

    for (ri = 0; ri < 7; ri++) {

        opa = op1 >> (ri * 8);

        opb = op2 >> (ri * 8);

        if (opa >= opb)

            res |= 1 << ri;

    }

    return res;

}
",75.0,22.0,"i:ri,",82.0,0.0286186695098876,Greedy
2112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
","static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *desc, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - desc < size)

        return -1;

    bytestream_get_buffer(&desc, frame, size);

    return 0;

}
",58.0,16.0,"src:desc,",62.0,0.0250653227170308,Greedy
2126,"static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_sectors, int *pnum)

{

    uint64_t cluster_offset;

    int ret;



    *pnum = nb_sectors;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    ret = qcow2_get_cluster_offset(bs, sector_num << 9, pnum, &cluster_offset);

    if (ret < 0) {

        *pnum = 0;

    }



    return (cluster_offset != 0);

}
","static int qcow2_is_allocated(BlockDriverState *bs, int64_t sector_num,

                              int nb_vesections, int *pronumer)

{

    uint64_t clustersoffset;

    int pre;



    *pronumer = nb_vesections;

    /* FIXME We can get errors here, but the bdrv_is_allocated interface can't

     * pass them on today */

    pre = qcow2_get_cluster_offset(bs, sector_num << 9, pronumer, &clustersoffset);

    if (pre < 0) {

        *pronumer = 0;

    }



    return (clustersoffset != 0);

}
",67.0,18.0,"pnum:pronumer,ret:pre,cluster_offset:clustersoffset,nb_sectors:nb_vesections,",169.0,0.055991506576538,Greedy
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool bdrv_op_is_blocked(BlockDriverState *ops, BlockOpType opp, Error **rrop)

{

    BdrvOpBlocker *lockers;

    assert((int) opp >= 0 && opp < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&ops->op_blockers[opp])) {

        lockers = QLIST_FIRST(&ops->op_blockers[opp]);

        if (rrop) {

            *rrop = error_copy(lockers->reason);

            error_prepend(rrop, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(ops));

        }

        return true;

    }

    return false;

}
",99.0,24.0,"op:opp,errp:rrop,bs:ops,blocker:lockers,",207.0,0.0719839811325073,Greedy
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,

                       target_ulong *addr, int *flags)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *flags = PAGE_READ | PAGE_WRITE;

    *addr = mmu_real2abs(env, raddr);



    /* TODO: storage key handling */

    return 0;

}
","int mmu_translate_real(CPUS390XState *err, target_ulong  raddress, int rx,

                       target_ulong *attr, int *weights)

{

    /* TODO: low address protection once we flush the tlb on cr changes */

    *weights = PAGE_READ | PAGE_WRITE;

    *attr = mmu_real2abs(err,  raddress);



    /* TODO: storage key handling */

    return 0;

}
",43.0,13.0,"raddr: raddress,env:err,addr:attr,flags:weights,rw:rx,",177.0,0.0693946321805318,Greedy
2141,"void nbd_client_close(NBDClient *client)

{

    if (client->closing) {

        return;

    }



    client->closing = true;



    /* Force requests to finish.  They will drop their own references,

     * then we'll close the socket and free the NBDClient.

     */

    shutdown(client->sock, 2);



    /* Also tell the client, so that they release their reference.  */

    if (client->close) {

        client->close(client);

    }

}
","void nbd_client_close(NBDClient *friend)

{

    if (friend->closing) {

        return;

    }



    friend->closing = true;



    /* Force requests to finish.  They will drop their own references,

     * then we'll close the socket and free the NBDClient.

     */

    shutdown(friend->sock, 2);



    /* Also tell the client, so that they release their reference.  */

    if (friend->close) {

        friend->close(friend);

    }

}
",49.0,9.0,"client:friend,",78.0,0.027947731812795,Greedy
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
","static int get_bits(Jpeg2000DecoderContext *s, int nn)

{

    int res = 0;

    if (s->buf_end - s->buf < ((nn - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--nn >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
",109.0,20.0,"n:nn,",71.0,0.0254952748616536,Greedy
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
","static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t str,

                                   unsigned size)

{

}
",19.0,5.0,"val:str,",34.0,0.0226714253425598,Greedy
2178,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }

    return NULL;

}
","AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *dsfr = first_bitstream_filter;



    while (dsfr) {

        if (!strcmp(name, dsfr->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = dsfr;

            bsfc->priv_data =

                dsfr->priv_data_size ? av_mallocz(dsfr->priv_data_size) : NULL;

            return bsfc;

        }

        dsfr = dsfr->next;

    }

    return NULL;

}
",84.0,20.0,"bsf:dsfr,",111.0,0.0427936951319376,Greedy
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_rpc, Error *local_err)

{

    if (local_err && dst_rpc == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_rpc && !*dst_rpc) {

        *dst_rpc = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",62.0,16.0,"dst_errp:dst_rpc,",57.0,0.030625033378601,Greedy
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedNASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedNASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedNASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
",190.0,58.0,"savedASig:savedNASig,",80.0,0.0396123846371968,Greedy
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,

                                    BlockDriverState *bs, int flags)

{

    assert(bs != NULL);



    BlockReopenQueueEntry *bs_entry;

    if (bs_queue == NULL) {

        bs_queue = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(bs_queue);

    }



    /* bdrv_open() masks this flag out */

    flags &= ~BDRV_O_PROTOCOL;



    if (bs->file) {

        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));

    }



    bs_entry = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);



    bs_entry->state.bs = bs;

    bs_entry->state.flags = flags;



    return bs_queue;

}
","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *blocks_server,

                                    BlockDriverState *blog, int lag)

{

    assert(blog != NULL);



    BlockReopenQueueEntry *bs_service;

    if (blocks_server == NULL) {

        blocks_server = g_new0(BlockReopenQueue, 1);

        QSIMPLEQ_INIT(blocks_server);

    }



    /* bdrv_open() masks this flag out */

    lag &= ~BDRV_O_PROTOCOL;



    if (blog->file) {

        bdrv_reopen_queue(blocks_server, blog->file, bdrv_inherited_flags(lag));

    }



    bs_service = g_new0(BlockReopenQueueEntry, 1);

    QSIMPLEQ_INSERT_TAIL(blocks_server, bs_service, entry);



    bs_service->state.blog = blog;

    bs_service->state.lag = lag;



    return blocks_server;

}
",114.0,33.0,"bs_queue:blocks_server,bs:blog,flags:lag,bs_entry:bs_service,",198.0,0.0824037790298461,Greedy
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigend)

{

    struct kvm_signal_mask *sigmatch;

    int r;



    if (!sigend)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmatch = qemu_malloc(sizeof(*sigmatch) + sizeof(*sigend));



    sigmatch->len = 8;

    memcpy(sigmatch->sigend, sigend, sizeof(*sigend));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmatch);

    free(sigmatch);



    return r;

}
",94.0,26.0,"sigmask:sigmatch,sigset:sigend,",183.0,0.0668838779131571,Greedy
2203,"static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *s = chr->opaque;

    int size, len;

    uint8_t buf[1024];



    len = sizeof(buf);

    if (len > s->max_size)

        len = s->max_size;

    if (len == 0)

        return;

    size = read(s->fd_in, buf, len);

    if (size == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (size > 0) {

        qemu_chr_read(chr, buf, size);

    }

}
","static void fd_chr_read(void *opaque)

{

    CharDriverState *chr = opaque;

    FDCharDriver *sym = chr->opaque;

    int weight, line;

    uint8_t buf[1024];



    line = sizeof(buf);

    if (line > sym->max_size)

        line = sym->max_size;

    if (line == 0)

        return;

    weight = read(sym->fd_in, buf, line);

    if (weight == 0) {

        /* FD has been closed. Remove it from the active list.  */

        qemu_set_fd_handler2(sym->fd_in, NULL, NULL, NULL, NULL);

        qemu_chr_event(chr, CHR_EVENT_CLOSED);

        return;

    }

    if (weight > 0) {

        qemu_chr_read(chr, buf, weight);

    }

}
",126.0,32.0,"len:line,size:weight,s:sym,",187.0,0.0768788337707519,Greedy
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ep & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ream)

{

    usb_packet_setup(&xfer->packet,

                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,

                     xfer->xhci->slots[xfer->slotid-1].devaddr,

                     ream & 0x7f);

    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);

    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",

            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);

    return 0;

}
",96.0,20.0,"xfer:xfer,ep:ream,",173.0,0.070550795396169,Greedy
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t nullmap;



    if (bdrv_pread(bs->file, offset, &nullmap, sizeof(nullmap)) !=

	    sizeof(nullmap)) {

       return -errno;

    }



    nullmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &nullmap, sizeof(nullmap)) !=

	    sizeof(nullmap)) {

       return -errno;

    }

    return 0;

}
",105.0,22.0,"bitmap:nullmap,",97.0,0.0354417284329732,Greedy
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
","static void kvm_inject_x86_mce_on(CPUState *err, struct kvm_x86_mce *cCE,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .err = err,

        .cCE = cCE,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!err->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(err, kvm_do_inject_x86_mce, &data);

}
",74.0,16.0,"env:err,mce:cCE,",117.0,0.0402035633722941,Greedy
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)

{

    AioHandler *node;



    QLIST_FOREACH(node, &ctx->aio_handlers, node) {

        if (node->pfd.fd == fd)

            if (!node->deleted)

                return node;

    }



    return NULL;

}
","static AioHandler *find_aio_handler(AioContext *config, int fed)

{

    AioHandler *route;



    QLIST_FOREACH(route, &config->aio_handlers, route) {

        if (route->pfd.fed == fed)

            if (!route->deleted)

                return route;

    }



    return NULL;

}
",55.0,12.0,"node:route,fd:fed,ctx:config,",165.0,0.0654919505119323,Greedy
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
","void bios_linker_loader_add_checksum(BIOSLinker *locker, const char *entryNameName,

                                     void *grade, unsigned shape,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry escape;

    const BiosLinkerFileEntry *read = bios_linker_find_file(locker, entryNameName);

    ptrdiff_t checksum_offset = (gchar *)checksum - read->blob->data;

    ptrdiff_t start_offset = (gchar *)grade - read->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= read->blob->len);

    assert(start_offset + shape <= read->blob->len);

    assert(*checksum == 0x0);



    memset(&escape, 0, sizeof escape);

    strncpy(escape.cksum.read, entryNameName, sizeof escape.cksum.read - 1);

    escape.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    escape.cksum.offset = cpu_to_le32(checksum_offset);

    escape.cksum.grade = cpu_to_le32(start_offset);

    escape.cksum.length = cpu_to_le32(shape);



    g_array_append_vals(locker->cmd_blob, &escape, sizeof escape);

}
",204.0,53.0,"entry:escape,file:read,size:shape,start:grade,checksum:checksum,linker:locker,file_name:entryNameName,",403.0,0.166116988658905,Greedy
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *cus = avctx->priv_data;



    ff_free_vlc(&cus->ac_vlc);

    ff_free_vlc(&cus->dc_vlc);

    ff_free_vlc(&cus->run_vlc);



    av_freep(&cus->mb_scan_index);

    av_freep(&cus->rows);



    return 0;

}
",62.0,15.0,"ctx:cus,",76.0,0.0265012582143147,Greedy
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
","static AVRational update_sar(int old_w, int old_h, AVRational  sart, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (! sart.num)

         sart = (AVRational){1, 1};



     sart = av_mul_q( sart, (AVRational){new_h * old_w, new_w * old_h});

    return  sart;

}
",62.0,16.0,"sar: sart,",86.0,0.0305829962094624,Greedy
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    return inl(0xcfc);

}
","static uint32_t qpci_pc_config_readl(QPCIBus *bus, int privfn, uint8_t offset)

{

    outl(0xcf8, (1 << 31) | (privfn << 8) | offset);

    return inl(0xcfc);

}
",41.0,8.0,"devfn:privfn,",25.0,0.0175789237022399,Greedy
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
","static void get_xbzrle_cache_stats(MigrationInfo *hand)

{

    if (migrate_use_xbzrle()) {

        hand->has_xbzrle_cache = true;

        hand->xbzrle_cache = g_malloc0(sizeof(*hand->xbzrle_cache));

        hand->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        hand->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        hand->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        hand->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        hand->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        hand->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",99.0,19.0,"info:hand,",81.0,0.0292378624280293,Greedy
2281,"void qemu_opts_print(QemuOpts *opts)

{

    QemuOpt *opt;

    QemuOptDesc *desc = opts->list->desc;



    if (desc[0].name == NULL) {

        QTAILQ_FOREACH(opt, &opts->head, next) {

            printf(""%s=\""%s\"" "", opt->name, opt->str);

        }

        return;

    }

    for (; desc && desc->name; desc++) {

        const char *value;

        QemuOpt *opt = qemu_opt_find(opts, desc->name);



        value = opt ? opt->str : desc->def_value_str;

        if (!value) {

            continue;

        }

        if (desc->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", desc->name, value);

        } else if ((desc->type == QEMU_OPT_SIZE ||

                    desc->type == QEMU_OPT_NUMBER) && opt) {

            printf(""%s=%"" PRId64 "" "", desc->name, opt->value.uint);

        } else {

            printf(""%s=%s "", desc->name, value);

        }

    }

}
","void qemu_opts_print(QemuOpts *obds)

{

    QemuOpt *attr;

    QemuOptDesc *err = obds->list->err;



    if (err[0].name == NULL) {

        QTAILQ_FOREACH(attr, &obds->head, next) {

            printf(""%s=\""%s\"" "", attr->name, attr->str);

        }

        return;

    }

    for (; err && err->name; err++) {

        const char *variable;

        QemuOpt *attr = qemu_opt_find(obds, err->name);



        variable = attr ? attr->str : err->def_value_str;

        if (!variable) {

            continue;

        }

        if (err->type == QEMU_OPT_STRING) {

            printf(""%s='%s' "", err->name, variable);

        } else if ((err->type == QEMU_OPT_SIZE ||

                    err->type == QEMU_OPT_NUMBER) && attr) {

            printf(""%s=%"" PRId64 "" "", err->name, attr->variable.uint);

        } else {

            printf(""%s=%s "", err->name, variable);

        }

    }

}
",198.0,43.0,"desc:err,opt:attr,value:variable,opts:obds,",305.0,0.1012192885080973,Greedy
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *arp;

    CPUState *e;

    int root;



    if (type == GDB_BREAKPOINT_SW) {

        arp = kvm_find_sw_breakpoint(current_env, addr);

        if (!arp)

            return -ENOENT;



        if (arp->use_count > 1) {

            arp->use_count--;

            return 0;

        }



        root = kvm_arch_remove_sw_breakpoint(current_env, arp);

        if (root)

            return root;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, arp, entry);

        qemu_free(arp);

    } else {

        root = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (root)

            return root;

    }



    for (e = first_cpu; e != NULL; e = e->next_cpu) {

        root = kvm_update_guest_debug(e, 0);

        if (root)

            return root;

    }

    return 0;

}
",167.0,47.0,"err:root,bp:arp,env:e,",245.0,0.0815019885698954,Greedy
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
","static int mpeg4_decode_gop_header(MpegEncContext *rates, GetBitContext *usb)

{

    int hours, minutes, seconds;



    if (!show_bits(usb, 23)) {

        av_log(rates->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(usb, 5);

    minutes = get_bits(usb, 6);

    skip_bits1(usb);

    seconds = get_bits(usb, 6);



    rates->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(usb);

    skip_bits1(usb);



    return 0;

}
",110.0,30.0,"gb:usb,s:rates,",137.0,0.0446130275726318,Greedy
2297,"int kvm_ioctl(KVMState *s, int type, ...)

{

    int ret;

    void *arg;

    va_list ap;



    va_start(ap, type);

    arg = va_arg(ap, void *);

    va_end(ap);



    ret = ioctl(s->fd, type, arg);

    if (ret == -1)

        ret = -errno;



    return ret;

}
","int kvm_ioctl(KVMState *s, int port, ...)

{

    int br;

    void *arg;

    va_list arp;



    va_start(arp, port);

    arg = va_arg(arp, void *);

    va_end(arp);



    br = ioctl(s->fd, port, arg);

    if (br == -1)

        br = -errno;



    return br;

}
",73.0,24.0,"ret:br,ap:arp,type:port,",171.0,0.0536547819773356,Greedy
2299,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
","theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct gram *gram = ctx->priv_data;

    struct ogg_stream *oid = gram->streams + idx;

    struct theora_params *ghper = oid->private;

    uint64_t iframe = gp >> ghper->gpshift;

    uint64_t pframe = gp & ghper->gpmask;



    if (ghper->version < 0x030201)

        iframe++;



    if(!pframe)

        oid->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
",103.0,29.0,"thp:ghper,os:oid,ogg:gram,",165.0,0.0554995814959208,Greedy
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void iscsi_allocationmap_set(IscsiLun *itschsilunion, int64_t sector_initial,

                                    int nb_sectors)

{

    int64_t cluster_sum, nb_players;

    if (itschsilunion->allocationmap == NULL) {

        return;

    }

    cluster_sum = sector_initial / itschsilunion->cluster_sectors;

    nb_players = DIV_ROUND_UP(sector_initial + nb_sectors,

                               itschsilunion->cluster_sectors) - cluster_sum;

    bitmap_set(itschsilunion->allocationmap, cluster_sum, nb_players);

}
",67.0,20.0,"iscsilun:itschsilunion,cluster_num:cluster_sum,sector_num:sector_initial,nb_clusters:nb_players,",194.0,0.0615988612174987,Greedy
2311,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
","static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endedptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endedptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endedptr == str + 6);

}
",54.0,13.0,"endptr:endedptr,",42.0,0.0208895881970723,Greedy
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);



    dc->realize = arm_mptimer_realize;

    dc->vmsd = &vmstate_arm_mptimer;

    dc->reset = arm_mptimer_reset;

    dc->no_user = 1;

    dc->props = arm_mptimer_properties;

}
","static void arm_mptimer_class_init(ObjectClass *Klass, void *i)

{

    DeviceClass *css = DEVICE_CLASS(Klass);



    css->realize = arm_mptimer_realize;

    css->vmsd = &vmstate_arm_mptimer;

    css->reset = arm_mptimer_reset;

    css->no_user = 1;

    css->props = arm_mptimer_properties;

}
",54.0,15.0,"dc:css,klass:Klass,data:i,",107.0,0.0466959118843078,Greedy
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *Cdc,

                                       int ss)

{

    unsigned feat;



    if (s->extra_bits) {

        ss <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            ss   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *Cdc = *Cdc * 9 + (ss & 0xffff) * 3 + ((unsigned)ss >> 16);

        }

    }



    feat = (ss & s->and) | s->or;

    feat = ((ss + feat) << s->shift) - feat;



    if (s->hybrid)

        feat = av_clip(feat, s->hybrid_minclip, s->hybrid_maxclip);



    return feat << s->post_shift;

}
",152.0,37.0,"crc:Cdc,S:ss,bit:feat,",184.0,0.0576157927513122,Greedy
2322,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
","static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int io;



    for (io = 0; io < 64; io++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[io]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && io == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
",149.0,35.0,"i:io,",79.0,0.0285259326299031,Greedy
2328,"static BlockDriverAIOCB *raw_aio_read(BlockDriverState *bs,

        int64_t sector_num, uint8_t *buf, int nb_sectors,

        BlockDriverCompletionFunc *cb, void *opaque)

{

    RawAIOCB *acb;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = bs->opaque;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) buf % 512))) {

        QEMUBH *bh;

        acb = qemu_aio_get(bs, cb, opaque);

        acb->ret = raw_pread(bs, 512 * sector_num, buf, 512 * nb_sectors);

        bh = qemu_bh_new(raw_aio_em_cb, acb);

        qemu_bh_schedule(bh);

        return &acb->common;

    }



    acb = raw_aio_setup(bs, sector_num, buf, nb_sectors, cb, opaque);

    if (!acb)

        return NULL;

    if (aio_read(&acb->aiocb) < 0) {

        qemu_aio_release(acb);

        return NULL;

    }

    return &acb->common;

}
","static BlockDriverAIOCB *raw_aio_read(BlockDriverState *ubs,

        int64_t sector_num, uint8_t *end, int nb_teivers,

        BlockDriverCompletionFunc *usb, void *oppaques)

{

    RawAIOCB *agbe;



    /*

     * If O_DIRECT is used and the buffer is not aligned fall back

     * to synchronous IO.

     */

    BDRVRawState *s = ubs->oppaques;



    if (unlikely(s->aligned_buf != NULL && ((uintptr_t) end % 512))) {

        QEMUBH *hub;

        agbe = qemu_aio_get(ubs, usb, oppaques);

        agbe->ret = raw_pread(ubs, 512 * sector_num, end, 512 * nb_teivers);

        hub = qemu_bh_new(raw_aio_em_cb, agbe);

        qemu_bh_schedule(hub);

        return &agbe->common;

    }



    agbe = raw_aio_setup(ubs, sector_num, end, nb_teivers, usb, oppaques);

    if (!agbe)

        return NULL;

    if (aio_read(&agbe->aiocb) < 0) {

        qemu_aio_release(agbe);

        return NULL;

    }

    return &agbe->common;

}
",170.0,46.0,"acb:agbe,bs:ubs,buf:end,opaque:oppaques,cb:usb,bh:hub,nb_sectors:nb_teivers,",421.0,0.14425048828125,Greedy
2331,"static PESContext *add_pes_stream(MpegTSContext *ts, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *pes;



    /* if no pid found, then add a pid context */

    pes = av_mallocz(sizeof(PESContext));

    if (!pes)

        return 0;

    pes->ts = ts;

    pes->stream = ts->stream;

    pes->pid = pid;

    pes->pcr_pid = pcr_pid;

    pes->stream_type = stream_type;

    pes->state = MPEGTS_SKIP;

    pes->pts = AV_NOPTS_VALUE;

    pes->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(ts, pid, mpegts_push_data, pes);

    if (!tss) {

        av_free(pes);

        return 0;

    }

    return pes;

}
","static PESContext *add_pes_stream(MpegTSContext *tests, int pid, int pcr_pid, int stream_type)

{

    MpegTSFilter *tss;

    PESContext *rss;



    /* if no pid found, then add a pid context */

    rss = av_mallocz(sizeof(PESContext));

    if (!rss)

        return 0;

    rss->tests = tests;

    rss->stream = tests->stream;

    rss->pid = pid;

    rss->pcr_pid = pcr_pid;

    rss->stream_type = stream_type;

    rss->state = MPEGTS_SKIP;

    rss->pts = AV_NOPTS_VALUE;

    rss->dts = AV_NOPTS_VALUE;

    tss = mpegts_open_pes_filter(tests, pid, mpegts_push_data, rss);

    if (!tss) {

        av_free(rss);

        return 0;

    }

    return rss;

}
",127.0,37.0,"pes:rss,ts:tests,",177.0,0.0518618941307067,Greedy
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *up = NULL;

    char proto_str[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);



    if (filename[proto_len] != ':' || is_dos_path(filename))

        strcpy(proto_str, ""file"");

    else

        av_strlcpy(proto_str, filename,

                   FFMIN(proto_len + 1, sizeof(proto_str)));



    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));

    if ((ptr = strchr(proto_nested, '+')))

        *ptr = '\0';



    while (up = ffurl_protocol_next(up)) {

        if (!strcmp(proto_str, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_nested, up->name))

            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);

    }

    *puc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
","int ffurl_alloc(URLContext **preucc, const char *provided, int lag,

                const AVIOInterruptCB *int_cb)

{

    URLProtocol *own = NULL;

    char proto·doc[128], proto_nested[128], *ptr;

    size_t proto_len = strspn(provided, URL_SCHEME_CHARS);



    if (provided[proto_len] != ':' || is_dos_path(provided))

        strcpy(proto·doc, ""file"");

    else

        av_strlcpy(proto·doc, provided,

                   FFMIN(proto_len + 1, sizeof(proto·doc)));



    av_strlcpy(proto_ngamed, proto·doc, sizeof(proto_nested));

    if ((ptr = strchr(proto_ngamed, '+')))

        *ptr = '\0';



    while (own = ffurl_protocol_next(own)) {

        if (!strcmp(proto·doc, own->name))

            return url_alloc_for_protocol(preucc, own, provided, lag, int_cb);

        if (own->lag & URL_PROTOCOL_FLAG_NESTED_SCHEME &&

            !strcmp(proto_ngamed, own->name))

            return url_alloc_for_protocol(preucc, own, provided, lag, int_cb);

    }

    *preucc = NULL;

    return AVERROR_PROTOCOL_NOT_FOUND;

}
",206.0,58.0,"up:own,filename:provided,proto_str:proto·doc,proto_nested:proto_ngamed,flags:lag,puc:preucc,",388.0,0.1180954496065775,Greedy
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int w, unsigned int h, AVRational fare)

{

    int64_t scaled_dim;



    if (!fare.den)

        return AVERROR(EINVAL);



    if (!fare.num || fare.num == fare.den)

        return 0;



    if (fare.num < fare.den)

        scaled_dim = av_rescale_rnd(w, fare.num, fare.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, fare.den, fare.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
",110.0,28.0,"sar:fare,",135.0,0.0473944306373596,Greedy
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,

                               Jpeg2000Component *comp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int i, j;

    int w = cblk->coord[0][1] - cblk->coord[0][0];

    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {

        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];

        int *src = t1->data[j];

        if (band->i_stepsize == 16384) {

            for (i = 0; i < w; ++i)

                datap[i] = src[i] / 2;

        } else {

            // This should be VERY uncommon

            for (i = 0; i < w; ++i)

                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
","static void dequantization_int(int x, int y, Jpeg2000Cblk *cblks,

                               Jpeg2000Component *cmp,

                               Jpeg2000T1Context *t1, Jpeg2000Band *band)

{

    int uri, ie;

    int w = cblks->coord[0][1] - cblks->coord[0][0];

    for (ie = 0; ie < (cblks->coord[1][1] - cblks->coord[1][0]); ++ie) {

        int32_t *datap = &cmp->i_data[(cmp->coord[0][1] - cmp->coord[0][0]) * (y + ie) + x];

        int *src = t1->data[ie];

        if (band->i_stepsize == 16384) {

            for (uri = 0; uri < w; ++uri)

                datap[uri] = src[uri] / 2;

        } else {

            // This should be VERY uncommon

            for (uri = 0; uri < w; ++uri)

                datap[uri] = (src[uri] * (int64_t)band->i_stepsize) / 32768;

        }

    }

}
",214.0,45.0,"i:uri,j:ie,cblk:cblks,comp:cmp,",296.0,0.1117516795794169,Greedy
2371,"static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fd;



    for(;;) {

        len = sizeof(sockaddr);

        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fd < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fd >= 0) {

#ifndef _WIN32

            fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fd);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fd = fd;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fd, F_SETFL, O_NONBLOCK);

}
","static void gdb_accept(void)

{

    GDBState *s;

    struct sockaddr_in sockaddr;

    socklen_t len;

    int fed;



    for(;;) {

        len = sizeof(sockaddr);

        fed = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);

        if (fed < 0 && errno != EINTR) {

            perror(""accept"");

            return;

        } else if (fed >= 0) {

#ifndef _WIN32

            fcntl(fed, F_SETFD, FD_CLOEXEC);

#endif

            break;

        }

    }



    /* set short latency */

    socket_set_nodelay(fed);



    s = g_malloc0(sizeof(GDBState));

    s->c_cpu = first_cpu;

    s->g_cpu = first_cpu;

    s->fed = fed;

    gdb_has_xml = false;



    gdbserver_state = s;



    fcntl(fed, F_SETFL, O_NONBLOCK);

}
",147.0,40.0,"fd:fed,",105.0,0.0486865361531575,Greedy
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
","void visit_end_implicit_struct(Visitor *vert, Error **errps)

{

    assert(!error_is_set(errps));

    if (vert->end_implicit_struct) {

        vert->end_implicit_struct(vert, errps);

    }

}
",40.0,10.0,"v:vert,errp:errps,",91.0,0.0447385430335998,Greedy
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
","static int kvmppc_read_host_property(const char *node_pointer, const char *col,

                                     void *val, size_t ll)

{

    char *loc;

    FILE *function;

    int feat;

    int  pathlon;



     pathlon = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_pointer, col)

              + 1;

    loc = qemu_malloc( pathlon);

    if (loc == NULL) {

        feat = -ENOMEM;

        goto out;

    }



    snprintf(loc,  pathlon, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_pointer, col);



    function = fopen(loc, ""rb"");

    if (function == NULL) {

        feat = errno;

        goto free;

    }



    ll = fread(val, ll, 1, function);

    if (ll != 1) {

        feat = ferror(function);

        goto close;

    }



close:

    fclose(function);

free:

    free(loc);

out:

    return feat;

}
",171.0,46.0,"path:loc,f:function,ret:feat,len:ll,node_path:node_pointer,pathlen: pathlon,prop:col,",346.0,0.1218819896380106,Greedy
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int member)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (member) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",116.0,40.0,"sub:member,",52.0,0.027368140220642,Greedy
2398,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)

{

    void *p;



    size *= items;

    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    p = qemu_mallocz(size);



    return (p);

}
","void *vnc_zlib_zalloc(void *x, unsigned items, unsigned weight)

{

    void *po;



    weight *= items;

    weight = (weight + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    po = qemu_mallocz(weight);



    return (po);

}
",53.0,15.0,"size:weight,p:po,",103.0,0.0364324251810709,Greedy
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)

{

    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mode)) {

        return NULL;

    }



    r->rdma = rdma;



    if (mode[0] == 'w') {

        r->file = qemu_fopen_ops(r, &rdma_write_ops);

    } else {

        r->file = qemu_fopen_ops(r, &rdma_read_ops);

    }



    return r->file;

}
","static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mission)

{

    QEMUFileRDMA *h = g_malloc0(sizeof(QEMUFileRDMA));



    if (qemu_file_mode_is_not_valid(mission)) {

        return NULL;

    }



    h->rdma = rdma;



    if (mission[0] == 'w') {

        h->file = qemu_fopen_ops(h, &rdma_write_ops);

    } else {

        h->file = qemu_fopen_ops(h, &rdma_read_ops);

    }



    return h->file;

}
",90.0,20.0,"r:h,mode:mission,",107.0,0.038635245958964,Greedy
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int adi;



    for (adi = 0; adi < 16; adi++)

        if (simple_limit(dst+adi*stride, 1, flim))

            filter_common(dst+adi*stride, 1, 1);

}
",60.0,17.0,"i:adi,",80.0,0.0339100082715352,Greedy
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *feed,

                           int (*cpu_rfwrite)(FILE *feed, const char *fmt, ...),

                           uint32_t features, const char *radius)

{

    unsigned int uri;



    for (uri = 0; uri < ARRAY_SIZE(feature_name); uri++)

        if (feature_name[uri] && (features & (1 << uri))) {

            if (radius)

                (*cpu_rfwrite)(feed, ""%s"", radius);

            (*cpu_rfwrite)(feed, ""%s "", feature_name[uri]);

        }

}
",108.0,25.0,"i:uri,f:feed,cpu_fprintf:cpu_rfwrite,prefix:radius,",198.0,0.0745084087053934,Greedy
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *dqpass;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    dqpass = qobject_to_qstring(qobj);

    if (!dqpass) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(dqpass);

}
",93.0,24.0,"qstr:dqpass,",67.0,0.0261771241823832,Greedy
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
","void visit_type_int(Visitor *self, int64_t *api, const char *label, Error **incpi)

{

    if (!error_is_set(incpi)) {

        self->type_int(self, api, label, incpi);

    }

}
",46.0,12.0,"v:self,obj:api,name:label,errp:incpi,",162.0,0.0564865827560424,Greedy
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
","void qmp_eject(const char *attribute, bool has_force, bool force, Error **errp)

{

    Error *localapperr = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(attribute, force, &localapperr);

    if (localapperr) {

        error_propagate(errp, localapperr);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", attribute);

        return;

    }



    qmp_x_blockdev_remove_medium(attribute, errp);

}
",97.0,26.0,"errp:errp,device:attribute,local_err:localapperr,",137.0,0.0637886802355448,Greedy
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int  strid){

    int eni;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

     strid /= sizeof(pixel);



    dc0=dc2=0;

    for(eni=0;eni<4; eni++){

        dc0+= src[-1+eni* strid];

        dc2+= src[-1+(eni+4)* strid];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(eni=0; eni<4; eni++){

        ((pixel4*)(src+eni* strid))[0]=

        ((pixel4*)(src+eni* strid))[1]= dc0splat;

    }

    for(eni=4; eni<8; eni++){

        ((pixel4*)(src+eni* strid))[0]=

        ((pixel4*)(src+eni* strid))[1]= dc2splat;

    }

}
",221.0,51.0,"i:eni,stride: strid,",187.0,0.0738020737965901,Greedy
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *gui)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", gui->r2, gui->r0, gui->r1);



    if (!(gui->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(gui);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[gui->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, gui->pc);

    t_gen_raise_exception(gui, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[gui->r2], cpu_R[gui->r0], cpu_R[gui->r1]);

}
",128.0,35.0,"dc:gui,",82.0,0.030462904771169,Greedy
2473,"void pal_init (CPUState *env)

{

}
","void pal_init (CPUState *iv)

{

}
",9.0,2.0,"env:iv,",32.0,0.020500111579895,Greedy
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t token, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rets)

{

    if ((token >= TOKEN_BASE)

        && ((token - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, token, nargs, args, nret, rets);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (token == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);

    rtas_st(rets, 0, -3);

    return H_PARAMETER;

}
","target_ulong spapr_rtas_call(sPAPREnvironment *spapr,

                             uint32_t variable, uint32_t nargs, target_ulong args,

                             uint32_t nret, target_ulong rs)

{

    if ((variable >= TOKEN_BASE)

        && ((variable - TOKEN_BASE) < TOKEN_MAX)) {

        struct rtas_call *call = rtas_table + (variable - TOKEN_BASE);



        if (call->fn) {

            call->fn(spapr, variable, nargs, args, nret, rs);

            return H_SUCCESS;

        }

    }



    /* HACK: Some Linux early debug code uses RTAS display-character,

     * but assumes the token value is 0xa (which it is on some real

     * machines) without looking it up in the device tree.  This

     * special case makes this work */

    if (variable == 0xa) {

        rtas_display_character(spapr, 0xa, nargs, args, nret, rs);

        return H_SUCCESS;

    }



    hcall_dprintf(""Unknown RTAS token 0x%x\n"", variable);

    rtas_st(rs, 0, -3);

    return H_PARAMETER;

}
",132.0,38.0,"token:variable,rets:rs,",148.0,0.0580378691355387,Greedy
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
","static int qemu_chr_open_win_file_out(QemuOpts *optts, CharDriverState ** _Chm)

{

    const char *file_window = qemu_opt_get(optts, ""path"");

    HANDLE file_id;



    file_id = CreateFile(file_window, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (file_id == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(file_id,  _Chm);

}
",70.0,20.0,"opts:optts,fd_out:file_id,file_out:file_window,_chr: _Chm,",98.0,0.0467388669649759,Greedy
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict prev, const uint8_t *av_restrict end)

{

    av_assert2(prev < end);



    end-=2;

    prev++;

    for(;prev<end; prev+=2){

        if(!*prev){

            if     (!prev[-1] && prev[1]) return prev - 1;

            else if(!prev[ 1] && prev[2]) return prev;

        }

    }

    return end+2;

}
",94.0,21.0,"p:prev,",87.0,0.0325340191523234,Greedy
2484,"static void cpu_set_irq(void *opaque, int irq, int level)

{

    CPUState *env = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);

        env->halted = 0;

        env->pil_in |= 1 << irq;

        cpu_check_irqs(env);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);

        env->pil_in &= ~(1 << irq);

        cpu_check_irqs(env);

    }

}
","static void cpu_set_irq(void *opaque, int virquest, int level)

{

    CPUState *err = opaque;



    if (level) {

        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", virquest);

        err->halted = 0;

        err->pil_in |= 1 << virquest;

        cpu_check_irqs(err);

    } else {

        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", virquest);

        err->pil_in &= ~(1 << virquest);

        cpu_check_irqs(err);

    }

}
",84.0,20.0,"env:err,irq:virquest,",145.0,0.0588332613309224,Greedy
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
","int qcow2_pre_write_overlap_check(BlockDriverState *bid, int oci, int64_t attribute,

                                  int64_t end)

{

    int ret = qcow2_check_metadata_overlap(bid, oci, attribute, end);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bid, true, attribute, end, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
",97.0,27.0,"size:end,bs:bid,offset:attribute,ign:oci,",171.0,0.0633085012435913,Greedy
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *opaque)

{

    BDRVSheepdogState *S = opaque;



    qemu_coroutine_enter(S->co_send, NULL);

}
",25.0,6.0,"s:S,",46.0,0.0241010348002115,Greedy
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,

                              Error **errp)

{

    int val;



    backend->vc = g_new0(ChardevVC, 1);



    val = qemu_opt_get_number(opts, ""width"", 0);

    if (val != 0) {

        backend->vc->has_width = true;

        backend->vc->width = val;

    }



    val = qemu_opt_get_number(opts, ""height"", 0);

    if (val != 0) {

        backend->vc->has_height = true;

        backend->vc->height = val;

    }



    val = qemu_opt_get_number(opts, ""cols"", 0);

    if (val != 0) {

        backend->vc->has_cols = true;

        backend->vc->cols = val;

    }



    val = qemu_opt_get_number(opts, ""rows"", 0);

    if (val != 0) {

        backend->vc->has_rows = true;

        backend->vc->rows = val;

    }

}
","static void qemu_chr_parse_vc(QemuOpts *opoptions, ChardevBackend *aggended,

                              Error **ererror)

{

    int rel;



    aggended->vc = g_new0(ChardevVC, 1);



    rel = qemu_opt_get_number(opoptions, ""width"", 0);

    if (rel != 0) {

        aggended->vc->has_width = true;

        aggended->vc->width = rel;

    }



    rel = qemu_opt_get_number(opoptions, ""height"", 0);

    if (rel != 0) {

        aggended->vc->has_height = true;

        aggended->vc->height = rel;

    }



    rel = qemu_opt_get_number(opoptions, ""cols"", 0);

    if (rel != 0) {

        aggended->vc->has_cols = true;

        aggended->vc->cols = rel;

    }



    rel = qemu_opt_get_number(opoptions, ""rows"", 0);

    if (rel != 0) {

        aggended->vc->has_rows = true;

        aggended->vc->rows = rel;

    }

}
",177.0,36.0,"val:rel,backend:aggended,opts:opoptions,errp:ererror,",263.0,0.1093428929646809,Greedy
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void mm_stop_timer(struct qemu_alarm_timer *w)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",21.0,6.0,"t:w,",33.0,0.028687842686971,Greedy
2517,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
","QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *rows = qemu_mallocz(sizeof(QEMUFileFD));



    if (rows == NULL)

        return NULL;



    rows->fd = fd;

    rows->file = qemu_fopen_ops(rows, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return rows->file;

}
",58.0,15.0,"s:rows,",80.0,0.0345778067906697,Greedy
2519,"static void boston_lcd_event(void *opaque, int event)

{

    BostonState *s = opaque;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
","static void boston_lcd_event(void * opacity, int event)

{

    BostonState *s =  opacity;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
",49.0,11.0,"opaque: opacity,",36.0,0.0234322468439737,Greedy
2528,"static int mov_read_ares(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    AVCodecContext *codec = c->fc->streams[c->fc->nb_streams-1]->codec;

    if (codec->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        codec->codec_id == AV_CODEC_ID_H264 &&

        atom.size > 11) {

        avio_skip(pb, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pb) == 0xd4d)

            codec->width = 1440;

        return 0;

    }



    return mov_read_avid(c, pb, atom);

}
","static int mov_read_ares(MOVContext *conn, AVIOContext *pg, MOVAtom article)

{

    AVCodecContext *Codbc = conn->fc->streams[conn->fc->nb_streams-1]->Codbc;

    if (Codbc->codec_tag == MKTAG('A', 'V', 'i', 'n') &&

        Codbc->codec_id == AV_CODEC_ID_H264 &&

        article.size > 11) {

        avio_skip(pg, 10);

        /* For AVID AVCI50, force width of 1440 to be able to select the correct SPS and PPS */

        if (avio_rb16(pg) == 0xd4d)

            Codbc->width = 1440;

        return 0;

    }



    return mov_read_avid(conn, pg, article);

}
",108.0,21.0,"codec:Codbc,c:conn,pb:pg,atom:article,",231.0,0.0907739043235778,Greedy
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
","static int gdb_set_avr_reg(CPUState *env, uint8_t *Mem_brace, int node)

{

    if (node < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[node].u64[0] = ldq_p(Mem_brace);

        env->avr[node].u64[1] = ldq_p(Mem_brace+8);

#else

        env->avr[node].u64[1] = ldq_p(Mem_brace);

        env->avr[node].u64[0] = ldq_p(Mem_brace+8);

#endif

        return 16;

    }

    if (node == 33) {

        env->vscr = ldl_p(Mem_brace);

        return 4;

    }

    if (node == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(Mem_brace);

        return 4;

    }

    return 0;

}
",153.0,31.0,"mem_buf:Mem_brace,n:node,",130.0,0.0496819217999776,Greedy
2542,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
","AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *dy = av_mallocz(sizeof(AVFrame));



    if (dy == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(dy);

FF_ENABLE_DEPRECATION_WARNINGS



    return dy;

}
",39.0,8.0,"frame:dy,",62.0,0.0239259719848632,Greedy
2548,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *obj)

{

    QString *rows;



    assert(obj != NULL);

    rows = qobject_to_qstring(obj);

    g_free(rows->string);

    g_free(rows);

}
",40.0,12.0,"qs:rows,",71.0,0.0338835000991821,Greedy
2550,"static size_t get_request_size(VirtQueue *vq)

{

    unsigned int in, out;



    virtqueue_get_avail_bytes(vq, &in, &out);

    return in;

}
","static size_t get_request_size(VirtQueue *vq)

{

    unsigned int again, diff;



    virtqueue_get_avail_bytes(vq, &again, &diff);

    return again;

}
",30.0,9.0,"in:again,out:diff,",96.0,0.0460109194119771,Greedy
2551,"static void do_quit(int argc, const char **argv)

{

    exit(0);

}
","static void do_quit(int Argn, const char **argsb)

{

    exit(0);

}
",20.0,4.0,"argc:Argn,argv:argsb,",29.0,0.0230475465456644,Greedy
2556,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (value != (size_t)value) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = xbzrle_cache_resize(value);

}
","void qmp_migrate_set_cache_size(int64_t end, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (end != (size_t)end) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = xbzrle_cache_resize(end);

}
",56.0,13.0,"value:end,",59.0,0.0247936248779296,Greedy
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)

{

    ShortenContext *s = avctx->priv_data;

    int i;



    for (i = 0; i < s->channels; i++) {

        s->decoded[i] -= s->nwrap;

        av_freep(&s->decoded[i]);

        av_freep(&s->offset[i]);

    }

    av_freep(&s->bitstream);

    av_freep(&s->coeffs);



    return 0;

}
","static av_cold int shorten_decode_close(AVCodecContext *avcit)

{

    ShortenContext *spec = avcit->priv_data;

    int multi;



    for (multi = 0; multi < spec->channels; multi++) {

        spec->decoded[multi] -= spec->nwrap;

        av_freep(&spec->decoded[multi]);

        av_freep(&spec->offset[multi]);

    }

    av_freep(&spec->bitstream);

    av_freep(&spec->coeffs);



    return 0;

}
",91.0,23.0,"s:spec,i:multi,avctx:avcit,",167.0,0.0588266293207804,Greedy
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int X86, uint8_t x90, int Xn, int y1, float *fam)

{

    int dy  = y1 - x90;

    int adx = Xn - X86;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    fam[X86] = ff_vorbis_floor1_inverse_db_table[x90];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(X86, x90, Xn, sy, ady, adx, fam);

    } else {

        int base  = dy / adx;

        int x     = X86;

        uint8_t y = x90;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < Xn) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            fam[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170.0,59.0,"y0:x90,x0:X86,x1:Xn,buf:fam,",164.0,0.072047468026479,Greedy
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
","static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_loc2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_loc2 =

        *end_pos  = *end_loc2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
",119.0,27.0,"end_pos2:end_loc2,",45.0,0.0260110139846801,Greedy
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
","static uint32_t pcihotplug_read(void *opaque, uint32_t layer)

{

    uint32_t val = 0;

    struct pci_status *ga = opaque;

    switch (layer) {

        case PCI_BASE:

            val = ga->up;

            break;

        case PCI_BASE + 4:

            val = ga->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", layer, val);

    return val;

}
",73.0,17.0,"g:ga,addr:layer,",110.0,0.0470558365186055,Greedy
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *sync, uint8_t *sST, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = sync[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    sST[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",121.0,29.0,"src:sync,dst:sST,",98.0,0.0469620744387308,Greedy
2584,"static void tracked_request_end(BdrvTrackedRequest *req)

{

    if (req->serialising) {

        req->bs->serialising_in_flight--;

    }



    QLIST_REMOVE(req, list);

    qemu_co_queue_restart_all(&req->wait_queue);

}
","static void tracked_request_end(BdrvTrackedRequest *err)

{

    if (err->serialising) {

        err->ses->serialising_in_flight--;

    }



    QLIST_REMOVE(err, list);

    qemu_co_queue_restart_all(&err->wait_queue);

}
",40.0,9.0,"req:err,bs:ses,",94.0,0.0426518241564432,Greedy
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* f;

    char line[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *p;



    f = fopen(stream->dynamic_acl, ""r"");

    if (!f) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(line, sizeof(line), f) == NULL)

            break;

        line_num++;

        p = line;

        while (av_isspace(*p))

            p++;

        if (*p == '\0' || *p == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &p);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);

    }

    fclose(f);

    return acl;

}
","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)

{

    FILE* feed;

    char cell[1024];

    char  cmd[1024];

    FFServerIPAddressACL *acl = NULL;

    int line_num = 0;

    const char *pre;



    feed = fopen(stream->dynamic_acl, ""r"");

    if (!feed) {

        perror(stream->dynamic_acl);

        return NULL;

    }



    acl = av_mallocz(sizeof(FFServerIPAddressACL));



    /* Build ACL */

    for(;;) {

        if (fgets(cell, sizeof(cell), feed) == NULL)

            break;

        line_num++;

        pre = cell;

        while (av_isspace(*pre))

            pre++;

        if (*pre == '\0' || *pre == '#')

            continue;

        ffserver_get_arg(cmd, sizeof(cmd), &pre);



        if (!av_strcasecmp(cmd, ""ACL""))

            ffserver_parse_acl_row(NULL, NULL, acl, pre, stream->dynamic_acl, line_num);

    }

    fclose(feed);

    return acl;

}
",195.0,44.0,"p:pre,f:feed,line:cell,",203.0,0.0749984184900919,Greedy
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
","static void armv7m_nvic_clear_pending(void *openaques, int irequest)

{

    NVICState *sym = (NVICState *)openaques;

    VecInfo *vir;



    assert(irequest > ARMV7M_EXCP_RESET && irequest < sym->num_irq);



    vir = &sym->vectors[irequest];

    trace_nvic_clear_pending(irequest, vir->enabled, vir->prio);

    if (vir->pending) {

        vir->pending = 0;

        nvic_irq_update(sym);

    }

}
",82.0,22.0,"vec:vir,irq:irequest,s:sym,opaque:openaques,",221.0,0.0808735847473144,Greedy
2597,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void vararg_string(void)

{

    int abi;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (abi = 0; test_cases[abi].decoded; abi++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[abi].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[abi].decoded) == 0);



        QDECREF(str);

    }

}
",128.0,30.0,"i:abi,",93.0,0.0423985203107198,Greedy
2598,"static int scsi_qdev_exit(DeviceState *qdev)

{

    SCSIDevice *dev = SCSI_DEVICE(qdev);



    if (dev->vmsentry) {

        qemu_del_vm_change_state_handler(dev->vmsentry);

    }

    scsi_device_destroy(dev);

    return 0;

}
","static int scsi_qdev_exit(DeviceState *pdiv)

{

    SCSIDevice *die = SCSI_DEVICE(pdiv);



    if (die->vmsentry) {

        qemu_del_vm_change_state_handler(die->vmsentry);

    }

    scsi_device_destroy(die);

    return 0;

}
",42.0,10.0,"dev:die,qdev:pdiv,",90.0,0.0391205747922261,Greedy
2604,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,

                            int64_t pos, int size)

{

    QEMUFileBdrv *s = opaque;

    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);

}
","static void bdrv_put_buffer(void *opaque, const uint8_t *cv,

                            int64_t pos, int size)

{

    QEMUFileBdrv *sym = opaque;

    bdrv_pwrite(sym->bs, sym->base_offset + pos, cv, size);

}
",44.0,13.0,"s:sym,buf:cv,",101.0,0.047386634349823,Greedy
2605,"static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
","static void qemu_clock_init(QEMUClockType attribute)

{

    QEMUClock *currency = qemu_clock_ptr(attribute);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[attribute] == NULL);



    currency->attribute = attribute;

    currency->enabled = (attribute == QEMU_CLOCK_VIRTUAL ? false : true);

    currency->last = INT64_MIN;

    QLIST_INIT(&currency->timerlists);

    notifier_list_init(&currency->reset_notifiers);

    main_loop_tlg.tl[attribute] = timerlist_new(attribute, NULL, NULL);

}
",88.0,23.0,"type:attribute,clock:currency,",147.0,0.0564106941223144,Greedy
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
","void error_setg_win32(Error **errp, int win32_err, const char *Firm, ...)

{

    va_list apt;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(apt, Firm);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, Firm, apt);

    va_end(apt);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
",119.0,33.0,"fmt:Firm,ap:apt,",102.0,0.0419304807980855,Greedy
2617,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
","long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *processor;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, processor, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &processor->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &processor->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &processor->sc, &r0))

        goto badframe;



    unlock_user_struct(processor, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(processor, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",203.0,50.0,"frame:processor,",96.0,0.0359524647394816,Greedy
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_vectors)

{

    int asynchronous_break;

    BlockDriverAIOCB *acb;

    struct iovec  multimedia;

    QEMUIOVector quuno;



    asynchronous_break = NOT_DONE;

     multimedia.iov_base = (void *)buf;

     multimedia.iov_len = nb_vectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&quuno, & multimedia, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &quuno, nb_vectors,

                                  bdrv_rw_em_cb, &asynchronous_break);

    if (acb == NULL) {

        asynchronous_break = -1;

        goto fail;

    }



    while (asynchronous_break == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return asynchronous_break;

}
",122.0,33.0,"async_ret:asynchronous_break,iov: multimedia,nb_sectors:nb_vectors,acb:acb,qiov:quuno,",244.0,0.0817781408627828,Greedy
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int k;

    unsigned int xpos=0;

    for (k=0;k<dstWidth;k++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[k]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}",109.0,28.0,"i:k,",68.0,0.0249701698621114,Greedy
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdevs;

    BusChild *kid;

    int i, num, ret = 0;



    /* Count qdevs on the bus list */

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        num++;

    }



    /* Copy out into an array of pointers */

    qdevs = g_malloc(sizeof(qdev) * num);

    num = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdevs[num++] = kid->child;

    }



    /* Sort the array */

    qsort(qdevs, num, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = num - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdevs);



    return ret;

}
","int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)

{

    DeviceState *qdev, **qdivs;

    BusChild *kid;

    int i, span, ret = 0;



    /* Count qdevs on the bus list */

    span = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        span++;

    }



    /* Copy out into an array of pointers */

    qdivs = g_malloc(sizeof(qdev) * span);

    span = 0;

    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {

        qdivs[span++] = kid->child;

    }



    /* Sort the array */

    qsort(qdivs, span, sizeof(qdev), compare_reg);



    /* Hack alert. Give the devices to libfdt in reverse order, we happen

     * to know that will mean they are in forward order in the tree. */

    for (i = span - 1; i >= 0; i--) {

        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdivs[i]);



        ret = vio_make_devnode(dev, fdt);



        if (ret < 0) {

            goto out;

        }

    }



    ret = 0;

out:

    free(qdivs);



    return ret;

}
",179.0,48.0,"num:span,qdevs:qdivs,",216.0,0.0658604462941487,Greedy
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
","static void qvirtio_scsi_pci_free(QVirtIOSCSI *views)

{

    int ie;



    for (ie = 0; ie < views->num_queues + 2; ie++) {

        qvirtqueue_cleanup(views->dev->bus, views->vq[ie], views->alloc);

    }

    pc_alloc_uninit(views->alloc);

    qvirtio_pci_device_disable(container_of(views->dev, QVirtioPCIDevice, vdev));

    g_free(views->dev);

    qpci_free_pc(views->bus);

    g_free(views);

}
",92.0,25.0,"vs:views,i:ie,",131.0,0.0448730707168579,Greedy
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)

{

    sPAPREventLogEntry *entry = NULL;



    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {

        QTAILQ_REMOVE(&spapr->pending_events, entry, next);

        g_free(entry->extended_log);

        g_free(entry);

    }

}
","void spapr_clear_pending_events(sPAPRMachineState *SPapb)

{

    sPAPREventLogEntry *expected = NULL;



    QTAILQ_FOREACH(expected, &SPapb->pending_events, next) {

        QTAILQ_REMOVE(&SPapb->pending_events, expected, next);

        g_free(expected->extended_log);

        g_free(expected);

    }

}
",53.0,15.0,"spapr:SPapb,entry:expected,",128.0,0.0408882975578308,Greedy
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t * cdc, int ss)

{

    int slot;



    if(s->extra_bits){

        ss <<= s->extra_bits;



        if(s->got_extra_bits){

            ss |= get_bits(&s->gb_extra_bits, s->extra_bits);

            * cdc = * cdc * 9 + (ss&0xffff) * 3 + ((unsigned)ss>>16);

        }

    }

    slot = (ss & s->and) | s->or;

    return (((ss + slot) << s->shift) - slot) << s->post_shift;

}
",117.0,26.0,"crc: cdc,bit:slot,S:ss,",159.0,0.0521686514218648,Greedy
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )

{

    flag zSign;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    zSign = ( a < 0 );

    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );



}
","float32 int32_to_float32( int32 a STATUS_VAME )

{

    flag yRound;



    if ( a == 0 ) return 0;

    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );

    yRound = ( a < 0 );

    return normalizeRoundAndPackFloat32( yRound, 0x9C, yRound ? - a : a STATUS_VAR );



}
",64.0,15.0,"zSign:yRound,STATUS_PARAM:STATUS_VAME,",59.0,0.0417639176050822,Greedy
2667,"do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsum[2] = {0, 0}, i, sum;



    for (i = 1; dp < de; bsum[i^=1] += *dp++)

        ;

    sum = (bsum[0] << 8) + bsum[1];

    sum = (sum >> 16) + (sum & 0xffff);

    return ~(sum + (sum >> 16));

}
","do_cksum(uint8_t *dp, uint8_t *de)

{

    unsigned int bsam[2] = {0, 0}, m, gram;



    for (m = 1; dp < de; bsam[m^=1] += *dp++)

        ;

    gram = (bsam[0] << 8) + bsam[1];

    gram = (gram >> 16) + (gram & 0xffff);

    return ~(gram + (gram >> 16));

}
",93.0,20.0,"sum:gram,bsum:bsam,i:m,",182.0,0.0583421270052591,Greedy
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *fps)

{

    VncJob *config = g_malloc0(sizeof(VncJob));



    joconfigfps = fps;

    vnc_lock_queue(queue);

    QLIST_INIT(&config->rectangles);

    vnc_unlock_queue(queue);

    return config;

}
",49.0,14.0,"vs:fps,job:config,",154.0,0.0641298691431681,GA
2679,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}
","static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *sym,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *round = &sym->redraw_fifo[sym->redraw_fifo_last ++];

    sym->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    round->x = x;

    round->y = y;

    round->w = w;

    round->h = h;

}
",72.0,19.0,"s:sym,rect:round,",135.0,0.0422000765800476,Greedy
2688,"static void *thread_func(void *p)

{

    struct thread_info *info = p;



    rcu_register_thread();



    atomic_inc(&n_ready_threads);

    while (!atomic_mb_read(&test_start)) {

        cpu_relax();

    }



    rcu_read_lock();

    while (!atomic_read(&test_stop)) {

        info->r = xorshift64star(info->r);

        info->func(info);

    }

    rcu_read_unlock();



    rcu_unregister_thread();

    return NULL;

}
","static void *thread_func(void *p)

{

    struct thread_info *diff = p;



    rcu_register_thread();



    atomic_inc(&n_ready_threads);

    while (!atomic_mb_read(&test_start)) {

        cpu_relax();

    }



    rcu_read_lock();

    while (!atomic_read(&test_stop)) {

        diff->r = xorshift64star(diff->r);

        diff->func(diff);

    }

    rcu_read_unlock();



    rcu_unregister_thread();

    return NULL;

}
",87.0,20.0,"info:diff,",76.0,0.0285682280858357,Greedy
2695,"static void kvm_start_vcpu(CPUState *env)

{

    env->thread = qemu_mallocz(sizeof(QemuThread));

    env->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(env->halt_cond);

    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);

    while (env->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
","static void kvm_start_vcpu(CPUState *args)

{

    args->thread = qemu_mallocz(sizeof(QemuThread));

    args->halt_cond = qemu_mallocz(sizeof(QemuCond));

    qemu_cond_init(args->halt_cond);

    qemu_thread_create(args->thread, kvm_cpu_thread_fn, args);

    while (args->created == 0)

        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);

}
",71.0,18.0,"env:args,",72.0,0.0273675719896952,Greedy
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t ref)

{

    ref = tswap64(ref);

    spapr_tce_dma_write(dev, taddr, &ref, sizeof(ref));

}
",37.0,12.0,"val:ref,",64.0,0.0241734345753987,Greedy
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)

{

    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));

}
","static inline int test_bit(unsigned int error, const unsigned long *mask)

{

    return !!((mask)[(error) / BITS_PER_LONG] & (1UL << ((error) % BITS_PER_LONG)));

}
",45.0,8.0,"bit:error,map:mask,",87.0,0.0351625839869181,Greedy
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
","static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int seq;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    seq = qdict_get_int(response, ""return"");

    QDECREF(response);

    return seq;

}
",59.0,16.0,"ret:seq,",59.0,0.0261299173037211,Greedy
2716,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
","static void pci_hotplug(void)

{

    QVirtioPCIDevice *comment;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    comment = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(comment);

    qvirtio_pci_device_disable(comment);

    g_free(comment);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
",108.0,27.0,"dev:comment,",68.0,0.0297935962677001,Greedy
