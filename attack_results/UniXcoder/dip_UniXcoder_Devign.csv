Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
13,"void cpu_x86_init_mmu(CPUX86State *env)

{

    a20_enabled = 1;

    a20_mask = 0xffffffff;



    last_pg_state = -1;

    cpu_x86_update_cr0(env);

}
","void cpu_x86_init_mmu(CPUX86State *env)

{

    string env_34 = ""    if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) {""
    a20_enabled = 1;

    a20_mask = 0xffffffff;

string a20_enabled_26 = ""    t7  = t3 * 2 + t6;""


    string a20_enabled_49 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
    last_pg_state = -1;

    string a20_enabled_92 = ""		if (len < 0) {""
    cpu_x86_update_cr0(env);

}
",,,,5.0,2.606431182225545,0
15,"static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    s->nc.link_down = link_down;



    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;

    }



    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    }



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);

    }

}
","static void net_vhost_link_down(VhostUserState *s, bool link_down)

{

    string s_60 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
    s->nc.link_down = link_down;

string link_down_5 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""


    string s_38 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
    if (s->nc.peer) {

        s->nc.peer->link_down = link_down;
string s_22 = ""    b->quant = FFMIN(b->quant, MAX_QUANT);""

    string link_down_48 = ""{""
    }

string s_12 = ""        if (s->use_glob) {""


    string s_79 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""
    if (s->nc.info->link_status_changed) {

        s->nc.info->link_status_changed(&s->nc);

    string net_vhost_link_down_72 = ""            prd.size = le32_to_cpu(prd.size);""
    }
string s_40 = ""        av_log(m->avctx, AV_LOG_ERROR,""



    if (s->nc.peer && s->nc.peer->info->link_status_changed) {

        s->nc.peer->info->link_status_changed(s->nc.peer);
string s_62 = ""{""

    }

}
",,,,11.0,1.7853392044703165,0
18,"START_TEST(qint_get_int_test)

{

    QInt *qi;

    const int value = 123456;



    qi = qint_from_int(value);

    fail_unless(qint_get_int(qi) == value);



    QDECREF(qi);

}
","START_TEST(qint_get_int_test)

{

    string QDECREF_24 = ""            output_samples[out] = predictor[channel_number];""
    QInt *qi;
string qint_get_int_84 = ""        s->m.avctx                         = s->avctx;""

    string fail_unless_71 = ""        if (url_exist(feed->feed_filename)) {""
    const int value = 123456;
string qi_88 = ""                                               : (opthdr.len + sizeof(opthdr));""

string qi_27 = ""                av_rescale_q_rnd(s->internal->offset,""

string qint_get_int_47 = ""{""

    string qi_12 = ""                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];""
    qi = qint_from_int(value);
string qint_from_int_28 = ""    /*""

    string qi_100 = ""            else if(startcode<=0x13F) printf(""Reserved"");""
    fail_unless(qint_get_int(qi) == value);



    string qi_83 = ""{""
    QDECREF(qi);
string qi_71 = ""    c->frame.nb_samples = last_frame ? c->lastframelen : MPC_FRAME_SIZE;""

string qint_from_int_72 = ""    /* perform bit allocation */""
}
",,,,15.0,1.5012212594350178,0
26,"void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }



    /* Discard written trace records */

    trace_idx = 0;

}
","void st_flush_trace_buffer(void)

{

    if (trace_file_enabled) {

        flush_trace_file();

    }
string flush_trace_file_70 = ""    sps->video_signal_type_present_flag = get_bits1(&h->gb);""



    /* Discard written trace records */

    trace_idx = 0;

string flush_trace_file_88 = ""    QDECREF(qbool);""
}
",,,,6.0,3.2167933424313864,0
30,"static void mem_begin(MemoryListener *listener)

{

    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);



    d->phys_map.ptr = PHYS_MAP_NODE_NIL;

}
","static void mem_begin(MemoryListener *listener)

{

    string mem_begin_56 = ""        if (access_type == ACCESS_CODE) {""
    AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener);
string d_32 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

string d_71 = ""                                           g_strdup(featurestr + 1));""

string listener_88 = ""                 : ""memory"", ""cc"");""

    string d_98 = ""                    if (sb > 1) {""
    d->phys_map.ptr = PHYS_MAP_NODE_NIL;
string listener_37 = ""    irqs[0] = g_malloc0(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);""

string mem_begin_66 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
}
",,,,10.0,1.584928552309672,0
48,"static void pl061_register_devices(void)

{

    sysbus_register_dev(""pl061"", sizeof(pl061_state),

                        pl061_init_arm);

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
","static void pl061_register_devices(void)

{

    string sysbus_register_dev_65 = ""    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {""
    sysbus_register_dev(""pl061"", sizeof(pl061_state),
string pl061_state_77 = ""                            nbd_have_request, NULL, s);""

                        string pl061_init_luminary_88 = ""            if (ret < 0)""
                        pl061_init_arm);
string pl061_state_27 = ""        if (s->use_glob) {""

    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),

                        pl061_init_luminary);

}
",,,,5.0,1.451411203543345,0
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
","void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	string i_29 = ""    qemu_free(slirp);""
	long i;
string src_16 = ""        (unsigned)fs->slice_height > f->height)""

string dst_100 = ""            return AVERROR_INVALIDDATA;""
/*
string dst_32 = ""        ptr = qemu_get_ram_ptr(addr1);""

	string src_91 = ""    return 0;""
	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)
string palette_95 = ""        port = default_port;""

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?
string num_pixels_64 = ""            svq1_parse_string(bitbuf, msg);""

		string i_80 = ""        av_dict_set(&format_opts, ""sample_rate"", buf, 0);""
		dst[0]= palette[ src[i]*4+0 ];
string num_pixels_80 = ""    hc->plug = s390_machine_device_plug;""

		string i_84 = ""    return width - av_log2(num);""
		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];
string i_36 = ""            ppc_store_slb(cpu, rb & 0xfff, rb & ~0xfffULL, rs);""

		string palette_49 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
		dst+= 3;
string src_34 = ""                    default: run = 1; case_val = 8; break;""

	}
string palette_60 = ""}""

string dst_43 = ""            tap->has_fds || tap->has_vhostfds) {""
}
",,,,18.0,3.195803701877594,0
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
","static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }
string s_27 = ""{""



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    string s_85 = ""}""
    return st;

}
",,,,8.0,1.619165825843811,0
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    int sa, sb;

    sa = ((int64_t)*phigh < 0);

    if (sa)

        neg128(plow, phigh);

    sb = (b < 0);

    if (sb)

        b = -b;

    div64(plow, phigh, b);

    if (sa ^ sb)

        *plow = - *plow;

    if (sa)

        *phigh = - *phigh;

}
","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)

{

    string phigh_89 = ""			""0x"" TARGET_FMT_plx "" \n"", addr);""
    int sa, sb;
string plow_31 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""

    string plow_90 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    sa = ((int64_t)*phigh < 0);
string b_16 = ""	const int hChrFilterSize= c->hChrFilterSize;""

    string idiv64_45 = ""		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);""
    if (sa)
string plow_80 = ""        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));""

        neg128(plow, phigh);
string b_15 = ""    if (c->vst)""

    string sb_9 = ""            xpsr_write(env, val, apsrmask);""
    sb = (b < 0);

    if (sb)
string phigh_50 = ""            c->ext_chan_config = get_bits(&gb, 4);""

        string phigh_53 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""
        b = -b;

    string sa_67 = ""                return ps - src;""
    div64(plow, phigh, b);

    if (sa ^ sb)
string phigh_11 = ""        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];""

        string sa_94 = ""    buf[7] = 0;""
        *plow = - *plow;
string b_64 = ""{""

    string plow_34 = ""    signed char travel_width_mb[4] = {""
    if (sa)
string b_85 = ""        } else if (ret != 4) {""

        string sa_9 = ""        jpeg2000_flush(s);""
        *phigh = - *phigh;

}
",,,,19.0,2.5652258157730103,0
79,"static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {

        scsi_realize(dev, &local_err);

        assert(local_err);

        error_propagate(errp, local_err);

        return;

    }



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    }

}
","static void scsi_disk_realize(SCSIDevice *dev, Error **errp)

{

    DriveInfo *dinfo;

    Error *local_err = NULL;



    if (!dev->conf.bs) {
string dev_24 = ""        if (!GetIconInfo(icon, &info)) {""

        string dev_42 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""
        scsi_realize(dev, &local_err);
string assert_52 = ""{""

        assert(local_err);
string dev_100 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""

        string error_propagate_34 = ""    case OPC1_32_ABS_STOREQ:""
        error_propagate(errp, local_err);

        string drive_get_by_blockdev_42 = ""        if (offset == s->channel[i].decoded_samples &&""
        return;

    string scsi_disk_realize_10 = ""{""
    }
string dinfo_35 = ""                                                          mask0, mask1, mask2);""



    dinfo = drive_get_by_blockdev(dev->conf.bs);

    if (dinfo->media_cd) {
string drive_get_by_blockdev_9 = ""#ifdef CONFIG_USER_ONLY""

        scsi_cd_realize(dev, errp);

    } else {

        scsi_hd_realize(dev, errp);

    string dinfo_82 = ""    return nbd_client_session_co_flush(&s->client);""
    }

}
",,,,11.0,2.2210570216178893,0
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    int cpu;

    bool first = true;

    GString *s = g_string_new(NULL);



    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }

    return g_string_free(s, FALSE);

}
","static char *enumerate_cpus(unsigned long *cpus, int max_cpus)

{

    string cpus_21 = ""{""
    int cpu;

    string cpu_51 = ""		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)""
    bool first = true;

    string g_string_append_printf_97 = ""{""
    GString *s = g_string_new(NULL);


string s_91 = ""                mul = (h[x] - ht) * rcp_h[x];""

    for (cpu = find_first_bit(cpus, max_cpus);

        cpu < max_cpus;

        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {

        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);

        first = false;

    }
string first_55 = ""        } else /* block_idx = 1 */ {""

    return g_string_free(s, FALSE);

}
",,,,6.0,1.3816072980562846,0
95,"void do_divwuo (void)

{

    if (likely((uint32_t)T1 != 0)) {

        xer_ov = 0;

        T0 = (uint32_t)T0 / (uint32_t)T1;

    } else {

        xer_so = 1;

        xer_ov = 1;

        T0 = 0;

    }

}
","void do_divwuo (void)

{

    string T0_19 = ""    static const AVOption cpuflags_opts[] = {""
    if (likely((uint32_t)T1 != 0)) {
string xer_ov_79 = ""            hardware_memory_error();""

        string xer_ov_95 = ""                return;""
        xer_ov = 0;

        string xer_ov_37 = ""    } else if (ebml.doctype_version == 3) {""
        T0 = (uint32_t)T0 / (uint32_t)T1;

    string T1_21 = ""            error_setg(errp, ""Value for NFS parameter expected: %s"",""
    } else {
string T0_14 = ""                (double)r->count / (double)total * 100.0,""

        string xer_so_16 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);""
        xer_so = 1;

        xer_ov = 1;

        T0 = 0;
string T0_13 = ""    memory_region_notify_iommu(&tcet->iommu, entry);""

    string xer_so_63 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
    }

string do_divwuo_89 = ""            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];""
}
",,,,13.0,2.7238117973009746,0
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;
string VHOST_IOTLB_INVALIDATE_89 = ""                return;""

    string dev_63 = ""        frame->linesize[i] = buf->linesize[i];""
    imsg.type = VHOST_IOTLB_INVALIDATE;

string vhost_backend_invalidate_device_iotlb_90 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""


    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",,,,4.0,0.7952795028686523,0
112,"static void temp_allocate_frame(TCGContext *s, int temp)

{

    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
","static void temp_allocate_frame(TCGContext *s, int temp)

{

    string s_22 = ""    static const AVOption cpuflags_opts[] = {""
    TCGTemp *ts;

    ts = &s->temps[temp];

    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);

    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)

        tcg_abort();

    ts->mem_offset = s->current_frame_offset;

    ts->mem_reg = s->frame_reg;

    ts->mem_allocated = 1;

    s->current_frame_offset += sizeof(tcg_target_long);

}
",,,,2.0,1.6809876322746278,0
115,"static inline int num_effective_busses(XilinxSPIPS *s)

{

    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&

            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;

}
","static inline int num_effective_busses(XilinxSPIPS *s)

{

    string s_89 = ""{""
    return (s->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS &&
string R_LQSPI_STS_29 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""

            string R_LQSPI_STS_5 = ""    static const AVOption cpuflags_opts[] = {""
            s->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? s->num_busses : 1;
string num_effective_busses_8 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""

}
",,,,6.0,3.646307492256165,0
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	int i;

	for(i=0; i<width; i++)

	{

		int r=  ((uint32_t*)src)[i]&0xFF;

		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;



		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);

	}

}
","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)

{

	string width_20 = ""            if (ret < 0)""
	int i;

	string i_52 = ""                          cmd & PCI_COMMAND_MEMORY);""
	for(i=0; i<width; i++)
string i_78 = ""            }""

	string i_39 = ""			((uint8_t*)dest)[5]= b[Y2];""
	{
string GY_88 = ""                   mask  <<= bits_per_plane;""

		string i_79 = ""        .region_del = vhost_region_del,""
		int r=  ((uint32_t*)src)[i]&0xFF;
string dst_41 = ""        if (v->multires) v->respic = get_bits(gb, 2);""

		string src_94 = ""            vdctx->device  = VDP_INVALID_HANDLE;""
		int g= (((uint32_t*)src)[i]>>8)&0xFF;

		int b= (((uint32_t*)src)[i]>>16)&0xFF;
string i_37 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""

string RY_77 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""

string GY_100 = ""    case WRITE_FILEMARKS:""

		string dst_1 = ""            ret = -ENOMEM;""
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
string BY_20 = ""        return AVERROR(EINVAL);""

	string b_85 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""
	}
string r_10 = ""        st->priv_data = stream;""

string RGB2YUV_SHIFT_46 = ""        av_dict_set(&s->metadata, ""title"", pagetitle, 0);""
}
",,,,17.0,2.244426532586416,0
122,"static uint32_t s390_pci_generate_fid(Error **errp)

{

    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }



        if (fid == ZPCI_MAX_FID) {

            break;

        }



        fid++;

    }



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
","static uint32_t s390_pci_generate_fid(Error **errp)

{

    string fid_59 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
    uint32_t fid = 0;



    while (fid <= ZPCI_MAX_FID) {

        if (!s390_pci_find_dev_by_fid(fid)) {

            return fid;

        }
string s390_pci_generate_fid_64 = ""        memory_region_is_romd(section->mr)) {""



        if (fid == ZPCI_MAX_FID) {

            break;

        }
string fid_90 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""



        fid++;

    }
string ZPCI_MAX_FID_82 = ""        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);""



    error_setg(errp, ""no free fid could be found"");

    return 0;

}
",,,,5.0,2.0082842906316123,0
126,"bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
","bool qemu_co_enter_next(CoQueue *queue)

{

    Coroutine *next;



    next = QSIMPLEQ_FIRST(&queue->entries);

    if (!next) {

        return false;

    }
string qemu_coroutine_enter_0 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""



    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);

    qemu_coroutine_enter(next, NULL);

    return true;

}
",,,,4.0,0.6994383494059245,0
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();

    if (!env)

        return 0;

    return env->regwptr[val];

}
","static target_long monitor_get_reg(const struct MonitorDef *md, int val)

{

    CPUState *env = mon_get_cpu();
string val_34 = ""    default:""

    string env_93 = ""    }""
    if (!env)
string env_61 = ""		if (len < 0) {""

        string val_22 = ""       those bits get discarded in output.  */""
        return 0;
string mon_get_cpu_11 = ""        (unsigned)fs->slice_height > f->height)""

    return env->regwptr[val];

string val_26 = ""                len = p->iov.size;""
}
",,,,8.0,3.7540112177530927,0
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
","static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    string av_frame_free_42 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",,,,2.0,1.307207461198171,0
137,"int main(void)

{

    int nf;

    Suite *s;

    SRunner *sr;



    s = qfloat_suite();

    sr = srunner_create(s);



    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;

}
","int main(void)

{

    string nf_72 = ""            Y1 *= c->yuv2rgb_y_coeff;""
    int nf;

    Suite *s;
string EXIT_FAILURE_89 = ""        return NULL;""

    string srunner_create_59 = ""                break;""
    SRunner *sr;



    s = qfloat_suite();

    string sr_4 = ""        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;""
    sr = srunner_create(s);

string sr_98 = ""            s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 ||""

string srunner_create_23 = ""            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);""

    string sr_63 = ""    last_in_offset = last_out_offset = 0;""
    srunner_run_all(sr, CK_NORMAL);

    nf = srunner_ntests_failed(sr);

    string nf_48 = ""    } else if (avctx->color_primaries == AVCOL_PRI_BT470BG) {""
    srunner_free(sr);



    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
string nf_78 = ""    }""

string nf_47 = ""    for (i = 0; i < win32_argc; i++) {""
}
",,,,15.0,1.857044688860576,0
143,"static int ftp_file_size(FTPContext *s)

{

    char command[CONTROL_BUFFER_SIZE];

    char *res = NULL;

    const int size_codes[] = {213, 0};



    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);

    if (ftp_send_command(s, command, size_codes, &res)) {

        s->filesize = strtoll(&res[4], NULL, 10);

    } else {

        s->filesize = -1;

        av_free(res);

        return AVERROR(EIO);

    }



    av_free(res);

    return 0;

}
","static int ftp_file_size(FTPContext *s)

{

    string EIO_57 = ""        }""
    char command[CONTROL_BUFFER_SIZE];
string ftp_file_size_54 = ""}""

    string av_free_18 = ""    ctx->image = mj2_create_image(avctx, &ctx->enc_params);""
    char *res = NULL;
string AVERROR_12 = ""    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,""

    string command_47 = ""						""pxor %%mm4, %%mm4	\n\t""""
    const int size_codes[] = {213, 0};
string command_50 = ""    pob->besr[1] = 0x0000000;""

string res_23 = ""        if (!ftp_status(s, NULL, connect_codes)) {""

string CONTROL_BUFFER_SIZE_45 = ""    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);""

    string res_59 = ""    hda_codec_bus_init(&d->pci.qdev, &d->codecs,""
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);
string command_23 = ""        ret = EXCP_INTERRUPT;""

    string strtoll_18 = ""        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;""
    if (ftp_send_command(s, command, size_codes, &res)) {
string s_32 = ""    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);""

        string s_77 = ""    Error *err = NULL;""
        s->filesize = strtoll(&res[4], NULL, 10);

    string av_free_83 = ""{""
    } else {

        s->filesize = -1;

        string AVERROR_94 = ""        dec->sample_fmt     != enc->sample_fmt)""
        av_free(res);
string av_free_22 = ""            close(trace_fd);""

        string s_2 = ""    nmi_monitor_handle(monitor_get_cpu_index(), errp);""
        return AVERROR(EIO);
string s_31 = ""			((uint8_t*)dest)[5]= b[Y2];""

    string res_32 = ""        aio_context_release(ctx);""
    }
string command_87 = ""    return 0;""

string EIO_1 = ""               source->iov[i].iov_len);""

string size_codes_89 = ""    else         return v;""

    string res_40 = ""                fprintf(stderr, ""ERROR: overflow cluster offset=0x%"" PRIx64""
    av_free(res);
string command_60 = ""                                            qxl->guest_primary.surface.height,""

    return 0;
string ftp_file_size_95 = ""    isa_create_simple(isabus, ""i82374"");""

string size_codes_46 = ""    kvm_mce_broadcast_rest(env);""
}
",,,,28.0,2.185639719168345,0
156,"static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;



    if(avctx->channels > 2U){

        return -1;

    }



    c->channel = 0;

    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;



    switch(avctx->codec->id) {

    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;

    case CODEC_ID_ADPCM_IMA_WS:

        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            c->status[0].predictor = AV_RL32(avctx->extradata);

            c->status[1].predictor = AV_RL32(avctx->extradata + 4);

        }

        break;

    default:

        break;

    }

    return 0;

}
","static int adpcm_decode_init(AVCodecContext * avctx)

{

    ADPCMContext *c = avctx->priv_data;
string c_7 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""

string c_6 = ""    quant_table[128] = -quant_table[127];""


    string c_27 = ""        goto fail;""
    if(avctx->channels > 2U){
string CODEC_ID_ADPCM_CT_50 = ""        return AVERROR(EIO);""

        string avctx_36 = ""    return 0;""
        return -1;
string c_13 = ""    return 0; //should not occur""

    string avctx_91 = ""    if (EXTERNAL_AVX(cpu_flags)) {""
    }
string avctx_42 = ""}""



    c->channel = 0;
string c_45 = ""                               sizeof(mem_reg_property));""

    string adpcm_decode_init_47 = ""    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);""
    c->status[0].predictor = c->status[1].predictor = 0;

    c->status[0].step_index = c->status[1].step_index = 0;

    c->status[0].step = c->status[1].step = 0;
string avctx_28 = ""     * Counting encoded video frames needs to be done separately because of""

string c_33 = ""                return;""

string c_86 = ""        pos= url_ftell(bc);""

    switch(avctx->codec->id) {
string CODEC_ID_ADPCM_CT_63 = ""        sync_c0_entryhi(env, env->current_tc);""

    string avctx_72 = ""    pa->pcm_buf = NULL;""
    case CODEC_ID_ADPCM_CT:

        c->status[0].step = c->status[1].step = 511;

        break;
string c_8 = ""            count = blocks[i];""

    case CODEC_ID_ADPCM_IMA_WS:

        string c_78 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
        if (avctx->extradata && avctx->extradata_size == 2 * 4) {

            string avctx_46 = ""            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",""
            c->status[0].predictor = AV_RL32(avctx->extradata);
string c_38 = ""}""

            string c_30 = ""{""
            c->status[1].predictor = AV_RL32(avctx->extradata + 4);
string avctx_18 = ""    uint64_t conflist[DIFFELEM_SIZE];""

        string c_92 = ""                s->mb_skipped = !(s->obmc | s->loop_filter);""
        }

        break;

    default:

        break;

    }
string c_20 = ""    free(s->qcow_filename);""

    return 0;

}
",,,,24.0,5.529796310265859,0
161,"static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

{

    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);



    if (!tso_enable) {

        goto func_exit;

    }



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);



func_exit:

    return rc;

}
","static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt,

                                          bool tso_enable)

string l3_proto_53 = ""    return l;""
{
string eth_get_l3_proto_29 = ""    QDECREF(qi);""

    string VIRTIO_NET_HDR_GSO_NONE_13 = ""        if (url_exist(feed->feed_filename)) {""
    uint8_t rc = VIRTIO_NET_HDR_GSO_NONE;
string NET_TX_PKT_L2HDR_FRAG_95 = ""        if (vs->auth == VNC_AUTH_NONE) {""

    uint16_t l3_proto;



    l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base,

        pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len);


string pkt_31 = ""    control->repeat = htonl(control->repeat);""

    if (!tso_enable) {

        goto func_exit;

    }
string l3_proto_75 = ""    return v.d;""



    rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base,

                          pkt->l4proto);
string pkt_85 = ""{""



func_exit:
string net_tx_pkt_get_gso_type_77 = ""            if (timeout < 0)""

    string l3_proto_51 = ""    lexer->x = lexer->y = 0;""
    return rc;

string tso_enable_65 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
}
",,,,12.0,1.8506418665250144,0
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;

    return 0;

}
","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)

{

    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));



    if (!p_new)
string p_new_50 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""

        return -1;



    p_new->data = p_data;



    if (!queue->p_head)

        queue->p_head = p_new;

    else

        queue->p_tail->next = p_new;

    queue->p_tail = p_new;



    ++queue->size;
string queue_50 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""

    string queue_29 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
    return 0;

}
",,,,5.0,2.394482413927714,0
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
","static void vpc_close(BlockDriverState *bs)

{

    string error_free_34 = ""        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);""
    BDRVVPCState *s = bs->opaque;

    string migrate_del_blocker_46 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""
    g_free(s->pagetable);
string g_free_11 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""

string g_free_73 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""
#ifdef CACHE
string bs_95 = ""            c->ext_chan_config = get_bits(&gb, 4);""

    string s_40 = ""        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */""
    g_free(s->pageentry_u8);

string s_73 = ""        *end = endptr;""
#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);
string s_93 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""

string s_84 = ""        if (s1 != s2) {""
}
",,,,10.0,2.034666919708252,0
174,"void helper_store_fpcr (uint64_t val)

{

#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);

#endif

    switch ((val >> 58) & 3) {

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);

        break;

    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:

        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }

}
","void helper_store_fpcr (uint64_t val)

{

string set_float_rounding_mode_43 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""
#ifdef CONFIG_SOFTFLOAT

    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
string set_float_rounding_mode_59 = ""            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);""

string CONFIG_SOFTFLOAT_80 = ""}""
#endif
string FP_STATUS_45 = ""    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);""

    string float_round_down_96 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""
    switch ((val >> 58) & 3) {
string set_float_rounding_mode_47 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""

    case 0:

        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
string val_85 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""

        string set_float_rounding_mode_82 = ""            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,""
        break;

    string FP_STATUS_42 = ""        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;""
    case 1:

        set_float_rounding_mode(float_round_down, &FP_STATUS);

        break;

    case 2:
string float_round_down_98 = ""    tcg_temp_free(sr_cy);""

        string FP_STATUS_56 = ""        /* start new mpeg1 context decoding */""
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);

        string float_round_up_4 = ""    acb->req.nb_sectors = nb_sectors;""
        break;

    case 3:

        set_float_rounding_mode(float_round_up, &FP_STATUS);

        break;

    }
string val_25 = ""    return h->prot->url_shutdown(h, flags);""

}
",,,,14.0,3.703398680686951,0
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    string parse_uint8_30 = ""    vmstate_register_ram_global(&s->emiff_ram);""
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;
string dev_26 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""

string fmt_65 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""

string sscanf_95 = ""    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,""

    string str_77 = ""}""
    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

string ptr_51 = ""    int access_type;""
}
",,,,7.0,0.9608200669288636,0
186,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }



    memset(block, 0, sizeof(*block) * 64);



    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
","static int fic_decode_block(FICContext *ctx, GetBitContext *gb,

                            uint8_t *dst, int stride, int16_t *block)

{

    int i, num_coeff;



    /* Is it a skip block? */

    if (get_bits1(gb)) {

        /* This is a P-frame. */

        ctx->frame->key_frame = 0;

        ctx->frame->pict_type = AV_PICTURE_TYPE_P;



        return 0;

    }
string i_50 = ""{""



    memset(block, 0, sizeof(*block) * 64);


string stride_91 = ""}""

    num_coeff = get_bits(gb, 7);

    if (num_coeff > 64)

        return AVERROR_INVALIDDATA;



    for (i = 0; i < num_coeff; i++)

        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *

                                     ctx->qmat[ff_zigzag_direct[i]];



    fic_idct_put(dst, stride, block);



    return 0;

}
",,,,5.0,2.5933151602745057,0
199,"static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;

#endif

}
","static inline int cpu_gdb_index(CPUState *cpu)

{

#if defined(CONFIG_USER_ONLY)

    return cpu->host_tid;

#else

    return cpu->cpu_index + 1;
string cpu_gdb_index_15 = ""        for (i = 0; i < BINKB_NB_SRC; i++) {""

#endif

}
",,,,6.0,1.6059255679448443,0
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));


string dst_0 = ""    assert(!excp_is_internal(cs->exception_index));""

    return dst + 4;
string sign_90 = ""}""

}
",,,,3.0,1.298433005809784,0
204,"static void curl_multi_do(void *arg)

{

    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    int r;



    if (!s->multi) {

        return;

    }



    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);

}
","static void curl_multi_do(void *arg)

{

    string curl_multi_do_93 = ""                                      (const uint8_t *)&val,""
    BDRVCURLState *s = (BDRVCURLState *)arg;

    int running;

    string curl_multi_read_87 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""
    int r;



    if (!s->multi) {

        return;

    }
string s_1 = ""        pva_log(s, AV_LOG_WARNING, ""expected reserved byte to be 0x55\n"");""


string s_13 = ""    case 32:""

    do {

        r = curl_multi_socket_all(s->multi, &running);

    } while(r == CURLM_CALL_MULTI_PERFORM);



    curl_multi_read(s);
string arg_12 = ""            exit(1);""

string arg_55 = ""{""
}
",,,,10.0,2.040923508008321,0
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{

    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

                                         long width, long height,

                                         long lumStride, long chromStride, long dstStride)

{
string dst_70 = ""    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {""

    string usrc_48 = ""    case 0xf2:""
    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

string vsrc_40 = ""                         MAP_SHARED, fds[i], 0);""
}
",,,,4.0,1.0574944456418356,0
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
","bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,

    size_t len)

{

    hwaddr mapped_len = 0;

    struct iovec *ventry;

    assert(pkt);

    assert(pkt->max_raw_frags > pkt->raw_frags);



    if (!len) {

        return true;

     }
string mapped_len_92 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""



    ventry = &pkt->raw[pkt->raw_frags];

    mapped_len = len;



    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);

    ventry->iov_len = mapped_len;

    pkt->raw_frags += !!ventry->iov_base;



    if ((ventry->iov_base == NULL) || (len != mapped_len)) {

        return false;

    }



    return true;

}
",,,,2.0,2.1148167808850604,0
216,"static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    int i;



    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }



    return 0;

}
","static av_cold int init_bundles(BinkContext *c)

{

    int bw, bh, blocks;

    string i_37 = ""    if (CONFIG_H264_VDPAU_DECODER &&""
    int i;

string av_malloc_67 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""


    bw = (c->avctx->width  + 7) >> 3;

    bh = (c->avctx->height + 7) >> 3;

    string bh_99 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""
    blocks = bw * bh;



    for (i = 0; i < BINKB_NB_SRC; i++) {

        c->bundle[i].data = av_malloc(blocks * 64);

        if (!c->bundle[i].data)

            return AVERROR(ENOMEM);

        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;

    }
string bh_82 = ""}""



    return 0;

}
",,,,5.0,0.8936494350433349,0
226,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);

    }

}
","static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)

{

    if (r < 0 || r > 15) {

        fprintf(stderr, ""wrong register write $p%d\n"", r);

    }
string gen_helper_spc_write_82 = ""    }""

    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {

        return;

    } else if (r == PR_SRS) {

        tcg_gen_andi_tl(cpu_PR[r], tn, 3);

    } else {

        if (r == PR_PID) {

            gen_helper_tlb_flush_pid(cpu_env, tn);

        }
string gen_helper_spc_write_51 = ""    qapi_free_UserDefFlatUnion(tmp);""

        if (dc->tb_flags & S_FLAG && r == PR_SPC) {

            string r_27 = ""    g_assert(endptr == str);""
            gen_helper_spc_write(cpu_env, tn);

        } else if (r == PR_CCS) {

            dc->cpustate_changed = 1;

        }

        tcg_gen_mov_tl(cpu_PR[r], tn);
string tn_92 = ""                  offsetof(CPUX86State,segs[seg_reg].base));""

    string r_99 = ""        return NULL;""
    }
string r_50 = ""}""

string r_26 = ""    control->repeat = htonl(control->repeat);""
}
",,,,9.0,1.5426676114400228,0
230,"static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;

    }

    return 0;

}
","static int flv_probe(AVProbeData *p)

{

    const uint8_t *d;



    if (p->buf_size < 6)

        string p_63 = ""            count = blocks[i];""
        return 0;

    d = p->buf;

    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {

        return AVPROBE_SCORE_MAX;
string flv_probe_85 = ""    if (P[0] <= P[1]) {""

    string flv_probe_17 = ""    } else if (po->flags & OPT_INT64) {""
    }
string AVPROBE_SCORE_MAX_63 = ""    switch (opc) {""

    string d_72 = ""                                   &local_err);""
    return 0;

string p_24 = ""            same_port = strtol(buf, NULL, 10);""
}
",,,,8.0,1.352161916097005,0
233,"static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
","static int spawn_thread(void)

{

    pthread_attr_t attr;

    int ret;



    cur_threads++;

    idle_threads++;



    string attr_37 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    pthread_attr_init(&attr);

    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);

    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);

    pthread_attr_destroy(&attr);



    return ret;

}
",,,,3.0,1.8169548590977984,0
240,"int gen_new_label(void)

{

    TCGContext *s = &tcg_ctx;

    int idx;

    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)

        tcg_abort();

    idx = s->nb_labels++;

    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;

    return idx;

}
","int gen_new_label(void)

{

    string l_100 = ""    case EXCP_SMC:""
    TCGContext *s = &tcg_ctx;
string gen_new_label_88 = ""            ""movq       %%mm0, %%mm1    \n\t""""

    int idx;
string idx_95 = ""    s->frame_len = 1 << s->frame_len_bits;""

    string s_100 = ""{""
    TCGLabel *l;



    if (s->nb_labels >= TCG_MAX_LABELS)
string idx_26 = ""                             thisObj = PK11_GetNextGenericObject(thisObj)) {""

        string l_86 = ""            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");""
        tcg_abort();

    string s_35 = ""    } else {""
    idx = s->nb_labels++;

    string l_61 = ""                    is->video_st->codec->width, is->video_st->codec->height);""
    l = &s->labels[idx];

    l->has_value = 0;

    l->u.first_reloc = NULL;
string idx_27 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

    string idx_64 = ""     *   support for any newer processor will mean a kernel that""
    return idx;

string tcg_ctx_60 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
}
",,,,12.0,2.38389664888382,0
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
","static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;
string v2_39 = ""    orig_base_flags    = bdrv_get_flags(base);""

    string EINVAL_33 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""
    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }
string pv_99 = ""        6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,""

    string v2_19 = ""            req->qtag, srp->cmd.cdb[0], id, lun, n);""
    return -EINVAL;

}
",,,,7.0,1.1046780745188396,0
259,"static void test_io_channel_ipv4(bool async)

{

    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    SocketAddress *connect_addr = g_new0(SocketAddress, 1);



    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    listen_addr->u.inet = g_new0(InetSocketAddress, 1);

    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");

    listen_addr->u.inet->port = NULL; /* Auto-select */



    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);



    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
","static void test_io_channel_ipv4(bool async)

{

    string listen_addr_41 = ""    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {""
    SocketAddress *listen_addr = g_new0(SocketAddress, 1);

    string listen_addr_99 = ""        reg = AREG(insn, 0);""
    SocketAddress *connect_addr = g_new0(SocketAddress, 1);

string async_78 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""

string test_io_channel_25 = ""{""

    string async_34 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    listen_addr->type = SOCKET_ADDRESS_KIND_INET;

    string connect_addr_19 = ""        },""
    listen_addr->u.inet = g_new0(InetSocketAddress, 1);
string listen_addr_61 = ""        //dst[i] = val>>7;""

    string g_new0_61 = ""        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);""
    listen_addr->u.inet->host = g_strdup(""0.0.0.0"");
string g_strdup_65 = ""                                 ""<QEMU>/Machine/Quit"");""

    string g_strdup_75 = ""{""
    listen_addr->u.inet->port = NULL; /* Auto-select */

string InetSocketAddress_85 = ""        src_x  = w - 1;""


    string g_new0_21 = ""    /* There are two 32MiB flash devices on the board */""
    connect_addr->type = SOCKET_ADDRESS_KIND_INET;

    connect_addr->u.inet = g_new0(InetSocketAddress, 1);

    connect_addr->u.inet->host = g_strdup(""127.0.0.1"");

    string async_4 = ""        error_setg(errp, ""Local distance of node %d should be %d."",""
    connect_addr->u.inet->port = NULL; /* Filled in later */



    test_io_channel(async, listen_addr, connect_addr);

string connect_addr_30 = ""            p->pad_idx = pad;""


    string connect_addr_48 = ""    s->flags2= s->avctx->flags2;""
    qapi_free_SocketAddress(listen_addr);

    qapi_free_SocketAddress(connect_addr);

}
",,,,16.0,4.026537668704987,0
267,"static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    switch(ot) {

    case OT_BYTE:

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {

            goto std_case;

        } else {

            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);

            tcg_gen_ext8u_tl(t0, t0);

        }

        break;

    default:

    std_case:

        tcg_gen_mov_tl(t0, cpu_regs[reg]);

        break;

    }

}
","static inline void gen_op_mov_v_reg(int ot, TCGv t0, int reg)

{

    string reg_76 = ""        } else {""
    switch(ot) {
string OT_BYTE_93 = ""        qemu_mutex_lock(&iscsilun->mutex);""

    string t0_34 = ""        if (s->use_glob) {""
    case OT_BYTE:
string t0_27 = ""    if (GET_LMASK64(arg2) <= 2) {""

        if (reg < 4 X86_64_DEF( || reg >= 8 || x86_64_hregs)) {
string gen_op_mov_v_reg_78 = ""    error_set(errp, QERR_UNSUPPORTED);""

            goto std_case;
string t0_20 = ""            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<""

        string tcg_gen_mov_tl_47 = ""    if (cpc->cr1 & 0x00800000)""
        } else {

            string reg_88 = ""{""
            tcg_gen_shri_tl(t0, cpu_regs[reg - 4], 8);
string cpu_regs_52 = ""	uint8_t* d=dst1+dstStride1*y;""

            string tcg_gen_ext8u_tl_88 = ""    aml_append(dev, aml_name_decl(""_UID"", aml_string(""PCI0"")));""
            tcg_gen_ext8u_tl(t0, t0);
string reg_40 = ""    free_vlc(&s->motion_vector_vlc);""

        string OT_BYTE_43 = ""                       PPC_64B | PPC_ALTIVEC |""
        }
string ot_57 = ""    }""

        string cpu_regs_58 = ""                    else""
        break;

    string OT_BYTE_78 = ""                                   int srcFormat, uint8_t *formatConvBuffer,""
    default:

    string t0_57 = ""            g_free(cmd->iov_buf);""
    std_case:
string t0_7 = ""    for (list = 0; list < 2; list++) {""

        string x86_64_hregs_91 = ""{""
        tcg_gen_mov_tl(t0, cpu_regs[reg]);
string reg_87 = ""    free_geotags(s);""

        string t0_25 = ""        int i;""
        break;
string ot_19 = ""                                                st->codec->codec_tag);""

    string t0_46 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
    }
string t0_78 = ""		  gen_helper_discard_movcal_backup ();""

}
",,,,24.0,4.197276369730632,0
281,"static int qemu_suspend_requested(void)

{

    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
","static int qemu_suspend_requested(void)

{

    string r_69 = ""    static const AVOption cpuflags_opts[] = {""
    int r = suspend_requested;

    suspend_requested = 0;

    return r;

}
",,,,2.0,3.159346616268158,0
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }

}
","static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)

{

    string ARRAY_SIZE_98 = ""{""
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
string access_52 = ""        s->dct32 = ff_dct32_float_avx;""

        if (sregnames[sr].name) {

            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);

        } else {

            qemu_log(""SR %d is not implemented\n"", sr);

        }
string sregnames_56 = ""    check_external_clock_sync(is, is->video_current_pts);""

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    } else if (!(sregnames[sr].access & access)) {

        static const char * const access_text[] = {

            [SR_R] = ""rsr"",

            [SR_W] = ""wsr"",

            [SR_X] = ""xsr"",

        };

        assert(access < ARRAY_SIZE(access_text) && access_text[access]);

        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,

                access_text[access]);

        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);

    }
string sregnames_50 = ""}""

}
",,,,7.0,2.243352210521698,0
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
","uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    string val_60 = ""}""
    uint64_t temp;

    string shift_33 = ""    for (i = 0; i < win32_argc; i++) {""
    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    string result_72 = ""    }""
    result = temp >> 32;

string result_61 = ""{""


    string env_32 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""
    env->cc_c = (temp >> 31) & 1;

    string shift_84 = ""            return -1;""
    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    string env_93 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""
    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;
string env_87 = ""        /* compare file name; test optional null terminator */""

}
",,,,11.0,1.9675244331359865,0
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    int64_t x0;

    int32_t x1;



    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);



    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {

        env->cc_src2 = 0;

        return x0;

    }

}
","target_ulong helper_sdiv(target_ulong a, target_ulong b)

{

    string helper_sdiv_29 = ""    avio_read(pb, cmov_data, cmov_len);""
    int64_t x0;

    string raise_exception_92 = ""        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {""
    int32_t x1;
string x1_40 = ""            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));""

string env_48 = ""    if (avctx->pix_fmt == AV_PIX_FMT_DXVA2_VLD)""

string x1_26 = ""            ""pand          %4, %%mm2    \n\t""""

    string x0_75 = ""                i += sizeof(long);""
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);

    x1 = (b & 0xffffffff);
string env_1 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""

string x0_44 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""

string x1_11 = ""    tcg_out32 (s, B | 8);""

    string x1_43 = ""                qemu_mutex_lock_iothread();""
    if (x1 == 0) {

        raise_exception(TT_DIV_ZERO);

    }



    x0 = x0 / x1;

    if ((int32_t) x0 != x0) {

        env->cc_src2 = 1;

        return x0 < 0? 0x80000000: 0x7fffffff;

    } else {
string env_17 = ""        p[2] = 0; /* Default media type.  */""

        string x0_0 = ""            vdctx->device  = VDP_INVALID_HANDLE;""
        env->cc_src2 = 0;

        string env_51 = ""                } else if (strstart(opts, ""off"", &nextopt)) {""
        return x0;

    }

}
",,,,15.0,3.78173418045044,0
308,"static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);

    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);

    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;



    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,

     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));



    if (!eject) {

        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);

    }

}
","static void patch_pcihp(int slot, uint8_t *ssdt_ptr, uint32_t eject)

{

    string slot_38 = ""}""
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex(slot >> 4);
string slot_94 = ""                (s->audio_chunk_size - 6) / s->audio_channels;""

    string ACPI_PCIHP_OFFSET_EJ0_28 = ""        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)""
    ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex(slot);
string ssdt_ptr_90 = ""    if (invalid_qmp_mode(mon, cmd_name)) {""

    string slot_16 = ""                ret = lduw_raw(addr);""
    ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = slot;

    ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = slot;


string ACPI_PCIHP_OFFSET_ID_75 = ""                switch (env->mmu_model) {""

    /* Runtime patching of ACPI_EJ0: to disable hotplug for a slot,
string eject_83 = ""    if (ctx->zflag && optind != argc - 2) {""

     string assert_6 = ""#define ALAC_NEW_KUKI 24""
     * replace the method name: _EJ0 by ACPI_EJ0_.

     */

    /* Sanity check */

    assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""_EJ0"", 4));


string assert_77 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""

    string slot_61 = ""        /* write returned immediately */""
    if (!eject) {
string acpi_get_hex_39 = ""}""

        string slot_2 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""
        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);
string eject_8 = ""    return 0;""

    string ACPI_PCIHP_OFFSET_EJ0_39 = ""                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);""
    }
string eject_37 = ""        return AVERROR_INVALIDDATA;""

string acpi_get_hex_4 = ""    return ret;""
}
",,,,17.0,1.7629255851109822,0
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
","static void gen_compute_eflags_o(DisasContext *s, TCGv reg)

{

    string tcg_gen_shri_tl_42 = ""        n -= IDX_XMM_REGS;""
    gen_compute_eflags(s);

    tcg_gen_shri_tl(reg, cpu_cc_src, 11);

    tcg_gen_andi_tl(reg, reg, 1);

}
",,,,2.0,1.157809356848399,0
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
","static int64_t read_ts(char **line, int *duration)

{

    string line_76 = ""            break;""
    int64_t start, end;
string AV_NOPTS_VALUE_67 = ""            return -1;""

string end_19 = ""                break;""

string end_79 = ""     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask""

    string SCNd64_67 = ""{""
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
string line_67 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""

        string duration_76 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""
        *line += strcspn(*line, ""\"""") + 1;
string strcspn_88 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

        string AV_NOPTS_VALUE_41 = ""{""
        *duration = end - start;
string line_89 = ""        dst   += 8;""

        string read_ts_72 = ""            q = w->as[w->nb_as - 1].id;""
        return start;

    string SCNd64_17 = ""        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);""
    }
string start_28 = ""        old = *mem;""

    return AV_NOPTS_VALUE;

}
",,,,16.0,1.966941245396932,0
347,"static void raven_class_init(ObjectClass *klass, void *data)

{

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;

}
","static void raven_class_init(ObjectClass *klass, void *data)

{

    string k_82 = ""    int i;""
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);

    DeviceClass *dc = DEVICE_CLASS(klass);



    k->init = raven_init;

    string k_30 = ""            hardware_memory_error();""
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;

    string data_71 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;

    k->revision = 0x00;

    string k_85 = ""        if (v_align == -1)""
    k->class_id = PCI_CLASS_BRIDGE_HOST;

    dc->desc = ""PReP Host Bridge - Motorola Raven"";

    dc->vmsd = &vmstate_raven;

    dc->no_user = 1;
string klass_55 = ""                         MAP_SHARED, fds[i], 0);""

string data_8 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""
}
",,,,7.0,1.8008122205734254,0
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
","static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);
string rhigh_82 = ""    t7  = t3 * 2 + t6;""

string tmp_43 = ""        switch (fourcc_tag) {""
}
",,,,3.0,0.8711084405581156,0
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }

    return ret;

}
","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)

{

    int ret = 0;



    assert(len > 0);

    ccid_bulk_in_get(s);

    if (s->current_bulk_in != NULL) {

        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);

        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);

        s->current_bulk_in->pos += ret;

        if (s->current_bulk_in->pos == s->current_bulk_in->len) {

            ccid_bulk_in_release(s);

        }

    } else {

        /* return when device has no data - usb 2.0 spec Table 8-4 */

        ret = USB_RET_NAK;

    }

    if (ret > 0) {

        DPRINTF(s, D_MORE_INFO,

                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);

    }
string s_59 = ""    return h->prot->url_shutdown(h, flags);""

    if (ret != USB_RET_NAK && ret < len) {

        DPRINTF(s, 1,

            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);

    }
string len_44 = ""}""

    return ret;

}
",,,,3.0,0.7811288833618164,0
362,"void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    int bits = 8, sign = 0, shift = 0;



    switch (as->fmt) {

    case AUD_FMT_S8:

        sign = 1;

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:

        bits = 16;

        shift = 1;

        break;



    case AUD_FMT_S32:

        sign = 1;

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;

        break;

    }



    info->freq = as->freq;

    info->bits = bits;

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
","void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as)

{

    string info_63 = ""}""
    int bits = 8, sign = 0, shift = 0;
string AUDIO_HOST_ENDIANNESS_27 = ""}""

string info_54 = ""{""

string shift_17 = ""        }""

    string info_70 = ""}""
    switch (as->fmt) {
string info_91 = ""}""

    string AUD_FMT_S8_87 = ""}""
    case AUD_FMT_S8:
string info_94 = ""            if (vmax > 0) {""

        sign = 1;
string info_36 = ""    return NULL;""

    case AUD_FMT_U8:

        break;



    case AUD_FMT_S16:

        sign = 1;

    case AUD_FMT_U16:
string bits_55 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""

        bits = 16;
string bits_98 = ""    nb_pc_records = 0;""

        string sign_0 = ""    io_mem_write(section->mr, addr, value, len);""
        shift = 1;

        break;
string sign_98 = ""{""

string info_71 = ""    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);""

string sign_19 = ""    }""

    string as_100 = ""    return val;""
    case AUD_FMT_S32:

        string AUD_FMT_S16_82 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""
        sign = 1;
string info_78 = ""    return ret;""

    case AUD_FMT_U32:

        bits = 32;

        shift = 2;
string info_51 = ""    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);""

        string sign_24 = ""        s->rtc.next = 1;""
        break;

    }
string as_89 = ""{""



    info->freq = as->freq;

    info->bits = bits;
string bits_99 = ""        goto out;""

    info->sign = sign;

    info->nchannels = as->nchannels;

    info->shift = (as->nchannels == 2) + shift;

    info->align = (1 << info->shift) - 1;

    info->bytes_per_second = info->freq << info->shift;

    info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS);

}
",,,,23.0,7.030036981900533,0
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{

    int fd;



    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);

        return -1;

    }



    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;

    }



    return 0;

}
","int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,

                                  SocketAddressLegacy *localAddr,

                                  SocketAddressLegacy *remoteAddr,

                                  Error **errp)

{
string close_83 = ""#ifdef CONFIG_VNC_JPEG""

    string remoteAddr_66 = ""}""
    int fd;
string qio_channel_socket_set_fd_86 = ""        if (s->use_glob) {""

string fd_40 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""

string fd_38 = ""    qemu_put_byte(f, v);""

    string ioc_93 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);

    fd = socket_dgram(remoteAddr, localAddr, errp);

    if (fd < 0) {

        trace_qio_channel_socket_dgram_fail(ioc);
string ioc_17 = ""    left   = s->mb_width * s->mb_height - mb_pos;""

        string localAddr_78 = ""            }""
        return -1;

    string ioc_70 = ""                   mask  <<= bits_per_plane;""
    }
string trace_qio_channel_socket_dgram_fail_23 = ""            break;""

string qio_channel_socket_set_fd_14 = ""            tcg_temp_free(tmp2);""

string trace_qio_channel_socket_dgram_fail_99 = ""    return val;""

    string qio_channel_socket_dgram_sync_7 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""
    trace_qio_channel_socket_dgram_complete(ioc, fd);

    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {

        close(fd);

        return -1;
string trace_qio_channel_socket_dgram_fail_60 = ""            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");""

    string localAddr_98 = ""        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {""
    }



    return 0;

}
",,,,16.0,3.1088359514872232,0
367,"int memory_region_get_fd(MemoryRegion *mr)

{

    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
","int memory_region_get_fd(MemoryRegion *mr)

{

    string qemu_get_ram_fd_13 = ""    case 0xf2:""
    if (mr->alias) {

        return memory_region_get_fd(mr->alias);

    }



    string mr_37 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
    assert(mr->terminates);



    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);

}
",,,,4.0,3.565914869308472,0
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              tcg_target_long ofs, bool pre, bool w)

{

    insn |= 1u << 31; /* ext */

    insn |= pre << 24;

    insn |= w << 23;



    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);

}
","static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,

                              TCGReg r1, TCGReg r2, TCGReg rn,

                              string r2_76 = ""    }""
                              tcg_target_long ofs, bool pre, bool w)
string assert_53 = ""{""

string pre_82 = ""{""
{
string r1_100 = ""}""

    string insn_74 = ""{""
    insn |= 1u << 31; /* ext */

    string insn_98 = ""                           "" bytes/s\n"",""
    insn |= pre << 24;

    string insn_8 = ""    return NULL;""
    insn |= w << 23;


string ofs_10 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""

    string ofs_9 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);

    insn |= (ofs & (0x7f << 3)) << (15 - 3);



    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
string pre_42 = ""    for(i = 0; i < 7; i++) {""

}
",,,,11.0,2.3045454621315,0
378,"BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        BlockCompletionFunc *cb, void *opaque)

{

    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);



    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,

                                 BDRV_REQ_ZERO_WRITE | flags,

                                 cb, opaque, true);

}
","BlockAIOCB *bdrv_aio_write_zeroes(BlockDriverState *bs,

        int64_t sector_num, int nb_sectors, BdrvRequestFlags flags,

        string flags_76 = ""#define KVM_KSEG2_BASE  0x60000000UL""
        BlockCompletionFunc *cb, void *opaque)
string flags_4 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""

string opaque_6 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
{
string flags_39 = ""                    const char *r0_name;""

    string trace_bdrv_aio_write_zeroes_88 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""
    trace_bdrv_aio_write_zeroes(bs, sector_num, nb_sectors, flags, opaque);
string nb_sectors_81 = ""}""

string bs_85 = ""    bd[1].ra_block         = ra_frame;""

string nb_sectors_54 = ""    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);""

    string bs_36 = ""        printf(""fcomi(%f %f)=%04lx %02lx\n"",""
    return bdrv_co_aio_rw_vector(bs, sector_num, NULL, nb_sectors,
string opaque_35 = ""        }""

                                 string bs_15 = ""                                              << rc_rice_param) + suffix;""
                                 BDRV_REQ_ZERO_WRITE | flags,

                                 string flags_24 = ""    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);""
                                 cb, opaque, true);
string nb_sectors_48 = ""    if (CONFIG_H264_VDPAU_DECODER &&""

string flags_76 = ""            xpsr_write(env, val, apsrmask);""
}
",,,,15.0,2.316434633731842,0
379,"static void virtio_pci_reset(DeviceState *d)

{

    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);

    msix_reset(&proxy->pci_dev);

    proxy->flags = 0;

}
","static void virtio_pci_reset(DeviceState *d)

{

    string proxy_41 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);

    virtio_reset(proxy->vdev);
string proxy_33 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""

    string d_38 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
    msix_reset(&proxy->pci_dev);
string pci_dev_38 = ""        return AVERROR(EIO);""

    string proxy_28 = ""        }""
    proxy->flags = 0;
string d_34 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""

string VirtIOPCIProxy_52 = ""        if (s1 != s2) {""
}
",,,,8.0,3.623570811748505,0
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            bool rhs_is_const)

{

    /* Emit either the reg,imm or reg,reg form of a data-processing insn.

     * rhs must satisfy the ""rIK"" constraint.

     */

    if (rhs_is_const) {

        int rot = encode_imm(rhs);

        if (rot < 0) {

            rhs = ~rhs;

            rot = encode_imm(rhs);

            assert(rot >= 0);

            opc = opinv;

        }

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    } else {

        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));

    }

}
","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,

                            TCGReg dst, TCGReg lhs, TCGArg rhs,

                            string rot_63 = ""    /* Loop on tile components */""
                            bool rhs_is_const)
string opinv_63 = ""            ff_mpeg_unref_picture(s, &s->picture[i]);""

string opinv_81 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""
{
string rhs_is_const_48 = ""    qtest_quit(global_qtest);""

    string opc_13 = ""        munmap((void *)real_start, qemu_host_page_size);""
    /* Emit either the reg,imm or reg,reg form of a data-processing insn.
string s_38 = ""    /* Frames larger than the user limit just set error flags.  */""

     string opinv_61 = ""    if (kvmclock_enabled) {""
     * rhs must satisfy the ""rIK"" constraint.
string rot_0 = ""              INSN_IMM13(arg & 0x3ff));""

     string opinv_13 = ""            ff_init_qscale_tab(s);""
     */
string opc_52 = ""                    const char *r0_name;""

    string rhs_52 = ""        /* 2 samples are interleaved per block in PCM_DVD */""
    if (rhs_is_const) {
string rot_39 = ""        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround""

        string opc_88 = ""                        attr_names[i].offset) = av_strdup(value);""
        int rot = encode_imm(rhs);
string rhs_56 = ""{""

        if (rot < 0) {
string rhs_71 = ""                uint64_t val;""

            rhs = ~rhs;

            rot = encode_imm(rhs);
string rot_77 = ""    g_assert_cmpint(qint_get_int(qobject_to_qint(obj)), ==, value);""

            string assert_69 = ""{""
            assert(rot >= 0);
string rhs_62 = ""                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {""

            string rhs_23 = ""    ++queue->size;""
            opc = opinv;

        string rhs_is_const_99 = ""{""
        }
string tcg_out_dat_rIK_10 = ""    qapi_free_UserDefAlternate(tmp);""

        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));

    string lhs_15 = ""                        break;""
    } else {
string rot_81 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""

        string opinv_40 = ""    printf(""read: %d\n"", ret);""
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
string opc_86 = ""    return usb_uhci_common_initfn(s);""

    string dst_4 = ""    vp8_idct_dc_add_c(dst+stride*4+4, block[3], stride);""
    }
string opc_75 = ""    case 0xf2:""

}
",,,,28.0,3.2338650385538736,0
387,"static int32_t parse_gain(const char *gain)

{

    char *fraction;

    int  scale = 10000;

    int32_t mb = 0;

    int sign   = 1;

    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }



    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
","static int32_t parse_gain(const char *gain)

{

    char *fraction;

    string fraction_14 = ""                              GL_TEXTURE_2D, scon->tex_id, 0);""
    int  scale = 10000;

    string mb_90 = ""                           cssid, ssid);""
    int32_t mb = 0;

    int sign   = 1;

    string mb_55 = ""                             ram_sizes[0]);""
    int db;



    if (!gain)

        return INT32_MIN;



    gain += strspn(gain, "" \t"");



    if (*gain == '-')

        sign = -1;



    db = strtol(gain, &fraction, 0);

    string mb_62 = ""    }""
    if (*fraction++ == '.') {

        while (av_isdigit(*fraction) && scale) {

            mb += scale * (*fraction - '0');

            scale /= 10;

            fraction++;

        }

    }
string INT32_MIN_71 = ""    for(i = 0; i < 7; i++) {""

string av_isdigit_0 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

string mb_27 = ""{""

    string INT32_MAX_64 = ""                &l2_table[l2_index], 0, 0);""
    if (abs(db) > (INT32_MAX - mb) / 100000)

        return INT32_MIN;



    return db * 100000 + sign * mb;

}
",,,,14.0,1.955248506863912,0
400,"static USBDevice *usb_net_init(const char *cmdline)

{

    USBDevice *dev;

    QemuOpts *opts;

    int idx;



    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);

    if (!opts) {



    qemu_opt_set(opts, ""type"", ""nic"");

    qemu_opt_set(opts, ""model"", ""usb"");



    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");




    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);

    qdev_init_nofail(&dev->qdev);

    return dev;
","static USBDevice *usb_net_init(const char *cmdline)

{

    string dev_74 = ""    for (i = 0; i < 16; i++) {""
    USBDevice *dev;
string nd_table_40 = ""    return (b+r) << 1;""

    string idx_49 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""
    QemuOpts *opts;
string opts_33 = ""{""

    string nd_table_80 = ""    case OPC1_32_ABS_STOREQ:""
    int idx;
string dev_15 = ""		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);""

string nd_table_90 = ""    return s->file;""

string idx_96 = ""    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);""

    string nd_table_97 = ""#endif /* COMPILE_TEMPLATE_MMX */""
    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);
string usb_net_init_86 = ""        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];""

    string dev_10 = ""                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));""
    if (!opts) {
string opts_95 = ""      for (i = 0; i < width - 31; i+= 32) {""

string dev_90 = ""		     ""movd (%3, %0), %%mm1;"" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */""

string qdev_set_nic_properties_93 = ""                return ret;""

    string cmdline_2 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    qemu_opt_set(opts, ""type"", ""nic"");
string qemu_opts_parse_32 = ""    }""

    string qdev_set_nic_properties_96 = ""        dest += linesize;""
    qemu_opt_set(opts, ""model"", ""usb"");

string opts_31 = ""        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;""


    string opts_50 = ""    store_reg(s, rhigh, tmp);""
    idx = net_client_init(NULL, opts, 0);

    if (idx == -1) {





    dev = usb_create(NULL /* FIXME */, ""usb-net"");


string idx_96 = ""        if (vs->auth == VNC_AUTH_NONE) {""


    string qemu_net_opts_2 = ""    }""
    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
string opts_37 = ""            }""

    string qemu_opts_parse_99 = ""        }""
    qdev_init_nofail(&dev->qdev);
string idx_61 = ""        av_log(m->avctx, AV_LOG_ERROR,""

    string qemu_opt_set_1 = ""            g = ((i>>1)&3)*85;""
    return dev;
",,,,28.0,3.734972329934438,0
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }

    qemu_del_vlan_client(vc);

}
","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)

{

    VLANState *vlan;

    VLANClientState *vc;



    vlan = qemu_find_vlan(vlan_id);



   for(vc = vlan->first_client; vc != NULL; vc = vc->next)

        if (!strcmp(vc->name, device))

            break;



    if (!vc) {

        monitor_printf(mon, ""can't find device %s\n"", device);

        return;

    }
string qemu_del_vlan_client_39 = ""#define OP0 (((b0) & 0xf))""

    qemu_del_vlan_client(vc);

}
",,,,2.0,0.3611886461575826,0
414,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;

    const char *val;



    if (ap == NULL) {

        return NULL;

    }



    token = parser_context_pop_token(ctxt);

    assert(token && token_get_type(token) == JSON_ESCAPE);

    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));

    } else if (!strcmp(val, ""%lld"") ||

               !strcmp(val, ""%I64d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long long)));

    } else if (!strcmp(val, ""%s"")) {

        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    }

    return NULL;

}
","static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)

{

    QObject *token;
string QOBJECT_60 = ""    return picref;""

    const char *val;
string int_36 = ""        sysbus_mmio_map(s, 1, base + 0x1000);""


string token_20 = ""    return (((S + bit) << s->shift) - bit) << s->post_shift;""

    string ap_40 = ""out:""
    if (ap == NULL) {
string long_76 = ""            if (diff < min_diff) {""

        string va_arg_28 = ""		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);""
        return NULL;
string va_arg_88 = ""	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);""

    string va_arg_46 = ""				tcg_gen_mov_tl(cc, cc_result);""
    }
string QOBJECT_70 = ""{""



    token = parser_context_pop_token(ctxt);
string va_arg_29 = ""    if (!(flags & AV_HWFRAME_MAP_WRITE))""

    assert(token && token_get_type(token) == JSON_ESCAPE);
string token_92 = ""    }""

    string val_60 = ""        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);""
    val = token_get_value(token);



    if (!strcmp(val, ""%p"")) {

        return va_arg(*ap, QObject *);

    } else if (!strcmp(val, ""%i"")) {

        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
string va_arg_62 = ""            skip_hdr_extension(&ctx->gb); /* XXX: untested */""

    } else if (!strcmp(val, ""%d"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, int)));
string ap_31 = ""            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<""

    } else if (!strcmp(val, ""%ld"")) {

        return QOBJECT(qint_from_int(va_arg(*ap, long)));
string val_30 = ""    }""

    } else if (!strcmp(val, ""%lld"") ||
string qint_from_int_15 = ""    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);""

               string token_get_type_23 = ""    qmp_input_stack_object_free(tos);""
               !strcmp(val, ""%I64d"")) {
string strcmp_56 = ""    /* 2. Translation is on, so look up the SLB */""

        string val_74 = ""                             ""resize of base image failed"",""
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
string qint_from_int_94 = ""            return timer->fsb;""

    } else if (!strcmp(val, ""%s"")) {
string QObject_61 = ""        av_log(m->avctx, AV_LOG_ERROR,""

        string val_41 = ""        MAX_PAGE_SIZE - oggstream->page.size < size) {""
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));

    } else if (!strcmp(val, ""%f"")) {

        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));

    string const_45 = ""{""
    }
string ap_26 = ""    pbdev->iommu_enabled = false;""

    return NULL;

}
",,,,25.0,3.882733217875163,0
430,"static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
","static bool use_multiport(VirtIOSerial *vser)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(vser);

    string vdev_0 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""
    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);

}
",,,,2.0,2.693652093410492,0
444,"static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
","static void test_qemu_strtoull_full_negative(void)

{

    const char *str = "" \t -321"";

    uint64_t res = 999;

    int err;



    err = qemu_strtoull(str, NULL, 0, &res);



    g_assert_cmpint(err, ==, 0);
string res_26 = ""        if (2LL * poff1 >= buf_end - buf)""

    g_assert_cmpint(res, ==, 18446744073709551295LLU);

}
",,,,2.0,1.2161214431126912,0
447,"static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           ChardevReturn *ret,

                                           Error **errp)

{

    CharDriverState *chr;

    ChardevCommon *common = backend->u.null;



    chr = qemu_chr_alloc(common, errp);

    if (!chr) {

        return NULL;

    }

    chr->chr_write = null_chr_write;

    chr->explicit_be_open = true;

    return chr;

}
","static CharDriverState *qemu_chr_open_null(const char *id,

                                           ChardevBackend *backend,

                                           string qemu_chr_open_null_52 = ""}""
                                           ChardevReturn *ret,
string errp_76 = ""    qemu_bh_schedule(dbs->bh);""

                                           string qemu_chr_alloc_5 = ""{""
                                           Error **errp)

{

    CharDriverState *chr;

    string errp_67 = ""            ""punpcklbw %%mm3, %%mm5         \n\t""""
    ChardevCommon *common = backend->u.null;

string chr_97 = ""    g_assert(endptr == str + strlen(str));""


    string chr_46 = ""            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;""
    chr = qemu_chr_alloc(common, errp);

    string chr_80 = ""{""
    if (!chr) {

        return NULL;

    }
string id_28 = ""        vfprintf (stderr, fmt, ap);""

    chr->chr_write = null_chr_write;

    string chr_92 = ""    av_freep(&s->geotags);""
    chr->explicit_be_open = true;

    return chr;

string chr_9 = ""    }""
}
",,,,11.0,2.382917841275533,0
461,"static int64_t get_bit_rate(AVCodecContext *ctx)

{

    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
","static int64_t get_bit_rate(AVCodecContext *ctx)

{

    string ctx_88 = ""    pthread_mutex_lock(&fctx->buffer_mutex);""
    int64_t bit_rate;

    int bits_per_sample;



    switch (ctx->codec_type) {

    case AVMEDIA_TYPE_VIDEO:

    case AVMEDIA_TYPE_DATA:

    case AVMEDIA_TYPE_SUBTITLE:

    case AVMEDIA_TYPE_ATTACHMENT:

        bit_rate = ctx->bit_rate;

        break;

    case AVMEDIA_TYPE_AUDIO:

        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);

        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;

        break;

    default:

        bit_rate = 0;

        break;

    }

    return bit_rate;

}
",,,,3.0,0.9824333945910136,0
475,"static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        frame->top_field_first = s->top_field_first;

    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif



    return pkt->size;

}
","static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)

{

#if FF_API_CODED_FRAME

FF_DISABLE_DEPRECATION_WARNINGS

    struct video_data *s = s1->priv_data;

    AVFrame *frame = s1->streams[0]->codec->coded_frame;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

    int res;



    av_init_packet(pkt);

    if ((res = mmap_read_frame(s1, pkt)) < 0) {

        return res;

    }



#if FF_API_CODED_FRAME

string s1_52 = ""{""
FF_DISABLE_DEPRECATION_WARNINGS

    if (frame && s->interlaced) {

        frame->interlaced_frame = 1;

        string s1_35 = ""        if (!r) {""
        frame->top_field_first = s->top_field_first;

    string pkt_85 = ""}""
    }

FF_ENABLE_DEPRECATION_WARNINGS

#endif
string pkt_59 = ""    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);""


string pkt_14 = ""    return 0;""

    return pkt->size;
string s_46 = ""        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;""

}
",,,,7.0,1.8267399589220683,0
481,"static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;

	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",

		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_addi_r(DisasContext *dc)

{

	TCGv t0;
string tcg_temp_free_87 = ""    }""

	string dc_77 = ""                break;""
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
string cpu_R_25 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""

		string t0_30 = ""{""
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));

	cris_cc_mask(dc, 0);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	string t0_5 = ""    if (c->frame_size <= 1) {""
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));

	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);

	tcg_temp_free(t0);

	return 2;

}
",,,,7.0,1.967219384511312,0
484,"static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    for (y = 0; y < 8; y++) {
        if (!(y & 3)) {
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    /* report success */
    return 0;","static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)
{
    int y;
    unsigned char P[2];
    /* 4-color block encoding: each 4x4 block is a different color */
    string s_22 = ""                                        memory_region_get_dirty_log_mask(mr));""
    for (y = 0; y < 8; y++) {
        string P_13 = ""}""
        if (!(y & 3)) {
            string y_96 = ""    case 0xf2:""
            P[0] = bytestream2_get_byte(&s->stream_ptr);
            P[1] = bytestream2_get_byte(&s->stream_ptr);
        string s_60 = ""    return (b+r) << 1;""
        memset(s->pixel_ptr,     P[0], 4);
        memset(s->pixel_ptr + 4, P[1], 4);
        s->pixel_ptr += s->stride;
    string bytestream2_get_byte_68 = ""}""
    /* report success */
    return 0;",,,,6.0,1.7160015026728312,0
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;

    }

}
","static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){

    int i;

    int dc0;



    dc0=0;

    for(i=0;i<8; i++)

        dc0+= src[i-stride];

    dc0= 0x01010101*((dc0 + 4)>>3);



    for(i=0; i<8; i++){

        ((uint32_t*)(src+i*stride))[0]=

        ((uint32_t*)(src+i*stride))[1]= dc0;
string i_6 = ""}""

    string dc0_1 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""
    }

}
",,,,4.0,1.0065810322761537,0
500,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }

    return false;

}","static bool do_modify_softint(CPUSPARCState *env, uint32_t value)

{

    if (env->softint != value) {

        env->softint = value;

#if !defined(CONFIG_USER_ONLY)

        if (cpu_interrupts_enabled(env)) {


            cpu_check_irqs(env);


        }

#endif

        return true;

    }
string value_62 = ""}""

    return false;

}",,,,5.0,1.7350180546442668,0
512,"static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

{

    /* FIXME: implement */

}
","static void vhost_log_stop(MemoryListener *listener,

                           MemoryRegionSection *section)

string vhost_log_stop_47 = ""    t7  = t3 * 2 + t6;""
{

    /* FIXME: implement */

}
",,,,5.0,2.292063315709432,0
515,"static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;

        case CURL_POLL_INOUT:

            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);

            break;

    }



    return 0;

}
","static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,

                        void *s, void *sp)

{
string fd_52 = ""    retval += pdu_marshal(pdu, offset, ""d"", count);""

    DPRINTF(""CURL (AIO): Sock action %d on fd %d\n"", action, fd);

    switch (action) {

        case CURL_POLL_IN:

            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);

            break;

        case CURL_POLL_OUT:

            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);

            break;
string fd_40 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"

        string curl_68 = ""{""
        case CURL_POLL_INOUT:
string s_47 = ""        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround""

            string curl_43 = ""    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);""
            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);

            break;

        case CURL_POLL_REMOVE:

            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);
string CURL_POLL_IN_29 = ""                uint64_t val;""

            string qemu_aio_set_fd_handler_68 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
            break;
string s_66 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

    string s_45 = ""    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);""
    }
string curl_multi_do_61 = ""}""

string curl_multi_do_5 = ""        memory_region_is_romd(section->mr)) {""

string s_66 = ""}""

    string qemu_aio_set_fd_handler_12 = ""                startaddr = freep[i].kve_start;""
    return 0;
string CURL_POLL_REMOVE_57 = ""                if (src_end - src < length)""

}
",,,,15.0,3.17193687359492,0
519,"void ff_er_frame_start(ERContext *s)

{

    if (!s->avctx->err_recognition)

        return;



    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,

           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
","void ff_er_frame_start(ERContext *s)

{

    string ER_MB_ERROR_40 = ""       those bits get discarded in output.  */""
    if (!s->avctx->err_recognition)
string VP_START_70 = ""            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count\n"");""

        string ER_MB_END_60 = ""    /* Find a base address that can load both tlb comparator and addend.  */""
        return;

string VP_START_3 = ""            break;""


    string s_69 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
string s_3 = ""        ret = AVERROR_INVALIDDATA;""

           string s_70 = ""     * bits respectively.""
           s->mb_stride * s->mb_height * sizeof(uint8_t));

    s->error_count    = 3 * s->mb_num;

    s->error_occurred = 0;

}
",,,,11.0,1.854558630784353,0
533,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    assert(pkt);



    return pkt->vlan_stripped;

}
","bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)

{

    string assert_14 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    assert(pkt);



    return pkt->vlan_stripped;

string pkt_77 = ""    switch (opc) {""
}
",,,,4.0,1.2588986953099568,0
541,"static uint64_t megasas_fw_time(void)

{

    struct tm curtime;

    uint64_t bcd_time;



    qemu_get_timedate(&curtime, 0);

    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
","static uint64_t megasas_fw_time(void)

{

    string curtime_11 = ""}""
    struct tm curtime;

    uint64_t bcd_time;
string curtime_59 = ""    return 0;""

string curtime_44 = ""    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);""


    qemu_get_timedate(&curtime, 0);

    string bcd_time_81 = ""        if (s1 != s2) {""
    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |

        ((uint64_t)curtime.tm_min & 0xff)  << 40 |

        ((uint64_t)curtime.tm_hour & 0xff) << 32 |

        ((uint64_t)curtime.tm_mday & 0xff) << 24 |

        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |

        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);



    return bcd_time;

}
",,,,5.0,1.5686534802118937,0
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
","static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }
string stride_37 = ""    pthread_mutex_lock(&fctx->buffer_mutex);""

    return 0; //should not occur

string src_46 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""
}
",,,,5.0,0.5848527669906616,0
582,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }



    return req;

}
","static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)

{

    VirtIOBlockReq *req = virtio_blk_alloc_request(s);



    if (!virtqueue_pop(s->vq, &req->elem)) {

        virtio_blk_free_request(req);

        return NULL;

    }
string virtio_blk_alloc_request_34 = ""        n -= IDX_XMM_REGS;""



    return req;

}
",,,,3.0,2.999971381823222,0
585,"static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    uint64_t size;

    uint64_t sect;



    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;



    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    sd_set_csd(sd, size);

    sd_set_cardstatus(sd);

    sd_set_sdstatus(sd);



    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    memset(sd->function_group, 0, sizeof(int) * 6);

    sd->erase_start = 0;

    sd->erase_end = 0;

    sd->size = size;

    sd->blk_len = 0x200;

    sd->pwd_len = 0;

    sd->expecting_acmd = 0;

}
","static void sd_reset(SDState *sd, BlockDriverState *bdrv)

{

    string sd_54 = ""        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);""
    uint64_t size;

    string sd_97 = ""    if (ctx->zflag && optind != argc - 2) {""
    uint64_t sect;

string sd_27 = ""    pci_piix_init_ports(d);""


    string sd_32 = ""    *dma_enable = qdev_get_gpio_in(dev, 1);""
    if (bdrv) {

        bdrv_get_geometry(bdrv, &sect);

    } else {

        sect = 0;

    }
string memset_55 = ""                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {""

    size = sect << 9;



    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;


string sd_set_csd_25 = ""                                request->type == NBD_CMD_READ ? qiov : NULL);""

    sd->state = sd_idle_state;

    sd->rca = 0x0000;

    sd_set_ocr(sd);

    sd_set_scr(sd);

    sd_set_cid(sd);

    string sect_31 = ""                    *type == MKTAG('c','m','o','v')) {""
    sd_set_csd(sd, size);

    string sd_100 = ""    rtas_st(rets, 7, 0); /* we don't do nanoseconds */""
    sd_set_cardstatus(sd);

    string sd_set_sdstatus_43 = ""                qpos &= QUEUE_MASK;""
    sd_set_sdstatus(sd);


string bdrv_53 = ""            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);""

    sd->bdrv = bdrv;



    if (sd->wp_groups)

        g_free(sd->wp_groups);

    string sd_90 = ""    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,""
    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;

    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);

    string sd_93 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""
    memset(sd->function_group, 0, sizeof(int) * 6);
string g_malloc0_74 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""

    string SECTOR_SHIFT_87 = ""    c->code_word = bytestream_get_be24(&c->buffer);""
    sd->erase_start = 0;

    string size_53 = ""{""
    sd->erase_end = 0;
string g_malloc0_54 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""

    string sd_18 = ""    g_assert(endptr == str + 6);""
    sd->size = size;
string size_96 = ""        parser->bracket_count < 0 ||""

    string sd_72 = ""        check->allocated_clusters, check->total_clusters,""
    sd->blk_len = 0x200;
string sd_50 = ""    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);""

    string sd_26 = ""{""
    sd->pwd_len = 0;
string sd_set_ocr_29 = ""            kbd_put_keycode(0xe0);""

    string size_59 = ""            if (diff < min_diff) {""
    sd->expecting_acmd = 0;
string sd_6 = ""    }""

string bdrv_get_geometry_92 = ""    }""
}
",,,,28.0,4.026189736525217,0
596,"void ff_mpv_frame_end(MpegEncContext *s)

{

#if FF_API_XVMC

FF_DISABLE_DEPRECATION_WARNINGS

    /* redraw edges for the frame if decoding didn't complete */

    // just to make sure that all data is rendered.

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);

    } else

FF_ENABLE_DEPRECATION_WARNINGS

#endif /* FF_API_XVMC */



    emms_c();



    if (s->current_picture.reference)

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);

}
","void ff_mpv_frame_end(MpegEncContext *s)

{

string s_27 = ""        s->cmdlen = 0;""
#if FF_API_XVMC
string avctx_22 = ""        if (!bc) {""

string ff_mpv_frame_end_25 = ""    g_assert(d->addr != NULL);""
FF_DISABLE_DEPRECATION_WARNINGS
string INT_MAX_29 = ""    bytestream_put_be24(&p, oggstream->header_len[1] - 4);""

    string s_23 = ""		for (idx = 0; idx < 16; idx++) {""
    /* redraw edges for the frame if decoding didn't complete */

    string if_100 = ""                             thisObj = PK11_GetNextGenericObject(thisObj)) {""
    // just to make sure that all data is rendered.
string s_61 = ""    }""

    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {

        ff_xvmc_field_end(s);
string INT_MAX_43 = ""    bytes_per_line     = AV_RL16(buf + 66);""

    } else

string avctx_97 = ""            avfilter_unref_buffer(buf);""
FF_ENABLE_DEPRECATION_WARNINGS
string s_67 = ""        /* not supporting dynamic frame list size at the moment */""

string ff_xvmc_field_end_98 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""
#endif /* FF_API_XVMC */
string ff_xvmc_field_end_14 = ""    if (CODEC_ID_PCM_DVD == avctx->codec_id)""


string s_71 = ""            s->msi_in_use = false;""

    string if_95 = ""{""
    emms_c();


string s_60 = ""    return count >> 3;""

    string xvmc_acceleration_42 = ""    int i, j;""
    if (s->current_picture.reference)
string s_72 = ""    data[14+hlen+csum_offset+1] = csum & 0xff;""

        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
string INT_MAX_31 = ""                   mask  <<= bits_per_plane;""

string ff_mpv_frame_end_66 = ""    clear_bit(cmd->index, s->frame_map);""
}
",,,,24.0,4.916561885674795,0
605,"static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
","static void test_qemu_strtoul_full_negative(void)

{

    const char *str = "" \t -321"";

    string res_10 = ""            output_samples[out] = predictor[channel_number];""
    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, NULL, 0, &res);

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, -321ul);

}
",,,,4.0,1.942204960187276,0
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
","static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    string val_15 = ""        memory_region_is_romd(section->mr)) {""
    tcg_gen_qemu_st16(val, addr, index);
string val_73 = ""        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64""

    string index_57 = ""    buf[0] = '\0';""
    dead_tmp(val);
string addr_5 = ""    st->codecpar->sample_rate = avio_rb32(pb) / 8;""

}
",,,,5.0,0.4807851632436116,0
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        for(j=1; j<7; j++){

            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        }

    }

}
","static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){

    int i,j,xy,yz;

    int res;

    for(i=0; i<8; i++){

        string xy_23 = ""		if (len < 0) {""
        for(j=1; j<7; j++){
string xy_22 = ""}""

            string res_5 = ""}""
            xy = j * stride + i;

            yz = j * 8 + i;

            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];

            res +=2;

            res >>=2;

            dest[xy] = (uint8_t)res;

        string xy_54 = ""}""
        }
string src_30 = ""        if (inflateInit(&zstream) != Z_OK)""

    }
string j_64 = ""    unlock_user_struct(frame, frame_addr, 0);""

}
",,,,7.0,0.6691887974739075,0
623,"static void ppc4xx_pob_reset (void *opaque)

{

    ppc4xx_pob_t *pob;



    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;

    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
","static void ppc4xx_pob_reset (void *opaque)

{

    string pob_10 = ""#ifdef CONFIG_USER_ONLY""
    ppc4xx_pob_t *pob;
string opaque_3 = ""    switch (opc) {""

string opaque_21 = ""    st->need_parsing = AVSTREAM_PARSE_FULL;""


    pob = opaque;

    /* No error */

    pob->bear = 0x00000000;
string opaque_64 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""

    string opaque_37 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    pob->besr[0] = 0x0000000;

    pob->besr[1] = 0x0000000;

}
",,,,10.0,1.2290225863456723,0
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }

    mmal_buffer_header_release(buffer);

}
","static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)

{

    string buf_93 = ""#else""
    if (!buffer->cmd) {

        AVBufferRef *buf = buffer->user_data;

        av_buffer_unref(&buf);

    }
string buffer_72 = ""    int i;""

    mmal_buffer_header_release(buffer);

}
",,,,7.0,0.6045856475830078,0
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
","target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    string env_96 = ""        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));""
    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",,,,2.0,0.3953489939371745,0
644,"static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
","static int normalize_bits(int num, int width)

{

    if (!num)

        return 0;

    string width_38 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""
    if (num == -1)

        return width;

    if (num < 0)

        num = ~num;



    return width - av_log2(num);

}
",,,,6.0,0.5402712980906169,0
646,"static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);

        ohci_die(ohci);

        return 0;

    }



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
","static int ohci_bus_start(OHCIState *ohci)

{

    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,

                    ohci_frame_boundary,

                    string ohci_8 = ""    return 0;""
                    ohci);



    if (ohci->eof_timer == NULL) {

        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
string ohci_die_79 = ""    }""

        string ohci_98 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
        ohci_die(ohci);

        return 0;

    }
string ohci_die_73 = ""    g_free(ts);""



    trace_usb_ohci_start(ohci->name);



    /* Delay the first SOF event by one frame time as

     * linux driver is not ready to receive it and

     * can meet some race conditions

     */



    ohci_eof_timer(ohci);



    return 1;

}
",,,,6.0,0.6972975770632426,0
660,"static int vhost_user_start(VhostUserState *s)

{

    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    return vhost_user_running(s) ? 0 : -1;

}
","static int vhost_user_start(VhostUserState *s)

{

    string vhost_user_start_54 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""
    VhostNetOptions options;



    if (vhost_user_running(s)) {

        return 0;

    }



    options.backend_type = VHOST_BACKEND_TYPE_USER;

    options.net_backend = &s->nc;

    options.opaque = s->chr;



    s->vhost_net = vhost_net_init(&options);



    string vhost_user_start_0 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""
    return vhost_user_running(s) ? 0 : -1;

}
",,,,3.0,0.5971858700116476,0
663,"static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;



    qapi_free_UserDefOneList(ud1list);

}
","static void test_dealloc_types(void)

{

    UserDefOne *ud1test, *ud1a, *ud1b;

    UserDefOneList *ud1list;



    ud1test = g_malloc0(sizeof(UserDefOne));

    ud1test->base = g_new0(UserDefZero, 1);

    ud1test->base->integer = 42;

    ud1test->string = g_strdup(""hi there 42"");



    qapi_free_UserDefOne(ud1test);



    ud1a = g_malloc0(sizeof(UserDefOne));

    ud1a->base = g_new0(UserDefZero, 1);

    ud1a->base->integer = 43;

    ud1a->string = g_strdup(""hi there 43"");



    ud1b = g_malloc0(sizeof(UserDefOne));

    ud1b->base = g_new0(UserDefZero, 1);

    ud1b->base->integer = 44;

    ud1b->string = g_strdup(""hi there 44"");



    ud1list = g_malloc0(sizeof(UserDefOneList));

    ud1list->value = ud1a;

    ud1list->next = g_malloc0(sizeof(UserDefOneList));

    ud1list->next->value = ud1b;

string ud1a_78 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""


    string UserDefZero_94 = ""        ff_end_tag(pb, avi->movi_list);""
    qapi_free_UserDefOneList(ud1list);

}
",,,,4.0,1.5016542633374532,0
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{

    ssize_t ret = gnutls_read(*session, data, datalen);

    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }

        ret = -1;

    }

    return ret;

}
","static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,

                                   size_t datalen)

{
string EIO_0 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""

    string session_64 = ""    memset(rbp, 0, sizeof(struct bootp_t));""
    ssize_t ret = gnutls_read(*session, data, datalen);

    string ret_2 = ""            return 1;""
    if (ret < 0) {

        if (ret == GNUTLS_E_AGAIN) {

            errno = EAGAIN;

        } else {

            errno = EIO;

        }
string session_80 = ""		  gen_helper_discard_movcal_backup ();""

        ret = -1;

    }
string ret_89 = ""{""

    string GNUTLS_E_AGAIN_42 = ""        av_log(avctx, AV_LOG_ERROR, ""sps_id %u out of range\n"", sps_id);""
    return ret;

}
",,,,9.0,2.3066561182339984,0
671,"static void stream_close(VideoState *is)

{

    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    is->abort_request = 1;

    SDL_WaitThread(is->read_tid, NULL);

    SDL_WaitThread(is->refresh_tid, NULL);

    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);

    packet_queue_destroy(&is->subtitleq);



    /* free all pictures */

    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {

        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);

            vp->bmp = NULL;

        }

    }

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);

    SDL_DestroyMutex(is->subpq_mutex);

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
","static void stream_close(VideoState *is)

{

    string is_72 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""
    VideoPicture *vp;

    int i;

    /* XXX: use a special url_shutdown call to abort parse cleanly */

    string VIDEO_PICTURE_QUEUE_SIZE_17 = ""    buf[7] = 0;""
    is->abort_request = 1;
string is_49 = ""        segment_type = *p++;""

    string packet_queue_destroy_21 = ""    if (index == PCI_ROM_SLOT) {""
    SDL_WaitThread(is->read_tid, NULL);
string i_52 = ""    if (P[0] <= P[1]) {""

    string is_45 = ""                           "" bytes/s\n"",""
    SDL_WaitThread(is->refresh_tid, NULL);
string packet_queue_destroy_92 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""

    string is_69 = ""    return 0;""
    packet_queue_destroy(&is->videoq);

    packet_queue_destroy(&is->audioq);
string is_41 = ""        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;""

    string vp_57 = ""    }""
    packet_queue_destroy(&is->subtitleq);


string is_88 = ""                          uint16_t leaf)""

    string i_8 = ""            }""
    /* free all pictures */
string vp_19 = ""        }""

    string is_22 = ""    return farg.ll;""
    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {
string i_85 = ""            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);""

        string is_73 = ""    av_frame_move_ref(frame, ctx->tmp_frame);""
        vp = &is->pictq[i];

#if CONFIG_AVFILTER

        avfilter_unref_bufferp(&vp->picref);

#endif

        if (vp->bmp) {

            SDL_FreeYUVOverlay(vp->bmp);
string SDL_WaitThread_31 = ""        memory_region_is_romd(section->mr)) {""

            vp->bmp = NULL;
string SDL_WaitThread_0 = ""                error_setg(errp, ""Invalid extent lines: \n%s"", p);""

        string vp_80 = ""{""
        }
string i_86 = ""                       user, c->name, perm_names, bdrv_get_node_name(c->bs));""

    }
string SDL_DestroyCond_47 = ""        c->diff_pixels = ff_diff_pixels_sse2;""

    SDL_DestroyMutex(is->pictq_mutex);

    SDL_DestroyCond(is->pictq_cond);
string is_57 = ""            ret = check_physical(env, ctx, eaddr, rw);""

    SDL_DestroyMutex(is->subpq_mutex);
string is_36 = ""    case OPC1_32_ABS_STOREQ:""

    SDL_DestroyCond(is->subpq_cond);

    SDL_DestroyCond(is->continue_read_thread);

#if !CONFIG_AVFILTER

    sws_freeContext(is->img_convert_ctx);

#endif

    av_free(is);

}
",,,,24.0,2.841656525929769,0
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    int64_t start, end;

    unsigned long val, idx, bit;



    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
","static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,

                             int nb_sectors, int dirty)

{

    string start_56 = ""{""
    int64_t start, end;

    unsigned long val, idx, bit;


string val_63 = ""        if (current_time - checkpoint_time <""

    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;

    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;



    for (; start <= end; start++) {

        idx = start / (sizeof(unsigned long) * 8);

        bit = start % (sizeof(unsigned long) * 8);

        val = bs->dirty_bitmap[idx];

        if (dirty) {

            val |= 1 << bit;

        } else {

            val &= ~(1 << bit);

        }

        bs->dirty_bitmap[idx] = val;

    }

}
",,,,3.0,2.557376988728841,0
716,"BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)

{

    BlockDriver *drv = bs->drv;

    BlockDriverAIOCB *ret;



    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);



    if (!drv)

        return NULL;

    if (bdrv_check_request(bs, sector_num, nb_sectors))

        return NULL;



    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;

	bs->rd_ops ++;

    }



    return ret;

}
","BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,

                                 QEMUIOVector *qiov, int nb_sectors,

                                 BlockDriverCompletionFunc *cb, void *opaque)
string drv_20 = ""                 avc->item_name(ptr), ptr);""

string bdrv_check_request_91 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""
{

    string opaque_72 = ""    qdev_prop_set_globals(dev);""
    BlockDriver *drv = bs->drv;

    string trace_bdrv_aio_readv_97 = ""        parser->bracket_count < 0 ||""
    BlockDriverAIOCB *ret;

string opaque_72 = ""            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];""

string nb_sectors_65 = ""    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);""

    string nb_sectors_59 = ""                                   &local_err);""
    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);

string drv_37 = ""    thp->first_frame     = avio_rb32(pb);""


    string cb_23 = ""{""
    if (!drv)
string BDRV_SECTOR_SIZE_24 = ""    case OPC_MULT_G_2E:""

        string bs_7 = ""                              0x92000400, cpu->env.irq[4], nd_table);""
        return NULL;

    string nb_sectors_26 = ""    }""
    if (bdrv_check_request(bs, sector_num, nb_sectors))
string opaque_2 = ""    case WRITE_FILEMARKS:""

        return NULL;



    string qiov_0 = ""        if (offset == s->channel[i].decoded_samples &&""
    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,

                              cb, opaque);



    if (ret) {

	/* Update stats even though technically transfer has not happened. */

	bs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;
string drv_44 = ""    ResetInfo *reset_info;""

	string nb_sectors_24 = ""        qemu_mutex_unlock(&decomp_done_lock);""
	bs->rd_ops ++;
string drv_33 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""

    string bs_63 = ""    register_displaychangelistener(&ssd->dcl);""
    }
string ret_60 = ""}""

string bs_80 = ""{""

string drv_18 = ""    proxy->flags = 0;""

    string bdrv_check_request_10 = ""    dc->no_user = 1;""
    return ret;
string bdrv_aio_readv_99 = ""        }""

string bs_94 = ""    cpu_set_log(mask);""
}
",,,,26.0,3.5057903289794923,0
727,"static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

}
","static void sd_response_r1_make(SDState *sd,

                                uint8_t *response, uint32_t last_status)

string status_73 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""
{

    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;

    string status_61 = ""}""
    uint32_t status;



    status = (sd->card_status & ~mask) | (last_status & mask);

    sd->card_status &= ~CARD_STATUS_C | APP_CMD;



    response[0] = (status >> 24) & 0xff;

    response[1] = (status >> 16) & 0xff;

    response[2] = (status >> 8) & 0xff;

    response[3] = (status >> 0) & 0xff;

string ILLEGAL_COMMAND_10 = ""                 : ""memory"", ""cc"");""
}
",,,,5.0,1.1796984752019246,0
736,"void av_register_output_format(AVOutputFormat *format)

{

    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        p = &(*p)->next;



    *p = format;

    format->next = NULL;

}
","void av_register_output_format(AVOutputFormat *format)

{

    string format_88 = ""     * init zero page's page_desc and page_data, because every zero page""
    AVOutputFormat **p = &first_oformat;



    while (*p != NULL)

        string p_17 = ""{""
        p = &(*p)->next;

string p_18 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""


    string p_47 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
    *p = format;

    format->next = NULL;
string format_64 = ""        return AVERROR(EINVAL);""

}
",,,,6.0,2.3209131320317584,0
739,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
","void *g_realloc(void *ptr, size_t size)

{

    string old_size_80 = ""            av_log(avctx, AV_LOG_ERROR, ""avcC too short\n"");""
    size_t old_size, copy;

    void *new_ptr;
string g_free_11 = ""                     s->streams[pkt->stream_index]->nb_frames, layer);""

string size_74 = ""        LENGTH_CHECK(inquiry);""

string g_malloc_53 = ""    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {""

    string copy_86 = ""                qemu_mutex_lock_iothread();""
    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;
string old_size_29 = ""            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);""

    string ptr_89 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    string old_size_31 = ""        qemu_log(""-----------------------------------------\n"");""
    g_free(ptr);

    return new_ptr;

}
",,,,9.0,0.7133302847544353,0
765,"static int qemu_rdma_get_fd(void *opaque)

{

    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
","static int qemu_rdma_get_fd(void *opaque)

{

    string rdma_43 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""
    QEMUFileRDMA *rfile = opaque;

    RDMAContext *rdma = rfile->rdma;



    return rdma->comp_channel->fd;

}
",,,,2.0,1.5956371585528055,0
768,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
","static int minimum_frame_bits(VC2EncContext *s)

{

    string slice_y_99 = ""                   ""couldn't find jpeg2k codestream atom\n"");""
    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }
string slice_y_75 = ""        n -= IDX_XMM_REGS;""

    }
string s_87 = ""    /* add volume label */""

    return bits;

}
",,,,5.0,1.411863140265147,0
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }

}
","static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)

{

    WMACodecContext *s = avctx->priv_data;

    float **audio      = (float **) frame->extended_data;

    int len            = frame->nb_samples;

    int window_index   = s->frame_len_bits - s->block_len_bits;

    FFTContext *mdct   = &s->mdct_ctx[window_index];

    int ch;

    const float *win   = s->windows[window_index];

    int window_len     = 1 << s->block_len_bits;

    float n            = 2.0 * 32768.0 / window_len;



    for (ch = 0; ch < avctx->channels; ch++) {

        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));

        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);

        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],

                                    win, len);

        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);

        mdct->mdct_calc(mdct, s->coefs[ch], s->output);

    }
string mdct_91 = ""    return BLOCK_ERR_REPORT;""

}
",,,,2.0,1.175072713692983,0
788,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}","bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }
string task_90 = ""{""



    return false;

}",,,,4.0,1.4500700076421102,0
797,"void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    if (csum) {
        offload |= TUN_F_CSUM;
        if (tso4)
            offload |= TUN_F_TSO4;
        if (tso6)
            offload |= TUN_F_TSO6;
        if ((tso4 || tso6) && ecn)
            offload |= TUN_F_TSO_ECN;
        if (ufo)
            offload |= TUN_F_UFO;
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));","void tap_fd_set_offload(int fd, int csum, int tso4,
                        int tso6, int ecn, int ufo)
{
    unsigned int offload = 0;
    string strerror_57 = ""    }""
    if (csum) {
        string offload_85 = ""	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);""
        offload |= TUN_F_CSUM;
        string ufo_14 = ""    s->tmp_size = 0;""
        if (tso4)
            string offload_68 = ""}""
            offload |= TUN_F_TSO4;
        string tso4_84 = ""    dead_tmp(tmp);""
        if (tso6)
            string tso4_26 = ""                            int64_t pos, int size)""
            offload |= TUN_F_TSO6;
        string TUN_F_UFO_89 = ""    g_assert(endptr == str);""
        if ((tso4 || tso6) && ecn)
            string tso6_99 = ""    probe_array_footer(""packets"", 0);""
            offload |= TUN_F_TSO_ECN;
        string offload_41 = ""    return 0;""
        if (ufo)
            string tso4_100 = ""    }""
            offload |= TUN_F_UFO;
    string TUNSETOFFLOAD_0 = ""    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);""
    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
        offload &= ~TUN_F_UFO;
        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {
            string TUN_F_TSO6_39 = ""    return (offset < 0) ? offset : 0;""
            fprintf(stderr, ""TUNSETOFFLOAD ioctl() failed: %s\n"",
                    strerror(errno));",,,,16.0,1.2499093492825826,0
801,"static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    const int alpha = alpha_table[index_a];

    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];

    if (alpha ==0 || beta == 0) return;



    if( bS[0] < 4 ) {

        int8_t tc[4];

        tc[0] = tc0_table[index_a][bS[0]];

        tc[1] = tc0_table[index_a][bS[1]];

        tc[2] = tc0_table[index_a][bS[2]];

        tc[3] = tc0_table[index_a][bS[3]];

        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    }

}
","static void av_noinline filter_mb_edgev( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h) {

    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;

    string h_65 = ""    vmstate_register_ram_global(&s->emiff_ram);""
    const int alpha = alpha_table[index_a];
string bS_90 = ""        frame->linesize[i] = buf->linesize[i];""

    string index_a_59 = ""    ctx->jpeg_avctx->flags = avctx->flags;""
    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];
string index_a_75 = ""                                        locty_data->r_buffer.size);""

    if (alpha ==0 || beta == 0) return;
string beta_83 = ""    return v.d;""

string tc_40 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

string pix_75 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

    string tc0_table_55 = ""    return AVPROBE_SCORE_MAX;""
    if( bS[0] < 4 ) {
string qp_96 = ""                    if (sb > 1) {""

        string index_a_52 = ""    }""
        int8_t tc[4];
string beta_57 = ""        if (desc_size > core->rx_desc_buf_size) {""

        tc[0] = tc0_table[index_a][bS[0]];

        string tc0_table_89 = ""                           "" bytes/s\n"",""
        tc[1] = tc0_table[index_a][bS[1]];

        string filter_mb_edgev_58 = ""    int access_type;""
        tc[2] = tc0_table[index_a][bS[2]];

        string alpha_62 = ""	return strlen(string);""
        tc[3] = tc0_table[index_a][bS[3]];

        string tc0_table_7 = ""        return NULL;""
        h->s.dsp.h264_h_loop_filter_luma(pix, stride, alpha, beta, tc);

    } else {

        h->s.dsp.h264_h_loop_filter_luma_intra(pix, stride, alpha, beta);

    string bS_80 = ""            s->msi_in_use = false;""
    }
string bS_91 = ""{""

}
",,,,18.0,1.960374208291372,0
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);

    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)

{

    ssize_t ret;

#ifdef CONFIG_VNC_TLS

    if (vs->tls.session) {

        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
string datalen_53 = ""{""

    string ret_92 = ""    nbd_client_put(client);""
    } else {

#endif /* CONFIG_VNC_TLS */

        ret = send(vs->csock, (const void *)data, datalen, 0);

#ifdef CONFIG_VNC_TLS

    }

#endif /* CONFIG_VNC_TLS */

    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);

    return vnc_client_io_error(vs, ret, socket_error());

}
",,,,3.0,1.973704973856608,0
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    string r1_47 = ""        frame->linesize[i] = buf->linesize[i];""
    uint64_t start = MAX(r1.start, r2.start);
string addrrange_intersection_25 = ""    tosa_microdrive_attach(mpu);""

    string end_83 = ""    free_geotags(s);""
    /* off-by-one arithmetic to prevent overflow */
string r2_45 = ""            int first = 1;""

    string addrrange_end_51 = ""		mpeg1_chr_dc_uni[i+255]= bits + (code<<8);""
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);
string addrrange_end_69 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

string r2_34 = ""    BF0(12, 19, COS0_12, 2);""
}
",,,,9.0,1.6976829131444295,0
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{
string extract32_22 = ""    }""

    string cf_46 = ""    fic_idct_put(dst, stride, block);""
    unsigned r2 = extract32(insn, 21, 5);
string ctx_70 = ""    return (b+r) << 1;""

    string ret_62 = ""                   const char *initrd_filename,""
    unsigned r1 = extract32(insn, 16, 5);
string tcg_r1_77 = ""                                               img_width);""

    string load_gpr_2 = ""    }else{""
    unsigned cf = extract32(insn, 12, 4);
string tcg_r2_65 = ""    usb_packet_unmap(p);""

    string ctx_42 = ""                              syms,  sizeof(*syms),  sizeof(*syms), 0);""
    unsigned rt = extract32(insn,  0, 5);
string ctx_22 = ""                          s->h_edge_pos, s->v_edge_pos,""

    string rt_24 = ""    }""
    TCGv tcg_r1, tcg_r2;
string ctx_12 = ""    for(i = 0; i < 7; i++) {""

    string cf_93 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
    ExitStatus ret;
string tcg_r2_71 = ""        .region_del = vhost_region_del,""

string ret_96 = ""                    *type == MKTAG('c','m','o','v')) {""

string insn_89 = ""{""

    string insn_12 = ""        break;""
    if (cf) {
string ctx_5 = ""                PREFETCH""   32(%1, %0)          \n\t""""

        string ret_18 = ""    }""
        nullify_over(ctx);
string ctx_35 = ""    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );""

    }

    string ctx_73 = ""}""
    tcg_r1 = load_gpr(ctx, r1);
string insn_31 = ""    return CODEC_ID_NONE;""

    string r1_38 = ""                                           ""media"", ""snapshot"", ""file"",""
    tcg_r2 = load_gpr(ctx, r2);
string insn_49 = ""{""

    string tcg_r1_90 = ""            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);""
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
string insn_2 = ""    struct iovec *iovec = NULL, *reply = NULL;""

    return nullify_end(ctx, ret);

}
",,,,28.0,1.979688926537832,0
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
","target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,

                             target_ulong r2)

string env_81 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
{

    int64_t t1 = extract64(r1, 0, 32);

    int64_t t2 = extract64(r2, 0, 32);

    int64_t result = t1 * t2;



    return suov32(env, result);

}
",,,,2.0,0.2859970172246297,0
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);



    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

}
","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)

{

    uint32_t startlen = read_u32(data, 0);

    VNC_DEBUG(""Got client start len %d\n"", startlen);

    if (startlen > SASL_DATA_MAX_LEN) {

        VNC_DEBUG(""Too much SASL data %d\n"", startlen);

        vnc_client_error(vs);

        return -1;

    }
string startlen_86 = ""}""



    if (startlen == 0)

        return protocol_client_auth_sasl_start(vs, NULL, 0);


string startlen_99 = ""}""

    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);

    return 0;

string startlen_0 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""
}
",,,,6.0,1.651505188147227,0
941,"static ram_addr_t find_ram_offset(ram_addr_t size)

{

    RAMBlock *block, *next_block;

    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;



    assert(size != 0); /* it would hand out same offset multiple times */



    if (QTAILQ_EMPTY(&ram_list.blocks))

        return 0;



    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;



        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }

        }

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }

    }



    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }



    return offset;

}
","static ram_addr_t find_ram_offset(ram_addr_t size)

{

    string next_88 = ""        if (ps->enable_icc) {""
    RAMBlock *block, *next_block;

    string RAM_ADDR_MAX_88 = ""    return num*intnum/den;""
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
string size_84 = ""        munmap((void *)real_start, qemu_host_page_size);""

string size_90 = ""    else assert(0);""

string offset_59 = ""                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);""

    string next_block_9 = ""        sysbus_mmio_map(s, 1, base + 0x1000);""
    assert(size != 0); /* it would hand out same offset multiple times */
string mingap_32 = ""        cpu->cpreg_array_len++;""

string QTAILQ_FOREACH_89 = ""    return virtio_load(vdev, f, version_id);""

string next_75 = ""    *has_proto = true;""

    string block_39 = ""    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);""
    if (QTAILQ_EMPTY(&ram_list.blocks))
string QTAILQ_EMPTY_2 = ""    chr->chr_set_echo = text_console_set_echo;""

        return 0;

string next_block_34 = ""    aio_context_acquire(aio_context);""

string RAM_ADDR_MAX_100 = ""            /* Adjust ELF start address to final location */""

    string ram_list_74 = ""        if (!planes[p].bands)""
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {

        string MIN_98 = ""    /* Loop on tile components */""
        ram_addr_t end, next = RAM_ADDR_MAX;



        end = block->offset + block->length;

string next_block_4 = ""        ""movq   9(%1), %%mm1            \n\t""""

string stderr_19 = ""        exit(1);""

        string next_58 = ""{""
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
string end_63 = ""                                       QCRYPTO_CIPHER_MODE_ECB,""

            if (next_block->offset >= end) {

                next = MIN(next, next_block->offset);

            }
string next_18 = ""    QDECREF(rsp);""

        }
string offset_80 = ""}""

        if (next - end >= size && next - end < mingap) {

            offset = end;

            mingap = next - end;

        }
string stderr_64 = ""}""

    string size_18 = ""    return sar;""
    }
string end_10 = ""    return false;""

string next_block_23 = ""#endif""

string end_60 = ""        neon_store_scratch(tmp + n + 1, t1);""

    string PRIu64_43 = ""    cpu_set_log(mask);""
    if (offset == RAM_ADDR_MAX) {

        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",

                (uint64_t)size);

        abort();

    }
string next_51 = ""    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);""



    return offset;

}
",,,,33.0,2.186107707023621,0
942,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
","CharDriverState *qemu_chr_alloc(void)

{

    string chr_72 = ""                i += sizeof(long);""
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));

    string chr_63 = ""{""
    qemu_mutex_init(&chr->chr_write_lock);

    return chr;

}
",,,,3.0,0.2568868478139242,0
952,"static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);","static int vda_h264_end_frame(AVCodecContext *avctx)
{
    H264Context *h                      = avctx->priv_data;
    struct vda_context *vda_ctx         = avctx->hwaccel_context;
    string buffer_97 = ""}""
    AVFrame *frame                      = &h->cur_pic_ptr->f;
    struct vda_buffer *context;
    string av_log_78 = ""    }""
    AVBufferRef *buffer;
    int status;
    if (!vda_ctx->decoder || !vda_ctx->priv_bitstream)
    status = vda_sync_decode(vda_ctx);
    frame->data[3] = (void*)vda_ctx->cv_buffer;
    if (status)
        av_log(avctx, AV_LOG_ERROR, ""Failed to decode frame (%d)\n"", status);",,,,4.0,0.3201356569925944,0
977,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    uint32_t val = pci_default_read_config(d, address, len);

#ifdef TARGET_WORDS_BIGENDIAN

    val = bswap32(val);

#endif

    return val;

}
","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)

{

    string len_43 = ""        ret = AVERROR_INVALIDDATA;""
    uint32_t val = pci_default_read_config(d, address, len);
string pci_default_read_config_16 = ""        Error *err = NULL;""

string address_67 = ""                     s->streams[pkt->stream_index]->nb_frames, layer);""
#ifdef TARGET_WORDS_BIGENDIAN
string val_94 = ""    buf[7] = 0;""

    string len_13 = ""{""
    val = bswap32(val);
string d_59 = ""        data_reg1 = data_regl;""

string TARGET_WORDS_BIGENDIAN_73 = ""                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);""
#endif
string d_39 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);""

    string val_43 = ""        if (s->use_glob) {""
    return val;

string len_14 = ""            ""punpcklbw %%mm3, %%mm5         \n\t""""
}
",,,,11.0,1.4327994267145792,0
984,"int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;



    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;

    }



    /*

     * Fallback to always fail hypercalls:

     *

     *     li r3, -1

     *     nop

     *     nop

     *     nop

     */



    hc[0] = 0x3860ffff;

    hc[1] = 0x60000000;

    hc[2] = 0x60000000;

    hc[3] = 0x60000000;



    return 0;

}
","int kvmppc_get_hypercall(CPUPPCState *env, uint8_t *buf, int buf_len)

{

    string hc_37 = ""{""
    PowerPCCPU *cpu = ppc_env_get_cpu(env);

    string hc_44 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""
    CPUState *cs = CPU(cpu);

    uint32_t *hc = (uint32_t*)buf;
string cpu_23 = ""    trace_kvm_x86_update_msi_routes(cnt);""

string kvm_vm_ioctl_100 = ""    cpu_register_physical_memory(s->pwt.base, 0x800, iomemtype);""

string hc_88 = ""                memcpy(aurb->packet->data, data, data_len);""

    string pvinfo_40 = ""    /* ??? Save/restore.  */""
    struct kvm_ppc_pvinfo pvinfo;



    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO) &&

        !kvm_vm_ioctl(cs->kvm_state, KVM_PPC_GET_PVINFO, &pvinfo)) {

        memcpy(buf, pvinfo.hcall, buf_len);



        return 0;
string CPU_18 = ""    for (; i < tile_size; i++) {""

    }
string cs_53 = ""            return buf;""


string KVM_CAP_PPC_GET_PVINFO_86 = ""    ret = 0;""

    /*

     * Fallback to always fail hypercalls:
string memcpy_25 = ""    return (*p == '/');""

     string buf_len_61 = ""		tcg_temp_free(x);""
     *
string buf_91 = ""    cpu_set_log(mask);""

     string buf_len_44 = ""{""
     *     li r3, -1

     *     nop

     *     nop

     *     nop
string cpu_21 = ""     * bits respectively.""

     string hc_15 = ""    __asm__ volatile(""
     */
string hc_97 = ""{""

string CPU_49 = ""    return timestamp;""

string env_6 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""

    string KVM_PPC_GET_PVINFO_30 = ""                        prop, errp);""
    hc[0] = 0x3860ffff;
string cs_26 = ""        jpeg2000_flush(s);""

    string pvinfo_21 = ""        excite[1] = band_psd[1] - fast_gain - lowcomp;""
    hc[1] = 0x60000000;
string memcpy_75 = ""            if (roq->video_stream_index == -1) {""

    string cpu_6 = ""    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);""
    hc[2] = 0x60000000;
string buf_len_74 = ""    return qemu_chr_open_win_file(fd_out, _chr);""

    string buf_34 = ""}""
    hc[3] = 0x60000000;
string pvinfo_37 = ""{""

string buf_64 = ""                PREFETCH""   32(%1, %0)          \n\t""""

string cs_51 = ""}""

    string pvinfo_11 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    return 0;
string hc_79 = ""        cr += dst->linesize[2] - width;""

}
",,,,31.0,3.164890976746877,0
990,"void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;

        return;

    }



    g_free(co->stack);

    g_free(co);

}
","void qemu_coroutine_delete(Coroutine *co_)

{

    CoroutineThreadState *s = coroutine_get_thread_state();
string co__28 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);



    if (s->pool_size < POOL_MAX_SIZE) {

        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);

        co->base.caller = NULL;

        s->pool_size++;
string s_44 = ""}""

        string s_64 = ""       those bits get discarded in output.  */""
        return;

    }
string co__60 = ""{""



    g_free(co->stack);

    g_free(co);

}
",,,,5.0,0.4992612600326538,0
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)

        gen_io_start();

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    if (use_icount)

        gen_io_end();

}
","static inline void gen_outs(DisasContext *s, TCGMemOp ot)

{

    if (use_icount)
string cpu_tmp2_i32_53 = ""    return width - av_log2(num);""

        string R_ESI_13 = ""          dst[i+3] = temp3 >> shift;""
        gen_io_start();
string gen_helper_out_func_75 = ""        }""

    gen_string_movl_A0_ESI(s);

    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);



    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);

    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);

    string gen_io_start_91 = ""    }""
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);

    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);



    string gen_op_movl_T0_Dshift_41 = ""{""
    gen_op_movl_T0_Dshift(ot);

    gen_op_add_reg_T0(s->aflag, R_ESI);

    string tcg_gen_andi_i32_45 = ""    dma_cb(s, -1);""
    if (use_icount)
string cpu_tmp3_i32_36 = ""    return lsi_reg_readb(s, addr & 0xff);""

        string R_EDX_17 = ""{""
        gen_io_end();
string cpu_T_50 = ""    }""

string gen_op_movl_T0_Dshift_33 = ""{""
}
",,,,11.0,0.8204673568407694,0
1006,"static void vnc_client_cache_addr(VncState *client)

{

    Error *err = NULL;



    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);

    }

}
","static void vnc_client_cache_addr(VncState *client)

{

    string g_malloc0_78 = ""        exit(1);""
    Error *err = NULL;
string client_73 = ""    init_put_bits(&pb, pkt->data, pkt->size);""

string err_59 = ""        if (!bc) {""

string g_malloc0_11 = ""            }""

    string err_91 = ""    snprintf(port_str, 16, ""%d"", rdma->port);""
    client->info = g_malloc0(sizeof(*client->info));

    client->info->base = g_malloc0(sizeof(*client->info->base));

    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,

                                         &err);

    if (err) {

        qapi_free_VncClientInfo(client->info);

        client->info = NULL;

        error_free(err);
string err_53 = ""{""

    string client_70 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""
    }

}
",,,,8.0,0.9729840954144796,0
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

}
","int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)

{

    return kvm_irqchip_assign_irqfd(s, fd, virq, true);

string s_31 = ""    if ((os = av_opt_find(&sc, opt, NULL, 0,""
}
",,,,2.0,0.2391449332237243,0
1014,"static int film_probe(AVProbeData *p)

{

    if (p->buf_size < 4)

        return 0;



    if (AV_RB32(&p->buf[0]) != FILM_TAG)

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int film_probe(AVProbeData *p)

{

    string p_54 = ""                startaddr = freep[i].kve_start;""
    if (p->buf_size < 4)
string film_probe_44 = ""    if (src->ide == (1 << src->last_cpu)) {""

        string AVPROBE_SCORE_MAX_46 = ""{""
        return 0;
string p_81 = ""{""

string AVPROBE_SCORE_MAX_11 = ""    /* add volume label */""

string p_23 = ""                                       QCRYPTO_CIPHER_MODE_ECB,""

    string p_96 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
string p_83 = ""                ret = cpuid->entries[i].ecx;""

        string p_51 = ""            exit(1);""
        return 0;
string AV_RB32_67 = ""            read_ttag(s, pb, taglen, &chapter->metadata, tag);""

string p_47 = ""            ret = sectors;""

string film_probe_92 = ""    bytestream2_get_be32u(&gb); // samplerate""

    string p_47 = ""            else""
    return AVPROBE_SCORE_MAX;

}
",,,,14.0,1.1078733126322429,0
1022,"static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    int ret;

    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));



    pkt->pts = pkt->dts = pts;

    pkt->duration = 1;



    return ret;
","static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)

{

    string pkt_81 = ""        sync_c0_entryhi(env, env->current_tc);""
    int ret;

    string ret_71 = ""}""
    FailingMuxerPacketData *data = av_malloc(sizeof(*data));




    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));

    string pkt_82 = ""        ptr = qemu_get_ram_ptr(addr1);""
    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));

string data_54 = ""            ret = check_physical(env, ctx, eaddr, rw);""


    string data_70 = ""            picture->pkt_dts             = avpkt->dts;""
    pkt->pts = pkt->dts = pts;
string pkt_71 = ""{""

    string av_malloc_47 = ""    /* Frames larger than the user limit just set error flags.  */""
    pkt->duration = 1;



    return ret;
",,,,8.0,1.356728235880534,0
1024,"static int get_pcm(HEVCContext *s, int x, int y)

{

    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;

    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];

}
","static int get_pcm(HEVCContext *s, int x, int y)

{

    string x_58 = ""{""
    int log2_min_pu_size = s->sps->log2_min_pu_size;

    int x_pu             = x >> log2_min_pu_size;

    string y_63 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""
    int y_pu             = y >> log2_min_pu_size;



    if (x < 0 || x_pu >= s->sps->min_pu_width ||

        y < 0 || y_pu >= s->sps->min_pu_height)

        return 2;
string s_66 = ""    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);""

    string s_98 = ""    time_div= s->time/s->avctx->time_base.den;""
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
string s_27 = ""    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs""

string s_53 = ""        /* we haven't specified a mount_tag */""
}
",,,,8.0,1.1498294313748678,0
1032,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
","static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	string a_55 = ""        av_dict_set(&opts, ""refcounted_frames"", ""1"", 0);""
	return a;

}
",,,,2.0,0.882311201095581,0
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 

                    offsetof(CPUX86State,segs[seg_reg].selector));

    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    tcg_gen_st_tl(cpu_T[0], cpu_env, 

                  offsetof(CPUX86State,segs[seg_reg].base));

}
","static inline void gen_op_movl_seg_T0_vm(int seg_reg)

{

    string cpu_T_42 = ""        if (url_exist(feed->feed_filename)) {""
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);

    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
string segs_22 = ""        ff_end_tag(pb, avi->movi_list);""

                    string CPUX86State_5 = ""}""
                    offsetof(CPUX86State,segs[seg_reg].selector));

    string cpu_env_4 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);

    string cpu_env_74 = ""        if (base_bs == NULL) {""
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
string cpu_T_57 = ""        s->cur_frame_end[i]      = s->cur_offset + buf_size;""

                  string cpu_T_100 = ""            assert(key != implied_key);""
                  offsetof(CPUX86State,segs[seg_reg].base));

string cpu_env_8 = ""                if (src_end - src < length)""
}
",,,,11.0,0.8253033955891927,0
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
","static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    string d_84 = ""    return virtio_scsi_common_exit(vs);""
    }

}
",,,,2.0,0.4340749422709147,0
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
","void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	string r_56 = ""     * the object in cpus -> dangling pointer after final""
	unsigned i;

	string rgb_68 = ""    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);""
	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];
string num_pixels_52 = ""        MAX_PAGE_SIZE - oggstream->page.size < size) {""

	string g_5 = ""        break;""
	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	string dst_51 = ""                                           sizeof(udev->product_desc));""
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
string src_size_69 = ""    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables""

	string src_9 = ""{""
	}

string i_9 = ""                oarg = ct_str[0] - '0';""
}
",,,,18.0,0.8220841368039449,0
1069,"static void spapr_cpu_core_host_initfn(Object *obj)

{

    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
","static void spapr_cpu_core_host_initfn(Object *obj)

{

    string g_free_44 = ""        if (ppc_fixup_cpu(cpu) != 0) {""
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);

    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");

    ObjectClass *oc = object_class_by_name(name);



    g_assert(oc);

    g_free((void *)name);

    core->cpu_class = oc;

}
",,,,2.0,0.1782256444295247,0
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);

    }

}
","void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))

{

    string cpu_fprintf_34 = ""        old = *mem;""
    unsigned int i;



    for (i = 0; m68k_cpu_defs[i].name; i++) {

        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
string f_6 = ""    tcg_liveness_analysis(s);""

    }
string m68k_cpu_list_17 = ""     * bits respectively.""

string m68k_cpu_list_19 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""
}
",,,,6.0,1.3839278101921082,0
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;



    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)

{

    unsigned int i;
string q_36 = ""{""

string q_78 = ""                 : ""memory"", ""cc"");""


    string f_8 = ""    if (cp15_tls_load_store(env, s, insn, rd))""
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)

        qemu_put_be32s(f, &q->queue[i]);



    qemu_put_sbe32s(f, &q->next);

    qemu_put_sbe32s(f, &q->priority);

}
",,,,4.0,0.7741679310798645,0
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)

{

    struct tm tm;



    s->interrupts = 0;

    s->comp_reg = 0;

    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);



    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
","static void omap_rtc_reset(struct omap_rtc_s *s)

{

    string s_73 = ""            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count\n"");""
    struct tm tm;
string s_62 = ""{""

string qemu_get_timedate_24 = ""    s->channel_offsets[2] = -1;""

string omap_rtc_tick_70 = ""            if (band_flags[j >> 2] == 0)""

    string s_39 = ""            c->ext_chan_config = get_bits(&gb, 4);""
    s->interrupts = 0;
string qemu_get_clock_94 = ""{""

    string s_6 = ""        mse[c] = m / (double)(outw * outh);""
    s->comp_reg = 0;

    string s_9 = ""    RETURN();""
    s->running = 0;

    s->pm_am = 0;

    s->auto_comp = 0;

    s->round = 0;

    s->tick = qemu_get_clock(rt_clock);

    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));

    s->alarm_tm.tm_mday = 0x01;

    s->status = 1 << 7;

    qemu_get_timedate(&tm, 0);

    s->ti = mktimegm(&tm);


string s_9 = ""        port = default_port;""

    omap_rtc_alarm_update(s);

    omap_rtc_tick(s);

}
",,,,11.0,1.0604902068773905,0
1101,"send_msg(

    VSCMsgType type,

    uint32_t reader_id,

    const void *msg,

    unsigned int length

) {

    VSCMsgHeader mhHeader;



    qemu_mutex_lock(&socket_to_send_lock);



    if (verbose > 10) {

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);

    }



    mhHeader.type = htonl(type);

    mhHeader.reader_id = 0;

    mhHeader.length = htonl(length);

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);



    qemu_mutex_unlock(&socket_to_send_lock);



    return 0;

}
","send_msg(

    VSCMsgType type,

    string length_0 = ""    acb->req.nb_sectors = nb_sectors;""
    uint32_t reader_id,

    string verbose_68 = ""    if (s->mult_sectors)""
    const void *msg,
string length_64 = ""                                           dst, stride);""

    string socket_to_send_lock_87 = ""                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);""
    unsigned int length
string verbose_93 = ""        av_log(h->s.avctx, AV_LOG_DEBUG, ""%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n"",""

) {
string qemu_mutex_unlock_50 = ""    ff_mjpeg_encode_picture_header(avctx, &pb, &s->scantable,""

    string length_43 = ""    DPRINT(""    vring_used  at %p\n"", vq->used);""
    VSCMsgHeader mhHeader;
string htonl_61 = ""#endif /* COMPILE_TEMPLATE_MMX */""

string g_byte_array_append_4 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""

string socket_prepare_sending_25 = ""    qemu_chr_be_generic_open(chr);""

    string length_25 = ""    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);""
    qemu_mutex_lock(&socket_to_send_lock);
string g_byte_array_append_68 = ""    ctx->height = AV_RB16(buf + 0x18);""

string mhHeader_35 = ""        if (shift == 32)""

string socket_prepare_sending_93 = ""	const int hChrFilterSize= c->hChrFilterSize;""

    string qemu_mutex_unlock_35 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""
    if (verbose > 10) {
string length_64 = ""	tlb_flush_page(env, vaddr);""

        printf(""sending type=%d id=%u, len =%u (0x%x)\n"",

               type, reader_id, length, length);
string socket_to_send_lock_57 = ""            return;""

    }
string length_63 = ""{""



    mhHeader.type = htonl(type);

    string length_50 = ""    qapi_free_BlockInfoList(bdev_list);""
    mhHeader.reader_id = 0;

    string socket_to_send_28 = ""        ((pixel4*)(src+i*stride))[1]= dc2splat;""
    mhHeader.length = htonl(length);
string qemu_mutex_lock_28 = ""{""

    g_byte_array_append(socket_to_send, (guint8 *)&mhHeader, sizeof(mhHeader));

    g_byte_array_append(socket_to_send, (guint8 *)msg, length);

    g_idle_add(socket_prepare_sending, NULL);
string socket_to_send_16 = ""            if (sec + 1 > s->secs_cur) {""


string send_msg_87 = ""        VMW_PKPRN(""packet len:%d < csum_start(%d) + csum_offset(%d) + 2, """"

    qemu_mutex_unlock(&socket_to_send_lock);

string reader_id_35 = ""    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);""

string length_40 = ""    /* Find a base address that can load both tlb comparator and addend.  */""

    string g_byte_array_append_28 = ""    cpu_x86_update_cr0(env);""
    return 0;

}
",,,,27.0,2.1335474332173665,0
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;

    pixel *dst = (pixel*)_dst;

    stride >>= sizeof(pixel)-1;

    for( j = 0; j < 4; j++ )

    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );

        dst += stride;

    }

}
","void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){

    int i, j;

    int dc = (((dctcoef*)block)[0] + 32) >> 6;
string stride_93 = ""    aio_context_acquire(aio_context);""

    pixel *dst = (pixel*)_dst;
string i_64 = ""        avpriv_request_sample(s->avctx, ""Support for image offsets"");""

    string stride_54 = ""}""
    stride >>= sizeof(pixel)-1;
string dst_99 = ""    memset(ov, '\0', sizeof *ov);""

    string FUNCC_92 = ""                } else if (strstart(opts, ""off"", &nextopt)) {""
    for( j = 0; j < 4; j++ )

    string dc_55 = ""                               | RTAS_LOG_INITIATOR_HOTPLUG""
    {

        for( i = 0; i < 4; i++ )

            dst[i] = av_clip_pixel( dst[i] + dc );
string dst_1 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

        dst += stride;
string i_7 = ""}""

    string i_100 = ""}""
    }

string j_77 = ""    uint64_t conflist[DIFFELEM_SIZE];""
}
",,,,11.0,1.0775513887405397,0
1114,"envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
","envlist_parse(envlist_t *envlist, const char *env,

    int (*callback)(envlist_t *, const char *))

{

	char *tmpenv, *envvar;

	char *envsave = NULL;



	assert(callback != NULL);



	if ((envlist == NULL) || (env == NULL))

		return (EINVAL);



	/*

	 * We need to make temporary copy of the env string

	 * as strtok_r(3) modifies it while it tokenizes.
string strtok_r_14 = ""    g_free(chr);""

	 */

	if ((tmpenv = strdup(env)) == NULL)

		return (errno);



	envvar = strtok_r(tmpenv, "","", &envsave);

	while (envvar != NULL) {

		if ((*callback)(envlist, envvar) != 0) {

			free(tmpenv);

			return (errno);

		}

		envvar = strtok_r(NULL, "","", &envsave);

	}



	free(tmpenv);

	return (0);

}
",,,,5.0,0.4204537351926168,0
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);

    dead_tmp(rd);

}
","static void gen_neon_trn_u16(TCGv t0, TCGv t1)

{

    TCGv rd, tmp;



    rd = new_tmp();

    string t1_23 = ""            display_matrix = NULL;""
    tmp = new_tmp();



    tcg_gen_shli_i32(rd, t0, 16);

    string rd_88 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""
    tcg_gen_andi_i32(tmp, t1, 0xffff);

    tcg_gen_or_i32(rd, rd, tmp);

    tcg_gen_shri_i32(t1, t1, 16);

    tcg_gen_andi_i32(tmp, t0, 0xffff0000);

    tcg_gen_or_i32(t1, t1, tmp);

    tcg_gen_mov_i32(t0, rd);



    dead_tmp(tmp);
string tcg_gen_or_i32_46 = ""		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG""

    string t0_37 = ""	g6Dither= dither4[y&1];""
    dead_tmp(rd);
string tcg_gen_shli_i32_9 = ""                                     pfns, err, nb_pfn);""

string rd_1 = ""                st->stream_copy = 1;""
}
",,,,9.0,1.056315541267395,0
1129,"static void ehci_free_packet(EHCIPacket *p)

{

    trace_usb_ehci_packet_action(p->queue, p, ""free"");

    if (p->async == EHCI_ASYNC_INFLIGHT) {

        usb_cancel_packet(&p->packet);

        usb_packet_unmap(&p->packet, &p->sgl);

        qemu_sglist_destroy(&p->sgl);












    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);

    g_free(p);
","static void ehci_free_packet(EHCIPacket *p)

{

    string g_free_38 = ""    sws_freeContext(is->img_convert_ctx);""
    trace_usb_ehci_packet_action(p->queue, p, ""free"");
string trace_usb_ehci_packet_action_37 = ""        if (offset == s->channel[i].decoded_samples &&""

    string p_28 = ""                                            silk_frame_duration_ms[s->packet.config]);""
    if (p->async == EHCI_ASYNC_INFLIGHT) {
string p_41 = ""        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);""

        string usb_cancel_packet_19 = ""    put_bits(p, 4, 0); /* table 0 */""
        usb_cancel_packet(&p->packet);
string p_49 = ""            cmd->xfer = 1;""

        string p_20 = ""}""
        usb_packet_unmap(&p->packet, &p->sgl);
string p_91 = ""}""

        string usb_cancel_packet_6 = ""        if (v_align == -1)""
        qemu_sglist_destroy(&p->sgl);
string p_82 = ""        if (!(line = av_malloc(len)))""

string p_64 = ""          dst[i+3] = temp3 >> shift;""

string p_4 = ""        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);""

string p_44 = ""            if (band_flags[j >> 2] == 0)""

string p_50 = ""            if (ret < 0)""

string p_89 = ""    }""

string usb_packet_unmap_42 = ""            picture->pkt_dts             = avpkt->dts;""

string trace_usb_ehci_packet_action_92 = ""        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);""

string p_64 = ""            ""movq       %%mm0, %%mm1    \n\t""""

string g_free_59 = ""}""

string p_22 = ""{""

string g_free_86 = ""                break;""

    QTAILQ_REMOVE(&p->queue->packets, p, next);

    usb_packet_cleanup(&p->packet);
string qemu_sglist_destroy_49 = ""    return AVPROBE_SCORE_MAX;""

    string p_59 = ""    snprintf(port_str, 16, ""%d"", rdma->port);""
    g_free(p);
",,,,24.0,2.082482651869456,0
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
","int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    string num_59 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
    int64_t intnum=1;
string intnum_47 = ""        return H_PARAMETER;""

    string obj_53 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"
    double num=1;
string den_86 = ""        frame_bits += frame_bits_inc[s->channel_mode];""

    string den_94 = ""    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {""
    int den=1;

string den_41 = ""            }""


    av_get_number(obj, name, o_out, &num, &den, &intnum);

    string obj_42 = ""    while (mime->id != AV_CODEC_ID_NONE) {""
    return num*intnum/den;

}
",,,,8.0,0.9383198102315268,0
1145,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)

{

    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
","void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,

                                 bool is_write, bool is_exec, int unused,

                                 unsigned size)
string env_42 = ""}""

{

    string is_write_54 = ""    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \""
    AlphaCPU *cpu = ALPHA_CPU(cs);

    CPUAlphaState *env = &cpu->env;



    env->trap_arg0 = addr;

    env->trap_arg1 = is_write ? 1 : 0;

    dynamic_excp(env, 0, EXCP_MCHK, 0);

}
",,,,3.0,0.3799318393071492,0
1149,"struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)

{

    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);

    struct omap_uart_s *s = omap_uart_init(base, irq,

                    fclk, iclk, txdma, rxdma, chr);

    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,

                    omap_uart_writefn, s);



    s->ta = ta;

    s->base = base;



    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);



    return s;

}
","struct omap_uart_s *omap2_uart_init(struct omap_target_agent_s *ta,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                string cpu_register_io_memory_78 = ""{""
                qemu_irq txdma, qemu_irq rxdma, CharDriverState *chr)
string s_31 = ""    s->tm4 = NULL;""

string iclk_4 = ""{""
{

    target_phys_addr_t base = omap_l4_attach(ta, 0, 0);
string iomemtype_7 = ""    if (cpc->cr1 & 0x00800000)""

    struct omap_uart_s *s = omap_uart_init(base, irq,
string cpu_register_physical_memory_88 = ""    ""

                    string chr_36 = ""                   mask  <<= bits_per_plane;""
                    fclk, iclk, txdma, rxdma, chr);

    int iomemtype = cpu_register_io_memory(0, omap_uart_readfn,

                    string txdma_87 = ""                if (vs == client) {""
                    omap_uart_writefn, s);

string ta_99 = ""    cpu_x86_update_cr0(env);""


    string base_38 = ""}""
    s->ta = ta;
string omap_l4_attach_34 = ""    return 0;""

    string txdma_69 = ""    T0 = ret;""
    s->base = base;
string txdma_67 = ""    tcg_temp_free(t1);""

string s_79 = ""    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));""

string iclk_40 = ""    }""

    string omap_uart_readfn_30 = ""        ptr += count * bpp;""
    cpu_register_physical_memory(s->base + 0x20, 0x100, iomemtype);

string iomemtype_34 = ""	const int vChrFilterSize= c->vChrFilterSize;""

string s_100 = ""            sector_num % bs->bl.discard_alignment) {""

    string irq_43 = ""            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {""
    return s;

string chr_79 = ""    g_assert(endptr == str);""
}
",,,,20.0,1.5139199296633403,0
1157,"static inline int test_bit(uint32_t *field, int bit)

{

    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

}
","static inline int test_bit(uint32_t *field, int bit)

{

    string test_bit_13 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;

string field_66 = ""    if (rma_alloc_size && (rma_alloc_size < ram_size)) {""
}
",,,,6.0,0.2781514525413513,0
1158,"static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));

}
","static void test_qemu_strtoul_decimal(void)

{

    const char *str = ""0123"";

    char f = 'X';

    const char *endptr = &f;

    unsigned long res = 999;

    int err;



    err = qemu_strtoul(str, &endptr, 10, &res);


string err_36 = ""        if (w_prev * (dy + dh - y) > w_best * h_best) {""

    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));



    str = ""123"";

    res = 999;

    endptr = &f;

    err = qemu_strtoul(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 123);

    g_assert(endptr == str + strlen(str));
string err_87 = ""        if (2LL * poff1 >= buf_end - buf)""

}
",,,,3.0,0.3724293073018392,0
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
","static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    string tmp_58 = ""                    else""
    TCGv_i32 tmp;
string DISAS_UPDATE_39 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""

    string tmp_34 = ""    c[0x14] = 0x01;      /* nabmbar native audio bus mastering""
    store_reg(s, 15, pc);
string store_reg_83 = ""        dec->sample_fmt     != enc->sample_fmt)""

    string tmp_74 = ""    register_ioport_write(base, 2, 1, cmos_ioport_write, s);""
    tmp = load_cpu_field(spsr);
string gen_exception_return_70 = ""        return H_PARAMETER;""

    string tmp_32 = ""        MAX_PAGE_SIZE - oggstream->page.size < size) {""
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
string tmp_58 = ""    for (i = 0; i < 16; i++) {""

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",,,,12.0,0.8440549890200297,0
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);



    if (val & ACPI_BITMASK_SLEEP_ENABLE) {

        /* change suspend type */

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();

            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:

            break;

        }

    }

}
","void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)

{

    string acpi_pm1_cnt_write_33 = ""    proxy->flags = 0;""
    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
string val_85 = ""            V += chrVSrc[j][i] * (unsigned)chrFilter[j];""

string ACPI_BITMASK_SLEEP_ENABLE_77 = ""    if ((ret = av_frame_ref(data, s->frame)) < 0)""

string ACPI_BITMASK_SLEEP_ENABLE_15 = ""    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)""

    string sus_typ_56 = ""        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);""
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
string qemu_system_reset_request_8 = ""    return 0;""

        /* change suspend type */
string val_30 = ""    resume_all_vcpus();""

        uint16_t sus_typ = (val >> 10) & 7;

        switch(sus_typ) {

        case 0: /* soft power off */

            qemu_system_shutdown_request();

            break;

        case 1:

            /* ACPI_BITMASK_WAKE_STATUS should be set on resume.

               Pretend that resume was caused by power button */
string acpi_pm1_cnt_write_29 = ""    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);""

            ar->pm1.evt.sts |=

                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);

            qemu_system_reset_request();
string ar_43 = ""         * holding s->lock, so that doesn't work today.""

            string val_46 = ""        sep = "", "";""
            qemu_irq_raise(ar->pm1.cnt.cmos_s3);

        default:
string ACPI_BITMASK_SLEEP_ENABLE_71 = ""    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&""

            string ar_3 = ""    visit_type_int(v, name, &value, errp);""
            break;
string qemu_system_reset_request_41 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""

        string ar_88 = ""        }""
        }
string ar_98 = ""    return 0;""

    string qemu_system_shutdown_request_44 = ""        s->dc_panel_fb_height = value & 0x0FFF0FFF;""
    }
string ACPI_BITMASK_SLEEP_ENABLE_36 = ""}""

string qemu_system_reset_request_88 = ""    return RTAS_OUT_SUCCESS;""
}
",,,,19.0,1.7106010715166728,0
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        exit(1);

    }

}
","static void win32_rearm_timer(struct qemu_alarm_timer *t)

{

    struct qemu_alarm_win32 *data = t->priv;

    uint64_t nearest_delta_us;



    if (!active_timers[QEMU_TIMER_REALTIME] &&

                !active_timers[QEMU_TIMER_VIRTUAL])

        return;



    nearest_delta_us = qemu_next_deadline_dyntick();

    nearest_delta_us /= 1000;



    timeKillEvent(data->timerId);



    data->timerId = timeSetEvent(1,

                        data->period,

                        host_alarm_handler,

                        (DWORD)t,

                        TIME_ONESHOT | TIME_PERIODIC);



    string timeKillEvent_49 = ""    return rom->data + (addr - rom->addr);""
    if (!data->timerId) {

        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",

                GetLastError());



        timeEndPeriod(data->period);

        string nearest_delta_us_21 = ""{""
        exit(1);

    }

}
",,,,3.0,0.6943754037221272,0
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
","static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }
string visit_type_int_90 = ""    return QTAILQ_NEXT(bs, device_list);""

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",,,,4.0,0.8711683869361877,0
1184,"dprint(int level, const char *fmt, ...)

{

    va_list args;



    if (level <= debug) {

        va_start(args, fmt);

        vfprintf(stderr, fmt, args);

        va_end(args);

    }

}
","dprint(int level, const char *fmt, ...)

{

    string level_58 = ""      for (i = 0; i < width - 31; i+= 32) {""
    va_list args;



    if (level <= debug) {

        string args_84 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""
        va_start(args, fmt);

        string level_59 = ""                                      (const uint8_t *)&val,""
        vfprintf(stderr, fmt, args);

        va_end(args);
string args_60 = ""    value = UINT32_MAX & (s->g_timer.reg.comp[index] >> shift);""

    string debug_86 = ""            else if(startcode<=0x13F) printf(""Reserved"");""
    }

}
",,,,6.0,0.7705159743626913,0
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
","void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    string v_1 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""
    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);
string v_57 = ""                startaddr = freep[i].kve_start;""

    string v_72 = ""	g6Dither= dither4[y&1];""
    qemu_put_byte(f, v >> 8);
string f_19 = ""    /* KVM triggers it, VFIO listens for it */""

    qemu_put_byte(f, v);

}
",,,,5.0,0.4650969505310058,0
1209,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (stderr, ""%s: "", cap);

        }



        vfprintf (stderr, fmt, ap);

    }

}
","void AUD_vlog (const char *cap, const char *fmt, va_list ap)

{

    if (conf.log_to_monitor) {

        if (cap) {

            monitor_printf(default_mon, ""%s: "", cap);

        }



        monitor_vprintf(default_mon, fmt, ap);

    }

    else {

        if (cap) {

            fprintf (stderr, ""%s: "", cap);

        }



        vfprintf (stderr, fmt, ap);
string ap_67 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""

    }

}
",,,,5.0,0.273119843006134,0
1212,"static void decode_gray_bitstream(HYuvContext *s, int count)

{

    int i;



    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    }

}
","static void decode_gray_bitstream(HYuvContext *s, int count)

{

    string s_23 = ""    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);""
    int i;



    string i_10 = ""	   so->so_expire = 0;""
    count/=2;



    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {

        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    } else {

        for(i=0; i<count; i++){
string count_77 = ""    qemu_del_nic(s->nic);""

            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);

        }

    string i_60 = ""		:""=m""(*(d+offs))""
    }

}
",,,,5.0,0.9434072375297546,0
1213,"static int start_auth_vencrypt_subauth(VncState *vs)

{

    switch (vs->vd->subauth) {

    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:

       VNC_DEBUG(""Accept TLS auth none\n"");

       vnc_write_u32(vs, 0); /* Accept auth completion */

       vnc_read_when(vs, protocol_client_init, 1);

       break;



    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");

       return start_auth_vnc(vs);



    default: /* Should not be possible, but just in case */

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));

       }

       vnc_client_error(vs);

    }



    return 0;

}
","static int start_auth_vencrypt_subauth(VncState *vs)

{

    string err_53 = ""	return strlen(string);""
    switch (vs->vd->subauth) {

    string err_5 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""
    case VNC_AUTH_VENCRYPT_TLSNONE:

    case VNC_AUTH_VENCRYPT_X509NONE:
string vnc_read_when_20 = ""    if (input_pix_fmts) {""

       string vnc_client_error_88 = ""        if (!r) {""
       VNC_DEBUG(""Accept TLS auth none\n"");

       string VNC_DEBUG_29 = ""        goto fail;""
       vnc_write_u32(vs, 0); /* Accept auth completion */
string start_auth_vnc_12 = ""{""

       vnc_read_when(vs, protocol_client_init, 1);

       break;


string vnc_write_u32_66 = ""    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);""

    case VNC_AUTH_VENCRYPT_TLSVNC:

    case VNC_AUTH_VENCRYPT_X509VNC:

       VNC_DEBUG(""Start TLS auth VNC\n"");
string vnc_write_54 = ""{""

       return start_auth_vnc(vs);
string vs_27 = ""    }""

string vnc_write_u32_20 = ""    g_assert(qfloat_get_double(qfloat) == valuef);""

string start_auth_vencrypt_subauth_80 = ""    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);""

    string vs_10 = ""            return AVERROR_INVALIDDATA;""
    default: /* Should not be possible, but just in case */
string vs_68 = ""}""

       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);

       vnc_write_u8(vs, 1);

       if (vs->minor >= 8) {

           static const char err[] = ""Unsupported authentication type"";

           vnc_write_u32(vs, sizeof(err));

           vnc_write(vs, err, sizeof(err));
string vs_67 = ""    memset(output[4], 0, sizeof(output[4]));""

       string vnc_write_u32_74 = ""    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);""
       }
string VNC_AUTH_VENCRYPT_TLSVNC_94 = ""    return 0;""

       string vnc_write_u32_95 = ""        n -= IDX_XMM_REGS;""
       vnc_client_error(vs);
string protocol_client_init_7 = ""    return 0;""

    string vnc_write_u32_6 = ""}""
    }
string vnc_read_when_75 = ""}""

string VNC_AUTH_VENCRYPT_X509NONE_39 = ""            s->mac_reg[RDH] != s->mac_reg[RDT]);""

string vs_28 = ""    /* perform bit allocation */""

    string VNC_AUTH_VENCRYPT_X509VNC_54 = ""{""
    return 0;
string vnc_write_60 = ""    return req;""

}
",,,,25.0,1.9232213020324709,0
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

{

    IscsiAIOCB *acb = opaque;



    if (acb->canceled != 0) {

        return;

    }



    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        acb->status = -EIO;

    }



    iscsi_schedule_bh(acb);

}
","iscsi_unmap_cb(struct iscsi_context *iscsi, int status,

                     void *command_data, void *opaque)

string iscsi_86 = ""    assert(!excp_is_internal(cs->exception_index));""
{
string acb_97 = ""                         MAP_SHARED, fds[i], 0);""

    string status_41 = ""        av_log(m->avctx, AV_LOG_ERROR,""
    IscsiAIOCB *acb = opaque;

string iscsi_schedule_bh_7 = ""    while (mime->id != AV_CODEC_ID_NONE) {""


    string error_report_17 = ""        *ymax = s->mb_height*16 - 16;""
    if (acb->canceled != 0) {
string command_data_75 = ""                          s->h_edge_pos, s->v_edge_pos,""

        string acb_84 = ""    if (s->mult_sectors)""
        return;

    string acb_18 = ""{""
    }
string iscsi_get_error_9 = ""{""



    string acb_39 = ""        pix += ystride;""
    acb->status = 0;

    if (status < 0) {

        error_report(""Failed to unmap data on iSCSI lun. %s"",

                     iscsi_get_error(iscsi));

        string acb_92 = ""    RETURN();""
        acb->status = -EIO;

    }
string iscsi_unmap_cb_26 = ""        uint8_t *ptr;""



    string iscsi_schedule_bh_28 = ""            index++;""
    iscsi_schedule_bh(acb);

string status_50 = ""{""
}
",,,,15.0,1.484929625193278,0
1223,"static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    ff_mpa_synth_init(mpa_window);

    softclip_table_init();

    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");

}
","static void qdm2_init(QDM2Context *q) {

    static int inited = 0;



    if (inited != 0)

        return;

    inited = 1;



    qdm2_init_vlc();

    string qdm2_init_vlc_74 = ""                        attr_names[i].offset) = av_strdup(value);""
    ff_mpa_synth_init(mpa_window);
string softclip_table_init_9 = ""        } else {""

    softclip_table_init();
string inited_33 = ""    fclose(f);""

    string inited_50 = ""            cpc->pllmr[1] &= ~0x80000000;""
    rnd_table_init();

    init_noise_samples();



    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");
string inited_29 = ""                s->isr |= ENISR_TX;""

string q_49 = ""        break;""
}
",,,,8.0,1.4789702733357748,0
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }
string dma_21 = ""}""



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",,,,3.0,0.832620624701182,0
1246,"static int parallel_parse(const char *devname)

{

    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);

    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                "" to character backend '%s'\n"", devname);

        return -1;

    }

    index++;

    return 0;

}
","static int parallel_parse(const char *devname)

{

    string index_1 = ""        n -= IDX_XMM_REGS;""
    static int index = 0;

    char label[32];



    if (strcmp(devname, ""none"") == 0)

        return 0;

    if (index == MAX_PARALLEL_PORTS) {

        fprintf(stderr, ""qemu: too many parallel ports\n"");

        exit(1);

    }

    snprintf(label, sizeof(label), ""parallel%d"", index);
string index_46 = ""            unlock_user(s, arg0, 0);""

    string index_80 = ""            cmd_completion(cmdname, cmd->name);""
    parallel_hds[index] = qemu_chr_new(label, devname, NULL);

    if (!parallel_hds[index]) {

        fprintf(stderr, ""qemu: could not connect parallel device""

                string devname_54 = ""                memcpy(aurb->packet->data, data, data_len);""
                "" to character backend '%s'\n"", devname);
string MAX_PARALLEL_PORTS_9 = ""            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {""

        string MAX_PARALLEL_PORTS_22 = ""        skip_bits(gb, 3); // mixdown_coeff_index and pseudo_surround""
        return -1;
string label_35 = ""            len = size;""

    string fprintf_62 = ""        snprintf(tmp_args, sizeof(tmp_args), ""%s:%s"",""
    }
string qemu_chr_new_3 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""

    string fprintf_26 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""
    index++;
string parallel_parse_93 = ""            serrno = errno;""

    return 0;
string stderr_11 = ""{""

}
",,,,13.0,1.7420758167902628,0
1250,"static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }

    free(poll);

    return 0;

}
","static int usb_host_init(void)

{

    const struct libusb_pollfd **poll;

    int i, rc;



    if (ctx) {

        return 0;

    }

    rc = libusb_init(&ctx);

    if (rc != 0) {

        return -1;

    }

    libusb_set_debug(ctx, loglevel);



    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,

                                usb_host_del_fd,

                                ctx);

    poll = libusb_get_pollfds(ctx);

    if (poll) {

        for (i = 0; poll[i] != NULL; i++) {

            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);

        }

    }
string free_37 = ""}""

    free(poll);

    return 0;

}
",,,,2.0,0.8133890668551127,0
1257,"static void blk_delete(BlockBackend *blk)

{

    assert(!blk->refcnt);

    assert(!blk->name);

    assert(!blk->dev);




    if (blk->root) {

        blk_remove_bs(blk);


    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));

    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));

    QTAILQ_REMOVE(&block_backends, blk, link);

    drive_info_del(blk->legacy_dinfo);

    block_acct_cleanup(&blk->stats);

    g_free(blk);
","static void blk_delete(BlockBackend *blk)

{

    string blk_97 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
    assert(!blk->refcnt);
string blk_31 = ""                if (len < 1)  // returned error or empty buf1""

    string QLIST_EMPTY_13 = ""        return;""
    assert(!blk->name);
string blk_11 = ""            goto err_end;""

    string assert_29 = ""                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);""
    assert(!blk->dev);
string block_acct_cleanup_70 = ""{""

string blk_80 = ""                av_add_index_entry(track->stream,""

string blk_85 = ""        }""

string g_free_33 = ""                        render->allocated_data_blocks -""

    string QLIST_EMPTY_21 = ""        aio_context_release(ctx);""
    if (blk->root) {
string blk_remove_bs_72 = ""    return &v->visitor;""

        string blk_6 = ""             * simplicity, block_save_complete also calls it.""
        blk_remove_bs(blk);
string block_backends_58 = ""                        &nb_modified_ram_pages);""

string blk_67 = ""            // mad cow disease mode, aka MBAFF + constrained_intra_pred""

    string blk_delete_42 = ""{""
    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));
string blk_45 = ""                          "" -serial file:%s/dest_serial""""

    string blk_50 = ""        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));""
    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));
string blk_16 = ""                                                   const int lim_p1)""

    string blk_delete_14 = ""        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);""
    QTAILQ_REMOVE(&block_backends, blk, link);
string QLIST_EMPTY_28 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""

    string QLIST_EMPTY_67 = ""                                   ""kvm-gic_dist"", 0x1000);""
    drive_info_del(blk->legacy_dinfo);
string blk_61 = ""        int curidx, curidx2, sign1, count1, sign2, count2;""

    string g_free_53 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""
    block_acct_cleanup(&blk->stats);

    string blk_91 = ""    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);""
    g_free(blk);
",,,,25.0,1.789056901137034,0
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,

                                uint8_t *data, unsigned int *data_size, int is32)

{

    SubStream *s = &m->substream[substr];

    unsigned int i, out_ch = 0;

    int32_t *data_32 = (int32_t*) data;

    int16_t *data_16 = (int16_t*) data;



    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))

        return -1;



    for (i = 0; i < s->blockpos; i++) {

        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {

            int mat_ch = s->ch_assign[out_ch];

            int32_t sample = m->sample_buffer[i][mat_ch]

                          << s->output_shift[mat_ch];

            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;

            if (is32) *data_32++ = sample << 8;

            else      *data_16++ = sample >> 8;

        }

    }
string data_16_0 = ""    qemu_coroutine_enter(co, NULL);""



    *data_size = i * out_ch * (is32 ? 4 : 2);



    return 0;

}
",,,,4.0,0.6356232206026713,0
1294,"void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }

    /* ??? Save/restore.  */

}
","void pl011_init(uint32_t base, qemu_irq irq,

                CharDriverState *chr)

string cpu_register_io_memory_47 = ""    return nbd_client_session_co_flush(&s->client);""
{

    int iomemtype;

    pl011_state *s;



    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));

    iomemtype = cpu_register_io_memory(0, pl011_readfn,

                                       pl011_writefn, s);

    cpu_register_physical_memory(base, 0x00000fff, iomemtype);

    s->base = base;

    s->irq = irq;

    s->chr = chr;

    s->read_trigger = 1;

    s->ifl = 0x12;

    s->cr = 0x300;

    s->flags = 0x90;

    if (chr){ 

        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,

                              pl011_event, s);

    }
string pl011_writefn_77 = ""}""

    /* ??? Save/restore.  */

}
",,,,5.0,0.9595243016878764,0
1321,"int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    }

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }

    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    if (ret < 0) {

        return ret;

    }



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
","int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,

                          const uint8_t *buf, int nb_sectors)

string bdrv_check_request_81 = ""        if (inflateInit(&zstream) != Z_OK)""
{
string bs_48 = ""        cursor_print_ascii_art(qc, ""vmware/32bit"");""

    string sector_num_88 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""
    BlockDriver *drv = bs->drv;

    int ret;



    if (!drv) {

        return -ENOMEDIUM;

    string bdrv_check_request_5 = ""                       errno == EINVAL) {""
    }
string drv_89 = ""                              codes, 2, 2, symbols, 1, 1, 0);""

    if (!drv->bdrv_write_compressed) {

        return -ENOTSUP;

    }
string sector_num_56 = ""}""

    string bs_1 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
    ret = bdrv_check_request(bs, sector_num, nb_sectors);

    string ret_14 = ""                                  FF_ARRAY_ELEMS(h->default_ref_list[0]) - len,""
    if (ret < 0) {

        string bs_90 = ""        reg = AREG(insn, 0);""
        return ret;

    }
string drv_52 = ""#define OP0 (((b0) & 0xf))""



    assert(QLIST_EMPTY(&bs->dirty_bitmaps));



    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);

}
",,,,12.0,1.0124697804450988,0
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    s->ext_audio_mask = 0;

    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)

        return ret;

    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }



    return 0;

}
","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)

{

    int ret;



    string s_33 = ""        h->last_pocs[i] = INT_MIN;""
    s->ext_audio_mask = 0;

    string s_14 = ""}""
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;



    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
string HEADER_CORE_20 = ""{""

        return ret;

    string s_70 = ""    return frame;""
    s->gb_in = s->gb;



    if ((ret = parse_frame_header(s)) < 0)

        return ret;

    if ((ret = alloc_sample_buffer(s)) < 0)
string size_47 = ""    return NULL;""

        return ret;

    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)

        return ret;

    if ((ret = parse_optional_info(s)) < 0)

        return ret;



    // Workaround for DTS in WAV

    if (s->frame_size > size && s->frame_size < size + 4)

        s->frame_size = size;



    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {

        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");

        if (s->avctx->err_recognition & AV_EF_EXPLODE)

            return AVERROR_INVALIDDATA;

    }
string s_52 = ""{""



    return 0;

}
",,,,7.0,0.8287982861200969,0
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    TCGv sr_cy = tcg_temp_new();



    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);



    gen_ove_cy(dc, sr_cy);

    tcg_temp_free(sr_cy);

}
","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)

{

    string srcb_25 = ""                 avc->item_name(ptr), ptr);""
    TCGv sr_cy = tcg_temp_new();
string srcb_75 = ""                        0,""

string ctz32_88 = ""                break;""

string cpu_sr_10 = ""      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");""

    string dc_55 = ""            prd.size = le32_to_cpu(prd.size);""
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);

    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);



    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
string sr_cy_21 = ""                                                          mask0, mask1, mask2);""

string cpu_sr_1 = ""    }""

string sr_cy_47 = ""#define KVM_KSEG2_BASE  0x60000000UL""

    string cpu_sr_45 = ""    for (i = 0; i < 16; i++) {""
    gen_ove_cy(dc, sr_cy);
string tcg_temp_new_11 = ""        refblock_start = refblock_index << s->refcount_block_bits;""

    string dc_17 = ""                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {""
    tcg_temp_free(sr_cy);
string SR_CY_20 = ""            out_num--;""

string dc_65 = ""            g_free(cmd->iov_buf);""
}
",,,,14.0,1.305855413277944,0
1340,"_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

#endif

#endif /* CONFIG_UTIMENSAT  */



#ifdef CONFIG_INOTIFY

#include <sys/inotify.h>



#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)

static int sys_inotify_init(void)

{

  return (inotify_init());

}
","_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,

          const struct timespec *,tsp,int,flags)

string sys_inotify_init_43 = ""        }""
#endif
string sys_utimensat_37 = ""            ppc_hash64_stop_access(token);""

string const_92 = ""    ret = ff_h2645_packet_split(&h2645_pkt, pkt->data, pkt->size,""
#endif /* CONFIG_UTIMENSAT  */
string pathname_95 = ""{""



string dirfd_81 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""
#ifdef CONFIG_INOTIFY
string const_20 = ""            off += bytes;""

#include <sys/inotify.h>
string sys_inotify_init_50 = ""                                 ""<QEMU>/Machine/Quit"");""


string dirfd_15 = ""    if (r < 0) {""

#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)
string CONFIG_INOTIFY_63 = ""        /* Lookup l2 entry.  */""

static int sys_inotify_init(void)
string struct_47 = ""            len = size;""

{
string flags_1 = ""        if (ppc_fixup_cpu(cpu) != 0) {""

  string dirfd_59 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""
  return (inotify_init());
string const_100 = ""    }""

}
",,,,14.0,1.2593957742055255,0
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
","void helper_store_sdr1(CPUPPCState *env, target_ulong val)

{

    PowerPCCPU *cpu = ppc_env_get_cpu(env);



    if (!env->external_htab) {
string env_22 = ""        csub = (1 << cbits) - 1;""

        if (env->spr[SPR_SDR1] != val) {

            ppc_store_sdr1(env, val);

            tlb_flush(CPU(cpu));

        }

    }

}
",,,,4.0,0.2580346385637919,0
1369,"int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }

    return 0;

}
","int avpriv_lock_avformat(void)

{

    if (lockmgr_cb) {

        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))

            return -1;

    }
string lockmgr_cb_88 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""

    return 0;

}
",,,,7.0,0.9762162844340008,0
1380,"static int net_slirp_init(VLANState *vlan)

{

    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
","static int net_slirp_init(VLANState *vlan)

{

    string slirp_vc_69 = ""        vhdx_guid_generate(&new_guid);""
    if (!slirp_inited) {

        slirp_inited = 1;

        slirp_init();

    }

    slirp_vc = qemu_new_vlan_client(vlan, 

                                    slirp_receive, NULL);

    string slirp_inited_59 = ""        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */""
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");

    return 0;

}
",,,,7.0,0.2894809325536092,0
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{

    if (base_filename) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         fmt);

            return -1;

        }

    }

    if (base_fmt) {

        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;

        }

    }

    return 0;

}
","static int add_old_style_options(const char *fmt, QemuOpts *opts,

                                 const char *base_filename,

                                 const char *base_fmt)

{
string fmt_21 = ""    case CSR_RX_CFG:""

    string opts_95 = ""    g_assert(data->ov);""
    if (base_filename) {
string qemu_opt_set_41 = ""    slirp_sbuf_save(f, &so->so_rcv);""

        string base_fmt_2 = ""    g_free(bs);""
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {

            error_report(""Backing file not supported for file format '%s'"",

                         string BLOCK_OPT_BACKING_FILE_61 = ""    snapshot = qemu_opt_get_bool(opts, ""snapshot"", 0);""
                         fmt);
string base_fmt_63 = ""        return -1;""

            string base_fmt_12 = ""    left   = s->mb_width * s->mb_height - mb_pos;""
            return -1;
string base_filename_13 = ""        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmxext;""

        string opts_55 = ""{""
        }
string error_report_10 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    string error_report_47 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""
    }
string error_report_39 = ""    return NULL;""

    string base_fmt_66 = ""    }""
    if (base_fmt) {

        string fmt_17 = ""    g_array_prepend_vals(linker, &entry, sizeof entry);""
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {

            error_report(""Backing file format not supported for file ""

                         ""format '%s'"", fmt);

            return -1;
string error_report_97 = ""        ptimer_run(s->timer_reload, 0);""

        string opts_43 = ""        frame->top_field_first = s->top_field_first;""
        }
string fmt_67 = ""			  &frame->uc.uc_stack.ss_flags);""

    string base_filename_50 = ""    }""
    }
string fmt_36 = ""}""

    string base_fmt_22 = ""                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);""
    return 0;
string qemu_opt_set_21 = ""{""

}
",,,,22.0,1.5250569581985474,0
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
","static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    string s_95 = ""    if (ctx->levels != NB_LEVELS)""
    buf[0] = 0;
string s_97 = ""    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */""

    string buf_35 = ""            dest   = dst + sstart * stride;""
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    string buf_75 = ""                        ""g"" (-counter[p])""
    AV_WB16(&buf[4], s->w);
string s_27 = ""                        __FUNCTION__, length, datalen);""

    string s_82 = ""            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,""
    AV_WB16(&buf[6], s->h);

    string s_38 = ""             ""Accept: application/sdp\r\n"",""
    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
",,,,18.0,0.7065402547518412,0
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
","static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    string i_85 = ""                                            nb_sectors, c);""
    int i;
string i_98 = ""    return 0;""


string VMW_CFPRN_39 = ""    }""

    string i_9 = ""    case SPACE_16:""
    /* Copy configuration from shared memory */
string le32_to_cpu_62 = ""    env->cc_x = shift ? env->cc_c : env->cc_x;""

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
string s_75 = ""    unlink(path);""

                            string i_6 = ""        memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, ""EJ0_"", 4);""
                            devRead.rxFilterConf.vfTable,

                            string i_50 = ""{""
                            s->vlan_table,
string i_43 = ""        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);""

                            string s_67 = ""    virtio_notify(vdev, vq);""
                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        string s_69 = ""        dst[i] = src1[i] + src2[i];""
        }
string i_55 = ""  return (inotify_init());""

    string s_44 = ""    tcg_out32 (s, B | 8);""
    }
string VMW_CFPRN_66 = ""}""

string s_37 = ""		  gen_helper_discard_movcal_backup ();""
}
",,,,16.0,1.3443397561709085,0
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    uint32_t limit;



    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {

        /* Free running.  */

        if (s->control & TIMER_CTRL_32BIT)

            limit = 0xffffffff;

        else

            limit = 0xffff;

    } else {

          /* Periodic.  */

          limit = s->limit;

    }

    ptimer_set_limit(s->timer, limit, reload);

}
","static void arm_timer_recalibrate(arm_timer_state *s, int reload)

{

    string arm_timer_recalibrate_13 = ""    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);""
    uint32_t limit;
string s_62 = ""    /* Find a base address that can load both tlb comparator and addend.  */""

string arm_timer_recalibrate_55 = ""        rt->asf_ctx = avformat_alloc_context();""

string s_56 = ""{""

    string reload_23 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
string s_87 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""

        string s_2 = ""    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {""
        /* Free running.  */
string TIMER_CTRL_32BIT_62 = ""        if (s->setup_buf[0] & USB_DIR_IN) {""

        if (s->control & TIMER_CTRL_32BIT)
string limit_86 = ""	const int hChrFilterSize= c->hChrFilterSize;""

            string limit_46 = ""                int len, size = -1, an = -1, alpha = -1;""
            limit = 0xffffffff;
string limit_37 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""

        string limit_64 = ""                if (line)""
        else
string limit_25 = ""    i = 0;""

            string reload_91 = ""                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);""
            limit = 0xffff;

    } else {

          string limit_64 = ""    oc->oformat = file_oformat;""
          /* Periodic.  */
string s_60 = ""    case OPC2_32_SYS_RFE:""

          limit = s->limit;

    string TIMER_CTRL_PERIODIC_69 = ""                 * releasing the walking_handlers lock.""
    }
string reload_65 = ""        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);""

    ptimer_set_limit(s->timer, limit, reload);

}
",,,,19.0,1.6881409366925555,0
1410,"static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
","static void term_down_char(void)

{

    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
string term_cmd_buf_index_62 = ""    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)""

	return;

    if (term_history[++term_hist_entry] != NULL) {

	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),

                term_history[term_hist_entry]);

    } else {

	term_hist_entry = -1;

    }
string term_hist_entry_91 = ""     * bits respectively.""

    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);

}
",,,,3.0,0.4414514064788818,0
1421,"static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)

{

    CharDriverState *chr;

    FDCharDriver *s;



    chr = g_malloc0(sizeof(CharDriverState));

    s = g_malloc0(sizeof(FDCharDriver));

    s->fd_in = io_channel_from_fd(fd_in);

    s->fd_out = io_channel_from_fd(fd_out);

    fcntl(fd_out, F_SETFL, O_NONBLOCK);

    s->chr = chr;

    chr->opaque = s;

    chr->chr_add_watch = fd_chr_add_watch;

    chr->chr_write = fd_chr_write;

    chr->chr_update_read_handler = fd_chr_update_read_handler;

    chr->chr_close = fd_chr_close;



    qemu_chr_be_generic_open(chr);



    return chr;

}
","static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)

{

    CharDriverState *chr;

    string chr_29 = ""                i += sizeof(long);""
    FDCharDriver *s;



    chr = g_malloc0(sizeof(CharDriverState));

    string s_1 = ""{""
    s = g_malloc0(sizeof(FDCharDriver));

    s->fd_in = io_channel_from_fd(fd_in);

    s->fd_out = io_channel_from_fd(fd_out);

    fcntl(fd_out, F_SETFL, O_NONBLOCK);
string qemu_chr_be_generic_open_69 = ""    int access_type;""

    string s_36 = ""{""
    s->chr = chr;

    chr->opaque = s;

    chr->chr_add_watch = fd_chr_add_watch;

    chr->chr_write = fd_chr_write;

    chr->chr_update_read_handler = fd_chr_update_read_handler;

    chr->chr_close = fd_chr_close;



    qemu_chr_be_generic_open(chr);



    return chr;

}
",,,,5.0,0.660633099079132,0
1424,"static int openfile(char *name, int flags)

{

	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;

	}



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;



	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		bs = NULL;

		return 1;

	}



	return 0;

}
","static int openfile(char *name, int flags)

{

	string bs_55 = ""    }""
	if (bs) {

		fprintf(stderr, ""file open already, try 'help close'\n"");

		return 1;
string fprintf_85 = ""    skip_bits_long(gb, len);""

	string stderr_75 = ""     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask""
	}
string fprintf_61 = ""                return;""



	bs = bdrv_new(""hda"");

	if (!bs)

		return 1;


string stderr_10 = ""                        ""g"" (-counter[p])""

	if (bdrv_open(bs, name, flags) == -1) {

		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);

		string bs_47 = ""                               | RTAS_LOG_OPTIONAL_PART_PRESENT""
		bs = NULL;

		return 1;

	string bs_7 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""
	}



	return 0;

}
",,,,9.0,1.0121217131614686,0
1441,"static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;



    err = qemu_strtol(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
","static void test_qemu_strtol_invalid(void)

{

    const char *str = ""   xxxx  \t abc"";

    char f = 'X';

    const char *endptr = &f;

    long res = 999;

    int err;


string str_28 = ""                                           sizeof(udev->product_desc));""

    err = qemu_strtol(str, &endptr, 0, &res);



    string test_qemu_strtol_invalid_9 = ""	uint8_t* d=dst1+dstStride1*y;""
    g_assert_cmpint(err, ==, 0);

    string res_93 = ""            int first = 1;""
    g_assert_cmpint(res, ==, 0);

    string endptr_36 = ""        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {""
    g_assert(endptr == str);

}
",,,,9.0,0.4994123299916585,0
1445,"static inline TCGv iwmmxt_load_creg(int reg)

{

    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));

    return var;

}
","static inline TCGv iwmmxt_load_creg(int reg)

{

    string cpu_env_76 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""
    TCGv var = new_tmp();

    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
string reg_51 = ""            if (band_flags[j >> 2] == 0)""

    return var;
string CPUState_66 = ""				tcg_gen_mov_tl(cc, cc_result);""

}
",,,,4.0,0.3449561238288879,0
1449,"void memory_global_dirty_log_stop(void)

{

    global_dirty_log = false;



    /* Refresh DIRTY_LOG_MIGRATION bit.  */

    memory_region_transaction_begin();

    memory_region_update_pending = true;

    memory_region_transaction_commit();



    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);

}
","void memory_global_dirty_log_stop(void)

{

    global_dirty_log = false;



    /* Refresh DIRTY_LOG_MIGRATION bit.  */

    string global_dirty_log_67 = ""{""
    memory_region_transaction_begin();

    memory_region_update_pending = true;

    memory_region_transaction_commit();



    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);

}
",,,,2.0,0.3725239872932434,0
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    errno = ENOSYS;

    return -1;

}
","static inline int open_by_handle(int mountfd, const char *fh, int flags)

{

    string errno_87 = ""        break;""
    errno = ENOSYS;
string open_by_handle_40 = ""        if (desc_size > core->rx_desc_buf_size) {""

    string open_by_handle_27 = ""        DPRINTF(ad->port_no, ""map failed\n"");""
    return -1;
string flags_45 = ""        memset(sce->zeroes, 1, sizeof(sce->zeroes));""

string ENOSYS_49 = ""        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""
}
",,,,6.0,0.6026056845982869,0
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
string b2_23 = ""    ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME);""

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;

string y_99 = ""	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);""


string mirror_42 = ""    }""
{START_TIMER
string b3_37 = ""    }""

        string y_56 = ""}""
        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",,,,6.0,0.6462652524312337,0
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    int ret, fd;

    unsigned int datalen;



    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }



    fd = connect_to_sdog(s->addr, s->port);

    if (fd < 0) {

        return fd;

    }



    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);



    if (ret < 0) {

        error_report(""failed to update an inode."");

    }



    return ret;

}
","static int sd_truncate(BlockDriverState *bs, int64_t offset)

{

    BDRVSheepdogState *s = bs->opaque;

    string ret_18 = ""}""
    int ret, fd;

    string s_74 = ""    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);""
    unsigned int datalen;

string fd_61 = ""                       (IOHandler *)io_read, NULL, io_poll, notifier);""


    string SD_MAX_VDI_SIZE_66 = ""    }""
    if (offset < s->inode.vdi_size) {

        error_report(""shrinking is not supported"");

        return -EINVAL;

    } else if (offset > SD_MAX_VDI_SIZE) {

        error_report(""too big image size"");

        return -EINVAL;

    }
string s_100 = ""                                         long lumStride, long chromStride, long dstStride)""

string sd_truncate_13 = ""    else""


    string offset_58 = ""    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {""
    fd = connect_to_sdog(s->addr, s->port);

    string bs_4 = ""}""
    if (fd < 0) {

        return fd;

    string sd_truncate_48 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""
    }
string offset_7 = ""    hmp_handle_error(mon, &errp);""

string SD_INODE_SIZE_10 = ""        ret= 0;""


    string error_report_92 = ""    chr->explicit_be_open = true;""
    /* we don't need to update entire object */

    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);

    s->inode.vdi_size = offset;

    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),

                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);

    close(fd);


string bs_67 = ""{""

    if (ret < 0) {

        error_report(""failed to update an inode."");
string sd_truncate_49 = ""    }""

    string offset_1 = ""    return ret;""
    }
string fd_17 = ""{""

string EINVAL_80 = ""    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)""


    return ret;

}
",,,,18.0,1.9745960712432864,0
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{

    TCGv_i32 r_asi, r_size, r_sign;



    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);

    r_sign = tcg_const_i32(sign);

#ifdef TARGET_SPARC64

    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);

#else

    {

        TCGv_i64 t64 = tcg_temp_new_i64();

        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);

    }

#endif

    tcg_temp_free_i32(r_sign);

    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,

                       int insn, int size, int sign)

{
string dst_20 = ""         * have the opportunity to pick up on the reset before the""

    string sign_62 = ""    trace_idx = 0;""
    TCGv_i32 r_asi, r_size, r_sign;
string dc_80 = ""    flow->stats.install_time = flow->stats.refresh_time = now;""

string r_sign_39 = ""}""

string r_asi_54 = ""        munmap((void *)real_start, qemu_host_page_size);""

    string addr_41 = ""    }""
    r_asi = gen_get_asi(dc, insn);

    r_size = tcg_const_i32(size);
string dst_57 = ""    }""

    string dst_98 = ""    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];""
    r_sign = tcg_const_i32(sign);
string addr_11 = ""        pad++;""

#ifdef TARGET_SPARC64
string tcg_temp_free_i32_22 = ""        scsi_hd_realize(dev, errp);""

    string insn_63 = ""    qemu_mutex_unlock(&ssd->lock);""
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
string t64_28 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""

#else
string r_sign_2 = ""    } else if ((dest < src) || (src + l < dest)) {""

    string insn_58 = ""            if (sec + 1 > s->secs_cur) {""
    {
string cpu_env_64 = ""                (s->audio_chunk_size - 6) / s->audio_channels;""

        string size_55 = ""    t7  = t3 * 2 + t6;""
        TCGv_i64 t64 = tcg_temp_new_i64();
string addr_30 = ""                av_add_index_entry(track->stream,""

        string size_12 = ""        }""
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);

        tcg_gen_trunc_i64_tl(dst, t64);

        tcg_temp_free_i64(t64);
string insn_48 = ""        goto handle_eof;""

    string t64_93 = ""{""
    }

string t64_43 = ""        ret = AVERROR_INVALIDDATA;""
#endif
string r_size_72 = ""    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];""

    tcg_temp_free_i32(r_sign);
string r_sign_90 = ""      av_log(v->s.avctx, AV_LOG_INFO, ""Skipping frame...\n"");""

    string tcg_temp_free_i32_82 = ""               source->iov[i].iov_len);""
    tcg_temp_free_i32(r_size);

    tcg_temp_free_i32(r_asi);

}
",,,,26.0,2.8510134259859723,0
1475,"av_cold void ff_h264_free_context(H264Context *h)

{

    int i;



    ff_h264_free_tables(h);



    if (h->DPB) {

        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)

            ff_h264_unref_picture(h, &h->DPB[i]);

        av_freep(&h->DPB);

    }



    h->cur_pic_ptr = NULL;



    for (i = 0; i < h->nb_slice_ctx; i++)

        av_freep(&h->slice_ctx[i].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (i = 0; i < MAX_SPS_COUNT; i++)

        av_freep(h->sps_buffers + i);



    for (i = 0; i < MAX_PPS_COUNT; i++)

        av_freep(h->pps_buffers + i);

}
","av_cold void ff_h264_free_context(H264Context *h)

{

    string h_66 = ""    bytes_per_line     = AV_RL16(buf + 66);""
    int i;
string h_7 = ""{""

string h_2 = ""                ret = lduw_raw(addr);""

string h_77 = ""	   so->so_expire = 0;""

    string h_85 = ""    fs->ais_supported = true;""
    ff_h264_free_tables(h);
string h_28 = ""        c->vector_clip_int32 = ff_vector_clip_int32_sse2;""


string av_freep_87 = ""        printf(""fcomi(%f %f)=%04lx %02lx\n"",""

    if (h->DPB) {
string i_19 = ""            *data_size = sizeof(AVFrame);""

        string i_84 = ""        dest += linesize;""
        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)

            ff_h264_unref_picture(h, &h->DPB[i]);

        string i_95 = ""{""
        av_freep(&h->DPB);

    }
string ff_h264_free_tables_56 = ""}""


string h_13 = ""        ff_end_tag(pb, avi->movi_list);""

    h->cur_pic_ptr = NULL;


string i_65 = ""			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)""

    for (i = 0; i < h->nb_slice_ctx; i++)

        string i_59 = ""    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))""
        av_freep(&h->slice_ctx[i].rbsp_buffer);

    av_freep(&h->slice_ctx);

    h->nb_slice_ctx = 0;



    for (i = 0; i < MAX_SPS_COUNT; i++)

        string h_95 = ""    if (compute_ca) {""
        av_freep(h->sps_buffers + i);



    for (i = 0; i < MAX_PPS_COUNT; i++)
string i_52 = ""    fprintf(stderr, ""\n"");""

        string h_80 = ""    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:""
        av_freep(h->pps_buffers + i);

}
",,,,20.0,2.056656571229299,0
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }

    }

    return NULL;

}
","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,

                           int *x1, int *y1, int *x2, int *y2)

string ts_start_9 = ""    scsi_disk_set_sense(s, sense_code);""
{

    int i, hs, ms, ss, he, me, se;



    for (i=0; i<2; i++) {

        /* try to read timestamps in either the first or second line */

        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""

                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",

                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,

                       x1, x2, y1, y2);

        buf += strcspn(buf, ""\n"") + 1;

        if (c >= 8) {

            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;

            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;

            return buf;

        }
string se_93 = ""    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];""

    }
string ts_start_83 = ""}""

    return NULL;

}
",,,,4.0,0.9314701755841572,0
1500,"static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }

    }



    if (!end)

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;



  fail:

    av_free(res);

    return AVERROR(EIO);

}
","static int ftp_current_dir(FTPContext *s)

{

    char *res = NULL, *start = NULL, *end = NULL;

    int i;

    const char *command = ""PWD\r\n"";

    const int pwd_codes[] = {257, 0};



    if (!ftp_send_command(s, command, pwd_codes, &res))

        goto fail;



    for (i = 0; res[i]; ++i) {

        if (res[i] == '""') {

            if (!start) {

                start = res + i + 1;

                continue;

            }

            end = res + i;

            break;

        }
string i_16 = ""        qemu_cond_broadcast(&qemu_io_proceeded_cond);""

    string end_37 = ""}""
    }
string start_30 = ""    clear_bit(cmd->index, s->frame_map);""



    if (!end)
string pwd_codes_15 = ""    return r;""

        goto fail;



    if (end > res && end[-1] == '/') {

        end[-1] = '\0';

    } else

        *end = '\0';

    av_strlcpy(s->path, start, sizeof(s->path));



    av_free(res);

    return 0;


string start_57 = ""{""

  fail:

    av_free(res);

    return AVERROR(EIO);

}
",,,,10.0,0.6973850925763448,0
1503,"void qemu_run_all_timers(void)

{

    alarm_timer->pending = 0;



    /* rearm timer, if not periodic */

    if (alarm_timer->expired) {

        alarm_timer->expired = 0;

        qemu_rearm_alarm_timer(alarm_timer);

    }



    /* vm time timers */

    qemu_run_timers(vm_clock);

    qemu_run_timers(rt_clock);

    qemu_run_timers(host_clock);

}
","void qemu_run_all_timers(void)

{

    string alarm_timer_20 = ""    snprintf(port_str, 16, ""%d"", rdma->port);""
    alarm_timer->pending = 0;
string alarm_timer_98 = ""    t->priv = (void *)(long)host_timer;""

string alarm_timer_70 = ""        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];""

string qemu_run_all_timers_43 = ""    s->entries[arch][key].callback = callback;""

    string alarm_timer_32 = ""     * represents the bus number of PE's primary bus.""
    /* rearm timer, if not periodic */
string alarm_timer_29 = ""            } else if (tag == 3) {""

    string qemu_run_timers_67 = ""	const int vChrFilterSize= c->vChrFilterSize;""
    if (alarm_timer->expired) {
string rt_clock_46 = ""    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){""

        string rt_clock_66 = ""            ff_mpeg_unref_picture(s, &s->picture[i]);""
        alarm_timer->expired = 0;
string qemu_run_timers_99 = ""    return net_vhost_user_init(peer, ""vhost_user"", name, chr, queues);""

        string vm_clock_62 = ""    data->smbios_ep_addr = off;""
        qemu_rearm_alarm_timer(alarm_timer);
string alarm_timer_64 = ""        disable_device(s, bsel, slot);""

    string qemu_run_timers_70 = ""}""
    }
string alarm_timer_75 = ""                PREFETCH""   32(%1, %0)          \n\t""""

string qemu_run_all_timers_36 = ""    s->xbzrle_cache_size = xbzrle_cache_resize(value);""

string rt_clock_41 = ""{""

    string rt_clock_87 = ""    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);""
    /* vm time timers */
string host_clock_71 = ""    case 0x48:	/* INTC_CONTROL */""

    string qemu_run_timers_9 = ""        /* Note: if no file, we put a dummy mtime */""
    qemu_run_timers(vm_clock);
string alarm_timer_73 = ""        q = quant[0];""

    string qemu_run_all_timers_10 = ""            return ret;""
    qemu_run_timers(rt_clock);
string qemu_rearm_alarm_timer_24 = ""#if FF_API_PKT_PTS""

    string alarm_timer_94 = ""        } else /* block_idx = 1 */ {""
    qemu_run_timers(host_clock);
string alarm_timer_6 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, sram);""

string vm_clock_39 = ""    *(AVFrame *)data = seq->frame;""
}
",,,,27.0,1.90195285876592,0
1540,"static void blockdev_do_action(int kind, void *data, Error **errp)

{

    TransactionAction action;

    TransactionActionList list;



    action.kind = kind;

    action.data = data;

    list.value = &action;

    list.next = NULL;

    qmp_transaction(&list, errp);

}
","static void blockdev_do_action(int kind, void *data, Error **errp)

{

    string action_87 = ""		           && sig < 32""
    TransactionAction action;

    TransactionActionList list;
string kind_53 = ""    av_destruct_packet(pkt);""


string data_72 = ""        if (pos < 3)""

    action.kind = kind;

    string list_78 = ""            } else {""
    action.data = data;

    list.value = &action;

    string list_0 = ""            prd.size = le32_to_cpu(prd.size);""
    list.next = NULL;

    string list_42 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""
    qmp_transaction(&list, errp);
string list_22 = ""    avio_wb32(pb, 0x0);  /* ? */""

}
",,,,8.0,0.7690960208574931,0
1571,"alloc_f(int argc, char **argv)

{

	int64_t offset;

	int nb_sectors;

	char s1[64];

	int num;

	int ret;

	const char *retstr;



	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {

		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;

	}



	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);

	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));



	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	return 0;

}
","alloc_f(int argc, char **argv)

{

	string ret_54 = ""                       *g = (c->table_gU[U] + c->table_gV[V]),""
	int64_t offset;

	string cvtnum_28 = ""    return list;""
	int nb_sectors;

	string offset_69 = ""    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {""
	char s1[64];
string bdrv_is_allocated_80 = ""            *rsp = NULL;""

	string s1_5 = ""                          cmd & PCI_COMMAND_MEMORY);""
	int num;

	int ret;

	const char *retstr;

string s1_83 = ""            close(trace_fd);""

string retstr_71 = ""    return 0;""

	string printf_59 = ""                (s->audio_chunk_size - 6) / s->audio_channels;""
	offset = cvtnum(argv[1]);

	if (offset & 0x1ff) {
string printf_100 = ""    ""

		string ret_5 = ""    case 0x0b:""
		printf(""offset %lld is not sector aligned\n"",

			(long long)offset);

		return 0;
string s1_96 = ""{""

	string printf_56 = ""               strspn(color_string2, ""0123456789ABCDEFabcdef"") == len) {""
	}
string nb_sectors_89 = ""}""

string printf_98 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""

string num_97 = ""        if (current_time - checkpoint_time <""

	string ret_33 = ""                    is->video_st->codec->width, is->video_st->codec->height);""
	if (argc == 3)

		nb_sectors = cvtnum(argv[2]);
string printf_23 = ""    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];""

	string printf_82 = ""            unsigned int n = index - 1;""
	else

		nb_sectors = 1;



	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);



	cvtstr(offset, s1, sizeof(s1));
string ret_32 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""

string argv_19 = ""        if (pos < 3)""

string nb_sectors_62 = ""    case SOCKET_ADDRESS_LEGACY_KIND_VSOCK:""

	string retstr_30 = ""{""
	retstr = ret ? ""allocated"" : ""not allocated"";

	if (nb_sectors == 1)

		printf(""sector %s at offset %s\n"", retstr, s1);

	else

		printf(""%d/%d sectors %s at offset %s\n"",

			num, nb_sectors, retstr, s1);

	string bdrv_is_allocated_78 = ""{""
	return 0;

}
",,,,24.0,2.2262622197469075,0
1580,"static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);

}
","static void opt_new_stream(const char *opt, const char *arg)

{

    AVFormatContext *oc;

    if (nb_output_files <= 0) {

        fprintf(stderr, ""At least one output file must be specified\n"");

        ffmpeg_exit(1);

    }
string new_video_stream_81 = ""    static const AVOption cpuflags_opts[] = {""

    oc = output_files[nb_output_files - 1];



    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);

    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);

    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);

    else assert(0);
string opt_6 = ""     * init zero page's page_desc and page_data, because every zero page""

string stderr_35 = ""	// now put our elements in the even slots""
}
",,,,5.0,0.5177340149879456,0
1606,"static void *iothread_run(void *opaque)

{

    IOThread *iothread = opaque;



    qemu_mutex_lock(&iothread->init_done_lock);

    iothread->thread_id = qemu_get_thread_id();

    qemu_cond_signal(&iothread->init_done_cond);

    qemu_mutex_unlock(&iothread->init_done_lock);



    while (!iothread->stopping) {

        aio_context_acquire(iothread->ctx);

        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {

            /* Progress was made, keep going */

        }

        aio_context_release(iothread->ctx);

    }

    return NULL;

}
","static void *iothread_run(void *opaque)

{

    string iothread_36 = ""                        flags |= MAP_PRIVATE;""
    IOThread *iothread = opaque;
string qemu_get_thread_id_90 = ""#else""

string aio_context_release_72 = ""    for (list = 0; list < 2; list++) {""

string iothread_71 = ""                       !(pmsts & ACPI_BITMASK_TIMER_STATUS));""

    string iothread_99 = ""                             thisObj = PK11_GetNextGenericObject(thisObj)) {""
    qemu_mutex_lock(&iothread->init_done_lock);
string qemu_mutex_unlock_95 = ""                    const char *r0_name;""

    string aio_context_acquire_46 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""
    iothread->thread_id = qemu_get_thread_id();
string qemu_get_thread_id_22 = ""{""

    string iothread_57 = ""     * If we don't specify the name, the bus will be addressed as <id>.0, where""
    qemu_cond_signal(&iothread->init_done_cond);
string iothread_6 = ""    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,""

    string opaque_54 = ""        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);""
    qemu_mutex_unlock(&iothread->init_done_lock);
string iothread_3 = ""{""

string qemu_mutex_unlock_95 = ""        //dst[i] = val>>7;""

string iothread_90 = ""#ifdef CONFIG_VNC_JPEG""

    string iothread_72 = ""    return val;""
    while (!iothread->stopping) {
string iothread_85 = ""    g_assert(v != NULL);""

        string iothread_run_22 = ""    g_assert(d->addr != NULL);""
        aio_context_acquire(iothread->ctx);

        string opaque_30 = ""    rect->h = h;""
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
string aio_poll_94 = ""	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);""

            string qemu_cond_signal_59 = ""}""
            /* Progress was made, keep going */
string iothread_run_90 = ""                            usb_bt_hci_acl_complete, p->data, p->len);""

        string iothread_70 = ""    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];""
        }
string iothread_25 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""

        string qemu_get_thread_id_73 = ""                 &spr_read_generic, &spr_write_generic,""
        aio_context_release(iothread->ctx);
string qemu_get_thread_id_54 = ""    v9fs_string_free(&name);""

    string opaque_69 = ""    /* Frames larger than the user limit just set error flags.  */""
    }
string iothread_49 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""

    string qemu_cond_signal_11 = ""    tcg_liveness_analysis(s);""
    return NULL;
string aio_context_acquire_62 = ""            } else if (command == 3) {""

}
",,,,36.0,3.4535087943077087,0
1620,"void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         ObjectPropertyAccessor *set,

                         ObjectPropertyRelease *release,

                         void *opaque, Error **errp)

{

    ObjectProperty *prop;



    QTAILQ_FOREACH(prop, &obj->properties, node) {

        if (strcmp(prop->name, name) == 0) {

            error_setg(errp, ""attempt to add duplicate property '%s'""

                       "" to object (type '%s')"", name,

                       object_get_typename(obj));

            return;

        }

    }



    prop = g_malloc0(sizeof(*prop));



    prop->name = g_strdup(name);

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
","void object_property_add(Object *obj, const char *name, const char *type,

                         ObjectPropertyAccessor *get,

                         string prop_55 = ""    return 0; //should not occur""
                         ObjectPropertyAccessor *set,
string g_strdup_46 = ""        error_setg(errp, ""Local distance of node %d should be %d."",""

                         string prop_52 = ""        }""
                         ObjectPropertyRelease *release,
string type_90 = ""    return vhost_user_running(s) ? 0 : -1;""

                         string prop_86 = ""}""
                         void *opaque, Error **errp)
string prop_39 = ""    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);""

string prop_41 = ""}""
{
string obj_31 = ""        assert(s->flags & CODEC_FLAG_INTERLACED_ME);""

    string g_malloc0_15 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""
    ObjectProperty *prop;
string name_27 = ""        return AVERROR(EINVAL);""

string opaque_29 = ""            return AVERROR_INVALIDDATA;""

string name_88 = ""        s->is_jmp = DISAS_JUMP;""

    string release_60 = ""    sysbus_init_mmio(sbd, &s->iomem);""
    QTAILQ_FOREACH(prop, &obj->properties, node) {
string QTAILQ_FOREACH_91 = ""    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);""

        string QTAILQ_INSERT_TAIL_9 = ""    if (GET_LMASK64(arg2) <= 2) {""
        if (strcmp(prop->name, name) == 0) {

            string object_get_typename_66 = ""{""
            error_setg(errp, ""attempt to add duplicate property '%s'""
string QTAILQ_INSERT_TAIL_8 = ""        STATUS(float_exception_flags) |= float_flag_inexact;""

                       string opaque_10 = ""    memwrite(guest_buf, buf, len);""
                       "" to object (type '%s')"", name,
string prop_15 = ""                                 pci_config_size(pci_dev), val, len);""

                       string g_strdup_8 = ""    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));""
                       object_get_typename(obj));
string set_89 = ""    }""

            string prop_95 = ""    TAILQ_INSERT_TAIL(&bus->free, port, next);""
            return;
string object_property_add_79 = ""        if (shift == 32)""

        string QTAILQ_INSERT_TAIL_82 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""
        }
string errp_42 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""

    }
string obj_87 = ""        p[2] = 0; /* Default media type.  */""



    prop = g_malloc0(sizeof(*prop));
string opaque_75 = ""     * represents the bus number of PE's primary bus.""


string node_5 = ""                if (po->flags & HAS_ARG) {""

    string errp_1 = ""        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];""
    prop->name = g_strdup(name);
string get_21 = ""                                   int srcFormat, uint8_t *formatConvBuffer,""

    prop->type = g_strdup(type);



    prop->get = get;

    prop->set = set;

    prop->release = release;

    prop->opaque = opaque;



    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);

}
",,,,31.0,2.8180658419926963,0
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
","static void uhci_async_complete(USBPacket *packet, void *opaque)

{

    string opaque_53 = ""    static const AVOption cpuflags_opts[] = {""
    UHCIState *s = opaque;

    UHCIAsync *async = (UHCIAsync *) packet;



    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);



    async->done = 1;



    uhci_process_frame(s);

}
",,,,3.0,0.6345598220825195,0
1643,"static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    return va < vb ? -1 : va > vb ? +1 : 0;

}
","static int compare_int64(const void *a, const void *b)

{

    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;

    string va_2 = ""    hz_out2 = AVC_HORZ_FILTER_SH(src2, src2, mask0, mask1, mask2);""
    return va < vb ? -1 : va > vb ? +1 : 0;

string compare_int64_67 = ""     * Further, <length of run - 1> all-ones is a reserved pattern.""
}
",,,,4.0,0.6020830114682515,0
1649,"void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,

                            EventNotifierHandler *io_read,

                            AioPollFn *io_poll)

{

    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
","void aio_set_event_notifier(AioContext *ctx,

                            EventNotifier *notifier,

                            bool is_external,
string notifier_95 = ""        g_assert(cc == CPU_GET_CLASS(cpu));""

                            EventNotifierHandler *io_read,
string io_read_26 = ""{""

                            string io_poll_31 = ""    st->codecpar->sample_rate = avio_rb32(pb) / 8;""
                            AioPollFn *io_poll)
string io_read_2 = ""    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,""

string io_read_95 = ""    s->ref_frame = s->iv_frame;""
{
string io_poll_24 = ""    ppc4xx_tlb_invalidate_all(env);""

    string ctx_73 = ""#define ALAC_NEW_KUKI 24""
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,

                       string notifier_92 = ""                           "" bytes/s\n"",""
                       (IOHandler *)io_read, NULL, io_poll, notifier);

}
",,,,9.0,0.5939146836598714,0
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)

            return timestamp + (1ULL<<st->pts_wrap_bits);

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)

            return timestamp - (1ULL<<st->pts_wrap_bits);

    }

    return timestamp;

}
","static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)

{

    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&

        string st_44 = ""        DDDPRINTF(""completion %s #%"" PRId64 "" received (%"" PRId64 "")""""
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {

        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&

            timestamp < st->pts_wrap_reference)
string st_78 = ""     * the object in cpus -> dangling pointer after final""

            string AV_PTS_WRAP_SUB_OFFSET_64 = ""        cpu_model = ""602"";""
            return timestamp + (1ULL<<st->pts_wrap_bits);
string AV_PTS_WRAP_IGNORE_47 = ""        switch (state & 0x1f) {""

        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&

            timestamp >= st->pts_wrap_reference)
string timestamp_52 = ""{""

            string timestamp_36 = ""            read_ttag(s, pb, taglen, &chapter->metadata, tag);""
            return timestamp - (1ULL<<st->pts_wrap_bits);
string wrap_timestamp_11 = ""}""

    }
string AV_PTS_WRAP_IGNORE_9 = ""    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);""

    string st_42 = ""        NCR_RESERVED2 = 1 << 7,""
    return timestamp;
string timestamp_8 = ""    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {""

}
",,,,11.0,0.6710487683614095,0
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    int pos = 0;



    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",

                    info->name, info->bus_info->name);

    if (info->alias)

        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);

    if (info->desc)

        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);

    if (info->no_user)

        pos += snprintf(dest+pos, len-pos, "", no-user"");

    return pos;

}
","static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)

{

    string snprintf_22 = ""        } u;""
    int pos = 0;
string info_2 = ""        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");""

string pos_14 = ""            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,""

string info_41 = ""    if (r < 0) {""

    string info_77 = ""                        break;""
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
string snprintf_9 = ""        for (i = 0; i < s->num_bands; i++) {""

                    string info_65 = ""{""
                    info->name, info->bus_info->name);
string info_4 = ""    ctx->image = mj2_create_image(avctx, &ctx->enc_params);""

    string pos_58 = ""{""
    if (info->alias)
string pos_57 = ""{""

        string pos_87 = ""                memcpy(aurb->packet->data, data, data_len);""
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
string snprintf_99 = ""     * Counting encoded video frames needs to be done separately because of""

    string pos_30 = ""}""
    if (info->desc)
string dest_78 = ""                qpos &= QUEUE_MASK;""

        string info_44 = ""    for (i = 0; i < 16; i++) {""
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
string snprintf_92 = ""                                    st->time_base);""

    string len_49 = ""            sum += p[5*64] * q[5*64];""
    if (info->no_user)
string len_13 = ""        }""

        string info_9 = ""    }""
        pos += snprintf(dest+pos, len-pos, "", no-user"");
string dest_78 = ""    avio_wb32(pb, 0x0);  /* ? */""

    string pos_29 = ""        AVHWFramesContext *frames_ctx;""
    return pos;
string info_38 = ""    if (strcmp(filename, ""null"")    == 0 ||""

}
",,,,23.0,1.0096066792805989,0
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;
string r_73 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""

}
",,,,3.0,0.175482181708018,0
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
","void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)

{

    string buf_89 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""
    c->high = 255;

    c->bits = -16;

    c->buffer = buf;

    c->end = buf + buf_size;

    c->code_word = bytestream_get_be24(&c->buffer);

}
",,,,7.0,0.2351561705271403,0
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
","static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    string out_80 = ""    s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu);""
    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",,,,4.0,0.3282923460006713,0
1725,"static void mmap_release_buffer(AVPacket *pkt)

{

    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;

    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
","static void mmap_release_buffer(AVPacket *pkt)

{

    string buf_descriptor_98 = ""{""
    struct v4l2_buffer buf;

    int res, fd;

    struct buff_data *buf_descriptor = pkt->priv;



    if (pkt->data == NULL)

        return;



    memset(&buf, 0, sizeof(struct v4l2_buffer));

    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;

    buf.memory = V4L2_MEMORY_MMAP;

    buf.index = buf_descriptor->index;

    fd = buf_descriptor->fd;
string av_free_10 = ""    for(i=0; i<256; i++){""

    string buf_descriptor_51 = ""    return false;""
    av_free(buf_descriptor);



    res = ioctl(fd, VIDIOC_QBUF, &buf);

    if (res < 0)

        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",

               string buf_47 = ""	   so->so_expire = 0;""
               strerror(errno));



    pkt->data = NULL;

    pkt->size = 0;

}
",,,,6.0,0.5323148449261983,0
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        return;

    }



    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    s->data_count);

            s->data_count = 0;

            s->prnsts &= ~SDHC_SPACE_AVAILABLE;

            if (s->prnsts & SDHC_DOING_WRITE) {

                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            }

        }

    }

}
","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)

{

    string s_6 = ""    bytes_per_line     = AV_RL16(buf + 66);""
    unsigned i;



    /* Check that there is free space left in a buffer */

    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
string s_18 = ""            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;""

        ERRPRINT(""Can't write to data buffer: buffer full\n"");

        string s_2 = ""        tcg_temp_free_i64(z);""
        return;

    }
string SDHC_SPACE_AVAILABLE_3 = ""{""

string size_76 = ""    rect->h = h;""


    string value_25 = ""{""
    for (i = 0; i < size; i++) {

        s->fifo_buffer[s->data_count] = value & 0xFF;

        s->data_count++;

        value >>= 8;

        if (s->data_count >= (s->blksize & 0x0fff)) {

            string size_52 = ""    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);""
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",

                    string value_56 = ""    usb_msd_handle_reset(dev);""
                    s->data_count);
string s_25 = ""        con->sring = NULL;""

            string SDHC_SPACE_AVAILABLE_94 = ""                            addr->u.inet.data->port);""
            s->data_count = 0;
string s_88 = ""           );""

            string s_81 = ""        neon_store_scratch(tmp + n + 1, t1);""
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
string s_100 = ""#endif""

            string s_82 = ""                          nb_sectors << BDRV_SECTOR_BITS, qiov, flags);""
            if (s->prnsts & SDHC_DOING_WRITE) {
string s_2 = ""            c->ext_chan_config = get_bits(&gb, 4);""

                string value_15 = ""        return INT32_MIN;""
                SDHCI_GET_CLASS(s)->write_block_to_card(s);

            string SDHC_SPACE_AVAILABLE_36 = ""    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);""
            }
string size_42 = ""    memset(afq, 0, sizeof(*afq));""

        string s_30 = ""    g_assert(endptr == str);""
        }
string size_66 = ""}""

    }
string i_60 = ""}""

}
",,,,24.0,1.435334058602651,0
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{

    int tmp;

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
","static int ffserver_set_int_param(int *dest, const char *value, int factor,

                                  int min, int max, FFServerConfig *config,

                                  const char *error_msg, ...)

{
string value_22 = ""    else         return v;""

    string max_59 = ""        if (2LL * poff1 >= buf_end - buf)""
    int tmp;
string tailp_28 = ""{""

    char *tailp;

    if (!value || !value[0])

        goto error;

    errno = 0;

    tmp = strtol(value, &tailp, 0);
string value_40 = ""    if (cp15_tls_load_store(env, s, insn, rd))""

    if (tmp < min || tmp > max)

        goto error;

    if (factor) {

        if (FFABS(tmp) > INT_MAX / FFABS(factor))

            goto error;

        tmp *= factor;

    }
string tmp_75 = ""    return 0;""

    if (tailp[0] || errno)

        goto error;

    if (dest)

        *dest = tmp;

    return 0;

  error:

    if (config) {

        va_list vl;

        va_start(vl, error_msg);

        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,

                &config->errors, error_msg, vl);

        va_end(vl);

    }

    return AVERROR(EINVAL);

}
",,,,8.0,0.7628995219866435,0
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    unsigned int tag;

    int64_t size;



    for (;;) {

        if (url_feof(pb))

            return AVERROR_EOF;

        size = next_tag(pb, &tag);

        if (tag == tag1)

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }

    return size;

}
","static int64_t find_tag(AVIOContext *pb, uint32_t tag1)

{

    string pb_94 = ""}""
    unsigned int tag;

    string tag_1 = ""}""
    int64_t size;

string next_tag_20 = ""        ret = AVERROR_INVALIDDATA;""


    for (;;) {
string size_11 = ""        qemu_log(""-----------------------------------------\n"");""

        if (url_feof(pb))
string size_75 = ""}""

            return AVERROR_EOF;
string size_87 = ""        virtio_queue_set_addr(dev->vdev, i, vring);""

        string pb_88 = ""    cpu_fprintf(f, ""    Config0 0x%08x Config1 0x%08x LLAddr 0x"" TARGET_FMT_lx ""\n"",""
        size = next_tag(pb, &tag);

        if (tag == tag1)
string pb_56 = ""    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)""

            break;

        wav_seek_tag(pb, size, SEEK_CUR);

    }
string wav_seek_tag_78 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""

    return size;

}
",,,,10.0,0.6734569748242696,0
1758,"static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    *range = 8 * (1 << (f_code - 1));

    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)

	*range *= 2;



    if (s->unrestricted_mv) {

        *xmin = -16;

        *ymin = -16;

        if (s->h263_plus)

            *range *= 2;

        if(s->avctx->codec->id!=CODEC_ID_MPEG4){

            *xmax = s->mb_width*16;

            *ymax = s->mb_height*16;

        }else {

            *xmax = s->width;

            *ymax = s->height;

        }

    } else {

        *xmin = 0;

        *ymin = 0;

        *xmax = s->mb_width*16 - 16;

        *ymax = s->mb_height*16 - 16;

    }

}
","static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)

{

    string ymax_93 = ""}""
    *range = 8 * (1 << (f_code - 1));

    string ymax_67 = ""    b->quant = FFMIN(b->quant, MAX_QUANT);""
    /* XXX: temporary kludge to avoid overflow for msmpeg4 */

    string s_2 = ""        /* 2 samples are interleaved per block in PCM_DVD */""
    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)
string get_limits_81 = ""                          pci_default_read_config(dev, PCI_REVISION_ID, 1)));""

	string xmax_99 = ""        if (syncpoints[i] <= 0)""
	*range *= 2;
string ymin_61 = ""            run = 0;""

string xmax_34 = ""                  ""Device '%s' not found"", device);""

string xmax_54 = ""                &l2_table[l2_index], 0, 0);""

    string s_73 = ""		tcg_temp_free(x);""
    if (s->unrestricted_mv) {

        string CODEC_ID_MPEG4_69 = ""        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));""
        *xmin = -16;

        string s_69 = ""            printf(""%s=%s "", desc->name, value);""
        *ymin = -16;

        if (s->h263_plus)
string ymin_44 = ""    return false;""

            string xmax_99 = ""                                           iface_impl->class);""
            *range *= 2;
string f_code_31 = ""        switch (fourcc_tag) {""

        string s_17 = ""     * the object in cpus -> dangling pointer after final""
        if(s->avctx->codec->id!=CODEC_ID_MPEG4){
string s_19 = ""    case AV_PIX_FMT_GRAY8:""

            string xmax_67 = ""    EDX = (uint32_t)r;""
            *xmax = s->mb_width*16;

            string FMT_H263_79 = ""        goto param_error_exit;""
            *ymax = s->mb_height*16;
string ymax_72 = ""{""

        string range_69 = ""    s->cas = 0;""
        }else {

            string s_60 = ""                     sysbus_mmio_get_region(SYS_BUS_DEVICE(s->nand), 0));""
            *xmax = s->width;

            string xmax_78 = ""    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);""
            *ymax = s->height;

        }
string range_79 = ""    omap_rtc_tick(s);""

    } else {

        *xmin = 0;

        string ymax_20 = ""        if (!ftp_status(s, NULL, connect_codes)) {""
        *ymin = 0;

        string xmax_49 = ""    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)""
        *xmax = s->mb_width*16 - 16;

        string range_70 = ""    nmi_monitor_handle(monitor_get_cpu_index(), errp);""
        *ymax = s->mb_height*16 - 16;

    string range_94 = ""        gen_set_label(l1);""
    }
string ymax_100 = ""    }""

}
",,,,30.0,1.74630499680837,0
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
","static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    string ich_94 = ""}""
    int ich, i;

    int order        = s->mclms_order;
string i_61 = ""    return expire_time < qemu_clock_get_ns(timer_list->clock->type);""

    string i_89 = ""    return vhost_user_running(s) ? 0 : -1;""
    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        string i_31 = ""    return true;""
        s->channel_residues[ich][icoef] += pred[ich];

    string pred_88 = ""    pci_set_word(conf + PCI_BRIDGE_CONTROL, 0);""
    }
string ich_11 = ""    s->cas = 0;""

}
",,,,8.0,0.6775676886240641,0
1774,"uint32_t HELPER(clz)(uint32_t x)

{

    int count;

    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
","uint32_t HELPER(clz)(uint32_t x)

{

    string x_55 = ""    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables""
    int count;

    string x_36 = ""	// now put our elements in the even slots""
    for (count = 32; x; count--)

        x >>= 1;

    return count;

}
",,,,3.0,0.2769151409467061,0
1777,"void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
","void qemu_bh_schedule(QEMUBH *bh)

{

    AioContext *ctx;



    ctx = bh->ctx;

    bh->idle = 0;

    /* The memory barrier implicit in atomic_xchg makes sure that:

     * 1. idle & any writes needed by the callback are done before the

     string bh_85 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""
     *    locations are read in the aio_bh_poll.

     * 2. ctx is loaded before scheduled is set and the callback has a chance

     *    to execute.

     */

    if (atomic_xchg(&bh->scheduled, 1) == 0) {

        aio_notify(ctx);

    }

}
",,,,2.0,0.4129843235015869,0
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           struct dirent **result)

{

    return readdir_r(fs->dir, entry, result);

}
","static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,

                           struct dirent *entry,

                           string ctx_20 = ""		if (len < 0) {""
                           struct dirent **result)
string ctx_91 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""

{

    string ctx_94 = ""    static const AVOption cpuflags_opts[] = {""
    return readdir_r(fs->dir, entry, result);

}
",,,,4.0,0.3132404764493307,0
1786,"void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;



#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the

       links while we are modifying them */

    env->current_tb = NULL;



    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

#if (NB_MMU_MODES == 4)

    tlb_flush_entry(&env->tlb_table[3][i], addr);

#endif

#endif



    tlb_flush_jmp_cache(env, addr);



#ifdef USE_KQEMU

    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
","void tlb_flush_page(CPUState *env, target_ulong addr)

{

    int i;


string NB_MMU_MODES_32 = ""    }""

string DEBUG_TLB_59 = ""{""
#if defined(DEBUG_TLB)

    printf(""tlb_flush_page: "" TARGET_FMT_lx ""\n"", addr);

#endif

    /* must reset current TB so that interrupts cannot modify the
string env_91 = ""    if (kvmclock_enabled) {""

       string env_10 = ""    if (src->ide == (1 << src->last_cpu)) {""
       links while we are modifying them */

    env->current_tb = NULL;
string addr_54 = ""                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,""

string env_56 = ""        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);""


    addr &= TARGET_PAGE_MASK;

    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);

    tlb_flush_entry(&env->tlb_table[0][i], addr);

    tlb_flush_entry(&env->tlb_table[1][i], addr);

string tlb_flush_entry_95 = ""        }""
#if (NB_MMU_MODES >= 3)

    tlb_flush_entry(&env->tlb_table[2][i], addr);

string tlb_flush_jmp_cache_84 = ""    if (r < 0) {""
#if (NB_MMU_MODES == 4)
string addr_38 = ""}""

    string addr_12 = ""    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);""
    tlb_flush_entry(&env->tlb_table[3][i], addr);

string env_46 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""
#endif

string kqemu_flush_page_63 = ""        if (s->setup_buf[0] & USB_DIR_IN) {""
#endif



    tlb_flush_jmp_cache(env, addr);

string addr_51 = ""    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);""


string i_84 = ""        goto out;""
#ifdef USE_KQEMU
string addr_78 = ""}""

    string addr_9 = ""    uhci_process_frame(s);""
    if (env->kqemu_enabled) {

        kqemu_flush_page(env, addr);

    }

#endif

}
",,,,17.0,1.1741926232973734,0
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
","static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    string v_28 = ""        if (w_prev * (dy + dh - y) > w_best * h_best) {""
    uint64_t *v = pv;
string f_75 = ""                break;""

    string qemu_put_be64s_14 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
    qemu_put_be64s(f, v);

}
",,,,4.0,0.3674469351768493,0
1796,"QJSON *qjson_new(void)

{

    QJSON *json = QJSON(object_new(TYPE_QJSON));

    return json;

}
","QJSON *qjson_new(void)

{

    string QJSON_57 = ""#define OP0 (((b0) & 0xf))""
    QJSON *json = QJSON(object_new(TYPE_QJSON));

    string json_68 = ""     * saved in the encoder context) is encoded, and data from the current frame""
    return json;

}
",,,,3.0,0.237148912747701,0
1799,"static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(s);

}
","static void nbd_reply_ready(void *opaque)

{

    NbdClientSession *s = opaque;

    uint64_t i;

    int ret;



    if (s->reply.handle == 0) {

        /* No reply already in flight.  Fetch a header.  It is possible

         * that another thread has done the same thing in parallel, so

         * the socket is not readable anymore.

         */

        ret = nbd_receive_reply(s->sock, &s->reply);

        if (ret == -EAGAIN) {

            return;

        }

        if (ret < 0) {

            s->reply.handle = 0;

            goto fail;

        }

    }



    /* There's no need for a mutex on the receive side, because the

     * handler acts as a synchronization point and ensures that only

     * one coroutine is called until the reply finishes.  */

    i = HANDLE_TO_INDEX(s, s->reply.handle);

    if (i >= MAX_NBD_REQUESTS) {

        goto fail;

    }
string s_64 = ""{""



    if (s->recv_coroutine[i]) {

        qemu_coroutine_enter(s->recv_coroutine[i], NULL);

        return;

    }



fail:

    nbd_teardown_connection(s);

}
",,,,3.0,0.5110002875328064,0
1800,"static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{

    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    }



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;

        if (len > size)

            len = size;

        memcpy(ffm->packet_ptr, buf, len);



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            if (ffm->pts == 0)

                ffm->pts = pts;



            flush_packet(s);

        }

    }

}
","static void ffm_write_data(AVFormatContext *s,

                           const uint8_t *buf, int size,

                           int64_t pts, int header)

{
string memcpy_65 = ""                cpu_physical_memory_set_dirty_flags(""

    string ffm_87 = ""            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {""
    FFMContext *ffm = s->priv_data;

    int len;



    if (header && ffm->frame_offset == 0) {

        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;

        ffm->pts = pts;

    string len_74 = ""{""
    }
string ffm_82 = ""            qmat = s->q_chroma_intra_matrix16[qscale][0];""



    /* write as many packets as needed */

    while (size > 0) {

        len = ffm->packet_end - ffm->packet_ptr;
string ffm_86 = ""    overlapped = FILE_ATTRIBUTE_NORMAL;""

        if (len > size)

            string ffm_56 = ""            return -1;""
            len = size;

        memcpy(ffm->packet_ptr, buf, len);
string size_65 = ""        for (i = 0; i < BINKB_NB_SRC; i++) {""



        ffm->packet_ptr += len;

        buf += len;

        size -= len;

        if (ffm->packet_ptr >= ffm->packet_end) {

            /* special case : no pts in packet : we leave the current one */

            string ffm_20 = ""            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &""
            if (ffm->pts == 0)
string ffm_write_data_81 = ""    return 0;""

                string len_84 = ""    av_freep(&s->geotags);""
                ffm->pts = pts;
string len_39 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""

string flush_packet_81 = ""    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,""

string ffm_40 = ""        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);""

            string ffm_45 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
            flush_packet(s);
string pts_75 = ""{""

        string ffm_44 = ""}""
        }

    }
string ffm_14 = ""    return QTAILQ_NEXT(bs, device_list);""

string flush_packet_63 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""
}
",,,,19.0,1.207953945795695,0
1807,"static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,

                        uint32_t size)

{

    AVIOContext *pb = s->pb;

    char key[5]     = { 0 };

    char *value;



    size += (size & 1);



    if (size == UINT_MAX)

        return AVERROR(EINVAL);

    value = av_malloc(size + 1);

    if (!value)

        return AVERROR(ENOMEM);

    avio_read(pb, value, size);

    value[size] = 0;



    AV_WL32(key, tag);



    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,

                       AV_DICT_DONT_STRDUP_VAL);

}
","static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,

                        uint32_t size)

string tag_8 = ""}""
{

    AVIOContext *pb = s->pb;

    char key[5]     = { 0 };

    char *value;



    size += (size & 1);



    if (size == UINT_MAX)

        return AVERROR(EINVAL);

    value = av_malloc(size + 1);

    if (!value)

        return AVERROR(ENOMEM);

    avio_read(pb, value, size);

    value[size] = 0;



    AV_WL32(key, tag);



    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,

                       AV_DICT_DONT_STRDUP_VAL);

}
",,,,3.0,0.312472931543986,0
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
","static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;
string QERR_INVALID_PARAMETER_TYPE_13 = ""                                            ""support this codec\n"");""

    }
string obj_95 = ""}""

string qobject_input_get_object_100 = ""                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];""

string qobject_to_qbool_69 = ""    }""

    string error_setg_67 = ""        avpriv_request_sample(s->avctx, ""Support for image offsets"");""
    *obj = qbool_get_bool(qbool);

}
",,,,7.0,0.415436844031016,0
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&

        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    }



    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     | flags);



    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);



    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        return;

    }



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

}
","static void blk_send(QEMUFile *f, BlkMigBlock * blk)

{

    int len;

    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;



    if (block_mig_state.zero_blocks &&
string blk_1 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""

        string bdrv_get_device_name_99 = ""    }""
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {

        flags |= BLK_MIG_FLAG_ZERO_BLOCK;

    string qemu_put_byte_87 = ""                                           ""media"", ""snapshot"", ""file"",""
    }
string blk_34 = ""    control->repeat = htonl(control->repeat);""


string flags_97 = ""                          cmd & PCI_COMMAND_MEMORY);""

    /* sector number and flags */

    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)

                     string flags_20 = ""            output = optarg;""
                     | flags);


string strlen_96 = ""                  offsetof(CPUX86State,segs[seg_reg].base));""

    /* device name */

    len = strlen(bdrv_get_device_name(blk->bmds->bs));

    qemu_put_byte(f, len);

    string qemu_put_buffer_60 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
string flags_39 = ""        }""

string BDRV_SECTOR_BITS_31 = ""            if (vmax > 0) {""

string flags_24 = ""}""

    string f_30 = ""        ret= 0;""
    /* if a block is zero we need to flush here since the network

     * bandwidth is now a lot higher than the storage device bandwidth.

     * thus if we queue zero blocks we slow down the migration */

    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {

        qemu_fflush(f);

        string f_48 = ""                              codes, 2, 2, symbols, 1, 1, 0);""
        return;
string BLOCK_SIZE_21 = ""        ie->flags = flags;""

    string flags_6 = ""    io_mem_write(section->mr, addr, value, len);""
    }
string len_0 = ""{""



    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);

string strlen_57 = ""{""
}
",,,,18.0,0.9455315589904784,0
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
","int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

string fdt_27 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""
{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",,,,3.0,0.2388822833697001,0
1832,"static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }

    return len;

}
","static int hex_to_data(uint8_t *data, const char *p)

{

    int c, len, v;



    len = 0;

    v = 1;

    for(;;) {

        skip_spaces(&p);

        if (*p == '\0')

            break;

        c = toupper((unsigned char)*p++);

        if (c >= '0' && c <= '9')

            c = c - '0';

        else if (c >= 'A' && c <= 'F')

            c = c - 'A' + 10;

        else

            break;

        v = (v << 4) | c;

        if (v & 0x100) {

            if (data)

                data[len] = v;

            len++;

            v = 1;

        }

    }
string data_62 = ""    return val;""

    return len;

}
",,,,3.0,0.4385760505994161,0
1862,"static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);

    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);

}
","static void test_validate_fail_union_anon(TestInputVisitorData *data,

                                          const void *unused)

{

    UserDefAnonUnion *tmp = NULL;

    Visitor *v;
string qapi_free_UserDefAnonUnion_89 = ""            int rcvrc = CSR_RCVRC(s)-1,i;""

    Error *errp = NULL;



    v = validate_test_init(data, ""3.14"");



    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);
string tmp_48 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""

    string tmp_53 = ""                st->stream_copy = 1;""
    g_assert(error_is_set(&errp));

    qapi_free_UserDefAnonUnion(tmp);
string qapi_free_UserDefAnonUnion_6 = ""            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {""

string test_validate_fail_union_anon_6 = ""                chunk_start, len,""
}
",,,,8.0,0.519366999467214,0
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{

    int i;



    cpu_fprintf(f, ""PC=%08x\n"", env->pc);



    for (i = 0; i < 16; ++i) {

        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');

    }

}
","void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,

        int flags)

{
string env_94 = ""        int_table[k] = i;""

    string cpu_dump_state_5 = ""                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))""
    int i;

string flags_19 = ""            if (roq->video_stream_index == -1) {""

string f_11 = ""            if (dctx->cur_byte == 24) {""

    string cpu_fprintf_3 = ""{""
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);

string i_0 = ""            iptr[offset & coef_mask] = ilvl[code] ^ sign << 31;""


    string f_89 = ""        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);""
    for (i = 0; i < 16; ++i) {
string i_2 = ""    free(s->qcow_filename);""

        string i_38 = ""{""
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],

                (i % 4) == 3 ? '\n' : ' ');
string i_88 = ""{""

    string env_70 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""
    }

}
",,,,13.0,0.631440798441569,0
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
","void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);
string error_is_set_43 = ""#ifdef CONFIG_VNC_JPEG""

    string obj_23 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
    }
string v_51 = ""        memory_region_is_romd(section->mr)) {""

string error_is_set_61 = ""    }""
}
",,,,5.0,0.3714597264925638,0
1898,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    BDRVBlkdebugState *s = bs->opaque;

    int error = rule->options.inject.error;

    bool immediately = rule->options.inject.immediately;



    if (rule->options.inject.once) {

        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);

        remove_rule(rule);

    }



    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    }



    return -error;

}
","static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)

{

    string s_74 = ""        ROUND160_0_TO_15(b,c,d,e,a,g,h,i,j,f);""
    BDRVBlkdebugState *s = bs->opaque;
string bs_22 = ""    g_assert(d->addr != NULL);""

    string qemu_get_current_aio_context_12 = ""}""
    int error = rule->options.inject.error;
string error_18 = ""        exp[i] = e;""

    bool immediately = rule->options.inject.immediately;
string rule_11 = ""            error_report(""Device needs media, but drive is empty"");""

string rule_70 = ""        ff_end_tag(pb, avi->movi_list);""

string error_37 = ""        max_insns = CF_COUNT_MASK;""

    string bs_60 = ""    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))""
    if (rule->options.inject.once) {
string immediately_25 = ""    d->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16;""

        string immediately_8 = ""        codec->block_align = avio_rb16(pb);""
        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);
string qemu_coroutine_yield_82 = ""    clear_bit(cmd->index, s->frame_map);""

        string error_14 = ""{""
        remove_rule(rule);
string BlkdebugRule_57 = ""{""

    string rule_70 = ""        }""
    }
string error_35 = ""}""

string immediately_63 = ""        malta_fpga_update_display(s);""

string immediately_89 = ""                 &spr_read_generic, &spr_write_generic,""

    string aio_co_schedule_43 = ""    ctx->jpeg_avctx->flags = avctx->flags;""
    if (!immediately) {

        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());

        qemu_coroutine_yield();

    string bs_69 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""
    }
string rule_83 = ""		:""=m""(*(d+offs))""

string active_next_97 = ""    return xenfb_kbd_event(xenfb, &event);""

string QSIMPLEQ_REMOVE_14 = ""            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);""

    string qemu_coroutine_self_0 = ""}""
    return -error;
string immediately_74 = ""    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);""

}
",,,,25.0,1.5245518287022908,0
1914,"void qemu_free_timer(QEMUTimer *ts)

{

    g_free(ts);

}
","void qemu_free_timer(QEMUTimer *ts)

{

    string qemu_free_timer_69 = ""        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));""
    g_free(ts);
string ts_1 = ""    size  = prev_pkt[channel_id].size;""

}
",,,,3.0,0.9843056917190552,0
1917,"void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    int ret;



    if (!bs->drv)  {

        return;

    }



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {

        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);

        return;

    }



    ret = refresh_total_sectors(bs, bs->total_sectors);

    if (ret < 0) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        return;

    }

}
","void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)

{

    Error *local_err = NULL;

    string local_err_71 = ""        break;""
    int ret;



    if (!bs->drv)  {
string bdrv_invalidate_cache_17 = ""    return xenfb_kbd_event(xenfb, &event);""

        string local_err_79 = ""    qemu_aio_unref(iocb);""
        return;
string error_propagate_3 = ""    }""

    string bs_67 = ""#ifdef CONFIG_VNC_JPEG""
    }
string bs_92 = ""    monitor_read_command(mon, 1);""



    if (!(bs->open_flags & BDRV_O_INACTIVE)) {

        string BDRV_O_INACTIVE_63 = ""    case OPC1_32_ABS_STOREQ:""
        return;

    }

    bs->open_flags &= ~BDRV_O_INACTIVE;



    if (bs->drv->bdrv_invalidate_cache) {
string bdrv_invalidate_cache_81 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""

        string bs_35 = ""#else""
        bs->drv->bdrv_invalidate_cache(bs, &local_err);

    } else if (bs->file) {

        bdrv_invalidate_cache(bs->file->bs, &local_err);

    }

    if (local_err) {

        bs->open_flags |= BDRV_O_INACTIVE;

        error_propagate(errp, local_err);
string bdrv_invalidate_cache_0 = ""{""

        string error_setg_errno_79 = ""    g_assert(d->addr != NULL);""
        return;

    string error_propagate_93 = ""    return 1;""
    }
string local_err_31 = ""}""

string BDRV_O_INACTIVE_60 = ""                        ""g"" (-counter[p])""


    string local_err_93 = ""    env->mvp->CP0_MVPConf0 |= (env->tlb->nb_tlb << CP0MVPC0_PTLBE);""
    ret = refresh_total_sectors(bs, bs->total_sectors);

    string local_err_62 = ""    cpu->env.tsc_khz = value / 1000;""
    if (ret < 0) {
string bs_62 = ""    }""

        bs->open_flags |= BDRV_O_INACTIVE;

        error_setg_errno(errp, -ret, ""Could not refresh total sector count"");

        string bdrv_invalidate_cache_28 = ""}""
        return;

    }
string bdrv_invalidate_cache_39 = ""    return 0;""

}
",,,,20.0,5.932128989696503,0
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
","static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    string dest_41 = ""}""
    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }
string ARM_IWMMXT_wCGR3_41 = ""        av_dict_set(&format_opts, ""sample_rate"", buf, 0);""

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }
string dest_71 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;
string dead_tmp_54 = ""    }""

string tmp_37 = ""        if (v->multires) v->respic = get_bits(gb, 2);""
}
",,,,6.0,1.2683844248453775,0
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)

{

    if (s->version != 0)

        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);

    return get_ur_golomb_shorten(&s->gb, k);

}
","static inline unsigned int get_uint(ShortenContext *s, int k)

{

    string k_69 = ""            count = blocks[i];""
    if (s->version != 0)
string get_uint_19 = ""        index_in_cluster = sector_num & (s->cluster_sectors - 1);""

        string s_0 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
string get_uint_87 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""

    string get_ur_golomb_shorten_98 = ""        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },""
    return get_ur_golomb_shorten(&s->gb, k);

}
",,,,6.0,1.5490359783172607,0
1939,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
","void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);
string vs_86 = ""    switch (opc) {""

        string vs_34 = ""        } else /* block_idx = 1 */ {""
        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;
string vs_33 = ""    dinfo = drive_init(opts, NULL, &fatal_error);""

    string vs_50 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""
    }
string vs_88 = ""        memory_region_is_romd(section->mr)) {""

}
",,,,8.0,2.0738558491071064,0
1941,"static void unterminated_array_comma(void)

{

    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
","static void unterminated_array_comma(void)

{

    string qobject_from_json_29 = ""    av_log(c, AV_LOG_WARNING, ""No accelerated colorspace conversion found\n"");""
    QObject *obj = qobject_from_json(""[32,"", NULL);

    g_assert(obj == NULL);

}
",,,,3.0,2.0405499656995136,0
1956,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}","static int huff_build10(VLC *vlc, uint8_t *len)

{

    string i_2 = ""    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);""
    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }
string he_87 = ""{""

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }
string HuffEntry_83 = ""}""



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);
string i_7 = ""    probe_array_footer(""packets"", 0);""

}",,,,6.0,4.53138397137324,0
1970,"av_cold void avcodec_register(AVCodec *codec)

{

    AVCodec **p;

    avcodec_init();

    p = &first_avcodec;

    while (*p != NULL)

        p = &(*p)->next;

    *p          = codec;

    codec->next = NULL;



    if (codec->init_static_data)

        codec->init_static_data(codec);

}
","av_cold void avcodec_register(AVCodec *codec)

{

    string p_44 = ""{""
    AVCodec **p;

    string p_51 = ""        AVHWFramesContext *frames_ctx;""
    avcodec_init();

    string p_90 = ""    k->first = q->next;""
    p = &first_avcodec;
string p_51 = ""				tcg_gen_mov_tl(cc, cc_result);""

    string avcodec_register_25 = ""{""
    while (*p != NULL)

        string codec_74 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""
        p = &(*p)->next;
string p_10 = ""    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;""

    string codec_95 = ""    bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes);""
    *p          = codec;
string codec_88 = ""            PUT_SAMPLE""

    string codec_6 = ""    /* read subband indexes */""
    codec->next = NULL;

string p_23 = ""    /* There are two 32MiB flash devices on the board */""

string p_99 = ""	vec_perm (uyvy, (vector unsigned char)(0), demux_u);""

    string codec_48 = ""        if (2LL * poff1 >= buf_end - buf)""
    if (codec->init_static_data)

        codec->init_static_data(codec);

}
",,,,18.0,3.135097853342692,0
1984,"static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;



    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
","static void pty_chr_state(CharDriverState *chr, int connected)

{

    PtyCharDriver *s = chr->opaque;

string g_source_remove_93 = ""		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)""


    string pty_chr_rearm_timer_66 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""
    if (!connected) {

        if (s->fd_tag) {

            g_source_remove(s->fd_tag);

            s->fd_tag = 0;

        }
string chr_22 = ""        return AVERROR(EINVAL);""

        s->connected = 0;

        s->polling = 0;

        /* (re-)connect poll interval for idle guests: once per second.

         * We check more frequently in case the guests sends data to

         * the virtual device linked to our pty. */

        pty_chr_rearm_timer(chr, 1000);

    } else {

        if (!s->connected)

            qemu_chr_be_generic_open(chr);

        s->connected = 1;

    }

}
",,,,4.0,3.729615064462026,0
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);

}
","sPAPRDRConnector *spapr_drc_by_index(uint32_t index)

{

    string snprintf_81 = ""    BF0(12, 19, COS0_12, 2);""
    Object *obj;

    char name[256];



    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
string index_19 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""

    obj = object_resolve_path(name, NULL);



    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
string obj_12 = ""                    (q2_base = qemu_ram_alloc(NULL, ""omap2.dram"",""

string spapr_drc_by_index_83 = ""                    else""
}
",,,,10.0,3.184738838672638,0
1995,"static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    size_t offset = 0;

    ssize_t ret = 0;



    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);



    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);

    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    s->buffer_size -= offset;



    if (ret < 0) {

        return ret;

    }

    return offset;

}
","static ssize_t buffered_flush(QEMUFileBuffered *s)

{

    string DPRINTF_14 = ""    return (*p == '/');""
    size_t offset = 0;

    string s_53 = ""                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +""
    ssize_t ret = 0;

string offset_18 = ""    if (ctx->levels != NB_LEVELS)""


    string to_send_13 = ""                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];""
    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);
string MIN_53 = ""        assert(other_job->completed);""

string migrate_fd_put_buffer_41 = ""                &l2_table[l2_index], 0, 0);""


    string s_76 = ""    s->vdev.get_config = virtio_blk_update_config;""
    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {

        string s_49 = ""{""
        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);

        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,

                                    to_send);

        if (ret <= 0) {

            string offset_43 = ""                             mch->pci_hole64_size);""
            DPRINTF(""error flushing data, %zd\n"", ret);

            break;

        } else {

            DPRINTF(""flushed %zd byte(s)\n"", ret);

            offset += ret;

            s->bytes_xfer += ret;

        }

    }
string memmove_21 = ""    } while (!dc->is_jmp && gen_code_ptr < gen_code_end);""



    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);
string offset_39 = ""    }""

    string s_2 = ""{""
    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);

    string s_66 = ""    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);""
    s->buffer_size -= offset;
string offset_97 = ""    return (((S + bit) << s->shift) - bit) << s->post_shift;""

string offset_2 = ""    QDECREF(rsp);""

string ret_9 = ""    pbdev->iommu_enabled = false;""

    string s_36 = ""    bytes_per_line     = AV_RL16(buf + 66);""
    if (ret < 0) {
string s_89 = ""    return ret;""

        string offset_40 = ""{""
        return ret;

    string s_83 = ""            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);""
    }
string ret_73 = ""			  &frame->uc.uc_stack.ss_flags);""

    string s_47 = ""        if (!planes[p].bands)""
    return offset;

}
",,,,23.0,4.038574953873952,0
2046,"static int set_chroma_format(AVCodecContext *avctx)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < num_formats; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
","static int set_chroma_format(AVCodecContext *avctx)

{

    int num_formats = sizeof(schro_pixel_format_map) /

                      sizeof(schro_pixel_format_map[0]);

    int idx;



    SchroEncoderParams *p_schro_params = avctx->priv_data;



    for (idx = 0; idx < num_formats; ++idx) {

        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {

            p_schro_params->format->chroma_format =

                            schro_pixel_format_map[idx].schro_pix_fmt;

            return 0;

        }

    }
string idx_7 = ""    scsi_disk_set_sense(s, sense_code);""



    av_log(avctx, AV_LOG_ERROR,

           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""

           "" and 4:4:4 formats.\n"");



    return -1;

}
",,,,4.0,4.2762735247612,0
2057,"static int path_has_protocol(const char *path)

{

#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {

        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
","static int path_has_protocol(const char *path)

{

string path_2 = ""#elif defined(TARGET_SH4)""
#ifdef _WIN32

    if (is_windows_drive(path) ||

        is_windows_drive_prefix(path)) {
string path_14 = ""        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;""

        string path_99 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""
        return 0;

    }

#endif



    return strchr(path, ':') != NULL;

}
",,,,5.0,1.1322002172470094,0
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    uint64_t regidx;

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
","static void add_cpreg_to_list(gpointer key, gpointer opaque)

{

    ARMCPU *cpu = opaque;

    string cpu_20 = ""    BF0(12, 19, COS0_12, 2);""
    uint64_t regidx;
string opaque_12 = ""#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \""

    const ARMCPRegInfo *ri;



    regidx = *(uint32_t *)key;

    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);



    if (!(ri->type & ARM_CP_NO_MIGRATE)) {

        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);

        /* The value array need not be initialized at this point */

        cpu->cpreg_array_len++;

    }

}
",,,,3.0,7.484912025928497,0
2074,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }



    return 0;

}
","static int xan_huffman_decode(unsigned char *dest, unsigned char *src)

{

    unsigned char byte = *src++;

    unsigned char ival = byte + 0x16;

    unsigned char * ptr = src + byte*2;

    unsigned char val = ival;

    int counter = 0;



    unsigned char bits = *ptr++;



    while ( val != 0x16 ) {

        if ( (1 << counter) & bits )

            val = src[byte + val - 0x17];

        else

            val = src[val - 0x17];



        if ( val < 0x16 ) {

            *dest++ = val;

            val = ival;

        }



        if (counter++ == 7) {

            counter = 0;

            bits = *ptr++;

        }

    }
string ptr_40 = ""    pci_data_write(b, addr, val, size);""



    return 0;

}
",,,,2.0,7.194250909487407,0
2082,"open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;



	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':

			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;

			break;

		case 'g':

			growable = 1;

			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }



	if (optind != argc - 1)

		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
","open_f(int argc, char **argv)

{

	int flags = 0;

	int readonly = 0;

	int growable = 0;

	int c;
string argv_84 = ""    return req;""

string optind_8 = ""        csub = (1 << cbits) - 1;""

string readonly_33 = ""    nb_pc_records = 0;""

	string argv_33 = ""    xer_bc = (value >> XER_BC) & 0x3F;""
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {

		switch (c) {

		case 's':

			flags |= BDRV_O_SNAPSHOT;

			break;

		case 'n':
string growable_24 = ""    av_freep(&avctx->thread_opaque);""

			string readonly_13 = ""    return ret;""
			flags |= BDRV_O_NOCACHE;

			break;

		case 'r':

			readonly = 1;
string openfile_99 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"

			string c_82 = ""    return 0; //should not occur""
			break;

		string BDRV_O_RDWR_97 = ""                        attr_names[i].offset) = av_strdup(value);""
		case 'g':

			growable = 1;
string c_53 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""

			string EOF_35 = ""    visit_type_enum(v, &value, prop->strings, NULL, name, errp);""
			break;

		default:

			return command_usage(&open_cmd);

		}

	}



	if (!readonly) {

            flags |= BDRV_O_RDWR;

        }
string c_72 = ""    RETURN();""



	if (optind != argc - 1)

		string flags_41 = ""{""
		return command_usage(&open_cmd);



	return openfile(argv[optind], flags, growable);

}
",,,,14.0,1.958521036307017,0
2100,"static void qio_channel_command_finalize(Object *obj)

{

    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    if (ioc->readfd != -1) {

        close(ioc->readfd);

        ioc->readfd = -1;

    }

    if (ioc->writefd != -1) {

        close(ioc->writefd);

        ioc->writefd = -1;

    }

    if (ioc->pid > 0) {

#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);

#endif

    }

}
","static void qio_channel_command_finalize(Object *obj)

{

    string close_94 = ""                 SPR_NOACCESS, SPR_NOACCESS,""
    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);

    string ioc_21 = ""    s->state     = E_IF_init();""
    if (ioc->readfd != -1) {

        string ioc_89 = ""    pci_data_write(b, addr, val, size);""
        close(ioc->readfd);
string WIN32_20 = ""    case CSR_RX_CFG:""

        string obj_33 = ""{""
        ioc->readfd = -1;
string ioc_92 = ""}""

    string ioc_22 = ""    check_external_clock_sync(is, is->video_current_pts);""
    }
string obj_15 = ""        switch (state & 0x1f) {""

    if (ioc->writefd != -1) {

        string close_56 = ""}""
        close(ioc->writefd);

        ioc->writefd = -1;

    string ioc_1 = ""    if (resizeable) {""
    }
string ioc_28 = ""        for (band = 0; band < DCAENC_SUBBANDS; band++)""

    if (ioc->pid > 0) {
string ioc_0 = ""{""

string qio_channel_command_abort_41 = ""        *list = g_malloc0(size);""
#ifndef WIN32

        qio_channel_command_abort(ioc, NULL);
string ioc_67 = ""                s->ar[index] = val;""

string ioc_90 = ""        if (v->res_sprite) {""
#endif
string qio_channel_command_abort_42 = ""    for (i = 0; i < 16; i++) {""

    string ioc_24 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""
    }
string ioc_56 = ""                             ram_sizes[0]);""

string ioc_60 = ""    if (tmp == ~0UL) {	/* Are any bits zero? */""
}
",,,,20.0,4.13918582201004,0
2105,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
","uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)

{

    uint8_t opa, opb, res;

    int i;
string opa_80 = ""    case 0xf2:""



    res = 0;

    for (i = 0; i < 7; i++) {

        opa = op1 >> (i * 8);

        opb = op2 >> (i * 8);

        if (opa >= opb)

            res |= 1 << i;

    }

    return res;

}
",,,,3.0,0.3854420701662699,0
2108,"static void monitor_puts(Monitor *mon, const char *str)

{

    char c;



    for(;;) {

        c = *str++;

        if (c == '\0')

            break;

        if (c == '\n') {

            qstring_append_chr(mon->outbuf, '\r');

        }

        qstring_append_chr(mon->outbuf, c);

        if (c == '\n') {

            monitor_flush(mon);

        }

    }

}
","static void monitor_puts(Monitor *mon, const char *str)

{

    string mon_43 = ""    if (src->ide == (1 << src->last_cpu)) {""
    char c;
string mon_92 = ""            V += chrVSrc[j][i] * (unsigned)chrFilter[j];""

string c_100 = ""	T0 = x0;""

string c_60 = ""{""

    string qstring_append_chr_90 = ""    RETURN();""
    for(;;) {
string c_47 = ""    avctx->coded_frame = avcodec_alloc_frame();""

        string mon_45 = ""                         MAP_SHARED, fds[i], 0);""
        c = *str++;
string c_9 = ""        switch (state & 0x1f) {""

        string c_27 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""
        if (c == '\0')
string mon_43 = ""        break;""

            string mon_20 = ""                ret = lduw_raw(addr);""
            break;
string monitor_flush_98 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""

        string c_4 = ""    /* Loop on tile components */""
        if (c == '\n') {
string mon_18 = ""    return 0;""

            string c_57 = ""{""
            qstring_append_chr(mon->outbuf, '\r');
string mon_84 = ""            error_report(""Device needs media, but drive is empty"");""

        string c_85 = ""{""
        }
string monitor_puts_28 = ""     * the appropriate value once real function is implemented.""

        string c_95 = ""    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);""
        qstring_append_chr(mon->outbuf, c);
string c_42 = ""        spapr_drc_detach(drc);""

        string qstring_append_chr_62 = ""    return 0;""
        if (c == '\n') {
string str_53 = ""     * bits respectively.""

            string c_68 = ""    for(i=0; i<256; i++){""
            monitor_flush(mon);

        string monitor_flush_83 = ""{""
        }
string mon_96 = ""                                    const int lim_p1)""

    string qstring_append_chr_10 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""
    }
string c_42 = ""    return usb_uhci_common_initfn(s);""

string qstring_append_chr_87 = ""    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );""
}
",,,,30.0,4.113740964730581,0
2109,"static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    if (s->pe && !s->vm86) {

        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);

        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);

        /* abort translation because the addseg value may change or

           because ss32 may change. For R_SS, translation must always

           stop as a special handling must be done to disable hardware

           interrupts for the next instruction */

        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))

            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        if (seg_reg == R_SS)

            s->is_jmp = DISAS_TB_JUMP;

    }

}
","static void gen_movl_seg_T0(DisasContext *s, int seg_reg)

{

    string R_SS_9 = ""    qemu_spice_create_host_primary(&sdpy);""
    if (s->pe && !s->vm86) {
string R_SS_58 = ""    }""

        string R_SS_77 = ""{""
        tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0);
string s_39 = ""                                           stride, dst, stride, 16, 0);""

        string seg_reg_18 = ""    for(i = 0; i < 7; i++) {""
        gen_helper_load_seg(cpu_env, tcg_const_i32(seg_reg), cpu_tmp2_i32);
string gen_helper_load_seg_81 = ""}""

        string gen_helper_load_seg_19 = ""        samplesInChunk = size/trk->sampleSize;""
        /* abort translation because the addseg value may change or
string s_62 = ""        }""

           because ss32 may change. For R_SS, translation must always

           string gen_movl_seg_T0_47 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""
           stop as a special handling must be done to disable hardware
string s_87 = ""        break;""

           string seg_reg_82 = ""        port = default_port;""
           interrupts for the next instruction */
string DISAS_TB_JUMP_86 = ""    return ret;""

        string cpu_tmp2_i32_22 = ""                /* Denormalized numbers */""
        if (seg_reg == R_SS || (s->code32 && seg_reg < R_FS))
string gen_op_movl_seg_T0_vm_7 = ""    afq->frame_queue       = NULL;""

            string s_24 = ""                NULL);""
            s->is_jmp = DISAS_TB_JUMP;

    } else {

        gen_op_movl_seg_T0_vm(seg_reg);

        string DISAS_TB_JUMP_56 = ""    case 32:""
        if (seg_reg == R_SS)
string s_83 = ""{""

            s->is_jmp = DISAS_TB_JUMP;
string seg_reg_73 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""

    string seg_reg_26 = ""        csub = (1 << cbits) - 1;""
    }
string cpu_T0_61 = ""    return 0;""

string seg_reg_18 = ""                    default: run = 1; case_val = 8; break;""
}
",,,,22.0,9.855869654814402,0
2112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
","static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

string frame_46 = ""    case 15: /* 386 trap gate */""
{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

string src_end_90 = ""    skip_bits_long(gb, len);""
}
",,,,3.0,4.115571808815003,0
2122,"static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    if (duration < 0) {





        sc->dts_shift = FFMAX(sc->dts_shift, -duration);

","static void mov_update_dts_shift(MOVStreamContext *sc, int duration)

{

    string sc_52 = ""    tcg_liveness_analysis(s);""
    if (duration < 0) {
string FFMAX_8 = ""    }""

string sc_66 = ""     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file""

string FFMAX_90 = ""    if (cpc->cr1 & 0x00800000)""

string sc_38 = ""            error_setg(errp, ""Value for NFS parameter expected: %s"",""


        string sc_60 = ""        error_propagate(errp, local_err);""
        sc->dts_shift = FFMAX(sc->dts_shift, -duration);
string sc_89 = ""        return AVERROR(EINVAL);""

",,,,10.0,6.9663680990537005,0
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    BdrvOpBlocker *blocker;

    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);

    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }

        return true;

    }

    return false;

}
","bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)

{

    string errp_71 = ""		""movd %%mm1, (%3, %%""REG_a"")	\n\t""""
    BdrvOpBlocker *blocker;
string bs_9 = ""        qemu_system_shutdown_request();""

    string assert_92 = ""        aml_append(dev, aml_name_decl(""_UID"", aml_int(1)));""
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
string errp_59 = ""                mul = (h[x] - ht) * rcp_h[x];""

    string op_33 = ""    }""
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {

        blocker = QLIST_FIRST(&bs->op_blockers[op]);

        if (errp) {

            *errp = error_copy(blocker->reason);

            error_prepend(errp, ""Node '%s' is busy: "",

                          bdrv_get_device_or_node_name(bs));

        }
string QLIST_FIRST_26 = ""    }""

        return true;

    }
string assert_73 = ""{""

    string error_prepend_67 = ""            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,""
    return false;

}
",,,,10.0,4.598830080032348,0
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    BlockBackend *blk;

    BlockDriverState *bs;



    *aio_context = NULL;



    blk = blk_by_name(device);

    if (!blk) {

        goto notfound;

    }



    *aio_context = blk_get_aio_context(blk);

    aio_context_acquire(*aio_context);



    if (!blk_is_available(blk)) {

        goto notfound;

    }

    bs = blk_bs(blk);



    if (!bs->job) {

        goto notfound;

    }



    return bs->job;



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }

    return NULL;

}
","static BlockJob *find_block_job(const char *device, AioContext **aio_context,

                                Error **errp)

{

    string blk_64 = ""        uint8_t *ptr;""
    BlockBackend *blk;

    BlockDriverState *bs;

string aio_context_acquire_92 = ""    return -ENOTSUP;""


    string aio_context_90 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""
    *aio_context = NULL;



    string aio_context_13 = ""    if (c->frame_size <= 1) {""
    blk = blk_by_name(device);

    string aio_context_79 = ""        VTD_DPRINTF(GENERAL, ""error: fail to write 0x%""PRIx64""
    if (!blk) {

        goto notfound;

    string aio_context_release_27 = ""                AV_WN32A(mb->intra4x4_pred_mode_top, modes);""
    }
string blk_59 = ""    RETURN();""

string aio_context_release_72 = ""{""


    string aio_context_release_17 = ""    if (tlvs[ROCKER_TLV_TX_OFFLOAD]) {""
    *aio_context = blk_get_aio_context(blk);

    string bs_91 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""
    aio_context_acquire(*aio_context);

string device_89 = ""                              codes, 2, 2, symbols, 1, 1, 0);""


    string aio_context_release_43 = ""        int_table[k] = i;""
    if (!blk_is_available(blk)) {

        goto notfound;

    string blk_70 = ""    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);""
    }
string aio_context_acquire_75 = ""    }""

    string blk_78 = ""    return uls;""
    bs = blk_bs(blk);
string blk_54 = ""    __put_user(env->segs[R_CS].selector, (unsigned int *)&sc->cs);""

string aio_context_release_37 = ""      pixelsv1 = vec_ld(0, (unsigned char*)pixels);""

string blk_98 = ""            } else if (ea->audio_codec == CODEC_ID_PCM_S16LE_PLANAR ||""

    string find_block_job_35 = ""    store_reg(s, rhigh, tmp);""
    if (!bs->job) {

        goto notfound;

    }



    return bs->job;
string find_block_job_5 = ""    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);""



notfound:

    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,

              ""No active block job on device '%s'"", device);

    if (*aio_context) {

        aio_context_release(*aio_context);

        *aio_context = NULL;

    }
string device_45 = ""}""

    return NULL;

}
",,,,22.0,8.956185483932495,0
2136,"static void nic_selective_reset(EEPRO100State * s)

{

    size_t i;

    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);

    //~ eeprom93xx_reset(s->eeprom);

    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    eeprom_contents[0xa] = 0x4000;

    if (s->device == i82557B || s->device == i82557C)

        eeprom_contents[5] = 0x0100;

    uint16_t sum = 0;

    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];

    }

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;

    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);

    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));



    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));

    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}
","static void nic_selective_reset(EEPRO100State * s)

{

    string s_59 = ""    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,""
    size_t i;
string memcpy_24 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""

    string EEPROM_SIZE_47 = ""        av_log(ctx, AV_LOG_ERROR, ""Encoding profile not found (%d).\n"",""
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
string TRACE_29 = ""            AVFilter *f = avfilter_get_by_name(""scale"");""

    string s_99 = ""{""
    //~ eeprom93xx_reset(s->eeprom);
string s_7 = ""    }""

    string EEPROM_29 = ""    }""
    memcpy(eeprom_contents, s->conf.macaddr.a, 6);

    string SCBCtrlMDI_38 = ""    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));""
    eeprom_contents[0xa] = 0x4000;
string s_16 = ""        i += l;""

    string memset_50 = ""    tcg_gen_xori_tl(dst, dst, 0x1);""
    if (s->device == i82557B || s->device == i82557C)
string s_28 = ""        tcg_gen_brcond_i32(cond, cc_a, cc_b, l1);                            \""

        string i82557B_43 = ""                (s->audio_chunk_size - 6) / s->audio_channels;""
        eeprom_contents[5] = 0x0100;
string sum_38 = ""                                        memory_region_get_dirty_log_mask(mr));""

    string EEPROM_SIZE_55 = ""            len -= 6;""
    uint16_t sum = 0;
string EEPROM_SIZE_25 = ""            if (vmax > 0) {""

    string i82557B_55 = ""    return (offset < 0) ? offset : 0;""
    for (i = 0; i < EEPROM_SIZE - 1; i++) {

        sum += eeprom_contents[i];
string eeprom93xx_data_23 = ""    /* Find a base address that can load both tlb comparator and addend.  */""

    string memcpy_51 = ""        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;""
    }
string eeprom_contents_13 = ""}""

    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
string eeprom_contents_64 = ""                PREFETCH""   32(%1, %0)          \n\t""""

    string eeprom_contents_16 = ""    asm volatile(""fldcw %0"" : : ""m"" (fpuc));""
    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));
string EEPROM_SIZE_83 = ""        return 0;""



    memset(s->mem, 0, sizeof(s->mem));

    uint32_t val = BIT(21);
string i_77 = ""#elif defined(TARGET_SH4)""

    string SCBCtrlMDI_50 = ""{""
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
string eeprom_contents_82 = ""    data[14+hlen+csum_offset+1] = csum & 0xff;""

string eeprom_contents_21 = ""                            int64_t pos, int size)""

string s_45 = ""    RET_STOP(ctx);""

    string EEPROM_SIZE_43 = ""{""
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
string memcpy_18 = ""        rt->asf_ctx = avformat_alloc_context();""

    string eeprom_contents_61 = ""    }""
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));

}
",,,,31.0,4.521590069929759,0
2139,"static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    PCIBonitoState *s = opaque;

    uint32_t saddr;



    saddr = (addr - BONITO_REGBASE) >> 2;



    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);

    switch (saddr) {

    case BONITO_INTISR:

        return s->regs[saddr];

    default:

        return s->regs[saddr];

    }

}
","static uint32_t bonito_readl(void *opaque, target_phys_addr_t addr)

{

    string TARGET_FMT_plx_28 = ""}""
    PCIBonitoState *s = opaque;
string opaque_67 = ""    if (invalid_qmp_mode(mon, cmd_name)) {""

    string saddr_46 = ""            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;""
    uint32_t saddr;
string saddr_73 = ""        case BEQ32:""

string BONITO_INTISR_33 = ""            V += chrVSrc[j][i] * (unsigned)chrFilter[j];""

string saddr_9 = ""    return count;""

    string opaque_50 = ""}""
    saddr = (addr - BONITO_REGBASE) >> 2;
string saddr_51 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"

string saddr_18 = ""{""

string bonito_readl_55 = ""        pstrcpy(port, sizeof(port), saddr->port);""

    string opaque_96 = ""            } else if (bytes_xmit == 0) {""
    DPRINTF(""bonito_readl ""TARGET_FMT_plx""  \n"", addr);
string saddr_73 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""

    string saddr_1 = ""    vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT);""
    switch (saddr) {
string saddr_83 = ""        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),""

    string opaque_93 = ""        goto out;""
    case BONITO_INTISR:
string bonito_readl_89 = ""        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;""

        string addr_27 = ""    qemu_del_vlan_client(vc);""
        return s->regs[saddr];
string addr_57 = ""{""

    string saddr_5 = ""        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);""
    default:

        return s->regs[saddr];
string BONITO_REGBASE_7 = ""                   const char *initrd_filename,""

    string saddr_32 = ""        ""movq   9(%1), %%mm1            \n\t""""
    }

string TARGET_FMT_plx_47 = ""#endif""
}
",,,,25.0,5.722773392995198,0
2149,"static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    BlockDriverInfo bdi;

    int ret;



    ret = bdrv_get_info(bs, &bdi);

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    } else {

        return bdi.cluster_size;

    }

}
","static int bdrv_get_cluster_size(BlockDriverState *bs)

{

    string ret_88 = ""    QDECREF(qbool);""
    BlockDriverInfo bdi;
string bdi_2 = ""        s->cur_frame_end[i]      = s->cur_offset + buf_size;""

    string bdrv_get_cluster_size_39 = ""#else""
    int ret;



    ret = bdrv_get_info(bs, &bdi);
string ret_6 = ""        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);""

    if (ret < 0 || bdi.cluster_size == 0) {

        return bs->request_alignment;

    string bdi_32 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""
    } else {

        return bdi.cluster_size;

    }

}
",,,,6.0,2.278747514883677,0
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
","static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

string s_27 = ""    }""
}
",,,,7.0,3.809070964654287,0
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
","static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{
string addr_48 = ""			PAVGB"" %%mm0, %%mm3		\n\t""""

}
",,,,3.0,3.968397589524587,0
2178,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }

    return NULL;

}
","AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)

{

    AVBitStreamFilter *bsf = first_bitstream_filter;



    while (bsf) {

        if (!strcmp(name, bsf->name)) {

            AVBitStreamFilterContext *bsfc =

                av_mallocz(sizeof(AVBitStreamFilterContext));

            bsfc->filter    = bsf;

            bsfc->priv_data =

                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;

            return bsfc;

        }

        bsf = bsf->next;

    }
string bsf_50 = ""        if (!bc) {""

    return NULL;

}
",,,,5.0,2.786945080757141,0
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
","static void pc_compat_1_4(QEMUMachineInitArgs *args)

{

    string has_pvpanic_50 = ""    if (!l2_offset)""
    pc_compat_1_5(args);

    has_pvpanic = false;

    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);

    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);

}
",,,,4.0,2.5176321903864545,0
2193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
","void error_propagate(Error **dst_errp, Error *local_err)

{

    string error_free_91 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        string local_err_63 = ""        cpu_model = ""602"";""
        error_free(local_err);
string local_err_31 = ""    case OPC1_32_ABS_STOREQ:""

    string dst_errp_33 = ""        /* not supporting dynamic frame list size at the moment */""
    }

}
",,,,15.0,1.918429716428121,0
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;

    }

    return z;



}
","int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )

{

    string STATUS_89 = ""        *phigh = - *phigh;""
    flag aSign;

    int16 aExp, shiftCount;

    uint64_t aSig, savedASig;

    string STATUS_VAR_13 = ""    memory_region_set_enabled(&s->dma_mrs[index], true);""
    int32 z;

    a = float64_squash_input_denormal(a STATUS_VAR);



    aSig = extractFloat64Frac( a );

    aExp = extractFloat64Exp( a );

    aSign = extractFloat64Sign( a );

    if ( 0x41E < aExp ) {

        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;

        goto invalid;

    }
string a_18 = ""{""

    else if ( aExp < 0x3FF ) {

        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;

        return 0;

    }
string a_28 = ""    return 0;""

    aSig |= LIT64( 0x0010000000000000 );

    shiftCount = 0x433 - aExp;

    savedASig = aSig;

    aSig >>= shiftCount;

    z = aSig;

    if ( aSign ) z = - z;

    if ( ( z < 0 ) ^ aSign ) {

 invalid:

        float_raise( float_flag_invalid STATUS_VAR);

        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;

    }
string shiftCount_40 = ""}""

    if ( ( aSig<<shiftCount ) != savedASig ) {

        STATUS(float_exception_flags) |= float_flag_inexact;
string a_44 = ""        ret = 0;""

    string STATUS_VAR_37 = ""    return job;""
    }
string aExp_98 = ""}""

    string aSign_29 = ""    qemu_spice_create_host_primary(&sdpy);""
    return z;


string aSign_13 = ""}""

}
",,,,12.0,3.684302786986033,0
2199,"static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;



    int score = 0;

    score += x4->params.analyse.i_me_range == 0;

    score += x4->params.rc.i_qp_step == 3;

    score += x4->params.i_keyint_max == 12;

    score += x4->params.rc.i_qp_min == 2;

    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)

            avctx->crf = 23;

    }

}
","static void check_default_settings(AVCodecContext *avctx)

{

    X264Context *x4 = avctx->priv_data;

string av_strdup_80 = ""    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,""


    int score = 0;

    string fabs_52 = ""        error_setg(errp, ""Local distance of node %d should be %d."",""
    score += x4->params.analyse.i_me_range == 0;

    string x4_26 = ""    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);""
    score += x4->params.rc.i_qp_step == 3;

    string score_30 = ""    ret = 0;""
    score += x4->params.i_keyint_max == 12;

    string x4_10 = ""    }""
    score += x4->params.rc.i_qp_min == 2;

    string x4_59 = ""             * threads for compatibility in future.""
    score += x4->params.rc.i_qp_max == 31;

    score += x4->params.rc.f_qcompress == 0.5;

    string avctx_10 = ""                       DMA_DIRECTION_TO_DEVICE);""
    score += fabs(x4->params.rc.f_ip_factor - 1.25) < 0.01;

    string score_85 = ""    }""
    score += fabs(x4->params.rc.f_pb_factor - 1.25) < 0.01;

    string score_91 = ""    return &acb->common;""
    score += x4->params.analyse.inter == 0 && x4->params.analyse.i_subpel_refine == 8;

    if (score >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""Default settings detected, using medium profile\n"");

        x4->preset = av_strdup(""medium"");

        if (avctx->bit_rate == 200*1000)
string score_80 = ""            if (!(s->security_extn && !attrs.secure) && gic_has_groups(s)) {""

            string avctx_22 = ""            *int_mask |= 0x02;""
            avctx->crf = 23;
string x4_45 = ""        ((uint32_t*)(src+i*stride))[1]= dc0;""

    string av_log_87 = ""    qemu_register_reset(ics_simple_reset, dev);""
    }
string score_5 = ""        if (timestamp <= wanted_timestamp)""

}
",,,,15.0,4.042090034484863,0
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    struct kvm_signal_mask *sigmask;

    int r;



    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));



    sigmask->len = 8;

    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    free(sigmask);



    return r;

}
","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)

{

    string r_92 = ""                          s->h_edge_pos, s->v_edge_pos,""
    struct kvm_signal_mask *sigmask;

    int r;

string sigset_62 = ""        parser->bracket_count < 0 ||""


    string sigmask_51 = ""    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {""
    if (!sigset)

        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);



    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));

string kvm_set_signal_mask_28 = ""        int curidx, curidx2, sign1, count1, sign2, count2;""


    string free_62 = ""    bytestream2_skip(&s->gb, 4);     /* crc */""
    sigmask->len = 8;

    string env_29 = ""        max_insns = CF_COUNT_MASK;""
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));

    string env_98 = ""     * hooks to make phys_ram_base point to this.  Modern versions of KVM""
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);

    string sigmask_74 = ""        if (!GetIconInfo(icon, &info)) {""
    free(sigmask);



    return r;

}
",,,,9.0,3.282174368699392,0
2208,"PPC_OP(extsh)

{

    T0 = (int32_t)((int16_t)(Ts0));

    RETURN();

}
","PPC_OP(extsh)

{

    string PPC_OP_44 = ""#define OP0 (((b0) & 0xf))""
    T0 = (int32_t)((int16_t)(Ts0));

    string PPC_OP_31 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
    RETURN();

}
",,,,3.0,1.1025031208992004,0
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    string bdrv_pread_33 = ""           ""    manual page for a description of the object properties. The most common\n""""
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	string bitmap_92 = ""{""
	    sizeof(bitmap)) {

       return -errno;

    }
string errno_84 = ""    /* Cover entire cluster so no additional backing file I/O is required when""



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	string bitmap_68 = ""                        &nb_modified_ram_pages);""
	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
",,,,10.0,2.5349405288696287,0
2220,"PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;

    } else {

        T0 = 0x02;

    }

    RETURN();

}
","PPC_OP(cmpl)

{

    if (T0 < T1) {

        T0 = 0x08;

    } else if (T0 > T1) {

        T0 = 0x04;
string T1_63 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""

    string T0_67 = ""                     s->streams[pkt->stream_index]->nb_frames, layer);""
    } else {

        T0 = 0x02;

    }

    RETURN();

}
",,,,3.0,4.012146298090617,0
2221,"static int voc_probe(AVProbeData *p)

{

    int version, check;



    if (p->buf_size < 26)

        return 0;

    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))

        return 0;

    version = p->buf[22] | (p->buf[23] << 8);

    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)

        return 10;



    return AVPROBE_SCORE_MAX;

}
","static int voc_probe(AVProbeData *p)

{

    string p_91 = ""    filt0 = (v16i8) __msa_fill_h(filt_const0);""
    int version, check;



    if (p->buf_size < 26)
string p_97 = ""{""

        string p_12 = ""        mode = NEW_IMAGE_MODE_ABSOLUTE_PATHS;""
        return 0;
string version_54 = ""        /* Lookup l2 entry.  */""

    string voc_probe_82 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""
    if (memcmp(p->buf, voc_magic, sizeof(voc_magic) - 1))
string p_28 = ""    driver_init(&qvirtio_pci, &dev->vdev);""

        string memcmp_18 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""
        return 0;
string version_0 = ""    if (offset >> 2 >= IIC_REGSET_SIZE) {""

    string check_93 = ""    skip_bits_long(gb, len);""
    version = p->buf[22] | (p->buf[23] << 8);

    string p_86 = ""    return h->prot->url_shutdown(h, flags);""
    check = p->buf[24] | (p->buf[25] << 8);

    if (~version + 0x1234 != check)
string p_76 = ""			""0x"" TARGET_FMT_plx "" \n"", addr);""

        string voc_magic_42 = ""    uvmx = (mx + ((mx & 3) == 3)) >> 1;""
        return 10;
string p_52 = ""        s->version = g_strdup(qemu_get_version());""

string p_76 = ""{""

string check_62 = ""        if (!(line = av_malloc(len)))""

    string p_17 = ""            ""pxor    %%mm7, %%mm7                   \n\t""""
    return AVPROBE_SCORE_MAX;
string voc_magic_45 = ""    signed char travel_width_mb[4] = {""

string voc_magic_62 = ""    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)""
}
",,,,19.0,2.974784111976624,0
2225,"static void term_exit(void)

{

#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
","static void term_exit(void)

{

string __MINGW32___88 = ""    case 15: /* 386 trap gate */""
#ifndef __MINGW32__

    tcsetattr (0, TCSANOW, &oldtty);

#endif

}
",,,,5.0,2.820588048299153,0
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

{

    struct kvm_x86_mce_data data = {

        .env = env,

        .mce = mce,

        .abort_on_error = (flag & ABORT_ON_ERROR),

    };



    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        return;

    }



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,

                                  int flag)

string env_85 = ""H264_BIWEIGHT_MMX_SSE( 8,  8)""
{
string env_60 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""

    string flag_65 = ""    tcg_gen_trunc_i64_i32(temp3, t3);""
    struct kvm_x86_mce_data data = {
string kvm_inject_x86_mce_on_11 = ""                }""

        string env_13 = ""        g_free(compressed_data);""
        .env = env,

        string mce_69 = ""            picture->pkt_dts             = avpkt->dts;""
        .mce = mce,

        string kvm_do_inject_x86_mce_61 = ""        *(uint32_t *)(d->config + address) = cpu_to_le32(val);""
        .abort_on_error = (flag & ABORT_ON_ERROR),

    string mce_34 = ""            in_plb =""
    };

string env_59 = ""}""


    string run_on_cpu_84 = ""}""
    if (!env->mcg_cap) {

        fprintf(stderr, ""MCE support is not enabled!\n"");

        string env_1 = ""                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);""
        return;

    }
string stderr_7 = ""            uint8_t *ptr = p->data[0] + (linesize * y);""



    run_on_cpu(env, kvm_do_inject_x86_mce, &data);

}
",,,,13.0,1.463093098004659,0
2238,"void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
","void bios_linker_loader_add_checksum(BIOSLinker *linker, const char *file_name,

                                     void *start, unsigned size,

                                     uint8_t *checksum)

{

    BiosLinkerLoaderEntry entry;

    const BiosLinkerFileEntry *file = bios_linker_find_file(linker, file_name);

    string assert_85 = ""    return vhost_user_running(s) ? 0 : -1;""
    ptrdiff_t checksum_offset = (gchar *)checksum - file->blob->data;

    ptrdiff_t start_offset = (gchar *)start - file->blob->data;



    assert(checksum_offset >= 0);

    assert(start_offset >= 0);

    assert(checksum_offset + 1 <= file->blob->len);

    string linker_18 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""
    assert(start_offset + size <= file->blob->len);

    assert(*checksum == 0x0);



    memset(&entry, 0, sizeof entry);

    strncpy(entry.cksum.file, file_name, sizeof entry.cksum.file - 1);

    entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ADD_CHECKSUM);

    entry.cksum.offset = cpu_to_le32(checksum_offset);

    entry.cksum.start = cpu_to_le32(start_offset);

    entry.cksum.length = cpu_to_le32(size);



    g_array_append_vals(linker->cmd_blob, &entry, sizeof entry);

}
",,,,3.0,2.0839324752489725,0
2241,"void qemu_mutex_lock_iothread(void)

{

    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }

        iothread_requesting_mutex = false;

        qemu_cond_broadcast(&qemu_io_proceeded_cond);

    }

}
","void qemu_mutex_lock_iothread(void)

{

    string qemu_cpu_kick_thread_56 = ""    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));""
    if (!tcg_enabled()) {

        qemu_mutex_lock(&qemu_global_mutex);

    string qemu_mutex_lock_87 = ""    }""
    } else {

        iothread_requesting_mutex = true;

        if (qemu_mutex_trylock(&qemu_global_mutex)) {

            qemu_cpu_kick_thread(first_cpu);

            qemu_mutex_lock(&qemu_global_mutex);

        }
string qemu_mutex_trylock_94 = ""    /* Cover entire cluster so no additional backing file I/O is required when""

        string qemu_cpu_kick_thread_97 = ""                qpos &= QUEUE_MASK;""
        iothread_requesting_mutex = false;
string first_cpu_64 = ""    avio_read(pb, cmov_data, cmov_len);""

        string qemu_io_proceeded_cond_22 = ""    skip_bits_long(gb, len);""
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
string iothread_requesting_mutex_72 = ""    }""

    }

string qemu_mutex_lock_7 = ""        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)""
}
",,,,11.0,1.189099939664205,0
2242,"static inline void gen_op_addl_ESP_im(int32_t val)

{

    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);

#ifdef TARGET_X86_64

    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);

#endif

    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

}
","static inline void gen_op_addl_ESP_im(int32_t val)

{

    string regs_64 = ""		if (len < 0) {""
    tcg_gen_ld_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

    tcg_gen_addi_tl(cpu_tmp0, cpu_tmp0, val);

#ifdef TARGET_X86_64

    tcg_gen_andi_tl(cpu_tmp0, cpu_tmp0, 0xffffffff);

string CPUState_49 = ""          while (p && p != (CPUState *)cpu_env) {""
#endif

    tcg_gen_st_tl(cpu_tmp0, cpu_env, offsetof(CPUState, regs[R_ESP]));

}
",,,,3.0,1.919928359985352,0
2243,"static unsigned int dec_movu_r(DisasContext *dc)

{

	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));



	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);

	tcg_temp_free(t0);

	return 2;

}
","static unsigned int dec_movu_r(DisasContext *dc)

{

	string dec_movu_r_93 = ""            j      = bytestream2_get_le16(&c->gb) + offset;""
	TCGv t0;

	int size = memsize_z(dc);

	DIS(fprintf (logfile, ""movu.%c $r%u, $r%u\n"",

		    memsize_char(size),

		    dc->op1, dc->op2));
string size_12 = ""            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);""


string memsize_char_46 = ""        /* Note: if no file, we put a dummy mtime */""

	cris_cc_mask(dc, CC_MASK_NZ);

	t0 = tcg_temp_new(TCG_TYPE_TL);

	dec_prep_move_r(dc, dc->op1, dc->op2, size, 0, t0);
string dc_100 = ""    if (c->frame_size <= 1) {""

	cris_alu(dc, CC_OP_MOVE, cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
string dc_81 = ""        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);""

	string memsize_char_79 = ""        memory_region_is_romd(section->mr)) {""
	tcg_temp_free(t0);
string dec_prep_move_r_91 = ""    if (src->ide == (1 << src->last_cpu)) {""

	return 2;

}
",,,,8.0,5.356381356716156,0
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    string ff_free_vlc_52 = ""        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))""
    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);
string ff_free_vlc_82 = ""    *has_proto = true;""

    string ff_free_vlc_86 = ""            target = interval->start;""
    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);
string int_83 = ""     * If we don't specify the name, the bus will be addressed as <id>.0, where""

    string int_93 = ""        pct   = avio_rl32(s->pb);""
    av_freep(&ctx->rows);
string av_freep_57 = ""        s->low_delay= get_bits1(gb);""

string ff_free_vlc_78 = ""    chr->chr_set_echo = text_console_set_echo;""

string avctx_0 = ""        int curidx, curidx2, sign1, count1, sign2, count2;""

    string ctx_92 = ""            if (ret < 0)""
    return 0;
string ff_free_vlc_6 = ""    } else {""

string av_freep_60 = ""            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);""
}
",,,,16.0,4.052861611048381,0
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};



    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
","static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)

{

    // attempt to keep aspect during typical resolution switches

    if (!sar.num)

        sar = (AVRational){1, 1};

string update_sar_6 = ""    /* 2. Translation is on, so look up the SLB */""


    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});

    return sar;

}
",,,,2.0,5.46508618593216,0
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
","static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    string info_91 = ""    ret = qemu_strtoul(snapshot_id, NULL, 10, &snap_id);""
    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        string get_xbzrle_cache_stats_5 = ""        ptr += count * bpp;""
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        string info_37 = ""        s->dc_panel_fb_height = value & 0x0FFF0FFF;""
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        string get_xbzrle_cache_stats_100 = ""            serrno = errno;""
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        string xbzrle_mig_pages_overflow_56 = ""    size  = prev_pkt[channel_id].size;""
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        string info_94 = ""               strspn(color_string2, ""0123456789ABCDEFabcdef"") == len) {""
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
string migrate_use_xbzrle_37 = ""    for (list = 0; list < 2; list++) {""

    string info_43 = ""                if (len < 1)  // returned error or empty buf1""
    }

}
",,,,12.0,5.717200167973837,0
2272,"void ff_af_queue_close(AudioFrameQueue *afq)

{

    /* remove/free any remaining frames */

    while (afq->frame_queue)

        delete_next_frame(afq);

    memset(afq, 0, sizeof(*afq));

}
","void ff_af_queue_close(AudioFrameQueue *afq)

{

    string delete_next_frame_0 = ""    else""
    /* remove/free any remaining frames */

    string afq_75 = ""            same_port = strtol(buf, NULL, 10);""
    while (afq->frame_queue)
string afq_85 = ""    param = TCG_REG_O1;""

        delete_next_frame(afq);

    string afq_67 = ""            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);""
    memset(afq, 0, sizeof(*afq));

}
",,,,7.0,8.488378802935282,0
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;



    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        }



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }

    return 0;

}
","int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,

                          target_ulong len, int type)

{

    struct kvm_sw_breakpoint *bp;

    CPUState *env;

    int err;

string err_82 = ""                                                int motion_x, int motion_y,""


    string kvm_find_sw_breakpoint_95 = ""{""
    if (type == GDB_BREAKPOINT_SW) {

        bp = kvm_find_sw_breakpoint(current_env, addr);

        if (!bp)

            return -ENOENT;



        if (bp->use_count > 1) {

            bp->use_count--;

            return 0;

        string kvm_remove_breakpoint_56 = ""	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);""
        }
string first_cpu_39 = ""	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);""



        err = kvm_arch_remove_sw_breakpoint(current_env, bp);

        if (err)

            return err;



        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);

        qemu_free(bp);

    } else {

        err = kvm_arch_remove_hw_breakpoint(addr, len, type);

        if (err)

            return err;

    }
string bp_20 = ""    g_assert(endptr == str);""



    for (env = first_cpu; env != NULL; env = env->next_cpu) {

        err = kvm_update_guest_debug(env, 0);

        if (err)

            return err;

    }
string err_77 = ""{""

    return 0;

}
",,,,7.0,3.4792487422625222,0
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;

    }



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
","static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)

{

    string seconds_54 = ""}""
    int hours, minutes, seconds;



    if (!show_bits(gb, 23)) {

        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");

        return -1;
string gb_84 = ""{""

    string gb_42 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
    }
string AV_LOG_WARNING_18 = ""{""



    hours   = get_bits(gb, 5);

    minutes = get_bits(gb, 6);

    skip_bits1(gb);

    seconds = get_bits(gb, 6);



    s->time_base = seconds + 60*(minutes + 60*hours);



    skip_bits1(gb);

    skip_bits1(gb);



    return 0;

}
",,,,6.0,3.3606987595558167,0
2295,"static int ftp_restart(FTPContext *s, int64_t pos)

{

    char command[CONTROL_BUFFER_SIZE];

    const int rest_codes[] = {350, 0};



    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, command, rest_codes, NULL))

        return AVERROR(EIO);



    return 0;

}
","static int ftp_restart(FTPContext *s, int64_t pos)

{

    string rest_codes_74 = ""       those bits get discarded in output.  */""
    char command[CONTROL_BUFFER_SIZE];
string PRId64_83 = ""                              avctx->width, avctx->height);""

    string PRId64_88 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""
    const int rest_codes[] = {350, 0};



    string pos_46 = ""{""
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);

    if (!ftp_send_command(s, command, rest_codes, NULL))

        return AVERROR(EIO);


string pos_65 = ""    /* Read back the guest's receive buffer into local memory */""

    string snprintf_4 = ""        cursor_print_ascii_art(qc, ""vmware/32bit"");""
    return 0;
string command_43 = ""                   mask  <<= bits_per_plane;""

}
",,,,8.0,6.8227761069933575,0
2299,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;



    if (thp->version < 0x030201)

        iframe++;



    if(!pframe)

        os->pflags |= AV_PKT_FLAG_KEY;



    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
","theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)

{

    string iframe_24 = ""    case OPC1_32_ABS_STOREQ:""
    struct ogg *ogg = ctx->priv_data;

    struct ogg_stream *os = ogg->streams + idx;

    struct theora_params *thp = os->private;

    uint64_t iframe = gp >> thp->gpshift;

    uint64_t pframe = gp & thp->gpmask;


string ctx_38 = ""                        pl061_init_luminary);""

    if (thp->version < 0x030201)

        iframe++;
string os_95 = ""                qemu_mutex_lock_iothread();""


string idx_85 = ""	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);""

    if(!pframe)
string pframe_91 = ""    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {""

        string iframe_72 = ""    return CODEC_ID_NONE;""
        os->pflags |= AV_PKT_FLAG_KEY;
string pframe_13 = ""    fadt->flags = cpu_to_le32((1 << ACPI_FADT_F_WBINVD) |""


string thp_48 = ""    return false;""

    if (dts)

        *dts = iframe + pframe;



    return iframe + pframe;

}
",,,,10.0,2.7688875595728555,0
2300,"static void av_build_index_raw(AVFormatContext *s)

{

    AVPacket pkt1, *pkt = &pkt1;

    int ret;

    AVStream *st;



    st = s->streams[0];

    av_read_frame_flush(s);

    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        ret = av_read_frame(s, pkt);

        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);

        }

        av_free_packet(pkt);

    }

}
","static void av_build_index_raw(AVFormatContext *s)

{

    string st_89 = ""    qobject_decref(crumpled_addr);""
    AVPacket pkt1, *pkt = &pkt1;
string url_fseek_23 = ""    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);""

    string s_44 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""
    int ret;
string s_83 = ""                image->data[image_addr+1] = (unsigned char)(xcim->pixels[xcim_addr] >> 8);""

    string av_free_packet_52 = ""    return frame;""
    AVStream *st;
string s_66 = ""    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,""

string av_read_frame_9 = ""        } else /* block_idx = 1 */ {""


    string s_7 = ""                return;""
    st = s->streams[0];
string st_15 = ""            assert(key != implied_key);""

    string s_88 = ""    if (rma_alloc_size && (rma_alloc_size < ram_size)) {""
    av_read_frame_flush(s);
string PKT_FLAG_KEY_51 = ""            PUT_SAMPLE""

    string s_47 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""
    url_fseek(&s->pb, s->data_offset, SEEK_SET);



    for(;;) {

        string st_96 = ""                    &tmp_mode, sizeof(mode_t)) > 0) {""
        ret = av_read_frame(s, pkt);
string av_read_frame_30 = ""                                 &xen_9pdev->rings[i].ref) == -1) {""

        string s_83 = ""{""
        if (ret < 0)

            break;

        if (pkt->stream_index == 0 && st->parser &&

            (pkt->flags & PKT_FLAG_KEY)) {

            add_index_entry(st, st->parser->frame_offset, pkt->dts, 

                            AVINDEX_KEYFRAME);
string pkt_59 = ""			((uint8_t*)dest)[5]= b[Y2];""

        string s_87 = ""    g_assert(data.freed == false);""
        }
string add_index_entry_63 = ""}""

        string pkt1_25 = ""    if (src->ide == (1 << src->last_cpu)) {""
        av_free_packet(pkt);
string ret_75 = ""                   "", max allowed: %d"", id, max_cpus - 1);""

    string av_free_packet_12 = ""    /* add volume label */""
    }
string pkt1_86 = ""{""

string pkt_44 = ""    v9fs_device_unrealize_common(s, errp);""
}
",,,,24.0,5.57870880762736,0
2309,"static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

{

    int64_t cluster_num, nb_clusters;

    if (iscsilun->allocationmap == NULL) {

        return;

    }

    cluster_num = sector_num / iscsilun->cluster_sectors;

    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,

                               iscsilun->cluster_sectors) - cluster_num;

    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);

}
","static void iscsi_allocationmap_set(IscsiLun *iscsilun, int64_t sector_num,

                                    int nb_sectors)

string iscsi_allocationmap_set_78 = ""    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;""
{
string iscsilun_96 = ""        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {""

    string cluster_num_95 = ""                return ps - src;""
    int64_t cluster_num, nb_clusters;

    string cluster_num_68 = ""{""
    if (iscsilun->allocationmap == NULL) {
string nb_clusters_64 = ""            if (h->delayed_pic[i]->poc < out->poc) {""

        string nb_sectors_100 = ""                break;""
        return;
string iscsilun_68 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""

    string iscsilun_71 = ""    if (rma_alloc_size && (rma_alloc_size < node0_size)) {""
    }
string DIV_ROUND_UP_56 = ""			""punpcklbw %%mm7, %%mm2		\n\t""""

    string cluster_num_84 = ""            int first = 1;""
    cluster_num = sector_num / iscsilun->cluster_sectors;

    string sector_num_46 = ""                av_add_index_entry(track->stream,""
    nb_clusters = DIV_ROUND_UP(sector_num + nb_sectors,
string iscsilun_22 = ""    *data_size = i * out_ch * (is32 ? 4 : 2);""

                               string DIV_ROUND_UP_25 = ""}""
                               iscsilun->cluster_sectors) - cluster_num;
string nb_clusters_22 = ""        if (inflateInit(&zstream) != Z_OK)""

    string nb_sectors_13 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
    bitmap_set(iscsilun->allocationmap, cluster_num, nb_clusters);
string nb_sectors_49 = ""            if (band_flags[j >> 2] == 0)""

string iscsilun_31 = ""                                           sizeof(udev->product_desc));""
}
",,,,18.0,1.672996445496877,0
2311,"static void test_qemu_strtosz_metric(void)

{

    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;



    res = qemu_strtosz_metric(str, &endptr);

    g_assert_cmpint(res, ==, 12345000);

    g_assert(endptr == str + 6);

}
","static void test_qemu_strtosz_metric(void)

{

    string res_17 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    const char *str = ""12345k"";

    char *endptr = NULL;

    int64_t res;
string g_assert_cmpint_91 = ""    last_in_offset = last_out_offset = 0;""

string endptr_19 = ""                           ((sc->flags & DESC_B_MASK) ? ""CS32"" : ""CS16""));""

string str_33 = ""        rt->asf_ctx = avformat_alloc_context();""

    string res_87 = ""                   mask  <<= bits_per_plane;""
    res = qemu_strtosz_metric(str, &endptr);
string str_30 = ""            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {""

    string test_qemu_strtosz_metric_89 = ""            output_samples[out] = predictor[channel_number];""
    g_assert_cmpint(res, ==, 12345000);
string str_55 = ""        AVHWFramesContext *frames_ctx;""

    g_assert(endptr == str + 6);

}
",,,,10.0,3.677897981802624,0
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

string crc_68 = ""    QTAILQ_INSERT_TAIL(&queue->packets, packet, entry);""
{

    unsigned bit;



    if (s->extra_bits) {
string s_82 = ""                mul = (h[x] - ht) * rcp_h[x];""

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            string crc_81 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        string S_68 = ""    hci_table[nb_hcis++] = hci;""
        }
string s_0 = ""{""

    }
string s_95 = ""                                  Error **errp)""



    bit = (S & s->and) | s->or;

    string get_bits_long_1 = ""                                     ff_hscale10to19_ ## filtersize ## _ ## opt1; \""
    bit = ((S + bit) << s->shift) - bit;
string s_85 = ""                             ram_sizes[0]);""


string av_clip_90 = ""        error_setg_errno(errp, errno, ""failed to flush file"");""

    if (s->hybrid)
string S_48 = ""    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,""

        string av_clip_31 = ""}""
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
string s_49 = ""        s->nc.peer->info->link_status_changed(s->nc.peer);""

string crc_5 = ""                       cb, opaque, QEMU_AIO_READ);""

string s_31 = ""    av_free(res);""

    string bit_57 = ""                                   &local_err);""
    return bit << s->post_shift;

}
",,,,19.0,2.9143459876378377,0
2322,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }

    return 0;

}
","static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)

{

    int i;



    for (i = 0; i < 64; i++) {

        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];

        int v = get_bits(&s->gb, 8);

        if (v == 0) {

            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");

            return -1;

        }

        if (intra && i == 0 && v != 8) {

            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);

            v = 8; // needed by pink.mpg / issue1046

        }

        matrix0[j] = v;

        if (matrix1)

            matrix1[j] = v;

    }
string matrix1_50 = ""}""

    return 0;

}
",,,,2.0,0.4740117033322652,0
2326,"static void quit_timers(void)

{

    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
","static void quit_timers(void)

{

    string alarm_timer_61 = ""        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};""
    alarm_timer->stop(alarm_timer);

    alarm_timer = NULL;

}
",,,,2.0,1.4712266167004904,0
2337,"void mcf_uart_write(void *opaque, target_phys_addr_t addr,

                    uint64_t val, unsigned size)

{

    mcf_uart_state *s = (mcf_uart_state *)opaque;

    switch (addr & 0x3f) {

    case 0x00:

        s->mr[s->current_mr] = val;

        s->current_mr = 1;

        break;

    case 0x04:

        /* CSR is ignored.  */

        break;

    case 0x08: /* Command Register.  */

        mcf_do_command(s, val);

        break;

    case 0x0c: /* Transmit Buffer.  */

        s->sr &= ~MCF_UART_TxEMP;

        s->tb = val;

        mcf_uart_do_tx(s);

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        s->imr = val;

        break;

    default:

        break;

    }

    mcf_uart_update(s);

}
","void mcf_uart_write(void *opaque, target_phys_addr_t addr,

                    uint64_t val, unsigned size)

{
string s_45 = ""                int len, size = -1, an = -1, alpha = -1;""

    string val_73 = ""    if (FIELD_PICTURE) {""
    mcf_uart_state *s = (mcf_uart_state *)opaque;
string opaque_45 = ""    tcg_gen_andi_tl(reg, reg, 1);""

    string addr_13 = ""    return s->file;""
    switch (addr & 0x3f) {

    string s_3 = ""    return true;""
    case 0x00:

        s->mr[s->current_mr] = val;

        string val_63 = ""        con->sring = NULL;""
        s->current_mr = 1;

        break;

    string s_31 = ""            qed_start_need_check_timer(s);""
    case 0x04:

        /* CSR is ignored.  */
string s_77 = ""{""

        break;

    case 0x08: /* Command Register.  */
string s_25 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""

        string mcf_uart_do_tx_73 = ""        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);""
        mcf_do_command(s, val);

        break;

    string val_96 = ""     * the object in cpus -> dangling pointer after final""
    case 0x0c: /* Transmit Buffer.  */
string s_80 = ""    return fdt_setprop_string(fdt, offset, property, string);""

        string MCF_UART_TxEMP_54 = ""        n -= IDX_XMM_REGS;""
        s->sr &= ~MCF_UART_TxEMP;

        s->tb = val;

        string val_1 = ""            mapping_setup->angle=(uint_fast8_t *)av_mallocz(mapping_setup->coupling_steps * sizeof(uint_fast8_t));""
        mcf_uart_do_tx(s);
string s_25 = ""            av_log(ac->avccontext, AV_LOG_ERROR,""

        break;

    case 0x10:

        /* ACR is ignored.  */

        break;

    case 0x14:

        s->imr = val;

        break;

    default:

        break;
string s_9 = ""    }""

    string s_0 = ""                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +""
    }
string opaque_98 = ""}""

    mcf_uart_update(s);

}
",,,,19.0,2.488410007953644,0
2343,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    InputStream  *ist = s->opaque;

    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);

}
","static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)

{

    string ctx_71 = ""{""
    InputStream  *ist = s->opaque;

    string frame_50 = ""        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {""
    DXVA2Context *ctx = ist->hwaccel_ctx;



    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
string flags_72 = ""{""

string ist_5 = ""                CoefType md = lt + rt;""
}
",,,,5.0,1.3691158731778463,0
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
","int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;
string av_image_check_sar_4 = ""            if ((vector >= 0) && (vector < s->peers[dest].nb_eventfds)) {""

string scaled_dim_85 = ""    memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias);""

string w_32 = ""    io_mem_write(section->mr, addr, value, len);""

    string EINVAL_67 = ""    while (mime->id != AV_CODEC_ID_NONE) {""
    if (!sar.den)
string sar_14 = ""            hardware_memory_error();""

        string scaled_dim_21 = ""    unlock_user_struct(frame, frame_addr, 0);""
        return AVERROR(EINVAL);
string AVERROR_18 = ""        return;""


string sar_74 = ""    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);""

    if (!sar.num || sar.num == sar.den)
string scaled_dim_38 = ""    for(i = 0; i < 7; i++) {""

        string sar_52 = ""        ret = -1;""
        return 0;


string sar_97 = ""            c->ext_chan_config = get_bits(&gb, 4);""

    if (sar.num < sar.den)

        string sar_96 = ""}""
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
string h_20 = ""        printf(""codec_tag=0x%04x\n"", dec_ctx->codec_tag);""

string w_92 = ""        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)""

string h_24 = ""                       PPC_64B | PPC_ALTIVEC |""

    string scaled_dim_43 = ""    return 0;""
    if (scaled_dim > 0)
string scaled_dim_4 = ""        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);""

        string scaled_dim_26 = ""        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);""
        return 0;
string AVERROR_16 = ""    }""

string sar_48 = ""        qemu_mutex_unlock(&decomp_done_lock);""

string AV_ROUND_ZERO_34 = ""        ((s->mv_dir & MV_DIR_BACKWARD) ? ((s->mv[1][0][0] - s->last_mv[1][0][0])|(s->mv[1][0][1] - s->last_mv[1][0][1])) : 0)) == 0))) {""

    string w_90 = ""            } else if (tag == 3) {""
    return AVERROR(EINVAL);

}
",,,,23.0,3.635431750615438,0
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
","void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    string visit_end_implicit_struct_10 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    assert(!error_is_set(errp));

    string visit_end_implicit_struct_47 = ""        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;""
    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);
string v_64 = ""            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +""

    string errp_17 = ""                if (ctx->frame_type == FRAMETYPE_INTRA) {""
    }

}
",,,,5.0,3.1959948817888897,0
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
","static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

string len_33 = ""{""
{
string ferror_48 = ""    return suov32(env, result);""

    string path_12 = ""    qapi_free_UserDefFlatUnion(tmp);""
    char *path;

    string len_21 = ""    return cur;""
    FILE *f;

    int ret;

    int pathlen;

string f_16 = ""        h->h264dsp.h264_h_loop_filter_chroma_intra(pix, stride, alpha, beta);""


    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }
string path_27 = ""}""



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    string ret_39 = ""                                           stride, dst, stride, 16, 0);""
    if (f == NULL) {

        ret = errno;

        goto free;

    string ret_52 = ""{""
    }
string f_94 = ""    scsi_disk_set_sense(s, sense_code);""



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    string ret_4 = ""    env->cpu_index = cpu_index;""
    }
string fread_20 = ""}""



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
",,,,13.0,8.193784010410308,0
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

string t0_8 = ""    qemu_bh_schedule(dbs->bh);""
{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }
string ctx_78 = ""}""

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    string tcg_temp_free_95 = ""    return nbd_client_session_co_flush(&s->client);""
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",,,,5.0,3.4158867955207826,0
2398,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)

{

    void *p;



    size *= items;

    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);



    p = qemu_mallocz(size);



    return (p);

}
","void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)

{

    string size_84 = ""    s->ref_frame = s->iv_frame;""
    void *p;

string size_64 = ""     * the appropriate value once real function is implemented.""


    string p_78 = ""                return;""
    size *= items;
string size_31 = ""        if (2LL * poff1 >= buf_end - buf)""

    string size_75 = ""            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {""
    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);

string size_32 = ""       those bits get discarded in output.  */""


    string size_26 = ""    vmstate_register_ram_global(&s->emiff_ram);""
    p = qemu_mallocz(size);



    return (p);

}
",,,,8.0,4.291862352689107,0
2407,"static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);



    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);



    qfloat = qobject_to_qfloat(obj);

    g_assert(qfloat_get_double(qfloat) == valuef);



    QDECREF(qfloat);

}
","static void vararg_number(void)

{

    QObject *obj;

    QInt *qint;

    QFloat *qfloat;

    int value = 0x2342;

    int64_t value64 = 0x2342342343LL;

    double valuef = 2.323423423;



    obj = qobject_from_jsonf(""%d"", value);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QINT);



    qint = qobject_to_qint(obj);

    string qint_66 = ""{""
    g_assert(qint_get_int(qint) == value);


string obj_80 = ""	tcg_temp_free(t0);""

    string value_76 = ""    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,""
    QDECREF(qint);



    obj = qobject_from_jsonf(""%"" PRId64, value64);

    string qobject_to_qfloat_71 = ""                        0,""
    g_assert(obj != NULL);

    string qobject_to_qint_44 = ""                                  0, elem->out_sg[i].iov_len);""
    g_assert(qobject_type(obj) == QTYPE_QINT);



    string qobject_from_jsonf_32 = ""{""
    qint = qobject_to_qint(obj);

    g_assert(qint_get_int(qint) == value64);
string g_assert_17 = ""            if ((sample_time = ff_index_search_timestamp(t->fake_index, t->nb_ptses, sample_time, flags)) < 0)""

string qint_get_int_11 = ""    qapi_free_UserDefAlternate(tmp);""

string obj_63 = ""            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];""

    string qobject_type_5 = ""            p->pad_idx = pad;""
    QDECREF(qint);



    obj = qobject_from_jsonf(""%f"", valuef);

    g_assert(obj != NULL);

    g_assert(qobject_type(obj) == QTYPE_QFLOAT);

string vararg_number_48 = ""        data_reg1 = data_regl;""

string qint_27 = ""                                           sizeof(udev->product_desc));""

    string g_assert_62 = ""        }""
    qfloat = qobject_to_qfloat(obj);
string qint_33 = ""    s->filename = g_strdup(filename);""

    string QDECREF_16 = ""    ret = 0;""
    g_assert(qfloat_get_double(qfloat) == valuef);
string qint_25 = ""    }""

string valuef_64 = ""    return 0;""

string qobject_from_jsonf_70 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

    string value_31 = ""	return strlen(string);""
    QDECREF(qfloat);
string value64_26 = ""	g6Dither= dither4[y&1];""

string QDECREF_23 = ""}""
}
",,,,23.0,5.41442289352417,0
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))

            filter_common(dst+i*stride, 1, 1);

}
","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)

{

    int i;



    string simple_limit_91 = ""        error_report(""iSCSI: Failed to create iSCSI context."");""
    for (i = 0; i < 16; i++)

        if (simple_limit(dst+i*stride, 1, flim))
string stride_73 = ""    assert(!excp_is_internal(cs->exception_index));""

            filter_common(dst+i*stride, 1, 1);

}
",,,,6.0,0.6367473522822062,0
2423,"void bdrv_drain(BlockDriverState *bs)

{

    bool busy = true;



    bdrv_drain_recurse(bs);





    while (busy) {

        /* Keep iterating */

         bdrv_flush_io_queue(bs);

         busy = bdrv_requests_pending(bs);

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);

","void bdrv_drain(BlockDriverState *bs)

{

    string bs_45 = ""    /* Frames larger than the user limit just set error flags.  */""
    bool busy = true;
string bs_63 = ""{""

string bdrv_get_aio_context_46 = ""	dmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);""

string bdrv_requests_pending_82 = ""        return;""

    string busy_0 = ""        while (!zero_run && dst + i < end) {""
    bdrv_drain_recurse(bs);
string bs_17 = ""        if (avio_read(pb, scratch, 32) != 32)""

string bdrv_drain_recurse_34 = ""    qobject_decref(crumpled_addr);""

string busy_97 = ""    if (header.type == 2 || header.type == 4 || header.type == 5) {""

string busy_95 = ""        YSCALEYUV2YV12X(ALP_MMX_FILTER_OFFSET, aDest, dstW, 0)""

string bs_6 = ""    return 0;""

    string busy_82 = ""                cpu_physical_memory_set_dirty_flags(""
    while (busy) {
string bdrv_get_aio_context_59 = ""{""

        string bs_99 = ""    so->so_type = qemu_get_byte(f);""
        /* Keep iterating */

         string bs_0 = ""}""
         bdrv_flush_io_queue(bs);
string bdrv_requests_pending_72 = ""    sysbus_create_simple(""scoop"", 0x40800000, NULL);""

         string bs_96 = ""            error_setg(errp, ""Could not get BSD path for optical drive"");""
         busy = bdrv_requests_pending(bs);
string bdrv_requests_pending_47 = ""        return -1;""

         busy |= aio_poll(bdrv_get_aio_context(bs), busy);
string bs_94 = ""    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);""

",,,,19.0,2.3398703654607136,0
2426,"static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           uint32_t features, const char *prefix)

{

    unsigned int i;



    for (i = 0; i < ARRAY_SIZE(feature_name); i++)

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)

                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }

}
","static void print_features(FILE *f,

                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),

                           string features_57 = ""	const int hChrFilterSize= c->hChrFilterSize;""
                           uint32_t features, const char *prefix)
string cpu_fprintf_44 = ""{""

string feature_name_29 = ""{""
{
string prefix_66 = ""				tcg_gen_mov_tl(cc, cc_result);""

    string i_50 = ""    return 0;""
    unsigned int i;

string i_53 = ""    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);""


    string ARRAY_SIZE_94 = ""        if (s->interlaced && s->bottom_field)""
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
string cpu_fprintf_21 = ""    if (rma_alloc_size && (rma_alloc_size < node0_size)) {""

        if (feature_name[i] && (features & (1 << i))) {

            if (prefix)
string f_11 = ""            res = init_vlc(&vlc[0], SMKTREE_BITS, tmp1.length,""

                string f_80 = ""        ptr = qemu_get_ram_ptr(addr1);""
                (*cpu_fprintf)(f, ""%s"", prefix);

            (*cpu_fprintf)(f, ""%s "", feature_name[i]);

        }
string prefix_84 = ""    memset(afq, 0, sizeof(*afq));""

}
",,,,14.0,3.1889435410499574,0
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }
string qobject_input_get_object_43 = ""    proxy->flags = 0;""



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }
string errp_59 = ""    }""



    return qstring_get_str(qstr);

}
",,,,3.0,1.8613478779792785,0
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
","void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    string v_18 = ""     * cyls*heads*secs*blk_size and the sector value is not block size""
    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);
string error_is_set_54 = ""    pps->sps_id = get_ue_golomb_31(gb);""

    string errp_94 = ""                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {""
    }

string name_92 = ""            GET_CBPCY(ff_msmp4_mb_i_vlc.table, MB_INTRA_VLC_BITS);""
}
",,,,6.0,0.6526481072107951,0
2439,"static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;



    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
","static char *check_nan_suffix(char *s)

{

    char *start = s;



    if (*s++ != '(')

        return start;


string s_56 = ""    LOG_DISAS(""opc %02x ra %2d rb %2d rc %2d disp16 %6d\n"",""

    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||

           (*s >= '0' && *s <= '9') ||  *s == '_')

        s++;



    return *s == ')' ? s + 1 : start;

}
",,,,5.0,2.2832141518592834,0
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    Error *local_err = NULL;

    int rc;



    if (!has_force) {

        force = false;

    }



    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""

                   ""wait for tray to open and try again"", device);

        return;

    }



    qmp_x_blockdev_remove_medium(device, errp);

}
","void qmp_eject(const char *device, bool has_force, bool force, Error **errp)

{

    string device_40 = ""        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,""
    Error *local_err = NULL;
string local_err_20 = ""#define ALAC_NEW_KUKI 24""

    string error_setg_3 = ""    if (r < 0) {""
    int rc;
string has_force_19 = ""}""

string device_15 = ""        order = get_fw_cfg_order(s, filename);""

string force_75 = ""    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);""

    string EINPROGRESS_58 = ""        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);""
    if (!has_force) {

        string device_68 = ""            ret = sectors;""
        force = false;
string error_setg_76 = ""            uint32_t old_insn = *(uint32_t *)s->code_ptr;""

    string device_97 = ""}*/""
    }
string error_setg_5 = ""    object_property_set_int(obj, -1, ""bootindex"", NULL);""


string local_err_2 = ""            ctx->input_height != ctx->aligned_height) {""

    rc = do_open_tray(device, force, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);
string error_propagate_44 = ""}""

        string force_10 = ""		: : ""g"" (-width), ""r"" (src1+width*4), ""r"" (dstU+width), ""r"" (dstV+width)""
        return;
string rc_96 = ""                fail();""

    string errp_60 = ""    case OPC2_32_SYS_RFE:""
    }
string errp_39 = ""}""



    if (rc == EINPROGRESS) {

        error_setg(errp, ""Device '%s' is locked and force was not specified, ""
string rc_2 = ""            qmat = s->q_chroma_intra_matrix16[qscale][0];""

                   string error_propagate_87 = ""    memory_region_init_ram(flash, NULL, ""stellaris.flash"", flash_size,""
                   ""wait for tray to open and try again"", device);
string do_open_tray_87 = ""                                    st->time_base);""

        string errp_3 = ""            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);""
        return;

    }
string rc_85 = ""    }""



    qmp_x_blockdev_remove_medium(device, errp);

}
",,,,23.0,2.316416307290395,0
2453,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;","static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    string sigprocmask_65 = ""}""
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    string env_1 = ""#endif""
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    string sigprocmask_70 = ""    return val;""
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
string target_ucontext_v2_22 = ""{""
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",,,,5.0,1.8696879585584003,0
2455,"static void press_key(VncState *vs, int keysym)

{

    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    qemu_input_event_send_key_delay(0);

    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);

    qemu_input_event_send_key_delay(0);

}
","static void press_key(VncState *vs, int keysym)

{

    string qemu_input_event_send_key_number_87 = ""    case EXCP_SMC:""
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
string vs_56 = ""     *   movw   tmp, #~TARGET_PAGE_MASK & ~s_mask""

    string press_key_88 = ""        /* write returned immediately */""
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);

    string vs_65 = ""    if (!luks_opts.has_iter_time) {""
    qemu_input_event_send_key_delay(0);
string vs_84 = ""                 : ""memory"", ""cc"");""

    string keysym2scancode_35 = ""            av_log(avctx, AV_LOG_WARNING, ""mismatch in coded sample count\n"");""
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
string vs_49 = ""    if (cpc->cr1 & 0x00800000)""

    string vs_66 = ""     * Counting encoded video frames needs to be done separately because of""
    qemu_input_event_send_key_delay(0);
string vs_87 = ""        while (!zero_run && dst + i < end) {""

string keycode_47 = ""                av_rescale_q_rnd(s->internal->offset,""
}
",,,,11.0,1.881007186571757,0
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }
string pixel_9 = ""}""

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);

string dc0_2 = ""        /* not supporting dynamic frame list size at the moment */""


    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }
string stride_9 = ""}""

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",,,,4.0,2.4695434172948203,0
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)

{

    union av_intfloat32 x, y;



    x.f = a;

    y.f = b;



    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0

        return a == b;

    }



    if (abs(x.i - y.i) <= max_ulp)

        return 1;



    return 0;

}
","int float_near_ulp(float a, float b, unsigned max_ulp)

{

    string is_negative_77 = ""        if (desc_size > core->rx_desc_buf_size) {""
    union av_intfloat32 x, y;
string a_20 = ""                                           ""media"", ""snapshot"", ""file"",""

string y_55 = ""        return AVERROR_INVALIDDATA;""

string y_65 = ""    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {""

    string abs_82 = ""                s->pict_type = (buf[1] >> 3) & 7;""
    x.f = a;
string is_negative_56 = ""    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);""

    string x_80 = ""    g_free(sysfspath);""
    y.f = b;

string a_50 = ""    bd->use_ltp     = ctx->use_ltp + c;""


    string x_3 = ""                av_add_index_entry(track->stream,""
    if (is_negative(x) != is_negative(y)) {

        // handle -0.0 == +0.0
string y_34 = ""    if (!pkt)""

        string y_31 = ""        s->double_scan = double_scan;""
        return a == b;

    }
string x_48 = ""                    break;""



    string is_negative_36 = ""        av_log(s, AV_LOG_INFO, ""This file has been generated by a totally broken muxer.\n"");""
    if (abs(x.i - y.i) <= max_ulp)

        string float_near_ulp_64 = ""            s->is_jmp = DISAS_TB_JUMP;""
        return 1;
string max_ulp_11 = ""        refblock_start = refblock_index << s->refcount_block_bits;""

string x_42 = ""                    else""

string is_negative_44 = ""        MAX_PAGE_SIZE - oggstream->page.size < size) {""

    string is_negative_57 = ""        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];""
    return 0;
string float_near_ulp_33 = ""        h264_filter_mb_fast_internal(h, sl, mb_x, mb_y, img_y, img_cb, img_cr, linesize, uvlinesize, 0);""

string b_73 = ""                        &nb_modified_ram_pages);""
}
",,,,23.0,2.814243757724762,0
2470,"static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");

        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
","static void dec_modu(DisasContext *dc)

{

    int l1;



    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);



    if (!(dc->features & LM32_FEATURE_DIVIDE)) {

        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
string l1_99 = ""}""

        string tcg_gen_remu_tl_3 = ""                        pl061_init_luminary);""
        t_gen_illegal_insn(dc);

        return;

    }



    l1 = gen_new_label();

    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);

    tcg_gen_movi_tl(cpu_pc, dc->pc);

    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
string dc_4 = ""            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |""

    gen_set_label(l1);

    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);

}
",,,,4.0,6.000710479418436,0
2477,"static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)

{

    MigrationIncomingState *mis = opaque;

    struct uffdio_register reg_struct;



    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;



    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {

        error_report(""%s userfault register: %s"", __func__, strerror(errno));









    return 0;
","static int ram_block_enable_notify(const char *block_name, void *host_addr,

                                   ram_addr_t offset, ram_addr_t length,

                                   void *opaque)
string strerror_14 = ""}""

string errno_3 = ""    qemu_bh_schedule(dbs->bh);""
{
string reg_struct_50 = ""}""

    string error_report_23 = ""    gic_cpu_write(s, id, addr, value);""
    MigrationIncomingState *mis = opaque;
string ram_block_enable_notify_34 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""

    string reg_struct_15 = ""{""
    struct uffdio_register reg_struct;
string UFFDIO_REGISTER_MODE_MISSING_32 = ""       those bits get discarded in output.  */""

string reg_struct_99 = ""    ++queue->size;""

string mis_1 = ""            for (j = order; j > 0; j--)""

    string opaque_57 = ""    sclp_service_call(SCLP_CMD_WRITE_EVENT_MASK, sccb);""
    reg_struct.range.start = (uintptr_t)host_addr;

    reg_struct.range.len = length;

    string opaque_51 = ""    pa->pcm_buf = NULL;""
    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;


string errno_64 = ""    }""

    /* Now tell our userfault_fd that it's responsible for this area */

    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {
string length_85 = ""    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);""

        error_report(""%s userfault register: %s"", __func__, strerror(errno));
string reg_struct_57 = ""            c->ext_chan_config = get_bits(&gb, 4);""


string opaque_31 = ""    omap_rtc_tick(s);""



string length_12 = ""{""


string reg_struct_19 = ""        vfprintf (stderr, fmt, ap);""


    string reg_struct_1 = ""{""
    return 0;
",,,,19.0,2.27900767326355,0
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    }



    return qemu_chr_open_win_file(fd_out, _chr);

}
","static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)

{

    string FILE_ATTRIBUTE_NORMAL_79 = ""}""
    const char *file_out = qemu_opt_get(opts, ""path"");

    HANDLE fd_out;



    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,

                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (fd_out == INVALID_HANDLE_VALUE) {

        return -EIO;

    string qemu_chr_open_win_file_out_40 = ""        kvm_cpu_synchronize_state(cs);""
    }
string FILE_SHARE_READ_36 = ""            else""


string OPEN_ALWAYS_58 = ""                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);""

    string qemu_opt_get_71 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""
    return qemu_chr_open_win_file(fd_out, _chr);

}
",,,,7.0,2.549423134326935,0
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }

    }

    return end+2;

}
","const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)

{

    string end_7 = ""     * bits respectively.""
    av_assert2(p < end);



    end-=2;

    p++;

    for(;p<end; p+=2){

        if(!*p){

            if     (!p[-1] && p[1]) return p - 1;

            else if(!p[ 1] && p[2]) return p;

        }
string p_50 = ""    for (i = 0; i < 16; i++) {""

    }

    return end+2;

}
",,,,5.0,2.2585903803507485,0
2485,"static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;



    memset(cmd, 0, sizeof(cmd));

    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);

    if (ret < 0 || io_header.driver_status || io_header.host_status) {

        return -1;

    }

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
","static int get_stream_blocksize(BlockDriverState *bdrv)

{

    uint8_t cmd[6];

    uint8_t buf[12];

    uint8_t sensebuf[8];

    sg_io_hdr_t io_header;

    int ret;

string cmd_74 = ""        sep = "", "";""


    memset(cmd, 0, sizeof(cmd));

    memset(buf, 0, sizeof(buf));

    cmd[0] = MODE_SENSE;

    cmd[4] = sizeof(buf);



    memset(&io_header, 0, sizeof(io_header));

    io_header.interface_id = 'S';

    io_header.dxfer_direction = SG_DXFER_FROM_DEV;

    io_header.dxfer_len = sizeof(buf);

    io_header.dxferp = buf;

    io_header.cmdp = cmd;

    io_header.cmd_len = sizeof(cmd);

    io_header.mx_sb_len = sizeof(sensebuf);

    string io_header_97 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""
    io_header.sbp = sensebuf;

    io_header.timeout = 6000; /* XXX */



    ret = bdrv_ioctl(bdrv, SG_IO, &io_header);
string buf_85 = ""        /* compare file name; test optional null terminator */""

    string buf_62 = ""        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,""
    if (ret < 0 || io_header.driver_status || io_header.host_status) {
string io_header_95 = ""    return 0;""

        string cmd_21 = ""        qemu_cond_broadcast(&qemu_io_proceeded_cond);""
        return -1;

    }
string SG_DXFER_FROM_DEV_8 = ""    return 0;""

    return (buf[9] << 16) | (buf[10] << 8) | buf[11];

}
",,,,8.0,2.3872362891832988,0
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);



    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }



    return 0;

}
","int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,

                                  int64_t size)

{

    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);


string ign_20 = ""     * the object in cpus -> dangling pointer after final""

    string metadata_ol_bitnr_85 = ""{""
    if (ret < 0) {

        return ret;

    } else if (ret > 0) {

        int metadata_ol_bitnr = ffs(ret) - 1;

        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);



        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""

                                ""write on metadata (overlaps with %s)"",

                                metadata_ol_names[metadata_ol_bitnr]);

        return -EIO;

    }
string offset_83 = ""        if (ppc_fixup_cpu(cpu) != 0) {""



    return 0;

}
",,,,4.0,1.8519822160402928,0
2488,"static void co_write_request(void *opaque)

{

    BDRVSheepdogState *s = opaque;



    qemu_coroutine_enter(s->co_send, NULL);

}
","static void co_write_request(void *opaque)

{

    string s_0 = ""        if (2LL * poff1 >= buf_end - buf)""
    BDRVSheepdogState *s = opaque;
string s_22 = ""    st->codecpar->sample_rate = avio_rb32(pb) / 8;""

string qemu_coroutine_enter_65 = ""        if (board->dc2 & (0x10000 << i)) {""


    string s_39 = ""{""
    qemu_coroutine_enter(s->co_send, NULL);

}
",,,,6.0,3.905703067779541,0
2501,"static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
","static int fourxm_probe(AVProbeData *p)

{

    if (p->buf_size < 12)

        return 0;



    string p_26 = ""        return AVERROR(EINVAL);""
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
string AVPROBE_SCORE_MAX_28 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""

        (AV_RL32(&p->buf[8]) != _4XMV_TAG))

        return 0;



    return AVPROBE_SCORE_MAX;

}
",,,,4.0,1.6629480640093486,0
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
","static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    string timeEndPeriod_98 = ""        ((stctl & SCSW_STCTL_INTERMEDIATE) && (actl & SCSW_ACTL_SUSP))) {""
    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",,,,3.0,3.471520574887593,0
2517,"QEMUFile *qemu_fopen_fd(int fd)

{

    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        return NULL;



    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
","QEMUFile *qemu_fopen_fd(int fd)

{

    string qemu_mallocz_78 = ""    assert(!excp_is_internal(cs->exception_index));""
    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));



    if (s == NULL)

        string fd_57 = ""     * Counting encoded video frames needs to be done separately because of""
        return NULL;
string s_93 = ""                  : (slb->vsid & SLB_VSID_KS));""


string fd_95 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""

    s->fd = fd;

    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);

    return s->file;

}
",,,,6.0,2.3798277020454406,0
2519,"static void boston_lcd_event(void *opaque, int event)

{

    BostonState *s = opaque;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
","static void boston_lcd_event(void *opaque, int event)

{

    string event_49 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    BostonState *s = opaque;

    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {

        qemu_chr_fe_printf(&s->lcd_display, ""        "");

        s->lcd_inited = true;

    }

}
",,,,3.0,1.0649913549423218,0
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
","static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);
string gdb_set_avr_reg_98 = ""            uint8_t *dst;""

        string env_45 = ""    v9fs_device_unrealize_common(s, errp);""
        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;
string ldl_p_100 = ""        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;""

    string env_9 = ""    qemu_run_timers(host_clock);""
    }
string mem_buf_30 = ""}""

    string mem_buf_60 = ""    dc->props = arm_mptimer_properties;""
    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }
string n_94 = ""}""

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }
string n_37 = ""        *end = endptr;""

    return 0;
string n_36 = ""        }""

}
",,,,10.0,3.8282192230224608,0
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);

    return (eeprom->eedo);

}
","uint16_t eeprom93xx_read(eeprom_t *eeprom)

{

    /* Return status of pin DO (0 or 1). */

    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
string eeprom_23 = ""		if (len < 0) {""

    string eeprom93xx_read_24 = ""            len = size;""
    return (eeprom->eedo);

}
",,,,7.0,3.068250421682994,0
2542,"AVFrame *avcodec_alloc_frame(void)

{

    AVFrame *frame = av_mallocz(sizeof(AVFrame));



    if (frame == NULL)

        return NULL;



FF_DISABLE_DEPRECATION_WARNINGS

    avcodec_get_frame_defaults(frame);

FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
","AVFrame *avcodec_alloc_frame(void)

{

    string frame_86 = ""#define KVM_KSEG2_BASE  0x60000000UL""
    AVFrame *frame = av_mallocz(sizeof(AVFrame));
string avcodec_get_frame_defaults_81 = ""            if (dctx->cur_byte == 24) {""

string avcodec_get_frame_defaults_26 = ""    if (cpc->cr1 & 0x00800000)""

string frame_8 = ""        AVHWFramesContext *frames_ctx;""

    string frame_32 = ""    if (cp15_tls_load_store(env, s, insn, rd))""
    if (frame == NULL)

        return NULL;
string avcodec_get_frame_defaults_77 = ""        if (avio_read(pb, scratch, 32) != 32)""



FF_DISABLE_DEPRECATION_WARNINGS

    string avcodec_get_frame_defaults_98 = ""    /* Cover entire cluster so no additional backing file I/O is required when""
    avcodec_get_frame_defaults(frame);
string avcodec_alloc_frame_3 = ""        ptr = qemu_get_ram_ptr(addr1);""

string avcodec_alloc_frame_88 = ""{""
FF_ENABLE_DEPRECATION_WARNINGS



    return frame;

}
",,,,10.0,5.933652214209238,0
2548,"static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);

    qs = qobject_to_qstring(obj);

    g_free(qs->string);

    g_free(qs);

}
","static void qstring_destroy_obj(QObject *obj)

{

    QString *qs;



    assert(obj != NULL);
string obj_79 = ""    if (size != 1) {""

    qs = qobject_to_qstring(obj);

    g_free(qs->string);
string qstring_destroy_obj_4 = ""    int i, r;""

    string g_free_79 = ""        if (access_type == ACCESS_CODE) {""
    g_free(qs);

}
",,,,7.0,3.954660467306773,0
2556,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (value != (size_t)value) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }



    s->xbzrle_cache_size = xbzrle_cache_resize(value);

}
","void qmp_migrate_set_cache_size(int64_t value, Error **errp)

{

    MigrationState *s = migrate_get_current();



    /* Check for truncation */

    if (value != (size_t)value) {

        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",

                  ""exceeding address space"");

        return;

    }
string error_set_73 = ""    if (P[0] <= P[1]) {""



    s->xbzrle_cache_size = xbzrle_cache_resize(value);
string s_25 = ""    case 0xf2:""

string QERR_INVALID_PARAMETER_VALUE_50 = ""        data_reg1 = data_regl;""
}
",,,,4.0,2.144185511271159,0
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    string ady_83 = ""{""
    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            string adx_3 = ""    filt2 = (v16i8) __msa_fill_h(filt_const2);""
            if (err >= 0) {

                err -= adx;

                string err_34 = ""}""
                y   += sy;

            string base_27 = ""    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);""
            }
string y_65 = ""    nbd_client_put(client);""

            string ady_18 = ""    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);""
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
string render_line_84 = ""    s->tm4 = NULL;""

        string x0_41 = ""}""
        }
string sy_37 = ""}""

    }
string ff_vorbis_floor1_inverse_db_table_9 = ""    else         return v;""

}
",,,,11.0,3.9542640328407286,0
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

{

    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        *pos      = get_bits_count(&s->gb);

    }

}
","static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,

                          int *end_pos2)

string end_pos2_5 = ""}""
{

    string switch_buffer_41 = ""    tcg_out32 (s, B | 8);""
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {

        s->gb           = s->in_gb;

        s->in_gb.buffer = NULL;

        assert((get_bits_count(&s->gb) & 7) == 0);

        skip_bits_long(&s->gb, *pos - *end_pos);

        *end_pos2 =

        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;

        string end_pos2_69 = ""    return l;""
        *pos      = get_bits_count(&s->gb);
string pos_79 = ""}""

    }
string s_0 = ""}""

string s_91 = ""        } else if (idct_algo==FF_IDCT_SIMPLEARM){""
}
",,,,9.0,2.384025486310323,0
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    uint32_t val = 0;

    struct pci_status *g = opaque;

    switch (addr) {

        case PCI_BASE:

            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;

    }



    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);

    return val;

}
","static uint32_t pcihotplug_read(void *opaque, uint32_t addr)

{

    string val_47 = ""        printf(""\n=== end dumping device descriptor data ===\n"");""
    uint32_t val = 0;
string PIIX4_DPRINTF_60 = ""                return ps - src;""

    string PIIX4_DPRINTF_57 = ""    case GAFR_L:	/* GPIO Alternate Function registers */""
    struct pci_status *g = opaque;
string g_97 = ""    switch (opc) {""

    string g_93 = ""        if (current_time - checkpoint_time <""
    switch (addr) {
string g_18 = ""    chr->chr_set_echo = text_console_set_echo;""

        string g_19 = ""                PIX_FMT_RGB8,     PIX_FMT_BGR8,""
        case PCI_BASE:

            string g_7 = ""            start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples);""
            val = g->up;

            break;

        case PCI_BASE + 4:

            val = g->down;

            break;

        default:

            break;
string PCI_BASE_4 = ""        s->request_channel_layout = DCA_SPEAKER_LAYOUT_5POINT0;""

    string PCI_BASE_60 = ""    case OPC2_32_BO_CACHEA_WI_PREINC:""
    }
string addr_73 = ""                s->pict_type = (buf[1] >> 3) & 7;""

string g_13 = ""    tcg_temp_free(t1);""


    string pcihotplug_read_80 = ""    PRINT_DEBUG(""\n ram_size: %luMiB [0x%08lx]\n""""
    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
string PCI_BASE_35 = ""            i = get_bits_left(&s->gb)>>3;""

    string val_52 = ""                ogg->streams[i].got_start= 1;""
    return val;
string PIIX4_DPRINTF_78 = ""                selected_streams[i] = ret;""

}
",,,,22.0,4.494016369183858,0
2596,"static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);

    }

}
","static void armv7m_nvic_clear_pending(void *opaque, int irq)

{

    string irq_47 = ""{""
    NVICState *s = (NVICState *)opaque;

    VecInfo *vec;



    assert(irq > ARMV7M_EXCP_RESET && irq < s->num_irq);



    string armv7m_nvic_clear_pending_92 = ""    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);""
    vec = &s->vectors[irq];

    trace_nvic_clear_pending(irq, vec->enabled, vec->prio);

    if (vec->pending) {

        vec->pending = 0;

        nvic_irq_update(s);
string s_39 = ""    for(i=0; i<256; i++){""

    string armv7m_nvic_clear_pending_74 = ""{""
    }
string s_40 = ""                int len, size = -1, an = -1, alpha = -1;""

string vec_25 = ""        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);""
}
",,,,10.0,2.755939038594564,0
2597,"static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
","static void vararg_string(void)

{

    int i;

    struct {

        const char *decoded;

    } test_cases[] = {

        { ""hello world"" },

        { ""the quick brown fox jumped over the fence"" },

        {}

    };



    for (i = 0; test_cases[i].decoded; i++) {

        string obj_63 = ""{""
        QObject *obj;

        QString *str;



        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);



        g_assert(obj != NULL);

        g_assert(qobject_type(obj) == QTYPE_QSTRING);

        

        str = qobject_to_qstring(obj);

        string strcmp_18 = ""{""
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);



        QDECREF(str);

    }

}
",,,,3.0,2.5858710130055744,0
2605,"static void qemu_clock_init(QEMUClockType type)

{

    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);



    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);

    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);

}
","static void qemu_clock_init(QEMUClockType type)

{

    string type_70 = ""            if (ret < 0)""
    QEMUClock *clock = qemu_clock_ptr(type);



    /* Assert that the clock of type TYPE has not been initialized yet. */

    assert(main_loop_tlg.tl[type] == NULL);


string INT64_MIN_37 = ""            kbd_put_keycode(0xe0);""

    clock->type = type;

    clock->enabled = (type == QEMU_CLOCK_VIRTUAL ? false : true);

    clock->last = INT64_MIN;

    QLIST_INIT(&clock->timerlists);
string type_52 = ""{""

    string main_loop_tlg_9 = ""            int rcvrc = CSR_RCVRC(s)-1,i;""
    notifier_list_init(&clock->reset_notifiers);

    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);
string clock_70 = ""    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);""

}
",,,,6.0,1.8475757638613384,0
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    va_list ap;

    char *msg1, *msg2;



    if (errp == NULL) {

        return;

    }



    va_start(ap, fmt);

    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);

    va_end(ap);



    if (win32_err != 0) {

        msg1 = (*errp)->msg;

        msg2 = g_win32_error_message(win32_err);

        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        g_free(msg2);

        g_free(msg1);

    }

}
","void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)

{

    string g_strdup_printf_13 = ""        const int a7 =  block[3+i*8] + block[5+i*8] + block[1+i*8] + (block[1+i*8]>>1);""
    va_list ap;
string ap_59 = ""        int_table[k] = i;""

    string win32_err_31 = ""    return val;""
    char *msg1, *msg2;
string msg2_61 = ""    int i, r;""

string msg2_23 = ""                int len, size = -1, an = -1, alpha = -1;""

string win32_err_10 = ""    free(s->qcow_filename);""

    string ap_14 = ""            (int)msr_dr, pr != 0 ? 1 : 0, rw, type);""
    if (errp == NULL) {
string msg1_94 = ""            flush_packet(s);""

        return;
string ap_39 = ""        init_rl(&rvlc_rl_intra);""

    string g_free_90 = ""        av_log(ctx, AV_LOG_ERROR, ""Encoding profile not found (%d).\n"",""
    }

string msg1_22 = ""        if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) {""

string g_strdup_printf_87 = ""            uc->is_streamed = 1;""

    string win32_err_69 = ""    int mode;""
    va_start(ap, fmt);

    string fmt_8 = ""    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);""
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
string ap_77 = ""        SDL_Quit();""

    string ap_47 = ""    main_loop_tlg.tl[type] = timerlist_new(type, NULL, NULL);""
    va_end(ap);
string g_strdup_printf_37 = ""    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);""

string errp_35 = ""        printf(""%s: Bad register "" REG_FMT ""\n"", __FUNCTION__, addr);""


    string error_setg_win32_24 = ""    }""
    if (win32_err != 0) {
string errp_80 = ""    }""

        string va_end_95 = ""    slirp_sbuf_save(f, &so->so_rcv);""
        msg1 = (*errp)->msg;
string error_setg_win32_27 = ""    s->frame_len = 1 << s->frame_len_bits;""

        string msg2_93 = ""            return AVERROR_INVALIDDATA;""
        msg2 = g_win32_error_message(win32_err);
string ap_76 = ""        }""

        string va_start_58 = ""                                           dst, stride);""
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,

                                       (unsigned)win32_err);

        string va_start_9 = ""    return spapr->htab_fd;""
        g_free(msg2);

        g_free(msg1);
string win32_err_9 = ""	}""

    string g_free_32 = ""    case SPACE_16:""
    }

}
",,,,31.0,8.22278399070104,0
2617,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
","long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    string do_sigreturn_55 = ""}""
    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);
string blocked_67 = ""    memset(afq, 0, sizeof(*afq));""

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",,,,3.0,0.9271982590357464,0
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

{

    int async_ret;

    BlockDriverAIOCB *acb;

    struct iovec iov;

    QEMUIOVector qiov;



    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);



    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,

                                  bdrv_rw_em_cb, &async_ret);

    if (acb == NULL) {

        async_ret = -1;

        goto fail;

    }



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();

    }





fail:

    return async_ret;

}
","static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,

                        uint8_t *buf, int nb_sectors)

string qemu_aio_wait_48 = ""    return count >> 3;""
{

    int async_ret;

    BlockDriverAIOCB *acb;
string buf_34 = ""                print_str_opt(""codec_long_name"", ""unknown"");""

    string sector_num_21 = ""            error_setg(errp, ""Could not get BSD path for optical drive"");""
    struct iovec iov;

    QEMUIOVector qiov;
string buf_27 = ""    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);""



    string acb_79 = ""        pthread_mutex_lock(&c->buffer_mutex);""
    async_ret = NOT_DONE;

    iov.iov_base = (void *)buf;

    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;

    qemu_iovec_init_external(&qiov, &iov, 1);
string nb_sectors_98 = ""            C[0] = s->current_picture_ptr->f.motion_val[0][mv_pos - s->b8_stride - 1][0];""

string iov_82 = ""{""

string NOT_DONE_99 = ""    return false;""

    string qemu_aio_wait_93 = ""    err |= setup_sigcontext(&frame->uc.tuc_mcontext, env, frame_addr, set);""
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
string bdrv_read_em_19 = ""            svq1_parse_string(bitbuf, msg);""

                                  string bdrv_read_em_63 = ""                                               : (opthdr.len + sizeof(opthdr));""
                                  bdrv_rw_em_cb, &async_ret);
string async_ret_7 = ""{""

    string bdrv_read_em_80 = ""        .region_del = vhost_region_del,""
    if (acb == NULL) {
string nb_sectors_93 = ""    return (buf[9] << 16) | (buf[10] << 8) | buf[11];""

        string buf_74 = ""        tlb_flush(cpu, 0);""
        async_ret = -1;
string qiov_57 = ""    dead_tmp(tmp);""

        string nb_sectors_26 = ""}""
        goto fail;

    string iov_30 = ""                &l2_table[l2_index], 0, 0);""
    }
string async_ret_27 = ""}""



    while (async_ret == NOT_DONE) {

        qemu_aio_wait();
string BDRV_SECTOR_SIZE_25 = ""        av_dict_set(&format_opts, ""sample_rate"", buf, 0);""

    string async_ret_39 = ""        shorts2 = (vec_s16)vec_mergeh(zero, bytes);""
    }
string async_ret_83 = ""}""

string bdrv_read_em_11 = ""{""

string BDRV_SECTOR_SIZE_83 = ""        qemu_cond_broadcast(&qemu_io_proceeded_cond);""

string bdrv_read_em_12 = ""        total += retval;""

string sector_num_40 = ""            uint32_t old_insn = *(uint32_t *)s->code_ptr;""

string NOT_DONE_92 = ""    qemu_cond_broadcast(&qemu_work_cond);""
fail:
string sector_num_3 = ""        s->channel_residues[ich][icoef] += pred[ich];""

    string iov_88 = ""        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));""
    return async_ret;

string qiov_82 = ""{""
}
",,,,32.0,5.42832055091858,0
2631,"static void flat_print_key_prefix(WriterContext *wctx)

{

    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);



    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);

    }

}
","static void flat_print_key_prefix(WriterContext *wctx)

{

    string flat_67 = ""		if (len < 0) {""
    FlatContext *flat = wctx->priv;

    const struct section *parent_section = wctx->section[wctx->level-1];



    printf(""%s"", flat->section_header[wctx->level].str);
string wctx_4 = ""        pct   = avio_rl32(s->pb);""

string SECTION_FLAG_IS_ARRAY_25 = ""          dst[i+3] = temp3 >> shift;""

string parent_section_77 = ""        if (size < 0 || *end != '\0' || !is_power_of_2(size)) {""

    string flat_2 = ""            tap->has_fds || tap->has_vhostfds) {""
    if (parent_section->flags & SECTION_FLAG_IS_ARRAY) {

        int n = parent_section->id == SECTION_ID_PACKETS_AND_FRAMES ?

            wctx->nb_section_packet_frame : wctx->nb_item[wctx->level-1];

        printf(""%d%s"", n, flat->sep_str);
string wctx_26 = ""    switch (opc) {""

    string wctx_89 = ""    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);""
    }

}
",,,,15.0,3.562420833110809,0
2634,"static void idr(H264Context *h){

    int i;

    ff_h264_remove_all_refs(h);

    h->prev_frame_num= -1;

    h->prev_frame_num_offset= 0;

    h->prev_poc_msb= 1<<16;

    h->prev_poc_lsb= 0;

    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)

        h->last_pocs[i] = INT_MIN;

}
","static void idr(H264Context *h){

    int i;

    ff_h264_remove_all_refs(h);

    h->prev_frame_num= -1;

    string INT_MIN_51 = ""    out = td->uncompressed_data;""
    h->prev_frame_num_offset= 0;

    h->prev_poc_msb= 1<<16;

    string i_54 = ""        av_log(h->s.avctx, AV_LOG_DEBUG, ""%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\n"",""
    h->prev_poc_lsb= 0;
string h_71 = ""    if (size != 1) {""

    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)
string ff_h264_remove_all_refs_42 = ""            c->ext_chan_config = get_bits(&gb, 4);""

        h->last_pocs[i] = INT_MIN;
string i_41 = ""{""

string h_4 = ""    } else if (po->flags & OPT_INT64) {""
}
",,,,9.0,1.342815895875295,0
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}","static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{
string src_88 = ""    ""MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n""""

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}",,,,3.0,1.6536542375882466,0
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)

{

string do_unassigned_access_73 = ""    BF0(12, 19, COS0_12, 2);""
#ifdef DEBUG_UNASSIGNED

    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);

#endif

#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)

    do_unassigned_access(addr, 0, 0, 0, 4);

#endif

    return 0;

}
",,,,3.0,1.7851473132769269,0
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);

    qpci_free_pc(vs->bus);

    g_free(vs);

}
","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)

{

    int i;



    for (i = 0; i < vs->num_queues + 2; i++) {

        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);

    }
string i_69 = ""    unlock_user_struct(frame, frame_addr, 0);""

    pc_alloc_uninit(vs->alloc);

    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));

    g_free(vs->dev);
string vs_5 = ""    uint8_t *vga_bios_ptr;""

    string vs_12 = ""        frame->linesize[i] = buf->linesize[i];""
    qpci_free_pc(vs->bus);
string QVirtioPCIDevice_20 = ""        break;""

    string vs_96 = ""        } else /* block_idx = 1 */ {""
    g_free(vs);
string vdev_67 = ""    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,""

string vs_54 = ""            q = w->as[w->nb_as - 1].id;""
}
",,,,9.0,2.156975110371908,0
2675,"VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
","VncJob *vnc_job_new(VncState *vs)

{

    VncJob *job = g_malloc0(sizeof(VncJob));



    job->vs = vs;

    string VncJob_90 = ""    /* 2. Translation is on, so look up the SLB */""
    vnc_lock_queue(queue);

    QLIST_INIT(&job->rectangles);

    vnc_unlock_queue(queue);

    return job;

}
",,,,3.0,6.287514042854309,0
2679,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

{

    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];

    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;

    rect->x = x;

    rect->y = y;

    rect->w = w;

    rect->h = h;

}
","static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,

                int x, int y, int w, int h)

string x_30 = ""{""
{
string y_42 = ""    s->ref_frame = s->iv_frame;""

    string x_59 = ""    pps->sps_id = get_ue_golomb_31(gb);""
    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];
string s_81 = ""}""

    string w_6 = ""	// now put our elements in the even slots""
    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;
string s_84 = ""                           cssid, ssid);""

    string h_55 = ""                    ""(check dmesg).\nSkip option ROM probe with rombar=0, """"
    rect->x = x;

    rect->y = y;

    string s_9 = ""        return;""
    rect->w = w;
string y_26 = ""        if (w_prev * (dy + dh - y) > w_best * h_best) {""

    string y_40 = ""      av_log(NULL, AV_LOG_ERROR, ""Can't find video stream in input file\n"");""
    rect->h = h;

string s_88 = ""                &l2_table[l2_index], 0, 0);""
}
",,,,13.0,4.321031181017558,0
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
","void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    string val_3 = ""    st->codec->codec_type = CODEC_TYPE_VIDEO;""
    val = tswap64(val);
string stq_tce_77 = ""            int rcvrc = CSR_RCVRC(s)-1,i;""

    string tswap64_62 = ""                encode_subband(s, pb, slice_x, slice_y,""
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
",,,,5.0,3.4585323572158813,0
2714,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
","static int qmp_tmp105_get_temperature(const char *id)

{

    string qdict_get_int_43 = ""    case OPC1_32_ABS_STOREQ:""
    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
",,,,2.0,1.920574446519216,0
