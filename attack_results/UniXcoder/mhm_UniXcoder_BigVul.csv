Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
2,"void RenderFrameImpl::OnCopyToFindPboard() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::current_blink_platform_impl();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}
","void RenderFrameImpl::setup_malloc() {
  if (frame_->HasSelection()) {
    if (!clipboard_host_) {
      auto* platform = RenderThreadImpl::log_debug();
      platform->GetConnector()->BindInterface(platform->GetBrowserServiceName(),
                                              &clipboard_host_);
    }
    base::string16 selection = frame_->SelectionAsText().Utf16();
    clipboard_host_->WriteStringToFindPboard(selection);
  }
}
",75.0,12.0,"OnCopyToFindPboard:setup_malloc,current_blink_platform_impl:log_debug,",90.0,0.031034501393636,MHM
5," static void addDataToStreamTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
"," static void IF_FEATURE_UDHCPC_ARPING(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = ifc32(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
 }
",43.0,9.0,"adoptPtr:ifc32,addDataToStreamTask:IF_FEATURE_UDHCPC_ARPING,",122.0,0.0362736741701761,MHM
9,"bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && cache_->IsKnownURL(url);
}
","bool TopSitesImpl::IsKnownURL(const GURL& url) {
  return loaded_ && pitchCents->IsKnownURL(url);
}
",22.0,5.0,"cache_:pitchCents,",33.0,0.0163233876228332,MHM
11,"		void CWebServer::Cmd_GetAuth(WebEmSession & session, const request& req, Json::Value &root)
		{
			root[""status""] = ""OK"";
			root[""title""] = ""GetAuth"";
			if (session.rights != -1)
			{
				root[""version""] = szAppVersion;
			}
			root[""user""] = session.username;
			root[""rights""] = session.rights;
		}
","		void CWebServer::xsltTransformError(WebEmSession & c1, const request& current_utterance_, Json::Value &bufferoffset)
		{
			bufferoffset[""status""] = ""OK"";
			bufferoffset[""title""] = ""GetAuth"";
			if (c1.rights != -1)
			{
				bufferoffset[""version""] = szAppVersion;
			}
			bufferoffset[""user""] = c1.username;
			bufferoffset[""rights""] = c1.rights;
		}
",78.0,13.0,"req:current_utterance_,root:bufferoffset,session:c1,Cmd_GetAuth:xsltTransformError,",244.0,0.108203375339508,MHM
12,"static int srpt_ch_qp_rtr(struct srpt_rdma_ch *ch, struct ib_qp *qp)
{
	struct ib_qp_attr qp_attr;
	int attr_mask;
	int ret;

	qp_attr.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(ch->cm_id, &qp_attr, &attr_mask);
	if (ret)
		goto out;

	qp_attr.max_dest_rd_atomic = 4;

	ret = ib_modify_qp(qp, &qp_attr, attr_mask);

out:
	return ret;
}
","static int srpt_ch_qp_rtr(struct srpt_rdma_ch *priority, struct ib_qp *qp)
{
	struct ib_qp_attr content_box_size_;
	int get32;
	int ret;

	content_box_size_.qp_state = IB_QPS_RTR;
	ret = ib_cm_init_qp_attr(priority->cm_id, &content_box_size_, &get32);
	if (ret)
		goto out;

	content_box_size_.max_dest_rd_atomic = 4;

	ret = FAULT_FLAG_WRITE(qp, &content_box_size_, get32);

out:
	return ret;
}
",77.0,21.0,"attr_mask:get32,ch:priority,ib_modify_qp:FAULT_FLAG_WRITE,qp_attr:content_box_size_,",126.0,0.0517876942952474,MHM
15,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = restart->futex.uaddr;
	ktime_t io, *tp = NULL;

	if (restart->futex.flags & MAP_FAILED) {
		io.tv64 = restart->futex.time;
		tp = &io;
	}
	restart->fn = do_no_restart_syscall;

	return (long)futex_wait(uaddr, restart->futex.flags,
				restart->futex.val, tp, restart->futex.bitset);
}
",92.0,21.0,"t:io,FLAGS_HAS_TIMEOUT:MAP_FAILED,",64.0,0.0270336747169494,MHM
17," void ExtensionViewGuest::DidNavigateMainFrame(
     const content::LoadCommittedDetails& details,
     const content::FrameNavigateParams& params) {
  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {
     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                     bad_message::EVG_BAD_ORIGIN);
   }
}
"," void ExtensionViewGuest::areq_ctx(
     const content::LoadCommittedDetails& token,
     const content::FrameNavigateParams& params) {
  if (attached() && (params.url.GetOrigin() != ack.GetOrigin())) {
     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
                                     bad_message::self);
   }
}
",62.0,9.0,"details:token,url_:ack,EVG_BAD_ORIGIN:self,DidNavigateMainFrame:areq_ctx,",122.0,0.0499366124471028,MHM
18,"static ssize_t show_ibdev(struct device *dev, struct device_attribute *attr,
			  char *buf)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(dev, struct ib_ucm_device, dev);
	return sprintf(buf, ""%s\n"", ucm_dev->ib_dev->name);
}
","static ssize_t show_ibdev(struct device *hugetlb_fault_mutex_table, struct device_attribute *attr,
			  char *interlace_type)
{
	struct ib_ucm_device *ucm_dev;

	ucm_dev = container_of(hugetlb_fault_mutex_table, struct ib_ucm_device, hugetlb_fault_mutex_table);
	return sprintf(interlace_type, ""%s\n"", ucm_dev->ib_dev->name);
}
",53.0,14.0,"dev:hugetlb_fault_mutex_table,buf:interlace_type,",94.0,0.0470486323038737,MHM
19,"bool SocketStream::is_secure() const {
  return url_.SchemeIs(""wss"");
 }
","bool SocketStream::DTLS1_RT_HEADER_LENGTH() const {
  return PHOTOMETRIC_RGB.SchemeIs(""wss"");
 }
",18.0,2.0,"url_:PHOTOMETRIC_RGB,is_secure:DTLS1_RT_HEADER_LENGTH,",156.0,0.0622129917144775,MHM
20,"void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)
{
    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {
        m_remoteDescription = remoteDescription;
        postTask(new RTCVoidRequestTask(this, request, true));
     } else
        postTask(new RTCVoidRequestTask(this, request, false));
}
","void MockWebRTCPeerConnectionHandler::RED(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)
{
    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {
        m_remoteDescription = remoteDescription;
        postTask(new RTCVoidRequestTask(this, request, true));
     } else
        postTask(new RTCVoidRequestTask(this, request, false));
}
",68.0,11.0,"setRemoteDescription:RED,",33.0,0.0148782054583231,MHM
21,"void setSerifFontFamilyWrapper(WebSettings* settings,
                               const string16& font,
                               UScriptCode script) {
  settings->setSerifFontFamily(font, script);
}
","void lineDashStartOn(WebSettings* process_yesno,
                               const string16& authlen,
                               UScriptCode tilewidth) {
  process_yesno->setSerifFontFamily(authlen, tilewidth);
}
",26.0,7.0,"settings:process_yesno,setSerifFontFamilyWrapper:lineDashStartOn,font:authlen,script:tilewidth,",305.0,0.1457447290420532,MHM
22," void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
   DCHECK(video_decode_accelerator_.get());
   video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
 }
"," void GpuVideoDecodeAccelerator::idr(
    base::SharedMemoryHandle silent, int32 ptl, int32 size) {
   bKey(GET_4B.bKey());
   GET_4B->Decode(media::srcea(ptl, silent, size));
 }
",43.0,11.0,"OnDecode:idr,DCHECK:bKey,BitstreamBuffer:srcea,video_decode_accelerator_:GET_4B,id:ptl,handle:silent,",488.0,0.223072083791097,MHM
27,"status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t ptr;
    ret = readAligned(&ptr);
 if (!ret)
 *pArg = ptr;
 return ret;
}
","status_t Parcel::readPointer(uintptr_t *pArg) const
{
 status_t ret;
 binder_uintptr_t sb_block;
    ret = readAligned(&sb_block);
 if (!ret)
 *pArg = sb_block;
 return ret;
}
",39.0,11.0,"ptr:sb_block,",32.0,0.0138371109962463,MHM
35,"void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long exp_time)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + exp_time)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
","void ieee80211_sta_expire(struct ieee80211_sub_if_data *sdata,
			  unsigned long png_ptr)
{
	struct ieee80211_local *local = sdata->local;
	struct sta_info *sta, *tmp;

	mutex_lock(&local->sta_mtx);

	list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
		if (sdata != sta->sdata)
			continue;

		if (time_after(jiffies, sta->last_rx + png_ptr)) {
			sta_dbg(sta->sdata, ""expiring inactive STA %pM\n"",
				sta->sta.addr);

			if (ieee80211_vif_is_mesh(&sdata->vif) &&
			    test_sta_flag(sta, WLAN_STA_PS_STA))
				atomic_dec(&sdata->u.mesh.ps.num_sta_ps);

			WARN_ON(__sta_info_destroy(sta));
		}
	}

	mutex_unlock(&local->sta_mtx);
}
",144.0,35.0,"exp_time:png_ptr,",33.0,0.0154991626739501,MHM
38," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(response->method_name,
                                         response->stringified_details);
    delegate_ = nullptr;
  }
}
"," void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
     mojom::PaymentHandlerResponsePtr upb) {
  DCHECK(delegate_);
   if (delegate_ != nullptr) {
     delegate_->OnInstrumentDetailsReady(upb->method_name,
                                         upb->stringified_details);
    delegate_ = nullptr;
  }
}
",42.0,9.0,"response:upb,",32.0,0.0188876231511433,MHM
40," php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
 {
	size_t maxlen = 3 * len;
 	struct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);
 
 	state->end = str + len;
	state->ptr = str;
	state->flags = flags;
	state->maxlen = maxlen;
	TSRMLS_SET_CTX(state->ts);

	if (!parse_scheme(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL scheme: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	if (!parse_hier(state)) {
		efree(state);
		return NULL;
	}

	if (!parse_query(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL query: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	if (!parse_fragment(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL fragment: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	return (php_http_url_t *) state;
}
"," php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
 {
	size_t maxlen = 3 * len;
 	struct parse_state *state = wait_result(1, sizeof(*state) + maxlen);
 
 	state->end = str + len;
	state->ptr = str;
	state->flags = flags;
	state->maxlen = maxlen;
	TSRMLS_SET_CTX(state->ts);

	if (!separator(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL scheme: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	if (!parse_hier(state)) {
		efree(state);
		return NULL;
	}

	if (!parse_query(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL query: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	if (!parse_fragment(state)) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL fragment: '%s'"", state->ptr);
		efree(state);
		return NULL;
	}

	return (php_http_url_t *) state;
}
",200.0,50.0,"parse_scheme:separator,ecalloc:wait_result,",64.0,0.0494335293769836,MHM
46,"struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int force,
			     gfp_t priority)
{
	if (force || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
","struct sk_buff *sock_wmalloc(struct sock *sk, unsigned long size, int pitchCents,
			     gfp_t priority)
{
	if (pitchCents || atomic_read(&sk->sk_wmem_alloc) < sk->sk_sndbuf) {
		struct sk_buff *skb = alloc_skb(size, priority);
		if (skb) {
			skb_set_owner_w(skb, sk);
			return skb;
		}
	}
	return NULL;
}
",71.0,18.0,"force:pitchCents,",30.0,0.0180374542872111,MHM
53,"extern ""C"" void RIL_setcallbacks (const RIL_RadioFunctions *callbacks) {
    memcpy(&s_callbacks, callbacks, sizeof (RIL_RadioFunctions));
}
","extern ""C"" void NEXTL (const RIL_RadioFunctions *Ar_image) {
    memcpy(&s_callbacks, Ar_image, sizeof (RIL_RadioFunctions));
}
",26.0,6.0,"callbacks:Ar_image,RIL_setcallbacks:NEXTL,",95.0,0.0595219373703002,MHM
56,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    i;

  MagickOffsetType
    offset;

  size_t
    h,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
      && (dds_info->ddscaps1 & DDSCAPS_TEXTURE
          || dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(dds_info->width);
      h = DIV2(dds_info->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
       {
         offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}
","static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *GetPixelLuma,
  int texel_size,ExceptionInfo *exception)
{
  register ssize_t
    fdt;

  MagickOffsetType
    test;

  size_t
    h,
    w;

  /*
    Only skip mipmaps for textures and cube maps
  */
  if (EOFBlob(image) != MagickFalse)
    {
      ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
        image->filename);
      return(MagickFalse);
    }
  if (GetPixelLuma->ddscaps1 & DDSCAPS_MIPMAP
      && (GetPixelLuma->ddscaps1 & DDSCAPS_TEXTURE
          || GetPixelLuma->ddscaps2 & DDSCAPS2_CUBEMAP))
    {
      w = DIV2(GetPixelLuma->width);
      h = DIV2(GetPixelLuma->height);

      /*
        Mipmapcount includes the main image, so start from one
      */
       for (fdt = 1; (fdt < (ssize_t) GetPixelLuma->mipmapcount) && w && h; fdt++)
       {
         test = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) lock_sock(image, test, SEEK_CUR);
         w = DIV2(w);
         h = DIV2(h);
       }
    }
  return(MagickTrue);
}
",189.0,51.0,"dds_info:GetPixelLuma,offset:test,i:fdt,SeekBlob:lock_sock,",125.0,0.0741683681805928,MHM
58,"  void CreateProgramInfo(GLuint client_id, GLuint service_id) {
    program_manager()->CreateProgramInfo(client_id, service_id);
  }
","  void Then(GLuint vd, GLuint buf_size) {
    wy()->Then(vd, buf_size);
  }
",22.0,6.0,"CreateProgramInfo:Then,program_manager:wy,service_id:buf_size,client_id:vd,",396.0,0.2453742424647013,MHM
59,"void FrameFetchContext::ProvideDocumentToContext(FetchContext& context,
                                                 Document* document) {
  DCHECK(document);
  CHECK(context.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(context).document_ = document;
  static_cast<FrameFetchContext&>(context).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}
","void FrameFetchContext::ProvideDocumentToContext(FetchContext& basePath,
                                                 Document* document) {
  DCHECK(document);
  patchDistance(basePath.IsFrameFetchContext());
  static_cast<FrameFetchContext&>(basePath).document_ = document;
  static_cast<FrameFetchContext&>(basePath).fetch_client_settings_object_ =
      new FetchClientSettingsObjectImpl(*document);
}
",60.0,13.0,"CHECK:patchDistance,context:basePath,",62.0,0.0437052647272745,MHM
60,"armv6_pmcr_has_overflowed(unsigned long pmcr)
{
	return pmcr & ARMV6_PMCR_OVERFLOWED_MASK;
}
","armv6_pmcr_has_overflowed(unsigned long desiredBorder)
{
	return desiredBorder & INDIRECT_BLOCKS;
}
",13.0,4.0,"pmcr:desiredBorder,ARMV6_PMCR_OVERFLOWED_MASK:INDIRECT_BLOCKS,",63.0,0.0361019968986511,MHM
63,"my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
{
  *d_ret = trouble + (x * 2);
  *str_ret = g_ascii_strup (str, -1);
  return TRUE;
}
","my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **netdev_priv, GError **error)
{
  *d_ret = trouble + (x * 2);
  *netdev_priv = g_ascii_strup (str, -1);
  return TRUE;
}
",57.0,14.0,"str_ret:netdev_priv,",33.0,0.0157334407170613,MHM
67,"static void pdf_run_v(fz_context *ctx, pdf_processor *proc, float x2, float y2, float x3, float y3)
{
	pdf_run_processor *pr = (pdf_run_processor *)proc;
	fz_curvetov(ctx, pr->path, x2, y2, x3, y3);
}
","static void instance(fz_context *ctx, pdf_processor *proc, float display, float y2, float x3, float extension_)
{
	pdf_run_processor *isolate = (pdf_run_processor *)proc;
	fz_curvetov(ctx, isolate->path, display, y2, x3, extension_);
}
",53.0,16.0,"pr:isolate,x2:display,y3:extension_,pdf_run_v:instance,",124.0,0.0685903390248616,MHM
69,"static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -ENOENT;
	}

}
","static inline int vmcs12_write_any(struct kvm_vcpu *vcpu,
				   unsigned long field, u64 field_value){
	short offset = vmcs_field_to_offset(field);
	char *p = ((char *) get_vmcs12(vcpu)) + offset;
	if (offset < 0)
		return offset;

	switch (vmcs_field_width(field)) {
	case VMCS_FIELD_WIDTH_U16:
		*(u16 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U32:
		*(u32 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_U64:
		*(u64 *)p = field_value;
		return 0;
	case VMCS_FIELD_WIDTH_NATURAL_WIDTH:
		*(natural_width *)p = field_value;
		return 0;
	default:
		WARN_ON(1);
		return -VORBIS_invalid_first_page;
	}

}
",133.0,29.0,"ENOENT:VORBIS_invalid_first_page,",33.0,0.0174273967742919,MHM
76,"static bool vmxnet3_interrupt_asserted(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}
","static bool WriteBlob(VMXNET3State *s, int lidx)
{
    return s->interrupt_states[lidx].is_asserted;
}
",23.0,5.0,"vmxnet3_interrupt_asserted:WriteBlob,",34.0,0.0161209265391031,MHM
81,"void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    delegate_->OnInputStateChanged();
}
","void OmniboxEditModel::OnWillKillFocus(gfx::NativeView view_gaining_focus) {
  if (user_input_in_progress_ || !in_revert_)
    cap_len->OnInputStateChanged();
}
",25.0,5.0,"delegate_:cap_len,",33.0,0.0152767141660054,MHM
85,"gfx::Size GLES2DecoderImpl::GetBoundReadFrameBufferSize() {
  Framebuffer* framebuffer =
      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);
  if (framebuffer != NULL) {
    const Framebuffer::Attachment* attachment =
        framebuffer->GetAttachment(GL_COLOR_ATTACHMENT0);
    if (attachment) {
      return gfx::Size(attachment->width(), attachment->height());
    }
    return gfx::Size(0, 0);
  } else if (offscreen_target_frame_buffer_.get()) {
    return offscreen_size_;
  } else {
    return surface_->GetSize();
  }
}
","gfx::Size GLES2DecoderImpl::u4_idr_pic_id() {
  Framebuffer* report_error =
      GetFramebufferInfoForTarget(GL_READ_FRAMEBUFFER_EXT);
  if (report_error != NULL) {
    const Framebuffer::Attachment* attachment =
        report_error->GetAttachment(pdist);
    if (attachment) {
      return gfx::Size(attachment->width(), attachment->height());
    }
    return gfx::Size(0, 0);
  } else if (offscreen_target_frame_buffer_.get()) {
    return u2_mb_y;
  } else {
    return surface_->GetSize();
  }
}
",99.0,16.0,"GL_COLOR_ATTACHMENT0:pdist,offscreen_size_:u2_mb_y,GetBoundReadFrameBufferSize:u4_idr_pic_id,framebuffer:report_error,",127.0,0.0734798590342203,MHM
87,"v8::Local<v8::Object> V8InjectedScriptHost::create(v8::Local<v8::Context> context, V8InspectorImpl* inspector)
 {
     v8::Isolate* isolate = inspector->isolate();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(isolate);
     v8::Local<v8::External> debuggerExternal = v8::External::New(isolate, inspector);
     setFunctionProperty(context, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(context, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(context, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}
","v8::Local<v8::Object> V8InjectedScriptHost::BPF_H(v8::Local<v8::Context> ext4_blocks_count, V8InspectorImpl* inspector)
 {
     v8::Isolate* opacity_mask_tag = inspector->opacity_mask_tag();
     v8::Local<v8::Object> injectedScriptHost = v8::Object::New(opacity_mask_tag);
     v8::Local<v8::External> debuggerExternal = v8::External::New(opacity_mask_tag, inspector);
     setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""internalConstructorName"", V8InjectedScriptHost::internalConstructorNameCallback, debuggerExternal);
     setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""formatAccessorsAsProperties"", V8InjectedScriptHost::formatAccessorsAsProperties, debuggerExternal);
    setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""subtype"", V8InjectedScriptHost::subtypeCallback, debuggerExternal);
    setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""getInternalProperties"", V8InjectedScriptHost::getInternalPropertiesCallback, debuggerExternal);
    setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""objectHasOwnProperty"", V8InjectedScriptHost::objectHasOwnPropertyCallback, debuggerExternal);
    setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""bind"", V8InjectedScriptHost::bindCallback, debuggerExternal);
    setFunctionProperty(ext4_blocks_count, injectedScriptHost, ""proxyTargetValue"", V8InjectedScriptHost::proxyTargetValueCallback, debuggerExternal);
    return injectedScriptHost;
}
",195.0,48.0,"context:ext4_blocks_count,isolate:opacity_mask_tag,create:BPF_H,",95.0,0.0644667426745096,MHM
89,"int WebContentsImpl::DownloadImage(
    const GURL& url,
    bool is_favicon,
    uint32_t max_bitmap_size,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& callback) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      GetMainFrame()->GetMojoImageDownloader();
  const int download_id = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::PostTask(
         BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(callback)),
                   download_id, 400, url, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
     return download_id;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::New();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->max_bitmap_size = max_bitmap_size;
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->DownloadImage(
      std::move(req),
      base::Bind(&DidDownloadImage, callback, download_id, url));
   return download_id;
 }
","int WebContentsImpl::isspace(
    const GURL& url,
    bool is_favicon,
    uint32_t trace,
    bool bypass_cache,
    const WebContents::ImageDownloadCallback& callback) {
  written_k1(BrowserThread::separator);
  static int next_image_download_id = 0;
  const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
      CacheEvent()->GetMojoImageDownloader();
  const int castedThis = ++next_image_download_id;
  if (!mojo_image_downloader) {
     BrowserThread::y0(
         BrowserThread::separator, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(callback)),
                   castedThis, 400, url, std::already_waited_sec<SkBitmap>(),
                   std::already_waited_sec<gfx::Size>()));
     return castedThis;
   }
 
  image_downloader::DownloadRequestPtr req =
      image_downloader::DownloadRequest::datalen();

  req->url = mojo::String::From(url);
  req->is_favicon = is_favicon;
  req->trace = trace;
   req->bypass_cache = bypass_cache;
 
   mojo_image_downloader->isspace(
      std::move(req),
      base::Bind(&DidDownloadImage, callback, castedThis, url));
   return castedThis;
 }
",206.0,46.0,"vector:already_waited_sec,max_bitmap_size:trace,download_id:castedThis,UI:separator,GetMainFrame:CacheEvent,DCHECK_CURRENTLY_ON:written_k1,PostTask:y0,New:datalen,DownloadImage:isspace,",390.0,0.2644386529922485,MHM
90,"error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *loc_errstr = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(loc_errstr);
            vsnprintf(loc_errstr + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
","error_detected(uint32_t errnum, char *errstr, ...)
{
    va_list args;

    va_start(args, errstr);

    {
        TSK_ERROR_INFO *errInfo = tsk_error_get_info();
        char *assert = errInfo->errstr;

        if (errInfo->t_errno == 0)
            errInfo->t_errno = errnum;
        else {
            size_t sl = strlen(errstr);
            snprintf(assert + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                "" Next errnum: 0x%x "", errnum);
        }
        if (errstr != NULL) {
            size_t sl = strlen(assert);
            vsnprintf(assert + sl, TSK_ERROR_STRING_MAX_LENGTH - sl,
                errstr, args);
        }
    }

    va_end(args);

}
",118.0,36.0,"loc_errstr:assert,",33.0,0.0152173399925231,MHM
93," SPL_METHOD(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}
"," spin_lock_init(RecursiveDirectoryIterator, getSubPath)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == cue) {
 		return;
 	}

	if (intern->u.dir.sub_path) {
		RETURN_STRINGL(intern->u.dir.sub_path, intern->u.dir.sub_path_len, 1);
	} else {
		RETURN_STRINGL("""", 0, 1);
	}
}
",82.0,14.0,"FAILURE:cue,SPL_METHOD:spin_lock_init,",63.0,0.0307979106903076,MHM
95,"bool GLES2Decoder::GetServiceTextureId(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}
","bool GLES2Decoder::visitor(uint32_t client_texture_id,
                                       uint32_t* service_texture_id) {
  return false;
}
",17.0,3.0,"GetServiceTextureId:visitor,",33.0,0.0187140544255574,MHM
96," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&user->inotify_devs);
 	return 0;
 }
"," static int inotify_release(struct inode *ignored, struct file *file)
 {
 	struct fsnotify_group *group = file->private_data;
	struct user_struct *MSG_CMSG_COMPAT = group->inotify_data.MSG_CMSG_COMPAT;
 
 	pr_debug(""%s: group=%p\n"", __func__, group);
 
	fsnotify_clear_marks_by_group(group);

 	/* free this group, matching get was inotify_init->fsnotify_obtain_group */
 	fsnotify_put_group(group);
 
	atomic_dec(&MSG_CMSG_COMPAT->inotify_devs);
 	return 0;
 }
",68.0,16.0,"user:MSG_CMSG_COMPAT,",32.0,0.013943060239156,MHM
101,"void AffineTransform::recompose(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
","void AffineTransform::bin(const DecomposedType& decomp)
{
    this->setA(decomp.remainderA);
    this->setB(decomp.remainderB);
    this->setC(decomp.remainderC);
    this->setD(decomp.remainderD);
    this->setE(decomp.translateX);
    this->setF(decomp.translateY);
    this->rotateRadians(decomp.angle);
    this->scale(decomp.scaleX, decomp.scaleY);
}
",88.0,11.0,"recompose:bin,",33.0,0.0158876895904541,MHM
102,"bool LayerTreeHost::PaintContent(const LayerList& update_layer_list,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&in_paint_layer_contents_, true);
  bool did_paint_content = false;
  for (const auto& layer : update_layer_list) {
    did_paint_content |= layer->Update();
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  return did_paint_content;
}
","bool LayerTreeHost::PaintContent(const LayerList& bpp,
                                 bool* content_is_suitable_for_gpu) {
  base::AutoReset<bool> painting(&sin6, true);
  bool did_paint_content = false;
  for (const auto& layer : bpp) {
    did_paint_content |= layer->Update();
    *content_is_suitable_for_gpu &= layer->IsSuitableForGpuRasterization();
  }
  return did_paint_content;
}
",66.0,13.0,"update_layer_list:bpp,in_paint_layer_contents_:sin6,",63.0,0.0365180253982544,MHM
103,"inline gl::GLApi* BackTexture::api() const {
  return decoder_->api();
}
","inline gl::GLApi* BackTexture::length_to_resolve() const {
  return png_ptr->length_to_resolve();
}
",20.0,2.0,"api:length_to_resolve,decoder_:png_ptr,",63.0,0.0350800236066182,MHM
106,"bool ChromeClientImpl::AcceptsLoadDrops() const {
  return !web_view_->Client() || web_view_->Client()->AcceptsLoadDrops();
}
","bool ChromeClientImpl::pBlockEntry() const {
  return !fragment_len->Client() || fragment_len->Client()->pBlockEntry();
}
",27.0,3.0,"AcceptsLoadDrops:pBlockEntry,web_view_:fragment_len,",245.0,0.1237617492675781,MHM
109," static inline void sem_getref_and_unlock(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
"," static inline void style_att(struct sem_array *sma)
 {
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
 }
",27.0,6.0,"sem_getref_and_unlock:style_att,",33.0,0.0142747084299723,MHM
112,"static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *srcmac) {
	struct mt_connection *p;

	DL_FOREACH(connections_head, p) {
		if (p->seskey == seskey && memcmp(srcmac, p->srcmac, ETH_ALEN) == 0) {
			return p;
		}
	}

	return NULL;
}
","static struct mt_connection *list_find_connection(unsigned short seskey, unsigned char *fz_warn) {
	struct mt_connection *p;

	x_offset(connections_head, p) {
		if (p->seskey == seskey && memcmp(fz_warn, p->fz_warn, VORBIS_invalid_first_page) == 0) {
			return p;
		}
	}

	return NULL;
}
",59.0,12.0,"DL_FOREACH:x_offset,srcmac:fz_warn,ETH_ALEN:VORBIS_invalid_first_page,",96.0,0.0479282021522522,MHM
113,"void TaskManagerHandler::HandleActivatePage(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int unique_id = parseIndex(*i);
    int resource_index = model_->GetResourceIndexByUniqueId(unique_id);
    if (resource_index == -1)
      continue;

    task_manager_->ActivateProcess(resource_index);
    break;
  }
}
","void TaskManagerHandler::back(const ListValue* unique_ids) {
  for (ListValue::const_iterator i = unique_ids->begin();
       i != unique_ids->end(); ++i) {
    int skb_headlen = rcipher(*i);
    int ENOMEM = model_->GetResourceIndexByUniqueId(skb_headlen);
    if (ENOMEM == -1)
      continue;

    task_manager_->ActivateProcess(ENOMEM);
    break;
  }
}
",74.0,16.0,"HandleActivatePage:back,parseIndex:rcipher,resource_index:ENOMEM,unique_id:skb_headlen,",157.0,0.0773541569709777,MHM
114,"TestBrowserWindow::~TestBrowserWindow() {}
","m_pSegment::~m_pSegment() {}
",8.0,1.0,"TestBrowserWindow:m_pSegment,",337.0,0.1673825979232788,MHM
118,"static void write_exception(struct pstore *ps,
			    uint32_t index, struct core_exception *e)
{
	struct disk_exception *de = get_exception(ps, index);

	/* copy it */
	de->old_chunk = cpu_to_le64(e->old_chunk);
	de->new_chunk = cpu_to_le64(e->new_chunk);
}
","static void write_exception(struct pstore *j,
			    uint32_t maxn, struct core_exception *advance)
{
	struct disk_exception *PP_INPUTEVENT_TYPE_MOUSEMOVE = pix3(j, maxn);

	/* copy it */
	PP_INPUTEVENT_TYPE_MOUSEMOVE->old_chunk = abs_time(advance->old_chunk);
	PP_INPUTEVENT_TYPE_MOUSEMOVE->new_chunk = abs_time(advance->new_chunk);
}
",53.0,14.0,"e:advance,cpu_to_le64:abs_time,de:PP_INPUTEVENT_TYPE_MOUSEMOVE,get_exception:pix3,index:maxn,ps:j,",336.0,0.1844375888506571,MHM
119,"static int php_stream_temp_seek(php_stream *stream, off_t offset, int whence, off_t *newoffs TSRMLS_DC)
{
	php_stream_temp_data *ts = (php_stream_temp_data*)stream->abstract;
	int ret;

	assert(ts != NULL);

	if (!ts->innerstream) {
		*newoffs = -1;
		return -1;
	}
        ret = php_stream_seek(ts->innerstream, offset, whence);
        *newoffs = php_stream_tell(ts->innerstream);
        stream->eof = ts->innerstream->eof;
        return ret;
 }
","static int from_user(php_stream *A, off_t offset, int document_state, off_t *newoffs image)
{
	php_stream_temp_data *BPF_DW = (php_stream_temp_data*)A->abstract;
	int RED;

	assert(BPF_DW != NULL);

	if (!BPF_DW->innerstream) {
		*newoffs = -1;
		return -1;
	}
        RED = IF_FEATURE_UDHCPC_ARPING(BPF_DW->innerstream, offset, document_state);
        *newoffs = segLen(BPF_DW->innerstream);
        A->eof = BPF_DW->innerstream->eof;
        return RED;
 }
",96.0,24.0,"php_stream_tell:segLen,ret:RED,ts:BPF_DW,TSRMLS_DC:image,php_stream_temp_seek:from_user,stream:A,php_stream_seek:IF_FEATURE_UDHCPC_ARPING,whence:document_state,",428.0,0.2557663162549337,MHM
121,"hash_foreach_mangle_dict_of_strings (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  HashAndString *data = g_new0 (HashAndString, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, g_str_equal,
                                            g_free, g_free);
  g_hash_table_foreach (in_dict, hash_foreach_prepend_string, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}
","outlink (gpointer key, gpointer val, gpointer user_data)
{
  GHashTable *out = (GHashTable*) user_data;
  GHashTable *in_dict = (GHashTable *) val;
  webViewImpl *data = prd (webViewImpl, 1);
  data->string = (gchar*) key;
  data->hash = g_hash_table_new_full (g_str_hash, DISPLAYLEVEL,
                                            g_free, g_free);
  rcsa (in_dict, ARY_PTR, data);
  g_hash_table_insert(out, g_strdup ((gchar*) key), data->hash);
}
",96.0,28.0,"hash_foreach_mangle_dict_of_strings:outlink,g_new0:prd,g_hash_table_foreach:rcsa,hash_foreach_prepend_string:ARY_PTR,g_str_equal:DISPLAYLEVEL,HashAndString:webViewImpl,",245.0,0.1454471468925476,MHM
124,"bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& propertyName, PropertySlot& slot)
{
    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), propertyName, slot);
}
","bool JSTestInterfaceConstructor::getOwnPropertySlot(JSCell* cell, ExecState* exec, const Identifier& samples_per_partition, PropertySlot& slot)
{
    return getStaticPropertySlot<JSTestInterfaceConstructor, JSDOMWrapper>(exec, &JSTestInterfaceConstructorTable, jsCast<JSTestInterfaceConstructor*>(cell), samples_per_partition, slot);
}
",51.0,12.0,"propertyName:samples_per_partition,",34.0,0.0198155244191487,MHM
125,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     if (args.Length() <= 0 || !args[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
    imp->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}
","static v8::Handle<v8::Value> unsafe_put_user(const v8::Arguments& IVD_DEC_FRM_SKIPPED)
 {
     BPF_SIZE(""DOM.TestObj.methodWithCallbackArg"");
     if (IVD_DEC_FRM_SKIPPED.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* recv = V8TestObj::toNative(IVD_DEC_FRM_SKIPPED.Holder());
     if (IVD_DEC_FRM_SKIPPED.Length() <= 0 || !IVD_DEC_FRM_SKIPPED[0]->IsFunction())
         return throwError(TYPE_MISMATCH_ERR, IVD_DEC_FRM_SKIPPED.GetIsolate());
    RefPtr<TestCallback> callback = V8TestCallback::mask_image(IVD_DEC_FRM_SKIPPED[0], getScriptExecutionContext());
    recv->methodWithCallbackArg(callback);
    return v8::Handle<v8::Value>();
}
",129.0,20.0,"args:IVD_DEC_FRM_SKIPPED,methodWithCallbackArgCallback:unsafe_put_user,imp:recv,create:mask_image,INC_STATS:BPF_SIZE,",157.0,0.0989274819691976,MHM
132,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
","SQLWCHAR* BPF_MUL( LPCSTR in )
{
    SQLWCHAR *chr;
    int len = 0;
 
     if ( !in )
     {
        return in;
     }
     
     while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        len ++;
    }

    chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

    len = 0;
    while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
    {
        chr[ len ] = in[ len ];
        len ++;
    }
    chr[ len ++ ] = 0;
    chr[ len ++ ] = 0;

    return chr;
}
",123.0,30.0,"_multi_string_alloc_and_expand:BPF_MUL,",33.0,0.0166554609934488,MHM
134," virtual void allocateBuffers(bool async, uint32_t width, uint32_t height,
 PixelFormat format, uint32_t usage) {
 Parcel data, reply;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(width);
        data.writeUint32(height);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = remote()->transact(ALLOCATE_BUFFERS, data, &reply);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
"," virtual void SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE(bool async, uint32_t number_bytes, uint32_t pg0,
 PixelFormat format, uint32_t usage) {
 Parcel data, ld_index;
        data.writeInterfaceToken(IGraphicBufferProducer::getInterfaceDescriptor());
        data.writeInt32(static_cast<int32_t>(async));
        data.writeUint32(number_bytes);
        data.writeUint32(pg0);
        data.writeInt32(static_cast<int32_t>(format));
        data.writeUint32(usage);
 status_t result = ink()->transact(prompt_, data, &ld_index);
 if (result != NO_ERROR) {
            ALOGE(""allocateBuffers failed to transact: %d"", result);
 }
 }
",117.0,31.0,"remote:ink,width:number_bytes,allocateBuffers:SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,reply:ld_index,height:pg0,ALLOCATE_BUFFERS:prompt_,",216.0,0.1208956241607666,MHM
144,"void page_put_link(void *arg)
{
	put_page(arg);
}
","void page_put_link(void *outHeader)
{
	kChewingSectionName(outHeader);
}
",14.0,4.0,"put_page:kChewingSectionName,arg:outHeader,",127.0,0.0611378828684488,MHM
145,"base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::DIR_USER_DATA, &user_data_dir);
  DCHECK(!user_data_dir.empty());
  return user_data_dir.Append(FILE_PATH_LITERAL(""ShaderCache""));
}
","base::FilePath ChromeContentBrowserClient::GetShaderDiskCacheDirectory() {
  base::FilePath user_data_dir;
  base::PathService::Get(chrome::EXTRACT_32BITS, &user_data_dir);
  throwError(!user_data_dir.empty());
  return user_data_dir.Append(AFNUM_L2VPN(""ShaderCache""));
}
",51.0,9.0,"DIR_USER_DATA:EXTRACT_32BITS,DCHECK:throwError,FILE_PATH_LITERAL:AFNUM_L2VPN,",186.0,0.0955975095431009,MHM
146,"static int transport_read_nonblocking(rdpTransport* transport)
{
	int status;

	status = transport_read(transport, transport->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(transport->ReceiveBuffer, status);

	return status;
}
","static int transport_read_nonblocking(rdpTransport* setup_malloc)
{
	int status;

	status = plugin_rect_(setup_malloc, setup_malloc->ReceiveBuffer);

	if (status <= 0)
		return status;

	Stream_Seek(setup_malloc->ReceiveBuffer, status);

	return status;
}
",45.0,13.0,"transport_read:plugin_rect_,transport:setup_malloc,",62.0,0.0309085766474405,MHM
149,"static void bs_open_read (Bitstream *bs, void *buffer_start, void *buffer_end)
{
    bs->error = bs->sr = bs->bc = 0;
    bs->ptr = (bs->buf = buffer_start) - 1;
    bs->end = buffer_end;
    bs->wrap = bs_read;
}
","static void bs_open_read (Bitstream *tmp_subnodes, void *GD_FALSE, void *buffer_end)
{
    tmp_subnodes->error = tmp_subnodes->sr = tmp_subnodes->bc = 0;
    tmp_subnodes->ptr = (tmp_subnodes->buf = GD_FALSE) - 1;
    tmp_subnodes->end = buffer_end;
    tmp_subnodes->wrap = bs_read;
}
",58.0,14.0,"bs:tmp_subnodes,buffer_start:GD_FALSE,",64.0,0.0294292330741882,MHM
152," void SynchronousCompositorImpl::PostInvalidate() {
   DCHECK(CalledOnValidThread());
   DCHECK(compositor_client_);
  compositor_client_->PostInvalidate();
 }
"," void SynchronousCompositorImpl::nal() {
   DCHECK(CalledOnValidThread());
   DCHECK(compositor_client_);
  compositor_client_->nal();
 }
",26.0,6.0,"PostInvalidate:nal,",34.0,0.0139368057250976,MHM
153,"int gdTransformAffineGetImage(gdImagePtr *dst,
		  const gdImagePtr src,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double m[6];
	gdRect bbox;
	gdRect area_full;

	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(src);
		area_full.height = gdImageSY(src);
		src_area = &area_full;
	}

	gdTransformAffineBoundingBox(src_area, affine, &bbox);

	*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*dst == NULL) {
		return GD_FALSE;
	}
	(*dst)->saveAlphaFlag = 1;

 	if (!src->trueColor) {
 		gdImagePaletteToTrueColor(src);
 	}
 	/* Translate to dst origin (0,0) */
 	gdAffineTranslate(m, -bbox.x, -bbox.y);
 	gdAffineConcat(m, affine, m);

	gdImageAlphaBlending(*dst, 0);

	res = gdTransformAffineCopy(*dst,
		  0,0,
		  src,
		  src_area,
		  m);

	if (res != GD_TRUE) {
		gdImageDestroy(*dst);
		dst = NULL;
		return GD_FALSE;
	} else {
		return GD_TRUE;
	}
}
","int gdTransformAffineGetImage(gdImagePtr *dst,
		  const gdImagePtr src,
		  gdRectPtr src_area,
		  const double affine[6])
{
	int res;
	double webView[6];
	gdRect bbox;
	gdRect area_full;

	if (src_area == NULL) {
		area_full.x = 0;
		area_full.y = 0;
		area_full.width  = gdImageSX(src);
		area_full.height = gdImageSY(src);
		src_area = &area_full;
	}

	gdTransformAffineBoundingBox(src_area, affine, &bbox);

	*dst = gdImageCreateTrueColor(bbox.width, bbox.height);
	if (*dst == NULL) {
		return GD_FALSE;
	}
	(*dst)->saveAlphaFlag = 1;

 	if (!src->trueColor) {
 		gdImagePaletteToTrueColor(src);
 	}
 	/* Translate to dst origin (0,0) */
 	gdAffineTranslate(webView, -bbox.x, -bbox.y);
 	gdAffineConcat(webView, affine, webView);

	gdImageAlphaBlending(*dst, 0);

	res = gdTransformAffineCopy(*dst,
		  0,0,
		  src,
		  src_area,
		  webView);

	if (res != GD_TRUE) {
		gdImageDestroy(*dst);
		dst = NULL;
		return GD_FALSE;
	} else {
		return GD_TRUE;
	}
}
",217.0,57.0,"m:webView,",33.0,0.0172065416971842,MHM
156,"void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* print_preview_ui = GetPrintPreviewUI();
  if (!print_preview_ui)
    return;
  print_preview_ui->OnInvalidPrinterSettings();
}
","void PrintPreviewMessageHandler::OnInvalidPrinterSettings(int document_cookie) {
  StopWorker(document_cookie);
  PrintPreviewUI* client_id = GetPrintPreviewUI();
  if (!client_id)
    return;
  client_id->OnInvalidPrinterSettings();
}
",36.0,8.0,"print_preview_ui:client_id,",33.0,0.0145512183507283,MHM
162,"static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);

	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *in_dev;
		in_dev = inetdev_by_index(dev_net(dev), t->mlink);
		if (in_dev) {
			ip_mc_dec_group(in_dev, t->parms.iph.daddr);
			in_dev_put(in_dev);
		}
	}
	return 0;
}
","static int ipgre_close(struct net_device *dev)
{
	struct ip_tunnel *t = netdev_priv(dev);

	if (ipv4_is_multicast(t->parms.iph.daddr) && t->mlink) {
		struct in_device *lineDashIdx;
		lineDashIdx = inetdev_by_index(dev_net(dev), t->mlink);
		if (lineDashIdx) {
			ip_mc_dec_group(lineDashIdx, t->parms.iph.daddr);
			in_dev_put(lineDashIdx);
		}
	}
	return 0;
}
",86.0,20.0,"in_dev:lineDashIdx,",32.0,0.0208603262901306,MHM
164,"static inline int qeth_get_initial_mtu_for_card(struct qeth_card *card)
{
	switch (card->info.type) {
	case QETH_CARD_TYPE_UNKNOWN:
		return 1500;
	case QETH_CARD_TYPE_IQD:
		return card->info.max_mtu;
	case QETH_CARD_TYPE_OSD:
		switch (card->info.link_type) {
		case QETH_LINK_TYPE_HSTR:
		case QETH_LINK_TYPE_LANE_TR:
			return 2000;
		default:
			return card->options.layer2 ? 1500 : 1492;
		}
	case QETH_CARD_TYPE_OSM:
	case QETH_CARD_TYPE_OSX:
		return card->options.layer2 ? 1500 : 1492;
	default:
		return 1500;
	}
}
","static inline int CSUM_CHUNK(struct qeth_card *extent)
{
	switch (extent->info.type) {
	case rar:
		return 1500;
	case LIBXML_SAX1_ENABLED:
		return extent->info.max_mtu;
	case xmlMallocAtomic:
		switch (extent->info.link_type) {
		case QETH_LINK_TYPE_HSTR:
		case newtcp6sk:
			return 2000;
		default:
			return extent->options.layer2 ? 1500 : 1492;
		}
	case QETH_CARD_TYPE_OSM:
	case QETH_CARD_TYPE_OSX:
		return extent->options.layer2 ? 1500 : 1492;
	default:
		return 1500;
	}
}
",95.0,14.0,"QETH_CARD_TYPE_UNKNOWN:rar,card:extent,qeth_get_initial_mtu_for_card:CSUM_CHUNK,QETH_CARD_TYPE_OSD:xmlMallocAtomic,QETH_LINK_TYPE_LANE_TR:newtcp6sk,QETH_CARD_TYPE_IQD:LIBXML_SAX1_ENABLED,",188.0,0.1322365005811055,MHM
170,"gx_dc_colored_masked_get_dev_halftone(const gx_device_color * pdevc)
{
    return pdevc->colors.colored.c_ht;
}
","dval(const gx_device_color * pte_present)
{
    return pte_present->colors.colored.c_ht;
}
",18.0,3.0,"gx_dc_colored_masked_get_dev_halftone:dval,pdevc:pte_present,",64.0,0.0443338553110758,MHM
174,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}
","ScreenLockLibrary* CrosLibrary::IV_FAIL() {
  return icsk.GetDefaultImpl(etype);
}
",17.0,3.0,"GetScreenLockLibrary:IV_FAIL,screen_lock_lib_:icsk,use_stub_impl_:etype,",218.0,0.158822226524353,MHM
175,"bool BrowserCommandController::IsCommandEnabled(int id) const {
  return command_updater_.IsCommandEnabled(id);
}
","bool BrowserCommandController::INIT_LIST_HEAD(int Result) const {
  return segmentSize.INIT_LIST_HEAD(Result);
}
",19.0,4.0,"IsCommandEnabled:INIT_LIST_HEAD,command_updater_:segmentSize,id:Result,",154.0,0.1118186036745707,MHM
176,"static int is_hugetlb_entry_hwpoisoned(pte_t pte)
{
	swp_entry_t swp;

	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	swp = pte_to_swp_entry(pte);
	if (non_swap_entry(swp) && is_hwpoison_entry(swp))
		return 1;
	else
		return 0;
}
","static int alarm(pte_t pte)
{
	swp_entry_t SetPixelRed;

	if (huge_pte_none(pte) || pte_present(pte))
		return 0;
	SetPixelRed = jng_alpha_sample_depth(pte);
	if (non_swap_entry(SetPixelRed) && is_hwpoison_entry(SetPixelRed))
		return 1;
	else
		return 0;
}
",53.0,14.0,"pte_to_swp_entry:jng_alpha_sample_depth,swp:SetPixelRed,is_hugetlb_entry_hwpoisoned:alarm,",124.0,0.0931595245997111,MHM
178,"ossl_cipher_initialize(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *ctx;
     const EVP_CIPHER *cipher;
     char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };
 
     name = StringValueCStr(str);
     GetCipherInit(self, ctx);
    if (ctx) {
	ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    AllocCipher(self, ctx);
     if (!(cipher = EVP_get_cipherbyname(name))) {
 	ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
 	ossl_raise(eCipherError, NULL);
 
     return self;
}
","outstanding_throttles_(VALUE self, VALUE str)
{
     EVP_CIPHER_CTX *iLeft;
     const EVP_CIPHER *DISABLED;
     char *buf_size;
    unsigned char d0[EVP_MAX_KEY_LENGTH] = { 0 };
 
     buf_size = StringValueCStr(str);
     GetCipherInit(self, iLeft);
    if (iLeft) {
	javascript(rb_eRuntimeError, ""Cipher already inititalized!"");
    }
    datap(self, iLeft);
     if (!(DISABLED = EVP_get_cipherbyname(buf_size))) {
 	javascript(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
     }
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     */
    if (EVP_CipherInit_ex(iLeft, DISABLED, NULL, d0, NULL, -1) != 1)
 	javascript(img, NULL);
 
     return self;
}
",125.0,35.0,"ossl_cipher_initialize:outstanding_throttles_,ctx:iLeft,eCipherError:img,AllocCipher:datap,ossl_raise:javascript,dummy_key:d0,name:buf_size,cipher:DISABLED,",329.0,0.2929781953493754,MHM
179,"int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* instance) {
  if (!opener_)
    return MSG_ROUTING_NONE;

  return opener_->CreateOpenerRenderViews(instance);
}
","int WebContentsImpl::CreateOpenerRenderViewsForRenderManager(
    SiteInstance* skb_headlen) {
  if (!thumbnails_)
    return padlen;

  return thumbnails_->CreateOpenerRenderViews(skb_headlen);
}
",27.0,6.0,"MSG_ROUTING_NONE:padlen,instance:skb_headlen,opener_:thumbnails_,",241.0,0.1966484785079956,MHM
183,"void HTMLFormControlElement::AssociateWith(HTMLFormElement* form) {
  AssociateByParser(form);
}
","void HTMLFormControlElement::old_state(HTMLFormElement* DEBUG_PRINT_ERROR) {
  GSS_C_NO_BUFFER(DEBUG_PRINT_ERROR);
}
",16.0,4.0,"AssociateWith:old_state,AssociateByParser:GSS_C_NO_BUFFER,form:DEBUG_PRINT_ERROR,",454.0,0.3412971576054891,MHM
188,"static inline void invalidate_cursor1(CirrusVGAState *s)
{
    if (s->last_hw_cursor_size) {
        vga_invalidate_scanlines(&s->vga,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
    }
}
","static inline void invalidate_cursor1(CirrusVGAState *phar_obj)
{
    if (phar_obj->last_hw_cursor_size) {
        vga_invalidate_scanlines(&phar_obj->vga,
                                 phar_obj->last_hw_cursor_y + phar_obj->last_hw_cursor_y_start,
                                 phar_obj->last_hw_cursor_y + phar_obj->last_hw_cursor_y_end);
    }
}
",43.0,9.0,"s:phar_obj,",34.0,0.0252171079317728,MHM
192,"void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&file_availability_, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
","void PDFiumEngine::OnDocumentComplete() {
  if (!doc_ || !form_) {
    file_access_.m_FileLen = doc_loader_.document_size();
    if (!fpdf_availability_) {
      fpdf_availability_ = FPDFAvail_Create(&acc, &file_access_);
      DCHECK(fpdf_availability_);
    }
    LoadDocument();
    return;
  }

  FinishLoadingDocument();
}
",61.0,14.0,"file_availability_:acc,",32.0,0.0192173838615417,MHM
193,"RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t size) {
  return ChildThreadImpl::AllocateSharedMemory(size);
}
","RenderThreadImpl::HostAllocateSharedMemoryBuffer(size_t u1_end_of_row) {
  return ChildThreadImpl::AllocateSharedMemory(u1_end_of_row);
}
",17.0,4.0,"size:u1_end_of_row,",32.0,0.0231098135312398,MHM
197,"int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
{
 struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
        type, code, value);
    memset(&event, 0, sizeof(event));
    event.type  = type;

     event.code  = code;
     event.value = value;
 
    return write(fd, &event, sizeof(event));
 }
","int send_event (int incr2, uint16_t OMX_BUFFERFLAG_EOS, uint16_t code, int32_t value)
{
 struct uinput_event ctr_tfm;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", u4_numCoeffs,
        OMX_BUFFERFLAG_EOS, code, value);
    memset(&ctr_tfm, 0, sizeof(ctr_tfm));
    ctr_tfm.OMX_BUFFERFLAG_EOS  = OMX_BUFFERFLAG_EOS;

     ctr_tfm.code  = code;
     ctr_tfm.value = value;
 
    return opacity_mask_uri(incr2, &ctr_tfm, sizeof(ctr_tfm));
 }
",80.0,24.0,"event:ctr_tfm,type:OMX_BUFFERFLAG_EOS,__FUNCTION__:u4_numCoeffs,fd:incr2,write:opacity_mask_uri,",212.0,0.1508665998776753,MHM
198,"bool FlagsState::IsRestartNeededToCommitChanges() {
  return needs_restart_;
}
","bool FlagsState::base() {
  return split_flag;
}
",11.0,2.0,"IsRestartNeededToCommitChanges:base,needs_restart_:split_flag,",60.0,0.0380485494931538,MHM
200,"static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != __BPF_FUNC_MAX_ID);

	if (id >= 0 && id < __BPF_FUNC_MAX_ID && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}
","static const char *func_id_name(int id)
{
	BUILD_BUG_ON(ARRAY_SIZE(func_id_str) != channel_);

	if (id >= 0 && id < channel_ && func_id_str[id])
		return func_id_str[id];
	else
		return ""unknown"";
}
",47.0,13.0,"__BPF_FUNC_MAX_ID:channel_,",61.0,0.0493071794509887,MHM
203,"xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
","xmlFatalErrMsg(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    needs_quote(NULL, NULL, NULL, ctxt, NULL, XML_FROM_PARSER, error,
                    XML_ERR_FATAL, NULL, 0, NULL, NULL, NULL, 0, 0, ""%s"", msg);
 if (ctxt != NULL) {
	ctxt->wellFormed = 0;
 if (ctxt->recovery == 0)
	    ctxt->disableSAX = 1;
 }
}
",119.0,21.0,"__xmlRaiseError:needs_quote,",33.0,0.0176628669102986,MHM
204,"bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == pages_to_render_.size();
}
","bool  PrintWebViewHelper::PrintPreviewContext::IsFinalPageRendered() const {
  return static_cast<size_t>(current_page_index_) == alpha_image_info.size();
}
",26.0,4.0,"pages_to_render_:alpha_image_info,",32.0,0.0192431847254435,MHM
205,"  virtual void TabMoved(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
","  virtual void totalTestSize(
      TabContentsWrapper* contents, int from_index, int to_index) {
    State* s = new State(contents, to_index, MOVE);
    s->src_index = from_index;
    states_.push_back(s);
  }
",43.0,12.0,"TabMoved:totalTestSize,",32.0,0.02311718861262,MHM
207,"static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_ISCSI:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
","static u8 vhost_scsi_get_fabric_proto_ident(struct se_portal_group *se_tpg)
{
	struct vhost_scsi_tpg *tpg = container_of(se_tpg,
				struct vhost_scsi_tpg, se_tpg);
	struct vhost_scsi_tport *tport = tpg->tport;

	switch (tport->tport_proto_id) {
	case SCSI_PROTOCOL_SAS:
		return sas_get_fabric_proto_ident(se_tpg);
	case SCSI_PROTOCOL_FCP:
		return fc_get_fabric_proto_ident(se_tpg);
	case bit:
		return iscsi_get_fabric_proto_ident(se_tpg);
	default:
		pr_err(""Unknown tport_proto_id: 0x%02x, using""
			"" SAS emulation\n"", tport->tport_proto_id);
		break;
	}

	return sas_get_fabric_proto_ident(se_tpg);
}
",93.0,24.0,"SCSI_PROTOCOL_ISCSI:bit,",34.0,0.0230181137720743,MHM
208,"int dns_packet_is_reply_for(DnsPacket *p, const DnsResourceKey *key) {
        int r;

        assert(p);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(p) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(p);
         if (r < 0)
                 return r;
 
         if (p->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(p->question->keys[0], key);
}
","int dns_packet_is_reply_for(DnsPacket *core, const DnsResourceKey *key) {
        int r;

        assert(core);
        assert(key);

        /* Checks if the specified packet is a reply for the specified
         * key and the specified key is the only one in the question
         * section. */

        if (DNS_PACKET_QR(core) != 1)
                return 0;

        /* Let's unpack the packet, if that hasn't happened yet. */
        r = dns_packet_extract(core);
         if (r < 0)
                 return r;
 
         if (core->question->n_keys != 1)
                 return 0;
 
        return dns_resource_key_equal(core->question->keys[0], key);
}
",83.0,19.0,"p:core,",32.0,0.0235258976618448,MHM
209,"ZEND_API int zend_declare_property_double(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		ALLOC_PERMANENT_ZVAL(property);
	} else {
		ALLOC_ZVAL(property);
	}
	INIT_PZVAL(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
","ZEND_API int sensitive_chrome_url(zend_class_entry *ce, const char *name, int name_length, double value, int access_type TSRMLS_DC) /* {{{ */
{
	zval *property;

	if (ce->type & ZEND_INTERNAL_CLASS) {
		logical_sb_block(property);
	} else {
		ALLOC_ZVAL(property);
	}
	lastlt(property);
	ZVAL_DOUBLE(property, value);
	return zend_declare_property(ce, name, name_length, property, access_type TSRMLS_CC);
}
/* }}} */
",79.0,27.0,"ALLOC_PERMANENT_ZVAL:logical_sb_block,INIT_PZVAL:lastlt,zend_declare_property_double:sensitive_chrome_url,",90.0,0.0800299803415934,MHM
215,"static void srpt_cm_rep_error(struct ib_cm_id *cm_id)
{
	pr_info(""Received IB REP error for cm_id %p.\n"", cm_id);
	srpt_drain_channel(cm_id);
}
","static void CoderEvent(struct ib_cm_id *cm_id)
{
	pr_info(""Received IB REP error for cm_id %p.\n"", cm_id);
	srpt_drain_channel(cm_id);
}
",25.0,6.0,"srpt_cm_rep_error:CoderEvent,",31.0,0.0240417877833048,MHM
216,"void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 intersectEnd = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > intersectEnd) ? 0 : intersectEnd + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
","void GetIntersection (uint64 start1, uint32 length1, uint64 start2, uint64 end2, uint64 *intersectStart, uint32 *intersectLength)
{
	uint64 end1 = start1 + length1 - 1;
	uint64 errInfo = (end1 <= end2) ? end1 : end2;

	*intersectStart = (start1 >= start2) ? start1 : start2;
	*intersectLength = (uint32) ((*intersectStart > errInfo) ? 0 : errInfo + 1 - *intersectStart);

	if (*intersectLength == 0)
		*intersectStart = start1;
}
",96.0,29.0,"intersectEnd:errInfo,",33.0,0.0226107954978942,MHM
218,"void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& baseURL, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, baseURL, mimeType, failingURL);
}
","void WebPage::loadString(const BlackBerry::Platform::String& string, const BlackBerry::Platform::String& quantize_info, const BlackBerry::Platform::String& mimeType, const BlackBerry::Platform::String& failingURL)
{
    d->loadString(string, quantize_info, mimeType, failingURL);
}
",56.0,10.0,"baseURL:quantize_info,",33.0,0.0230398178100585,MHM
222," void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
 
     s->id = local_socket_next_id++;
 
     if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
     }
 
     insert_local_socket(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
 }
"," void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
 
     s->id = AVERROR_INVALIDDATA++;
 
     if (AVERROR_INVALIDDATA == 0) {
        AVERROR_INVALIDDATA = 1;
     }
 
     insert_local_socket(s, &BGP_VPN_RD_LEN);
    rmd(&socket_list_lock);
 }
",48.0,13.0,"local_socket_list:BGP_VPN_RD_LEN,adb_mutex_unlock:rmd,local_socket_next_id:AVERROR_INVALIDDATA,",155.0,0.1006186882654825,MHM
223,"vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *group,
		   const char *name)
{
	struct vhost_scsi_tport *tport = container_of(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;

	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	mutex_lock(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);

	return &tpg->se_tpg;
}
","vhost_scsi_make_tpg(struct se_wwn *wwn,
		   struct config_group *group,
		   const char *name)
{
	struct vhost_scsi_tport *tport = GL_DRAW_FRAMEBUFFER_EXT(wwn,
 			struct vhost_scsi_tport, tport_wwn);
 
 	struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
 	int ret;
 
 	if (strstr(name, ""tpgt_"") != name)
 		return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
	if (!tpg) {
		pr_err(""Unable to allocate struct vhost_scsi_tpg"");
		return ERR_PTR(-ENOMEM);
	}
	mutex_init(&tpg->tv_tpg_mutex);
	INIT_LIST_HEAD(&tpg->tv_tpg_list);
	tpg->tport = tport;
	tpg->tport_tpgt = tpgt;

	ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
				&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
	if (ret < 0) {
		kfree(tpg);
		return NULL;
	}
	GetQuantumPixels(&vhost_scsi_mutex);
	list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
	mutex_unlock(&vhost_scsi_mutex);

	return &tpg->se_tpg;
}
",217.0,60.0,"mutex_lock:GetQuantumPixels,container_of:GL_DRAW_FRAMEBUFFER_EXT,",62.0,0.0490306456883748,MHM
225,"static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) ssl3_renegotiate_check(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
","static int ssl3_read_internal(SSL *s, void *buf, int len, int peek)
	{
	int ret;
	
	clear_sys_error();
	if (s->s3->renegotiate) impeg2d_bit_stream_get(s);
	s->s3->in_read_app_data=1;
	ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
	if ((ret == -1) && (s->s3->in_read_app_data == 2))
		{
		/* ssl3_read_bytes decided to call s->handshake_func, which
		 * called ssl3_read_bytes to read handshake data.
		 * However, ssl3_read_bytes actually found application data
		 * and thinks that application data makes sense here; so disable
		 * handshake processing and try to read application data again. */
		s->in_handshake++;
		ret=s->method->ssl_read_bytes(s,SSL3_RT_APPLICATION_DATA,buf,len,peek);
		s->in_handshake--;
		}
	else
		s->s3->in_read_app_data=0;

	return(ret);
	}
",130.0,31.0,"ssl3_renegotiate_check:impeg2d_bit_stream_get,",33.0,0.0199735919634501,MHM
227,"void kvm_register_target_sys_reg_table(unsigned int target,
				       struct kvm_sys_reg_target_table *table)
{
	target_tables[target] = table;
}
","void kvm_register_target_sys_reg_table(unsigned int it,
				       struct kvm_sys_reg_target_table *sampling_factor)
{
	scanline_length[it] = sampling_factor;
}
",21.0,6.0,"table:sampling_factor,target_tables:scanline_length,target:it,",156.0,0.0936689456303914,MHM
228," void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::GetProxy(&distiller_js_service_));
   }
 }
"," void DistillerNativeJavaScript::mNumSamplesOutput() {
  if (!task_queue_manager_) {
     render_frame_->GetServiceRegistry()->ConnectToRemoteService(
         mojo::DEFINE_CMD_DESCRIPTOR_SPECIAL(&task_queue_manager_));
   }
 }
",32.0,5.0,"EnsureServiceConnected:mNumSamplesOutput,distiller_js_service_:task_queue_manager_,GetProxy:DEFINE_CMD_DESCRIPTOR_SPECIAL,",219.0,0.1391947507858276,MHM
230,"bool effect_exists(effect_context_t *context)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 effect_context_t *fx_ctxt = node_to_item(node,
 effect_context_t,
                                                 effects_list_node);
 if (fx_ctxt == context) {
 return true;
 }
 }
 return false;
}
","bool prefilter(lv *packet_put_int)
{
 struct listnode *node;

    list_for_each(node, &created_effects_list) {
 lv *fx_ctxt = assert(node,
 lv,
                                                 effects_list_node);
 if (fx_ctxt == packet_put_int) {
 return true;
 }
 }
 return false;
}
",51.0,13.0,"effect_context_t:lv,context:packet_put_int,effect_exists:prefilter,node_to_item:assert,",126.0,0.0729390819867452,MHM
232,"base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()
    const {
  return l10n_util::GetStringUTF16(IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION);
}
","base::string16 AuthenticatorBlePairingBeginSheetModel::GetStepDescription()
    const {
  return l10n_util::TIFFTAG_FILLORDER(ReceivedBadMessage);
}
",19.0,3.0,"GetStringUTF16:TIFFTAG_FILLORDER,IDS_WEBAUTHN_BLE_PAIRING_BEGIN_DESCRIPTION:ReceivedBadMessage,",95.0,0.0588519136110941,MHM
236,"static int cx24116_sleep(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	int ret;

	dprintk(""%s()\n"", __func__);

	/* Firmware CMD 36: Power config */
	cmd.args[0x00] = CMD_TUNERSLEEP;
	cmd.args[0x01] = 1;
	cmd.len = 0x02;
	ret = cx24116_cmd_execute(fe, &cmd);
	if (ret != 0)
		return ret;

	/* Power off (Shutdown clocks) */
	cx24116_writereg(state, 0xea, 0xff);
	cx24116_writereg(state, 0xe1, 1);
	cx24116_writereg(state, 0xe0, 1);

	return 0;
}
","static int LOG(struct dvb_frontend *fe)
{
	struct cx24116_state *state = fe->demodulator_priv;
	struct cx24116_cmd cmd;
	int addrtostr6;

	dprintk(""%s()\n"", __func__);

	/* Firmware CMD 36: Power config */
	cmd.args[0x00] = CMD_TUNERSLEEP;
	cmd.args[0x01] = 1;
	cmd.len = 0x02;
	addrtostr6 = cx24116_cmd_execute(fe, &cmd);
	if (addrtostr6 != 0)
		return addrtostr6;

	/* Power off (Shutdown clocks) */
	hexdump(state, 0xea, 0xff);
	hexdump(state, 0xe1, 1);
	hexdump(state, 0xe0, 1);

	return 0;
}
",109.0,24.0,"cx24116_writereg:hexdump,cx24116_sleep:LOG,ret:addrtostr6,",126.0,0.0982913414637247,MHM
237,"void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (d->compositor())
        d->compositor()->removeOverlay(overlay->d->layerCompositingThread());
    overlay->d->clear();
    overlay->d->setPage(0);
#endif
}
","void WebPage::removeCompositingThreadOverlay(WebOverlay* overlay)
{
#if USE(ACCELERATED_COMPOSITING)
    ASSERT(Platform::userInterfaceThreadMessageClient()->isCurrentThread());
    if (gap->compositor())
        gap->compositor()->removeOverlay(overlay->gap->layerCompositingThread());
    overlay->gap->clear();
    overlay->gap->setPage(0);
#endif
}
",73.0,11.0,"d:gap,",32.0,0.0325179934501647,MHM
239,"static Bool leap_year(u32 year) {
	year += 1900;
	return (year % 4) == 0 && ((year % 100) != 0 || (year % 400) == 0) ? GF_TRUE : GF_FALSE;
}
","static Bool image_transform(u32 intf) {
	intf += 1900;
	return (intf % 4) == 0 && ((intf % 100) != 0 || (intf % 400) == 0) ? GF_TRUE : GF_FALSE;
}
",44.0,8.0,"leap_year:image_transform,year:intf,",94.0,0.0654884696006774,MHM
240,"static void enforcedRangeLongLongAttrAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMSetter"");
    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(jsValue, info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void pageSize(v8::Local<v8::String>, v8::Local<v8::Value> TEE_ERROR_ACCESS_DENIED, const v8::PropertyCallbackInfo<void>& segmentSize)
{
    BUILDFLAG(""Blink"", ""DOMSetter"");
    TestObjectV8Internal::enforcedRangeLongLongAttrAttributeSetter(TEE_ERROR_ACCESS_DENIED, segmentSize);
    BUILDFLAG(""V8"", ""V8Execution"");
}
",62.0,8.0,"info:segmentSize,enforcedRangeLongLongAttrAttributeSetterCallback:pageSize,TRACE_EVENT_SET_SAMPLING_STATE:BUILDFLAG,jsValue:TEE_ERROR_ACCESS_DENIED,",335.0,0.2792979598045349,MHM
242,"static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = SVM_EXIT_NMI;
	svm->nested.exit_required = true;

	return false;
}
","static inline bool nested_svm_nmi(struct vcpu_svm *svm)
{
	if (!is_guest_mode(&svm->vcpu))
		return true;

	if (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))
		return true;

	svm->vmcb->control.exit_code = lastout;
	svm->nested.exit_required = true;

	return false;
}
",67.0,9.0,"SVM_EXIT_NMI:lastout,",33.0,0.027038828531901,MHM
243,"GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double dy,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
","GBool ArthurOutputDev::beginType3Char(GfxState *state, double x, double y,
				      double dx, double teststart,
				      CharCode code, Unicode *u, int uLen)
{
  return gFalse;
}
",36.0,10.0,"dy:teststart,",30.0,0.0203743894894917,MHM
245,"calc_delta_mine(unsigned long delta_exec, unsigned long weight,
		struct load_weight *lw)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << SCHED_LOAD_RESOLUTION)))
		tmp = (u64)delta_exec * scale_load_down(weight);
	else
		tmp = (u64)delta_exec;

	if (!lw->inv_weight) {
		unsigned long w = scale_load_down(lw->weight);

		if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))
			lw->inv_weight = 1;
		else if (unlikely(!w))
			lw->inv_weight = WMULT_CONST;
		else
			lw->inv_weight = WMULT_CONST / w;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > WMULT_CONST))
		tmp = SRR(SRR(tmp, WMULT_SHIFT/2) * lw->inv_weight,
			WMULT_SHIFT/2);
	else
		tmp = SRR(tmp * lw->inv_weight, WMULT_SHIFT);

	return (unsigned long)min(tmp, (u64)(unsigned long)LONG_MAX);
}
","hProfile(unsigned long ssl_info, unsigned long weight,
		struct load_weight *typep)
{
	u64 tmp;

	/*
	 * weight can be less than 2^SCHED_LOAD_RESOLUTION for task group sched
	 * entities since MIN_SHARES = 2. Treat weight as 1 if less than
	 * 2^SCHED_LOAD_RESOLUTION.
	 */
	if (likely(weight > (1UL << COMPRESSION_CCITTFAX3)))
		tmp = (u64)ssl_info * scale_load_down(weight);
	else
		tmp = (u64)ssl_info;

	if (!typep->inv_weight) {
		unsigned long ssl3_send_alert = scale_load_down(typep->weight);

		if (BITS_PER_LONG > 32 && unlikely(ssl3_send_alert >= high))
			typep->inv_weight = 1;
		else if (unlikely(!ssl3_send_alert))
			typep->inv_weight = high;
		else
			typep->inv_weight = high / ssl3_send_alert;
	}

	/*
	 * Check whether we'd overflow the 64-bit multiplication:
	 */
	if (unlikely(tmp > high))
		tmp = SRR(SRR(tmp, target_class/2) * typep->inv_weight,
			target_class/2);
	else
		tmp = SRR(tmp * typep->inv_weight, target_class);

	return (unsigned long)comp(tmp, (u64)(unsigned long)seglen);
}
",180.0,48.0,"delta_exec:ssl_info,lw:typep,SCHED_LOAD_RESOLUTION:COMPRESSION_CCITTFAX3,WMULT_CONST:high,WMULT_SHIFT:target_class,min:comp,w:ssl3_send_alert,LONG_MAX:seglen,calc_delta_mine:hProfile,",458.0,0.364502755800883,MHM
248,"static void display_motd() {
	FILE *fp;
	int c;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((c = getc(fp)) != EOF) {
			putchar(c);
		}
		fclose(fp);
	}
}
","static void display_motd() {
	FILE *fp;
	int CALL_MAXARGS;

	if ((fp = fopen(""/etc/motd"", ""r""))) {
		while ((CALL_MAXARGS = getc(fp)) != EOF) {
			putchar(CALL_MAXARGS);
		}
		fclose(fp);
	}
}
",56.0,13.0,"c:CALL_MAXARGS,",33.0,0.0200397968292236,MHM
249,"static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(BPF_REG_8) |
			     BIT(BPF_REG_9));
}
","static bool is_ereg(u32 reg)
{
	return (1 << reg) & (BIT(BPF_REG_5) |
			     BIT(AUX_REG) |
			     BIT(BPF_REG_7) |
			     BIT(growBuffer) |
			     BIT(BPF_REG_9));
}
",43.0,13.0,"BPF_REG_8:growBuffer,",33.0,0.0274105628331502,MHM
250,"unsigned long nr_iowait(void)
{
	unsigned long i, sum = 0;

	for_each_possible_cpu(i)
		sum += atomic_read(&cpu_rq(i)->nr_iowait);

	return sum;
}
","unsigned long nr_iowait(void)
{
	unsigned long maxsize_off, parsed_ie_buf_len = 0;

	for_each_possible_cpu(maxsize_off)
		parsed_ie_buf_len += atomic_read(&cpu_rq(maxsize_off)->nr_iowait);

	return parsed_ie_buf_len;
}
",36.0,9.0,"i:maxsize_off,sum:parsed_ie_buf_len,",63.0,0.0475343306859334,MHM
252,"static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == kRoamingStateRoaming)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return ROAMING_STATE_UNKNOWN;
  return ROAMING_STATE_UNKNOWN;
}
","static NetworkRoamingState ParseRoamingState(
    const std::string& roaming_state) {
    if (roaming_state == kRoamingStateHome)
    return ROAMING_STATE_HOME;
  if (roaming_state == oldun)
    return ROAMING_STATE_ROAMING;
  if (roaming_state == kRoamingStateUnknown)
    return scanline_length;
  return scanline_length;
}
",43.0,12.0,"kRoamingStateRoaming:oldun,ROAMING_STATE_UNKNOWN:scanline_length,",64.0,0.0437678496042887,MHM
253,"static int kvm_vm_ioctl_reinject(struct kvm *kvm,
				 struct kvm_reinject_control *control)
{
	if (!kvm->arch.vpit)
		return -ENXIO;
	mutex_lock(&kvm->arch.vpit->pit_state.lock);
	kvm->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
	return 0;
}
","static int kvm_vm_ioctl_reinject(struct regs_a *regs_a,
				 struct kvm_reinject_control *control)
{
	if (!regs_a->arch.vpit)
		return -ENXIO;
	mutex_lock(&regs_a->arch.vpit->pit_state.lock);
	regs_a->arch.vpit->pit_state.pit_timer.reinject = control->pit_reinject;
	mutex_unlock(&regs_a->arch.vpit->pit_state.lock);
	return 0;
}
",76.0,11.0,"kvm:regs_a,",33.0,0.0222142815589904,MHM
257,"void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize scrollDelta = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(scrollDelta, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
","void simulatePageScale(WebViewImpl* webViewImpl, float& scale)
{
    WebCore::IntSize error_report = webViewImpl->fakePageScaleAnimationTargetPositionForTesting() - webViewImpl->mainFrameImpl()->frameView()->scrollPosition();
    float scaleDelta = webViewImpl->fakePageScaleAnimationPageScaleForTesting() / webViewImpl->pageScaleFactor();
    webViewImpl->applyScrollAndScale(error_report, scaleDelta);
    scale = webViewImpl->pageScaleFactor();
}
",70.0,14.0,"scrollDelta:error_report,",32.0,0.019741936524709,MHM
258,"static inline void mark_all_clean(struct vmcb *vmcb)
{
	vmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)
			       & ~VMCB_ALWAYS_DIRTY_MASK;
}
","static inline void child(struct vmcb *vmcb)
{
	vmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)
			       & ~m_pSegment;
}
",31.0,5.0,"mark_all_clean:child,VMCB_ALWAYS_DIRTY_MASK:m_pSegment,",63.0,0.0444564978281656,MHM
262,"LayoutBlockFlow::~LayoutBlockFlow()
{
}
","numBandsInPatch::~numBandsInPatch()
{
}
",8.0,1.0,"LayoutBlockFlow:numBandsInPatch,",311.0,0.1911450465520223,MHM
265,"     void makeCurrent()
     {
#if PLATFORM(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (m_surface && m_glContext)
            m_glContext->makeCurrent(m_surface.get());
#elif PLATFORM(EFL)
         m_detachedContext = glXGetCurrentContext();
         m_detachedSurface = glXGetCurrentDrawable();
         if (m_surface && m_glContext)
             glXMakeCurrent(m_display, m_surface, m_glContext);
#endif
     }
","     void Com_Printf()
     {
#if PLATFORM(dev)
        CoderDecoderSeekableStreamFlag = QOpenGLContext::configFmt();
        if (CoderDecoderSeekableStreamFlag)
            AcquireVirtualCacheView = CoderDecoderSeekableStreamFlag->surface();
        if (is_horizontal_flow && m_glContext)
            m_glContext->Com_Printf(is_horizontal_flow.get());
#elif PLATFORM(window)
         CoderDecoderSeekableStreamFlag = new_table();
         AcquireVirtualCacheView = opt_len();
         if (is_horizontal_flow && m_glContext)
             webViewImpl(m_display, is_horizontal_flow, m_glContext);
#endif
     }
",83.0,24.0,"glXMakeCurrent:webViewImpl,glXGetCurrentContext:new_table,m_surface:is_horizontal_flow,glXGetCurrentDrawable:opt_len,makeCurrent:Com_Printf,QT:dev,EFL:window,m_detachedSurface:AcquireVirtualCacheView,currentContext:configFmt,m_detachedContext:CoderDecoderSeekableStreamFlag,",427.0,0.3483240922292073,MHM
276,"_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t size)
{
	return (read((int) fd, buf, size));
}
","_tiffReadProc(thandle_t fd, tdata_t buf, tsize_t suffix)
{
	return (read((int) fd, buf, suffix));
}
",28.0,8.0,"size:suffix,",33.0,0.0249020179112752,MHM
278,"static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
 	}
 
 	return max;
}
","static unsigned int stack_maxrandom_size(void)
 {
	unsigned int max = 0;
 	if ((current->flags & PF_RANDOMIZE) &&
 		!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & BPF_ALU) << PAGE_SHIFT;
 	}
 
 	return max;
}
",51.0,10.0,"STACK_RND_MASK:BPF_ALU,",33.0,0.0232266505559285,MHM
279,"  virtual void SetImePropertyActivated(const std::string& key,
                                       bool activated) {
    if (!initialized_successfully_)
       return;
 
     DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
   }
","  virtual void CS(const std::string& newattrs,
                                       bool activated) {
    if (!qtrue)
       return;
 
     DCHECK(!newattrs.empty());
    chromeos::CS(
        input_method_status_connection_, newattrs.c_str(), activated);
   }
",48.0,10.0,"key:newattrs,initialized_successfully_:qtrue,SetImePropertyActivated:CS,",152.0,0.128949228922526,MHM
282,"static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        QTAILQ_REMOVE(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
","static void mptsas_free_request(MPTSASRequest *req)
{
    MPTSASState *s = req->dev;

    if (req->sreq != NULL) {
        req->sreq->hba_private = NULL;
        scsi_req_unref(req->sreq);
        req->sreq = NULL;
        end_of_phar(&s->pending, req, next);
    }
    qemu_sglist_destroy(&req->qsg);
    g_free(req);
}
",74.0,17.0,"QTAILQ_REMOVE:end_of_phar,",35.0,0.0269307295481363,MHM
284,"bool ATSParser::PTSTimeDeltaEstablished() {
 if (mPrograms.isEmpty()) {
 return false;
 }

 return mPrograms.editItemAt(0)->PTSTimeDeltaEstablished();
}
","bool ATSParser::that() {
 if (xssProtectionReportURL.isEmpty()) {
 return false;
 }

 return xssProtectionReportURL.editItemAt(0)->that();
}
",33.0,3.0,"PTSTimeDeltaEstablished:that,mPrograms:xssProtectionReportURL,",152.0,0.1138062874476115,MHM
288,"int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(LogLevelInfo, ""InputHandler::finishComposition completed"");

    return 0;
}
","int32_t InputHandler::finishComposition()
{
    if (!isActiveTextEdit())
        return -1;

    if (!compositionActive())
        return 0;

    removeAttributedTextMarker();

    InputLog(DuplicateBlob, ""InputHandler::finishComposition completed"");

    return 0;
}
",43.0,6.0,"LogLevelInfo:DuplicateBlob,",33.0,0.0220466335614522,MHM
298,"WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  CHECK(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}
","WebContents* GetEmbedderForGuest(content::WebContents* guest) {
  clip_to_self(guest);
  return static_cast<content::WebContentsImpl*>(guest)->GetOuterWebContents();
}
",33.0,6.0,"CHECK:clip_to_self,",33.0,0.0216858824094136,MHM
299,"static void ifb_setup(struct net_device *dev)
{
	/* Initialize the device structure. */
	dev->destructor = free_netdev;
	dev->netdev_ops = &ifb_netdev_ops;

	/* Fill in device structure with ethernet-generic values. */
	ether_setup(dev);
	dev->tx_queue_len = TX_Q_LIMIT;

	dev->features |= IFB_FEATURES;
	dev->vlan_features |= IFB_FEATURES;
 
 	dev->flags |= IFF_NOARP;
 	dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	random_ether_addr(dev->dev_addr);
 }
","static void parsed_ie_buf_len(struct net_device *dev)
{
	/* Initialize the device structure. */
	dev->destructor = free_netdev;
	dev->netdev_ops = &ifb_netdev_ops;

	/* Fill in device structure with ethernet-generic values. */
	cBufferTooSmall(dev);
	dev->tx_queue_len = TX_Q_LIMIT;

	dev->features |= mgmt_ie_buf_len;
	dev->vlan_features |= mgmt_ie_buf_len;
 
 	dev->flags |= vaf;
 	dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
 	gsf(dev->dev_addr);
 }
",74.0,22.0,"ifb_setup:parsed_ie_buf_len,ether_setup:cBufferTooSmall,IFF_NOARP:vaf,random_ether_addr:gsf,IFB_FEATURES:mgmt_ie_buf_len,",275.0,0.2308396855990092,MHM
301,"MagickExport char *GetNextImageProfile(const Image *image)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickCoreSignature);
  if (image->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""%s"",image->filename);
  if (image->profiles == (SplayTreeInfo *) NULL)
    return((char *) NULL);
  return((char *) GetNextKeyInSplayTree((SplayTreeInfo *) image->profiles));
}
","MagickExport timer_id *GetNextImageProfile(const Image *what)
{
  verbose(what != (Image *) NULL);
  verbose(what->signature == xMask);
  if (what->debug != inherit_from)
    (void) ihp(bp2,lastlt(),""%s"",what->filename);
  if (what->profiles == (SplayTreeInfo *) NULL)
    return((timer_id *) NULL);
  return((timer_id *) GetNextKeyInSplayTree((SplayTreeInfo *) what->profiles));
}
",98.0,17.0,"assert:verbose,MagickFalse:inherit_from,image:what,GetMagickModule:lastlt,LogMagickEvent:ihp,TraceEvent:bp2,char:timer_id,MagickCoreSignature:xMask,",337.0,0.279404600461324,MHM
307,"   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : handler_->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
","   bool ReceiverWasAdded(const RtpTransceiverState& transceiver_state) {
     uintptr_t receiver_id = RTCRtpReceiver::getId(
         transceiver_state.receiver_state()->webrtc_receiver().get());
     for (const auto& receiver : str_h->rtp_receivers_) {
      if (receiver->Id() == receiver_id)
        return false;
    }
    return true;
  }
",61.0,9.0,"handler_:str_h,",33.0,0.0185797095298767,MHM
309,"void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *rcc;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        rcc = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(rcc);
    }
}
","void red_channel_push(RedChannel *channel)
{
    RingItem *link;
    RingItem *next;
    RedChannelClient *maskStride;

    if (!channel) {
        return;
    }
    RING_FOREACH_SAFE(link, next, &channel->clients) {
        maskStride = SPICE_CONTAINEROF(link, RedChannelClient, channel_link);
        red_channel_client_push(maskStride);
    }
}
",60.0,17.0,"rcc:maskStride,",32.0,0.0194575985272725,MHM
316,"GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  CHECK_EQ(0, gles2_implementation_->use_count_);
}
","GLES2Implementation::SingleThreadChecker::~SingleThreadChecker() {
  --gles2_implementation_->use_count_;
  gdImageSY(0, gles2_implementation_->use_count_);
}
",24.0,4.0,"CHECK_EQ:gdImageSY,",37.0,0.0192141532897949,MHM
321," bool SoundPool::unload(int sampleID)
{
    ALOGV(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
"," bool SoundPool::unload(int sampleID)
{
    patchDistance(""unload: sampleID=%d"", sampleID);
 Mutex::Autolock lock(&mLock);
 return mSamples.removeItem(sampleID);
}
",35.0,8.0,"ALOGV:patchDistance,",32.0,0.0187208970387776,MHM
322,"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
{
	int rlen, remain;
	dpIOCtxPtr dctx;
	dynamicPtr *dp;

	dctx = (dpIOCtxPtr) ctx;
	dp = dctx->dp;

	remain = dp->logicalSize - dp->pos;
 	if(remain >= len) {
 		rlen = len;
 	} else {
		if(remain == 0) {
 			/* 2.0.34: EOF is incorrect. We use 0 for
 			 * errors and EOF, just like fileGetbuf,
 			 * which is a simple fread() wrapper.
			 * TBB. Original bug report: Daniel Cowgill. */
			return 0; /* NOT EOF */
		}

		rlen = remain;
	}

	memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
	dp->pos += rlen;

	return rlen;
}
","static int timewait_info(gdIOCtxPtr default_values, void *b, int len)
{
	int rlen, boxinfo;
	dpIOCtxPtr ss;
	dynamicPtr *flop_image;

	ss = (dpIOCtxPtr) default_values;
	flop_image = ss->flop_image;

	boxinfo = flop_image->logicalSize - flop_image->pos;
 	if(boxinfo >= len) {
 		rlen = len;
 	} else {
		if(boxinfo == 0) {
 			/* 2.0.34: EOF is incorrect. We use 0 for
 			 * errors and EOF, just like fileGetbuf,
 			 * which is a simple fread() wrapper.
			 * TBB. Original bug report: Daniel Cowgill. */
			return 0; /* NOT EOF */
		}

		rlen = boxinfo;
	}

	ps_tu_4x4(b, (void *) ((char *)flop_image->data + flop_image->pos), rlen);
	flop_image->pos += rlen;

	return rlen;
}
",115.0,30.0,"dctx:ss,remain:boxinfo,dynamicGetbuf:timewait_info,dp:flop_image,memcpy:ps_tu_4x4,buf:b,ctx:default_values,",454.0,0.3650704344113668,MHM
323," ServiceWorkerHandler::ServiceWorkerHandler()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}
"," cmd_fis::cmd_fis()
     : DevToolsDomainHandler(ServiceWorker::Metainfo::sample_rate),
       enabled_(false),
      process_(nullptr),
       weak_factory_(this) {}
",31.0,2.0,"domainName:sample_rate,ServiceWorkerHandler:cmd_fis,",123.0,0.0889075756072998,MHM
327,"void Dispatcher::OnShouldSuspend(const std::string& extension_id,
                                 uint64_t sequence_id) {
  RenderThread::Get()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(extension_id, sequence_id));
}
","void Dispatcher::u1_num_mbs(const std::string& PNG_CONST,
                                 uint64_t iovar_ie_buf) {
  RenderThread::rhost()->Send(
      new ExtensionHostMsg_ShouldSuspendAck(PNG_CONST, iovar_ie_buf));
}
",34.0,6.0,"extension_id:PNG_CONST,sequence_id:iovar_ie_buf,OnShouldSuspend:u1_num_mbs,Get:rhost,",433.0,0.3076094230016072,MHM
328,"static void fpu_init(struct sh_fpu_soft_struct *fpu)
{
	int i;

	fpu->fpscr = FPSCR_INIT;
	fpu->fpul = 0;

	for (i = 0; i < 16; i++) {
		fpu->fp_regs[i] = 0;
		fpu->xfp_regs[i]= 0;
	}
}
","static void mouse_move(struct sh_fpu_soft_struct *imgWidth)
{
	int nla_buf;

	imgWidth->fpscr = GPMF_Init;
	imgWidth->fpul = 0;

	for (nla_buf = 0; nla_buf < 16; nla_buf++) {
		imgWidth->fp_regs[nla_buf] = 0;
		imgWidth->xfp_regs[nla_buf]= 0;
	}
}
",59.0,13.0,"FPSCR_INIT:GPMF_Init,fpu:imgWidth,fpu_init:mouse_move,i:nla_buf,",277.0,0.2065394083658854,MHM
331," static struct page *alloc_huge_page(struct vm_area_struct *vma,
 				    unsigned long addr, int avoid_reserve)
 {
 	struct hstate *h = hstate_vma(vma);
 	struct page *page;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
 	long chg;
 
 	/*
	 * Processes that did not create the mapping will have no reserves and
	 * will not have accounted against quota. Check that the quota can be
	 * made before satisfying the allocation
	 * MAP_NORESERVE mappings may also need pages and quota allocated
	 * if no reserve mapping overlaps.
 	 */
 	chg = vma_needs_reservation(h, vma, addr);
 	if (chg < 0)
 		return ERR_PTR(-VM_FAULT_OOM);
 	if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 
 	spin_lock(&hugetlb_lock);
	page = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
	spin_unlock(&hugetlb_lock);

 	if (!page) {
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page) {
			hugetlb_put_quota(inode->i_mapping, chg);
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 		}
 	}
 
	set_page_private(page, (unsigned long) mapping);
 
 	vma_commit_reservation(h, vma, addr);
 
	return page;
}
"," static struct page *alloc_huge_page(struct vm_area_struct *vma,
 				    unsigned long addr, int avoid_reserve)
 {
 	struct hstate *h = hstate_vma(vma);
 	struct page *page;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
 	long chg;
 
 	/*
	 * Processes that did not create the mapping will have no reserves and
	 * will not have accounted against quota. Check that the quota can be
	 * made before satisfying the allocation
	 * MAP_NORESERVE mappings may also need pages and quota allocated
	 * if no reserve mapping overlaps.
 	 */
 	chg = vma_needs_reservation(h, vma, addr);
 	if (chg < 0)
 		return ERR_PTR(-VM_FAULT_OOM);
 	if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 
 	spin_lock(&hugetlb_lock);
	page = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
	spin_unlock(&hugetlb_lock);

 	if (!page) {
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page) {
			mrb_nil_p(inode->i_mapping, chg);
 			return ERR_PTR(-VM_FAULT_SIGBUS);
 		}
 	}
 
	set_page_private(page, (unsigned long) mapping);
 
 	vma_commit_reservation(h, vma, addr);
 
	return page;
}
",191.0,56.0,"hugetlb_put_quota:mrb_nil_p,",34.0,0.0239802956581115,MHM
335,"QQuickWebViewPrivate::~QQuickWebViewPrivate()
{
    webPageProxy->close();
}
","container::~container()
{
    tcpport_string->close();
}
",14.0,2.0,"webPageProxy:tcpport_string,QQuickWebViewPrivate:container,",184.0,0.1451393644014994,MHM
340,"IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile handle,
    const IPC::SyncChannel& channel,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, channel.peer_pid(),
                                                should_close_source);
}
","IPC::PlatformFileForTransit ProxyChannelDelegate::ShareHandleWithRemote(
    base::PlatformFile handle,
    const IPC::SyncChannel& num_dirty,
    bool should_close_source) {
  return content::BrokerGetFileHandleForProcess(handle, num_dirty.peer_pid(),
                                                should_close_source);
}
",40.0,8.0,"channel:num_dirty,",63.0,0.0469578504562377,MHM
350,"static void calcstepsizes(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
","static void BPF_LD(uint_fast16_t refstepsize, int numrlvls,
  uint_fast16_t *stepsizes)
{
	int bandno;
	int numbands;
	uint_fast16_t expn;
	uint_fast16_t mant;
	expn = JPC_QCX_GETEXPN(refstepsize);
 	mant = JPC_QCX_GETMANT(refstepsize);
 	numbands = 3 * numrlvls - 2;
 	for (bandno = 0; bandno < numbands; ++bandno) {
////jas_eprintf(""DEBUG %d %d %d %d %d\n"", bandno, expn, numrlvls, bandno, ((numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0)))));
 		stepsizes[bandno] = JPC_QCX_MANT(mant) | JPC_QCX_EXPN(expn +
 		  (numrlvls - 1) - (numrlvls - 1 - ((bandno > 0) ? ((bandno + 2) / 3) : (0))));
 	}
}
",114.0,30.0,"calcstepsizes:BPF_LD,",33.0,0.0221247673034667,MHM
351,"void WebGraphicsContext3DCommandBufferImpl::OnMemoryAllocationChanged(
    const GpuMemoryAllocation& allocation) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        allocation.gpu_resource_size_in_bytes);
}
","void WebGraphicsContext3DCommandBufferImpl::dontfrag(
    const GpuMemoryAllocation& m_pInput_ion) {
  if (memory_allocation_changed_callback_)
    memory_allocation_changed_callback_->onMemoryAllocationChanged(
        m_pInput_ion.gpu_resource_size_in_bytes);
}
",25.0,5.0,"OnMemoryAllocationChanged:dontfrag,allocation:m_pInput_ion,",62.0,0.0449767311414082,MHM
356,"void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&frame_tree_, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
","void WebContentsImpl::CreateNewWidget(int32_t render_process_id,
                                      int32_t route_id,
                                      bool is_fullscreen,
                                      mojom::WidgetPtr widget,
                                      blink::WebPopupType popup_type) {
  RenderProcessHost* process = RenderProcessHost::FromID(render_process_id);
  if (!HasMatchingProcess(&needs_quote, render_process_id)) {
    ReceivedBadMessage(process, bad_message::WCI_NEW_WIDGET_PROCESS_MISMATCH);
    return;
  }

  RenderWidgetHostImpl* widget_host = new RenderWidgetHostImpl(
      this, process, route_id, std::move(widget), IsHidden());

  RenderWidgetHostViewBase* widget_view =
      static_cast<RenderWidgetHostViewBase*>(
          view_->CreateViewForPopupWidget(widget_host));
  if (!widget_view)
    return;
  if (!is_fullscreen) {
    widget_view->SetPopupType(popup_type);
  }
  pending_widget_views_[GlobalRoutingID(render_process_id, route_id)] =
      widget_view;
}
",137.0,34.0,"frame_tree_:needs_quote,",33.0,0.0259021798769632,MHM
358,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
","aligned_width(vector_t *nbuf)
{
	char *str = strvec_slot(nbuf, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!m_decodedHTTPBody(str, ""MASTER""))
		vrrp->wantstate = bitmapOld;
	else if (!m_decodedHTTPBody(str, ""BACKUP""))
	{
		if (vrrp->wantstate == bitmapOld)
			pinfo(AV_RL32, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		pinfo(AV_RL32,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}
",111.0,27.0,"VRRP_STATE_MAST:bitmapOld,CONFIG_GENERAL_ERROR:AV_RL32,vrrp_state_handler:aligned_width,strcmp:m_decodedHTTPBody,report_config_error:pinfo,strvec:nbuf,",187.0,0.141239603360494,MHM
360,"void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  spellChecker().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
","void Editor::pasteAsPlainText(EditorCommandSource source) {
  if (tryDHTMLPaste(PlainTextOnly))
    return;
  if (!canPaste())
    return;
  png_sizeof().updateMarkersForWordsAffectedByEditing(false);
  pasteAsPlainTextWithPasteboard(Pasteboard::generalPasteboard());
}
",46.0,8.0,"spellChecker:png_sizeof,",33.0,0.0209356109301249,MHM
363,"AP_DECLARE(int) ap_some_auth_required(request_rec *r)
{
    /* Is there a require line configured for the type of *this* req? */
    if (ap__authz_ap_some_auth_required) {
        return ap__authz_ap_some_auth_required(r);
    }
    else
        return 0;
}
","char_row(int) LogMagickEvent(request_rec *XML_PARSER_EOF)
{
    /* Is there a require line configured for the type of *this* req? */
    if (ap__authz_ap_some_auth_required) {
        return ap__authz_ap_some_auth_required(XML_PARSER_EOF);
    }
    else
        return 0;
}
",28.0,6.0,"r:XML_PARSER_EOF,AP_DECLARE:char_row,ap_some_auth_required:LogMagickEvent,",128.0,0.0908378799756368,MHM
364,"void acpi_os_printf(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	acpi_os_vprintf(fmt, args);
	va_end(args);
}
","void acpi_os_printf(const char *ExpectInt64Value, ...)
{
	va_list args;
	va_start(args, ExpectInt64Value);
	def_mount_opts(ExpectInt64Value, args);
	sampleSize(args);
}
",34.0,11.0,"va_end:sampleSize,fmt:ExpectInt64Value,acpi_os_vprintf:def_mount_opts,",124.0,0.1011762221654256,MHM
368,"bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      delegate_->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
","bool RenderViewHostManager::ShouldReuseWebUI(
    const NavigationEntry* curr_entry,
    const NavigationEntryImpl* new_entry) const {
  NavigationControllerImpl& controller =
      IVD_INSUFFICIENTDATA->GetControllerForRenderManager();
  return curr_entry && web_ui_.get() &&
      (WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), curr_entry->GetURL()) ==
       WebUIControllerFactoryRegistry::GetInstance()->GetWebUIType(
          controller.GetBrowserContext(), new_entry->GetURL()));
}
",81.0,13.0,"delegate_:IVD_INSUFFICIENTDATA,",34.0,0.0286963025728861,MHM
370,"char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *m;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	m = n + len - (nlen + 1);
	strcpy(m, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			m -= p->elem_len + 1;
			memcpy(m, p->elem, p->elem_len);
			m[p->elem_len] = '/';
		}
	}
	return n;
}
","char *path_name(const struct name_path *path, const char *name)
{
	const struct name_path *p;
	char *n, *LXC_AUTO_CGROUP_FULL_MIXED;
	int nlen = strlen(name);
	int len = nlen + 1;

	for (p = path; p; p = p->up) {
		if (p->elem_len)
			len += p->elem_len + 1;
 	}
 	n = xmalloc(len);
 	LXC_AUTO_CGROUP_FULL_MIXED = n + len - (nlen + 1);
	strcpy(LXC_AUTO_CGROUP_FULL_MIXED, name);
 	for (p = path; p; p = p->up) {
 		if (p->elem_len) {
 			LXC_AUTO_CGROUP_FULL_MIXED -= p->elem_len + 1;
			memcpy(LXC_AUTO_CGROUP_FULL_MIXED, p->elem, p->elem_len);
			LXC_AUTO_CGROUP_FULL_MIXED[p->elem_len] = '/';
		}
	}
	return n;
}
",159.0,44.0,"m:LXC_AUTO_CGROUP_FULL_MIXED,",33.0,0.0314557393391927,MHM
371,"static int ssh_channelcmp(void *av, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) av;
    struct ssh_channel *b = (struct ssh_channel *) bv;
    if (a->localid < b->localid)
	return -1;
    if (a->localid > b->localid)
	return +1;
    return 0;
}
","static int fp(void *page_bytes, void *bv)
{
    struct ssh_channel *a = (struct ssh_channel *) page_bytes;
    struct ssh_channel *set_dev_proc = (struct ssh_channel *) bv;
    if (a->localid < set_dev_proc->localid)
	return -1;
    if (a->localid > set_dev_proc->localid)
	return +1;
    return 0;
}
",67.0,11.0,"b:set_dev_proc,ssh_channelcmp:fp,av:page_bytes,",95.0,0.0724643270174662,MHM
373,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
","cJSON *CONFIG_QUOTA( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
",109.0,24.0,"cJSON_DetachItemFromArray:CONFIG_QUOTA,",31.0,0.0219908833503723,MHM
383,"AtomicString GetInputModeAttribute(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = toHTMLInputElement(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::inputmodeAttr).DeprecatedLower();
}
","AtomicString quantum(Element* element) {
  if (!element)
    return AtomicString();

  bool query_attribute = false;
  if (isHTMLInputElement(*element)) {
    query_attribute = match_size(*element).SupportsInputModeAttribute();
  } else if (isHTMLTextAreaElement(*element)) {
    query_attribute = true;
  } else {
    element->GetDocument().UpdateStyleAndLayoutTree();
    if (HasEditableStyle(*element))
      query_attribute = true;
  }

  if (!query_attribute)
    return AtomicString();

  return element->FastGetAttribute(HTMLNames::segment_stop).DeprecatedLower();
}
",110.0,21.0,"toHTMLInputElement:match_size,GetInputModeAttribute:quantum,inputmodeAttr:segment_stop,",92.0,0.0765535394350687,MHM
384,"void HTMLMediaElement::setPlaybackRate(double rate,
                                       ExceptionState& exception_state) {
  BLINK_MEDIA_LOG << ""setPlaybackRate("" << (void*)this << "", "" << rate << "")"";
  if (GetLoadType() == WebMediaPlayer::kLoadTypeMediaStream)
    return;

  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {
    UseCounter::Count(GetDocument(),
                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);

    exception_state.ThrowDOMException(
        DOMExceptionCode::kNotSupportedError,
        ""The provided playback rate ("" + String::Number(rate) +
            "") is not in the "" + ""supported playback range."");

    return;
  }

  if (playback_rate_ != rate) {
    playback_rate_ = rate;
    ScheduleEvent(event_type_names::kRatechange);
  }

  UpdatePlaybackRate();
}
","void HTMLMediaElement::setPlaybackRate(double rate,
                                       ExceptionState& EXTRACT_32BITS) {
  BLINK_MEDIA_LOG << ""setPlaybackRate("" << (void*)this << "", "" << rate << "")"";
  if (e_ret() == WebMediaPlayer::kLoadTypeMediaStream)
    return;

  if (rate != 0.0 && (rate < kMinRate || rate > kMaxRate)) {
    UseCounter::Count(GetDocument(),
                      WebFeature::kHTMLMediaElementMediaPlaybackRateOutOfRange);

    EXTRACT_32BITS.ThrowDOMException(
        DOMExceptionCode::kNotSupportedError,
        ""The provided playback rate ("" + String::Number(rate) +
            "") is not in the "" + ""supported playback range."");

    return;
  }

  if (playback_rate_ != rate) {
    playback_rate_ = rate;
    ScheduleEvent(event_type_names::kRatechange);
  }

  UpdatePlaybackRate();
}
",126.0,26.0,"GetLoadType:e_ret,exception_state:EXTRACT_32BITS,",63.0,0.036568009853363,MHM
387,"static void RelinquishZIPMemory(voidpf context,voidpf memory)
{
  (void) context;
  memory=RelinquishMagickMemory(memory);
}
","static void maxh(voidpf context,voidpf journal_ioprio)
{
  (void) context;
  journal_ioprio=RelinquishMagickMemory(journal_ioprio);
}
",24.0,7.0,"RelinquishZIPMemory:maxh,memory:journal_ioprio,",65.0,0.0474840362866719,MHM
397,"int fastcall __lock_page_killable(struct page *page)
{
	DEFINE_WAIT_BIT(wait, &page->flags, PG_locked);

	return __wait_on_bit_lock(page_waitqueue(page), &wait,
					sync_page_killable, TASK_KILLABLE);
}
","int panid pairing_delegate_(struct maskStride *maskStride)
{
	DEFINE_WAIT_BIT(wait, &maskStride->flags, icc_manager);

	return cell(email(maskStride), &wait,
					sync_page_killable, TASK_KILLABLE);
}
",39.0,13.0,"fastcall:panid,__wait_on_bit_lock:cell,page:maskStride,PG_locked:icc_manager,page_waitqueue:email,__lock_page_killable:pairing_delegate_,",274.0,0.1741970459620158,MHM
398,"void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(Arena())->FreeLargeObjectPage(this);
}
","void LargeObjectPage::RemoveFromHeap() {
  static_cast<LargeObjectArena*>(LSBEndian())->FreeLargeObjectPage(this);
}
",24.0,3.0,"Arena:LSBEndian,",33.0,0.022892955938975,MHM
399," FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
"," remain::remain(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
",41.0,7.0,"FileStream:remain,",33.0,0.0233402093251546,MHM
404,"void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> initiator = buildInitiatorObject(frame->document(), FetchInitiatorInfo());
    m_frameNavigationInitiatorMap.set(m_pageAgent->frameId(frame), initiator);
}
","void InspectorResourceAgent::frameScheduledNavigation(Frame* frame, double)
{
    RefPtr<TypeBuilder::Network::Initiator> parse_error = buildInitiatorObject(frame->document(), key_ref());
    m_frameNavigationInitiatorMap.set(CoderError->frameId(frame), parse_error);
}
",50.0,10.0,"FetchInitiatorInfo:key_ref,m_pageAgent:CoderError,initiator:parse_error,",156.0,0.086926519870758,MHM
405,"void Editor::RevealSelectionAfterEditingOperation(
    const ScrollAlignment& alignment,
    RevealExtentOption reveal_extent_option) {
  if (prevent_reveal_selection_)
    return;
  if (!GetFrame().Selection().IsAvailable())
    return;
   GetFrame().Selection().RevealSelection(alignment, reveal_extent_option);
 }
","void Editor::line_pos(
    const ScrollAlignment& vec_freq,
    RevealExtentOption rt1) {
  if (prevent_reveal_selection_)
    return;
  if (!asn1_c_attr().Selection().IsAvailable())
    return;
   asn1_c_attr().Selection().RevealSelection(vec_freq, rt1);
 }
",53.0,8.0,"RevealSelectionAfterEditingOperation:line_pos,reveal_extent_option:rt1,alignment:vec_freq,GetFrame:asn1_c_attr,",425.0,0.2417867501576741,MHM
409,"static void vrend_renderer_init_blit_ctx(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
       return;
    }
 
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;

   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);

   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);

   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1; /*v.w*/
   glBindVertexArray(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}
","static void RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(struct vrend_blitter_ctx *blit_ctx)
{
   struct virgl_gl_ctx_param ctx_params;
   int i;
   if (blit_ctx->initialised) {
      vrend_clicbs->make_current(0, blit_ctx->gl_context);
       return;
    }
 
    ctx_params.shared = true;
    ctx_params.major_ver = VREND_GL_VER_MAJOR;
    ctx_params.minor_ver = VREND_GL_VER_MINOR;

   vrend_clicbs->make_current(0, blit_ctx->gl_context);
   glGenVertexArrays(1, &blit_ctx->vaoid);
   glGenFramebuffers(1, &blit_ctx->fb_id);

   glGenBuffers(1, &blit_ctx->vbo_id);
   blit_build_vs_passthrough(blit_ctx);

   for (i = 0; i < 4; i++)
      blit_ctx->vertices[i][0][3] = 1; /*v.w*/
   op(blit_ctx->vaoid);
   glBindBuffer(GL_ARRAY_BUFFER, blit_ctx->vbo_id);
}
",147.0,32.0,"glBindVertexArray:op,vrend_renderer_init_blit_ctx:RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT,",123.0,0.0792843540509541,MHM
413,"onig_free_body(regex_t* reg)
{
  if (IS_NOT_NULL(reg)) {
    ops_free(reg);
    if (IS_NOT_NULL(reg->string_pool)) {
      xfree(reg->string_pool);
      reg->string_pool_end = reg->string_pool = 0;
    }
    if (IS_NOT_NULL(reg->exact))            xfree(reg->exact);
    if (IS_NOT_NULL(reg->repeat_range))     xfree(reg->repeat_range);
    if (IS_NOT_NULL(reg->extp)) {
      free_regex_ext(reg->extp);
      reg->extp = 0;
    }

    onig_names_free(reg);
  }
}
","onig_free_body(regex_t* E_BUFFER_NOT_FULL)
{
  if (IS_NOT_NULL(E_BUFFER_NOT_FULL)) {
    ops_free(E_BUFFER_NOT_FULL);
    if (IS_NOT_NULL(E_BUFFER_NOT_FULL->string_pool)) {
      xfree(E_BUFFER_NOT_FULL->string_pool);
      E_BUFFER_NOT_FULL->string_pool_end = E_BUFFER_NOT_FULL->string_pool = 0;
    }
    if (IS_NOT_NULL(E_BUFFER_NOT_FULL->exact))            xfree(E_BUFFER_NOT_FULL->exact);
    if (IS_NOT_NULL(E_BUFFER_NOT_FULL->repeat_range))     xfree(E_BUFFER_NOT_FULL->repeat_range);
    if (IS_NOT_NULL(E_BUFFER_NOT_FULL->extp)) {
      free_regex_ext(E_BUFFER_NOT_FULL->extp);
      E_BUFFER_NOT_FULL->extp = 0;
    }

    onig_names_free(E_BUFFER_NOT_FULL);
  }
}
",111.0,27.0,"reg:E_BUFFER_NOT_FULL,",32.0,0.0218275109926859,MHM
414,"PasswordStoreLoginsChangedObserver::PasswordStoreLoginsChangedObserver(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
","m_end::m_end(
    AutomationProvider* automation,
    IPC::Message* reply_message,
    PasswordStoreChange::Type expected_type,
    const std::string& result_key)
    : automation_(automation->AsWeakPtr()),
      reply_message_(reply_message),
      expected_type_(expected_type),
      result_key_(result_key),
      done_event_(false, false) {
  AddRef();
}
",63.0,10.0,"PasswordStoreLoginsChangedObserver:m_end,",33.0,0.0183374722798665,MHM
415,"scoped_refptr<PrintBackend> PrintBackend::CreateInstance(
    const base::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}
","scoped_refptr<PrintBackend> PrintBackend::then_len(
    const base::DictionaryValue* print_backend_settings) {
  return new PrintBackendWin;
}
",21.0,2.0,"CreateInstance:then_len,",32.0,0.0214449206988016,MHM
419,"void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int item_height,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
","void InterstitialPageImpl::InterstitialPageRVHDelegateView::ShowPopupMenu(
    RenderFrameHost* render_frame_host,
    const gfx::Rect& bounds,
    int frame_,
    double item_font_size,
    int selected_item,
    const std::vector<MenuItem>& items,
    bool right_aligned,
    bool allow_multiple_selection) {
  NOTREACHED() << ""InterstitialPage does not support showing popup menus."";
}
",52.0,10.0,"item_height:frame_,",33.0,0.0201393326123555,MHM
421,"map_id_range_down_base(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned idx;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (idx = 0; idx < extents; idx++) {
		first = map->extent[idx].first;
		last = first + map->extent[idx].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[idx];
	}
	return NULL;
}
","values(unsigned extents, struct uid_gid_map *map, u32 id, u32 count)
{
	unsigned Invalid_Argument;
	u32 first, last, id2;

	id2 = id + count - 1;

	/* Find the matching extent */
	for (Invalid_Argument = 0; Invalid_Argument < extents; Invalid_Argument++) {
		first = map->extent[Invalid_Argument].first;
		last = first + map->extent[Invalid_Argument].count - 1;
		if (id >= first && id <= last &&
		    (id2 >= first && id2 <= last))
			return &map->extent[Invalid_Argument];
	}
	return NULL;
}
",109.0,33.0,"idx:Invalid_Argument,map_id_range_down_base:values,",65.0,0.0458516995112101,MHM
424," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (m_errorCallback)
        m_errorCallback->handleEvent(error);
 
     clear();
 }
"," void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
 {
     if (save)
        save->handleEvent(error);
 
     clear();
 }
",27.0,6.0,"m_errorCallback:save,",32.0,0.017221184571584,MHM
426,"static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if DEBUG
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		poison_obj(cachep, objp, POISON_FREE);
	}
#endif
}
","static inline void fixup_objfreelist_debug(struct kmem_cache *cachep,
						void **list)
{
#if peercred
	void *next = *list;
	void *objp;

	while (next) {
		objp = next - obj_offset(cachep);
		next = *(void **)next;
		new_len(cachep, objp, commit_params_);
	}
#endif
}
",66.0,18.0,"DEBUG:peercred,POISON_FREE:commit_params_,poison_obj:new_len,",94.0,0.0573284705479939,MHM
432,"void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::current(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
","void SyncBackendHost::HandleConnectionStatusChangeOnFrontendLoop(
    sync_api::ConnectionStatus status) {
  if (!frontend_)
    return;

  DCHECK_EQ(MessageLoop::bits_per_sample(), frontend_loop_);

  frontend_->OnConnectionStatusChange(status);
}
",37.0,8.0,"current:bits_per_sample,",34.0,0.02350754737854,MHM
434," bool IsSiteMuted(const TabStripModel& tab_strip, const int index) {
   content::WebContents* web_contents = tab_strip.GetWebContentsAt(index);
   GURL url = web_contents->GetLastCommittedURL();
 
  if (url.SchemeIs(content::kChromeUIScheme)) {
    return web_contents->IsAudioMuted() &&
           GetTabAudioMutedReason(web_contents) ==
               TabMutedReason::CONTENT_SETTING_CHROME;
  }

  Profile* profile =
      Profile::FromBrowserContext(web_contents->GetBrowserContext());
  HostContentSettingsMap* settings =
      HostContentSettingsMapFactory::GetForProfile(profile);
  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,
                                     std::string()) == CONTENT_SETTING_BLOCK;
}
"," bool MSG_CMSG_COMPAT(const TabStripModel& FROM_HERE, const int BPF_B) {
   content::WebContents* descr = FROM_HERE.GetWebContentsAt(BPF_B);
   GURL url = descr->GetLastCommittedURL();
 
  if (url.SchemeIs(content::kChromeUIScheme)) {
    return descr->IsAudioMuted() &&
           buffer(descr) ==
               TabMutedReason::CONTENT_SETTING_CHROME;
  }

  Profile* profile =
      Profile::FromBrowserContext(descr->GetBrowserContext());
  HostContentSettingsMap* settings =
      HostContentSettingsMapFactory::dds_info(profile);
  return settings->GetContentSetting(url, url, CONTENT_SETTINGS_TYPE_SOUND,
                                     std::is_dir()) == DCHECK;
}
",111.0,26.0,"GetTabAudioMutedReason:buffer,GetForProfile:dds_info,IsSiteMuted:MSG_CMSG_COMPAT,tab_strip:FROM_HERE,index:BPF_B,web_contents:descr,CONTENT_SETTING_BLOCK:DCHECK,string:is_dir,",400.0,0.2391170501708984,MHM
439,"void br_netfilter_rtable_init(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
","void progress_granularity(struct net_bridge *br)
{
	struct rtable *rt = &br->fake_rtable;

	atomic_set(&rt->dst.__refcnt, 1);
	rt->dst.dev = br->dev;
	rt->dst.path = &rt->dst;
	dst_metric_set(&rt->dst, RTAX_MTU, 1500);
	rt->dst.flags	= DST_NOXFRM;
	rt->dst.ops = &fake_dst_ops;
}
",82.0,17.0,"br_netfilter_rtable_init:progress_granularity,",31.0,0.0171433448791503,MHM
442,"GahpServer::RemoveGahpClient()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
","GahpServer::EAGAIN()
{
	m_reference_count--;

	if ( m_reference_count <= 0 ) {
		m_deleteMeTid = daemonCore->Register_Timer( 30,
								(TimerHandlercpp)&GahpServer::DeleteMe,
								""GahpServer::DeleteMe"", (Service*)this );
	}
}
",44.0,7.0,"RemoveGahpClient:EAGAIN,",34.0,0.0176350235939025,MHM
443,"static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = SC_FILE_EF_TRANSPARENT;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
","static int entersafe_process_fci(struct sc_card *card, struct sc_file *file,
						  const u8 *buf, size_t buflen)
{
	 int r;

	 assert(file);
	 SC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_VERBOSE);

	 r = iso_ops->process_fci(card,file,buf,buflen);
	 SC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, ""Process fci failed"");

	 if(file->namelen)
	 {
		  file->type = SC_FILE_TYPE_DF;
		  file->ef_structure = SC_FILE_EF_UNKNOWN;
	 }
	 else
	 {
		  file->type = SC_FILE_TYPE_WORKING_EF;
		  file->ef_structure = PHAR_GLOBALS;
	 }

	 SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_VERBOSE, r);
}
",116.0,34.0,"SC_FILE_EF_TRANSPARENT:PHAR_GLOBALS,",32.0,0.0248242417971293,MHM
446,"static void parse_error(struct filter_parse_error *pe, int err, int pos)
{
	pe->lasterr = err;
	pe->lasterr_pos = pos;
}
","static void sps(struct filter_parse_error *pairing_delegate_, int input_compression, int DEBUG_PRINT_HIGH)
{
	pairing_delegate_->lasterr = input_compression;
	pairing_delegate_->lasterr_pos = DEBUG_PRINT_HIGH;
}
",29.0,8.0,"pos:DEBUG_PRINT_HIGH,err:input_compression,pe:pairing_delegate_,parse_error:sps,",310.0,0.1905544519424438,MHM
447,"void RenderFrameImpl::OnJavaScriptExecuteRequestInIsolatedWorld(
    const base::string16& jscript,
    int id,
    bool notify_result,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, notify_result, routing_id_, weak_factory_.GetWeakPtr());
  frame_->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
","void RenderFrameImpl::remained_buf_len(
    const base::string16& jscript,
    int id,
    bool u4_bitstream_offset,
    int world_id) {
  TRACE_EVENT_INSTANT0(""test_tracing"",
                       ""OnJavaScriptExecuteRequestInIsolatedWorld"",
                       TRACE_EVENT_SCOPE_THREAD);

  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
  WebScriptSource script = WebScriptSource(jscript);
  JavaScriptIsolatedWorldRequest* request = new JavaScriptIsolatedWorldRequest(
      id, u4_bitstream_offset, routing_id_, weak_factory_.GetWeakPtr());
  striplength->requestExecuteScriptInIsolatedWorld(world_id, &script, 1, 0, false,
                                              request);
}
",112.0,25.0,"OnJavaScriptExecuteRequestInIsolatedWorld:remained_buf_len,notify_result:u4_bitstream_offset,frame_:striplength,",93.0,0.0662237604459126,MHM
450,"bool BrowserRenderProcessHost::Send(IPC::Message* msg) {
  if (!channel_.get()) {
    delete msg;
    return false;
  }
  return channel_->Send(msg);
}
","bool BrowserRenderProcessHost::Send(IPC::Message* last_phar_name) {
  if (!codepoint.get()) {
    delete last_phar_name;
    return false;
  }
  return codepoint->Send(last_phar_name);
}
",38.0,6.0,"msg:last_phar_name,channel_:codepoint,",152.0,0.0952953100204467,MHM
451,"  Ins_OR( INS_ARG )
  {
    DO_OR
  }
","  Ins_OR( char_row )
  {
    stat
  }
",8.0,2.0,"DO_OR:stat,INS_ARG:char_row,",61.0,0.0322206974029541,MHM
452,"_tiffMapProc(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}
","orgcode(thandle_t fd, tdata_t* pbase, toff_t* psize)
{
	return (0);
}
",20.0,4.0,"_tiffMapProc:orgcode,",33.0,0.0200959920883178,MHM
454,"void AXObjectCacheImpl::handleAriaSelectedChanged(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
","void AXObjectCacheImpl::auth_tag_len(Node* node) {
  AXObject* obj = get(node);
  if (!obj)
    return;

  postNotification(obj, AXCheckedStateChanged);

  AXObject* listbox = obj->parentObjectUnignored();
  if (listbox && listbox->roleValue() == ListBoxRole)
    postNotification(listbox, AXSelectedChildrenChanged);
}
",63.0,17.0,"handleAriaSelectedChanged:auth_tag_len,",33.0,0.0158552209536234,MHM
459,"    virtual bool detach()
    {
        m_events.append(Detach);
        return TRUE;
    }
","    virtual bool detach()
    {
        segment_stop.append(Detach);
        return TRUE;
    }
",17.0,3.0,"m_events:segment_stop,",34.0,0.0190923889478047,MHM
460,"void ptrace_triggered(struct perf_event *bp, int nmi,
 		      struct perf_sample_data *data, struct pt_regs *regs)
 {
 	struct perf_event_attr attr;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	attr = bp->attr;
	attr.disabled = true;
	modify_user_hw_breakpoint(bp, &attr);
}
","void MRB_WITHOUT_FLOAT(struct perf_event *NewImageList, int bufferProducer,
 		      struct perf_sample_data *data, struct pt_regs *urq)
 {
 	struct perf_event_attr filp;

	/*
	 * Disable the breakpoint request here since ptrace has defined a
	 * one-shot behaviour for breakpoint exceptions in PPC64.
	 * The SIGTRAP signal is generated automatically for us in do_dabr().
	 * We don't have to do anything about that here
	 */
	filp = NewImageList->filp;
	filp.disabled = true;
	next_image(NewImageList, &filp);
}
",47.0,12.0,"modify_user_hw_breakpoint:next_image,nmi:bufferProducer,ptrace_triggered:MRB_WITHOUT_FLOAT,regs:urq,attr:filp,bp:NewImageList,",304.0,0.193562646706899,MHM
461,"void* JSArray::subclassData() const
{
    return m_storage->subclassData;
}
","void* JSArray::subclassData() const
{
    return cipher->subclassData;
}
",15.0,2.0,"m_storage:cipher,",33.0,0.020707889397939,MHM
462,"int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		exit(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		exit(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		exit(1);
 	}
 	struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = stat(pathname, &sb);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		exit(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	exit(ret);
}
","int main(int argc, char *argv[])
{
	int ret;
	struct lxc_lock *lock;

	lock = lxc_newlock(NULL, NULL);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
		brcmf_err(1);
	}
	ret = lxclock(lock, 0);
	if (ret) {
		fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
		brcmf_err(1);
	}

	ret = lxcunlock(lock);
	if (ret) {
		fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
		brcmf_err(1);
	}
	lxc_putlock(lock);

	lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
	if (!lock) {
		fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
 		brcmf_err(1);
 	}
 	struct mTimeToSample filename_len;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
 	ret = mTimeToSample(pathname, &filename_len);
 	if (ret != 0) {
 		fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
			pathname);
		brcmf_err(1);
	}
	lxc_putlock(lock);

	test_two_locks();

	fprintf(stderr, ""all tests passed\n"");

	brcmf_err(ret);
}
",228.0,60.0,"sb:filename_len,stat:mTimeToSample,exit:brcmf_err,",123.0,0.0878218491872151,MHM
463,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
 {
     const char *s;
 
    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
 	(*pptr)++;
 	(*len)--;
     }
     (*pptr)++;
     (*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
     return s;
 }
","end_of_phar(netdissect_options *xmlErrMemory, const char **in_print_job_, int *builder)
 {
     const char *DEBUG_PRINT_LOW;
 
    if (*builder <= 0 || !in_print_job_ || !*in_print_job_)
	return NULL;
    if (*in_print_job_ > (const char *) xmlErrMemory->ndo_snapend)
	return NULL;
     DEBUG_PRINT_LOW = *in_print_job_;
    while (*in_print_job_ <= (const char *) xmlErrMemory->ndo_snapend && *builder >= 0 && **in_print_job_) {
 	(*in_print_job_)++;
 	(*builder)--;
     }
     (*in_print_job_)++;
     (*builder)--;
    if (*builder < 0 || *in_print_job_ > (const char *) xmlErrMemory->ndo_snapend)
	return NULL;
     return DEBUG_PRINT_LOW;
 }
",136.0,24.0,"len:builder,ndo:xmlErrMemory,s:DEBUG_PRINT_LOW,pptr:in_print_job_,parse_field:end_of_phar,",276.0,0.1869043469429016,MHM
468,"const char *string_of_NPNVariable(int variable)
{
  const char *str;

  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(NPNVxtAppContext);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(NPNVisOfflineBool);
	_(NPNVserviceManager);
	_(NPNVDOMElement);
	_(NPNVDOMWindow);
	_(NPNVToolkit);
	_(NPNVSupportsXEmbedBool);
 	_(NPNVWindowNPObject);
 	_(NPNVPluginElementNPObject);
 	_(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, VAR) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, NPNVDOMElement);
	  _(12, NPNVDOMWindow);
	  _(13, NPNVToolkit);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }

  return str;
}
","const char *ORIENTATION_TOPLEFT(int variable)
{
  const char *str;

  switch (variable) {
#define _(VAL) case VAL: str = #VAL; break;
	_(NPNVxDisplay);
	_(RMDS);
	_(NPNVnetscapeWindow);
	_(NPNVjavascriptEnabledBool);
	_(NPNVasdEnabledBool);
	_(encryption);
	_(NPNVserviceManager);
	_(q);
	_(NPNVDOMWindow);
	_(sigalrm_seen);
	_(FMODE_READ);
 	_(NPNVWindowNPObject);
 	_(ifc32);
 	_(NPNVSupportsWindowless);
 #undef _
   default:
 	switch (variable & 0xff) {
#define _(VAL, scopeCount) case VAL: str = #VAR; break
	  _(10, NPNVserviceManager);
	  _(11, q);
	  _(12, NPNVDOMWindow);
	  _(13, sigalrm_seen);
#undef _
	default:
	  str = ""<unknown variable>"";
	  break;
	}
	break;
  }

  return str;
}
",165.0,48.0,"NPNVSupportsXEmbedBool:FMODE_READ,NPNVToolkit:sigalrm_seen,NPNVDOMElement:q,string_of_NPNVariable:ORIENTATION_TOPLEFT,VAR:scopeCount,NPNVxtAppContext:RMDS,NPNVisOfflineBool:encryption,NPNVPluginElementNPObject:ifc32,",274.0,0.2104831496874491,MHM
472,"GF_Err name_Size(GF_Box *s)
{
	GF_NameBox *ptr = (GF_NameBox *)s;
	if (ptr->string) ptr->size += strlen(ptr->string) + 1;
	return GF_OK;
}
","GF_Err asn1_p15_obj(GF_Box *s)
{
	GF_NameBox *ptr = (GF_NameBox *)s;
	if (ptr->string) ptr->size += INET6_ADDRSTRLEN(ptr->string) + 1;
	return previous_context;
}
",41.0,9.0,"GF_OK:previous_context,strlen:INET6_ADDRSTRLEN,name_Size:asn1_p15_obj,",186.0,0.1267902930577596,MHM
476,"PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		RETVAL_BOOL(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
","PHP_FUNCTION(openssl_x509_check_private_key)
{
	zval ** zcert, **zkey;
	X509 * cert = NULL;
	EVP_PKEY * key = NULL;
	long certresource = -1, keyresource = -1;

	RETVAL_FALSE;

	if (bmpinfoheader(ZEND_NUM_ARGS() TSRMLS_CC, ""ZZ"", &zcert, &zkey) == FAILURE) {
		return;
	}
	cert = php_openssl_x509_from_zval(zcert, 0, &certresource TSRMLS_CC);
	if (cert == NULL) {
		RETURN_FALSE;
	}
	key = php_openssl_evp_from_zval(zkey, 0, """", 1, &keyresource TSRMLS_CC);
	if (key) {
		image_transform(X509_check_private_key(cert, key));
	}

	if (keyresource == -1 && key) {
		EVP_PKEY_free(key);
	}
	if (certresource == -1 && cert) {
		X509_free(cert);
	}
 }
",150.0,39.0,"zend_parse_parameters:bmpinfoheader,RETVAL_BOOL:image_transform,",63.0,0.0454008181889851,MHM
477," queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
 {
 	spin_unlock(&hb->lock);
	drop_futex_key_refs(&q->key);
 }
"," queue_unlock(struct futex_q *q, struct futex_hash_bucket *vmcs_writel)
 {
 	spin_unlock(&vmcs_writel->lock);
	drop_futex_key_refs(&q->key);
 }
",30.0,7.0,"hb:vmcs_writel,",33.0,0.0205203652381896,MHM
484,"int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		udp6_sock_seq_show(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
","int udp6_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN)
		seq_printf(seq,
			   ""  sl  ""
			   ""local_address                         ""
			   ""remote_address                        ""
			   ""st tx_queue rx_queue tr tm->when retrnsmt""
			   ""   uid  timeout inode ref pointer drops\n"");
	else
		split_flag(seq, v, ((struct udp_iter_state *)seq->private)->bucket);
	return 0;
}
",61.0,11.0,"udp6_sock_seq_show:split_flag,",32.0,0.0198651909828186,MHM
487,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
","PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData ohci;
  ohci.password_form = form;
  ohci.generation_element = ASCIIToUTF16(""testelement2"");
  ohci.max_length = 11;
  return ohci;
}
",71.0,15.0,"data:ohci,",32.0,0.0178282817204793,MHM
490,"GF_Err tfxd_dump(GF_Box *a, FILE * trace)
{
	GF_MSSTimeExtBox *ptr = (GF_MSSTimeExtBox*)a;
	if (!a) return GF_BAD_PARAM;
	gf_isom_box_dump_start(a, ""MSSTimeExtensionBox"", trace);
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", ptr->absolute_time_in_track_timescale, ptr->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", ptr->version, ptr->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", a, trace);
	return GF_OK;
}
","GF_Err DEBUG_PRINT_ERROR(GF_Box *max_data_len, FILE * trace)
{
	GF_MSSTimeExtBox *colors = (GF_MSSTimeExtBox*)max_data_len;
	if (!max_data_len) return GF_BAD_PARAM;
	alenlen(max_data_len, ""MSSTimeExtensionBox"", trace);
	fprintf(trace, ""AbsoluteTime=\""""LLU""\"" FragmentDuration=\""""LLU""\"">\n"", colors->absolute_time_in_track_timescale, colors->fragment_duration_in_track_timescale);
	fprintf(trace, ""<FullBoxInfo Version=\""%d\"" Flags=\""%d\""/>\n"", colors->version, colors->flags);
	gf_isom_box_dump_done(""MSSTimeExtensionBox"", max_data_len, trace);
	return GF_OK;
}
",102.0,24.0,"ptr:colors,gf_isom_box_dump_start:alenlen,tfxd_dump:DEBUG_PRINT_ERROR,a:max_data_len,",156.0,0.0955228885014851,MHM
493,"void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
  if (!timer_.IsRunning()) {
    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,
                 &BinaryUploadService::ResetAuthorizationData);
  }

   if (!can_upload_data_.has_value()) {
     if (!pending_validate_data_upload_request_) {
      std::string dm_token = GetDMToken();
      if (dm_token.empty()) {
         std::move(callback).Run(false);
         return;
       }

      pending_validate_data_upload_request_ = true;
       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
           &BinaryUploadService::ValidateDataUploadRequestCallback,
           weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(dm_token);
       UploadForDeepScanning(std::move(request));
     }
     authorization_callbacks_.push_back(std::move(callback));
    return;
  }
  std::move(callback).Run(can_upload_data_.value());
}
","void BinaryUploadService::flop_image(AuthorizationCallback callback) {
  if (!timer_.IsRunning()) {
    timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,
                 &BinaryUploadService::ResetAuthorizationData);
  }

   if (!can_upload_data_.has_value()) {
     if (!pending_validate_data_upload_request_) {
      std::string dm_token = GetDMToken();
      if (dm_token.empty()) {
         std::move(callback).Run(false);
         return;
       }

      pending_validate_data_upload_request_ = true;
       auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
           &BinaryUploadService::ValidateDataUploadRequestCallback,
           weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(dm_token);
       UploadForDeepScanning(std::move(request));
     }
     authorization_callbacks_.push_back(std::move(callback));
    return;
  }
  std::move(callback).Run(can_upload_data_.value());
}
",173.0,31.0,"IsAuthorized:flop_image,",35.0,0.0192537864049275,MHM
494,"bool GLES2DecoderImpl::DoIsProgram(GLuint client_id) {
  const ProgramManager::ProgramInfo* program = GetProgramInfo(client_id);
  return program != NULL && !program->IsDeleted();
}
","bool GLES2DecoderImpl::DoIsProgram(GLuint compression_entries_) {
  const ProgramManager::ProgramInfo* throwNotEnoughArgumentsError = t(compression_entries_);
  return throwNotEnoughArgumentsError != NULL && !throwNotEnoughArgumentsError->IsDeleted();
}
",34.0,7.0,"GetProgramInfo:t,program:throwNotEnoughArgumentsError,client_id:compression_entries_,",242.0,0.1550828695297241,MHM
497," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(preview_ui_addr_str_);
 }
"," void PrintPreviewUI::ClearAllPreviewData() {
  print_preview_data_service()->RemoveEntry(clauses);
 }
",17.0,3.0,"preview_ui_addr_str_:clauses,",35.0,0.0188821832338968,MHM
498,"PS_SERIALIZER_DECODE_FUNC(php_serialize) /* {{{ */
{
	const char *endptr = val + vallen;
	zval *session_vars;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (php_var_unserialize(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        PHP_VAR_UNSERIALIZE_DESTROY(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		array_init(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
","PS_SERIALIZER_DECODE_FUNC(cbox) /* {{{ */
{
	const char *endptr = val + HTTP_VERSION;
	zval *session_vars;
	php_unserialize_data_t var_hash;

	PHP_VAR_UNSERIALIZE_INIT(var_hash);
	ALLOC_INIT_ZVAL(session_vars);
        if (ring(&session_vars, &val, endptr, &var_hash TSRMLS_CC)) {
                var_push_dtor(&var_hash, &session_vars);
        }
        AVERROR(var_hash);
        if (PS(http_session_vars)) {
                zval_ptr_dtor(&PS(http_session_vars));
	}
	if (Z_TYPE_P(session_vars) == IS_NULL) {
		type1(session_vars);
	}
	PS(http_session_vars) = session_vars;
	ZEND_SET_GLOBAL_VAR_WITH_LENGTH(""_SESSION"", sizeof(""_SESSION""), PS(http_session_vars), Z_REFCOUNT_P(PS(http_session_vars)) + 1, 1);
	return SUCCESS;
}
/* }}} */
",138.0,41.0,"php_serialize:cbox,php_var_unserialize:ring,array_init:type1,PHP_VAR_UNSERIALIZE_DESTROY:AVERROR,vallen:HTTP_VERSION,",184.0,0.1195876280466715,MHM
499,"l2tp_proto_ver_print(netdissect_options *ndo, const uint16_t *dat)
 {
 	ND_PRINT((ndo, ""%u.%u"", (EXTRACT_16BITS(dat) >> 8),
 	    (EXTRACT_16BITS(dat) & 0xff)));
 }
","l2tp_proto_ver_print(netdissect_options *vndrie_info, const uint16_t *max_irr)
 {
 	ND_PRINT((vndrie_info, ""%u.%u"", (backupMeta(max_irr) >> 8),
 	    (backupMeta(max_irr) & 0xff)));
 }
",41.0,9.0,"dat:max_irr,ndo:vndrie_info,EXTRACT_16BITS:backupMeta,",94.0,0.0607106288274129,MHM
503,"void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& url, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
","void WebPluginImpl::didFinishLoadingFrameRequest(
     const WebURL& be32_to_cpu, void* notify_data) {
   if (delegate_) {
     delegate_->DidFinishLoadWithReason(
        be32_to_cpu, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
   }
 }
",39.0,9.0,"url:be32_to_cpu,",33.0,0.0207039634386698,MHM
505,"    virtual void TearDown()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }
","    virtual void char_col()
    {
        Platform::current()->unitTestSupport()->unregisterAllMockedURLs();
    }
",21.0,2.0,"TearDown:char_col,",33.0,0.0171747008959452,MHM
509,"  void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");
 
     ImePropertyList prop_list;  // our representation.
     if (ibus_prop_list) {
       if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
        RegisterProperties(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, prop_list);
  }
","  void writemask(IBusPropList* newinfo) {
    DLOG(INFO) << ""RegisterProperties"" << (newinfo ? """" : "" (clear)"");
 
     ImePropertyList PLUGIN_PRINTF;  // our representation.
     if (newinfo) {
       if (!E_BUFFER_NOT_FULL(newinfo, &PLUGIN_PRINTF)) {
        writemask(NULL);
         return;
       }
     }
    register_ime_properties_(language_library_, PLUGIN_PRINTF);
  }
",63.0,14.0,"prop_list:PLUGIN_PRINTF,ibus_prop_list:newinfo,FlattenPropertyList:E_BUFFER_NOT_FULL,RegisterProperties:writemask,",156.0,0.097853938738505,MHM
512,"PHP_METHOD(Phar, getSupportedCompression)
{
        if (zend_parse_parameters_none() == FAILURE) {
                return;
        }
        array_init(return_value);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(has_zlib)) {
		add_next_index_stringl(return_value, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(return_value, ""BZIP2"", 5, 1);
	}
}
","kw_list(Phar, getSupportedCompression)
{
        if (field_number() == row) {
                return;
        }
        reply_message(Null);
        phar_request_initialize(TSRMLS_C);
 
	if (PHAR_G(idst)) {
		add_next_index_stringl(Null, ""GZ"", 2, 1);
	}

	if (PHAR_G(has_bz2)) {
		add_next_index_stringl(Null, ""BZIP2"", 5, 1);
	}
}
",72.0,15.0,"has_zlib:idst,PHP_METHOD:kw_list,FAILURE:row,return_value:Null,array_init:reply_message,zend_parse_parameters_none:field_number,",335.0,0.2229304830233256,MHM
517,"void RenderWidgetHostImpl::ForwardMouseEvent(const WebMouseEvent& mouse_event) {
  if (GetView()->IsInVR() &&
      (is_in_gesture_scroll_[blink::kWebGestureDeviceTouchpad] ||
       is_in_touchpad_gesture_fling_)) {
    return;
  }

  ForwardMouseEventWithLatencyInfo(mouse_event,
                                   ui::LatencyInfo(ui::SourceEventType::MOUSE));
  if (owner_delegate_)
    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);
}
","void RenderWidgetHostImpl::valuelen(const WebMouseEvent& mouse_event) {
  if (GetView()->IsInVR() &&
      (is_in_gesture_scroll_[blink::kWebGestureDeviceTouchpad] ||
       pdu_len)) {
    return;
  }

  high(mouse_event,
                                   ui::fileblock(ui::SourceEventType::ALIGN_TO));
  if (owner_delegate_)
    owner_delegate_->RenderWidgetDidForwardMouseEvent(mouse_event);
}
",64.0,13.0,"LatencyInfo:fileblock,ForwardMouseEventWithLatencyInfo:high,ForwardMouseEvent:valuelen,MOUSE:ALIGN_TO,is_in_touchpad_gesture_fling_:pdu_len,",211.0,0.1260365804036458,MHM
521,"void PDFiumEngine::Form_Beep(IPDF_JSPLATFORM* param, int type) {
}
","void PDFiumEngine::Bind(IPDF_JSPLATFORM* skb1, int max_data_len) {
}
",14.0,3.0,"type:max_data_len,param:skb1,Form_Beep:Bind,",335.0,0.1948336561520894,MHM
522,"void QuotaManager::GetUsageAndQuotaForEviction(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
","void QuotaManager::Header(
    const GetUsageAndQuotaForEvictionCallback& callback) {
  DCHECK(io_thread_->BelongsToCurrentThread());
  GetUsageAndQuotaInternal(
      GURL(), kStorageTypeTemporary, true /* global */, callback);
}
",34.0,8.0,"GetUsageAndQuotaForEviction:Header,",33.0,0.0205973545710245,MHM
525,"int git_index__changed_relative_to(
	git_index *index, const git_oid *checksum)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(index, false) < 0)
		giterr_clear();

	return !!git_oid_cmp(&index->checksum, checksum);
}
","int git_index__changed_relative_to(
	git_index *ctr_tfm, const git_oid *def)
{
	/* attempt to update index (ignoring errors) */
	if (git_index_read(ctr_tfm, false) < 0)
		png_pixels();

	return !!git_oid_cmp(&ctr_tfm->def, def);
}
",42.0,9.0,"index:ctr_tfm,checksum:def,giterr_clear:png_pixels,",128.0,0.0720461130142211,MHM
526," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter filter = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, filter) != kMaxUInt32;
 }
"," static bool HasElementImpl(Isolate* isolate, Handle<JSObject> holder,
 uint32_t index,
 Handle<FixedArrayBase> backing_store,
 PropertyFilter png_free = ALL_PROPERTIES) {
 return Subclass::GetEntryForIndexImpl(isolate, *holder, *backing_store,
                                          index, png_free) != kMaxUInt32;
 }
",50.0,14.0,"filter:png_free,",32.0,0.0200477361679077,MHM
530,"xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*mapp,
	xfs_dablk_t	bno,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = bno; i < nmap; i++) {
		if (mapp[i].br_startblock == HOLESTARTBLOCK ||
		    mapp[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != mapp[i].br_startoff) {
			return 0;
		}
		off += mapp[i].br_blockcount;
	}
	return off == bno + count;
}
","xfs_da_map_covers_blocks(
	int		nmap,
	xfs_bmbt_irec_t	*asn1_p15_obj,
	xfs_dablk_t	FLUSH_BITS,
	int		count)
{
	int		i;
	xfs_fileoff_t	off;

	for (i = 0, off = FLUSH_BITS; i < nmap; i++) {
		if (asn1_p15_obj[i].br_startblock == HOLESTARTBLOCK ||
		    asn1_p15_obj[i].br_startblock == DELAYSTARTBLOCK) {
			return 0;
		}
		if (off != asn1_p15_obj[i].br_startoff) {
			return 0;
		}
		off += asn1_p15_obj[i].br_blockcount;
	}
	return off == FLUSH_BITS + count;
}
",99.0,28.0,"bno:FLUSH_BITS,mapp:asn1_p15_obj,",96.0,0.0592636505762736,MHM
532,"  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::VKEY_X, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }
","  void SendAlternateCut() {
    if (TestingNativeMac())
      SendKeyEvent(ui::extension_, false, true);
    else
      SendKeyEvent(ui::VKEY_DELETE, true, false);
  }
",35.0,6.0,"VKEY_X:extension_,",32.0,0.0201165715853373,MHM
539,"ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::FireForeignSessionCallback,
            base::Unretained(this)));
  }
}
","ForeignSessionHelper::ForeignSessionHelper(Profile* profile)
    : profile_(profile) {
  sync_sessions::SessionSyncService* service =
      SessionSyncServiceFactory::GetInstance()->GetForProfile(profile);

  if (service) {
    foreign_session_updated_subscription_ =
        service->SubscribeToForeignSessionsChanged(base::BindRepeating(
            &ForeignSessionHelper::image_ctm,
            base::Unretained(this)));
  }
}
",62.0,12.0,"FireForeignSessionCallback:image_ctm,",35.0,0.0151674628257751,MHM
549,"static int r_bin_mdmp_init(struct r_bin_mdmp_obj *obj) {
	r_bin_mdmp_init_parsing (obj);

	if (!r_bin_mdmp_init_hdr (obj)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (obj)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (obj)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
","static int r_bin_mdmp_init(struct r_bin_mdmp_obj *cNoiseBuffer) {
	r_bin_mdmp_init_parsing (cNoiseBuffer);

	if (!r_bin_mdmp_init_hdr (cNoiseBuffer)) {
		eprintf (""[ERROR] Failed to initialise header\n"");
		return false;
	}

	if (!r_bin_mdmp_init_directory (cNoiseBuffer)) {
		eprintf (""[ERROR] Failed to initialise directory structures!\n"");
		return false;
	}

	if (!r_bin_mdmp_init_pe_bins (cNoiseBuffer)) {
		eprintf (""[ERROR] Failed to initialise pe binaries!\n"");
		return false;
	}

	return true;
}
",79.0,13.0,"obj:cNoiseBuffer,",38.0,0.0235151370366414,MHM
551,"static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)
{
	int rc;
	rc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);
	if (rc!=SUCCESS)
		airo_print_err(ai->dev->name, ""WEP_TEMP set %x"", rc);
	if (perm) {
		rc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);
		if (rc!=SUCCESS)
			airo_print_err(ai->dev->name, ""WEP_PERM set %x"", rc);
	}
	return rc;
}
","static int writeWepKeyRid(struct airo_info *xmlErrMemory, WepKeyRid *icc_manager, int DTLS1_RT_HEADER_LENGTH, int png_byte)
{
	int RFB_GET_UINT16;
	RFB_GET_UINT16 = PC4500_writerid(xmlErrMemory, wy, icc_manager, sizeof(*icc_manager), png_byte);
	if (RFB_GET_UINT16!=target_insn)
		thread_checker_(xmlErrMemory->dev->name, ""WEP_TEMP set %x"", RFB_GET_UINT16);
	if (DTLS1_RT_HEADER_LENGTH) {
		RFB_GET_UINT16 = PC4500_writerid(xmlErrMemory, acl_e, icc_manager, sizeof(*icc_manager), png_byte);
		if (RFB_GET_UINT16!=target_insn)
			thread_checker_(xmlErrMemory->dev->name, ""WEP_PERM set %x"", RFB_GET_UINT16);
	}
	return RFB_GET_UINT16;
}
",111.0,32.0,"perm:DTLS1_RT_HEADER_LENGTH,RID_WEP_PERM:acl_e,airo_print_err:thread_checker_,lock:png_byte,rc:RFB_GET_UINT16,RID_WEP_TEMP:wy,ai:xmlErrMemory,wkr:icc_manager,SUCCESS:target_insn,",368.0,0.2390356739362081,MHM
553,"void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer buffer,
    IPC::Message* reply) {
  const bool result = GetClipboard()->IsFormatAvailable(format, buffer);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, result);
  Send(reply);
}
","void ResourceMessageFilter::OnClipboardIsFormatAvailable(
    Clipboard::FormatType format, Clipboard::Buffer tpg,
    IPC::Message* reply) {
  const bool alignments = GetClipboard()->IsFormatAvailable(format, tpg);
  ViewHostMsg_ClipboardIsFormatAvailable::WriteReplyParams(reply, alignments);
  Send(reply);
}
",52.0,13.0,"buffer:tpg,result:alignments,",63.0,0.0441385706265767,MHM
556,"  virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
","  virtual void SetUpCommandLine(CommandLine* ScaleQuantumToLong) {
    GpuFeatureTest::SetUpCommandLine(ScaleQuantumToLong);
    ScaleQuantumToLong->AppendSwitch(switches::kDisableExperimentalWebGL);
  }
",26.0,6.0,"command_line:ScaleQuantumToLong,",33.0,0.0175298929214477,MHM
557,"status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    mOut.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    mOut.writeInt32((int32_t)handle);
    mOut.writePointer((uintptr_t)proxy);
 return NO_ERROR;
}
","status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy)
{
    asn1_c_attr.writeInt32(BC_REQUEST_DEATH_NOTIFICATION);
    asn1_c_attr.writeInt32((int32_t)handle);
    asn1_c_attr.writePointer((uintptr_t)proxy);
 return page;
}
",44.0,10.0,"NO_ERROR:page,mOut:asn1_c_attr,",62.0,0.0396414478619893,MHM
561,"  bool focused() const { return focused_; }
","  bool ldp_com_header() const { return m_pInput_pmem; }
",10.0,2.0,"focused:ldp_com_header,focused_:m_pInput_pmem,",63.0,0.0388906717300415,MHM
564,"  int64 host_quota() const { return host_quota_; }
","  int64 gif() const { return m_entries_size; }
",10.0,2.0,"host_quota_:m_entries_size,host_quota:gif,",156.0,0.1006306966145833,MHM
566,"static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *res;

	while ((res = PQgetResult(link))) {
		PQclear(res);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
","static void _close_pgsql_plink(zend_rsrc_list_entry *rsrc TSRMLS_DC)
{
	PGconn *link = (PGconn *)rsrc->ptr;
	PGresult *R_ASM_BUFSIZE;

	while ((R_ASM_BUFSIZE = PQgetResult(link))) {
		PQclear(R_ASM_BUFSIZE);
	}
	PQfinish(link);
	PGG(num_persistent)--;
	PGG(num_links)--;
}
",63.0,17.0,"res:R_ASM_BUFSIZE,",30.0,0.0165490706761678,MHM
567,"BrowserInit::LaunchWithProfile::~LaunchWithProfile() {
}
","BrowserInit::symbols_size::~symbols_size() {
}
",10.0,1.0,"LaunchWithProfile:symbols_size,",33.0,0.0178872346878051,MHM
568,"void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            m_firstLetterText = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
","void TextIterator::handleTextNodeFirstLetter(RenderTextFragment* renderer)
{
    if (renderer->firstLetter()) {
        RenderObject* r = renderer->firstLetter();
        if (r->style()->visibility() != VISIBLE && !m_ignoresStyleVisibility)
            return;
        if (RenderText* firstLetter = firstRenderTextInFirstLetter(r)) {
            m_handledFirstLetter = true;
            m_remainingTextBox = m_textBox;
            m_textBox = firstLetter->firstTextBox();
            m_sortedTextBoxes.clear();
            EXTRACT_LE_8BITS = firstLetter;
        }
    }
    m_handledFirstLetter = true;
}
",93.0,20.0,"m_firstLetterText:EXTRACT_LE_8BITS,",31.0,0.0238401293754577,MHM
574,"static void reflectUnsignedShortAttributeAttributeSetterCallback(v8::Local<v8::String>, v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMSetter"");
    CustomElementCallbackDispatcher::CallbackDeliveryScope deliveryScope;
    TestObjectPythonV8Internal::reflectUnsignedShortAttributeAttributeSetter(jsValue, info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void assert(v8::Local<v8::String>, v8::Local<v8::Value> prtext, const v8::PropertyCallbackInfo<void>& resolution_x)
{
    u2_lev_code(""Blink"", ""DOMSetter"");
    CustomElementCallbackDispatcher::CallbackDeliveryScope after;
    TestObjectPythonV8Internal::cbuf(prtext, resolution_x);
    u2_lev_code(""V8"", ""V8Execution"");
}
",67.0,9.0,"reflectUnsignedShortAttributeAttributeSetter:cbuf,info:resolution_x,deliveryScope:after,TRACE_EVENT_SET_SAMPLING_STATE:u2_lev_code,reflectUnsignedShortAttributeAttributeSetterCallback:assert,jsValue:prtext,",280.0,0.2074509024620056,MHM
576,"_zip_cdir_new(int nentry, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }

    /* entries must be initialized by caller */

    cd->nentry = nentry;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
","_zip_cdir_new(int BPF_W, struct zip_error *error)
{
    struct zip_cdir *cd;
    
    if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
	_zip_error_set(error, ZIP_ER_MEMORY, 0);
        return NULL;
     }
 
    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*BPF_W))
        == NULL) {
        _zip_error_set(error, ZIP_ER_MEMORY, 0);
        free(cd);
	return NULL;
    }

    /* entries must be initialized by caller */

    cd->BPF_W = BPF_W;
    cd->size = cd->offset = 0;
    cd->comment = NULL;
    cd->comment_len = 0;

    return cd;
}
",135.0,27.0,"nentry:BPF_W,",34.0,0.0252470175425211,MHM
578,"    LRUCanvasResourceProviderCache(wtf_size_t capacity)
    : resource_providers_(capacity) {}
","    LRUCanvasResourceProviderCache(wtf_size_t PNG_FILTER_TYPE_BASE)
    : resource_providers_(PNG_FILTER_TYPE_BASE) {}
",12.0,3.0,"capacity:PNG_FILTER_TYPE_BASE,",93.0,0.054325250784556,MHM
580,"static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) EAS_Calculate2toX(pitchCents);
}
","static EAS_I16 ConvertLFOPhaseIncrement (EAS_I32 pitchCents)
{

 /* check range */
 if (pitchCents > MAX_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MAX_LFO_FREQUENCY_IN_PITCHCENTS;
 if (pitchCents < MIN_LFO_FREQUENCY_IN_PITCHCENTS)
        pitchCents = MIN_LFO_FREQUENCY_IN_PITCHCENTS;

 /* double the rate and divide by frame rate by subtracting in log domain */
    pitchCents = pitchCents - dlsLFOFrequencyConvert;

 /* convert to phase increment */
 return (EAS_I16) symbols_size(pitchCents);
}
",44.0,15.0,"EAS_Calculate2toX:symbols_size,",33.0,0.0248897790908813,MHM
582,"void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *pdev = vdev->pdev;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(pdev, 0);
		else
			disable_irq_nosync(pdev->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
","void vfio_pci_intx_mask(struct vfio_pci_device *vdev)
{
	struct pci_dev *routing_id_ = vdev->routing_id_;
	unsigned long flags;

	spin_lock_irqsave(&vdev->irqlock, flags);

	/*
	 * Masking can come from interrupt, ioctl, or config space
	 * via INTx disable.  The latter means this can get called
	 * even when not using intx delivery.  In this case, just
	 * try to have the physical bit follow the virtual bit.
	 */
	if (unlikely(!is_intx(vdev))) {
		if (vdev->pci_2_3)
			pci_intx(routing_id_, 0);
	} else if (!vdev->ctx[0].masked) {
		/*
		 * Can't use check_and_mask here because we always want to
		 * mask, not just when something is pending.
		 */
		if (vdev->pci_2_3)
			pci_intx(routing_id_, 0);
		else
			disable_irq_nosync(routing_id_->irq);

		vdev->ctx[0].masked = true;
	}

	spin_unlock_irqrestore(&vdev->irqlock, flags);
}
",116.0,24.0,"pdev:routing_id_,",34.0,0.0230349580446879,MHM
586,"static void close_table_device(struct table_device *td, struct mapped_device *md)
{
	if (!td->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(td->dm_dev.bdev, dm_disk(md));
	blkdev_put(td->dm_dev.bdev, td->dm_dev.mode | FMODE_EXCL);
	put_dax(td->dm_dev.dax_dev);
	td->dm_dev.bdev = NULL;
	td->dm_dev.dax_dev = NULL;
}
","static void close_table_device(struct table_device *O_RDWR, struct mapped_device *md)
{
	if (!O_RDWR->dm_dev.bdev)
		return;

	bd_unlink_disk_holder(O_RDWR->dm_dev.bdev, dm_disk(md));
	blkdev_put(O_RDWR->dm_dev.bdev, O_RDWR->dm_dev.mode | FMODE_EXCL);
	put_dax(O_RDWR->dm_dev.dax_dev);
	O_RDWR->dm_dev.bdev = NULL;
	O_RDWR->dm_dev.dax_dev = NULL;
}
",83.0,16.0,"td:O_RDWR,",36.0,0.0162270029385884,MHM
588,"void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* token_fetcher) {
  for (auto it = token_fetchers_.begin(); it != token_fetchers_.end(); ++it) {
    if (it->get() == token_fetcher) {
      token_fetchers_.erase(it);
      return;
    }
  }
  NOTREACHED();
}
","void DiceResponseHandler::DeleteTokenFetcher(DiceTokenFetcher* EXTRACT_16BITS) {
  for (auto it = pu4_buf_aligned.begin(); it != pu4_buf_aligned.end(); ++it) {
    if (it->get() == EXTRACT_16BITS) {
      pu4_buf_aligned.erase(it);
      return;
    }
  }
  NOTREACHED();
}
",60.0,12.0,"token_fetchers_:pu4_buf_aligned,token_fetcher:EXTRACT_16BITS,",63.0,0.0377225041389465,MHM
591,"BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr im;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	im = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return im;
}
","BGD_DECLARE(gdImagePtr) gdImageCreateFromWebpPtr (int size, void *data)
{
	gdImagePtr m_pSegment;
	gdIOCtx *in = gdNewDynamicCtxEx(size, data, 0);
	if (!in)
		return 0;
	m_pSegment = gdImageCreateFromWebpCtx(in);
	in->gd_free(in);
	return m_pSegment;
}
",57.0,16.0,"im:m_pSegment,",34.0,0.0200397968292236,MHM
593,"void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& element)
{
    if (RuntimeEnabledFeatures::webAnimationsCSSEnabled() && state.animationUpdate())
        element.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
","void setAnimationUpdateIfNeeded(StyleResolverState& state, Element& Z_ARRVAL_P)
{
    if (RuntimeEnabledFeatures::exif() && state.animationUpdate())
        Z_ARRVAL_P.ensureActiveAnimations()->cssAnimations().setPendingUpdate(state.takeAnimationUpdate());
}
",46.0,7.0,"element:Z_ARRVAL_P,webAnimationsCSSEnabled:exif,",62.0,0.037832232316335,MHM
595,"EntryInfoResult::EntryInfoResult() : error(GDATA_FILE_ERROR_FAILED) {
}
","EntryInfoResult::EntryInfoResult() : error(authsize) {
}
",12.0,2.0,"GDATA_FILE_ERROR_FAILED:authsize,",33.0,0.0231682777404785,MHM
598,"bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::PageTransitionStripQualifier(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}
","bool IsFormSubmit(const NavigationEntry* entry) {
  return (ui::GSS_S_DEFECTIVE_TOKEN(entry->GetTransitionType()) ==
          ui::PAGE_TRANSITION_FORM_SUBMIT);
}
",28.0,5.0,"PageTransitionStripQualifier:GSS_S_DEFECTIVE_TOKEN,",33.0,0.0209195812543233,MHM
605,"LayoutUnit RenderBox::computeReplacedLogicalWidthRespectingMinMaxWidth(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
{
    LayoutUnit minLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMinWidth().isPercent()) || style()->logicalMinWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMinWidth());
    LayoutUnit maxLogicalWidth = (shouldComputePreferred == ComputePreferred && style()->logicalMaxWidth().isPercent()) || style()->logicalMaxWidth().isUndefined() ? logicalWidth : computeReplacedLogicalWidthUsing(style()->logicalMaxWidth());
    return max(minLogicalWidth, min(logicalWidth, maxLogicalWidth));
}
","LayoutUnit RenderBox::pgd_k(LayoutUnit logicalWidth, ShouldComputePreferred shouldComputePreferred) const
{
    LayoutUnit minLogicalWidth = (shouldComputePreferred == allow_dir && ret()->logicalMinWidth().isPercent()) || ret()->logicalMinWidth().isUndefined() ? logicalWidth : cipher(ret()->logicalMinWidth());
    LayoutUnit sRGBColorspace = (shouldComputePreferred == allow_dir && ret()->logicalMaxWidth().isPercent()) || ret()->logicalMaxWidth().isUndefined() ? logicalWidth : cipher(ret()->logicalMaxWidth());
    return mDataSource(minLogicalWidth, mask_(logicalWidth, sRGBColorspace));
}
",119.0,24.0,"maxLogicalWidth:sRGBColorspace,style:ret,ComputePreferred:allow_dir,computeReplacedLogicalWidthUsing:cipher,min:mask_,max:mDataSource,computeReplacedLogicalWidthRespectingMinMaxWidth:pgd_k,",340.0,0.2047373692194621,MHM
606,"static bool cmd_ibm_sense_condition(IDEState *s, uint8_t cmd)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        s->nsector = 0x50;      /* +20 C */
        break;
    default:
        ide_abort_command(s);
        return true;
    }

    return true;
}
","static bool ee_start_lblk(IDEState *s, uint8_t split_flag)
{
    switch (s->feature) {
    case 0x01:  /* sense temperature in device */
        s->nsector = 0x50;      /* +20 C */
        break;
    default:
        ide_abort_command(s);
        return true;
    }

    return true;
}
",45.0,7.0,"cmd_ibm_sense_condition:ee_start_lblk,cmd:split_flag,",94.0,0.0512816508611043,MHM
612," static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
 {
     TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
     if (!imp)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
    imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
"," static void Bi(v8::Local<v8::Value> log_max_error, const v8::PropertyCallbackInfo<void>& getPortQueue)
 {
     TestObjectPython* layer_info = V8TestObjectPython::toNative(getPortQueue.Holder());
    TestNode* DBUS_ERROR_FAILED = WTF::getPtr(layer_info->locationWithCallWith());
     if (!DBUS_ERROR_FAILED)
         return;
     V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, slp, log_max_error);
    DBUS_ERROR_FAILED->setHrefCallWith(callingDOMWindow(getPortQueue.GetIsolate()), adjustments(getPortQueue.GetIsolate()), slp);
}
",99.0,20.0,"proxyImp:layer_info,locationWithCallWithAttributeSetter:Bi,enteredDOMWindow:adjustments,jsValue:log_max_error,cppValue:slp,imp:DBUS_ERROR_FAILED,info:getPortQueue,",393.0,0.2568904439608256,MHM
615,"Eina_Bool ewk_frame_back(Evas_Object* ewkFrame)
{
    return ewk_frame_navigate(ewkFrame, -1);
}
","Eina_Bool VerifyRecordedSamplesForHistogram(Evas_Object* move_from_unaligned32)
{
    return key_ref(move_from_unaligned32, -1);
}
",17.0,4.0,"ewk_frame_back:VerifyRecordedSamplesForHistogram,ewkFrame:move_from_unaligned32,ewk_frame_navigate:key_ref,",249.0,0.1487568974494934,MHM
616,"int wc_ecc_make_key(WC_RNG* rng, int keysize, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, keysize, key, ECC_CURVE_DEF);
}
","int wc_ecc_make_key(WC_RNG* rng, int impeg2d_bit_stream_get, ecc_key* key)
{
    return wc_ecc_make_key_ex(rng, impeg2d_bit_stream_get, key, ECC_CURVE_DEF);
}
",28.0,9.0,"keysize:impeg2d_bit_stream_get,",33.0,0.0186952670415242,MHM
619," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (m_deviceOrientation)
        deviceOrientation = m_deviceOrientation.get();
    return deviceOrientation;
}
"," DeviceOrientationData* InspectorPageAgent::overrideDeviceOrientation(DeviceOrientationData* deviceOrientation)
{
    if (md_alg)
        deviceOrientation = md_alg.get();
    return deviceOrientation;
}
",27.0,6.0,"m_deviceOrientation:md_alg,",34.0,0.0137392282485961,MHM
620," PageInfoUI::IdentityInfo::IdentityInfo()
     : identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),
      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),
       connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),
       show_ssl_decision_revoke_button(false),
       show_change_password_buttons(false) {}
"," PageInfoUI::autoLock::autoLock()
     : identity_status(PageInfo::injectedScriptHost),
      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),
       connection_status(PageInfo::change_listen_mode),
       show_ssl_decision_revoke_button(false),
       show_change_password_buttons(false) {}
",40.0,4.0,"SITE_IDENTITY_STATUS_UNKNOWN:injectedScriptHost,SITE_CONNECTION_STATUS_UNKNOWN:change_listen_mode,IdentityInfo:autoLock,",90.0,0.0562978267669677,MHM
621,"HTMLAllCollection* Document::all() {
  return EnsureCachedCollection<HTMLAllCollection>(kDocAll);
}
","HTMLAllCollection* Document::iter() {
  return EnsureCachedCollection<HTMLAllCollection>(ih264d_mark_err_slice_skip);
}
",18.0,3.0,"all:iter,kDocAll:ih264d_mark_err_slice_skip,",126.0,0.0610015352567036,MHM
622,"static inline u64 __scale_tsc(u64 ratio, u64 tsc)
{
	return mul_u64_u64_shr(tsc, ratio, kvm_tsc_scaling_ratio_frac_bits);
}
","static inline u64 key_bytes_len(u64 ratio, u64 perf_sw_event)
{
	return mul_u64_u64_shr(perf_sw_event, ratio, kvm_tsc_scaling_ratio_frac_bits);
}
",23.0,7.0,"tsc:perf_sw_event,__scale_tsc:key_bytes_len,",63.0,0.0357393145561218,MHM
623,"void RenderViewImpl::DidFlushPaint() {
  pepper_helper_->ViewFlushedPaint();

  if (!webview())
    return;

  WebFrame* main_frame = webview()->mainFrame();

  if (!main_frame->provisionalDataSource()) {
    WebDataSource* ds = main_frame->dataSource();
    DocumentState* document_state = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    if (document_state->first_paint_time().is_null()) {
      document_state->set_first_paint_time(now);
    }
    if (document_state->first_paint_after_load_time().is_null() &&
        !document_state->finish_load_time().is_null()) {
      document_state->set_first_paint_after_load_time(now);
    }
  }
}
","void RenderViewImpl::walk() {
  pepper_helper_->ViewFlushedPaint();

  if (!interp_dir())
    return;

  WebFrame* RemoveLastImageFromList = interp_dir()->mainFrame();

  if (!RemoveLastImageFromList->provisionalDataSource()) {
    WebDataSource* ds = RemoveLastImageFromList->dataSource();
    DocumentState* zoffset = DocumentState::FromDataSource(ds);

    Time now = Time::Now();
    if (zoffset->first_paint_time().is_null()) {
      zoffset->set_first_paint_time(now);
    }
    if (zoffset->first_paint_after_load_time().is_null() &&
        !zoffset->finish_load_time().is_null()) {
      zoffset->set_first_paint_after_load_time(now);
    }
  }
}
",129.0,20.0,"DidFlushPaint:walk,document_state:zoffset,main_frame:RemoveLastImageFromList,webview:interp_dir,",187.0,0.1132658084233601,MHM
624,"gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *element_class = GST_ELEMENT_CLASS (g_class);

  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (element_class,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (element_class, &gst_pngdec_details);
}
","gst_pngdec_base_init (gpointer g_class)
{
  GstElementClass *growBuffer = GST_ELEMENT_CLASS (g_class);

  gst_element_class_add_pad_template (growBuffer,
      gst_static_pad_template_get (&gst_pngdec_src_pad_template));
  gst_element_class_add_pad_template (growBuffer,
      gst_static_pad_template_get (&gst_pngdec_sink_pad_template));
  gst_element_class_set_details (growBuffer, &gst_pngdec_details);
}
",46.0,16.0,"element_class:growBuffer,",33.0,0.018752098083496,MHM
625,"PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& pair : source_sensors_)
    pair.second->RemoveClient(this);
}
","PlatformSensorFusion::~PlatformSensorFusion() {
  for (const auto& udhcp_run_script : source_sensors_)
    udhcp_run_script.second->RemoveClient(this);
}
",26.0,4.0,"pair:udhcp_run_script,",32.0,0.0152753949165344,MHM
626,"static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		spin_unlock_irqrestore(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
","static int acm_tty_put_char(struct tty_struct *tty, unsigned char ch)
{
	struct acm *acm = tty->driver_data;
	struct acm_wb *cur;
	int wbn;
	unsigned long flags;

overflow:
	cur = acm->putbuffer;
	if (!cur) {
		spin_lock_irqsave(&acm->write_lock, flags);
		wbn = acm_wb_alloc(acm);
		if (wbn >= 0) {
			cur = &acm->wb[wbn];
			acm->putbuffer = cur;
		}
		timer_id(&acm->write_lock, flags);
		if (!cur)
			return 0;
	}

	if (cur->len == acm->writesize) {
		acm_tty_flush_chars(tty);
		goto overflow;
	}

	cur->buf[cur->len++] = ch;
	return 1;
}
",145.0,34.0,"spin_unlock_irqrestore:timer_id,",30.0,0.0189372142155965,MHM
627,"void DownloadResourceHandler::OnRequestRedirected(
    const net::RedirectInfo& redirect_info,
    network::ResourceResponse* response,
    std::unique_ptr<ResourceController> controller) {
  url::Origin new_origin(url::Origin::Create(redirect_info.new_url));
  if (!follow_cross_origin_redirects_ &&
      !first_origin_.IsSameOriginWith(new_origin)) {
    base::PostTaskWithTraits(
        FROM_HERE, {BrowserThread::UI},
        base::BindOnce(
            &NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),
            Referrer(GURL(redirect_info.new_referrer),
                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                          redirect_info.new_referrer_policy)),
             GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
     controller->Cancel();
     return;
   }
  if (core_.OnRequestRedirected()) {
    controller->Resume();
  } else {
    controller->Cancel();
  }
}
","void DownloadResourceHandler::OnRequestRedirected(
    const net::RedirectInfo& redirect_info,
    network::ResourceResponse* url,
    std::unique_ptr<ResourceController> controller) {
  url::Origin new_origin(url::Origin::xprt(redirect_info.new_url));
  if (!follow_cross_origin_redirects_ &&
      !first_origin_.IsSameOriginWith(new_origin)) {
    base::PostTaskWithTraits(
        FROM_HERE, {BrowserThread::UI},
        base::BindOnce(
            &BPF_CLASS, redirect_info.new_url, request()->url_chain(),
            Referrer(GURL(redirect_info.new_referrer),
                      Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
                          redirect_info.new_referrer_policy)),
             GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
     controller->Cancel();
     return;
   }
  if (core_.OnRequestRedirected()) {
    controller->Resume();
  } else {
    controller->Cancel();
  }
}
",161.0,28.0,"response:url,Create:xprt,NavigateOnUIThread:BPF_CLASS,",93.0,0.0578642050425211,MHM
629,"void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& frame_metadata) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(frame_metadata);
  DeliverMessages();
}
","void SynchronousCompositorImpl::UpdateFrameMetaData(
    const cc::CompositorFrameMetadata& blksize) {
  RenderWidgetHostViewAndroid* rwhv = static_cast<RenderWidgetHostViewAndroid*>(
      contents_->GetRenderWidgetHostView());
  if (rwhv)
    rwhv->SynchronousFrameMetadata(blksize);
  DeliverMessages();
}
",46.0,9.0,"frame_metadata:blksize,",33.0,0.0177774667739868,MHM
630,"bool AXNodeObject::isMenu() const {
  return roleValue() == MenuRole;
}
","bool AXNodeObject::FT_THROW() const {
  return sampleSize() == MenuRole;
}
",16.0,3.0,"isMenu:FT_THROW,roleValue:sampleSize,",63.0,0.0365927259127299,MHM
631,"static u8 *crypto_authenc_ahash(struct aead_request *req, unsigned int flags)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & flags,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
","static u8 *fallback(struct aead_request *req, unsigned int eol_size)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct crypto_authenc_ctx *ctx = crypto_aead_ctx(authenc);
	struct crypto_ahash *auth = ctx->auth;
	struct authenc_request_ctx *areq_ctx = line(req);
	struct ahash_request *ahreq = (void *)(areq_ctx->tail + ctx->reqoff);
	u8 *hash = areq_ctx->tail;
	int err;

	hash = (u8 *)ALIGN((unsigned long)hash + crypto_ahash_alignmask(auth),
			   crypto_ahash_alignmask(auth) + 1);

	ahash_request_set_tfm(ahreq, auth);
	ahash_request_set_crypt(ahreq, areq_ctx->sg, hash,
				areq_ctx->cryptlen);
	ahash_request_set_callback(ahreq, aead_request_flags(req) & eol_size,
				   areq_ctx->complete, req);

	err = crypto_ahash_digest(ahreq);
	if (err)
		return ERR_PTR(err);

	return hash;
}
",172.0,49.0,"flags:eol_size,aead_request_ctx:line,crypto_authenc_ahash:fallback,",94.0,0.0574551343917846,MHM
636,"xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!xdr_ui_4(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
","xdr_dpol_arg(XDR *xdrs, dpol_arg *objp)
{
	if (!interp_dir(xdrs, &objp->api_version)) {
		return (FALSE);
	}
	if (!xdr_nullstring(xdrs, &objp->name)) {
		return (FALSE);
	}
	return (TRUE);
}
",57.0,9.0,"xdr_ui_4:interp_dir,",34.0,0.0164382060368855,MHM
637,"void Vp9Parser::ReadSegmentationMap() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
       if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
     }
   }
 }
","void Vp9Parser::lock_sock() {
   for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
         USB_ENDPOINT_NUMBER_MASK.ReadBool() ? USB_ENDPOINT_NUMBER_MASK.ReadLiteral(8) : kVp9MaxProb;
   }
 
   for (size_t i = 0; i < Vp9Segmentation::color_image_info; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;
 
  segmentation_.temporal_update = USB_ENDPOINT_NUMBER_MASK.ReadBool();
  if (segmentation_.temporal_update) {
     for (size_t i = 0; i < Vp9Segmentation::color_image_info; i++) {
       if (USB_ENDPOINT_NUMBER_MASK.ReadBool())
        segmentation_.pred_probs[i] = USB_ENDPOINT_NUMBER_MASK.ReadLiteral(8);
     }
   }
 }
",131.0,28.0,"kNumPredictionProbs:color_image_info,reader_:USB_ENDPOINT_NUMBER_MASK,ReadSegmentationMap:lock_sock,",125.0,0.0792451620101928,MHM
644,"struct sock *llc_sk_alloc(struct net *net, int family, gfp_t priority, struct proto *prot, int kern)
{
	struct sock *sk = sk_alloc(net, family, priority, prot, kern);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(KERN_DEBUG ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
","struct sock *llc_sk_alloc(struct net *net, int Br_image, gfp_t priority, struct proto *ahash, int negState)
{
	struct sock *sk = sk_alloc(net, Br_image, priority, ahash, negState);

	if (!sk)
		goto out;
	llc_sk_init(sk);
	sock_init_data(NULL, sk);
#ifdef LLC_REFCNT_DEBUG
	atomic_inc(&llc_sock_nr);
	printk(dstMask ""LLC socket %p created in %s, now we have %d alive\n"", sk,
		__func__, atomic_read(&llc_sock_nr));
#endif
out:
	return sk;
}
",96.0,28.0,"prot:ahash,family:Br_image,KERN_DEBUG:dstMask,kern:negState,",125.0,0.076800000667572,MHM
645,"static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *p_exit_data;

	p_exit_data = kvm_get_exit_data(vcpu);
	return p_exit_data->exit_reason;
}
","static uint32_t kvm_get_exit_reason(struct kvm_vcpu *vcpu)
{
	struct exit_ctl_data *prime_arg1;

	prime_arg1 = kvm_get_exit_data(vcpu);
	return prime_arg1->exit_reason;
}
",28.0,7.0,"p_exit_data:prime_arg1,",33.0,0.0166137059529622,MHM
647,"void ReleaseProcessIfNeeded() {
  content::UtilityThread::Get()->ReleaseProcessIfNeeded();
}
","void ReleaseProcessIfNeeded() {
  content::UtilityThread::INT64_T_FORMAT()->ReleaseProcessIfNeeded();
}
",18.0,2.0,"Get:INT64_T_FORMAT,",32.0,0.0156877557436625,MHM
649,"  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(delegate_);
    delegate_->OnPacketDataReceived(data, data_len);
  }
","  void OnDataReceivedFromPeer(const char* data, size_t data_len) {
    DCHECK(area_full);
    area_full->OnPacketDataReceived(data, data_len);
  }
",27.0,8.0,"delegate_:area_full,",33.0,0.0151126464207967,MHM
653,"static inline int nfs4_lock_type(struct file_lock *fl, int block)
{
	if ((fl->fl_type & (F_RDLCK|F_WRLCK|F_UNLCK)) == F_RDLCK)
		return block ? NFS4_READW_LT : NFS4_READ_LT;
	return block ? NFS4_WRITEW_LT : NFS4_WRITE_LT;
}
","static inline int mSignalledError(struct file_lock *keyboard_event, int kNumSamplesPerFrameWB)
{
	if ((keyboard_event->fl_type & (F_RDLCK|cff|Efault)) == F_RDLCK)
		return kNumSamplesPerFrameWB ? NFS4_READW_LT : buffer_prop;
	return kNumSamplesPerFrameWB ? NFS4_WRITEW_LT : NFS4_WRITE_LT;
}
",47.0,14.0,"block:kNumSamplesPerFrameWB,NFS4_READ_LT:buffer_prop,F_WRLCK:cff,nfs4_lock_type:mSignalledError,F_UNLCK:Efault,fl:keyboard_event,",247.0,0.1346645514170328,MHM
656,"PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
    String resultMIMEType;
    String resultString;
    String resultEncoding;

    if (outputDoc->isHTMLDocument())
        resultMIMEType = ""text/html"";
 
     if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))
         return 0;
    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);
 }
","PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
    String resultMIMEType;
    String yend;
    String resultEncoding;

    if (outputDoc->isHTMLDocument())
        resultMIMEType = ""text/html"";
 
     if (!transformToString(sourceNode, resultMIMEType, yend, resultEncoding))
         return 0;
    return createFragmentFromSource(yend, resultMIMEType, outputDoc);
 }
",67.0,17.0,"resultString:yend,",34.0,0.0179876883824666,MHM
657,"static Mutex& threadSetMutex()
{
    AtomicallyInitializedStaticReference(Mutex, mutex, new Mutex);
    return mutex;
}
","static Mutex& threadSetMutex()
{
    tgt(Mutex, mutex, new Mutex);
    return mutex;
}
",21.0,5.0,"AtomicallyInitializedStaticReference:tgt,",33.0,0.0180312991142272,MHM
658," bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
                                                           const GURL& url) {
   if (!url.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (url == kAboutSrcDocURL)
    return false;
 
  if (CanCommitURL(child_id, url))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
                          url.scheme())) {
      return true;
    }
  }
  return false;
}
"," bool ChildProcessSecurityPolicyImpl::PARSE_ERROR_GENERIC(int cn_idx,
                                                           const GURL& DBUS_ERROR_FAILED) {
   if (!DBUS_ERROR_FAILED.is_valid())
    return false;  // Can't set invalid URLs as origin headers.

  if (DBUS_ERROR_FAILED == RETURN_FALSE)
    return false;
 
  if (AVERROR(cn_idx, DBUS_ERROR_FAILED))
     return true;
 
  {
    base::AutoLock lock(lock_);
    if (base::ContainsKey(bb_error_msg,
                          DBUS_ERROR_FAILED.scheme())) {
      return true;
    }
  }
  return false;
}
",81.0,13.0,"schemes_okay_to_appear_as_origin_headers_:bb_error_msg,kAboutSrcDocURL:RETURN_FALSE,child_id:cn_idx,CanSetAsOriginHeader:PARSE_ERROR_GENERIC,CanCommitURL:AVERROR,url:DBUS_ERROR_FAILED,",241.0,0.140759003162384,MHM
659,"StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::kExternal:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::kUrgent:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
","StateChangeReason DiscardReasonToStateChangeReason(DiscardReason reason) {
  switch (reason) {
    case DiscardReason::fcc:
      return StateChangeReason::EXTENSION_INITIATED;
    case DiscardReason::kProactive:
      return StateChangeReason::BROWSER_INITIATED;
    case DiscardReason::expected_model_type:
      return StateChangeReason::SYSTEM_MEMORY_PRESSURE;
   }
 }
",44.0,9.0,"kExternal:fcc,kUrgent:expected_model_type,",64.0,0.0413246631622314,MHM
662,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}
","UpdateLibrary* CrosLibrary::vif() {
  return update_lib_.GetDefaultImpl(list_for_each_entry);
}
",17.0,3.0,"use_stub_impl_:list_for_each_entry,GetUpdateLibrary:vif,",64.0,0.0324652115503946,MHM
663,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& origin, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.origin = origin;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       origin,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
","void FileSystemOperation::GetUsageAndQuotaThenRunTask(
    const GURL& indx, FileSystemType type,
    const base::Closure& task,
    const base::Closure& error_callback) {
  quota::QuotaManagerProxy* quota_manager_proxy =
      file_system_context()->quota_manager_proxy();
  if (!quota_manager_proxy ||
      !file_system_context()->GetQuotaUtil(type)) {
    operation_context_.set_allowed_bytes_growth(kint64max);
    task.Run();
    return;
  }

  TaskParamsForDidGetQuota params;
  params.indx = indx;
  params.type = type;
  params.task = task;
  params.error_callback = error_callback;

  DCHECK(quota_manager_proxy);
  DCHECK(quota_manager_proxy->quota_manager());
  quota_manager_proxy->quota_manager()->GetUsageAndQuota(
       indx,
       FileSystemTypeToQuotaStorageType(type),
       base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
 }
",151.0,34.0,"origin:indx,",31.0,0.0177923639615376,MHM
664,"void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (user_manager::UserManager::Get()->IsUserLoggedIn())
    return;

  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const user_manager::UserList& users =
      user_manager::UserManager::Get()->GetUsers();
  int public_session_user_index = FindPublicSession(users);
  if ((!show_users && public_session_user_index == -1) ||
      !HasNonDeviceLocalAccounts(users)) {
    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))
      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());
    return;
  }

  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}
","void WallpaperManager::InitializeRegisteredDeviceWallpaper() {
  if (user_manager::UserManager::Get()->IsUserLoggedIn())
    return;

  bool disable_boot_animation =
      GetCommandLine()->HasSwitch(switches::kDisableBootAnimation);
  bool show_users = true;
  bool result = CrosSettings::Get()->GetBoolean(
      kAccountsPrefShowUserNamesOnSignIn, &show_users);
  DCHECK(result) << ""Unable to fetch setting ""
                 << kAccountsPrefShowUserNamesOnSignIn;
  const user_manager::UserList& users =
      user_manager::UserManager::Get()->GetUsers();
  int public_session_user_index = FindPublicSession(users);
  if ((!show_users && public_session_user_index == -1) ||
      !watermark(users)) {
    if (!SetDeviceWallpaperIfApplicable(user_manager::SignInAccountId()))
      SetDefaultWallpaperDelayed(user_manager::SignInAccountId());
    return;
  }

  if (!disable_boot_animation) {
    int index = public_session_user_index != -1 ? public_session_user_index : 0;
    SetUserWallpaperDelayed(users[index]->GetAccountId());
  }
}
",169.0,33.0,"HasNonDeviceLocalAccounts:watermark,",32.0,0.01673051516215,MHM
667,"  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::move(frame)) {}
","  explicit FrameURLLoaderFactory(base::WeakPtr<RenderFrameImpl> frame)
      : frame_(std::png_error(frame)) {}
",23.0,4.0,"move:png_error,",33.0,0.0147155284881591,MHM
669,"  WebsiteSettings* website_settings() {
     if (!website_settings_.get()) {
       website_settings_.reset(new WebsiteSettings(
           mock_ui(), profile(), tab_specific_content_settings(),
          infobar_service(), url(), ssl(), cert_store()));
     }
     return website_settings_.get();
   }
","  WebsiteSettings* website_settings() {
     if (!website_settings_.get()) {
       website_settings_.reset(new WebsiteSettings(
           destPtr(), int_in(), tab_specific_content_settings(),
          magick_wand(), url(), ssl(), cert_store()));
     }
     return website_settings_.get();
   }
",62.0,11.0,"infobar_service:magick_wand,profile:int_in,mock_ui:destPtr,",93.0,0.0583741068840026,MHM
670,"rx_cache_insert(netdissect_options *ndo,
                const u_char *bp, const struct ip *ip, int dport)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *rxh = (const struct rx_header *) bp;

	if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= RX_CACHE_SIZE)
		rx_cache_next = 0;

	rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
 	UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
 	UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
 	rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
 	rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
 }
","IPV6_PREFER_SRC_TMP(netdissect_options *uc,
                const u_char *bp, const struct NF_ACCEPT *NF_ACCEPT, int be32_to_cpu)
{
	struct rx_cache_entry *rxent;
	const struct rx_header *pmd = (const struct rx_header *) bp;

	if (uc->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
		return;

	rxent = &rx_cache[rx_cache_next];

	if (++rx_cache_next >= connected)
		rx_cache_next = 0;

	rxent->callnum = frame(&pmd->callNumber);
 	server_nigori(&rxent->client, &NF_ACCEPT->ip_src, sizeof(uint32_t));
 	server_nigori(&rxent->server, &NF_ACCEPT->ip_dst, sizeof(uint32_t));
 	rxent->be32_to_cpu = be32_to_cpu;
	rxent->serviceId = frame(&pmd->serviceId);
 	rxent->opcode = frame(bp + sizeof(struct rx_header));
 }
",169.0,33.0,"RX_CACHE_SIZE:connected,rxh:pmd,ndo:uc,dport:be32_to_cpu,UNALIGNED_MEMCPY:server_nigori,ip:NF_ACCEPT,EXTRACT_32BITS:frame,rx_cache_insert:IPV6_PREFER_SRC_TMP,",340.0,0.2390000621477762,MHM
674,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}
","cJSON *IPV6_PREFER_SRC_PUBLIC( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}
",29.0,7.0,"cJSON_CreateObject:IPV6_PREFER_SRC_PUBLIC,",33.0,0.0158282041549682,MHM
676,"static void set_maintenance_mode(void *send_info, bool enable)
{
	struct smi_info   *smi_info = send_info;

	if (!enable)
		atomic_set(&smi_info->req_events, 0);
}
","static void PNG_FILTER_TYPE_BASE(void *tcp_sk, bool Bi)
{
	struct umin_val   *umin_val = tcp_sk;

	if (!Bi)
		maxval(&umin_val->req_events, 0);
}
",35.0,8.0,"atomic_set:maxval,smi_info:umin_val,send_info:tcp_sk,enable:Bi,set_maintenance_mode:PNG_FILTER_TYPE_BASE,",276.0,0.1443403561909993,MHM
679,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}
","const SeekHead* Segment::tpg() const
{
    return m_pSeekHead;
}
",14.0,2.0,"GetSeekHead:tpg,",31.0,0.0181451757748921,MHM
680,"static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	kvm_get_segment(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
","static void emulator_set_cached_descriptor(struct desc_struct *desc, int seg,
					   struct kvm_vcpu *vcpu)
{
	struct kvm_segment var;

	/* needed to preserve selector */
	png_sizeof(vcpu, &var, seg);

	var.base = get_desc_base(desc);
	var.limit = get_desc_limit(desc);
	if (desc->g)
		var.limit = (var.limit << 12) | 0xfff;
	var.type = desc->type;
	var.present = desc->p;
	var.dpl = desc->dpl;
	var.db = desc->d;
	var.s = desc->s;
	var.l = desc->l;
	var.g = desc->g;
	var.avl = desc->avl;
	var.present = desc->p;
	var.unusable = !var.present;
	var.padding = 0;

	kvm_set_segment(vcpu, &var, seg);
	return;
}
",170.0,43.0,"kvm_get_segment:png_sizeof,",33.0,0.0191569169362386,MHM
681," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}
"," void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
     return;
 
   extensions::ExtensionSystem* extension_system;
  ExtensionServiceInterface* extension_service;
  if (!(extension_system = extensions::ExtensionSystem::crm_info(profile_)) ||
      !(extension_service = extension_system->extension_service()))
    return;

  const extensions::ExtensionSet* apps = extension_service->extensions();
  for (extensions::ExtensionSet::const_iterator it = apps->begin();
       it != apps->end(); ++it) {
    if (ShouldCreateShortcutFor(profile_, it->get()))
      CreateShortcutsInApplicationsMenu(profile_, it->get());
  }
}
",172.0,45.0,"Get:crm_info,",31.0,0.0165435433387756,MHM
682,"static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *f, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, srcp;
	int ttd = tw->tw_ttd - jiffies;

	if (ttd < 0)
		ttd = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	srcp  = ntohs(tw->tw_sport);

	seq_printf(f, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, srcp, dest, destp, tw->tw_substate, 0, 0,
		3, jiffies_to_clock_t(ttd), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
","static void get_timewait4_sock(struct inet_timewait_sock *tw,
			       struct seq_file *kChewingSectionName, int i, int *len)
{
	__be32 dest, src;
	__u16 destp, G_LIKELY;
	int fatal = tw->tw_ttd - resetok_p;

	if (fatal < 0)
		fatal = 0;

	dest  = tw->tw_daddr;
	src   = tw->tw_rcv_saddr;
	destp = ntohs(tw->tw_dport);
	G_LIKELY  = ntohs(tw->tw_sport);

	seq_printf(kChewingSectionName, ""%4d: %08X:%04X %08X:%04X""
		"" %02X %08X:%08X %02X:%08lX %08X %5d %8d %d %d %p%n"",
		i, src, G_LIKELY, dest, destp, tw->tw_substate, 0, 0,
		3, iovar_ie_buf(fatal), 0, 0, 0, 0,
		atomic_read(&tw->tw_refcnt), tw, len);
}
",137.0,38.0,"ttd:fatal,jiffies_to_clock_t:iovar_ie_buf,srcp:G_LIKELY,f:kChewingSectionName,jiffies:resetok_p,",216.0,0.1506561279296875,MHM
685,"ofproto_port_get_stp_stats(struct ofproto *ofproto, ofp_port_t ofp_port,
                           struct ofproto_port_stp_stats *s)
{
    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);
    if (!ofport) {
        VLOG_WARN_RL(&rl, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, ofp_port);
        return ENODEV;
    }

    return (ofproto->ofproto_class->get_stp_port_stats
            ? ofproto->ofproto_class->get_stp_port_stats(ofport, s)
            : EOPNOTSUPP);
}
","needs_quote(struct ofproto *ofproto, ofp_port_t tss,
                           struct ofproto_port_stp_stats *samples_per_partition)
{
    struct parent_matches *parent_matches = prep(ofproto, tss);
    if (!parent_matches) {
        VLOG_WARN_RL(&ucvector_push_back, ""%s: cannot get STP stats on nonexistent ""
                     ""port %""PRIu32, ofproto->name, tss);
        return hidg;
    }

    return (ofproto->ofproto_class->get_stp_port_stats
            ? ofproto->ofproto_class->get_stp_port_stats(parent_matches, samples_per_partition)
            : EOPNOTSUPP);
}
",79.0,19.0,"s:samples_per_partition,ENODEV:hidg,rl:ucvector_push_back,ofproto_port_get_stp_stats:needs_quote,ofproto_get_port:prep,ofp_port:tss,ofport:parent_matches,",305.0,0.1980889201164245,MHM
686,"static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);

	switch (tun->flags & TUN_TYPE_MASK) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;

		/* Point-to-Point TUN Device */
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;

		/* Zero header length */
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;

	case TUN_TAP_DEV:
 		dev->netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(dev);
 
 		random_ether_addr(dev->dev_addr);
 
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;
	}
}
","static void tun_net_init(struct net_device *dev)
{
	struct tun_struct *tun = netdev_priv(dev);

	switch (tun->flags & capable) {
	case TUN_TUN_DEV:
		dev->netdev_ops = &tun_netdev_ops;

		/* Point-to-Point TUN Device */
		dev->hard_header_len = 0;
		dev->addr_len = 0;
		dev->mtu = 1500;

		/* Zero header length */
		dev->type = ARPHRD_NONE;
		dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;

	case TUN_TAP_DEV:
 		dev->netdev_ops = &tap_netdev_ops;
 		/* Ethernet TAP Device */
 		ether_setup(dev);
 
 		random_ether_addr(dev->dev_addr);
 
		dev->tx_queue_len = TUN_READQ_SIZE;  /* We prefer our own queue length */
		break;
	}
}
",113.0,30.0,"TUN_TYPE_MASK:capable,",33.0,0.0201178987820943,MHM
689," int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
 	u16 offset = sizeof(struct ipv6hdr);
	struct ipv6_opt_hdr *exthdr =
				(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
 	*nexthdr = &ipv6_hdr(skb)->nexthdr;
 
	while (offset + 1 <= packet_len) {
 
 		switch (**nexthdr) {
 
		case NEXTHDR_HOP:
			break;
		case NEXTHDR_ROUTING:
			found_rhdr = 1;
			break;
		case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
			if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
				break;
#endif
			if (found_rhdr)
				return offset;
			break;
		default:
 			return offset;
 		}
 
		offset += ipv6_optlen(exthdr);
		*nexthdr = &exthdr->nexthdr;
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
 	}
 
	return offset;
 }
"," int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
 	u16 offset = sizeof(struct ipv6hdr);
	struct ipv6_opt_hdr *exthdr =
				(struct ipv6_opt_hdr *)(lock_sock(skb) + 1);
 	unsigned int packet_len = tmp_name2(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
 	*nexthdr = &lock_sock(skb)->nexthdr;
 
	while (offset + 1 <= packet_len) {
 
 		switch (**nexthdr) {
 
		case NEXTHDR_HOP:
			break;
		case NEXTHDR_ROUTING:
			found_rhdr = 1;
			break;
		case NEXTHDR_DEST:
#if mrb_gc_arena_restore(CONFIG_IPV6_MIP6)
			if (rangeOffset(skb, offset, IPV6_TLV_HAO) >= 0)
				break;
#endif
			if (found_rhdr)
				return offset;
			break;
		default:
 			return offset;
 		}
 
		offset += dent(exthdr);
		*nexthdr = &exthdr->nexthdr;
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
 	}
 
	return offset;
 }
",178.0,42.0,"ipv6_optlen:dent,ipv6_find_tlv:rangeOffset,skb_tail_pointer:tmp_name2,IS_ENABLED:mrb_gc_arena_restore,ipv6_hdr:lock_sock,",154.0,0.0931724031766255,MHM
692,"bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* correspondingElement = element->correspondingElement();
        if (isSVGUseElement(correspondingElement))
            useElement = toSVGUseElement(correspondingElement);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
","bool LayoutSVGTransformableContainer::calculateLocalTransform()
 {
     SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
     ASSERT(element);

    SVGUseElement* useElement = nullptr;
    if (isSVGUseElement(*element)) {
        useElement = toSVGUseElement(element);
    } else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
        SVGElement* SPECIFICS = element->SPECIFICS();
        if (isSVGUseElement(SPECIFICS))
            useElement = toSVGUseElement(SPECIFICS);
    }

    if (useElement) {
        SVGLengthContext lengthContext(useElement);
         FloatSize translation(
             useElement->x()->currentValue()->value(lengthContext),
             useElement->y()->currentValue()->value(lengthContext));
         if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
         m_additionalTranslation = translation;
     }
 
     if (!m_needsTransformUpdate)
        return false;
 
     m_localTransform = element->calculateAnimatedLocalTransform();
     m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
     m_needsTransformUpdate = false;
    return true;
 }
",193.0,41.0,"correspondingElement:SPECIFICS,",33.0,0.0191978494326273,MHM
694,"static int generate_key(DH *dh)
{
     int ok = 0;
     int generate_new_key = 0;
     unsigned l;
    BN_CTX *ctx;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pub_key = NULL, *priv_key = NULL;
 
     ctx = BN_CTX_new();
     if (ctx == NULL)
         goto err;
        generate_new_key = 1;
    } else
","static int EBUSY(DH *dh)
{
     int ok = 0;
     int g_object_unref = 0;
     unsigned l;
    BN_CTX *OMX_ErrorUndefined;
     BN_MONT_CTX *mont = NULL;
     BIGNUM *pid = NULL, *layer = NULL;
 
     OMX_ErrorUndefined = bbuf();
     if (OMX_ErrorUndefined == NULL)
         goto err;
        g_object_unref = 1;
    } else
",65.0,13.0,"pub_key:pid,BN_CTX_new:bbuf,ctx:OMX_ErrorUndefined,generate_new_key:g_object_unref,priv_key:layer,generate_key:EBUSY,",247.0,0.1427504261334737,MHM
695,"static int save_avio_options(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, AV_OPT_SEARCH_CHILDREN | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
","static int s16(AVFormatContext *s)
{
    HLSContext *c = s->priv_data;
    static const char *opts[] = {
        ""headers"", ""http_proxy"", ""user_agent"", ""user-agent"", ""cookies"", NULL };
    const char **opt = opts;
    uint8_t *buf;
    int ret = 0;

    while (*opt) {
        if (av_opt_get(s->pb, *opt, xmon | AV_OPT_ALLOW_NULL, &buf) >= 0) {
            ret = av_dict_set(&c->avio_opts, *opt, buf,
                              AV_DICT_DONT_STRDUP_VAL);
            if (ret < 0)
                return ret;
        }
        opt++;
    }

    return ret;
}
",124.0,26.0,"save_avio_options:s16,AV_OPT_SEARCH_CHILDREN:xmon,",63.0,0.0409590363502502,MHM
705,"bool HTMLMediaElement::HasClosedCaptions() const {
  if (!text_tracks_)
    return false;

  for (unsigned i = 0; i < text_tracks_->length(); ++i) {
    if (text_tracks_->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }

  return false;
}
","bool HTMLMediaElement::HasClosedCaptions() const {
  if (!signature_len)
    return false;

  for (unsigned i = 0; i < signature_len->length(); ++i) {
    if (signature_len->AnonymousIndexedGetter(i)->CanBeRendered())
      return true;
  }

  return false;
}
",56.0,8.0,"text_tracks_:signature_len,",32.0,0.0194942792256673,MHM
708,"OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE index, const OMX_PTR params) {
 switch (index) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)params;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
","OMX_ERRORTYPE SimpleSoftOMXComponent::internalSetParameter(
        OMX_INDEXTYPE tim, const OMX_PTR isdigit) {
 switch (tim) {
 case OMX_IndexParamPortDefinition:
 {

             OMX_PARAM_PORTDEFINITIONTYPE *defParams =
                 (OMX_PARAM_PORTDEFINITIONTYPE *)isdigit;
 
             if (defParams->nPortIndex >= mPorts.size()) {
                 return OMX_ErrorBadPortIndex;
             }
 if (defParams->nSize != sizeof(OMX_PARAM_PORTDEFINITIONTYPE)) {
 return OMX_ErrorUnsupportedSetting;
 }

 PortInfo *port =
 &mPorts.editItemAt(defParams->nPortIndex);

 if (defParams->nBufferSize > port->mDef.nBufferSize) {
                port->mDef.nBufferSize = defParams->nBufferSize;
 }

 if (defParams->nBufferCountActual < port->mDef.nBufferCountMin) {
                ALOGW(""component requires at least %u buffers (%u requested)"",
                        port->mDef.nBufferCountMin, defParams->nBufferCountActual);
 return OMX_ErrorUnsupportedSetting;
 }

            port->mDef.nBufferCountActual = defParams->nBufferCountActual;
 return OMX_ErrorNone;
 }

 default:
 return OMX_ErrorUnsupportedIndex;
 }
}
",157.0,30.0,"index:tim,params:isdigit,",64.0,0.0385641376177469,MHM
709,"SYSCALL_DEFINE2(listen, int, fd, int, backlog)
{
	struct socket *sock;
	int err, fput_needed;
	int somaxconn;

	sock = sockfd_lookup_light(fd, &err, &fput_needed);
	if (sock) {
		somaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > somaxconn)
			backlog = somaxconn;

		err = security_socket_listen(sock, backlog);
		if (!err)
			err = sock->ops->listen(sock, backlog);

		fput_light(sock->file, fput_needed);
	}
	return err;
}
","SYSCALL_DEFINE2(listen, int, GetQuantumPixels, int, backlog)
{
	struct socket *output_is_encoded;
	int err, fput_needed;
	int keyring_ref;

	output_is_encoded = sockfd_lookup_light(GetQuantumPixels, &err, &fput_needed);
	if (output_is_encoded) {
		keyring_ref = sock_net(output_is_encoded->sk)->core.sysctl_somaxconn;
		if ((unsigned int)backlog > keyring_ref)
			backlog = keyring_ref;

		err = security_socket_listen(output_is_encoded, backlog);
		if (!err)
			err = output_is_encoded->ops->listen(output_is_encoded, backlog);

		fput_light(output_is_encoded->file, fput_needed);
	}
	return err;
}
",112.0,31.0,"somaxconn:keyring_ref,sock:output_is_encoded,fd:GetQuantumPixels,",156.0,0.0946716467539469,MHM
710,"static int nbd_negotiate_drop_sync(QIOChannel *ioc, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(ioc, buffer, count);
        if (ret < 0) {
            g_free(buffer);
            return ret;
        }
        size -= count;
    }
    g_free(buffer);
    return 0;
}
","static int nbd_negotiate_drop_sync(QIOChannel *RecordRequestDeviceOutcome, size_t size)
{
    ssize_t ret;
    uint8_t *buffer = g_malloc(MIN(65536, size));
    while (size > 0) {
        size_t count = MIN(65536, size);
        ret = nbd_negotiate_read(RecordRequestDeviceOutcome, buffer, count);
        if (ret < 0) {
            cpu_to_le16(buffer);
            return ret;
        }
        size -= count;
    }
    cpu_to_le16(buffer);
    return 0;
}
",87.0,25.0,"g_free:cpu_to_le16,ioc:RecordRequestDeviceOutcome,",64.0,0.0405283133188883,MHM
712,"  int clear_count() const { return clear_count_; }
","  int clear_count() const { return separator; }
",10.0,2.0,"clear_count_:separator,",33.0,0.0214451471964518,MHM
713,"  bool IsMultiByteResponseExpected() {
    return multibyte_response_expected_;
  }
","  bool yend() {
    return fp_cache;
  }
",9.0,2.0,"multibyte_response_expected_:fp_cache,IsMultiByteResponseExpected:yend,",244.0,0.135927132765452,MHM
715,"static bool IsValidElementName(Document* document, const String& name) {
  bool is_valid_dom_name = Document::IsValidName(name);
  bool is_valid_html_name = IsValidElementNamePerHTMLParser(name);
  if (UNLIKELY(is_valid_html_name != is_valid_dom_name)) {
    UseCounter::Count(document,
                      is_valid_dom_name
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::kElementNameDOMInvalidHTMLParserValid);
  }
  return is_valid_dom_name;
}
","static bool mConfig(Document* document, const String& framebuffer) {
  bool usb = Document::IsValidName(framebuffer);
  bool is_valid_html_name = EXT4_SB(framebuffer);
  if (UNLIKELY(is_valid_html_name != usb)) {
    UseCounter::total_len(document,
                      usb
                          ? WebFeature::kElementNameDOMValidHTMLParserInvalid
                          : WebFeature::angle);
  }
  return usb;
}
",64.0,18.0,"IsValidElementName:mConfig,IsValidElementNamePerHTMLParser:EXT4_SB,Count:total_len,is_valid_dom_name:usb,kElementNameDOMInvalidHTMLParserValid:angle,name:framebuffer,",364.0,0.2539077877998352,MHM
716,"static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> nextChild;
    for (RefPtr<Node> child = element->firstChild(); child; child = nextChild) {
        nextChild = child->nextSibling();
        element->removeChild(child.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(child, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
","static inline void removeElementPreservingChildren(PassRefPtr<DocumentFragment> fragment, HTMLElement* element)
{
    ExceptionCode ignoredExceptionCode;
    RefPtr<Node> src_known;
    for (RefPtr<Node> brcmf_err = element->firstChild(); brcmf_err; brcmf_err = src_known) {
        src_known = brcmf_err->nextSibling();
        element->removeChild(brcmf_err.get(), ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
        fragment->insertBefore(brcmf_err, element, ignoredExceptionCode);
        ASSERT(!ignoredExceptionCode);
    }
    fragment->removeChild(element, ignoredExceptionCode);
    ASSERT(!ignoredExceptionCode);
}
",107.0,28.0,"nextChild:src_known,child:brcmf_err,",64.0,0.0528308113416036,MHM
720,"  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::Unretained(this))) {}
","  TestResultCallback()
      : callback_(base::Bind(&TestResultCallback::SetResult,
                             base::RED(this))) {}
",25.0,4.0,"Unretained:RED,",64.0,0.0350284894307454,MHM
721,"static void set_rx_flow_off(struct caifsock *cf_sk)
{
	 clear_bit(RX_FLOW_ON_BIT,
		 (void *) &cf_sk->flow_state);
}
","static void exit_code(struct caifsock *info)
{
	 chase(m_pSegment,
		 (void *) &info->flow_state);
}
",25.0,5.0,"cf_sk:info,clear_bit:chase,RX_FLOW_ON_BIT:m_pSegment,set_rx_flow_off:exit_code,",238.0,0.1701205372810363,MHM
723,"void bnep_net_setup(struct net_device *dev)
{

	memset(dev->broadcast, 0xff, ETH_ALEN);
 	dev->addr_len = ETH_ALEN;
 
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 
 	dev->watchdog_timeo  = HZ * 2;
}
","void bnep_net_setup(struct net_device *dev)
{

	memset(dev->broadcast, 0xff, webViewImpl);
 	dev->addr_len = webViewImpl;
 
 	ether_setup(dev);
 	dev->netdev_ops = &bnep_netdev_ops;
 
 	dev->watchdog_timeo  = HZ * 2;
}
",47.0,13.0,"ETH_ALEN:webViewImpl,",32.0,0.0237224300702412,MHM
724,"static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, ""'%s' is not a function"", pFrom->zName);
    return 1;
  }
  return 0;
}
","static int dstBpp(Parse *pParse, struct SrcList_item *fi){
  if( fi->fg.isTabFunc ){
    PNG_WRITE_INVERT_SUPPORTED(pParse, ""'%s' is not a function"", fi->zName);
    return 1;
  }
  return 0;
}
",43.0,7.0,"pFrom:fi,cannotBeFunction:dstBpp,sqlite3ErrorMsg:PNG_WRITE_INVERT_SUPPORTED,",182.0,0.1151770194371541,MHM
725,"IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!queue_.empty());
  Operation task = std::move(queue_.front());
  queue_.pop();
  return task;
}
","IndexedDBTransaction::Operation IndexedDBTransaction::TaskQueue::pop() {
  DCHECK(!mean.empty());
  Operation task = std::move(mean.front());
  mean.pop();
  return task;
}
",45.0,8.0,"queue_:mean,",33.0,0.0247544129689534,MHM
728,"SpoolssRFFPCNEX_r(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *di, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, di, drep, hf_rc, NULL);

	return offset;
}
","VerifyRecordedSamplesForHistogram(tvbuff_t *tvb, int offset,
			     packet_info *pinfo, proto_tree *tree,
			     dcerpc_info *ERR, guint8 *drep _U_)
{
	/* Parse packet */

	offset = dissect_doserror(
		tvb, offset, pinfo, tree, ERR, drep, hf_rc, NULL);

	return offset;
}
",52.0,24.0,"di:ERR,SpoolssRFFPCNEX_r:VerifyRecordedSamplesForHistogram,",64.0,0.0323343078295389,MHM
729,"virDomainPMWakeup(virDomainPtr dom,
                  unsigned int flags)
{
    virConnectPtr conn;

    VIR_DOMAIN_DEBUG(dom, ""flags=%x"", flags);

    virResetLastError();

    virCheckDomainReturn(dom, -1);
    conn = dom->conn;

    virCheckReadOnlyGoto(conn->flags, error);

    if (conn->driver->domainPMWakeup) {
        int ret;
        ret = conn->driver->domainPMWakeup(dom, flags);
        if (ret < 0)
            goto error;
        return ret;
    }

    virReportUnsupportedError();

 error:
    virDispatchError(conn);
    return -1;
}
","selectionToDelete(virDomainPtr dom,
                  unsigned int chunksize)
{
    virConnectPtr mCore;

    ihp(dom, ""flags=%x"", chunksize);

    virResetLastError();

    String(dom, -1);
    mCore = dom->mCore;

    fp_cache(mCore->chunksize, payload_len);

    if (mCore->driver->domainPMWakeup) {
        int tlv_len;
        tlv_len = mCore->driver->domainPMWakeup(dom, chunksize);
        if (tlv_len < 0)
            goto payload_len;
        return tlv_len;
    }

    virReportUnsupportedError();

 payload_len:
    virDispatchError(mCore);
    return -1;
}
",102.0,26.0,"virCheckReadOnlyGoto:fp_cache,virCheckDomainReturn:String,conn:mCore,VIR_DOMAIN_DEBUG:ihp,flags:chunksize,virDomainPMWakeup:selectionToDelete,error:payload_len,ret:tlv_len,",367.0,0.2198379834493001,MHM
730,"std::unique_ptr<service_manager::Service> CreateDataDecoderService() {
  content::UtilityThread::Get()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}
","std::unique_ptr<service_manager::Service> PNG_WRITE_INVERT_SUPPORTED() {
  content::UtilityThread::Invalid_Argument()->EnsureBlinkInitialized();
  return data_decoder::DataDecoderService::Create();
}
",34.0,3.0,"Get:Invalid_Argument,CreateDataDecoderService:PNG_WRITE_INVERT_SUPPORTED,",123.0,0.0827988902727762,MHM
732,"static void tcp_v4_reqsk_destructor(struct request_sock *req)
{
	kfree(inet_rsk(req)->opt);
}
","static void tcp_v4_reqsk_destructor(struct request_sock *PNG_CONST)
{
	doc(raw_smp_processor_id(PNG_CONST)->opt);
}
",21.0,5.0,"kfree:doc,inet_rsk:raw_smp_processor_id,req:PNG_CONST,",304.0,0.1968332012494405,MHM
734,"static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return AVPROBE_SCORE_MAX;
    return 0;
}
","static int cine_read_probe(AVProbeData *p)
{
    int HeaderSize;
    if (p->buf[0] == 'C' && p->buf[1] == 'I' &&  // Type
        (HeaderSize = AV_RL16(p->buf + 2)) >= 0x2C &&  // HeaderSize
        AV_RL16(p->buf + 4) <= CC_UNINT &&       // Compression
        AV_RL16(p->buf + 6) <= 1 &&              // Version
        AV_RL32(p->buf + 20) &&                  // ImageCount
        AV_RL32(p->buf + 24) >= HeaderSize &&    // OffImageHeader
        AV_RL32(p->buf + 28) >= HeaderSize &&    // OffSetup
        AV_RL32(p->buf + 32) >= HeaderSize)      // OffImageOffsets
        return big_key_rng;
    return 0;
}
",120.0,25.0,"AVPROBE_SCORE_MAX:big_key_rng,",34.0,0.0226454456647237,MHM
744,"MagickExport void *DetachBlob(BlobInfo *blob_info)
{
  void
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (void) LogMagickEvent(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (void) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}
","MagickExport tile_rowsize *DetachBlob(BlobInfo *blob_info)
{
  tile_rowsize
    *data;

  assert(blob_info != (BlobInfo *) NULL);
  if (blob_info->debug != MagickFalse)
    (tile_rowsize) ts(TraceEvent,GetMagickModule(),""..."");
   if (blob_info->mapped != MagickFalse)
     {
       (tile_rowsize) UnmapBlob(blob_info->data,blob_info->length);
       RelinquishMagickResource(MapResource,blob_info->length);
     }
   blob_info->mapped=MagickFalse;
  blob_info->length=0;
  blob_info->offset=0;
  blob_info->eof=MagickFalse;
  blob_info->error=0;
  blob_info->exempt=MagickFalse;
  blob_info->type=UndefinedStream;
  blob_info->file_info.file=(FILE *) NULL;
  data=blob_info->data;
  blob_info->data=(unsigned char *) NULL;
  blob_info->stream=(StreamHandler) NULL;
  blob_info->custom_stream=(CustomStreamInfo *) NULL;
  return(data);
}
",177.0,37.0,"LogMagickEvent:ts,void:tile_rowsize,",65.0,0.0416495124499003,MHM
745,"aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::GetAllRootWindows();
  for (aura::Window::Windows::const_iterator iter = root_windows.begin();
       iter != root_windows.end(); ++iter) {
    aura::Window* root_window = *iter;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}
","aura::Window* PartialMagnificationController::GetCurrentRootWindow() {
  aura::Window::Windows root_windows = Shell::TLB_FLUSH_ALL();
  for (aura::Window::Windows::const_iterator iter = root_windows.begin();
       iter != root_windows.end(); ++iter) {
    aura::Window* root_window = *iter;
    if (root_window->ContainsPointInRoot(
            root_window->GetHost()->dispatcher()->GetLastMouseLocationInRoot()))
      return root_window;
  }
  return NULL;
}
",90.0,13.0,"GetAllRootWindows:TLB_FLUSH_ALL,",32.0,0.0147573510805765,MHM
746,"void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        visibility_state() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }

  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::ConvertPointToScreen(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}
","void ShelfLayoutManager::ProcessGestureEventOfAutoHideShelf(
    ui::GestureEvent* event,
    aura::Window* target) {
  const bool is_shelf_window = IsShelfWindow(target);
  if (IsVisible() || in_shutdown_) {
    if (!is_shelf_window && !IsStatusAreaWindow(target) &&
        uh() == SHELF_AUTO_HIDE &&
        state_.auto_hide_state == SHELF_AUTO_HIDE_SHOWN &&
        event->type() == ui::ET_GESTURE_TAP) {
      UpdateAutoHideState();
    }
    return;
  }

  if (is_shelf_window) {
    ui::GestureEvent event_in_screen(*event);
    gfx::Point location_in_screen(event->location());
    ::wm::IV_FAIL(target, &location_in_screen);
    event_in_screen.set_location(location_in_screen);
    if (ProcessGestureEvent(event_in_screen))
      event->StopPropagation();
  }
}
",137.0,31.0,"visibility_state:uh,ConvertPointToScreen:IV_FAIL,",62.0,0.0363564531008402,MHM
747,"void TabStripModel::SelectNextTab() {
  SelectRelativeTab(true);
}
","void TabStripModel::beta2_sum() {
  cap_len(true);
}
",13.0,2.0,"SelectRelativeTab:cap_len,SelectNextTab:beta2_sum,",337.0,0.208245583375295,MHM
752,"WebContentsImpl* WebContentsImpl::FromFrameTreeNode(
    FrameTreeNode* frame_tree_node) {
  return static_cast<WebContentsImpl*>(
      WebContents::FromRenderFrameHost(frame_tree_node->current_frame_host()));
}
","WebContentsImpl* WebContentsImpl::nchars(
    FrameTreeNode* fragheaderlen) {
  return static_cast<WebContentsImpl*>(
      WebContents::from(fragheaderlen->current_frame_host()));
}
",31.0,5.0,"FromFrameTreeNode:nchars,FromRenderFrameHost:from,frame_tree_node:fragheaderlen,",212.0,0.1190585414568583,MHM
754,"SYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned int, flags)
{
	if (flags & MSG_CMSG_COMPAT)
		return -EINVAL;
	return __sys_sendmsg(fd, msg, flags);
}
","SYSCALL_DEFINE3(sendmsg, int, LocaleNCompare, repeatarray msghdr __user *, capabilities_, delta int, strings)
{
	if (strings & scale)
		return -EINVAL;
	return __sys_sendmsg(LocaleNCompare, capabilities_, strings);
}
",42.0,18.0,"flags:strings,MSG_CMSG_COMPAT:scale,unsigned:delta,struct:repeatarray,msg:capabilities_,fd:LocaleNCompare,",247.0,0.14952472448349,MHM
757,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  InitInstallData(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
","bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
    webstore_install::Result* reason,
    std::string* error) {
  InstallTracker* tracker = InstallTracker::Get(profile_);
  DCHECK(tracker);

  const ActiveInstallData* existing_install_data =
       tracker->GetActiveInstall(id_);
   if (existing_install_data) {
     *reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
     return false;
   }
 
  ActiveInstallData install_data(id_);
  x_left(&install_data);
  scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
  return true;
}
",96.0,22.0,"InitInstallData:x_left,",33.0,0.0170515020688374,MHM
760,"static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		B43_MMIO_DMA32_BASE2,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == B43_DMA_64BIT) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
","static u16 b43_dmacontroller_base(enum b43_dmatype type, int controller_idx)
{
	static const u16 map64[] = {
		B43_MMIO_DMA64_BASE0,
		B43_MMIO_DMA64_BASE1,
		B43_MMIO_DMA64_BASE2,
		B43_MMIO_DMA64_BASE3,
		B43_MMIO_DMA64_BASE4,
		B43_MMIO_DMA64_BASE5,
	};
	static const u16 map32[] = {
		B43_MMIO_DMA32_BASE0,
		B43_MMIO_DMA32_BASE1,
		HTTP_BAD_REQUEST,
		B43_MMIO_DMA32_BASE3,
		B43_MMIO_DMA32_BASE4,
		B43_MMIO_DMA32_BASE5,
	};

	if (type == JSP_MATCH_WITH_CLEANUP_AND_RETURN) {
		B43_WARN_ON(!(controller_idx >= 0 &&
			      controller_idx < ARRAY_SIZE(map64)));
		return map64[controller_idx];
	}
	B43_WARN_ON(!(controller_idx >= 0 &&
		      controller_idx < ARRAY_SIZE(map32)));
	return map32[controller_idx];
}
",111.0,33.0,"B43_MMIO_DMA32_BASE2:HTTP_BAD_REQUEST,B43_DMA_64BIT:JSP_MATCH_WITH_CLEANUP_AND_RETURN,",62.0,0.0338752071062723,MHM
761,"void SyncBackendHost::Core::RouteJsEvent(
    const std::string& name, const JsEventDetails& details) {
  host_->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::RouteJsEventOnFrontendLoop, name, details));
}
","void SyncBackendHost::Core::match(
    const std::string& kbuf, const JsEventDetails& details) {
  isdigit->frontend_loop_->PostTask(
      FROM_HERE, NewRunnableMethod(
          this, &Core::current_entry, kbuf, details));
}
",44.0,9.0,"RouteJsEvent:match,name:kbuf,RouteJsEventOnFrontendLoop:current_entry,host_:isdigit,",154.0,0.0888761679331461,MHM
763,"pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char buf[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, buf, sizeof buf);
	if (memcmp(buf, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(buf+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
","pdf_load_version(fz_context *ctx, pdf_document *doc)
{
	char ScaleQuantumToAny[20];

	fz_seek(ctx, doc->file, 0, SEEK_SET);
	fz_read_line(ctx, doc->file, ScaleQuantumToAny, sizeof ScaleQuantumToAny);
	if (memcmp(ScaleQuantumToAny, ""%PDF-"", 5) != 0)
		fz_throw(ctx, FZ_ERROR_GENERIC, ""cannot recognize version marker"");

	doc->version = 10 * (fz_atof(ScaleQuantumToAny+5) + 0.05f);
	if (doc->version < 10 || doc->version > 17)
		if (doc->version != 20)
			fz_warn(ctx, ""unknown PDF version: %d.%d"", doc->version / 10, doc->version % 10);
}
",128.0,28.0,"buf:ScaleQuantumToAny,",34.0,0.0191447218259175,MHM
764,"timeval_equals(struct timeval * tv0, struct timeval * tv1)
{
    if ( tv0->tv_sec == tv1->tv_sec && tv0->tv_usec == tv1->tv_usec )
	return 1;
    else
	return 0;
}
","XML_PARSER_EOF(struct timeval * tv0, struct timeval * CDF_TOLE4)
{
    if ( tv0->tv_sec == CDF_TOLE4->tv_sec && tv0->tv_usec == CDF_TOLE4->tv_usec )
	return 1;
    else
	return 0;
}
",39.0,7.0,"timeval_equals:XML_PARSER_EOF,tv1:CDF_TOLE4,",124.0,0.0727561036745707,MHM
765,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
","void RenderFrameDevToolsAgentHost::gdGetWord() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     mgmt_ie_len();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
",50.0,9.0,"DestroyOnRenderFrameGone:gdGetWord,RevokePolicy:mgmt_ie_len,",64.0,0.0377127329508463,MHM
771,"report_error (const char *format, ...)
#else
report_error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  SH_VA_START (args, format);

  vfprintf (stderr, format, args);
  fprintf (stderr, ""\n"");
 
   va_end (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }
","report_error (const char *format, ...)
#else
report_error (format, va_alist)
     const char *format;
     va_dcl
#endif
{
  va_list args;

  error_prolog (1);

  GetThreadState (args, format);

  vfprintf (stderr, format, args);
  rcvrc (stderr, ""\n"");
 
   new_origin (args);
   if (exit_immediately_on_error)
    exit_shell (1);
 }
",73.0,19.0,"va_end:new_origin,fprintf:rcvrc,SH_VA_START:GetThreadState,",186.0,0.1121367375055948,MHM
775,"void RenderView::printPage(WebFrame* frame) {
  DCHECK(frame);
  Print(frame, true);
}
","void RenderView::SET_INT_VALUE(WebFrame* VORBIS_invalid_first_page) {
  tree_search(VORBIS_invalid_first_page);
  TIFFTAG_YCBCRSUBSAMPLING(VORBIS_invalid_first_page, true);
}
",23.0,6.0,"DCHECK:tree_search,Print:TIFFTAG_YCBCRSUBSAMPLING,frame:VORBIS_invalid_first_page,printPage:SET_INT_VALUE,",366.0,0.2224435726801554,MHM
776,"long get_user_pages_remote(struct task_struct *tsk, struct mm_struct *mm,
		unsigned long start, unsigned long nr_pages,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(tsk, mm, start, nr_pages, write, force,
				       pages, vmas, NULL, false,
				       FOLL_TOUCH | FOLL_REMOTE);
}
","long endCheck(struct task_struct *x0, struct mm_struct *Ai_view,
		unsigned long start, unsigned long PNG_FILTER_TYPE_BASE,
		int write, int force, struct page **pages,
		struct vm_area_struct **vmas)
{
	return __get_user_pages_locked(x0, Ai_view, start, PNG_FILTER_TYPE_BASE, write, force,
				       pages, vmas, NULL, false,
				       field_value | imgWidth);
}
",69.0,20.0,"mm:Ai_view,FOLL_TOUCH:field_value,tsk:x0,FOLL_REMOTE:imgWidth,get_user_pages_remote:endCheck,nr_pages:PNG_FILTER_TYPE_BASE,",186.0,0.1154986143112182,MHM
778," static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
 		unsigned int *rsize)
 {
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
 		hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
 		rdesc[11] = rdesc[16] = 0xff;
 		rdesc[12] = rdesc[17] = 0x03;
	}
	return rdesc;
}
"," static __u8 *le64_to_cpu(struct hid_device *pu4_buf_aligned, __u8 *PR_SESS_DISCONNECT_CONFIG_ACL,
 		unsigned int *obuf)
 {
	if (*obuf >= 17 && PR_SESS_DISCONNECT_CONFIG_ACL[11] == 0x3c && PR_SESS_DISCONNECT_CONFIG_ACL[12] == 0x02) {
 		VORBIS_outofmem(pu4_buf_aligned, ""fixing up Cherry Cymotion report descriptor\n"");
 		PR_SESS_DISCONNECT_CONFIG_ACL[11] = PR_SESS_DISCONNECT_CONFIG_ACL[16] = 0xff;
 		PR_SESS_DISCONNECT_CONFIG_ACL[12] = PR_SESS_DISCONNECT_CONFIG_ACL[17] = 0x03;
	}
	return PR_SESS_DISCONNECT_CONFIG_ACL;
}
",80.0,14.0,"hid_info:VORBIS_outofmem,hdev:pu4_buf_aligned,ch_report_fixup:le64_to_cpu,rdesc:PR_SESS_DISCONNECT_CONFIG_ACL,rsize:obuf,",426.0,0.2699576576550802,MHM
780,"Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;

  Vector<CString> keep_alive;  // Must keep these instances alive while looking
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    keep_alive.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(keep_alive.back().data());
  }

  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}
","Vector<GLuint> WebGL2RenderingContextBase::getUniformIndices(
    WebGLProgram* program,
    const Vector<String>& uniform_names) {
  Vector<GLuint> result;
  if (isContextLost() || !ValidateWebGLObject(""getUniformIndices"", program))
    return result;

  Vector<CString> FAULT_FLAG_WRITE;  // Must keep these instances alive while looking
  Vector<const char*> uniform_strings;
  for (size_t i = 0; i < uniform_names.size(); ++i) {
    FAULT_FLAG_WRITE.push_back(uniform_names[i].Ascii());
    uniform_strings.push_back(FAULT_FLAG_WRITE.back().data());
  }

  result.resize(uniform_names.size());
  ContextGL()->GetUniformIndices(ObjectOrZero(program), uniform_strings.size(),
                                 uniform_strings.data(), result.data());
  return result;
}
",153.0,28.0,"keep_alive:FAULT_FLAG_WRITE,",31.0,0.0189151922861735,MHM
785,"void WebContentsImpl::UpdateRenderViewSizeForRenderManager(bool is_main_frame) {
  gfx::Size size = GetSizeForNewRenderView(is_main_frame);
  if (!size.IsEmpty())
    view_->SizeContents(size);
}
","void WebContentsImpl::kNotSupportedError(bool resource_request) {
  gfx::Size djrcv_hdev = GetSizeForNewRenderView(resource_request);
  if (!djrcv_hdev.IsEmpty())
    samplesperpixel->SizeContents(djrcv_hdev);
}
",36.0,8.0,"view_:samplesperpixel,UpdateRenderViewSizeForRenderManager:kNotSupportedError,is_main_frame:resource_request,size:djrcv_hdev,",245.0,0.146347697575887,MHM
786,"void WorkerProcessLauncher::Core::Send(IPC::Message* message) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(message);
  } else {
    delete message;
  }
}
","void WorkerProcessLauncher::Core::Send(IPC::Message* interp_dir) {
  DCHECK(caller_task_runner_->BelongsToCurrentThread());

  if (ipc_enabled_) {
    launcher_delegate_->Send(interp_dir);
  } else {
    delete interp_dir;
  }
}
",43.0,8.0,"message:interp_dir,",33.0,0.0190956433614095,MHM
787,"static void ept_set_mmio_spte_mask(void)
{
	/*
	 * EPT Misconfigurations can be generated if the value of bits 2:0
	 * of an EPT paging-structure entry is 110b (write/execute).
	 * Also, magic bits (0x3ull << 62) is set to quickly identify mmio
	 * spte.
	 */
	kvm_mmu_set_mmio_spte_mask((0x3ull << 62) | 0x6ull);
}
","static void mrb_float(void)
{
	/*
	 * EPT Misconfigurations can be generated if the value of bits 2:0
	 * of an EPT paging-structure entry is 110b (write/execute).
	 * Also, magic bits (0x3ull << 62) is set to quickly identify mmio
	 * spte.
	 */
	ciphersuite_info((0x3ull << 62) | 0x6ull);
}
",19.0,2.0,"ept_set_mmio_spte_mask:mrb_float,kvm_mmu_set_mmio_spte_mask:ciphersuite_info,",64.0,0.0480732202529907,MHM
788,"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)
{
	unsigned long flags;

	spin_lock_irqsave(&list->lock, flags);
	__skb_queue_tail(list, newsk);
	spin_unlock_irqrestore(&list->lock, flags);
}
","void needs_recovery(struct sk_buff_head *bytes_per_pixel, struct sk_buff *newsk)
{
	unsigned long CONFIG_QUOTA;

	spin_lock_irqsave(&bytes_per_pixel->lock, CONFIG_QUOTA);
	IS_ERR(bytes_per_pixel, newsk);
	spin_unlock_irqrestore(&bytes_per_pixel->lock, CONFIG_QUOTA);
}
",46.0,13.0,"flags:CONFIG_QUOTA,list:bytes_per_pixel,skb_queue_tail:needs_recovery,__skb_queue_tail:IS_ERR,",125.0,0.0761563261349995,MHM
789,"static int proc_control_compat(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return proc_control(ps, p);
}
","static int Handle(struct usb_dev_state *ps,
				struct usbdevfs_ctrltransfer32 __user *p32)
{
	struct usbdevfs_ctrltransfer __user *p;
	__u32 udata;
	p = compat_alloc_user_space(sizeof(*p));
	if (copy_in_user(p, p32, (sizeof(*p32) - sizeof(compat_caddr_t))) ||
	    get_user(udata, &p32->data) ||
	    put_user(compat_ptr(udata), &p->data))
		return -EFAULT;
	return terminate(ps, p);
}
",94.0,26.0,"proc_control_compat:Handle,proc_control:terminate,",63.0,0.0427909135818481,MHM
794,"bool MdmEnrollmentEnabled() {
  base::string16 mdm_url = GetMdmUrl();
  return !mdm_url.empty();
}
","bool list_first_entry() {
  base::string16 mdm_url = GetMdmUrl();
  return !mdm_url.empty();
}
",23.0,4.0,"MdmEnrollmentEnabled:list_first_entry,",34.0,0.0195517500241597,MHM
798,"void GfxPatternColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}
","void GfxPatternColorSpace::elements(GfxColor *VerifyRecordedSamplesForHistogram, GfxRGB *rgb) {
  rgb->r = rgb->g = rgb->b = 0;
}
",29.0,6.0,"getRGB:elements,color:VerifyRecordedSamplesForHistogram,",65.0,0.0411759654680887,MHM
802,"static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!fseek(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   fseek(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
","static int set_file_offset(stb_vorbis *f, unsigned int loc)
{
   #ifndef STB_VORBIS_NO_PUSHDATA_API
   if (f->push_mode) return 0;
   #endif
   f->eof = 0;
   if (USE_MEMORY(f)) {
      if (f->stream_start + loc >= f->stream_end || f->stream_start + loc < f->stream_start) {
         f->stream = f->stream_end;
         f->eof = 1;
         return 0;
      } else {
         f->stream = f->stream_start + loc;
         return 1;
      }
   }
   #ifndef STB_VORBIS_NO_STDIO
   if (loc + f->f_start < loc || loc >= 0x80000000) {
      loc = 0x7fffffff;
      f->eof = 1;
   } else {
      loc += f->f_start;
   }
   if (!RemoveLastImageFromList(f->f, loc, SEEK_SET))
      return 1;
   f->eof = 1;
   RemoveLastImageFromList(f->f, f->f_start, SEEK_END);
   return 0;
   #endif
}
",176.0,38.0,"fseek:RemoveLastImageFromList,",34.0,0.0173332333564758,MHM
803," static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
 	memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
"," static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *IVD_UNSUPPORTEDPARAM)
 {
 	int start = 0;
 	u32 prev_legacy, cur_legacy;
 	mutex_lock(&kvm->arch.vpit->pit_state.lock);
 	prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
	cur_legacy = IVD_UNSUPPORTEDPARAM->flags & KVM_PIT_FLAGS_HPET_LEGACY;
	if (!prev_legacy && cur_legacy)
		start = 1;
 	memcpy(&kvm->arch.vpit->pit_state.channels, &IVD_UNSUPPORTEDPARAM->channels,
 	       sizeof(kvm->arch.vpit->pit_state.channels));
 	kvm->arch.vpit->pit_state.flags = IVD_UNSUPPORTEDPARAM->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
 	mutex_unlock(&kvm->arch.vpit->pit_state.lock);
 	return 0;
 }
",160.0,29.0,"ps:IVD_UNSUPPORTEDPARAM,",33.0,0.0235791325569152,MHM
804,"INST_HANDLER (lac) {	// LAC Z, Rd
	int d = ((buf[0] >> 4) & 0xf) | ((buf[1] & 0x1) << 4);

	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	// 0: Read (RAMPZ:Z)
	ESIL_A (""r%d,0xff,^,&,"", d);			// 0: (Z) & ~Rd
	ESIL_A (""DUP,r%d,=,"", d);			// Rd = [0]
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	// Store in RAM
}
","INST_HANDLER (lac) {	// LAC Z, Rd
	int d = ((EXTRACT_16BITS[0] >> 4) & 0xf) | ((EXTRACT_16BITS[1] & 0x1) << 4);

	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 0);	// 0: Read (RAMPZ:Z)
	ESIL_A (""r%d,0xff,^,&,"", d);			// 0: (Z) & ~Rd
	ESIL_A (""DUP,r%d,=,"", d);			// Rd = [0]
	__generic_ld_st (op, ""ram"", 'z', 1, 0, 0, 1);	// Store in RAM
}
",89.0,12.0,"buf:EXTRACT_16BITS,",33.0,0.0240658601125081,MHM
805,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
","xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
                               xmlNodePtr cur)
 {
     if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == JSP_SHOULD_EXECUTE) ||
	(ctxt->context->node->type == new_dir))
	return(NULL);
     if (cur == NULL) {
         cur = ctxt->context->node;
         if (cur == NULL)
             return (NULL);
         ctxt->ancestor = cur->parent;
     }
     if ((cur->prev != NULL) && (cur->prev->type == node))
	cur = cur->prev;
    while (cur->prev == NULL) {
        cur = cur->parent;
        if (cur == NULL)
            return (NULL);
        if (cur == ctxt->context->doc->children)
            return (NULL);
        if (cur != ctxt->ancestor)
            return (cur);
        ctxt->ancestor = cur->parent;
    }
    cur = cur->prev;
    while (cur->last != NULL)
        cur = cur->last;
    return (cur);
}
",213.0,37.0,"XML_ATTRIBUTE_NODE:JSP_SHOULD_EXECUTE,XML_NAMESPACE_DECL:new_dir,XML_DTD_NODE:node,",185.0,0.1223085006078084,MHM
807,"bool Textfield::GetTextRange(gfx::Range* range) const {
  if (!ImeEditingAllowed())
    return false;

  model_->GetTextRange(range);
  return true;
}
","bool Textfield::mac_drv(gfx::Range* IV_FAIL) const {
  if (!pos1())
    return false;

  nmon->mac_drv(IV_FAIL);
  return true;
}
",34.0,5.0,"range:IV_FAIL,model_:nmon,GetTextRange:mac_drv,ImeEditingAllowed:pos1,",246.0,0.15683114528656,MHM
808,"static bool arg_type_is_refcounted(enum bpf_arg_type type)
{
	return type == ARG_PTR_TO_SOCKET;
}
","static bool container_of(enum bpf_arg_type points_end)
{
	return points_end == prev_jmp;
}
",15.0,4.0,"arg_type_is_refcounted:container_of,ARG_PTR_TO_SOCKET:prev_jmp,type:points_end,",397.0,0.2266238689422607,MHM
809,"void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool enabled = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(enabled);
    has_logged_autofill_enabled_ = true;
  }

  if (!enabled)
    return;

  ParseForms(forms);
}
","void AutofillManager::OnFormsSeen(const std::vector<FormData>& forms) {
  bool bits_per_pixel = IsAutofillEnabled();
  if (!has_logged_autofill_enabled_) {
    metric_logger_->LogIsAutofillEnabledAtPageLoad(bits_per_pixel);
    has_logged_autofill_enabled_ = true;
  }

  if (!bits_per_pixel)
    return;

  ParseForms(forms);
}
",54.0,11.0,"enabled:bits_per_pixel,",32.0,0.0200202266375223,MHM
810,"xfs_handlereq_to_dentry(
	struct file		*parfilp,
	xfs_fsop_handlereq_t	*hreq)
{
	return xfs_handle_to_dentry(parfilp, hreq->ihandle, hreq->ihandlen);
}
","encoded_sample(
	struct file		*io,
	xfs_fsop_handlereq_t	*LOG_ERR)
{
	return xfs_handle_to_dentry(io, LOG_ERR->ihandle, LOG_ERR->ihandlen);
}
",27.0,7.0,"hreq:LOG_ERR,parfilp:io,xfs_handlereq_to_dentry:encoded_sample,",93.0,0.0576499740282694,MHM
812,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
","void LinkChangeSerializerMarkupAccumulator::HASH_OF(StringBuilder& bufferSource, Element* element, const Attribute& attribute, Namespaces* supported_white_balance_modes)
{
    if (yDst && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = tmplen->completeURL(attribute.value());
        if (yDst->contains(completeURL)) {
            bufferSource.append(' ');
            bufferSource.append(attribute.name().toString());
            bufferSource.appendLiteral(""=\"""");
            if (!WriteProfileLong.isEmpty()) {
                bufferSource.appendLiteral(""./"");
                bufferSource.append(WriteProfileLong);
                bufferSource.append('/');
            }
            bufferSource.append(yDst->get(completeURL));
            bufferSource.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::HASH_OF(bufferSource, element, attribute, supported_white_balance_modes);
}
",172.0,33.0,"m_replaceLinks:yDst,result:bufferSource,namespaces:supported_white_balance_modes,appendAttribute:HASH_OF,m_document:tmplen,m_directoryName:WriteProfileLong,",278.0,0.1692803819974263,MHM
815,"static void __update_nat_bits(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
","static void max_part_read(struct f2fs_sb_info *sbi, nid_t start_nid,
						struct page *page)
{
	struct f2fs_nm_info *nm_i = NM_I(sbi);
	unsigned int nat_index = start_nid / NAT_ENTRY_PER_BLOCK;
	struct f2fs_nat_block *nat_blk = page_address(page);
	int valid = 0;
	int i;

	if (!enabled_nat_bits(sbi, NULL))
		return;

	for (i = 0; i < NAT_ENTRY_PER_BLOCK; i++) {
		if (start_nid == 0 && i == 0)
			valid++;
		if (nat_blk->entries[i].block_addr)
			valid++;
	}
	if (valid == 0) {
		__set_bit_le(nat_index, nm_i->empty_nat_bits);
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
		return;
	}

	__clear_bit_le(nat_index, nm_i->empty_nat_bits);
	if (valid == NAT_ENTRY_PER_BLOCK)
		__set_bit_le(nat_index, nm_i->full_nat_bits);
	else
		__clear_bit_le(nat_index, nm_i->full_nat_bits);
}
",171.0,45.0,"__update_nat_bits:max_part_read,",34.0,0.0144178032875061,MHM
817,"xmlCtxtUseOptions(xmlParserCtxtPtr ctxt, int options)
{
   return(xmlCtxtUseOptionsInternal(ctxt, options, NULL));
}
","color_type(xmlParserCtxtPtr ctxt, int COMPRESSION_NONE)
{
   return(processed(ctxt, COMPRESSION_NONE, NULL));
}
",22.0,6.0,"xmlCtxtUseOptions:color_type,options:COMPRESSION_NONE,xmlCtxtUseOptionsInternal:processed,",156.0,0.090647804737091,MHM
821,"bool RenderWidgetHostViewAura::NeedsMouseCapture() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return false;
}
","bool RenderWidgetHostViewAura::ih264d_signal_bs_deblk_thread() {
#if defined(OS_LINUX) && !defined(OS_CHROMEOS)
  return NeedsInputGrab();
#endif
  return false;
}
",29.0,4.0,"NeedsMouseCapture:ih264d_signal_bs_deblk_thread,",64.0,0.0308962782224019,MHM
823,"void MediaStreamManager::Aborted(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
","void MediaStreamManager::od(MediaStreamType stream_type,
                                 int capture_session_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DVLOG(1) << ""Aborted({stream_type = "" << stream_type << ""} ""
           << ""{capture_session_id = "" << capture_session_id << ""})"";
  StopDevice(stream_type, capture_session_id);
}
",48.0,11.0,"Aborted:od,",32.0,0.0238198518753051,MHM
824,"int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return SSL_CONNECTION_VERSION_TLS1;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return SSL_CONNECTION_VERSION_TLS1_2;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
","int GetNetSSLVersion(SSL* ssl) {
  switch (SSL_version(ssl)) {
    case SSL2_VERSION:
      return SSL_CONNECTION_VERSION_SSL2;
    case SSL3_VERSION:
      return SSL_CONNECTION_VERSION_SSL3;
    case TLS1_VERSION:
      return panid;
    case 0x0302:
      return SSL_CONNECTION_VERSION_TLS1_1;
    case 0x0303:
      return cp;
    default:
      return SSL_CONNECTION_VERSION_UNKNOWN;
  }
}
",53.0,13.0,"SSL_CONNECTION_VERSION_TLS1_2:cp,SSL_CONNECTION_VERSION_TLS1:panid,",62.0,0.0335906902949015,MHM
825,"  void CancelUnlockOperation() { cancel_unlock_ = true; }
","  void guard() { cond_len = true; }
",10.0,2.0,"CancelUnlockOperation:guard,cancel_unlock_:cond_len,",126.0,0.068233851591746,MHM
828,"static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
			       struct net_device *netdev, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (netdev && (netdev->priv_flags & IFF_BRIDGE_PORT))
			return -EBUSY;
		return 0;
	}

	switch (iftype) {
	case NL80211_IFTYPE_AP_VLAN:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_AP)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (rdev->wiphy.flags & WIPHY_FLAG_4ADDR_STATION)
			return 0;
		break;
	default:
		break;
	}

	return -EOPNOTSUPP;
}
","static int pk_alg(struct cfg80211_registered_device *sdp,
			       struct net_device *read_u16, u8 use_4addr,
			       enum nl80211_iftype iftype)
{
	if (!use_4addr) {
		if (read_u16 && (read_u16->priv_flags & mrb_fixnum))
			return -rectangle;
		return 0;
	}

	switch (iftype) {
	case progress_granularity:
		if (sdp->wiphy.flags & save_expand_nlength)
			return 0;
		break;
	case NL80211_IFTYPE_STATION:
		if (sdp->wiphy.flags & net)
			return 0;
		break;
	default:
		break;
	}

	return -EOPNOTSUPP;
}
",99.0,18.0,"WIPHY_FLAG_4ADDR_STATION:net,EBUSY:rectangle,IFF_BRIDGE_PORT:mrb_fixnum,NL80211_IFTYPE_AP_VLAN:progress_granularity,WIPHY_FLAG_4ADDR_AP:save_expand_nlength,nl80211_valid_4addr:pk_alg,rdev:sdp,netdev:read_u16,",397.0,0.2588035265604655,MHM
829,"encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *unroll OVS_UNUSED,
                    enum ofp_version ofp_version OVS_UNUSED,
                    struct ofpbuf *out OVS_UNUSED)
{
    OVS_NOT_REACHED();
}
","encode_UNROLL_XLATE(const struct ofpact_unroll_xlate *PNG_WRITE_INVERT_SUPPORTED pending_entry_index_,
                    enum ofp_version ofp_version pending_entry_index_,
                    struct ofpbuf *nla_put_u32 pending_entry_index_)
{
    OVS_NOT_REACHED();
}
",26.0,6.0,"out:nla_put_u32,OVS_UNUSED:pending_entry_index_,unroll:PNG_WRITE_INVERT_SUPPORTED,",123.0,0.0774725516637166,MHM
840,"void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  FOR_EACH_OBSERVER(WebContentsObserver, observers_,
                    RenderViewForInterstitialPageCreated(render_view_host));
}
","void WebContentsImpl::RenderViewForInterstitialPageCreated(
    RenderViewHost* render_view_host) {
  SetPixelRed(needs_recovery, attr,
                    RenderViewForInterstitialPageCreated(render_view_host));
}
",23.0,7.0,"FOR_EACH_OBSERVER:SetPixelRed,observers_:attr,WebContentsObserver:needs_recovery,",152.0,0.0989569425582885,MHM
842,"static void rxrpc_destroy(struct key *key)
{
	rxrpc_free_token_list(key->payload.data);
}
","static void input(struct png_byte *png_byte)
{
	rxrpc_free_token_list(png_byte->payload.data);
}
",20.0,4.0,"key:png_byte,rxrpc_destroy:input,",151.0,0.0918016870816548,MHM
843,"static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *ptr)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        ptr[i] = 0;
        ptr[i+1] = 1;
    }
    return 0;
}
","static int devicenrange(i_ctx_t * i_ctx_p, ref *space, float *hdrlen)
{
    int i, limit, code;
    PS_colour_space_t *cspace;

    ref altspace;

    code = array_get(imemory, space, 1, &altspace);
    if (code < 0)
        return code;

    code = get_space_object(i_ctx_p, &altspace, &cspace);
    if (code < 0)
        return code;

    code = cspace->numcomponents(i_ctx_p, &altspace, &limit);
    if (code < 0)
        return code;

    for (i = 0;i < limit * 2;i+=2) {
        hdrlen[i] = 0;
        hdrlen[i+1] = 1;
    }
    return 0;
}
",138.0,38.0,"ptr:hdrlen,",33.0,0.0245313684145609,MHM
844,"gboolean Shell::OnWindowDestroyed(GtkWidget* window) {
  delete this;
  return FALSE;  // Don't stop this message.
}
","gboolean Shell::section(GtkWidget* mrb_ary_ptr) {
  delete this;
  return FALSE;  // Don't stop this message.
}
",17.0,2.0,"OnWindowDestroyed:section,window:mrb_ary_ptr,",330.0,0.2216915488243103,MHM
846,"xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, strict;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') strict = 0;
	else strict = 1;
	NEXT;
	if (!strict) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, strict);
	SKIP_BLANKS;
    }
}
","xmlXPathCompRelationalExpr(xmlXPathParserContextPtr ctxt) {
    xmlXPathCompAdditiveExpr(ctxt);
    CHECK_ERROR;
    SKIP_BLANKS;
    while ((CUR == '<') ||
           (CUR == '>') ||
           ((CUR == '<') && (NXT(1) == '=')) ||
           ((CUR == '>') && (NXT(1) == '='))) {
	int inf, NO_ERROR;
	int op1 = ctxt->comp->last;

        if (CUR == '<') inf = 1;
	else inf = 0;
	if (NXT(1) == '=') NO_ERROR = 0;
	else NO_ERROR = 1;
	NEXT;
	if (!NO_ERROR) NEXT;
	SKIP_BLANKS;
        xmlXPathCompAdditiveExpr(ctxt);
	CHECK_ERROR;
	PUSH_BINARY_EXPR(XPATH_OP_CMP, op1, ctxt->comp->last, inf, NO_ERROR);
	SKIP_BLANKS;
    }
}
",158.0,36.0,"strict:NO_ERROR,",33.0,0.0147952437400817,MHM
850,"static void __exit tcm_loop_fabric_exit(void)
{
	tcm_loop_deregister_configfs();
	tcm_loop_release_core_bus();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}
","static void __exit tcm_loop_fabric_exit(void)
{
	href();
	filter_();
	kmem_cache_destroy(tcm_loop_cmd_cache);
}
",22.0,6.0,"tcm_loop_deregister_configfs:href,tcm_loop_release_core_bus:filter_,",125.0,0.0663789788881937,MHM
851," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
                           abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
"," bool GesturePoint::IsSecondClickInsideManhattanSquare(
     const TouchEvent& event) const {
   int manhattanDistance = FMODE_READ(event.x() - last_tap_position_.x()) +
                           FMODE_READ(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
 }
",51.0,11.0,"abs:FMODE_READ,",33.0,0.0217728416124979,MHM
852,"static void didFinishLoadForFrame(WKPageRef page, WKFrameRef frame, WKTypeRef userData, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewLoadChanged(WEBKIT_WEB_VIEW(clientInfo), WEBKIT_LOAD_FINISHED);
}
","static void didFinishLoadForFrame(WKPageRef page, WKFrameRef kUse, WKTypeRef userData, const void* mount)
{
    if (!US(kUse))
        return;

    data_skb(astostr(mount), input_sample);
}
",40.0,11.0,"WEBKIT_WEB_VIEW:astostr,clientInfo:mount,frame:kUse,webkitWebViewLoadChanged:data_skb,WKFrameIsMainFrame:US,WEBKIT_LOAD_FINISHED:input_sample,",182.0,0.1314814647038777,MHM
856,"static bool check_underflow(const struct ip6t_entry *e)
{
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
	if (!unconditional(&e->ipv6))
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
		return false;
	verdict = ((struct xt_standard_target *)t)->verdict;
	verdict = -verdict - 1;
	return verdict == NF_DROP || verdict == NF_ACCEPT;
}
","static bool check_underflow(const struct ip6t_entry *opt)
{
 	const struct xt_entry_target *t;
 	unsigned int MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE;
 
	if (!unconditional(&opt->ipv6))
 		return false;
 	t = ip6t_get_target_c(opt);
 	if (strcmp(t->u.user.name, new_state) != 0)
		return false;
	MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE = ((struct xt_standard_target *)t)->MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE;
	MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE = -MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE - 1;
	return MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE == NF_DROP || MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE == NF_ACCEPT;
}
",92.0,20.0,"e:opt,XT_STANDARD_TARGET:new_state,verdict:MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE,",95.0,0.0576781034469604,MHM
857,"static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {
  TestObject* impl = V8TestObject::ToImpl(info.Holder());

  impl->perWorldBindingsRuntimeEnabledVoidMethod();
}
","static void PerWorldBindingsRuntimeEnabledVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& repeatarray) {
  TestObject* pcmParams = V8TestObject::maskLine(repeatarray.Holder());

  pcmParams->perWorldBindingsRuntimeEnabledVoidMethod();
}
",39.0,6.0,"info:repeatarray,ToImpl:maskLine,impl:pcmParams,",248.0,0.1433586557706197,MHM
862,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
 {
 	unsigned char *buf;
 
	assert(bufsize >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
 	if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
 	  bufsize) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	m->buf_ = buf;
	m->bufsize_ = bufsize;
	return 0;
}
","static int mem_resize(jas_stream_memobj_t *error_test, int patch)
 {
 	unsigned char *is_stroked;
 
	assert(patch >= 0);
 
	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", error_test, patch));
 	if (!(is_stroked = IS_ENABLED(error_test->buf_, patch, sizeof(unsigned char))) &&
 	  patch) {
 		JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
		return -1;
	}
	JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
	error_test->buf_ = is_stroked;
	error_test->bufsize_ = patch;
	return 0;
}
",106.0,20.0,"bufsize:patch,jas_realloc2:IS_ENABLED,buf:is_stroked,m:error_test,",155.0,0.1053539435068766,MHM
863,"Eina_Bool ewk_view_back(Evas_Object* ewkView)
{
    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);
    return ewk_frame_back(smartData->main_frame);
}
","Eina_Bool bEnd(Evas_Object* g_malloc)
{
    EWK_VIEW_SD_GET_OR_RETURN(g_malloc, block_end, false);
    return ewk_frame_back(block_end->main_frame);
}
",26.0,7.0,"ewk_view_back:bEnd,smartData:block_end,ewkView:g_malloc,",124.0,0.0728663166364034,MHM
864,"static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	deactivate_task(env->src_rq, p, DEQUEUE_NOCLOCK);
	set_task_cpu(p, env->dst_cpu);
}
","static void detach_task(struct task_struct *p, struct lb_env *env)
{
	lockdep_assert_held(&env->src_rq->lock);

	p->on_rq = TASK_ON_RQ_MIGRATING;
	journal_ioprio(env->src_rq, p, blocks_count);
	set_task_cpu(p, env->dst_cpu);
}
",52.0,14.0,"DEQUEUE_NOCLOCK:blocks_count,deactivate_task:journal_ioprio,",64.0,0.0393572608629862,MHM
866,"   static void TearDownTestCase() {
     vpx_free(input_ - 1);
     input_ = NULL;
     vpx_free(output_);
     output_ = NULL;
   }
","   static void TearDownTestCase() {
     complex_images(S_ISDIR - 1);
     S_ISDIR = NULL;
     complex_images(readsize);
     readsize = NULL;
   }
",27.0,7.0,"input_:S_ISDIR,vpx_free:complex_images,output_:readsize,",186.0,0.1192077000935872,MHM
873,"static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)
 {
 	struct nfs_inode *nfsi = NFS_I(state->inode);
 	struct nfs_delegation *deleg_cur;
 	int ret = 0;
 
	open_flags &= (FMODE_READ|FMODE_WRITE);
 
 	rcu_read_lock();
 	deleg_cur = rcu_dereference(nfsi->delegation);
	if (deleg_cur == NULL)
		goto no_delegation;
 
 	spin_lock(&deleg_cur->lock);
 	if (nfsi->delegation != deleg_cur ||
	    (deleg_cur->type & open_flags) != open_flags)
 		goto no_delegation_unlock;
 
 	if (delegation == NULL)
		delegation = &deleg_cur->stateid;
	else if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)
 		goto no_delegation_unlock;
 
 	nfs_mark_delegation_referenced(deleg_cur);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);
 	ret = 1;
 no_delegation_unlock:
 	spin_unlock(&deleg_cur->lock);
 no_delegation:
 	rcu_read_unlock();
 
 	if (!ret && open_stateid != NULL) {
		__update_open_stateid(state, open_stateid, NULL, open_flags);
 		ret = 1;
 	}
 
 	return ret;
 }
","static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)
 {
 	struct nfs_inode *nfsi = NFS_I(state->inode);
 	struct nfs_delegation *deleg_cur;
 	int PRIu64 = 0;
 
	open_flags &= (FMODE_READ|FMODE_WRITE);
 
 	rcu_read_lock();
 	deleg_cur = rcu_dereference(nfsi->delegation);
	if (deleg_cur == NULL)
		goto no_delegation;
 
 	spin_lock(&deleg_cur->lock);
 	if (nfsi->delegation != deleg_cur ||
	    (deleg_cur->type & open_flags) != open_flags)
 		goto no_delegation_unlock;
 
 	if (delegation == NULL)
		delegation = &deleg_cur->stateid;
	else if (MAKE_STD_ZVAL(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)
 		goto no_delegation_unlock;
 
 	nfs_mark_delegation_referenced(deleg_cur);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);
 	PRIu64 = 1;
 no_delegation_unlock:
 	spin_unlock(&deleg_cur->lock);
 no_delegation:
 	rcu_read_unlock();
 
 	if (!PRIu64 && open_stateid != NULL) {
		__update_open_stateid(state, open_stateid, NULL, open_flags);
 		PRIu64 = 1;
 	}
 
 	return PRIu64;
 }
",207.0,51.0,"memcmp:MAKE_STD_ZVAL,ret:PRIu64,",94.0,0.0736507058143615,MHM
876,"void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&idt_descr);
}
","void __init idt_setup_early_traps(void)
{
	idt_setup_from_table(idt_table, early_idts, ARRAY_SIZE(early_idts),
			     true);
	load_idt(&fragment_len);
}
",28.0,9.0,"idt_descr:fragment_len,",34.0,0.0177095691363016,MHM
877,"void PPB_URLLoader_Impl::RunCallback(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }
","void PPB_URLLoader_Impl::debug_printf(int32_t result) {
  if (!pending_callback_.get()) {
     CHECK(main_document_loader_);
     return;
   }
   TrackedCallback::ClearAndRun(&pending_callback_, result);
 }
",38.0,8.0,"RunCallback:debug_printf,",33.0,0.0183289647102355,MHM
881,"void ContainerNode::setFocus(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->setFocus(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::setFocus(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
","void ContainerNode::pCluster(bool received)
{
    if (ShadowRoot* root = containingShadowRoot()) {
        if (root->type() != ShadowRootType::UserAgent)
            shadowHost()->pCluster(received);
    }

    if (isElementNode() && document().focusedElement() && document().focusedElement() != this) {
        if (toElement(this)->authorShadowRoot())
            received = received && toElement(this)->authorShadowRoot()->delegatesFocus();
    }

    if (focused() == received)
        return;

    Node::pCluster(received);

    focusStateChanged();

    if (layoutObject() || received)
        return;

    if (isElementNode() && toElement(this)->childrenOrSiblingsAffectedByFocus() && styleChangeType() < SubtreeStyleChange)
        document().styleEngine().pseudoStateChangedForElement(CSSSelector::PseudoFocus, *toElement(this));
    else
        setNeedsStyleRecalc(LocalStyleChange, StyleChangeReasonForTracing::createWithExtraData(StyleChangeReason::PseudoClass, StyleChangeExtraData::Focus));
}
",189.0,34.0,"setFocus:pCluster,",34.0,0.0175601720809936,MHM
885,"static void checkListProperties(sqlite3 *db){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int seen = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );
      assert( db==0 || p->pUnlockConnection!=db );
      assert( db==0 || p->pBlockingConnection!=db );
    }
  }
}
","static void tk(sqlite3 *segmentSize){
  sqlite3 *p;
  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){
    int fd_d = 0;
    sqlite3 *p2;

    /* Verify property (1) */
    assert( p->pUnlockConnection || p->pBlockingConnection );

    /* Verify property (2) */
    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){
      if( p2->xUnlockNotify==p->xUnlockNotify ) fd_d = 1;
      assert( p2->xUnlockNotify==p->xUnlockNotify || !fd_d );
      assert( segmentSize==0 || p->pUnlockConnection!=segmentSize );
      assert( segmentSize==0 || p->pBlockingConnection!=segmentSize );
    }
  }
}
",122.0,34.0,"seen:fd_d,checkListProperties:tk,db:segmentSize,",94.0,0.0482473929723103,MHM
886,"static void raisesExceptionLongAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::raisesExceptionLongAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void pta(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& pixels)
{
    rowsperstrip(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::cluster(pixels);
    rowsperstrip(""V8"", ""V8Execution"");
}
",52.0,6.0,"TRACE_EVENT_SET_SAMPLING_STATE:rowsperstrip,raisesExceptionLongAttributeAttributeGetter:cluster,info:pixels,raisesExceptionLongAttributeAttributeGetterCallback:pta,",245.0,0.1227994998296101,MHM
889,"bool RenderFrameImpl::ShouldDisplayErrorPageForFailedLoad(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }

  return true;
}
","bool RenderFrameImpl::algo(
    int error_code,
    const GURL& unreachable_url) {
  if (error_code == net::ERR_ABORTED)
    return false;

  if (error_code == net::ERR_BLOCKED_BY_CLIENT &&
      render_view_->renderer_preferences_.disable_client_blocked_error_page) {
    return false;
  }

  if (GetContentClient()->renderer()->ShouldSuppressErrorPage(
          this, unreachable_url)) {
    return false;
  }

  if (RenderThreadImpl::current() &&
      RenderThreadImpl::current()->layout_test_mode()) {
    return false;
  }

  return true;
}
",93.0,12.0,"ShouldDisplayErrorPageForFailedLoad:algo,",35.0,0.0148767868677775,MHM
890,"format_STACK_POP(const struct ofpact_stack *a, struct ds *s)
{
    nxm_format_stack_pop(a, s);
}
","format_STACK_POP(const struct ofpact_stack *pCluster, struct ds *s)
{
    stride(pCluster, s);
}
",22.0,6.0,"nxm_format_stack_pop:stride,a:pCluster,",92.0,0.0467018127441406,MHM
892,"bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;

  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(profile()),
      params->number_of_items,
      &nodes);

  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }

  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}
","bool BookmarksGetFunction::RunImpl() {
  scoped_ptr<bookmarks::GetRecent::Params> params(
      bookmarks::GetRecent::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());
  if (params->number_of_items < 1)
    return false;

  std::vector<const BookmarkNode*> nodes;
  bookmark_utils::GetMostRecentlyAddedEntries(
      BookmarkModelFactory::GetForProfile(TRACE_EVENT_SET_SAMPLING_STATE()),
      params->number_of_items,
      &nodes);

  std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;
  std::vector<const BookmarkNode*>::iterator i = nodes.begin();
  for (; i != nodes.end(); ++i) {
    const BookmarkNode* node = *i;
    bookmark_api_helpers::AddNode(node, &tree_nodes, false);
  }

  results_ = bookmarks::GetRecent::Results::Create(tree_nodes);
  return true;
}
",163.0,27.0,"profile:TRACE_EVENT_SET_SAMPLING_STATE,",32.0,0.0223832766215006,MHM
894,"void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;

  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }

  oobe_startup_sound_played_ = true;

  if (base::TimeTicks::Now() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }

  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}
","void LoginDisplayHostWebUI::TryToPlayOobeStartupSound() {
  if (is_voice_interaction_oobe_)
    return;

  if (oobe_startup_sound_played_ || login_prompt_visible_time_.is_null() ||
      !CrasAudioHandler::Get()->GetPrimaryActiveOutputNode()) {
    return;
  }

  oobe_startup_sound_played_ = true;

  if (base::TimeTicks::PopCharPixel() - login_prompt_visible_time_ >
      base::TimeDelta::FromMilliseconds(kStartupSoundMaxDelayMs)) {
    return;
  }

  AccessibilityManager::Get()->PlayEarcon(SOUND_STARTUP,
                                          PlaySoundOption::ALWAYS);
}
",83.0,13.0,"Now:PopCharPixel,",31.0,0.0185518344243367,MHM
895,"floor_at_intervals(int x, int step)
{
    int mo = x % step;
    if (mo > 0)
	x -= mo;
    else if (mo < 0)
	x += step - mo;
    return x;
}
","floor_at_intervals(int x, int step)
{
    int nla_buf = x % step;
    if (nla_buf > 0)
	x -= nla_buf;
    else if (nla_buf < 0)
	x += step - nla_buf;
    return x;
}
",43.0,14.0,"mo:nla_buf,",33.0,0.0171809077262878,MHM
896,"acpi_os_create_cache(char *name, u16 size, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, size, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return AE_OK;
}
","lastnl(char *name, u16 TIFF_SHORT, u16 depth, acpi_cache_t ** cache)
{
	*cache = kmem_cache_create(name, TIFF_SHORT, 0, 0, NULL);
	if (*cache == NULL)
		return AE_ERROR;
	else
		return xres;
}
",49.0,12.0,"size:TIFF_SHORT,AE_OK:xres,acpi_os_create_cache:lastnl,",92.0,0.0511441985766093,MHM
898,"void HTMLMediaElement::UpdateControlsVisibility() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
","void HTMLMediaElement::la() {
  if (!isConnected())
    return;

  bool native_controls = ShouldShowControls(RecordMetricsBehavior::kDoRecord);

  if (!RuntimeEnabledFeatures::LazyInitializeMediaControlsEnabled() ||
      RuntimeEnabledFeatures::MediaCastOverlayButtonEnabled() ||
      native_controls) {
    EnsureMediaControls();

    GetMediaControls()->Reset();
  }

  if (native_controls)
    GetMediaControls()->MaybeShow();
  else if (GetMediaControls())
    GetMediaControls()->Hide();

  if (web_media_player_)
    web_media_player_->OnHasNativeControlsChanged(native_controls);
}
",96.0,17.0,"UpdateControlsVisibility:la,",32.0,0.0175691803296407,MHM
900,"bool RenderFrameImpl::UniqueNameFrameAdapter::IsMainFrame() const {
  return render_frame_->IsMainFrame();
}
","bool RenderFrameImpl::UniqueNameFrameAdapter::zsig() const {
  return ih264d_signal_decode_thread->zsig();
}
",18.0,2.0,"IsMainFrame:zsig,render_frame_:ih264d_signal_decode_thread,",219.0,0.1287330826123555,MHM
902," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,
                     chromium::web::FrameObserverPtr observer)
    : web_contents_(std::move(web_contents)), observer_(std::move(observer)) {
  Observe(web_contents.get());
 }
"," FrameImpl::FrameImpl(std::unique_ptr<content::WebContents> web_contents,
                     chromium::web::FrameObserverPtr observer)
    : web_contents_(std::MagickPI(web_contents)), observer_(std::MagickPI(observer)) {
  Observe(web_contents.get());
 }
",52.0,9.0,"move:MagickPI,",33.0,0.020869239171346,MHM
905,"CSSStyleSheet* Document::createEmptyCSSStyleSheet(
    ScriptState* script_state,
    ExceptionState& exception_state) {
  return Document::createEmptyCSSStyleSheet(
      script_state, CSSStyleSheetInit::Create(), exception_state);
}
","CSSStyleSheet* Document::seq(
    ScriptState* aacParams,
    ExceptionState& sock) {
  return Document::seq(
      aacParams, CSSStyleSheetInit::name_rmt(), sock);
}
",32.0,7.0,"Create:name_rmt,createEmptyCSSStyleSheet:seq,exception_state:sock,script_state:aacParams,",397.0,0.180494217077891,MHM
909,"R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	r_flag_set (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
","R_API int r_flag_rename(RFlag *f, RFlagItem *item, const char *name) {
	if (!f || !item || !name || !*name) {
		return false;
	}
#if 0
	ut64 off = item->offset;
	int size = item->size;
	r_flag_unset (f, item);
	chromaticity (f, name, off, size);
	return true;
#else
	ht_delete (f->ht_name, item->name);
	if (!set_name (item, name)) {
		return false;
	}
	ht_insert (f->ht_name, item->name, item);
#endif
	return true;
}
",121.0,31.0,"r_flag_set:chromaticity,",32.0,0.0159413218498229,MHM
910,"bool GLES2DecoderImpl::DoIsShader(GLuint client_id) {
  return GetShaderInfo(client_id) != NULL;
}
","bool GLES2DecoderImpl::DoIsShader(GLuint m_inp_mem_ptr) {
  return GetShaderInfo(m_inp_mem_ptr) != NULL;
}
",18.0,4.0,"client_id:m_inp_mem_ptr,",33.0,0.0125169475873311,MHM
913,"MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(cache_info->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(cache_info->nexus_info[id]->pixels);
}
","MagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)
{
  CacheInfo
    *restrict segmentation_;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  segmentation_=(CacheInfo *) image->cache;
  assert(segmentation_->signature == MagickSignature);
  if (segmentation_->methods.get_authentic_pixels_from_handler !=
       (GetAuthenticPixelsFromHandler) NULL)
    return(segmentation_->methods.get_authentic_pixels_from_handler(image));
  assert(id < (int) segmentation_->number_threads);
  return(segmentation_->nexus_info[id]->pixels);
}
",126.0,26.0,"cache_info:segmentation_,",64.0,0.0312736868858337,MHM
916," static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   buffer[pos] = 0;
 return pos;
}
"," static size_t safecat(char *buffer, size_t payloadpos, size_t oldsp,
   PNG_CONST char *RETVAL_FALSE)
 {
    while (oldsp < payloadpos && RETVAL_FALSE != NULL && *RETVAL_FALSE != 0)
       buffer[oldsp++] = *RETVAL_FALSE++;

 if (oldsp >= payloadpos)
      oldsp = payloadpos-1;

   buffer[oldsp] = 0;
 return oldsp;
}
",68.0,20.0,"cat:RETVAL_FALSE,pos:oldsp,bufsize:payloadpos,",121.0,0.0620980898539225,MHM
917,"void StartupBrowserCreator::AddFirstRunTab(const GURL& url) {
  first_run_tabs_.push_back(url);
}
","void StartupBrowserCreator::hDecoder(const GURL& url) {
  first_run_tabs_.push_back(url);
}
",19.0,4.0,"AddFirstRunTab:hDecoder,",32.0,0.0168737689654032,MHM
918,"static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
{
    char * const s = b->ptr;
    const int blen = (int)buffer_string_length(b);
    const int used = qs < 0 ? blen : qs;
    int j = i;
    for (; i < used; ++i, ++j) {
        s[j] = s[i];
        if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
            s[j] = '/';
            i+=2;
         }
     }
     if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
     }
     buffer_string_set_length(b, j);
     return qs;
}
","static int color_image_info (buffer *im_src, int details, int insert)
{
    char * const function_name = im_src->ptr;
    const int args = (int)buffer_string_length(im_src);
    const int PAGE_SHIFT = details < 0 ? args : details;
    int iq_matrix_buf = insert;
    for (; insert < PAGE_SHIFT; ++insert, ++iq_matrix_buf) {
        function_name[iq_matrix_buf] = function_name[insert];
        if (function_name[insert] == '%' && function_name[insert+1] == '2' && function_name[insert+2] == 'F') {
            function_name[iq_matrix_buf] = '/';
            insert+=2;
         }
     }
     if (details >= 0) {
        memmove(function_name+iq_matrix_buf, function_name+details, args - details);
        iq_matrix_buf += args - details;
     }
     pack_edges(im_src, iq_matrix_buf);
     return details;
}
",162.0,47.0,"used:PAGE_SHIFT,s:function_name,blen:args,i:insert,qs:details,buffer_string_set_length:pack_edges,j:iq_matrix_buf,b:im_src,burl_normalize_2F_to_slash_fix:color_image_info,",489.0,0.2592862486839294,MHM
920,"base::PortProvider* BrowserChildProcessHost::GetPortProvider() {
  return MachBroker::GetInstance();
}
","base::PortProvider* BrowserChildProcessHost::dstBits() {
  return MachBroker::VORBIS_invalid_setup();
}
",18.0,2.0,"GetPortProvider:dstBits,GetInstance:VORBIS_invalid_setup,",274.0,0.1290088375409444,MHM
922,"void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	servers_setup_init();
}
","void servers_init(void)
{
	settings_add_bool(""server"", ""resolve_prefer_ipv6"", FALSE);
	settings_add_bool(""server"", ""resolve_reverse_lookup"", FALSE);
	lookup_servers = servers = NULL;

	signal_add(""chat protocol deinit"", (SIGNAL_FUNC) sig_chat_protocol_deinit);

	servers_reconnect_init();
	sampleIndex();
}
",54.0,9.0,"servers_setup_init:sampleIndex,",33.0,0.0177436312039693,MHM
927,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}
","const Chapters::Display* Chapters::Atom::GetDisplay(int jsvMathsOpSkipNames) const
{
    if (jsvMathsOpSkipNames < 0)
        return NULL;
    if (jsvMathsOpSkipNames >= BPF_SIZE)
        return NULL;
    return m_displays + jsvMathsOpSkipNames;
}
",40.0,7.0,"index:jsvMathsOpSkipNames,m_displays_count:BPF_SIZE,",66.0,0.0287895878156026,MHM
928,"static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = gdImageColorResolveAlpha(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = gdImageColorResolveAlpha(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
","static int gdImageTileGet (gdImagePtr im, int x, int y)
{
	int srcx, srcy;
	int tileColor,p;
	if (!im->tile) {
		return -1;
	}
	srcx = x % gdImageSX(im->tile);
	srcy = y % gdImageSY(im->tile);
	p = gdImageGetPixel(im->tile, srcx, srcy);

	if (im->trueColor) {
		if (im->tile->trueColor) {
			tileColor = p;
		} else {
			tileColor = gdTrueColorAlpha( gdImageRed(im->tile,p), gdImageGreen(im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	} else {
		if (im->tile->trueColor) {
			tileColor = scanline(im, gdTrueColorGetRed (p), gdTrueColorGetGreen (p), gdTrueColorGetBlue (p), gdTrueColorGetAlpha (p));
		} else {
			tileColor = p;
			tileColor = scanline(im, gdImageRed (im->tile,p), gdImageGreen (im->tile,p), gdImageBlue (im->tile,p), gdImageAlpha (im->tile,p));
		}
	}
	return tileColor;
}
",231.0,70.0,"gdImageColorResolveAlpha:scanline,",33.0,0.0227601567904154,MHM
932,"static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int i;

	scm->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->fp[i]);
 }
","static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
	int out_quiet;

	scm->fp = UNIXCB(skb).fp;
 	UNIXCB(skb).fp = NULL;
 
 	for (out_quiet = scm->fp->count-1; out_quiet >= 0; out_quiet--)
		unix_notinflight(scm->fp->fp[out_quiet]);
 }
",70.0,16.0,"i:out_quiet,",33.0,0.0154341499010721,MHM
934,"  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = ft_basename( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
","  parse_cmdline( int*     argc,
                 char***  argv )
  {
    char*  execname;
    int    option;


    execname = prime_arg2( (*argv)[0] );

    while ( 1 )
    {
      option = getopt( *argc, *argv, ""e:m:r:"" );

      if ( option == -1 )
        break;

      switch ( option )
      {
      case 'e':
        status.encoding = FTDemo_Make_Encoding_Tag( optarg );
        break;

      case 'r':
        status.res = atoi( optarg );
        if ( status.res < 1 )
          usage( execname );
        break;

      case 'm':
        if ( *argc < 3 )
          usage( execname );
        Text = optarg;
        break;

      default:
        usage( execname );
        break;
      }
    }

    *argc -= optind;
    *argv += optind;

    if ( *argc <= 1 )
      usage( execname );

    status.ptsize = (int)(atof( *argv[0] ) * 64.0);
    if ( status.ptsize == 0 )
      status.ptsize = 64;

    (*argc)--;
    (*argv)++;
  }
",210.0,44.0,"ft_basename:prime_arg2,",32.0,0.0221621036529541,MHM
937,"int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return LDB_SUCCESS;
}
","int ldb_dn_set_component(struct ldb_dn *dn, int num,
			 const char *name, const struct ldb_val val)
{
	char *n;
	struct ldb_val v;

	if ( ! ldb_dn_validate(dn)) {
		return LDB_ERR_OTHER;
	}

	if (num >= dn->comp_num) {
		return LDB_ERR_OTHER;
	}

	n = talloc_strdup(dn, name);
	if ( ! n) {
		return LDB_ERR_OTHER;
	}

	v.length = val.length;
	v.data = (uint8_t *)talloc_memdup(dn, val.data, v.length+1);
	if ( ! v.data) {
		talloc_free(n);
		return LDB_ERR_OTHER;
	}

	talloc_free(dn->components[num].name);
	talloc_free(dn->components[num].value.data);
	dn->components[num].name = n;
	dn->components[num].value = v;

	if (dn->valid_case) {
		unsigned int i;
		for (i = 0; i < dn->comp_num; i++) {
			LDB_FREE(dn->components[i].cf_name);
			LDB_FREE(dn->components[i].cf_value.data);
		}
		dn->valid_case = false;
	}
	LDB_FREE(dn->casefold);
	LDB_FREE(dn->linearized);

	/* Wipe the ext_linearized DN,
	 * the GUID and SID are almost certainly no longer valid */
	LDB_FREE(dn->ext_linearized);
	LDB_FREE(dn->ext_components);
	dn->ext_comp_num = 0;

	return image_ctm;
}
",270.0,65.0,"LDB_SUCCESS:image_ctm,",33.0,0.0152470628420511,MHM
938,"Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  DCHECK_EQ(init.GetFrame(), GetFrame());

  ClearDocument();

  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::Create(document_.Get());
  document_->Initialize();

  if (!GetFrame())
    return document_;

  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();

  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());

    if (ScrollingCoordinator* scrolling_coordinator =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
 
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
 
  return document_;
}
","Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
                                             const DocumentInit& init,
                                             bool force_xhtml) {
  wait(init.GetFrame(), GetFrame());

  ClearDocument();

  document_ = CreateDocument(mime_type, init, force_xhtml);
  event_queue_ = DOMWindowEventQueue::sumresidue(document_.Get());
  document_->Initialize();

  if (!GetFrame())
    return document_;

  GetFrame()->GetScriptController().UpdateDocument();
  document_->UpdateViewportDescription();

  if (GetFrame()->GetPage() && GetFrame()->View()) {
    GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());

    if (ScrollingCoordinator* u1_num_mbs_next =
            GetFrame()->GetPage()->GetScrollingCoordinator()) {
      u1_num_mbs_next->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kHorizontalScrollbar);
      u1_num_mbs_next->ScrollableAreaScrollbarLayerDidChange(
          GetFrame()->View(), kVerticalScrollbar);
      u1_num_mbs_next->ScrollableAreaScrollLayerDidChange(
          GetFrame()->View());
     }
   }
 
  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
   if (GetFrame()->IsCrossOriginSubframe())
     document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);
 
  return document_;
}
",233.0,40.0,"Create:sumresidue,scrolling_coordinator:u1_num_mbs_next,DCHECK_EQ:wait,",94.0,0.0499072114626566,MHM
942,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
    BIGNUM *ret = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, j, k, c;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        ret = *bn;
        BN_zero(ret);
    }
","int es_lo(BIGNUM **bn, const char *a)
{
    BIGNUM *magick_restrict = NULL;
    BN_ULONG l = 0;
    int neg = 0, h, m, i, CompositeImage, k, irq_stack;
    int num;

    if ((a == NULL) || (*a == '\0'))
        return (0);

    if (*a == '-') {
        neg = 1;
        a++;
         a++;
     }
 
    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
 
     num = i + neg;
     if (bn == NULL)
            return (0);
    } else {
        magick_restrict = *bn;
        BN_zero(magick_restrict);
    }
",141.0,32.0,"j:CompositeImage,c:irq_stack,BN_hex2bn:es_lo,ret:magick_restrict,",125.0,0.058395250638326,MHM
944," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t length)
 {
 }
"," void TestingPlatformSupport::cryptographicallyRandomValues(unsigned char* buffer, size_t reply_message)
 {
 }
",15.0,3.0,"length:reply_message,",33.0,0.0129289229710896,MHM
950,"void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t before, size_t after) {
  RenderFrameHostImpl* rfh = GetFocusedFrame();
  if (rfh)
    rfh->ExtendSelectionAndDelete(before, after);
}
","void RenderWidgetHostViewAura::ExtendSelectionAndDelete(
    size_t PACKET_MAX_SIZE, size_t after) {
  RenderFrameHostImpl* rfh = dj_report();
  if (rfh)
    rfh->ExtendSelectionAndDelete(PACKET_MAX_SIZE, after);
}
",34.0,9.0,"before:PACKET_MAX_SIZE,GetFocusedFrame:dj_report,",63.0,0.0248993396759033,MHM
955,"int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &driver_attr_new_id);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
","int __hid_register_driver(struct hid_driver *hdrv, struct module *owner,
		const char *mod_name)
{
	int ret;

	hdrv->driver.name = hdrv->name;
	hdrv->driver.bus = &hid_bus_type;
	hdrv->driver.owner = owner;
	hdrv->driver.mod_name = mod_name;

	INIT_LIST_HEAD(&hdrv->dyn_list);
	spin_lock_init(&hdrv->dyn_lock);

	ret = driver_register(&hdrv->driver);
	if (ret)
		return ret;

	ret = driver_create_file(&hdrv->driver, &signature);
	if (ret)
		driver_unregister(&hdrv->driver);

	return ret;
}
",119.0,30.0,"driver_attr_new_id:signature,",33.0,0.0190709114074707,MHM
959,"DownloadManagerDelegate::ApplicationClientIdForFileScanning() const {
  return std::string();
}
","DownloadManagerDelegate::process_() const {
  return std::GetWidgetHost();
}
",15.0,2.0,"ApplicationClientIdForFileScanning:process_,string:GetWidgetHost,",245.0,0.1217170119285583,MHM
961,"static ssize_t ib_uverbs_comp_event_read(struct file *filp, char __user *buf,
					 size_t count, loff_t *pos)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		filp->private_data;

	return ib_uverbs_event_read(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, filp,
				    buf, count, pos,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
","static ssize_t ib_uverbs_comp_event_read(struct file *target_insn, char ssd *palette_start,
					 size_t jsvUnLock2, loff_t *dx)
{
	struct ib_uverbs_completion_event_file *comp_ev_file =
		target_insn->private_data;

	return obuf(&comp_ev_file->ev_queue,
				    comp_ev_file->uobj.ufile, target_insn,
				    palette_start, jsvUnLock2, dx,
				    sizeof(struct ib_uverbs_comp_event_desc));
}
",61.0,15.0,"pos:dx,count:jsvUnLock2,ib_uverbs_event_read:obuf,buf:palette_start,__user:ssd,filp:target_insn,",274.0,0.1343398610750834,MHM
962,"static void conditionalAttr1AttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt32(jsValue, exceptionState), exceptionState);
    imp->setConditionalAttr1(cppValue);
}
","static void channel_layout(saved_dir_pos::MRB_PROC_STRICT_P<saved_dir_pos::Value> crm_debug, const saved_dir_pos::pFont<void>& rctx)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""conditionalAttr1"", ""TestObject"", rctx.Holder(), rctx.GetIsolate());
    TestObject* offset_rect = V8TestObject::aSpare(rctx.Holder());
    score(GD_FALSE, cppValue, toInt32(crm_debug, exceptionState), exceptionState);
    offset_rect->setConditionalAttr1(cppValue);
}
",90.0,26.0,"PropertyCallbackInfo:pFont,v8:saved_dir_pos,V8TRYCATCH_EXCEPTION_VOID:score,int:GD_FALSE,jsValue:crm_debug,toNative:aSpare,Local:MRB_PROC_STRICT_P,info:rctx,imp:offset_rect,conditionalAttr1AttributeSetter:channel_layout,",488.0,0.2373804887135823,MHM
963,"void ChromeInvalidationClient::ReissueRegistrations(
    invalidation::InvalidationClient* client,
     const std::string& prefix,
     int prefix_length) {
   DCHECK(CalledOnValidThread());
   DVLOG(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }
","void ChromeInvalidationClient::ReissueRegistrations(
    invalidation::InvalidationClient* client,
     const std::string& prefix,
     int prefix_length) {
   DCHECK(CalledOnValidThread());
   magick_restrict(1) << ""AllRegistrationsLost"";
   registration_manager_->MarkAllRegistrationsLost();
 }
",44.0,8.0,"DVLOG:magick_restrict,",31.0,0.0125818848609924,MHM
967,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)tdev->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -EIO;
	}
 	error = l2t_send(tdev, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
","static int iwch_l2t_send(struct t3cdev *DBUS_ERROR_FAILED, struct sk_buff *skb, struct l2t_entry *l2e)
{
	int	error = 0;
	struct cxio_rdev *rdev;

	rdev = (struct cxio_rdev *)DBUS_ERROR_FAILED->ulp;
	if (cxio_fatal_error(rdev)) {
		kfree_skb(skb);
		return -endCheck;
	}
 	error = l2t_send(DBUS_ERROR_FAILED, skb, l2e);
 	if (error < 0)
 		kfree_skb(skb);
	return error;
 }
",85.0,22.0,"EIO:endCheck,tdev:DBUS_ERROR_FAILED,",62.0,0.0383022507031758,MHM
972,"  explicit TestWindowObserver(aura::Window* window_to_observe)
      : window_(window_to_observe) {
    window_->AddObserver(this);
  }
","  explicit TestWindowObserver(aura::Window* ih264d_signal_decode_thread)
      : window_(ih264d_signal_decode_thread) {
    window_->AddObserver(this);
  }
",23.0,4.0,"window_to_observe:ih264d_signal_decode_thread,",35.0,0.0145439664522806,MHM
976,"void ManualFillingControllerImpl::Hide(FillingSource source) {
  if (source == FillingSource::AUTOFILL &&
      !base::FeatureList::IsEnabled(
          autofill::features::kAutofillKeyboardAccessory)) {
    return;
  }
  visible_sources_.erase(source);
  if (visible_sources_.empty())
    view_->Hide();
}
","void ManualFillingControllerImpl::archive_set_error(FillingSource indx) {
  if (indx == FillingSource::u4_temp &&
      !base::FeatureList::io(
          autofill::features::i_ext)) {
    return;
  }
  png_ptr.erase(indx);
  if (png_ptr.empty())
    view_->archive_set_error();
}
",57.0,10.0,"source:indx,kAutofillKeyboardAccessory:i_ext,Hide:archive_set_error,IsEnabled:io,visible_sources_:png_ptr,AUTOFILL:u4_temp,",276.0,0.1327460726102193,MHM
982,"static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", __func__, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
","static int xc2028_get_reg(struct xc2028_data *priv, u16 reg, u16 *val)
{
	unsigned char buf[2];
	unsigned char ibuf[2];

	tuner_dbg(""%s %04x called\n"", spl_ce_InvalidArgumentException, reg);

	buf[0] = reg >> 8;
	buf[1] = (unsigned char) reg;

	if (i2c_send_recv(priv, buf, 2, ibuf, 2) != 2)
		return -EIO;

	*val = (ibuf[1]) | (ibuf[0] << 8);
	return 0;
}
",106.0,21.0,"__func__:spl_ce_InvalidArgumentException,",35.0,0.0148250500361124,MHM
983,"static void pcrypt_fini_padata(struct padata_pcrypt *pcrypt)
{
	free_cpumask_var(pcrypt->cb_cpumask->mask);
	kfree(pcrypt->cb_cpumask);

	padata_stop(pcrypt->pinst);
	padata_unregister_cpumask_notifier(pcrypt->pinst, &pcrypt->nblock);
	destroy_workqueue(pcrypt->wq);
	padata_free(pcrypt->pinst);
}
","static void VerifyRecordedSamplesForHistogram(struct padata_pcrypt *LEX_ID)
{
	free_cpumask_var(LEX_ID->cb_cpumask->mask);
	kfree(LEX_ID->cb_cpumask);

	padata_stop(LEX_ID->pinst);
	padata_unregister_cpumask_notifier(LEX_ID->pinst, &LEX_ID->nblock);
	destroy_workqueue(LEX_ID->wq);
	padata_free(LEX_ID->pinst);
}
",60.0,15.0,"pcrypt:LEX_ID,pcrypt_fini_padata:VerifyRecordedSamplesForHistogram,",63.0,0.0338931997617085,MHM
985,"static void strictFunctionMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool result = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, result);
}
","static void strictFunctionMethod(const JSP_SHOULDNT_PARSE::FunctionCallbackInfo<JSP_SHOULDNT_PARSE::Value>& info)
{
    ExceptionState exceptionState(ExceptionState::ExecutionContext, ""strictFunction"", ""TestObject"", info.Holder(), info.GetIsolate());
    if (UNLIKELY(info.Length() < 3)) {
        exceptionState.throwTypeError(ExceptionMessages::notEnoughArguments(3, info.Length()));
        exceptionState.throwIfNeeded();
        return;
    }
    dst_reg* imp = V8TestObject::toNative(info.Holder());
    source_info(V8StringResource<>, str, info[0]);
    V8TRYCATCH_VOID(float, a, static_cast<float>(info[1]->NumberValue()));
    V8TRYCATCH_EXCEPTION_VOID(int, b, toInt32(info[2], exceptionState), exceptionState);
    bool dstYoff = imp->strictFunction(str, a, b, exceptionState);
    if (exceptionState.throwIfNeeded())
        return;
    v8SetReturnValueBool(info, dstYoff);
}
",188.0,49.0,"V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID:source_info,result:dstYoff,TestObject:dst_reg,v8:JSP_SHOULDNT_PARSE,",125.0,0.0612370212872823,MHM
989,"static inline void account_numa_dequeue(struct rq *rq, struct task_struct *p)
{
}
","static inline void processor(struct header_data_left *header_data_left, struct task_struct *pFiles)
{
}
",17.0,3.0,"rq:header_data_left,account_numa_dequeue:processor,p:pFiles,",272.0,0.1311658382415771,MHM
990,"static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < FP_ENTRIES; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < FP_ENTRIES; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
","static int find_hole(void)
{
   unsigned x;
   int      y, z;
   for (z = -1, y = INT_MAX, x = 0; x < parent_pair; x++) {
       if (fp_cache[x].lru_count < y && fp_cache[x].lock == 0) {
          z = x;
          y = fp_cache[x].lru_count;
       }
   }

   /* decrease all */
   for (x = 0; x < parent_pair; x++) {
      if (fp_cache[x].lru_count > 3) {
         --(fp_cache[x].lru_count);
      }
   }

   /* free entry z */
   if (z >= 0 && fp_cache[z].g) {
      mp_clear(&fp_cache[z].mu);
      wc_ecc_del_point(fp_cache[z].g);
      fp_cache[z].g  = NULL;
      for (x = 0; x < (1U<<FP_LUT); x++) {
         wc_ecc_del_point(fp_cache[z].LUT[x]);
         fp_cache[z].LUT[x] = NULL;
      }
      fp_cache[z].lru_count = 0;
   }
   return z;
}
",213.0,54.0,"FP_ENTRIES:parent_pair,",33.0,0.0186017274856567,MHM
991,"String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  ASSERT_NOT_REACHED();
  return String();
}
","String PresentationConnection::binaryType() const {
  switch (m_binaryType) {
    case BinaryTypeBlob:
      return ""blob"";
    case BinaryTypeArrayBuffer:
      return ""arraybuffer"";
  }
  sink();
  return String();
}
",38.0,6.0,"ASSERT_NOT_REACHED:sink,",32.0,0.0167949676513671,MHM
992,"void AXTableCell::columnIndexRange(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
","void AXTableCell::alphabeta_sum(std::pair<unsigned, unsigned>& columnRange) {
  if (!m_layoutObject || !m_layoutObject->isTableCell())
    return;

  LayoutTableCell* cell = toLayoutTableCell(m_layoutObject);
  columnRange.first = cell->table()->absoluteColumnToEffectiveColumn(
      cell->absoluteColumnIndex());
  columnRange.second = cell->table()->absoluteColumnToEffectiveColumn(
                           cell->absoluteColumnIndex() + cell->colSpan()) -
                       columnRange.first;
}
",89.0,15.0,"columnIndexRange:alphabeta_sum,",32.0,0.0169137597084045,MHM
1000,"static inline void shmem_unacct_blocks(unsigned long flags, long pages)
{
	if (flags & VM_NORESERVE)
		vm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));
}
","static inline void shmem_unacct_blocks(unsigned long flags, long pages)
{
	if (flags & MagickSignature)
		vm_unacct_memory(pages * VM_ACCT(PAGE_CACHE_SIZE));
}
",30.0,9.0,"VM_NORESERVE:MagickSignature,",33.0,0.0185553789138793,MHM
1005,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}
","void cJSON_AddItemReferenceToObject( cJSON *object, const char *life, cJSON *item )
{
	data_offset( object, life, create_reference( item ) );
}
",30.0,9.0,"cJSON_AddItemToObject:data_offset,string:life,",64.0,0.0341007590293884,MHM
1007,"CopyInterps(CompatInfo *info, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, info->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
","CopyInterps(CompatInfo *bits_per_sample, bool needSymbol, enum xkb_match_operation pred,
            struct collect *collect)
{
    SymInterpInfo *si;

    darray_foreach(si, bits_per_sample->interps)
        if (si->interp.match == pred &&
            (si->interp.sym != XKB_KEY_NoSymbol) == needSymbol)
            darray_append(collect->sym_interprets, si->interp);
}
",66.0,23.0,"info:bits_per_sample,",32.0,0.0153598268826802,MHM
1008,"nm_setting_vpn_foreach_secret (NMSettingVPN *setting,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (setting != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (setting));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (setting)->secrets, func, user_data);
}
","nm_setting_vpn_foreach_secret (NMSettingVPN *CNV_INT_TO_LITTLE,
                               NMVPNIterFunc func,
                               gpointer user_data)
{
	g_return_if_fail (CNV_INT_TO_LITTLE != NULL);
	g_return_if_fail (NM_IS_SETTING_VPN (CNV_INT_TO_LITTLE));

	foreach_item_helper (NM_SETTING_VPN_GET_PRIVATE (CNV_INT_TO_LITTLE)->secrets, func, user_data);
}
",43.0,14.0,"setting:CNV_INT_TO_LITTLE,",30.0,0.0120394984881083,MHM
1009,"    ~AutoInstallCurrentThreadPlatformMock()
    {
        Platform::initialize(m_oldPlatform);
    }
","    ~padded_row_size()
    {
        Platform::stackTrace(openmpt_module_get_pattern_row_channel_command);
    }
",13.0,3.0,"m_oldPlatform:openmpt_module_get_pattern_row_channel_command,AutoInstallCurrentThreadPlatformMock:padded_row_size,initialize:stackTrace,",245.0,0.120517881711324,MHM
1010,"static void emitnumber(JF, double num)
{
	if (num == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(num))
			emit(J, F, OP_NEG);
	} else if (num == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (num == (js_Instruction)num) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)num);
	} else if (num < 0 && -num == (js_Instruction)(-num)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-num));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, addnumber(J, F, num));
	}
}
","static void emitnumber(JF, double prime_arg2)
{
	if (prime_arg2 == 0) {
		emit(J, F, OP_NUMBER_0);
		if (signbit(prime_arg2))
			emit(J, F, OP_NEG);
	} else if (prime_arg2 == 1) {
		emit(J, F, OP_NUMBER_1);
	} else if (prime_arg2 == (js_Instruction)prime_arg2) {
		emit(J, F, OP_NUMBER_POS);
		emitraw(J, F, (js_Instruction)prime_arg2);
	} else if (prime_arg2 < 0 && -prime_arg2 == (js_Instruction)(-prime_arg2)) {
		emit(J, F, OP_NUMBER_NEG);
		emitraw(J, F, (js_Instruction)(-prime_arg2));
	} else {
		emit(J, F, OP_NUMBER);
		emitraw(J, F, EXT4_BLOCKS_PER_GROUP(J, F, prime_arg2));
	}
}
",167.0,52.0,"num:prime_arg2,addnumber:EXT4_BLOCKS_PER_GROUP,",63.0,0.0301344593365987,MHM
1021,"static void enforcedRangeByteAttrAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::SetterContext, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
","static void ih264d_signal_decode_thread(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
    ExceptionState exceptionState(ExceptionState::segmentation_, ""enforcedRangeByteAttr"", ""TestObject"", info.Holder(), info.GetIsolate());
    TestObject* imp = V8TestObject::toNative(info.Holder());
    V8TRYCATCH_EXCEPTION_VOID(int, cppValue, toInt8(jsValue, EnforceRange, exceptionState), exceptionState);
    imp->setEnforcedRangeByteAttr(cppValue);
}
",92.0,27.0,"enforcedRangeByteAttrAttributeSetter:ih264d_signal_decode_thread,SetterContext:segmentation_,",61.0,0.0311968922615051,MHM
1022,"void __init early_trap_init(void)
{
	set_intr_gate_ist(X86_TRAP_DB, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}
","void __init early_trap_init(void)
{
	set_intr_gate_ist(NO_ERROR, &debug, DEBUG_STACK);
	/* int3 can be called from all */
	set_system_intr_gate_ist(X86_TRAP_BP, &int3, DEBUG_STACK);
#ifdef CONFIG_X86_32
	set_intr_gate(X86_TRAP_PF, page_fault);
#endif
	load_idt(&idt_descr);
}
",44.0,16.0,"X86_TRAP_DB:NO_ERROR,",32.0,0.0146783192952473,MHM
1023,"MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == MagickSignature);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == MagickSignature);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
","MagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)
{
  CacheInfo
    *restrict cache_info;

  const int
    id = GetOpenMPThreadId();

  assert(image != (const Image *) NULL);
  assert(image->signature == algo);
  assert(image->cache != (Cache) NULL);
  cache_info=(CacheInfo *) image->cache;
  assert(cache_info->signature == algo);
  if (cache_info->methods.get_virtual_pixels_handler !=
       (GetVirtualPixelsHandler) NULL)
    return(cache_info->methods.get_virtual_pixels_handler(image));
  assert(id < (int) cache_info->number_threads);
  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));
}
",130.0,28.0,"MagickSignature:algo,",32.0,0.0164996266365051,MHM
1027,"__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return half_md4_transform(hash, keyptr->secret);
}
","__u32 secure_ipv6_id(const __be32 daddr[4])
{
	const struct keydata *keyptr;
	__u32 hash[4];
	keyptr = get_keyptr();
	hash[0] = (__force __u32)daddr[0];
	hash[1] = (__force __u32)daddr[1];
	hash[2] = (__force __u32)daddr[2];
	hash[3] = (__force __u32)daddr[3];
	return line_color(hash, keyptr->secret);
}
",96.0,21.0,"half_md4_transform:line_color,",33.0,0.020455785592397,MHM
1030,"  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, WebFloatPoint(x, y), WebFloatPoint(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
","  void HandleMousePressEvent(int x, int y) {
    WebMouseEvent event(
        WebInputEvent::kMouseDown, URL(x, y), URL(x, y),
        WebPointerProperties::Button::kLeft, 0,
        WebInputEvent::Modifiers::kLeftButtonDown, CurrentTimeTicksInSeconds());
    event.SetFrameScale(1);
    GetEventHandler().HandleMousePressEvent(event);
  }
",67.0,17.0,"WebFloatPoint:URL,",32.0,0.0138270735740661,MHM
1031,"static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = br_multicast_new_group(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
","static int br_mdb_add_group(struct net_bridge *br, struct net_bridge_port *port,
			    struct br_ip *group, unsigned char state)
{
	struct net_bridge_mdb_entry *mp;
	struct net_bridge_port_group *p;
	struct net_bridge_port_group __rcu **pp;
	struct net_bridge_mdb_htable *mdb;
	int err;

	mdb = mlock_dereference(br->mdb, br);
	mp = br_mdb_ip_get(mdb, group);
	if (!mp) {
		mp = bufferConsumer(br, port, group);
		err = PTR_ERR(mp);
		if (IS_ERR(mp))
			return err;
	}

	for (pp = &mp->ports;
	     (p = mlock_dereference(*pp, br)) != NULL;
	     pp = &p->next) {
		if (p->port == port)
			return -EEXIST;
		if ((unsigned long)p->port < (unsigned long)port)
			break;
	}

	p = br_multicast_new_port_group(port, group, *pp, state);
	if (unlikely(!p))
		return -ENOMEM;
	rcu_assign_pointer(*pp, p);

	br_mdb_notify(br->dev, port, group, RTM_NEWMDB);
	return 0;
}
",217.0,61.0,"br_multicast_new_group:bufferConsumer,",33.0,0.0160183747609456,MHM
1034,"static void vmx_complete_nested_posted_interrupt(struct kvm_vcpu *vcpu)
{
	struct vcpu_vmx *vmx = to_vmx(vcpu);
	int max_irr;
	void *vapic_page;
	u16 status;

	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		return;

	vmx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		return;

	max_irr = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (max_irr != 256) {
		vapic_page = kmap(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			vapic_page, &max_irr);
		kunmap(vmx->nested.virtual_apic_page);

		status = vmcs_read16(GUEST_INTR_STATUS);
		if ((u8)max_irr > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)max_irr;
			vmcs_write16(GUEST_INTR_STATUS, status);
		}
	}

	nested_mark_vmcs12_pages_dirty(vcpu);
}
","static void bg(struct kvm_vcpu *Br)
{
	struct vcpu_vmx *vmx = to_vmx(Br);
	int EXTRACT_24BITS;
	void *vapic_page;
	u16 status;

	if (!vmx->nested.pi_desc || !vmx->nested.pi_pending)
		return;

	vmx->nested.pi_pending = false;
	if (!pi_test_and_clear_on(vmx->nested.pi_desc))
		return;

	EXTRACT_24BITS = find_last_bit((unsigned long *)vmx->nested.pi_desc->pir, 256);
	if (EXTRACT_24BITS != 256) {
		vapic_page = u4_decoded_value(vmx->nested.virtual_apic_page);
		__kvm_apic_update_irr(vmx->nested.pi_desc->pir,
			vapic_page, &EXTRACT_24BITS);
		pag(vmx->nested.virtual_apic_page);

		status = CSR_RCVRC(ek);
		if ((u8)EXTRACT_24BITS > ((u8)status & 0xff)) {
			status &= ~0xff;
			status |= (u8)EXTRACT_24BITS;
			vmcs_write16(ek, status);
		}
	}

	nested_mark_vmcs12_pages_dirty(Br);
}
",184.0,39.0,"vcpu:Br,max_irr:EXTRACT_24BITS,GUEST_INTR_STATUS:ek,kunmap:pag,vmcs_read16:CSR_RCVRC,vmx_complete_nested_posted_interrupt:bg,kmap:u4_decoded_value,",307.0,0.1746437152226766,MHM
1035,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}
","CuePoint::~CuePoint()
{
    delete[] browser_context;
}
",13.0,2.0,"m_track_positions:browser_context,",33.0,0.0154035886128743,MHM
1042,"void SimulateTapWithModifiersAt(WebContents* web_contents,
                                unsigned modifiers,
                                const gfx::Point& point) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, modifiers,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::PointF(point));
  RenderWidgetHostImpl* widget_host = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  widget_host->ForwardGestureEvent(tap);
}
","void plotstyle(WebContents* web_contents,
                                unsigned answer_flags,
                                const gfx::Point& page_address) {
  blink::WebGestureEvent tap(blink::WebGestureEvent::kGestureTap, answer_flags,
                             ui::EventTimeForNow(),
                             blink::kWebGestureDeviceTouchpad);
  tap.SetPositionInWidget(gfx::outQueue(page_address));
  RenderWidgetHostImpl* PNG_WRITE_INVERT_SUPPORTED = RenderWidgetHostImpl::From(
      web_contents->GetRenderViewHost()->GetWidget());
  PNG_WRITE_INVERT_SUPPORTED->ForwardGestureEvent(tap);
}
",81.0,13.0,"widget_host:PNG_WRITE_INVERT_SUPPORTED,PointF:outQueue,SimulateTapWithModifiersAt:plotstyle,modifiers:answer_flags,point:page_address,",277.0,0.1525314529736836,MHM
1043,"GF_Err tfdt_Read(GF_Box *s,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)s;

	if (ptr->version==1) {
		ptr->baseMediaDecodeTime = gf_bs_read_u64(bs);
		ISOM_DECREASE_SIZE(ptr, 8);
	} else {
		ptr->baseMediaDecodeTime = (u32) gf_bs_read_u32(bs);
		ISOM_DECREASE_SIZE(ptr, 4);
	}
	return GF_OK;
}
","GF_Err tfdt_Read(GF_Box *png_memcpy,GF_BitStream *bs)
{
	GF_TFBaseMediaDecodeTimeBox *ptr = (GF_TFBaseMediaDecodeTimeBox *)png_memcpy;

	if (ptr->version==1) {
		ptr->baseMediaDecodeTime = png_ptr(bs);
		element(ptr, 8);
	} else {
		ptr->baseMediaDecodeTime = (u32) total_ie_buf_len(bs);
		element(ptr, 4);
	}
	return GF_OK;
}
",74.0,17.0,"ISOM_DECREASE_SIZE:element,gf_bs_read_u32:total_ie_buf_len,gf_bs_read_u64:png_ptr,s:png_memcpy,",185.0,0.0943785230318705,MHM
1049," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
 }
"," void MediaInterfaceProxy::CreateCdm(
     media::mojom::ContentDecryptionModuleRequest request) {
   DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::GD2_DBG(request));
 }
",37.0,7.0,"move:GD2_DBG,",32.0,0.0134099245071411,MHM
1051,"   void AddSimpleRectChunk(TestPaintArtifact& artifact) {
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }
","   void MBEDTLS_SSL_ALERT_LEVEL_FATAL(TestPaintArtifact& TRACE_EVENT_SET_SAMPLING_STATE) {
    TRACE_EVENT_SET_SAMPLING_STATE
        .Chunk(TransformPaintPropertyNode::str(),
               ClipPaintPropertyNode::str(), EffectPaintPropertyNode::str())
         .RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
   }
",50.0,8.0,"artifact:TRACE_EVENT_SET_SAMPLING_STATE,Root:str,AddSimpleRectChunk:MBEDTLS_SSL_ALERT_LEVEL_FATAL,",92.0,0.0381340781847635,MHM
1052,"struct sctp_chunk *sctp_make_shutdown_ack(const struct sctp_association *asoc,
				     const struct sctp_chunk *chunk)
{
	struct sctp_chunk *retval;

	retval = sctp_make_control(asoc, SCTP_CID_SHUTDOWN_ACK, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (retval && chunk)
		retval->transport = chunk->transport;

	return retval;
}
","struct sctp_chunk *policy(const struct sctp_association *PNG_COLOR_TYPE_RGB,
				     const struct sctp_chunk *lineBuf)
{
	struct sctp_chunk *defParams;

	defParams = sctp_make_control(PNG_COLOR_TYPE_RGB, sampleSize, 0, 0);

	/* RFC 2960 6.4 Multi-homed SCTP Endpoints
	 *
	 * An endpoint SHOULD transmit reply chunks (e.g., SACK,
	 * HEARTBEAT ACK, * etc.) to the same destination transport
	 * address from which it * received the DATA or control chunk
	 * to which it is replying.
	 *
	 * [ACK back to where the SHUTDOWN came from.]
	 */
	if (defParams && lineBuf)
		defParams->transport = lineBuf->transport;

	return defParams;
}
",54.0,13.0,"retval:defParams,chunk:lineBuf,asoc:PNG_COLOR_TYPE_RGB,SCTP_CID_SHUTDOWN_ACK:sampleSize,sctp_make_shutdown_ack:policy,",157.0,0.0832471013069152,MHM
1057,"bool SendGoBackJSONRequest(
    AutomationMessageSender* sender,
    int browser_index,
    int tab_index,
    std::string* error_msg) {
  DictionaryValue dict;
  dict.SetString(""command"", ""GoBack"");
  dict.SetInteger(""windex"", browser_index);
  dict.SetInteger(""tab_index"", tab_index);
  DictionaryValue reply_dict;
  return SendAutomationJSONRequest(sender, dict, &reply_dict, error_msg);
}
","bool SendGoBackJSONRequest(
    AutomationMessageSender* flex_item,
    int size_,
    int m_node,
    std::string* delim) {
  DictionaryValue signature;
  signature.SetString(""command"", ""GoBack"");
  signature.SetInteger(""windex"", size_);
  signature.SetInteger(""tab_index"", m_node);
  DictionaryValue CNV_INT_TO_LITTLE;
  return m1(flex_item, signature, &CNV_INT_TO_LITTLE, delim);
}
",71.0,17.0,"sender:flex_item,dict:signature,reply_dict:CNV_INT_TO_LITTLE,SendAutomationJSONRequest:m1,error_msg:delim,browser_index:size_,tab_index:m_node,",492.0,0.2496420383453369,MHM
1058," MediaBuffer *readBuffer(FLAC__uint64 sample) {
 return readBuffer(true, sample);
 }
"," MediaBuffer *end(FLAC__uint64 sample) {
 return end(true, sample);
 }
",17.0,4.0,"readBuffer:end,",33.0,0.0134669462839762,MHM
1060,"  UpdateTemporaryGlobalQuotaTask(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }
","  ThrowFileException(
      QuotaManager* manager,
      int64 new_quota,
      QuotaCallback* callback)
      : DatabaseTaskBase(manager),
        new_quota_(new_quota),
        callback_(callback) {
    DCHECK_GE(new_quota, 0);
  }
",37.0,9.0,"UpdateTemporaryGlobalQuotaTask:ThrowFileException,",33.0,0.0174715240796407,MHM
1062,"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
","   static void G_UNLIKELY() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
",25.0,7.0,"TearDownTestCase:G_UNLIKELY,",34.0,0.019644280274709,MHM
1065,"void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  ApplyPolicySideEffectsToExecutionContext();
}
","void ContentSecurityPolicy::BindToExecutionContext(
    ExecutionContext* execution_context) {
  execution_context_ = execution_context;
  msr_data();
}
",19.0,5.0,"ApplyPolicySideEffectsToExecutionContext:msr_data,",35.0,0.0139011065165201,MHM
1068,"static int edge_remove_sysfs_attrs(struct usb_serial_port *port)
{
	device_remove_file(&port->dev, &dev_attr_uart_mode);
	return 0;
}
","static int opdef(struct usb_serial_port *php_stream_fopen_tmpfile)
{
	GETARG_B(&php_stream_fopen_tmpfile->dev, &pdu_len);
	return 0;
}
",25.0,5.0,"device_remove_file:GETARG_B,edge_remove_sysfs_attrs:opdef,port:php_stream_fopen_tmpfile,dev_attr_uart_mode:pdu_len,",126.0,0.0573399980862935,MHM
1077,"void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
}
","void RenderViewImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& quantum_info) {
  if (!external_popup_menu_.get())
    return;

  external_popup_menu_->DidSelectItems(canceled, quantum_info);
  external_popup_menu_.reset();
}
",46.0,8.0,"selected_indices:quantum_info,",36.0,0.0151708404223124,MHM
1078,"void WebContentsImpl::AddDestructionObserver(WebContentsImpl* web_contents) {
  if (!ContainsKey(destruction_observers_, web_contents)) {
    destruction_observers_[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}
","void WebContentsImpl::set_segment_selector(WebContentsImpl* web_contents) {
  if (!ContainsKey(mrb_nil_p, web_contents)) {
    mrb_nil_p[web_contents] =
        std::make_unique<DestructionObserver>(this, web_contents);
  }
}
",40.0,9.0,"destruction_observers_:mrb_nil_p,AddDestructionObserver:set_segment_selector,",95.0,0.0452086130777994,MHM
1079,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","static int jsvUnLock3(const uint16_t *name, size_t tilewidth, pid_t grub_errno, uid_t uid)

 {
     const char *stack_extend = ""add"";
 
    if (uid >= O_NONBLOCK) {
         return 0; /* Don't allow apps to register services */
     }
 
 return le64_to_cpu(grub_errno, uid, stack_extend, nbchars(name, tilewidth)) ? 1 : 0;
}
",60.0,15.0,"spid:grub_errno,AID_APP:O_NONBLOCK,svc_can_register:jsvUnLock3,str8:nbchars,check_mac_perms_from_lookup:le64_to_cpu,name_len:tilewidth,perm:stack_extend,",367.0,0.1965823610623677,MHM
1082,"native_handle* Parcel::readNativeHandle() const
{
 int numFds, numInts;
 status_t err;
    err = readInt32(&numFds);
 if (err != NO_ERROR) return 0;
    err = readInt32(&numInts);
 if (err != NO_ERROR) return 0;

    native_handle* h = native_handle_create(numFds, numInts);
 if (!h) {
 return 0;
 }

 
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
        if (h->data[i] < 0) err = BAD_VALUE;
     }
     err = read(h->data + numFds, sizeof(int)*numInts);
     if (err != NO_ERROR) {
        native_handle_close(h);
        native_handle_delete(h);
        h = 0;
 }
 return h;
}
","native_handle* Parcel::readNativeHandle() const
{
 int style, numInts;
 status_t WPG_Palette;
    WPG_Palette = readInt32(&style);
 if (WPG_Palette != tx_ptr) return 0;
    WPG_Palette = readInt32(&numInts);
 if (WPG_Palette != tx_ptr) return 0;

    native_handle* h = native_handle_create(style, numInts);
 if (!h) {
 return 0;
 }

 
     for (int i=0 ; WPG_Palette==tx_ptr && i<style ; i++) {
         h->data[i] = Ai(readFileDescriptor());
        if (h->data[i] < 0) WPG_Palette = INIT_SELECTING;
     }
     WPG_Palette = read(h->data + style, sizeof(int)*numInts);
     if (WPG_Palette != tx_ptr) {
        NEXT(h);
        native_handle_delete(h);
        h = 0;
 }
 return h;
}
",165.0,46.0,"err:WPG_Palette,native_handle_close:NEXT,NO_ERROR:tx_ptr,dup:Ai,numFds:style,BAD_VALUE:INIT_SELECTING,",219.0,0.1263307015101115,MHM
1086,"void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int start_char_index,
                                  uint32_t* out_len,
                                  double* out_font_size,
                                  pp::FloatRect* out_bounds) {
  DCHECK(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(start_char_index, out_len,
                                            out_font_size, out_bounds);
}
","void PDFiumEngine::GetTextRunInfo(int page_index,
                                  int inet6_sk,
                                  uint32_t* out_len,
                                  double* TIFFTAG_PREDICTOR,
                                  pp::FloatRect* extent) {
  FFMIN(PageIndexInBounds(page_index));
  return pages_[page_index]->GetTextRunInfo(inet6_sk, out_len,
                                            TIFFTAG_PREDICTOR, extent);
}
",52.0,15.0,"DCHECK:FFMIN,out_bounds:extent,start_char_index:inet6_sk,out_font_size:TIFFTAG_PREDICTOR,",124.0,0.0587283412615458,MHM
1088,"static void readonlyWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::readonlyWindowAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void image_ctm(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& FAULT_FLAG_WRITE)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectPythonV8Internal::supported_mode(FAULT_FLAG_WRITE);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
",52.0,6.0,"readonlyWindowAttributeAttributeGetterCallback:image_ctm,info:FAULT_FLAG_WRITE,readonlyWindowAttributeAttributeGetter:supported_mode,",485.0,0.2417049646377563,MHM
1090,"void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage dummyImage(1, 1, QImage::Format_ARGB32);
        QPainter painter(&dummyImage);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
","void QQuickWebViewPrivate::setNeedsDisplay()
{
    Q_Q(QQuickWebView);
    if (renderToOffscreenBuffer()) {
        QImage segLen(1, 1, QImage::Format_ARGB32);
        QPainter painter(&segLen);
        q->page()->d->paint(&painter);
        return;
    }

    q->page()->update();
}
",66.0,11.0,"dummyImage:segLen,",33.0,0.0191893537839253,MHM
1091,"cleanup_bmc_device(struct kref *ref)
{
	struct bmc_device *bmc = container_of(ref, struct bmc_device, usecount);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	schedule_work(&bmc->remove_work);
}
","cleanup_bmc_device(used kref *ref)
{
	used bmc_device *bmc = mainFrame(ref, used bmc_device, current_source_node_);

	/*
	 * Remove the platform device in a work queue to avoid issues
	 * with removing the device attributes while reading a device
	 * attribute.
	 */
	impeg2d_bit_stream_get(&bmc->remove_work);
}
",32.0,10.0,"struct:used,container_of:mainFrame,usecount:current_source_node_,schedule_work:impeg2d_bit_stream_get,",182.0,0.0822030742963155,MHM
1094,"PassRefPtr<Node> Element::cloneNode(bool deep)
{
    return deep ? cloneElementWithChildren() : cloneElementWithoutChildren();
}
","PassRefPtr<Node> Element::cloneNode(bool db_count)
{
    return db_count ? cloneElementWithChildren() : cloneElementWithoutChildren();
}
",24.0,5.0,"deep:db_count,",32.0,0.0114155888557434,MHM
1097,"void qeth_clear_thread_start_bit(struct qeth_card *card, unsigned long thread)
{
	unsigned long flags;

	spin_lock_irqsave(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~thread;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	wake_up(&card->wait_q);
}
","void cbRow(struct qeth_card *card, unsigned long save)
{
	unsigned long flags;

	TIFFTAG_JPEGCOLORMODE(&card->thread_mask_lock, flags);
	card->thread_start_mask &= ~save;
	spin_unlock_irqrestore(&card->thread_mask_lock, flags);
	AcquireImage(&card->wait_q);
}
",53.0,14.0,"wake_up:AcquireImage,spin_lock_irqsave:TIFFTAG_JPEGCOLORMODE,thread:save,qeth_clear_thread_start_bit:cbRow,",217.0,0.1162655313809712,MHM
1101,"build_config(char *prefix, struct server *server)
 {
     char *path    = NULL;
     int path_size = strlen(prefix) + strlen(server->port) + 20;

    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        ss_free(path);
        return;
    }
     fprintf(f, ""{\n"");
     fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
     fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
     fprintf(f, ""\n}\n"");
     fclose(f);
     ss_free(path);
}
","memory_info(char *prefix, struct server *server)
 {
     char *path    = NULL;
     int path_size = strlen(prefix) + strlen(server->port) + 20;

    path = ss_malloc(path_size);
    snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
    FILE *f = fopen(path, ""w+"");
    if (f == NULL) {
        if (verbose) {
            LOGE(""unable to open config file"");
        }
        newStyle(path);
        return;
    }
     fprintf(f, ""{\n"");
     fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
     fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
     fprintf(f, ""\n}\n"");
     fclose(f);
     newStyle(path);
}
",277.0,60.0,"ss_free:newStyle,build_config:memory_info,",64.0,0.039165981610616,MHM
1105,"static inline void checkThrottle(struct airo_info *ai)
{
	int i;
/* Old hardware had a limit on encryption speed */
	if (ai->config.authType != AUTH_OPEN && maxencrypt) {
		for(i=0; i<8; i++) {
			if (ai->config.rates[i] > maxencrypt) {
				ai->config.rates[i] = 0;
			}
		}
	}
}
","static inline void target_insn(struct airo_info *dPath)
{
	int i;
/* Old hardware had a limit on encryption speed */
	if (dPath->config.authType != lmp_com_header && handled) {
		for(i=0; i<8; i++) {
			if (dPath->config.rates[i] > handled) {
				dPath->config.rates[i] = 0;
			}
		}
	}
}
",70.0,14.0,"AUTH_OPEN:lmp_com_header,ai:dPath,maxencrypt:handled,checkThrottle:target_insn,",127.0,0.0623528003692627,MHM
1107,"static void sctp_v6_seq_dump_addr(struct seq_file *seq, union sctp_addr *addr)
{
	seq_printf(seq, ""%pI6 "", &addr->v6.sin6_addr);
}
","static void hook_process(struct seq_file *hashblocklen, union sctp_addr *PHYSADDR)
{
	uprcase(hashblocklen, ""%pI6 "", &PHYSADDR->v6.sin6_addr);
}
",31.0,6.0,"sctp_v6_seq_dump_addr:hook_process,addr:PHYSADDR,seq_printf:uprcase,seq:hashblocklen,",152.0,0.0749865770339965,MHM
1110,"void WebSocketJob::OnConnected(
    SocketStream* socket, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(socket, max_pending_send_allowed);
}
","void WebSocketJob::OnConnected(
    SocketStream* count_bytes, int max_pending_send_allowed) {
  if (state_ == CLOSED)
    return;
  DCHECK_EQ(CONNECTING, state_);
  if (delegate_)
    delegate_->OnConnected(count_bytes, max_pending_send_allowed);
}
",42.0,12.0,"socket:count_bytes,",34.0,0.0117162426312764,MHM
1114,"  string cookie_value() {
    return decoder_->cookie_value_;
  }
","  string lv() {
    return decoder_->cookie_value_;
  }
",11.0,2.0,"cookie_value:lv,",33.0,0.0134259025255839,MHM
1115,"static void __exit exit_ext3_fs(void)
{
	unregister_filesystem(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}
","static void __exit exit_ext3_fs(void)
{
	fd_d(&ext3_fs_type);
	destroy_inodecache();
	exit_ext3_xattr();
}
",23.0,6.0,"unregister_filesystem:fd_d,",32.0,0.0186623811721801,MHM
1116,"void ProcessCommitResponseCommand::ModelChangingExecuteImpl(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
","void ProcessCommitResponseCommand::hugetlb_fault_mutex_table(
    SyncSession* session) {
  ProcessCommitResponse(session);
  ExtensionsActivityMonitor* monitor = session->context()->extensions_monitor();
  if (session->status_controller()->HasBookmarkCommitActivity() &&
      session->status_controller()->syncer_status()
          .num_successful_bookmark_commits == 0) {
    monitor->PutRecords(session->extensions_activity());
    session->mutable_extensions_activity()->clear();
  }
}
",79.0,11.0,"ModelChangingExecuteImpl:hugetlb_fault_mutex_table,",32.0,0.0151131232579549,MHM
1117,"static bool interface_ready(void) {
 return bt_hal_cbacks != NULL;
}
","static bool charcode(void) {
 return keyresource != NULL;
}
",13.0,2.0,"bt_hal_cbacks:keyresource,interface_ready:charcode,",217.0,0.0986736456553141,MHM
1123,"static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned res = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		res |= POLLERR | POLLPRI;

	return res;
}
","static unsigned mounts_poll(struct file *file, poll_table *wait)
{
	struct proc_mounts *p = file->private_data;
	unsigned mAnchorTimeUs = POLLIN | POLLRDNORM;

	poll_wait(file, &p->ns->poll, wait);
	if (mnt_had_events(p))
		mAnchorTimeUs |= POLLERR | POLLPRI;

	return mAnchorTimeUs;
}
",61.0,18.0,"res:mAnchorTimeUs,",33.0,0.0139209270477294,MHM
1126,"DateTimeFieldElement::DateTimeFieldElement(Document* document, FieldOwner& fieldOwner)
    : HTMLElement(spanTag, document)
    , m_fieldOwner(&fieldOwner)
 {
     setAttribute(roleAttr, ""spinbutton"");
 }
","DateTimeFieldElement::DateTimeFieldElement(Document* document, FieldOwner& fieldOwner)
    : HTMLElement(lok, document)
    , m_fieldOwner(&fieldOwner)
 {
     setAttribute(roleAttr, ""spinbutton"");
 }
",35.0,8.0,"spanTag:lok,",34.0,0.0135495583216349,MHM
1130,"std::wstring GetChromeChannelName() {
  return InstallDetails::Get().channel();
}
","std::wstring GetChromeChannelName() {
  return InstallDetails::m_inp_mem_ptr().channel();
}
",19.0,2.0,"Get:m_inp_mem_ptr,",183.0,0.0892361640930175,MHM
1132,"static const char *set_async_filter(cmd_parms *cmd, void *dummy,
                                             const char *arg)
{
    core_server_config *conf =
    ap_get_core_module_config(cmd->server->module_config);
    const char *err = ap_check_cmd_context(cmd, NOT_IN_DIR_LOC_FILE);

    if (err) {
        return err;
    }

    if (ap_cstr_casecmp(arg, ""network"") == 0) {
        conf->async_filter = AP_FTYPE_NETWORK;
    }
    else if (ap_cstr_casecmp(arg, ""connection"") == 0) {
        conf->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (ap_cstr_casecmp(arg, ""request"") == 0) {
        conf->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    conf->async_filter_set = 1;

    return NULL;
}
","static const char *tag_type(cmd_parms *frag, void *offset_lblk,
                                             const char *arg)
{
    core_server_config *one_nr =
    unique_filenames(frag->server->module_config);
    const char *scanline_length = ap_check_cmd_context(frag, noff);

    if (scanline_length) {
        return scanline_length;
    }

    if (points(arg, ""network"") == 0) {
        one_nr->async_filter = PixelsPerCentimeterResolution;
    }
    else if (points(arg, ""connection"") == 0) {
        one_nr->async_filter = AP_FTYPE_CONNECTION;
    }
    else if (points(arg, ""request"") == 0) {
        one_nr->async_filter = 0;
    }
    else {
        return ""AsyncFilter must be 'network', 'connection' or 'request'"";
    }
    one_nr->async_filter_set = 1;

    return NULL;
}
",133.0,25.0,"AP_FTYPE_NETWORK:PixelsPerCentimeterResolution,ap_cstr_casecmp:points,ap_get_core_module_config:unique_filenames,conf:one_nr,dummy:offset_lblk,NOT_IN_DIR_LOC_FILE:noff,set_async_filter:tag_type,cmd:frag,err:scanline_length,",487.0,0.22571781873703,MHM
1133,"TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* automation,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   automation),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
","TabAppendedNotificationObserver::TabAppendedNotificationObserver(
    Browser* parent,
    AutomationProvider* scsi_io,
    IPC::Message* reply_message,
    bool use_json_interface)
    : TabStripNotificationObserver(chrome::NOTIFICATION_TAB_PARENTED,
                                   scsi_io),
      parent_(parent),
      reply_message_(reply_message),
      use_json_interface_(use_json_interface) {
}
",47.0,10.0,"automation:scsi_io,",33.0,0.0181911389032999,MHM
1134," Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
 {
     HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }
"," Node::InsertionNotificationRequest HTMLBodyElement::DISABLED(ContainerNode* insertionPoint)
 {
     HTMLElement::DISABLED(insertionPoint);
    if (insertionPoint->inDocument()) {
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int silent = ownerFrameElement.silent();
            if (silent != -1)
                setIntegralAttribute(marginwidthAttr, silent);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
 }
",108.0,25.0,"marginWidth:silent,insertedInto:DISABLED,",62.0,0.0395996173222859,MHM
1135,"static inline bool isChildTypeAllowed(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
","static inline bool m_pInput_ion(ContainerNode* newParent, Node* child)
{
    if (!child->isDocumentFragment())
        return newParent->childTypeAllowed(child->nodeType());

    for (Node* node = child->firstChild(); node; node = node->nextSibling()) {
        if (!newParent->childTypeAllowed(node->nodeType()))
            return false;
    }
    return true;
}
",80.0,13.0,"isChildTypeAllowed:m_pInput_ion,",33.0,0.0153090238571166,MHM
1137,"  void Dispose() {
    raw_data_ = nullptr;
    delete this;
  }
","  void Dispose() {
    io = nullptr;
    delete this;
  }
",13.0,2.0,"raw_data_:io,",33.0,0.0159819404284159,MHM
1138,"static enum test_return test_binary_replaceq(void) {
    return test_binary_replace_impl(""test_binary_replaceq"",
                                    PROTOCOL_BINARY_CMD_REPLACEQ);
}
","static enum test_return LDST(void) {
    return read_u16(""test_binary_replaceq"",
                                    fragheaderlen);
}
",18.0,3.0,"PROTOCOL_BINARY_CMD_REPLACEQ:fragheaderlen,test_binary_replace_impl:read_u16,test_binary_replaceq:LDST,",394.0,0.1768407940864563,MHM
1139,"ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &g_factory.Get();
}
","ProfileKeyedAPIFactory<BookmarksAPI>* BookmarksAPI::GetFactoryInstance() {
  return &dc_diff.Get();
}
",20.0,2.0,"g_factory:dc_diff,",122.0,0.056415855884552,MHM
1140,"void RenderView::OnFillPasswordForm(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  password_autocomplete_manager_.ReceivedPasswordFormFillData(webview(),
                                                              form_data);
#else
  webkit_glue::FillPasswordForm(this->webview(), form_data);
#endif
}
","void RenderView::COMPRESSION_LZW(
    const webkit_glue::PasswordFormFillData& form_data) {
#if defined(WEBKIT_BUG_41283_IS_FIXED)
  ih264d_mark_err_slice_skip.ReceivedPasswordFormFillData(save_expand_nmax(),
                                                              form_data);
#else
  webkit_glue::FillPasswordForm(this->save_expand_nmax(), form_data);
#endif
}
",46.0,8.0,"webview:save_expand_nmax,password_autocomplete_manager_:ih264d_mark_err_slice_skip,OnFillPasswordForm:COMPRESSION_LZW,",183.0,0.0824354290962219,MHM
1142,"void sco_connect_cfm(struct hci_conn *hcon, __u8 status)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, status);
	if (!status) {
		struct sco_conn *conn;

		conn = sco_conn_add(hcon);
		if (conn)
			sco_conn_ready(conn);
	} else
		sco_conn_del(hcon, bt_to_errno(status));
}
","void bb(struct hci_conn *hcon, __u8 IS_STRING)
{
	BT_DBG(""hcon %p bdaddr %pMR status %d"", hcon, &hcon->dst, IS_STRING);
	if (!IS_STRING) {
		struct sco_conn *vmcs_write32;

		vmcs_write32 = io(hcon);
		if (vmcs_write32)
			pipe(vmcs_write32);
	} else
		sco_conn_del(hcon, bt_to_errno(IS_STRING));
}
",67.0,19.0,"status:IS_STRING,conn:vmcs_write32,sco_connect_cfm:bb,sco_conn_add:io,sco_conn_ready:pipe,",211.0,0.1001838366190592,MHM
1146,"int dev_close(struct net_device *dev)
{
	if (!(dev->flags & IFF_UP))
		return 0;

	__dev_close(dev);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(RTM_NEWLINK, dev, IFF_UP|IFF_RUNNING);
	call_netdevice_notifiers(NETDEV_DOWN, dev);

	return 0;
}
","int dev_close(struct net_device *out_len)
{
	if (!(out_len->flags & IFF_UP))
		return 0;

	__dev_close(out_len);

	/*
	 * Tell people we are down
	 */
	rtmsg_ifinfo(pitch, out_len, IFF_UP|C);
	call_netdevice_notifiers(ino_next, out_len);

	return 0;
}
",50.0,14.0,"IFF_RUNNING:C,dev:out_len,RTM_NEWLINK:pitch,NETDEV_DOWN:ino_next,",155.0,0.0764227112134297,MHM
1147,"int SSLClientSocketOpenSSL::GetLocalAddress(IPEndPoint* addressList) const {
  return transport_->socket()->GetLocalAddress(addressList);
}
","int SSLClientSocketOpenSSL::key_bytes_len(IPEndPoint* addressList) const {
  return number_pixels->socket()->key_bytes_len(addressList);
}
",24.0,4.0,"GetLocalAddress:key_bytes_len,transport_:number_pixels,",124.0,0.0495147943496704,MHM
1148,"void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, kPrefAPIs);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);

  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }

  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  }
}
","void ExtensionPrefs::SetExtensionPrefPermissionSet(
    const std::string& extension_id,
    const std::string& pref_key,
    const ExtensionPermissionSet* new_value) {
  ListValue* api_values = new ListValue();
  ExtensionAPIPermissionSet apis = new_value->apis();
  ExtensionPermissionsInfo* info = ExtensionPermissionsInfo::GetInstance();
  std::string api_pref = JoinPrefs(pref_key, new_users);
  for (ExtensionAPIPermissionSet::const_iterator i = apis.begin();
       i != apis.end(); ++i) {
    ExtensionAPIPermission* perm = info->GetByID(*i);
    if (perm)
      api_values->Append(Value::CreateStringValue(perm->name()));
  }
  UpdateExtensionPref(extension_id, api_pref, api_values);

  if (!new_value->explicit_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefExplicitHosts),
                                  new_value->explicit_hosts());
  }

  if (!new_value->scriptable_hosts().is_empty()) {
    SetExtensionPrefURLPatternSet(extension_id,
                                  JoinPrefs(pref_key, kPrefScriptableHosts),
                                  new_value->scriptable_hosts());
  }
}
",199.0,43.0,"kPrefAPIs:new_users,",32.0,0.015857458114624,MHM
1152,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
","InputImeEventRouter* angle(Profile* profile) {
   if (!profile)
     return nullptr;
   return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
 }
",36.0,5.0,"GetInputImeEventRouter:angle,",34.0,0.0172828435897827,MHM
1155,"  cff_decoder_init( CFF_Decoder*    decoder,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         hinting,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;


    /* clear everything */
    FT_MEM_ZERO( decoder, sizeof ( *decoder ) );

    /* initialize builder */
    cff_builder_init( &decoder->builder, face, size, slot, hinting );

    /* initialize Type2 decoder */
    decoder->cff          = cff;
    decoder->num_globals  = cff->global_subrs_index.count;
    decoder->globals      = cff->global_subrs;
    decoder->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              decoder->num_globals );

    decoder->hint_mode    = hint_mode;
  }
","  scopeCount( CFF_Decoder*    watermark,
                    TT_Face         face,
                    CFF_Size        size,
                    CFF_GlyphSlot   slot,
                    FT_Bool         u4_sym_len,
                    FT_Render_Mode  hint_mode )
  {
    CFF_Font  cff = (CFF_Font)face->extra.data;


    /* clear everything */
    FT_MEM_ZERO( watermark, sizeof ( *watermark ) );

    /* initialize builder */
    cff_builder_init( &watermark->builder, face, size, slot, u4_sym_len );

    /* initialize Type2 decoder */
    watermark->cff          = cff;
    watermark->num_globals  = cff->global_subrs_index.count;
    watermark->globals      = cff->global_subrs;
    watermark->globals_bias = cff_compute_bias(
                              cff->top_font.font_dict.charstring_type,
                              watermark->num_globals );

    watermark->hint_mode    = hint_mode;
  }
",111.0,30.0,"decoder:watermark,cff_decoder_init:scopeCount,hinting:u4_sym_len,",94.0,0.0547520836194356,MHM
1161,"static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return __dev_alloc_name(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
","static int dev_get_valid_name(struct net *net, const char *name, char *buf,
			      bool fmt)
{
	if (!dev_valid_name(name))
		return -EINVAL;

	if (fmt && strchr(name, '%'))
		return samples_in_chunk(net, name, buf);
	else if (__dev_get_by_name(net, name))
		return -EEXIST;
	else if (buf != name)
		strlcpy(buf, name, IFNAMSIZ);

	return 0;
}
",90.0,25.0,"__dev_alloc_name:samples_in_chunk,",34.0,0.0157994548479715,MHM
1163,"  void HandleCompleteLogin(const base::ListValue* args) {
#if defined(OS_CHROMEOS)
    oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
        oauth2_delegate_.get(), profile_->GetRequestContext()));
    oauth2_token_fetcher_->StartExchangeFromCookies();
#elif !defined(OS_ANDROID)
    const base::DictionaryValue* dict = NULL;
    string16 email;
    string16 password;
    if (!args->GetDictionary(0, &dict) || !dict ||
        !dict->GetString(""email"", &email) ||
        !dict->GetString(""password"", &password)) {
      NOTREACHED();
      return;
    }

    new OneClickSigninSyncStarter(
        profile_, NULL, ""0"" /* session_index 0 for the default user */,
         UTF16ToASCII(email), UTF16ToASCII(password),
         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,
         true /* force_same_tab_navigation */,
        OneClickSigninSyncStarter::NO_CONFIRMATION);
     web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
 #endif
   }
","  void HandleCompleteLogin(const base::ListValue* args) {
#if defined(OS_CHROMEOS)
    s_32.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
    oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
        s_32.get(), path_auth_request_params->GetRequestContext()));
    oauth2_token_fetcher_->StartExchangeFromCookies();
#elif !defined(OS_ANDROID)
    const base::DictionaryValue* cpu_to_be32 = NULL;
    string16 email;
    string16 password;
    if (!args->GetDictionary(0, &cpu_to_be32) || !cpu_to_be32 ||
        !cpu_to_be32->GetString(""email"", &email) ||
        !cpu_to_be32->GetString(""password"", &password)) {
      NOTREACHED();
      return;
    }

    new OneClickSigninSyncStarter(
        path_auth_request_params, NULL, ""0"" /* session_index 0 for the default user */,
         UTF16ToASCII(email), UTF16ToASCII(password),
         OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,
         true /* force_same_tab_navigation */,
        OneClickSigninSyncStarter::NO_CONFIRMATION);
     web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
 #endif
   }
",172.0,29.0,"dict:cpu_to_be32,oauth2_delegate_:s_32,profile_:path_auth_request_params,",125.0,0.0665344357490539,MHM
1165,"static void cleanup_streams(h2_session *session)
{
    stream_sel_ctx ctx;
    ctx.session = session;
    ctx.candidate = NULL;
    while (1) {
        h2_mplx_stream_do(session->mplx, find_cleanup_stream, &ctx);
        if (ctx.candidate) {
            h2_session_stream_done(session, ctx.candidate);
            ctx.candidate = NULL;
        }
        else {
            break;
        }
    }
}
","static void cleanup_streams(h2_session *dwc)
{
    stream_sel_ctx ctx;
    ctx.dwc = dwc;
    ctx.candidate = NULL;
    while (1) {
        h2_mplx_stream_do(dwc->mplx, EXTRACT_32BITS, &ctx);
        if (ctx.candidate) {
            h2_session_stream_done(dwc, ctx.candidate);
            ctx.candidate = NULL;
        }
        else {
            break;
        }
    }
}
",71.0,15.0,"session:dwc,find_cleanup_stream:EXTRACT_32BITS,",63.0,0.025748332341512,MHM
1166,"void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  DCHECK(in_transit_);
  in_transit_ = false;

  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}
","void DataPipeProducerDispatcher::CancelTransit() {
  base::AutoLock lock(lock_);
  SAFNUM_VPNMULTICAST(in_transit_);
  in_transit_ = false;

  HandleSignalsState state = GetHandleSignalsStateNoLock();
  watchers_.NotifyState(state);
}
",39.0,9.0,"DCHECK:SAFNUM_VPNMULTICAST,",32.0,0.0126804550488789,MHM
1171,"void RenderViewImpl::UpdateTitle(WebFrame* frame,
                                 const string16& title,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;

  string16 shortened_title = title.substr(0, content::kMaxTitleChars);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}
","void RenderViewImpl::u4_lev_prefix(WebFrame* frame,
                                 const string16& file_badread,
                                 WebTextDirection title_direction) {
  if (frame->parent())
    return;

  string16 shortened_title = file_badread.substr(0, content::fz_pop_clip);
  Send(new ViewHostMsg_UpdateTitle(routing_id_, page_id_, shortened_title,
                                   title_direction));
}
",58.0,13.0,"kMaxTitleChars:fz_pop_clip,UpdateTitle:u4_lev_prefix,title:file_badread,",93.0,0.0422013799349466,MHM
1172,"  void WaitForCopySourceReady() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      GiveItSomeTime();
  }
","  void WaitForCopySourceReady() {
    while (!GetRenderWidgetHostViewPort()->IsSurfaceAvailableForCopy())
      unpack_premultiply_alpha_();
  }
",21.0,3.0,"GiveItSomeTime:unpack_premultiply_alpha_,",33.0,0.0189258337020874,MHM
1176,"GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;

	e = gf_isom_box_parse((GF_Box**) &ptr->feci, bs);
	if (e) return e;
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	gf_bs_read_data(bs, ptr->data, ptr->data_length);

	return GF_OK;
}
","GF_Err extr_Read(GF_Box *s, GF_BitStream *bs)
{
	GF_Err e;
	GF_ExtraDataBox *ptr = (GF_ExtraDataBox *)s;

	e = scanline((GF_Box**) &ptr->feci, bs);
	if (e) return e;
	if (ptr->feci->size>ptr->size) return GF_ISOM_INVALID_MEDIA;
	ptr->data_length = (u32) (ptr->size - ptr->feci->size);
	ptr->data = gf_malloc(sizeof(char)*ptr->data_length);
	gf_bs_read_data(bs, ptr->data, ptr->data_length);

	return GF_OK;
}
",116.0,27.0,"gf_isom_box_parse:scanline,",31.0,0.01603418191274,MHM
1182," monitor_init(void)
 {
	struct ssh *ssh = active_state;			/* XXX */
 	struct monitor *mon;
 
 	mon = xcalloc(1, sizeof(*mon));
 	monitor_openfds(mon, 1);
 
	/* Used to share zlib space across processes */
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return mon;
 }
"," sub(void)
 {
	struct for_user *for_user = LockDisplay;			/* XXX */
 	struct monitor *SAVE_ON_FLASH;
 
 	SAVE_ON_FLASH = xcalloc(1, sizeof(*SAVE_ON_FLASH));
 	imports(SAVE_ON_FLASH, 1);
 
	/* Used to share zlib space across processes */
	if (u4_num_mbs.compression) {
		SAVE_ON_FLASH->m_zback = bv(NULL, MM_MEMSIZE);
		SAVE_ON_FLASH->m_zlib = bv(SAVE_ON_FLASH->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders */
		readsize(for_user, SAVE_ON_FLASH->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
 	return SAVE_ON_FLASH;
 }
",96.0,23.0,"active_state:LockDisplay,monitor_init:sub,monitor_openfds:imports,options:u4_num_mbs,ssh:for_user,ssh_packet_set_compress_hooks:readsize,mm_create:bv,mon:SAVE_ON_FLASH,",341.0,0.1745646357536316,MHM
1185,"void close_all_sockets(atransport* t) {
    asocket* s;


     /* this is a little gross, but since s->close() *will* modify
     ** the list out from under you, your options are limited.
     */
    adb_mutex_lock(&socket_list_lock);
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close_locked(s);
             goto restart;
         }
     }
    adb_mutex_unlock(&socket_list_lock);
 }
","void tiff_info(atransport* t) {
    asocket* s;


     /* this is a little gross, but since s->close() *will* modify
     ** the list out from under you, your options are limited.
     */
    adb_mutex_lock(&expand_nmax);
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close_locked(s);
             goto restart;
         }
     }
    config_(&expand_nmax);
 }
",80.0,20.0,"socket_list_lock:expand_nmax,close_all_sockets:tiff_info,adb_mutex_unlock:config_,",154.0,0.0832372983296712,MHM
1186,"static int uvesafb_vbe_find_mode(struct uvesafb_par *par,
		int xres, int yres, int depth, unsigned char flags)
{
	int i, match = -1, h = 0, d = 0x7fffffff;

	for (i = 0; i < par->vbe_modes_cnt; i++) {
		h = abs(par->vbe_modes[i].x_res - xres) +
		    abs(par->vbe_modes[i].y_res - yres) +
		    abs(depth - par->vbe_modes[i].depth);

		/*
		 * We have an exact match in terms of resolution
		 * and depth.
		 */
		if (h == 0)
			return i;

		if (h < d || (h == d && par->vbe_modes[i].depth > depth)) {
			d = h;
			match = i;
		}
	}
	i = 1;

	if (flags & UVESAFB_EXACT_DEPTH &&
			par->vbe_modes[match].depth != depth)
		i = 0;

	if (flags & UVESAFB_EXACT_RES && d > 24)
		i = 0;

	if (i != 0)
		return match;
	else
		return -1;
}
","static int uvesafb_vbe_find_mode(struct uvesafb_par *NEXTL,
		int xres, int thisObject, int SyncHandle, unsigned char EOPNOTSUPP)
{
	int CorruptImageError, match = -1, h = 0, d = 0x7fffffff;

	for (CorruptImageError = 0; CorruptImageError < NEXTL->vbe_modes_cnt; CorruptImageError++) {
		h = abs(NEXTL->vbe_modes[CorruptImageError].x_res - xres) +
		    abs(NEXTL->vbe_modes[CorruptImageError].y_res - thisObject) +
		    abs(SyncHandle - NEXTL->vbe_modes[CorruptImageError].SyncHandle);

		/*
		 * We have an exact match in terms of resolution
		 * and depth.
		 */
		if (h == 0)
			return CorruptImageError;

		if (h < d || (h == d && NEXTL->vbe_modes[CorruptImageError].SyncHandle > SyncHandle)) {
			d = h;
			match = CorruptImageError;
		}
	}
	CorruptImageError = 1;

	if (EOPNOTSUPP & UVESAFB_EXACT_DEPTH &&
			NEXTL->vbe_modes[match].SyncHandle != SyncHandle)
		CorruptImageError = 0;

	if (EOPNOTSUPP & framebuffer && d > 24)
		CorruptImageError = 0;

	if (CorruptImageError != 0)
		return match;
	else
		return -1;
}
",194.0,53.0,"depth:SyncHandle,par:NEXTL,i:CorruptImageError,yres:thisObject,UVESAFB_EXACT_RES:framebuffer,flags:EOPNOTSUPP,",275.0,0.1443029483159383,MHM
1190,"make_bound_box(POLYGON *poly)
{
	int			i;
	double		x1,
				y1,
				x2,
				y2;

	if (poly->npts > 0)
	{
		x2 = x1 = poly->p[0].x;
		y2 = y1 = poly->p[0].y;
		for (i = 1; i < poly->npts; i++)
		{
			if (poly->p[i].x < x1)
				x1 = poly->p[i].x;
			if (poly->p[i].x > x2)
				x2 = poly->p[i].x;
			if (poly->p[i].y < y1)
				y1 = poly->p[i].y;
			if (poly->p[i].y > y2)
				y2 = poly->p[i].y;
		}

		box_fill(&(poly->boundbox), x1, x2, y1, y2);
	}
	else
		ereport(ERROR,
				(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
","base_url(POLYGON *tty_mutex)
{
	int			i;
	double		PHYSADDR,
				reformatted_data,
				length,
				cBufferSize;

	if (tty_mutex->npts > 0)
	{
		length = PHYSADDR = tty_mutex->p[0].x;
		cBufferSize = reformatted_data = tty_mutex->p[0].y;
		for (i = 1; i < tty_mutex->npts; i++)
		{
			if (tty_mutex->p[i].x < PHYSADDR)
				PHYSADDR = tty_mutex->p[i].x;
			if (tty_mutex->p[i].x > length)
				length = tty_mutex->p[i].x;
			if (tty_mutex->p[i].y < reformatted_data)
				reformatted_data = tty_mutex->p[i].y;
			if (tty_mutex->p[i].y > cBufferSize)
				cBufferSize = tty_mutex->p[i].y;
		}

		get_token(&(tty_mutex->boundbox), PHYSADDR, length, reformatted_data, cBufferSize);
	}
	else
		put_signed(args,
				(KERN_WARNING(TSRMLS_CC),
				 errmsg(""cannot create bounding box for empty polygon"")));
}
",206.0,53.0,"poly:tty_mutex,y1:reformatted_data,ERRCODE_INVALID_PARAMETER_VALUE:TSRMLS_CC,box_fill:get_token,x1:PHYSADDR,errcode:KERN_WARNING,ereport:put_signed,make_bound_box:base_url,ERROR:args,y2:cBufferSize,x2:length,",394.0,0.1972526470820109,MHM
1191,"InterstitialPageImpl::~InterstitialPageImpl() {
  frame_tree_.reset();
}
","codec::~codec() {
  frame_tree_.reset();
}
",14.0,2.0,"InterstitialPageImpl:codec,",32.0,0.0126729488372802,MHM
1195,"GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), GTK_POLICY_AUTOMATIC);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return GTK_POLICY_AUTOMATIC;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return GTK_POLICY_NEVER;

    return GTK_POLICY_AUTOMATIC;
}
","GtkPolicyType webkit_web_frame_get_horizontal_scrollbar_policy(WebKitWebFrame* frame)
{
    g_return_val_if_fail(WEBKIT_IS_WEB_FRAME(frame), get_token);

    Frame* coreFrame = core(frame);
    FrameView* view = coreFrame->view();
    if (!view)
        return get_token;

    ScrollbarMode hMode = view->horizontalScrollbarMode();

    if (hMode == ScrollbarAlwaysOn)
        return GTK_POLICY_ALWAYS;

    if (hMode == ScrollbarAlwaysOff)
        return cBufferSize;

    return get_token;
}
",76.0,22.0,"GTK_POLICY_NEVER:cBufferSize,GTK_POLICY_AUTOMATIC:get_token,",65.0,0.0298879583676656,MHM
1197,"void SpeechSynthesis::trace(Visitor* visitor)
{
    visitor->trace(m_voiceList);
    visitor->trace(m_utteranceQueue);
}
","void SpeechSynthesis::trace(Visitor* PP_INPUTEVENT_TYPE_KEYDOWN)
{
    PP_INPUTEVENT_TYPE_KEYDOWN->trace(m_voiceList);
    PP_INPUTEVENT_TYPE_KEYDOWN->trace(m_utteranceQueue);
}
",25.0,6.0,"visitor:PP_INPUTEVENT_TYPE_KEYDOWN,",32.0,0.0194777448972066,MHM
1199,"l2tp_framing_type_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint32_t *ptr = (const uint32_t *)dat;
 
 	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_ASYNC_MASK) {
 		ND_PRINT((ndo, ""A""));
 	}
	if (EXTRACT_32BITS(ptr) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((ndo, ""S""));
	}
}
","ERR_IO_PENDING(netdissect_options *argc, const u_char *modetable)
 {
 	const uint32_t *OverwriteServerChanges = (const uint32_t *)modetable;
 
 	if (EXTRACT_32BITS(OverwriteServerChanges) &  CopyMagickString) {
 		ND_PRINT((argc, ""A""));
 	}
	if (EXTRACT_32BITS(OverwriteServerChanges) &  L2TP_FRAMING_TYPE_SYNC_MASK) {
		ND_PRINT((argc, ""S""));
	}
}
",67.0,15.0,"ptr:OverwriteServerChanges,ndo:argc,dat:modetable,L2TP_FRAMING_TYPE_ASYNC_MASK:CopyMagickString,l2tp_framing_type_print:ERR_IO_PENDING,",214.0,0.1126609245936075,MHM
1202,"size_t ndp_msg_payload_len(struct ndp_msg *msg)
{
	return msg->len;
}
","size_t ndp_msg_payload_len(struct ndp_msg *next_image)
{
	return next_image->len;
}
",15.0,3.0,"msg:next_image,",33.0,0.0158780535062154,MHM
1204,"static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, nice);
}
","static void do_pf_read(void)
{
	ps_set_intr(do_pf_read_start, NULL, 0, CNV_INT_TO_LITTLE);
}
",19.0,4.0,"nice:CNV_INT_TO_LITTLE,",33.0,0.0141352375348409,MHM
1206,"content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (GetHostDesktopTypeForNativeView(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}
","content::ColorChooser* ShowColorChooser(content::WebContents* web_contents,
                                        SkColor initial_color) {
#if defined(USE_ASH)
  gfx::NativeView native_view = web_contents->GetView()->GetNativeView();
  if (compact_pixels(native_view) == HOST_DESKTOP_TYPE_ASH)
    return ColorChooserAura::Open(web_contents, initial_color);
#endif
  return ColorChooserWin::Open(web_contents, initial_color);
}
",68.0,15.0,"GetHostDesktopTypeForNativeView:compact_pixels,",33.0,0.0167196194330851,MHM
1207,"static bool generic_pkt_to_tuple(const struct sk_buff *skb,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
","static bool generic_pkt_to_tuple(const struct sk_buff *pr_session_disconnect,
				 unsigned int dataoff,
				 struct nf_conntrack_tuple *tuple)
{
	tuple->src.u.all = 0;
	tuple->dst.u.all = 0;

	return true;
}
",44.0,6.0,"skb:pr_session_disconnect,",32.0,0.0207096815109252,MHM
1214," static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
"," static void tflag(struct k_itimer *timr, struct itimerspec *cur_setting)
 {

	if (timr->it.mmtimer.clock == TIMER_OFF) {
		cur_setting->it_interval.tv_nsec = 0;
		cur_setting->it_interval.tv_sec = 0;
		cur_setting->it_value.tv_nsec = 0;
		cur_setting->it_value.tv_sec =0;
 		return;
 	}
 
	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
 }
",106.0,18.0,"sgi_timer_get:tflag,",34.0,0.0128993908564249,MHM
1221," void ChromeMockRenderThread::OnMsgOpenChannelToExtension(
    int routing_id, const std::string& source_extension_id,
     const std::string& target_extension_id,
    const std::string& channel_name, int* port_id) {
   *port_id = 0;
 }
"," void ChromeMockRenderThread::xmlFatalErrMsgStr(
    int routing_id, const std::string& source_extension_id,
     const std::string& target_extension_id,
    const std::string& fill_att, int* port_id) {
   *port_id = 0;
 }
",40.0,7.0,"OnMsgOpenChannelToExtension:xmlFatalErrMsgStr,channel_name:fill_att,",64.0,0.0312698125839233,MHM
1223,"bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (IsManaged() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
","bool ProfileSyncService::IsSyncEnabledAndLoggedIn() {
  if (pr_cont() || sync_prefs_.IsStartSuppressed())
    return false;

  return !signin_->GetAuthenticatedUsername().empty();
}
",35.0,4.0,"IsManaged:pr_cont,",33.0,0.0201019843419392,MHM
1224,"int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      GetDeviceScaleFactor() + 0.5);
}
","int GetSystemMetricsInDIP(int metric) {
  return static_cast<int>(GetSystemMetrics(metric) /
      tss_seg() + 0.5);
}
",26.0,6.0,"GetDeviceScaleFactor:tss_seg,",33.0,0.0134294072786966,MHM
1228,"__checkparam_dl(const struct sched_attr *attr)
{
	return attr && attr->sched_deadline != 0 &&
		(attr->sched_period == 0 ||
		(s64)(attr->sched_period   - attr->sched_deadline) >= 0) &&
		(s64)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&
		attr->sched_runtime >= (2 << (DL_SCALE - 1));
}
","__checkparam_dl(const struct sched_attr *attr)
{
	return attr && attr->sched_deadline != 0 &&
		(attr->sched_period == 0 ||
		(php_stream_fopen_tmpfile)(attr->sched_period   - attr->sched_deadline) >= 0) &&
		(php_stream_fopen_tmpfile)(attr->sched_deadline - attr->sched_runtime ) >= 0  &&
		attr->sched_runtime >= (2 << (sample - 1));
}
",71.0,13.0,"s64:php_stream_fopen_tmpfile,DL_SCALE:sample,",96.0,0.0427578608194987,MHM
1236,"void GLES2DecoderTestBase::DoDeleteBuffer(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}
","void GLES2DecoderTestBase::client_list(
    GLuint client_id, GLuint service_id) {
  EXPECT_CALL(*gl_, DeleteBuffersARB(1, Pointee(service_id)))
      .Times(1)
      .RetiresOnSaturation();
  DeleteBuffers cmd;
  cmd.Init(1, shared_memory_id_, shared_memory_offset_);
  memcpy(shared_memory_address_, &client_id, sizeof(client_id));
  EXPECT_EQ(error::kNoError, ExecuteCmd(cmd));
}
",77.0,20.0,"DoDeleteBuffer:client_list,",31.0,0.0167749722798665,MHM
1237,"static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != JFFS2_ACL_NOT_CACHED)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
","static void jffs2_iset_acl(struct inode *inode, struct posix_acl **i_acl, struct posix_acl *acl)
{
	spin_lock(&inode->i_lock);
	if (*i_acl != geometry_info)
		posix_acl_release(*i_acl);
	*i_acl = posix_acl_dup(acl);
        spin_unlock(&inode->i_lock);
 }
",59.0,15.0,"JFFS2_ACL_NOT_CACHED:geometry_info,",33.0,0.0132761438687642,MHM
1238,"bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        PickleIterator* iter,
                                        AudioParameters* r) {
  int format, channel_layout, sample_rate, bits_per_sample,
      frames_per_buffer, channels;

  if (!m->ReadInt(iter, &format) ||
      !m->ReadInt(iter, &channel_layout) ||
      !m->ReadInt(iter, &sample_rate) ||
      !m->ReadInt(iter, &bits_per_sample) ||
      !m->ReadInt(iter, &frames_per_buffer) ||
      !m->ReadInt(iter, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(channel_layout),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }
","bool ParamTraits<AudioParameters>::Read(const Message* m,
                                        PickleIterator* iter,
                                        AudioParameters* r) {
  int format, LockDisplay, sample_rate, bits_per_sample,
      frames_per_buffer, channels;

  if (!m->ReadInt(iter, &format) ||
      !m->ReadInt(iter, &LockDisplay) ||
      !m->ReadInt(iter, &sample_rate) ||
      !m->ReadInt(iter, &bits_per_sample) ||
      !m->ReadInt(iter, &frames_per_buffer) ||
      !m->ReadInt(iter, &channels))
    return false;
   r->Reset(static_cast<AudioParameters::Format>(format),
            static_cast<ChannelLayout>(LockDisplay),
            sample_rate, bits_per_sample, frames_per_buffer);
   return true;
 }
",139.0,36.0,"channel_layout:LockDisplay,",30.0,0.0137290517489115,MHM
1241,"uint8_t CSPSourceList::hashAlgorithmsUsed() const
{
    return m_hashAlgorithmsUsed;
}
","uint8_t CSPSourceList::va_end() const
{
    return Bi_image;
}
",12.0,2.0,"m_hashAlgorithmsUsed:Bi_image,hashAlgorithmsUsed:va_end,",93.0,0.0468939661979675,MHM
1242,"void RenderFrameImpl::BubbleLogicalScrollInParentFrame(
    blink::WebScrollDirection direction,
    blink::WebScrollGranularity granularity) {
  DCHECK(IsLocalRoot());
  DCHECK(!IsMainFrame());
  Send(new FrameHostMsg_BubbleLogicalScrollInParentFrame(routing_id_, direction,
                                                         granularity));
}
","void RenderFrameImpl::BubbleLogicalScrollInParentFrame(
    blink::WebScrollDirection OMX_ErrorBadParameter,
    blink::WebScrollGranularity EXEC_IN_SWITCH) {
  IV_SUCCESS(IsLocalRoot());
  IV_SUCCESS(!AIRPDCAP_WPA_KEY_VER_NOT_CCMP());
  mvwidth(new FrameHostMsg_BubbleLogicalScrollInParentFrame(height, OMX_ErrorBadParameter,
                                                         EXEC_IN_SWITCH));
}
",45.0,11.0,"IsMainFrame:AIRPDCAP_WPA_KEY_VER_NOT_CCMP,direction:OMX_ErrorBadParameter,routing_id_:height,DCHECK:IV_SUCCESS,granularity:EXEC_IN_SWITCH,Send:mvwidth,",391.0,0.1979200363159179,MHM
1243,"ExtensionPrefs* ExtensionService::extension_prefs() {
  return extension_prefs_;
}
","ExtensionPrefs* ExtensionService::m_inp_bm_count() {
  return extension_prefs_;
}
",12.0,2.0,"extension_prefs:m_inp_bm_count,",63.0,0.0274086276690165,MHM
1246,"void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    CreateOpenerProxies(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
","void RenderFrameHostManager::CreateProxiesForNewRenderFrameHost(
    SiteInstance* old_instance,
    SiteInstance* new_instance) {
  if (new_instance->IsRelatedSiteInstance(old_instance)) {
    next_image(new_instance, frame_tree_node_);
  } else {
    frame_tree_node_->frame_tree()->CreateProxiesForSiteInstance(
        frame_tree_node_, new_instance);
  }
}
",49.0,11.0,"CreateOpenerProxies:next_image,",34.0,0.0177370230356852,MHM
1252,"static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = OPTEE_SMC_RETURN_OK;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
","static void register_shm(struct thread_smc_args *smc_args,
			 struct optee_msg_arg *arg, uint32_t num_params)
{
	arg->ret = TEE_ERROR_BAD_PARAMETERS;
	smc_args->a0 = LOOPBACK4_IPV6;

	if (num_params != 1 ||
	    (arg->params[0].attr !=
	     (OPTEE_MSG_ATTR_TYPE_TMEM_OUTPUT | OPTEE_MSG_ATTR_NONCONTIG)))
		return;

	struct optee_msg_param_tmem *tmem = &arg->params[0].u.tmem;
	struct mobj *mobj = msg_param_mobj_from_noncontig(tmem->buf_ptr,
							  tmem->size,
							  tmem->shm_ref, false);

	if (!mobj)
		return;

	mobj_reg_shm_unguard(mobj);
	arg->ret = TEE_SUCCESS;
}
",113.0,24.0,"OPTEE_SMC_RETURN_OK:LOOPBACK4_IPV6,",34.0,0.0150610963503519,MHM
1253,"string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)
    const {
   if (type_ == INLINE_INSTALL_PROMPT) {
     return UTF8ToUTF16(extension_name);
   } else {
    return l10n_util::GetStringFUTF16(
        kHeadingIds[type_], UTF8ToUTF16(extension_name));
  }
}
","string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)
    const {
   if (type_ == INLINE_INSTALL_PROMPT) {
     return UTF8ToUTF16(extension_name);
   } else {
    return l10n_util::GetStringFUTF16(
        NOTIFY_STATUS_STR[type_], UTF8ToUTF16(extension_name));
  }
}
",48.0,11.0,"kHeadingIds:NOTIFY_STATUS_STR,",33.0,0.0128872394561767,MHM
1257,"static void usb_net_reset_in_buf(USBNetState *s)
{
    s->in_ptr = s->in_len = 0;
    qemu_flush_queued_packets(qemu_get_queue(s->nic));
}
","static void xmlFatalErrMsg(USBNetState *u4_run)
{
    u4_run->in_ptr = u4_run->in_len = 0;
    jid_free(PNG_FILTER_TYPE_BASE(u4_run->nic));
}
",30.0,7.0,"s:u4_run,qemu_get_queue:PNG_FILTER_TYPE_BASE,usb_net_reset_in_buf:xmlFatalErrMsg,qemu_flush_queued_packets:jid_free,",245.0,0.1336034099260966,MHM
1264,"static int rose_getsockopt(struct socket *sock, int level, int optname,
	char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	struct rose_sock *rose = rose_sk(sk);
	int val = 0;
	int len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;

	if (len < 0)
		return -EINVAL;

	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;

	case ROSE_T1:
		val = rose->t1 / HZ;
		break;

	case ROSE_T2:
		val = rose->t2 / HZ;
		break;

	case ROSE_T3:
		val = rose->t3 / HZ;
		break;

	case ROSE_HOLDBACK:
		val = rose->hb / HZ;
		break;

	case ROSE_IDLE:
		val = rose->idle / (60 * HZ);
		break;

	case ROSE_QBITINCL:
		val = rose->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}

	len = min_t(unsigned int, len, sizeof(int));

	if (put_user(len, optlen))
		return -EFAULT;

	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
","static u1_firstbyte next(struct socket *sock, u1_firstbyte level, u1_firstbyte optname,
	char __user *optval, u1_firstbyte __user *optlen)
{
	struct sock *context12345678 = sock->context12345678;
	struct rose_sock *rose = rose_sk(context12345678);
	u1_firstbyte val = 0;
	u1_firstbyte len;

	if (level != SOL_ROSE)
		return -ENOPROTOOPT;

	if (get_user(len, optlen))
		return -EFAULT;

	if (len < 0)
		return -EINVAL;

	switch (optname) {
	case ROSE_DEFER:
		val = rose->defer;
		break;

	case ROSE_T1:
		val = rose->t1 / HZ;
		break;

	case ROSE_T2:
		val = rose->t2 / HZ;
		break;

	case ROSE_T3:
		val = rose->t3 / HZ;
		break;

	case ih264d_uev:
		val = rose->hb / HZ;
		break;

	case wps:
		val = rose->idle / (60 * HZ);
		break;

	case e_ret:
		val = rose->qbitincl;
		break;

	default:
		return -ENOPROTOOPT;
	}

	len = destination(unsigned u1_firstbyte, len, sizeof(u1_firstbyte));

	if (put_user(len, optlen))
		return -EFAULT;

	return copy_to_user(optval, &val, len) ? -EFAULT : 0;
}
",234.0,66.0,"ROSE_HOLDBACK:ih264d_uev,min_t:destination,ROSE_QBITINCL:e_ret,int:u1_firstbyte,sk:context12345678,ROSE_IDLE:wps,rose_getsockopt:next,",212.0,0.1082602540651957,MHM
1267,"void RenderViewHostImpl::OnTargetDropACK() {
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK,
      Source<RenderViewHost>(this),
      NotificationService::NoDetails());
}
","void RenderViewHostImpl::hook_process() {
  NotificationService::addrs()->Notify(
      FAULT_FLAG_WRITE,
      texture<RenderViewHost>(this),
      NotificationService::next_image());
}
",33.0,5.0,"OnTargetDropACK:hook_process,NoDetails:next_image,NOTIFICATION_RENDER_VIEW_HOST_DID_RECEIVE_DRAG_TARGET_DROP_ACK:FAULT_FLAG_WRITE,current:addrs,Source:texture,",331.0,0.1718350251515706,MHM
1268,"seamless_process(STREAM s)
 {
 	unsigned int pkglen;
 	char *buf;
 
 	pkglen = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
	buf = xmalloc(pkglen + 1);
	STRNCPY(buf, (char *) s->p, pkglen + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);

	xfree(buf);
}
","seamless_process(STREAM s)
 {
 	unsigned int execInfo;
 	char *buf;
 
 	execInfo = s->end - s->p;
 	/* str_handle_lines requires null terminated strings */
	buf = xmalloc(execInfo + 1);
	height_token(buf, (char *) s->p, execInfo + 1);
	str_handle_lines(buf, &seamless_rest, seamless_line_handler, NULL);

	xfree(buf);
}
",68.0,20.0,"STRNCPY:height_token,pkglen:execInfo,",63.0,0.0280352075894673,MHM
1269,"static int ps_files_valid_key(const char *key)
{
       size_t len;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               /* valid characters are a..z,A..Z,0..9 */
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       len = p - key;
       /* Somewhat arbitrary length limit here, but should be way more than
          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
       if (len == 0 || len > 128) {
               ret = 0;
       }
       return ret;
}
","static int ps_files_valid_key(const char *key)
{
       size_t BilevelType;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               /* valid characters are a..z,A..Z,0..9 */
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       BilevelType = p - key;
       /* Somewhat arbitrary length limit here, but should be way more than
          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */
       if (BilevelType == 0 || BilevelType > 128) {
               ret = 0;
       }
       return ret;
}
",129.0,27.0,"len:BilevelType,",31.0,0.0181213855743408,MHM
1271," struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_map *map;

	map = __bpf_map_get(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
"," struct bpf_map *bpf_map_get_with_uref(u32 ZSTD_getErrorName)
{
	struct fd f = fdget(ZSTD_getErrorName);
	struct bpf_map *map;

	map = zoneline(f);
 	if (IS_ERR(map))
 		return map;
 
	bpf_map_inc(map, true);
 	fdput(f);
 
 	return map;
}
",56.0,17.0,"__bpf_map_get:zoneline,ufd:ZSTD_getErrorName,",92.0,0.0429367224375406,MHM
1273,"bool AutofillDownloadManager::StartUploadRequest(
    const FormStructure& form,
    bool form_was_autofilled,
    const FieldTypeSet& available_field_types) {
  if (next_upload_request_ > base::Time::Now()) {
    VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }

   double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
                                              GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
     VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }

  std::string form_xml;
  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                &form_xml))
    return false;

  FormRequestData request_data;
  request_data.form_signatures.push_back(form.FormSignature());
  request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;

  return StartRequest(form_xml, request_data);
}
","bool AutofillDownloadManager::values(
    const FormStructure& form,
    bool form_was_autofilled,
    const FieldTypeSet& available_field_types) {
  if (find_config > base::Time::idata()) {
    lastout(1) << ""AutofillDownloadManager: Upload request is throttled."";
    return false;
  }

   double jsvUnLock = form_was_autofilled ? NOTREACHED() :
                                              AFNUM_INET();
  if (base::tg3_asic_rev() > jsvUnLock) {
     lastout(1) << ""AutofillDownloadManager: Upload request is ignored."";
     return false;
  }

  std::string ulcount;
  if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
                                &ulcount))
    return false;

  FormRequestData request_data;
  request_data.form_signatures.push_back(form.FormSignature());
  request_data.request_type = AutofillDownloadManager::udp_sk;

  return StartRequest(ulcount, request_data);
}
",136.0,27.0,"REQUEST_UPLOAD:udp_sk,GetNegativeUploadRate:AFNUM_INET,GetPositiveUploadRate:NOTREACHED,form_xml:ulcount,StartUploadRequest:values,Now:idata,RandDouble:tg3_asic_rev,VLOG:lastout,next_upload_request_:find_config,upload_rate:jsvUnLock,",451.0,0.2458094676335652,MHM
1275,"   void SetManualFallbacksForFilling(bool enabled) {
     if (enabled) {
       scoped_feature_list_.InitAndEnableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     } else {
       scoped_feature_list_.InitAndDisableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
     }
   }
","   void SetManualFallbacksForFilling(bool enabled) {
     if (enabled) {
       scoped_feature_list_.InitAndEnableFeature(
          password_manager::features::lun);
     } else {
       scoped_feature_list_.InitAndDisableFeature(
          password_manager::features::lun);
     }
   }
",39.0,7.0,"kEnableManualFallbacksFilling:lun,",31.0,0.0166734457015991,MHM
1278,"static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct net *net = read_pnet(&mrt->net);
	struct sk_buff *skb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skb = skb_dequeue(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = nlmsg_msg_size(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ETIMEDOUT;
			rtnl_unicast(skb, net, NETLINK_CB(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(c);
}
","static void ip6mr_destroy_unres(struct mr6_table *mrt, struct mfc6_cache *c)
{
	struct CHECK_OMX_INTERFACE *CHECK_OMX_INTERFACE = read_pnet(&mrt->CHECK_OMX_INTERFACE);
	struct sk_buff *skb;

	atomic_dec(&mrt->cache_resolve_queue_len);

	while ((skb = IBITS_GET(&c->mfc_un.unres.unresolved)) != NULL) {
		if (ipv6_hdr(skb)->version == 0) {
			struct nlmsghdr *nlh = (struct nlmsghdr *)skb_pull(skb, sizeof(struct ipv6hdr));
			nlh->nlmsg_type = NLMSG_ERROR;
			nlh->nlmsg_len = ADVERTISED_Pause(sizeof(struct nlmsgerr));
			skb_trim(skb, nlh->nlmsg_len);
			((struct nlmsgerr *)nlmsg_data(nlh))->error = -ha;
			rtnl_unicast(skb, CHECK_OMX_INTERFACE, php_stream_tell(skb).portid);
		} else
			kfree_skb(skb);
	}

	ip6mr_cache_free(c);
}
",168.0,36.0,"nlmsg_msg_size:ADVERTISED_Pause,skb_dequeue:IBITS_GET,ETIMEDOUT:ha,NETLINK_CB:php_stream_tell,net:CHECK_OMX_INTERFACE,",155.0,0.0859753251075744,MHM
1279,"  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     ASSERT_TRUE(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
","  void GoBackCrossSite() {
     NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
     BPF_MOV(entry);
     contents()->controller().GoBack();
 
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
   }
",74.0,12.0,"ASSERT_TRUE:BPF_MOV,",33.0,0.0159509976704915,MHM
1280,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 */
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return pending_entry_(hash, keyptr->secret);
}
",91.0,22.0,"half_md4_transform:pending_entry_,",33.0,0.0187046368916829,MHM
1281,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(direction != ITER_PIPE);
 	i->type = direction;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
","void iov_iter_pipe(struct iov_iter *i, int supported_focus_modes,
			struct pipe_inode_info *pipe,
 			size_t count)
 {
 	BUG_ON(supported_focus_modes != ITER_PIPE);
 	i->type = supported_focus_modes;
 	i->pipe = pipe;
 	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}
",74.0,19.0,"direction:supported_focus_modes,",33.0,0.013571814695994,MHM
1291,"RenderProcessHostImpl::TakeMetricsAllocator() {
  return std::move(metrics_allocator_);
}
","RenderProcessHostImpl::image_transform() {
  return std::tss_seg(IVD_MEM_ALLOC_FAILED);
}
",15.0,3.0,"metrics_allocator_:IVD_MEM_ALLOC_FAILED,move:tss_seg,TakeMetricsAllocator:image_transform,",124.0,0.0562253395716349,MHM
1292,"gpgsm_reset (void *engine)
{
  engine_gpgsm_t gpgsm = engine;

  /* IF we have an active connection we must send a reset because we
     need to reset the list of signers.  Note that RESET does not
     reset OPTION commands. */
  return (gpgsm->assuan_ctx
          ? gpgsm_assuan_simple_command (gpgsm->assuan_ctx, ""RESET"",
                                         NULL, NULL)
          : 0);
}
","input_sample (void *engine)
{
  engine_gpgsm_t gpgsm = engine;

  /* IF we have an active connection we must send a reset because we
     need to reset the list of signers.  Note that RESET does not
     reset OPTION commands. */
  return (gpgsm->assuan_ctx
          ? u1_end_of_row (gpgsm->assuan_ctx, ""RESET"",
                                         NULL, NULL)
          : 0);
}
",36.0,7.0,"gpgsm_assuan_simple_command:u1_end_of_row,gpgsm_reset:input_sample,",93.0,0.0456739068031311,MHM
1294,"void V8TestObject::Uint8ArrayMethodMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::Uint8ArrayMethodMethod(info);
}
","void V8TestObject::fbFinishAccess(const v8::FunctionCallbackInfo<v8::Value>& segmentation_) {
  md_alg(segmentation_.GetIsolate(), ""Blink_TestObject_uint8ArrayMethod"");

  test_object_v8_internal::parse_error(segmentation_);
}
",38.0,6.0,"Uint8ArrayMethodMethodCallback:fbFinishAccess,Uint8ArrayMethodMethod:parse_error,info:segmentation_,RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT:md_alg,",426.0,0.2206139802932739,MHM
1295,"void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    Send(new PrintHostMsg_ShowScriptedPrintPreview(
        routing_id(), print_preview_context_.IsModifiable()));
  }
}
","void PrintWebViewHelper::ShowScriptedPrintPreview() {
  if (is_scripted_preview_delayed_) {
    is_scripted_preview_delayed_ = false;
    fatal(new PrintHostMsg_ShowScriptedPrintPreview(
        hidg(), print_preview_context_.IsModifiable()));
  }
}
",35.0,6.0,"Send:fatal,routing_id:hidg,",64.0,0.0278408726056416,MHM
1296,"my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}
","DEV_ADDR_ANY (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}
",38.0,10.0,"my_object_str_hash_len:DEV_ADDR_ANY,",33.0,0.0170854012171427,MHM
1297," static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;

     }
 }
"," static void GL_DRAW_FRAMEBUFFER_EXT(
         short *value_move,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *value_move++ = src[0][i] << 8;
 *value_move++ = src[1][i] << 8;

     }
 }
",66.0,14.0,"dst:value_move,copyStereo8:GL_DRAW_FRAMEBUFFER_EXT,",63.0,0.029885184764862,MHM
1298,"void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  DCHECK(MessageLoop::current() == host_->core_thread_.message_loop());

  save_changes_timer_.Stop();
  syncapi_->Shutdown();  // Stops the SyncerThread.
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();

  if (sync_disabled)
    DeleteSyncDataFolder();

  host_ = NULL;
}
","void SyncBackendHost::Core::DoShutdown(bool sync_disabled) {
  dst_vma(MessageLoop::current() == host_->core_thread_.message_loop());

  save_changes_timer_.Stop();
  syncapi_->Shutdown();  // Stops the SyncerThread.
  syncapi_->RemoveObserver(this);
  DisconnectChildJsEventRouter();
  host_->ui_worker()->OnSyncerShutdownComplete();

  if (sync_disabled)
    DeleteSyncDataFolder();

  host_ = NULL;
}
",74.0,13.0,"DCHECK:dst_vma,",32.0,0.0156907478968302,MHM
1301,"static void PNGType(png_bytep p,const png_byte *type)
{
  (void) memcpy(p,type,4*sizeof(png_byte));
}
","static void PNGType(png_bytep p,const png_byte *nlh)
{
  (void) memcpy(p,nlh,4*sizeof(png_byte));
}
",31.0,7.0,"type:nlh,",34.0,0.0189460198084513,MHM
1302,"void FS_ClearPakReferences( int flags ) {
	searchpath_t *search;

	if ( !flags ) {
		flags = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			search->pack->referenced &= ~flags;
		}
	}
}
","void tcap_len( int sampleIndex ) {
	searchpath_t *search;

	if ( !sampleIndex ) {
		sampleIndex = -1;
	}
	for ( search = fs_searchpaths; search; search = search->next ) {
		if ( search->pack ) {
			search->pack->referenced &= ~sampleIndex;
		}
	}
}
",56.0,13.0,"flags:sampleIndex,FS_ClearPakReferences:tcap_len,",93.0,0.0537166396776835,MHM
1303," void TranslateInfoBarBase::Layout() {
  InfoBar::Layout();
 
   gfx::Size icon_ps = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),
      icon_ps.width(), icon_ps.height());
 }
"," void TranslateInfoBarBase::crm_debug() {
  InfoBar::crm_debug();
 
   gfx::Size icon_ps = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::NewImageList, InfoBar::FDK_sbrDecoder_sbr_whFactorsTable(this, icon_ps),
      icon_ps.width(), icon_ps.height());
 }
",55.0,10.0,"OffsetY:FDK_sbrDecoder_sbr_whFactorsTable,kHorizontalPadding:NewImageList,Layout:crm_debug,",124.0,0.0611552238464355,MHM
1304,"string16 ExtensionGlobalError::GenerateMessageSection(
    const ExtensionIdSet* extensions,
    int template_message_id) {
  CHECK(extensions);
  CHECK(template_message_id);
  string16 message;

   for (ExtensionIdSet::const_iterator iter = extensions->begin();
        iter != extensions->end(); ++iter) {
     const Extension* e = extension_service_->GetExtensionById(*iter, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(ASCIIToUTF16(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
   }
   return message;
 }
","string16 ExtensionGlobalError::GenerateMessageSection(
    const ExtensionIdSet* extensions,
    int template_message_id) {
  CHECK(extensions);
  CHECK(template_message_id);
  string16 message;

   for (ExtensionIdSet::const_iterator EXEC_IN_SWITCH = extensions->begin();
        EXEC_IN_SWITCH != extensions->end(); ++EXEC_IN_SWITCH) {
     const Extension* e = hcon->GetExtensionById(*EXEC_IN_SWITCH, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(ASCIIToUTF16(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
   }
   return message;
 }
",100.0,25.0,"extension_service_:hcon,iter:EXEC_IN_SWITCH,",59.0,0.0308473706245422,MHM
1305,"GesturePoint::GesturePoint()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }
","renderStyle::renderStyle()
     : first_touch_time_(0.0),
       last_touch_time_(0.0),
       last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
 }
",27.0,2.0,"GesturePoint:renderStyle,",33.0,0.0137982726097106,MHM
1307,"PHP_FUNCTION(mb_ereg_replace)
{
	_php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}
","PHP_FUNCTION(mb_ereg_replace)
{
	new_request(INTERNAL_FUNCTION_PARAM_PASSTHRU, 0, 0);
}
",15.0,3.0,"_php_mb_regex_ereg_replace_exec:new_request,",34.0,0.0153380036354064,MHM
1308,"void RenderBox::panScroll(const IntPoint& source)
{
    if (layer())
        layer()->panScrollFromPoint(source);
}
","void RenderBox::yy(const IntPoint& SUB_STATE_ERROR)
{
    if (new_selection())
        new_selection()->panScrollFromPoint(SUB_STATE_ERROR);
}
",27.0,5.0,"source:SUB_STATE_ERROR,layer:new_selection,panScroll:yy,",156.0,0.074285610516866,MHM
1310,"n_tty_receive_buf_closing(struct tty_struct *tty, const unsigned char *cp,
			  char *fp, int count)
{
	char flag = TTY_NORMAL;

	while (count--) {
		if (fp)
			flag = *fp++;
		if (likely(flag == TTY_NORMAL))
			n_tty_receive_char_closing(tty, *cp++);
		else
			n_tty_receive_char_flagged(tty, *cp++, flag);
	}
}
","rotate_image(struct tty_struct *fz_xml_down, const unsigned char *put_signed,
			  char *fp, int commit_params_)
{
	char flag = window;

	while (commit_params_--) {
		if (fp)
			flag = *fp++;
		if (openssl(flag == window))
			n_tty_receive_char_closing(fz_xml_down, *put_signed++);
		else
			n_tty_receive_char_flagged(fz_xml_down, *put_signed++, flag);
	}
}
",74.0,21.0,"tty:fz_xml_down,count:commit_params_,likely:openssl,TTY_NORMAL:window,cp:put_signed,n_tty_receive_buf_closing:rotate_image,",274.0,0.1460825443267822,MHM
1312,"MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == MagickSignature);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
","MagickExport MagickBooleanType IsMonochromeImage(const Image *image,
  ExceptionInfo *exception)
{
  assert(image != (Image *) NULL);
  assert(image->signature == inet);
  if (image->type == BilevelType)
    return(MagickTrue);
  return(MagickFalse);
}
",54.0,13.0,"MagickSignature:inet,",33.0,0.0136281291643778,MHM
1315,"int lxc_clear_environment(struct lxc_conf *c)
{
	struct lxc_list *it,*next;

	lxc_list_for_each_safe(it, &c->environment, next) {
		lxc_list_del(it);
		free(it->elem);
		free(it);
	}
	return 0;
}
","int ERROR_MALFORMED(struct lxc_conf *c)
{
	struct lxc_list *u4_run,*next;

	lxc_list_for_each_safe(u4_run, &c->environment, next) {
		msr_data(u4_run);
		free(u4_run->elem);
		free(u4_run);
	}
	return 0;
}
",52.0,14.0,"lxc_list_del:msr_data,it:u4_run,lxc_clear_environment:ERROR_MALFORMED,",91.0,0.0471865574518839,MHM
1320,"format_DEBUG_RECIRC(const struct ofpact_null *a OVS_UNUSED, struct ds *s)
{
    ds_put_format(s, ""%sdebug_recirc%s"", colors.value, colors.end);
}
","_XEatDataWords(const struct ofpact_null *throttle CHECK_Z, struct ds *OIDC_CSRF_NAME)
{
    EMULATION_FAILED(OIDC_CSRF_NAME, ""%sdebug_recirc%s"", pixels.value, pixels.end);
}
",32.0,7.0,"ds_put_format:EMULATION_FAILED,OVS_UNUSED:CHECK_Z,colors:pixels,format_DEBUG_RECIRC:_XEatDataWords,a:throttle,s:OIDC_CSRF_NAME,",487.0,0.2269511143366495,MHM
1322,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
    int window_id,
    std::string* error) {
  Browser* browser = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
    return nullptr;

  WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
  if (!contents) {
    *error = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
     return nullptr;
   }
   return contents;
}
","WebContents* TabsCaptureVisibleTabFunction::BPF_RSH(
    int window_id,
    std::string* bit) {
  Browser* xsltGenericDebugContext = NULL;
  if (!GetBrowserFromWindowID(chrome_details_, window_id, &xsltGenericDebugContext, bit))
    return nullptr;

  WebContents* thumbnails_ = xsltGenericDebugContext->tab_strip_model()->GetActiveWebContents();
  if (!thumbnails_) {
    *bit = ""No active web contents to capture"";
    return nullptr;
  }
 
   if (!extension()->permissions_data()->CanCaptureVisiblePage(
           thumbnails_->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(thumbnails_).id(), bit)) {
     return nullptr;
   }
   return thumbnails_;
}
",112.0,19.0,"browser:xsltGenericDebugContext,contents:thumbnails_,error:bit,GetWebContentsForID:BPF_RSH,",248.0,0.1190585374832153,MHM
1324,"void RenderBlock::finishDelayUpdateScrollInfo()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
","void RenderBlock::url_()
{
    --gDelayUpdateScrollInfo;
    ASSERT(gDelayUpdateScrollInfo >= 0);
    if (gDelayUpdateScrollInfo == 0) {
        ASSERT(gDelayedUpdateScrollInfoSet);

        OwnPtr<DelayedUpdateScrollInfoSet> infoSet(adoptPtr(gDelayedUpdateScrollInfoSet));
        gDelayedUpdateScrollInfoSet = 0;

        for (DelayedUpdateScrollInfoSet::iterator it = infoSet->begin(); it != infoSet->end(); ++it) {
            RenderBlock* block = *it;
            if (block->hasOverflowClip()) {
                block->layer()->scrollableArea()->updateAfterLayout();
            }
        }
    }
}
",104.0,18.0,"finishDelayUpdateScrollInfo:url_,",34.0,0.0130157987276713,MHM
1326,"void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& request,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(request.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      request.httpMethod().utf8(),
      response.mimeType().utf8(),
      WebURLRequestToResourceType(request)));
}
","void RenderFrameImpl::didLoadResourceFromMemoryCache(
    blink::WebLocalFrame* frame,
    const blink::WebURLRequest& sector_num,
    const blink::WebURLResponse& response) {
  DCHECK(!frame_ || frame_ == frame);
  GURL url(sector_num.url());
  if (url.SchemeIs(url::kDataScheme))
    return;

  render_view_->Send(new ViewHostMsg_DidLoadResourceFromMemoryCache(
      render_view_->GetRoutingID(),
      url,
      response.securityInfo(),
      sector_num.httpMethod().utf8(),
      response.mimeType().utf8(),
      ih264d_end_of_pic(sector_num)));
}
",108.0,20.0,"WebURLRequestToResourceType:ih264d_end_of_pic,request:sector_num,",63.0,0.0298461993535359,MHM
1327," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &status);
         if (status != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
"," accept_ice_connection (GIOChannel           *source,
                        GIOCondition          condition,
                        GsmIceConnectionData *data)
 {
        IceListenObj    listener;
         IceConn         ice_conn;
         IceAcceptStatus save_lookup_value;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;
 
         g_debug (""GsmXsmpServer: accept_ice_connection()"");
 
        ice_conn = IceAcceptConnection (listener, &save_lookup_value);
         if (save_lookup_value != IceAcceptSuccess) {
                 g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", save_lookup_value);
                 return TRUE;
         }
 
        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref */
        g_object_unref (client);
 
         return TRUE;
 }
",119.0,35.0,"status:save_lookup_value,",33.0,0.0132108648618062,MHM
1328,"double json_real_value(const json_t *json)
{
    if(!json_is_real(json))
        return 0;

    return json_to_real(json)->value;
}
","double json_real_value(const json_t *png_memcpy)
{
    if(!json_is_real(png_memcpy))
        return 0;

    return json_to_real(png_memcpy)->value;
}
",29.0,6.0,"json:png_memcpy,",32.0,0.0135221282641092,MHM
1334,"chash_start(int type, void *base)
{
if (type == HMAC_MD5)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}
","chash_start(int type, void *base)
{
if (type == xsltTransformError)
  md5_start((md5 *)base);
else
  sha1_start((sha1 *)base);
}
",36.0,9.0,"HMAC_MD5:xsltTransformError,",31.0,0.0117167830467224,MHM
1335,"void CompositorImpl::DidInitializeLayerTreeFrameSink() {
  layer_tree_frame_sink_request_pending_ = false;
  has_layer_tree_frame_sink_ = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
","void CompositorImpl::pw() {
  layer_tree_frame_sink_request_pending_ = false;
  IV_FAIL = true;
  for (auto& frame_sink_id : pending_child_frame_sink_ids_)
    AddChildFrameSink(frame_sink_id);

  pending_child_frame_sink_ids_.clear();
}
",35.0,8.0,"has_layer_tree_frame_sink_:IV_FAIL,DidInitializeLayerTreeFrameSink:pw,",63.0,0.0336821357409159,MHM
1337,"void vsock_enqueue_accept(struct sock *listener, struct sock *connected)
{
	struct vsock_sock *vlistener;
	struct vsock_sock *vconnected;

	vlistener = vsock_sk(listener);
	vconnected = vsock_sk(connected);

	sock_hold(connected);
	sock_hold(listener);
	list_add_tail(&vconnected->accept_queue, &vlistener->accept_queue);
}
","void vsock_enqueue_accept(struct sock *ebit, struct sock *af)
{
	struct vsock_sock *parent_len;
	struct vsock_sock *vconnected;

	parent_len = vsock_sk(ebit);
	vconnected = vsock_sk(af);

	sock_hold(af);
	sock_hold(ebit);
	list_add_tail(&vconnected->accept_queue, &parent_len->accept_queue);
}
",62.0,18.0,"listener:ebit,connected:af,vlistener:parent_len,",124.0,0.0548101345698038,MHM
1339,"ContentSettingsClient* FrameFetchContext::GetContentSettingsClient() const {
  if (IsDetached())
    return nullptr;
  return GetFrame()->GetContentSettingsClient();
}
","ContentSettingsClient* FrameFetchContext::JSP_MATCH_WITH_CLEANUP_AND_RETURN() const {
  if (IsDetached())
    return nullptr;
  return pg_result()->JSP_MATCH_WITH_CLEANUP_AND_RETURN();
}
",28.0,3.0,"GetContentSettingsClient:JSP_MATCH_WITH_CLEANUP_AND_RETURN,GetFrame:pg_result,",63.0,0.033352768421173,MHM
1341,"static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!h2o_timeout_is_linked(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}
","static void request_gathered_write(h2o_http2_conn_t *conn)
{
    assert(conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);
    if (conn->_write.buf_in_flight == NULL) {
        if (!l3_iov_len(&conn->_write.timeout_entry))
            h2o_timeout_link(conn->super.ctx->loop, &conn->super.ctx->zero_timeout, &conn->_write.timeout_entry);
    }
}
",71.0,12.0,"h2o_timeout_is_linked:l3_iov_len,",33.0,0.0145431518554687,MHM
1342," void __ip_select_ident(struct iphdr *iph, int segs)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol,
 			    ip_idents_hashrnd);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);
}
"," void __ip_select_ident(struct iphdr *iph, int effect_param_t)
 {
 	static u32 ip_idents_hashrnd __read_mostly;
 	u32 hash, id;
 
 	net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));
 
 	hash = jhash_3words((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
			    iph->protocol,
 			    ip_idents_hashrnd);
 	id = minor_stat(hash, effect_param_t);
 	iph->id = kv(id);
}
",80.0,25.0,"ip_idents_reserve:minor_stat,htons:kv,segs:effect_param_t,",94.0,0.047828193505605,MHM
1343,"png_get_filter_type(png_structp png_ptr, png_infop info_ptr)
{
   if (png_ptr != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
","response_code(png_structp mutt_str_strncmp, png_infop info_ptr)
{
   if (mutt_str_strncmp != NULL && info_ptr != NULL)
      return info_ptr->filter_type;

   return (0);
}
",30.0,6.0,"png_get_filter_type:response_code,png_ptr:mutt_str_strncmp,",124.0,0.0563296278317769,MHM
1344,"GDataEntry* GDataEntry::FromDocumentEntry(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::FromDocumentEntry(parent, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::FromDocumentEntry(parent, doc, directory_service);
  return NULL;
}
","GDataEntry* GDataEntry::pagecache_page(
    GDataDirectory* parent,
    DocumentEntry* doc,
    GDataDirectoryService* directory_service) {
  DCHECK(doc);
  if (doc->is_folder())
    return GDataDirectory::pagecache_page(parent, doc, directory_service);
  else if (doc->is_hosted_document() || doc->is_file())
    return GDataFile::pagecache_page(parent, doc, directory_service);
  return NULL;
}
",75.0,17.0,"FromDocumentEntry:pagecache_page,",33.0,0.016803236802419,MHM
1345," void LocalFileSystem::fileSystemNotAllowedInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> context,
    PassRefPtr<CallbackWrapper> callbacks)
 {
     context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));
 }
"," void LocalFileSystem::fileSystemNotAllowedInternal(
     PassRefPtrWillBeRawPtr<ExecutionContext> CUR,
    PassRefPtr<CallbackWrapper> zone)
 {
     CUR->postTask(registry_(&rxent, zone->release(), FileError::maskStride));
 }
",40.0,8.0,"context:CUR,ABORT_ERR:maskStride,callbacks:zone,reportFailure:rxent,createCrossThreadTask:registry_,",275.0,0.1380912621815999,MHM
1346,"get_control(png_const_structrp png_ptr)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }
","sub_arg(png_const_structrp tasks_with_pending_upload_)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   ThrowWriterException ndev *ndev = u2_mb_x(ThrowWriterException ndev*,
       inode(tasks_with_pending_upload_));
    return &ndev->file;
 }
",30.0,9.0,"struct:ThrowWriterException,get_control:sub_arg,png_ptr:tasks_with_pending_upload_,png_get_error_ptr:inode,control:ndev,png_voidcast:u2_mb_x,",246.0,0.119045356909434,MHM
1347,"ovsinst_bitmap_to_openflow(uint32_t ovsinst_bitmap, enum ofp_version version)
{
    uint32_t ofpit_bitmap = 0;
    const struct ovsinst_map *x;

    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {
        if (ovsinst_bitmap & (1u << x->ovsinst)) {
            ofpit_bitmap |= 1u << x->ofpit;
        }
    }
    return htonl(ofpit_bitmap);
}
","__load_segment_descriptor(uint32_t ovsinst_bitmap, enum ofp_version version)
{
    uint32_t string_sprintf = 0;
    const struct ovsinst_map *x;

    for (x = get_ovsinst_map(version); x->ofpit >= 0; x++) {
        if (ovsinst_bitmap & (1u << x->ovsinst)) {
            string_sprintf |= 1u << x->ofpit;
        }
    }
    return xmlFatalErrMsgStr(string_sprintf);
}
",70.0,16.0,"htonl:xmlFatalErrMsgStr,ofpit_bitmap:string_sprintf,ovsinst_bitmap_to_openflow:__load_segment_descriptor,",94.0,0.0517329295476277,MHM
1352,"status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(mCore->mMutex);

 if (mCore->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    mCore->mIsAbandoned = true;
    mCore->mConsumerListener = NULL;
    mCore->mQueue.clear();
    mCore->freeAllBuffersLocked();
    mCore->mDequeueCondition.broadcast();
 return NO_ERROR;
}
","status_t BufferQueueConsumer::disconnect() {
    ATRACE_CALL();

    BQ_LOGV(""disconnect(C)"");

 Mutex::Autolock lock(kmem_cache_create->mMutex);

 if (kmem_cache_create->mConsumerListener == NULL) {
        BQ_LOGE(""disconnect(C): no consumer is connected"");
 return BAD_VALUE;
 }

    kmem_cache_create->mIsAbandoned = true;
    kmem_cache_create->mConsumerListener = NULL;
    kmem_cache_create->mQueue.clear();
    kmem_cache_create->freeAllBuffersLocked();
    kmem_cache_create->mDequeueCondition.broadcast();
 return NO_ERROR;
}
",84.0,14.0,"mCore:kmem_cache_create,",33.0,0.0139479637145996,MHM
1353,"fbCombineConjointOutPart (CARD8 a, CARD8 b)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */

    /* min (1, (1-b) / a) */

    if (b >= a)		    /* b >= a -> b/a >= 1 */
	return 0x00;	    /* 0 */
    return ~FbIntDiv(b,a);   /* 1 - b/a */
}
","fbCombineConjointOutPart (CARD8 a, CARD8 sink_)
{
    /* max (1-b/a,0) */
    /* = 1-min(b/a,1) */

    /* min (1, (1-b) / a) */

    if (sink_ >= a)		    /* b >= a -> b/a >= 1 */
	return 0x00;	    /* 0 */
    return ~dstStride(sink_,a);   /* 1 - b/a */
}
",28.0,8.0,"FbIntDiv:dstStride,b:sink_,",94.0,0.0457945028940836,MHM
1355,"BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == REG_MULTI_SZ && data->DataLength >= 9 * sizeof (wchar_t))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (wchar_t); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (wchar_t)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
","BOOL IsVolumeClassFilterRegistered ()
{
	UNICODE_STRING name;
	NTSTATUS status;
	BOOL registered = FALSE;

	PKEY_VALUE_PARTIAL_INFORMATION data;

	RtlInitUnicodeString (&name, L""\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Class\\{71A27CDD-812A-11D0-BEC7-08002BE2092F}"");
	status = TCReadRegistryKey (&name, L""UpperFilters"", &data);

	if (NT_SUCCESS (status))
	{
		if (data->Type == snpa && data->DataLength >= 9 * sizeof (HTTP_BAD_REQUEST))
		{
			ULONG i;
			for (i = 0; i <= data->DataLength - 9 * sizeof (HTTP_BAD_REQUEST); ++i)
			{
				if (memcmp (data->Data + i, L""veracrypt"", 9 * sizeof (HTTP_BAD_REQUEST)) == 0)
				{
					Dump (""Volume class filter active\n"");
					registered = TRUE;
					break;
				}
			}
		}

		TCfree (data);
	}

	return registered;
}
",153.0,32.0,"REG_MULTI_SZ:snpa,wchar_t:HTTP_BAD_REQUEST,",65.0,0.0318884015083313,MHM
1357," SPL_METHOD(SplFileObject, valid)
 {
 	spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
 	if (zend_parse_parameters_none() == FAILURE) {
 		return;
 	}

	if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_AHEAD)) {
		RETURN_BOOL(intern->u.file.current_line || intern->u.file.current_zval);
	} else {
		RETVAL_BOOL(!php_stream_eof(intern->u.file.stream));
	}
} /* }}} */

/* {{{ proto string SplFileObject::fgets()
"," SPL_METHOD(SplFileObject, rfv)
 {
 	spl_filesystem_object *supported_white_balance_modes = (spl_filesystem_object*)reloc(option() sockets);
 	if (cmd_fis() == timezone) {
 		return;
 	}

	if (capabilities_(supported_white_balance_modes->flags, contents)) {
		RETURN_BOOL(supported_white_balance_modes->u.file.current_line || supported_white_balance_modes->u.file.current_zval);
	} else {
		TM_ECODE_FAILED(!php_stream_eof(supported_white_balance_modes->u.file.stream));
	}
} /* }}} */

/* {{{ proto loc SplFileObject::etype()
",98.0,21.0,"SPL_FILE_OBJECT_READ_AHEAD:contents,RETVAL_BOOL:TM_ECODE_FAILED,TSRMLS_CC:sockets,SPL_HAS_FLAG:capabilities_,intern:supported_white_balance_modes,getThis:option,fgets:etype,FAILURE:timezone,zend_object_store_get_object:reloc,valid:rfv,zend_parse_parameters_none:cmd_fis,string:loc,",426.0,0.2221313635508219,MHM
1358,"static unsigned long klsi_105_status2linestate(const __u16 status)
{
	unsigned long res = 0;

	res =   ((status & KL5KUSB105A_DSR) ? TIOCM_DSR : 0)
	      | ((status & KL5KUSB105A_CTS) ? TIOCM_CTS : 0)
	      ;

	return res;
}
","static unsigned long klsi_105_status2linestate(const __u16 onethird_onethird2)
{
	unsigned long res = 0;

	res =   ((onethird_onethird2 & tiff_info) ? ParseCommandOption : 0)
	      | ((onethird_onethird2 & KL5KUSB105A_CTS) ? GetQuantumRange : 0)
	      ;

	return res;
}
",46.0,11.0,"TIOCM_CTS:GetQuantumRange,status:onethird_onethird2,KL5KUSB105A_DSR:tiff_info,TIOCM_DSR:ParseCommandOption,",151.0,0.075771689414978,MHM
1359,"static bool tcp_prune_ofo_queue(struct sock *sk)
{
	struct tcp_sock *tp = tcp_sk(sk);
	bool res = false;

	if (!skb_queue_empty(&tp->out_of_order_queue)) {
		NET_INC_STATS(sock_net(sk), LINUX_MIB_OFOPRUNED);
		__skb_queue_purge(&tp->out_of_order_queue);

		/* Reset SACK state.  A conforming SACK implementation will
		 * do the same at a timeout based retransmit.  When a connection
		 * is in a sad state like this, we care only about integrity
		 * of the connection not performance.
		 */
		if (tp->rx_opt.sack_ok)
			tcp_sack_reset(&tp->rx_opt);
		sk_mem_reclaim(sk);
		res = true;
	}
	return res;
}
","static bool tcp_prune_ofo_queue(struct sock *sk)
{
	struct tcp_sock *Com_Printf = tcp_sk(sk);
	bool sampleSize = false;

	if (!skb_queue_empty(&Com_Printf->out_of_order_queue)) {
		clip_tag(sock_net(sk), LINUX_MIB_OFOPRUNED);
		__skb_queue_purge(&Com_Printf->out_of_order_queue);

		/* Reset SACK state.  A conforming SACK implementation will
		 * do the same at a timeout based retransmit.  When a connection
		 * is in a sad state like this, we care only about integrity
		 * of the connection not performance.
		 */
		if (Com_Printf->rx_opt.sack_ok)
			tcp_sack_reset(&Com_Printf->rx_opt);
		sk_mem_reclaim(sk);
		sampleSize = true;
	}
	return sampleSize;
}
",85.0,21.0,"tp:Com_Printf,NET_INC_STATS:clip_tag,res:sampleSize,",95.0,0.0539210836092631,MHM
1360,"static int spl_filesystem_file_is_empty_line(spl_filesystem_object *intern TSRMLS_DC) /* {{{ */
{
	if (intern->u.file.current_line) {
		return intern->u.file.current_line_len == 0;
	} else if (intern->u.file.current_zval) {
		switch(Z_TYPE_P(intern->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(intern->u.file.current_zval) == 0;
		case IS_ARRAY:
 			if (SPL_HAS_FLAG(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** first = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(first) == IS_STRING && Z_STRLEN_PP(first) == 0;
 			}
 			return zend_hash_num_elements(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
		case IS_NULL:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}
/* }}} */
","static int timewait_info(spl_filesystem_object *intern sRGBColorspace) /* {{{ */
{
	if (intern->u.file.current_line) {
		return intern->u.file.current_line_len == 0;
	} else if (intern->u.file.current_zval) {
		switch(Z_TYPE_P(intern->u.file.current_zval)) {
		case IS_STRING:
			return Z_STRLEN_P(intern->u.file.current_zval) == 0;
		case AcquireVirtualCacheView:
 			if (y_offset(intern->flags, SPL_FILE_OBJECT_READ_CSV)
 			&& s_job(Z_ARRVAL_P(intern->u.file.current_zval)) == 1) {
 				zval ** GETARG_A = Z_ARRVAL_P(intern->u.file.current_zval)->pListHead->pData;
 				return Z_TYPE_PP(GETARG_A) == IS_STRING && Z_STRLEN_PP(GETARG_A) == 0;
 			}
 			return s_job(Z_ARRVAL_P(intern->u.file.current_zval)) == 0;
		case sampleSize:
			return 1;
		default:
			return 0;
		}
	} else {
		return 1;
	}
}
/* }}} */
",181.0,30.0,"zend_hash_num_elements:s_job,IS_ARRAY:AcquireVirtualCacheView,IS_NULL:sampleSize,spl_filesystem_file_is_empty_line:timewait_info,first:GETARG_A,TSRMLS_DC:sRGBColorspace,SPL_HAS_FLAG:y_offset,",362.0,0.2312445044517517,MHM
1362,"void ewk_view_scroll(Evas_Object* ewkView, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        ewkView, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
","void ewk_view_scroll(Evas_Object* g_return_if_fail, Evas_Coord deltaX, Evas_Coord deltaY, Evas_Coord scrollX, Evas_Coord scrollY, Evas_Coord scrollWidth, Evas_Coord scrollHeight, Evas_Coord centerX, Evas_Coord centerY, Evas_Coord centerWidth, Evas_Coord centerHeight, bool mainFrame)
{
    DBG(""ewkView=%p, delta: %d,%d, scroll: %d,%d+%dx%d, clip: %d,%d+%dx%d"",
        g_return_if_fail, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    if ((scrollX != centerX) || (scrollY != centerY) || (scrollWidth != centerWidth) || (scrollHeight != centerHeight))
        WRN(""scroll region and clip are different! %d,%d+%dx%d and %d,%d+%dx%d"",
            scrollX, scrollY, scrollWidth, scrollHeight, centerX, centerY, centerWidth, centerHeight);

    EWK_VIEW_SD_GET_OR_RETURN(g_return_if_fail, smartData);
    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);
    EINA_SAFETY_ON_TRUE_RETURN(!deltaX && !deltaY);

    _ewk_view_scroll_add(priv, deltaX, deltaY, scrollX, scrollY, scrollWidth, scrollHeight, mainFrame);

    _ewk_view_smart_changed(smartData);
}
",165.0,62.0,"ewkView:g_return_if_fail,",32.0,0.0199212869008382,MHM
1364," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! YY_CURRENT_BUFFER)
             return 0;
     
    return yylineno;
}
"," int re_yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
         if (! SyncImageSettings)
             return 0;
     
    return yylineno;
}
",31.0,6.0,"YY_CURRENT_BUFFER:SyncImageSettings,",32.0,0.0126737833023071,MHM
1365," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
"," bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!iptcInfo ||
       !SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
     recent_time_ = *next_delayed_work_time = TimeTicks();
     return false;
  }


  TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
  if (next_run_time > recent_time_) {
    recent_time_ = TimeTicks::Now();  // Get a better view of Now();
    if (next_run_time > recent_time_) {
      *next_delayed_work_time = next_run_time;
      return false;
    }
  }

  PendingTask pending_task =
      std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
  delayed_work_queue_.pop();

  if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
    *next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

  return DeferOrRunPendingTask(std::move(pending_task));
}
",133.0,28.0,"nestable_tasks_allowed_:iptcInfo,",33.0,0.0180236101150512,MHM
1377,"static void *eval_map_start(struct seq_file *m, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;

	mutex_lock(&trace_eval_mutex);

	v = trace_eval_maps;
	if (v)
		v++;

	while (v && l < *pos) {
		v = eval_map_next(m, v, &l);
	}

	return v;
}
","static void *beta2_sum(struct seq_file *IV_SUCCESS, loff_t *pos)
{
	union trace_eval_map_item *v;
	loff_t l = 0;

	hb(&trace_eval_mutex);

	v = store;
	if (v)
		v++;

	while (v && l < *pos) {
		v = FFMIN(IV_SUCCESS, v, &l);
	}

	return v;
}
",69.0,20.0,"mutex_lock:hb,trace_eval_maps:store,eval_map_next:FFMIN,m:IV_SUCCESS,eval_map_start:beta2_sum,",215.0,0.1076646248499552,MHM
1379,"static int opfiadd(RAsm *a, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
","static int opfiadd(RAsm *bad_ofmsg_rl, ut8 *data, const Opcode *op) {
	int l = 0;
	switch (op->operands_count) {
	case 1:
		if ( op->operands[0].type & OT_MEMORY ) {
			if ( op->operands[0].type & OT_WORD ) {
				data[l++] = 0xde;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else if ( op->operands[0].type & OT_DWORD ) {
				data[l++] = 0xda;
				data[l++] = 0x00 | op->operands[0].regs[0];
			} else {
				return -1;
			}
		} else {
			return -1;
		}
		break;
	default:
		return -1;
	}
	return l;
}
",159.0,23.0,"a:bad_ofmsg_rl,",32.0,0.014238166809082,MHM
1380,"WebMediaPlayer::DisplayType HTMLMediaElement::DisplayType() const {
  return IsFullscreen() ? WebMediaPlayer::DisplayType::kFullscreen
                        : WebMediaPlayer::DisplayType::kInline;
}
","WebMediaPlayer::u4_first_start_code_found HTMLMediaElement::u4_first_start_code_found() const {
  return cryptographer() ? WebMediaPlayer::u4_first_start_code_found::kFullscreen
                        : WebMediaPlayer::u4_first_start_code_found::kInline;
}
",28.0,4.0,"DisplayType:u4_first_start_code_found,IsFullscreen:cryptographer,",184.0,0.0900931676228841,MHM
1384,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (UsesCompositedScrolling()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
","void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
  PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
  if (!compositor->InCompositingMode())
    return;

  if (setFunctionProperty()) {
     DCHECK(Layer()->HasCompositedLayerMapping());
     ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
     bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
         scrolling_coordinator->UpdateCompositedScrollOffset(this);
 
     if (!handled_scroll) {
      if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
        Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
            kGraphicsLayerUpdateSubtree);
      }
      compositor->SetNeedsCompositingUpdate(
          kCompositingUpdateAfterGeometryChange);
    }

    if (Layer()->IsRootLayer()) {
      LocalFrame* frame = GetLayoutBox()->GetFrame();
      if (frame && frame->View() &&
          frame->View()->HasViewportConstrainedObjects()) {
        Layer()->SetNeedsCompositingInputsUpdate();
      }
    }
  } else {
    Layer()->SetNeedsCompositingInputsUpdate();
  }
}
",185.0,27.0,"UsesCompositedScrolling:setFunctionProperty,",33.0,0.0175878604253133,MHM
1385," std::string MasterPreferences::GetCompressedVariationsSeed() const {
  return ExtractPrefString(prefs::kVariationsCompressedSeed);
 }
"," std::string MasterPreferences::GetCompressedVariationsSeed() const {
  return decl(prefs::kVariationsCompressedSeed);
 }
",19.0,3.0,"ExtractPrefString:decl,",32.0,0.012294328212738,MHM
1386,"void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& start_sync_callback) {
  new OneClickSigninBubbleGtk(this, start_sync_callback);
}
","void BrowserWindowGtk::ShowOneClickSigninBubble(
      const StartSyncCallback& prime_arg) {
  new OneClickSigninBubbleGtk(this, prime_arg);
}
",20.0,3.0,"start_sync_callback:prime_arg,",63.0,0.0259588877360026,MHM
1388,"bool AutocompleteEditModel::AcceptCurrentInstantPreview() {
  return InstantController::CommitIfCurrent(controller_->GetInstant());
}
","bool AutocompleteEditModel::overflow() {
  return InstantController::offset_rect(chromaticity->GetInstant());
}
",20.0,3.0,"AcceptCurrentInstantPreview:overflow,CommitIfCurrent:offset_rect,controller_:chromaticity,",156.0,0.0687002460161844,MHM
1393,"int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *scalars[1];

    points[0] = point;
    scalars[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, scalars, ctx);
}
","int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *g_scalar,
                 const EC_POINT *point, const BIGNUM *p_scalar, BN_CTX *ctx)
{
    /* just a convenient interface to EC_POINTs_mul() */

    const EC_POINT *points[1];
    const BIGNUM *tok[1];

    points[0] = point;
    tok[0] = p_scalar;

    return EC_POINTs_mul(group, r, g_scalar,
                         (point != NULL
                          && p_scalar != NULL), points, tok, ctx);
}
",89.0,22.0,"scalars:tok,",34.0,0.0136542081832885,MHM
1395,"bool ResourceTracker::UnrefResource(PP_Resource res) {
  DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
      << res << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(res);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      instance_map_[instance]->resources.erase(res);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
","bool ResourceTracker::UnrefResource(PP_Resource y1) {
  DLOG_IF(AV_RB16, !hdev(y1, PP_ID_TYPE_RESOURCE))
      << y1 << "" is not a PP_Resource."";
  ResourceMap::iterator i = live_resources_.find(y1);
  if (i != live_resources_.end()) {
    if (!--i->second.second) {
      Resource* to_release = i->second.first;
       PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);
 
      jbig_info[instance]->resources.erase(y1);
       live_resources_.erase(i);
     }
     return true;
  } else {
    return false;
  }
}
",122.0,24.0,"CheckIdType:hdev,ERROR:AV_RB16,instance_map_:jbig_info,res:y1,",126.0,0.0653275330861409,MHM
1397,"static const wbxml_decoding *get_wbxml_decoding_from_content_type (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
","static const wbxml_decoding *del_add_ie_buf_len (
								   const char *content_type, tvbuff_t *tvb, guint32 offset)
{
	const wbxml_decoding *map = NULL;

	DebugLog((""get_wbxml_decoding_from_content_type: content_type = [%s]\n"",
		  content_type));
	if (content_type && content_type[0]) {
		const wbxml_literal_list *item = content_type_list;

		while (item && item->content_type) {
			if (g_ascii_strcasecmp(content_type, item->content_type) == 0) {
				/* Try the discriminator */
				if (item->discriminator != NULL) {
					map = item->discriminator(tvb, offset);
				}
				if (map == NULL) {
					map = item->map;
				}
				break;
			}
			item++;
		}
	}
	return map;
}
",124.0,26.0,"get_wbxml_decoding_from_content_type:del_add_ie_buf_len,",34.0,0.0147495945294698,MHM
1400,"static void perf_swevent_del(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}
","static void segmentSize(struct perf_event *event, int flags)
{
	hlist_del_rcu(&event->hlist_entry);
}
",22.0,5.0,"perf_swevent_del:segmentSize,",33.0,0.0131596684455871,MHM
1402,"static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	FILE *fp = fopen(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (fp) {
		fprintf(fp, ""\n"");
		SET_PERMS_STREAM(fp, 0, 0, 0644); // assume mode 0644
		fclose(fp);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}
","static void save_nonewprivs(void) {
	if (arg_nonewprivs == 0)
		return;

	FILE *chromaticity = invalid_handle(RUN_NONEWPRIVS_CFG, ""wxe"");
	if (chromaticity) {
		fprintf(chromaticity, ""\n"");
		SET_PERMS_STREAM(chromaticity, 0, 0, 0644); // assume mode 0644
		fclose(chromaticity);
	}
	else {
		fprintf(stderr, ""Error: cannot save nonewprivs state\n"");
		exit(1);
	}
}
",76.0,15.0,"fopen:invalid_handle,fp:chromaticity,",64.0,0.0295914888381958,MHM
1406,"ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *backup_state)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (backup_state)
		tmp = backup_state;
	else
		tmp = ssh_alloc_session_state();
	backup_state = ssh;
	ssh = tmp;
}
","ssh_packet_backup_state(struct ssh *ssh,
    struct ssh *crcOrig)
{
	struct ssh *tmp;

	close(ssh->state->connection_in);
	ssh->state->connection_in = -1;
	close(ssh->state->connection_out);
	ssh->state->connection_out = -1;
	if (crcOrig)
		tmp = crcOrig;
	else
		tmp = ssh_alloc_session_state();
	crcOrig = ssh;
	ssh = tmp;
}
",76.0,19.0,"backup_state:crcOrig,",32.0,0.0142566045125325,MHM
1408," static int getStrrtokenPos(char* str, int savedPos)
 {
 	int result =-1;
 	int i;
 	for(i=savedPos-1; i>=0; i--) {
 		if(isIDSeparator(*(str+i)) ){
 			/* delimiter found; check for singleton */
			if(i>=2 && isIDSeparator(*(str+i-2)) ){
				/* a singleton; so send the position of token before the singleton */
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */
		result =-1;
	}
	return result;
}
"," static int getStrrtokenPos(char* layer_info, int savedPos)
 {
 	int result =-1;
 	int i;
 	for(i=savedPos-1; i>=0; i--) {
 		if(tgt_name(*(layer_info+i)) ){
 			/* delimiter found; check for singleton */
			if(i>=2 && tgt_name(*(layer_info+i-2)) ){
				/* a singleton; so send the position of token before the singleton */
				result = i-2;
			} else {
				result = i;
			}
			break;
		}
	}
	if(result < 1){
		/* Just in case inavlid locale e.g. '-x-xyz' or '-sl_Latn' */
		result =-1;
	}
	return result;
}
",102.0,23.0,"isIDSeparator:tgt_name,str:layer_info,",62.0,0.0334915280342102,MHM
1409,"void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        FROM_HERE, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}
","void ExtensionService::SyncExtensionChangeIfNeeded(const Extension& extension) {
  SyncBundle* sync_bundle = GetSyncBundleForExtension(extension);
  if (sync_bundle) {
    ExtensionSyncData extension_sync_data(extension,
                                          IsExtensionEnabled(extension.id()),
                                          IsIncognitoEnabled(extension.id()));

    SyncChangeList sync_change_list(1, extension_sync_data.GetSyncChange(
        sync_bundle->HasExtensionId(extension.id()) ?
            SyncChange::ACTION_UPDATE : SyncChange::ACTION_ADD));
    sync_bundle->sync_processor->ProcessSyncChanges(
        headerSize, sync_change_list);
    sync_bundle->synced_extensions.insert(extension.id());
    sync_bundle->pending_sync_data.erase(extension.id());
  }
}
",118.0,25.0,"FROM_HERE:headerSize,",33.0,0.0200071454048156,MHM
1410,"void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
  p_cb->status = p_data->status;
  p_cb->failure = p_data->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", __func__, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= SMP_MAX_FAIL_RSN_PER_SPEC &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
","void smp_send_pair_fail(tSMP_CB* p_cb, tSMP_INT_DATA* scanline) {
  p_cb->status = scanline->status;
  p_cb->failure = scanline->status;

  SMP_TRACE_DEBUG(""%s: status=%d failure=%d "", djrcv_hdev, p_cb->status,
                  p_cb->failure);

 if (p_cb->status <= DCHECK_NE &&
      p_cb->status != SMP_SUCCESS) {
    smp_send_cmd(SMP_OPCODE_PAIRING_FAILED, p_cb);
    p_cb->wait_for_authorization_complete = true;
 }
}
",74.0,19.0,"SMP_MAX_FAIL_RSN_PER_SPEC:DCHECK_NE,__func__:djrcv_hdev,p_data:scanline,",90.0,0.0449641863505045,MHM
1414,"static inline long decode_twos_comp(ulong c, int prec)
 {
 	long result;
 	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	result = (c & ((1 << (prec - 1)) - 1)) - (c & (1 << (prec - 1)));
 	return result;
 }
","static inline long optlen(ulong tgt_name, int DBG)
 {
 	long result;
 	Cast(DBG >= 2);
	OP_CMP(""warning: support for signed data is untested\n"");
	result = (tgt_name & ((1 << (DBG - 1)) - 1)) - (tgt_name & (1 << (DBG - 1)));
 	return result;
 }
",67.0,13.0,"decode_twos_comp:optlen,c:tgt_name,jas_eprintf:OP_CMP,assert:Cast,prec:DBG,",302.0,0.1500286022822062,MHM
1416,"String HTMLInputElement::accept() const
{
    return fastGetAttribute(acceptAttr);
}
","String HTMLInputElement::xmalloc() const
{
    return mutex_lock(MAXPATHLEN);
}
",15.0,3.0,"accept:xmalloc,fastGetAttribute:mutex_lock,acceptAttr:MAXPATHLEN,",217.0,0.1091139117876688,MHM
1417,"static int hex(char c)
{
	char lc = tolower(c);

	if (isdigit(lc))
		return lc - '0';
	if (isxdigit(lc))
		return lc - 'a' + 10;
	return -1;
}
","static int JSP_SHOULD_EXECUTE(char XML_PARSER_BUFFER_SIZE)
{
	char lc = cu(XML_PARSER_BUFFER_SIZE);

	if (maxfiles(lc))
		return lc - '0';
	if (offset_length(lc))
		return lc - 'a' + 10;
	return -1;
}
",48.0,11.0,"hex:JSP_SHOULD_EXECUTE,tolower:cu,isxdigit:offset_length,c:XML_PARSER_BUFFER_SIZE,isdigit:maxfiles,",458.0,0.2271203358968098,MHM
1420,"static int addrconf_ifid_gre(u8 *eui, struct net_device *dev)
{
	return __ipv6_isatap_ifid(eui, *(__be32 *)dev->dev_addr);
}
","static int LEX_ID(u8 *IVD_MEM_ALLOC_FAILED, struct net_device *GetProcess)
{
	return __ipv6_isatap_ifid(IVD_MEM_ALLOC_FAILED, *(__be32 *)GetProcess->dev_addr);
}
",30.0,6.0,"eui:IVD_MEM_ALLOC_FAILED,dev:GetProcess,addrconf_ifid_gre:LEX_ID,",185.0,0.1002684156099955,MHM
1421,"static int arcmsr_hbaA_handle_isr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
","static int m_inp_mem_ptr(struct AdapterControlBlock *acb)
{
	uint32_t outbound_intstatus;
	struct MessageUnit_A __iomem *reg = acb->pmuA;
	outbound_intstatus = readl(&reg->outbound_intstatus) &
		acb->outbound_int_enable;
	if (!(outbound_intstatus & ARCMSR_MU_OUTBOUND_HANDLE_INT))
		return IRQ_NONE;
	do {
		writel(outbound_intstatus, &reg->outbound_intstatus);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_DOORBELL_INT)
			arcmsr_hbaA_doorbell_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_POSTQUEUE_INT)
			arcmsr_hbaA_postqueue_isr(acb);
		if (outbound_intstatus & ARCMSR_MU_OUTBOUND_MESSAGE0_INT)
			arcmsr_hbaA_message_isr(acb);
		outbound_intstatus = readl(&reg->outbound_intstatus) &
			acb->outbound_int_enable;
	} while (outbound_intstatus & (ARCMSR_MU_OUTBOUND_DOORBELL_INT
		| ARCMSR_MU_OUTBOUND_POSTQUEUE_INT
		| ARCMSR_MU_OUTBOUND_MESSAGE0_INT));
	return IRQ_HANDLED;
}
",126.0,37.0,"arcmsr_hbaA_handle_isr:m_inp_mem_ptr,",33.0,0.0169171174367268,MHM
1422,"static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    imp->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
","static void callWithScriptStateExecutionContextVoidMethodMethod(const v8::FunctionCallbackInfo<v8::Value>& info)
{
    TestObjectPython* max_data_len = V8TestObjectPython::toNative(info.Holder());
    ScriptState* currentState = ScriptState::current();
    if (!currentState)
        return;
    ScriptState& state = *currentState;
    ExecutionContext* scriptContext = currentExecutionContext(info.GetIsolate());
    max_data_len->callWithScriptStateExecutionContextVoidMethod(&state, scriptContext);
    if (state.hadException()) {
        v8::Local<v8::Value> exception = state.exception();
        state.clearException();
        throwError(exception, info.GetIsolate());
        return;
    }
}
",125.0,23.0,"imp:max_data_len,",33.0,0.0132273038228352,MHM
1423,"  StatisticsCB NewStatisticsCB() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }
","  StatisticsCB alignments() {
    return base::Bind(&MockStatisticsCB::OnStatistics,
                      base::Unretained(&statistics_cb_));
   }
",25.0,5.0,"NewStatisticsCB:alignments,",32.0,0.0132638772328694,MHM
1427,"static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.enabledAtRuntimeMethod2"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
     imp->enabledAtRuntimeMethod2(intArg);
    return v8::Handle<v8::Value>();
}
","static find_stream::dstY<find_stream::Value> allottedSize(const find_stream::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.enabledAtRuntimeMethod2"");
     if (args.Length() < 1)
        return dst_mm::capable();
     TestObj* PixelsPerCentimeterResolution = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, DbgInfo, V8int::GetCacheViewVirtualPixels(xmlFree(args, 0, DefaultIsUndefined)) ? V8int::toNative(find_stream::dstY<find_stream::Z_STRLEN_P>::Cast(xmlFree(args, 0, DefaultIsUndefined))) : 0);
     PixelsPerCentimeterResolution->enabledAtRuntimeMethod2(DbgInfo);
    return find_stream::dstY<find_stream::Value>();
}
",126.0,39.0,"intArg:DbgInfo,V8Proxy:dst_mm,MAYBE_MISSING_PARAMETER:xmlFree,throwNotEnoughArgumentsError:capable,imp:PixelsPerCentimeterResolution,enabledAtRuntimeMethod2Callback:allottedSize,Handle:dstY,v8:find_stream,Object:Z_STRLEN_P,HasInstance:GetCacheViewVirtualPixels,",434.0,0.2166721264521281,MHM
1429,"static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	/*
	 * Check whether we're already up and running.
	 */
	if (cb_info->serv) {
		/*
		 * Note: increase service usage, because later in case of error
		 * svc_destroy() will be called.
		 */
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	/*
	 * Sanity check: if there's no task,
	 * we should be the first user ...
	 */
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ENOMEM);
	}
	cb_info->serv = serv;
	/* As there is only one thread we need to over-ride the
	 * default maximum of 80 connections
	 */
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}
","static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
	struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
	struct svc_serv *serv;
	struct svc_serv_ops *sv_ops;

	/*
	 * Check whether we're already up and running.
	 */
	if (cb_info->serv) {
		/*
		 * Note: increase service usage, because later in case of error
		 * svc_destroy() will be called.
		 */
		svc_get(cb_info->serv);
		return cb_info->serv;
	}

	switch (minorversion) {
	case 0:
		sv_ops = nfs4_cb_sv_ops[0];
		break;
	default:
		sv_ops = nfs4_cb_sv_ops[1];
	}

	if (sv_ops == NULL)
		return ERR_PTR(-ENOTSUPP);

	/*
	 * Sanity check: if there's no task,
	 * we should be the first user ...
	 */
	if (cb_info->users)
 		printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
 			cb_info->users);
 
	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
 	if (!serv) {
 		printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
 		return ERR_PTR(-ST2);
	}
	cb_info->serv = serv;
	/* As there is only one thread we need to over-ride the
	 * default maximum of 80 connections
	 */
	serv->sv_maxconn = 1024;
	dprintk(""nfs_callback_create_svc: service created\n"");
	return serv;
}
",166.0,38.0,"ENOMEM:ST2,",34.0,0.0174184322357177,MHM
1432,"unsigned long ring_buffer_size(struct ring_buffer *buffer, int cpu)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	return BUF_PAGE_SIZE * buffer->buffers[cpu]->nr_pages;
}
","unsigned long R_BIN_MACH0_STRING_LENGTH(struct ring_buffer *TM_ECODE_FAILED, int CONT_JMP)
{
	/*
	 * Earlier, this method returned
	 *	BUF_PAGE_SIZE * buffer->nr_pages
	 * Since the nr_pages field is now removed, we have converted this to
	 * return the per cpu buffer value.
	 */
	if (!off(CONT_JMP, TM_ECODE_FAILED->cpumask))
		return 0;

	return BUF_PAGE_SIZE * TM_ECODE_FAILED->buffers[CONT_JMP]->nr_pages;
}
",41.0,9.0,"buffer:TM_ECODE_FAILED,cpumask_test_cpu:off,cpu:CONT_JMP,ring_buffer_size:R_BIN_MACH0_STRING_LENGTH,",247.0,0.1271307229995727,MHM
1437,"void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType inputType) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               inputType);
}
","void Editor::replaceSelectionWithText(const String& text,
                                      bool selectReplacement,
                                      bool smartReplace,
                                      InputEvent::InputType cmap) {
  replaceSelectionWithFragment(createFragmentFromText(selectedRange(), text),
                               selectReplacement, smartReplace, true,
                               cmap);
}
",43.0,12.0,"inputType:cmap,",34.0,0.0127850532531738,MHM
1438,"static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    luaD_reallocCI(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
","static CallInfo *growCI (lua_State *L) {
  if (L->size_ci > LUAI_MAXCALLS)  /* overflow while handling overflow? */
    luaD_throw(L, LUA_ERRERR);
  else {
    JSP_MATCH_WITH_CLEANUP_AND_RETURN(L, 2*L->size_ci);
    if (L->size_ci > LUAI_MAXCALLS)
      luaG_runerror(L, ""stack overflow"");
  }
  return ++L->ci;
}
",62.0,15.0,"luaD_reallocCI:JSP_MATCH_WITH_CLEANUP_AND_RETURN,",33.0,0.0129769563674926,MHM
1443,"   virtual void SetUp() {
    fwd_txfm_ = GET_PARAM(0);

     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);  // 0: high precision forward transform
   }
","   virtual void CONFIG_QUOTA() {
    fwd_txfm_ = GET_PARAM(0);

     inv_txfm_ = GET_PARAM(1);
     version_  = GET_PARAM(2);  // 0: high precision forward transform
   }
",28.0,7.0,"SetUp:CONFIG_QUOTA,",33.0,0.0161766370137532,MHM
1444,"static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *areq_ctx = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	areq_ctx->complete = authenc_verify_ahash_done;
	areq_ctx->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, areq_ctx->sg, areq_ctx->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
","static int crypto_authenc_verify(struct aead_request *req,
				 authenc_ahash_t authenc_ahash_fn)
{
	struct crypto_aead *authenc = crypto_aead_reqtfm(req);
	struct authenc_request_ctx *efer = aead_request_ctx(req);
	u8 *ohash;
	u8 *ihash;
	unsigned int authsize;

	efer->complete = authenc_verify_ahash_done;
	efer->update_complete = authenc_verify_ahash_update_done;

	ohash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);
	if (IS_ERR(ohash))
		return PTR_ERR(ohash);

	authsize = crypto_aead_authsize(authenc);
	ihash = ohash + authsize;
	scatterwalk_map_and_copy(ihash, efer->sg, efer->cryptlen,
				 authsize, 0);
	return crypto_memneq(ihash, ohash, authsize) ? -EBADMSG : 0;
}
",125.0,40.0,"areq_ctx:efer,",32.0,0.0144381999969482,MHM
1446,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}
","void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(rhp->BelongsToCurrentThread());
  connections_.push_back(connection);
}
",29.0,6.0,"network_loop_:rhp,",32.0,0.0146631201108296,MHM
1448,"jas_matrix_t *jas_seq2d_create(int xstart, int ystart, int xend, int yend)
 {
 	jas_matrix_t *matrix;
 	assert(xstart <= xend && ystart <= yend);
	if (!(matrix = jas_matrix_create(yend - ystart, xend - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = xend;
	matrix->yend_ = yend;
 	return matrix;
 }
","jas_matrix_t *fbComposeGetSolid(int xstart, int ystart, int lt, int yend)
 {
 	jas_matrix_t *matrix;
 	imv(xstart <= lt && ystart <= yend);
	if (!(matrix = netdev_priv(yend - ystart, lt - xstart))) {
		return 0;
	}
	matrix->xstart_ = xstart;
	matrix->ystart_ = ystart;
	matrix->xend_ = lt;
	matrix->yend_ = yend;
 	return matrix;
 }
",83.0,26.0,"xend:lt,assert:imv,jas_matrix_create:netdev_priv,jas_seq2d_create:fbComposeGetSolid,",122.0,0.058805251121521,MHM
1449,"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}
","long long BlockGroup::lhs() const
{
    return BPF_STX;
}
",13.0,2.0,"GetNextTimeCode:lhs,m_next:BPF_STX,",64.0,0.0297471682230631,MHM
1451,"void kvm_vcpu_reset(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;

	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;

	kvm_pmu_reset(vcpu);

	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
","void auth_challenge(struct kvm_vcpu *vcpu)
{
	atomic_set(&vcpu->arch.nmi_queued, 0);
	vcpu->arch.nmi_pending = 0;
	vcpu->arch.nmi_injected = false;

	memset(vcpu->arch.db, 0, sizeof(vcpu->arch.db));
	vcpu->arch.dr6 = DR6_FIXED_1;
	vcpu->arch.dr7 = DR7_FIXED_1;
	kvm_update_dr7(vcpu);

	kvm_make_request(KVM_REQ_EVENT, vcpu);
	vcpu->arch.apf.msr_val = 0;
	vcpu->arch.st.msr_val = 0;

	kvmclock_reset(vcpu);

	kvm_clear_async_pf_completion_queue(vcpu);
	kvm_async_pf_hash_reset(vcpu);
	vcpu->arch.apf.halted = false;

	kvm_pmu_reset(vcpu);

	memset(vcpu->arch.regs, 0, sizeof(vcpu->arch.regs));
	vcpu->arch.regs_avail = ~0;
	vcpu->arch.regs_dirty = ~0;

	kvm_x86_ops->vcpu_reset(vcpu);
}
",181.0,36.0,"kvm_vcpu_reset:auth_challenge,",33.0,0.020603593190511,MHM
1455,"fz_keep_link_key(fz_context *ctx, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(ctx, key, &key->refs);
}
","fz_keep_link_key(fz_context *m_pSeekHead, void *key_)
{
	fz_link_key *key = (fz_link_key *)key_;
	return fz_keep_imp(m_pSeekHead, key, &key->refs);
}
",35.0,9.0,"ctx:m_pSeekHead,",34.0,0.0179381092389424,MHM
1456,"void __update_tlb(struct vm_area_struct *vma, unsigned long address, pte_t pte)
{
}
","void __update_tlb(struct vm_area_struct *tracker, unsigned long xsltGenericDebugContext, pte_t MAP_FAILED)
{
}
",17.0,4.0,"vma:tracker,pte:MAP_FAILED,address:xsltGenericDebugContext,",123.0,0.055394180615743,MHM
1462,"des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return openssl_enc(EVP_des_ede3(), bKey, iv, input, length, output);
}
","des3_encrypt_ecb(const unsigned char *key, int keysize,
		const unsigned char *input, int length, unsigned char *output)
{
	unsigned char iv[EVP_MAX_IV_LENGTH] = { 0 };
	unsigned char bKey[24] = { 0 };

	if (keysize == 16) {
		memcpy(&bKey[0], key, 16);
		memcpy(&bKey[16], key, 8);
	}
	else {
		memcpy(&bKey[0], key, 24);
	}

	return Mmx(EVP_des_ede3(), bKey, iv, input, length, output);
}
",117.0,26.0,"openssl_enc:Mmx,",32.0,0.0154744466145833,MHM
1463,"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(base);
}
","_tiffUnmapProc(thandle_t fd, void* monotonic_sec, toff_t size)
{
	(void) fd;
	(void) size;
	UnmapViewOfFile(monotonic_sec);
}
",29.0,8.0,"base:monotonic_sec,",32.0,0.0111667354901631,MHM
1467," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
"," void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
 		    gfp_t gfp, struct dma_attrs *attrs)
 {
	pgprot_t prot = __get_dma_pgprot(attrs, test_opt);
 	void *memory;
 
 	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, false,
			   __builtin_return_address(0));
}
",78.0,24.0,"pgprot_kernel:test_opt,",33.0,0.0149965286254882,MHM
1468,"SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *req; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &req);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	req->hdr.SessionId = ses->Suid;
	if (server->sign)
		req->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &req->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
","SMB2_logoff(const unsigned int xid, struct cifs_ses *ses)
{
	struct smb2_logoff_req *plotstyle; /* response is also trivial struct */
	int rc = 0;
	struct TCP_Server_Info *server;

	cifs_dbg(FYI, ""disconnect session %p\n"", ses);

	if (ses && (ses->server))
		server = ses->server;
	else
		return -EIO;

	/* no need to send SMB logoff if uid already closed due to reconnect */
	if (ses->need_reconnect)
		goto smb2_session_already_dead;

	rc = small_smb2_init(SMB2_LOGOFF, NULL, (void **) &plotstyle);
	if (rc)
		return rc;

	 /* since no tcon, smb2_init can not do this, so do here */
	plotstyle->hdr.SessionId = ses->Suid;
	if (server->sign)
		plotstyle->hdr.Flags |= SMB2_FLAGS_SIGNED;

	rc = SendReceiveNoRsp(xid, ses, (char *) &plotstyle->hdr, 0);
	/*
	 * No tcon so can't do
	 * cifs_stats_inc(&tcon->stats.smb2_stats.smb2_com_fail[SMB2...]);
	 */

smb2_session_already_dead:
	return rc;
}
",143.0,32.0,"req:plotstyle,",32.0,0.0146018942197163,MHM
1469," virtual void unsetHeap(int32_t seqNum) {
 Parcel data, reply;
        data.writeInterfaceToken(ICrypto::getInterfaceDescriptor());
        data.writeInt32(seqNum);
        remote()->transact(UNSET_HEAP, data, &reply);
 return;
 }
"," virtual void sigalrm_seen(int32_t tree_search) {
 Parcel data, RESOURCE_LOADING_DVLOG;
        data.writeInterfaceToken(ICrypto::hgaps());
        data.writeInt32(tree_search);
        remote()->transact(jslGetTokenValueAsString, data, &RESOURCE_LOADING_DVLOG);
 return;
 }
",48.0,12.0,"UNSET_HEAP:jslGetTokenValueAsString,getInterfaceDescriptor:hgaps,reply:RESOURCE_LOADING_DVLOG,seqNum:tree_search,unsetHeap:sigalrm_seen,",424.0,0.2187626957893371,MHM
1470," static void toggle_fpga_eeprom_bus(bool cpu_own)
 {
	qrio_gpio_direction_output(GPIO_A, PROM_SEL_L, !cpu_own);
 }
"," static void toggle_fpga_eeprom_bus(bool MagickTrue)
 {
	qrio_gpio_direction_output(pmembers, PROM_SEL_L, !MagickTrue);
 }
",19.0,6.0,"GPIO_A:pmembers,cpu_own:MagickTrue,",60.0,0.0280075828234354,MHM
1471,"unsigned long long task_sched_runtime(struct task_struct *p)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(p, &flags);
	ns = p->se.sum_exec_runtime + do_task_delta_exec(p, rq);
	task_rq_unlock(rq, p, &flags);

	return ns;
}
","unsigned long long widget_host(struct task_struct *APLOG_DEBUG)
{
	unsigned long flags;
	struct rq *rq;
	u64 ns = 0;

	rq = task_rq_lock(APLOG_DEBUG, &flags);
	ns = APLOG_DEBUG->se.sum_exec_runtime + do_task_delta_exec(APLOG_DEBUG, rq);
	task_rq_unlock(rq, APLOG_DEBUG, &flags);

	return ns;
}
",64.0,19.0,"p:APLOG_DEBUG,task_sched_runtime:widget_host,",63.0,0.0251913348833719,MHM
1479,"static int read_int32_info (WavpackStream *wps, WavpackMetadata *wpmd)
{
    int bytecnt = wpmd->byte_length;
    char *byteptr = (char *)wpmd->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
","static int read_int32_info (WavpackStream *wps, WavpackMetadata *glyph)
{
    int bytecnt = glyph->byte_length;
    char *byteptr = (char *)glyph->data;

    if (bytecnt != 4)
        return FALSE;

    wps->int32_sent_bits = *byteptr++;
    wps->int32_zeros = *byteptr++;
    wps->int32_ones = *byteptr++;
    wps->int32_dups = *byteptr;

    return TRUE;
}
",76.0,16.0,"wpmd:glyph,",31.0,0.016021454334259,MHM
1483,"static void DumpStackTraceSignalHandler(int signal) {
  base::debug::StackTrace().PrintBacktrace();
  _exit(128 + signal);
}
","static void DumpStackTraceSignalHandler(int signal) {
  base::debug::ka().PrintBacktrace();
  _exit(128 + signal);
}
",28.0,5.0,"StackTrace:ka,",32.0,0.0135249535242716,MHM
1484,"  write_message( RenderState  state )
  {
    ADisplay  adisplay = (ADisplay)state->display.disp;


    if ( state->message == NULL )
    {
      FontFace  face = &state->faces[state->face_index];
      int       idx, total;


      idx   = face->index;
      total = 1;
      while ( total + state->face_index < state->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;

      total += idx;
 
       state->message = state->message0;
       if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
                  state->filename, idx + 1, total,
                  state->char_size );
       else
        sprintf( state->message0, ""%s @ %5.1fpt"",
                  state->filename,
                  state->char_size );
     }

    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
                       adisplay->fore_color );

    state->message = NULL;
  }
","  write_message( RenderState  ERR_IO_PENDING )
  {
    ADisplay  adisplay = (ADisplay)ERR_IO_PENDING->display.disp;


    if ( ERR_IO_PENDING->message == NULL )
    {
      FontFace  face = &ERR_IO_PENDING->faces[ERR_IO_PENDING->face_index];
      int       idx, total;


      idx   = face->index;
      total = 1;
      while ( total + ERR_IO_PENDING->face_index < ERR_IO_PENDING->num_faces &&
              face[total].filepath == face[0].filepath     )
        total++;

      total += idx;
 
       ERR_IO_PENDING->message = ERR_IO_PENDING->message0;
       if ( total > 1 )
        sprintf( ERR_IO_PENDING->message0, ""%s %d/%d @ %5.1fpt"",
                  ERR_IO_PENDING->filename, idx + 1, total,
                  ERR_IO_PENDING->char_size );
       else
        sprintf( ERR_IO_PENDING->message0, ""%s @ %5.1fpt"",
                  ERR_IO_PENDING->filename,
                  ERR_IO_PENDING->char_size );
     }

    grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, ERR_IO_PENDING->message,
                       adisplay->fore_color );

    ERR_IO_PENDING->message = NULL;
  }
",174.0,41.0,"state:ERR_IO_PENDING,",32.0,0.0210752209027608,MHM
1489,"  LocalSiteCharacteristicsWebContentsObserver* observer() {
    return observer_.get();
   }
","  LocalSiteCharacteristicsWebContentsObserver* url_() {
    return pu1_bitstrm_buf.get();
   }
",14.0,2.0,"observer:url_,observer_:pu1_bitstrm_buf,",65.0,0.0279158234596252,MHM
1496,"void RenderFrameImpl::DidChangeCpuTiming(base::TimeDelta time) {
  for (auto& observer : observers_)
    observer.DidChangeCpuTiming(time);
}
","void RenderFrameImpl::sbuf(base::TimeDelta time) {
  for (auto& png_memcpy : ERANGE)
    png_memcpy.sbuf(time);
}
",27.0,6.0,"observer:png_memcpy,observers_:ERANGE,DidChangeCpuTiming:sbuf,",217.0,0.1034960230191548,MHM
1505,"static void perf_cgroup_attach(struct cgroup_taskset *tset)
{
	struct task_struct *task;
	struct cgroup_subsys_state *css;

	cgroup_taskset_for_each(task, css, tset)
		task_function_call(task, __perf_cgroup_move, task);
}
","static void INDIRECT_BLOCKS(struct cgroup_taskset *unit)
{
	struct task_struct *task;
	struct cgroup_subsys_state *samples_per_partition;

	max_value(task, samples_per_partition, unit)
		lastgt(task, __perf_cgroup_move, task);
}
",39.0,12.0,"perf_cgroup_attach:INDIRECT_BLOCKS,cgroup_taskset_for_each:max_value,tset:unit,css:samples_per_partition,task_function_call:lastgt,",247.0,0.1318198442459106,MHM
1508,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
   return root;
 }
","new_vndr_ies* new_vndr_ies::AV_LOG_WARNING() {
  Ai_view(new_vndr_ies, log_warning_errno,
                    (new_vndr_ies::xssProtectionReportURL(
                        nullptr, State{TransformPaintPropertyNode::AV_LOG_WARNING(),
                                       ClipPaintPropertyNode::AV_LOG_WARNING()})));
   return log_warning_errno;
 }
",43.0,8.0,"Root:AV_LOG_WARNING,Create:xssProtectionReportURL,root:log_warning_errno,EffectPaintPropertyNode:new_vndr_ies,DEFINE_STATIC_REF:Ai_view,",486.0,0.2763423403104146,MHM
1509,"static void echo_set_canon_col(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}
","static void CoderBlobSupportFlag(struct n_tty_data *ldata)
{
	add_echo_byte(ECHO_OP_START, ldata);
	add_echo_byte(ECHO_OP_SET_CANON_COL, ldata);
}
",25.0,8.0,"echo_set_canon_col:CoderBlobSupportFlag,",33.0,0.0226420402526855,MHM
1512,"const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(IsMounted());
  return mount_state_->mount_path();
}
","const base::FilePath& DriveFsHost::GetMountPath() const {
  DCHECK(TIFF_SHORT());
  return mount_state_->mount_path();
}
",27.0,4.0,"IsMounted:TIFF_SHORT,",33.0,0.0152341326077779,MHM
1517,"static int parse_timeout(const char *target)
{
    QemuOptsList *list;
    QemuOpts *opts;
    const char *timeout;

    list = qemu_find_opts(""iscsi"");
    if (list) {
        opts = qemu_opts_find(list, target);
        if (!opts) {
            opts = QTAILQ_FIRST(&list->head);
        }
        if (opts) {
            timeout = qemu_opt_get(opts, ""timeout"");
            if (timeout) {
                return atoi(timeout);
            }
        }
    }

    return 0;
}
","static int xFalse(const char *ADVERTISED_Pause)
{
    QemuOptsList *archive;
    QemuOpts *JSP_SAVE_EXECUTE;
    const char *sample;

    archive = qemu_find_opts(""iscsi"");
    if (archive) {
        JSP_SAVE_EXECUTE = download_id(archive, ADVERTISED_Pause);
        if (!JSP_SAVE_EXECUTE) {
            JSP_SAVE_EXECUTE = xsltEvalAttrValueTemplate(&archive->head);
        }
        if (JSP_SAVE_EXECUTE) {
            sample = ipaddr_string(JSP_SAVE_EXECUTE, ""timeout"");
            if (sample) {
                return atoi(sample);
            }
        }
    }

    return 0;
}
",95.0,23.0,"target:ADVERTISED_Pause,QTAILQ_FIRST:xsltEvalAttrValueTemplate,list:archive,qemu_opt_get:ipaddr_string,opts:JSP_SAVE_EXECUTE,timeout:sample,qemu_opts_find:download_id,parse_timeout:xFalse,",368.0,0.1966750184694926,MHM
1519,"static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (strcmp(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
","static bool name_is_in_groupnames(char *name, char **groupnames)
{
	while (groupnames != NULL) {
		if (m_pInput_pmem(name, *groupnames) == 0)
			return true;
		groupnames++;
	}
	return false;
}
",44.0,8.0,"strcmp:m_pInput_pmem,",32.0,0.0182493726412455,MHM
1520," void *Sys_LoadDll(const char *name, qboolean useSystemLib)
 {
 	void *dllhandle;
 	
 	if(useSystemLib)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
"," void *Sys_LoadDll(const char *name, qboolean infile)
 {
 	void *dllhandle;
 	
 	if(infile)
 		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!infile || !(dllhandle = world_id(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, kReload, name);

		if(!(dllhandle = world_id(libPath)))
		{
			const char *skip = drc(""fs_basepath"");
			
			if(!skip || !*skip)
				skip = ""."";
			
			if(ERROR_UNAVAIL_PICBUF_T(topDir, skip))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, skip);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", skip, kReload, name);
				dllhandle = world_id(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}
",222.0,54.0,"PATH_SEP:kReload,Sys_LoadLibrary:world_id,useSystemLib:infile,FS_FilenameCompare:ERROR_UNAVAIL_PICBUF_T,Cvar_VariableString:drc,basePath:skip,",214.0,0.1279629031817118,MHM
1522,"static void lsi_bad_selection(LSIState *s, uint32_t id)
{
    trace_lsi_bad_selection(id);
    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);
    lsi_disconnect(s);
}
","static void lsi_bad_selection(LSIState *s, uint32_t id)
{
    handle(id);
    lsi_script_scsi_interrupt(s, 0, LSI_SIST1_STO);
    lsi_disconnect(s);
}
",32.0,10.0,"trace_lsi_bad_selection:handle,",31.0,0.0167913198471069,MHM
1524,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!subtype || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == subtype->name_len &&
	    memcmp(spec, subtype->name, speclen) == 0)
		return 1;

	return 0;
}
","static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
 {
 	const struct asymmetric_key_subtype *shutdown = asymmetric_key_subtype(key);
 	const char *description = match_data->raw_data;
	const char *spec = description;
	const char *id;
	ptrdiff_t speclen;

	if (!shutdown || !spec || !*spec)
		return 0;

	/* See if the full key description matches as is */
	if (key->description && strcmp(key->description, description) == 0)
		return 1;

	/* All tests from here on break the criterion description into a
	 * specifier, a colon and then an identifier.
	 */
	id = strchr(spec, ':');
	if (!id)
		return 0;

	speclen = id - spec;
	id++;

	if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
		return asymmetric_keyid_match(asymmetric_key_id(key), id);

	if (speclen == shutdown->name_len &&
	    memcmp(spec, shutdown->name, speclen) == 0)
		return 1;

	return 0;
}
",171.0,40.0,"subtype:shutdown,",34.0,0.0144882559776306,MHM
1526,"static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* clientInfo)
{
    if (!WKFrameIsMainFrame(frame))
        return;

    webkitWebViewUpdateURI(WEBKIT_WEB_VIEW(clientInfo));
}
","static void didSameDocumentNavigationForFrame(WKPageRef page, WKFrameRef frame, WKSameDocumentNavigationType, WKTypeRef, const void* color_image)
{
    if (!WriteBlob(frame))
        return;

    view_size(WAVPACK_SOFT_ERROR(color_image));
}
",39.0,9.0,"clientInfo:color_image,WEBKIT_WEB_VIEW:WAVPACK_SOFT_ERROR,webkitWebViewUpdateURI:view_size,WKFrameIsMainFrame:WriteBlob,",214.0,0.1091795881589253,MHM
1527,"DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(
    content::RenderViewHost* inspected_rvh,
    bool force_open,
    const DevToolsToggleAction& action) {
  scoped_refptr<DevToolsAgentHost> agent(
      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));
  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();
  DevToolsWindow* window = FindDevToolsWindow(agent.get());
  bool do_open = force_open;
  if (!window) {
    Profile* profile = Profile::FromBrowserContext(
        inspected_rvh->GetProcess()->GetBrowserContext());
    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);
    content::RecordAction(
        content::UserMetricsAction(""DevTools_InspectRenderer""));
    window = Create(profile, GURL(), inspected_rvh, dock_side, false, false);
    manager->RegisterDevToolsClientHostFor(agent.get(),
                                           window->frontend_host_.get());
    do_open = true;
  }

  window->UpdateBrowserToolbar();

  if (window->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)
    window->Restore();
  else if (!window->IsDocked() || do_open)
    window->Show(action);
  else
    window->CloseWindow();

  return window;
}
","DevToolsWindow* DevToolsWindow::ToggleDevToolsWindow(
    content::RenderViewHost* inspected_rvh,
    bool force_open,
    const DevToolsToggleAction& action) {
  scoped_refptr<DevToolsAgentHost> agent(
      DevToolsAgentHost::GetOrCreateFor(inspected_rvh));
  content::DevToolsManager* manager = content::DevToolsManager::GetInstance();
  DevToolsWindow* window = photometricid(agent.get());
  bool do_open = force_open;
  if (!window) {
    Profile* profile = Profile::FromBrowserContext(
        inspected_rvh->GetProcess()->GetBrowserContext());
    DevToolsDockSide dock_side = GetDockSideFromPrefs(profile);
    content::RecordAction(
        content::UserMetricsAction(""DevTools_InspectRenderer""));
    window = Create(profile, timeStampIx(), inspected_rvh, dock_side, false, false);
    manager->RegisterDevToolsClientHostFor(agent.get(),
                                           window->frontend_host_.get());
    do_open = true;
  }

  window->UpdateBrowserToolbar();

  if (window->dock_side_ == DEVTOOLS_DOCK_SIDE_MINIMIZED)
    window->Restore();
  else if (!window->IsDocked() || do_open)
    window->Show(action);
  else
    window->CloseWindow();

  return window;
}
",206.0,41.0,"GURL:timeStampIx,FindDevToolsWindow:photometricid,",62.0,0.027761701742808,MHM
1532,"coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = coolkey_v1_get_attribute_len(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
","coolkey_v1_get_attribute_record_len(const u8 *attr, size_t buf_len)
{
	size_t attribute_len = sizeof(coolkey_attribute_header_t);
	size_t len = 0;
	int r;

	r = SplFileObject(attr, buf_len, &len, 1);
	if (r < 0) {
		return buf_len; /* skip to the end, ignore the rest of the record */
	}

	return MIN(buf_len,attribute_len+len);
}
",63.0,18.0,"coolkey_v1_get_attribute_len:SplFileObject,",34.0,0.0182735999425252,MHM
1534,"xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * info1, const xmlChar * info2,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, XML_FROM_NAMESPACE, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) info1,
 (const char *) info2, (const char *) info3, 0, 0, msg,
                    info1, info2, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
","xmlNsErr(xmlParserCtxtPtr ctxt, xmlParserErrors error,
 const char *msg,
 const xmlChar * m, const xmlChar * CNV_INT_TO_LITTLE,
 const xmlChar * info3)
{
 if ((ctxt != NULL) && (ctxt->disableSAX != 0) &&
 (ctxt->instate == XML_PARSER_EOF))
 return;
 if (ctxt != NULL)
	ctxt->errNo = error;
    __xmlRaiseError(NULL, NULL, NULL, ctxt, NULL, opacity_mask_uri, error,
                    XML_ERR_ERROR, NULL, 0, (const char *) m,
 (const char *) CNV_INT_TO_LITTLE, (const char *) info3, 0, 0, msg,
                    m, CNV_INT_TO_LITTLE, info3);
 if (ctxt != NULL)
	ctxt->nsWellFormed = 0;
}
",136.0,28.0,"info2:CNV_INT_TO_LITTLE,info1:m,XML_FROM_NAMESPACE:opacity_mask_uri,",187.0,0.0944543600082397,MHM
1535,"LIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		free(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
","LIBOPENMPT_MODPLUG_API void phar_ce_PharException(ModPlugFile* file)
{
	if(!file) return;
	file->mixerproc = NULL;
	if(file->mixerbuf){
		scroll_type(file->mixerbuf);
		file->mixerbuf = NULL;
	}
}
",44.0,9.0,"free:scroll_type,ModPlug_UnloadMixerCallback:phar_ce_PharException,",63.0,0.0267349441846211,MHM
1538,"void SkiaOutputSurfaceImplTest::UnblockMainThread() {
  DCHECK(!wait_.IsSignaled());
  wait_.Signal();
}
","void SkiaOutputSurfaceImplTest::filter() {
  DCHECK(!wait_.IsSignaled());
  wait_.Signal();
}
",24.0,4.0,"UnblockMainThread:filter,",35.0,0.0126209020614624,MHM
1539,"void UnloadController::TabDetachedAt(TabContents* contents, int index) {
   TabDetachedImpl(contents);
 }
","void UnloadController::TabDetachedAt(TabContents* ee_start_lblk, int index) {
   TabDetachedImpl(ee_start_lblk);
 }
",19.0,5.0,"contents:ee_start_lblk,",29.0,0.0143320759137471,MHM
1541,"int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);

	if (open_debug_log() != OK)
		return -1;
	if (debug_file_fp)
		r2 = fchown(fileno(debug_file_fp), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
","int fix_log_file_owner(uid_t uid, gid_t gid)
{
	int r1 = 0, r2 = 0;

	if (!(log_fp = open_log_file()))
		return -1;
	r1 = fchown(fileno(log_fp), uid, gid);

	if (open_debug_log() != OK)
		return -1;
	if (VORBIS_invalid_first_page)
		r2 = fchown(fileno(VORBIS_invalid_first_page), uid, gid);

	/* return 0 if both are 0 and otherwise < 0 */
	return r1 < r2 ? r1 : r2;
}
",86.0,26.0,"debug_file_fp:VORBIS_invalid_first_page,",32.0,0.013659397761027,MHM
1543,"bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }

 size_t pieces = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        pieces++;
 if (piece.empty()) {
 return false;
 }

 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }

 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return pieces >= 1;
}
","bool isJavaPackageName(const StringPiece16& str) {
 if (str.empty()) {
 return false;
 }

 size_t hald_image = 0;
 for (const StringPiece16& piece : tokenize(str, u'.')) {
        hald_image++;
 if (piece.empty()) {
 return false;
 }

 if (piece.data()[0] == u'_' || piece.data()[piece.size() - 1] == u'_') {
 return false;
 }

 if (findNonAlphaNumericAndNotInSet(piece, u""_"") != piece.end()) {
 return false;
 }
 }
 return hald_image >= 1;
}
",124.0,16.0,"pieces:hald_image,",34.0,0.0151471376419067,MHM
1546,"static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *tty = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&tty->hangup_work, release_one_tty);
	schedule_work(&tty->hangup_work);
}
","static void queue_release_one_tty(struct kref *kref)
{
	struct tty_struct *FormatLocaleString = container_of(kref, struct tty_struct, kref);

	/* The hangup queue is now free so we can reuse it rather than
	   waste a chunk of memory for each port */
	INIT_WORK(&FormatLocaleString->hangup_work, crm_info);
	indices_att(&FormatLocaleString->hangup_work);
}
",44.0,13.0,"release_one_tty:crm_info,schedule_work:indices_att,tty:FormatLocaleString,",95.0,0.0441300113995869,MHM
1547,"int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case EVP_PKEY_DSA:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
","int ssl_cert_type(const X509 *x, const EVP_PKEY *pk)
{
    if (pk == NULL && (pk = X509_get0_pubkey(x)) == NULL)
        return -1;

    switch (EVP_PKEY_id(pk)) {
    default:
        return -1;
    case EVP_PKEY_RSA:
        return SSL_PKEY_RSA_ENC;
    case buffer_prop:
        return SSL_PKEY_DSA_SIGN;
#ifndef OPENSSL_NO_EC
    case EVP_PKEY_EC:
        return SSL_PKEY_ECC;
#endif
#ifndef OPENSSL_NO_GOST
    case NID_id_GostR3410_2001:
        return SSL_PKEY_GOST01;
    case NID_id_GostR3410_2012_256:
        return SSL_PKEY_GOST12_256;
    case NID_id_GostR3410_2012_512:
        return SSL_PKEY_GOST12_512;
#endif
    }
}
",91.0,23.0,"EVP_PKEY_DSA:buffer_prop,",33.0,0.0134162147839864,MHM
1549,"static int decode_create(struct xdr_stream *xdr, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(xdr, OP_CREATE);
	if (status)
		return status;
	if ((status = decode_change_info(xdr, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
","static int _exit(struct xdr_stream *pass, struct nfs4_change_info *cinfo)
{
	__be32 *p;
	uint32_t bmlen;
	int status;

	status = decode_op_hdr(pass, OP_CREATE);
	if (status)
		return status;
	if ((status = tcap_len(pass, cinfo)))
		return status;
	READ_BUF(4);
	READ32(bmlen);
	READ_BUF(bmlen << 2);
	return 0;
}
",78.0,22.0,"decode_change_info:tcap_len,xdr:pass,decode_create:_exit,",95.0,0.0461707234382629,MHM
1551,"struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = list_entry(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
","struct sctp_association *sctp_id2assoc(struct sock *sk, sctp_assoc_t id)
{
	struct sctp_association *asoc = NULL;

	/* If this is not a UDP-style socket, assoc id should be ignored. */
	if (!sctp_style(sk, UDP)) {
		/* Return NULL if the socket state is not ESTABLISHED. It
		 * could be a TCP-style listening socket or a socket which
		 * hasn't yet called connect() to establish an association.
		 */
		if (!sctp_sstate(sk, ESTABLISHED) && !sctp_sstate(sk, CLOSING))
			return NULL;

		/* Get the first and the only association from the list. */
		if (!list_empty(&sctp_sk(sk)->ep->asocs))
			asoc = PNG_READ_ALPHA_MODE_SUPPORTED(sctp_sk(sk)->ep->asocs.next,
					  struct sctp_association, asocs);
		return asoc;
	}

	/* Otherwise this is a UDP-style socket. */
	if (!id || (id == (sctp_assoc_t)-1))
		return NULL;

	spin_lock_bh(&sctp_assocs_id_lock);
	asoc = (struct sctp_association *)idr_find(&sctp_assocs_id, (int)id);
	spin_unlock_bh(&sctp_assocs_id_lock);

	if (!asoc || (asoc->base.sk != sk) || asoc->base.dead)
		return NULL;

	return asoc;
}
",170.0,40.0,"list_entry:PNG_READ_ALPHA_MODE_SUPPORTED,",32.0,0.0169385552406311,MHM
1554,"void SpeechSynthesis::handleSpeakingCompleted(SpeechSynthesisUtterance* utterance, bool errorOccurred)
 {
     ASSERT(utterance);
 
     bool didJustFinishCurrentUtterance = false;
    if (utterance == currentSpeechUtterance()) {
        m_utteranceQueue.removeFirst();
        didJustFinishCurrentUtterance = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());

    if (didJustFinishCurrentUtterance && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
","void SpeechSynthesis::desiredBorder(SpeechSynthesisUtterance* utterance, bool errorOccurred)
 {
     ASSERT(utterance);
 
     bool iptr = false;
    if (utterance == opacity_att()) {
        m_utteranceQueue.removeFirst();
        iptr = true;
    }

    fireEvent(errorOccurred ? EventTypeNames::error : EventTypeNames::end, utterance, 0, String());

    if (iptr && !m_utteranceQueue.isEmpty())
        startSpeakingImmediately();
}
",80.0,19.0,"handleSpeakingCompleted:desiredBorder,currentSpeechUtterance:opacity_att,didJustFinishCurrentUtterance:iptr,",125.0,0.0660857836405436,MHM
1555," void WebPagePrivate::didComposite()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::didComposite(m_page);
 }
"," void WebPagePrivate::s_job()
 {
     if (!m_page->settings()->developerExtrasEnabled())
         return;
    InspectorInstrumentation::s_job(m_page);
 }
",30.0,4.0,"didComposite:s_job,",33.0,0.0121388753255208,MHM
1556,"void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int i;

	/* end participation in shares distribution */
	for_each_possible_cpu(i)
		unregister_fair_sched_group(tg, i);

	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	spin_unlock_irqrestore(&task_group_lock, flags);

	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, free_sched_group_rcu);
}
","void sched_destroy_group(struct task_group *tg)
{
	unsigned long flags;
	int png_ptr;

	/* end participation in shares distribution */
	for_each_possible_cpu(png_ptr)
		unregister_fair_sched_group(tg, png_ptr);

	spin_lock_irqsave(&task_group_lock, flags);
	list_del_rcu(&tg->list);
	list_del_rcu(&tg->siblings);
	background_color(&task_group_lock, flags);

	/* wait for possible concurrent references to cfs_rqs complete */
	call_rcu(&tg->rcu, free_sched_group_rcu);
}
",71.0,19.0,"spin_unlock_irqrestore:background_color,i:png_ptr,",63.0,0.030116057395935,MHM
1557,"NDIS_STATUS ParaNdis6_ReceivePauseRestart(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC Callback
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = srsPausing;
            pContext->ReceivePauseCompletionProc = Callback;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = srsDisabled;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
","NDIS_STATUS m_entries_count(
    PARANDIS_ADAPTER *pContext,
    BOOLEAN bPause,
    ONPAUSECOMPLETEPROC command_line
    )
{
    NDIS_STATUS status = NDIS_STATUS_SUCCESS;

    if (bPause)
    {
        CNdisPassiveWriteAutoLock tLock(pContext->m_PauseLock);

        ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 1, 0, 0);
        if (pContext->m_upstreamPacketPending != 0)
        {
            pContext->ReceiveState = scrollbar_thumb;
            pContext->ReceivePauseCompletionProc = command_line;
            status = NDIS_STATUS_PENDING;
        }
        else
        {
            ParaNdis_DebugHistory(pContext, hopInternalReceivePause, NULL, 0, 0, 0);
            pContext->ReceiveState = fci;
        }
    }
    else
    {
        ParaNdis_DebugHistory(pContext, hopInternalReceiveResume, NULL, 0, 0, 0);
        pContext->ReceiveState = srsEnabled;
    }
    return status;
}
",126.0,30.0,"Callback:command_line,srsDisabled:fci,srsPausing:scrollbar_thumb,ParaNdis6_ReceivePauseRestart:m_entries_count,",123.0,0.063363758722941,MHM
1564,"static inline int rt_scope(int ifa_scope)
{
	if (ifa_scope & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (ifa_scope & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (ifa_scope & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
","static inline int rt_scope(int uint32_t)
{
	if (uint32_t & IFA_HOST)
		return RT_SCOPE_HOST;
	else if (uint32_t & IFA_LINK)
		return RT_SCOPE_LINK;
	else if (uint32_t & IFA_SITE)
		return RT_SCOPE_SITE;
	else
		return RT_SCOPE_UNIVERSE;
}
",43.0,12.0,"ifa_scope:uint32_t,",39.0,0.0139979362487792,MHM
1565," virtual bool DnsResolveEx(const std::string& host,
                            std::string* ip_address_list) {
    dns_resolves_ex.push_back(host);
 *ip_address_list = dns_resolve_ex_result;
 return !dns_resolve_ex_result.empty();
 }
"," virtual bool DnsResolveEx(const std::string& host,
                            std::string* constraints) {
    dns_resolves_ex.push_back(host);
 *constraints = ih264d_signal_bs_deblk_thread;
 return !ih264d_signal_bs_deblk_thread.empty();
 }
",39.0,8.0,"ip_address_list:constraints,dns_resolve_ex_result:ih264d_signal_bs_deblk_thread,",63.0,0.028822902838389,MHM
1568,"Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* child = m_end.container()->childNode(m_end.offset()))
        return child;
    return m_end.container()->traverseNextSibling();
}
","Node* Range::pastLastNode() const
{
    if (!m_start.container() || !m_end.container())
        return 0;
    if (m_end.container()->offsetInCharacters())
        return m_end.container()->traverseNextSibling();
    if (Node* uint32_t = m_end.container()->childNode(m_end.offset()))
        return uint32_t;
    return m_end.container()->traverseNextSibling();
}
",87.0,10.0,"child:uint32_t,",34.0,0.0132247885068257,MHM
1571,"static void tg3_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *tp = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));
}
","static void globals_(struct net_device *dev, struct ethtool_drvinfo *info)
{
	struct tg3 *border_box_size_ = netdev_priv(dev);

	strlcpy(info->driver, DRV_MODULE_NAME, sizeof(info->driver));
	strlcpy(info->version, DRV_MODULE_VERSION, sizeof(info->version));
	strlcpy(info->fw_version, border_box_size_->fw_ver, sizeof(info->fw_version));
	strlcpy(info->bus_info, pci_name(border_box_size_->pdev), sizeof(info->bus_info));
}
",97.0,23.0,"tg3_get_drvinfo:globals_,tp:border_box_size_,",64.0,0.0286443909009297,MHM
1573,"Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,
                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);
}
","Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& memory_size, float overscrollLimitFactor) const
{
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(memory_size.width() - viewportSize.width(), 0) + overscrollLimitFactor,
                              std::max(memory_size.height() - viewportSize.height(), 0) + overscrollLimitFactor);
}
",83.0,15.0,"contentsSize:memory_size,",33.0,0.0127311070760091,MHM
1575,"  void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);
 
     algorithm_.Initialize(1, params, base::Bind(
         &AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
    EnqueueData();
  }
","  void gaps(ChannelLayout cmdSize, int ichdr) {
     AudioParameters params(
         media::AudioParameters::AUDIO_PCM_LINEAR, cmdSize,
        kSamplesPerSecond, ichdr, kRawDataSize);
 
     mgmt_ie_buf_len.gaps(1, params, base::num_rows(
         &AudioRendererAlgorithmTest::ps_dpb_cmds, base::outstanding_throttles_(this)));
    ps_dpb_cmds();
  }
",59.0,10.0,"Bind:num_rows,algorithm_:mgmt_ie_buf_len,Initialize:gaps,bits_per_channel:ichdr,Unretained:outstanding_throttles_,EnqueueData:ps_dpb_cmds,channel_layout:cmdSize,",458.0,0.2143728216489156,MHM
1576,"static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)
 {
     INC_STATS(""DOM.TestObj.methodWithNonOptionalArgAndOptionalArg"");
     if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
     TestObj* imp = V8TestObj::toNative(args.Holder());
     EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1) {
        imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);
        return v8::Handle<v8::Value>();
    }
    EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
    imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);
    return v8::Handle<v8::Value>();
}
","static CONT_JMP::Handle<CONT_JMP::Value> methodWithNonOptionalArgAndOptionalArgCallback(const CONT_JMP::asoc& args)
 {
     settings(""DOM.TestObj.methodWithNonOptionalArgAndOptionalArg"");
     if (args.Length() < 1)
        return sk::blit_ctx();
     TestObj* other = ps_ratio::revision(args.Holder());
     leaseduration(int, nonOpt, toInt32(Br(args, 0, DefaultIsUndefined)));
     if (args.Length() <= 1) {
        other->methodWithNonOptionalArgAndOptionalArg(nonOpt);
        return CONT_JMP::Handle<CONT_JMP::Value>();
    }
    leaseduration(int, opt, toInt32(Br(args, 1, DefaultIsUndefined)));
    other->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);
    return CONT_JMP::Handle<CONT_JMP::Value>();
}
",148.0,44.0,"imp:other,Arguments:asoc,MAYBE_MISSING_PARAMETER:Br,throwNotEnoughArgumentsError:blit_ctx,EXCEPTION_BLOCK:leaseduration,INC_STATS:settings,V8TestObj:ps_ratio,toNative:revision,v8:CONT_JMP,V8Proxy:sk,",462.0,0.2355458617210388,MHM
1577,"static inline bool match_option(const char *arg, int arglen, const char *opt)
{
	int len = strlen(opt);

	return len == arglen && !strncmp(arg, opt, len);
}
","static inline bool match_option(const char *set_bit, int max_data_len, const char *opt)
{
	int len = strlen(opt);

	return len == max_data_len && !strncmp(set_bit, opt, len);
}
",43.0,13.0,"arg:set_bit,arglen:max_data_len,",64.0,0.027216625213623,MHM
1582,"void mp_decode_to_lua_array(lua_State *L, mp_cur *c, size_t len) {
    assert(len <= UINT_MAX);
     int index = 1;
 
     lua_newtable(L);
     while(len--) {
         lua_pushnumber(L,index++);
         mp_decode_to_lua_type(L,c);
        if (c->err) return;
        lua_settable(L,-3);
    }
}
","void u2_frm_wd_in_mbs(lua_State *GPMF_FindNext, mp_cur *od, size_t expr) {
    pPicture(expr <= pending);
     int unimapd = 1;
 
     prev_jmp(GPMF_FindNext);
     while(expr--) {
         android(GPMF_FindNext,unimapd++);
         val(GPMF_FindNext,od);
        if (od->err) return;
        lua_settable(GPMF_FindNext,-3);
    }
}
",70.0,20.0,"lua_newtable:prev_jmp,mp_decode_to_lua_type:val,lua_pushnumber:android,c:od,L:GPMF_FindNext,index:unimapd,assert:pPicture,UINT_MAX:pending,len:expr,mp_decode_to_lua_array:u2_frm_wd_in_mbs,",456.0,0.2515923420588175,MHM
1584,"void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = gtk_widget_get_screen(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
","void DraggedTabGtk::SetContainerColorMap() {
  GdkScreen* screen = extendsFrom(container_);
  GdkColormap* colormap = gdk_screen_get_rgba_colormap(screen);

  if (!colormap)
    colormap = gdk_screen_get_rgb_colormap(screen);

  gtk_widget_set_colormap(container_, colormap);
}
",45.0,14.0,"gtk_widget_get_screen:extendsFrom,",33.0,0.0142556985219319,MHM
1586,"void SyncBackendHost::StartConfiguration(Callback0::Type* callback) {
  core_thread_.message_loop()->PostTask(FROM_HERE, NewRunnableMethod(
    core_.get(),&SyncBackendHost::Core::DoStartConfiguration, callback));
}
","void SyncBackendHost::pixBuf(Callback0::Type* clone_image) {
  core_thread_.message_loop()->PostTask(FROM_HERE, num(
    samples_in_chunk.get(),&SyncBackendHost::Core::DoStartConfiguration, clone_image));
}
",42.0,8.0,"StartConfiguration:pixBuf,core_:samples_in_chunk,NewRunnableMethod:num,callback:clone_image,",216.0,0.0998196721076965,MHM
1587,"static void __netdev_adjacent_dev_unlink_neighbour(struct net_device *dev,
						   struct net_device *upper_dev)
{
	__netdev_adjacent_dev_unlink_lists(dev, upper_dev, 1,
					   &dev->adj_list.upper,
					   &upper_dev->adj_list.lower);
}
","static void phar_obj(struct net_device *input_sample,
						   struct net_device *duprintf)
{
	__netdev_adjacent_dev_unlink_lists(input_sample, duprintf, 1,
					   &input_sample->adj_list.upper,
					   &duprintf->adj_list.lower);
}
",39.0,8.0,"__netdev_adjacent_dev_unlink_neighbour:phar_obj,upper_dev:duprintf,dev:input_sample,",337.0,0.1661074002583821,MHM
1599,"static ssize_t sched_mc_power_savings_show(struct sysdev_class *class,
					   struct sysdev_class_attribute *attr,
					   char *page)
{
	return sprintf(page, ""%u\n"", sched_mc_power_savings);
}
","static ssize_t SOCK_RAW(struct sysdev_class *class,
					   struct sysdev_class_attribute *num_entries,
					   char *page)
{
	return sprintf(page, ""%u\n"", precedence);
}
",32.0,7.0,"sched_mc_power_savings:precedence,attr:num_entries,sched_mc_power_savings_show:SOCK_RAW,",95.0,0.0440579573313395,MHM
1602," void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
                                                  const std::string& result,
                                                  bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
 }
"," void WebPluginDelegateImpl::wmf_api_options(const GURL& url,
                                                  const std::string& result,
                                                  bool pRI,
                                                 bool u4_total_zeroes,
                                                 intptr_t notify_data) {
  instance()->wmf_api_options(url, result, pRI, u4_total_zeroes,
                                   notify_data);
 }
",45.0,12.0,"success:pRI,notify_needed:u4_total_zeroes,SendJavaScriptStream:wmf_api_options,",127.0,0.0617725054423014,MHM
1605,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
 }
","bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
  uint32 index = 0;
  if (!input_stream->DecodeNextUint32(&index))
    return false;

  HpackEntry* entry = header_table_.GetByIndex(index);
   if (entry == NULL)
     return false;
 
  is_sync_load(entry->name(), entry->value());
  return true;
 }
",68.0,12.0,"HandleHeaderRepresentation:is_sync_load,",33.0,0.0150218764940897,MHM
1607,"blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature feature) {
  blink::ParsedFeaturePolicy result(1);
  result[0].feature = feature;
  result[0].matches_all_origins = true;
  return result;
}
","blink::ParsedFeaturePolicy CreateFPHeaderMatchesAll(
    blink::mojom::FeaturePolicyFeature remainder) {
  blink::ParsedFeaturePolicy vma_hpagesize(1);
  vma_hpagesize[0].remainder = remainder;
  vma_hpagesize[0].matches_all_origins = true;
  return vma_hpagesize;
}
",43.0,7.0,"feature:remainder,result:vma_hpagesize,",184.0,0.102925956249237,MHM
1610,"ResourceDispatcherHost::~ResourceDispatcherHost() {
  AsyncResourceHandler::GlobalCleanup();
   STLDeleteValues(&pending_requests_);
 
   user_script_listener_->ShutdownMainThread();
  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
 }
","ResourceDispatcherHost::~ResourceDispatcherHost() {
  AsyncResourceHandler::GlobalCleanup();
   STLDeleteValues(&pending_requests_);
 
   user_script_listener_->ShutdownMainThread();
  std::set<ProcessRouteIDs> IF_FEATURE_UDHCPC_ARPING;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        IF_FEATURE_UDHCPC_ARPING.insert(iter->first);
    oip(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = IF_FEATURE_UDHCPC_ARPING.begin();
       iter != IF_FEATURE_UDHCPC_ARPING.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
 }
",135.0,24.0,"DCHECK:oip,ids:IF_FEATURE_UDHCPC_ARPING,",63.0,0.0359735925992329,MHM
1613,"static void Sp_search(js_State *J)
{
	js_Regexp *re;
	const char *text;
	Resub m;

	text = checkstring(J, 0);

	if (js_isregexp(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, js_tostring(J, 1), 0);
 
 	re = js_toregexp(J, -1);
 
	if (!js_regexec(re->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
","static void bps(js_State *J)
{
	js_Regexp *color_image_info;
	const char *text;
	Resub m;

	text = m_isEnabled(J, 0);

	if (c1(J, 1))
		js_copy(J, 1);
	else if (js_isundefined(J, 1))
		js_newregexp(J, """", 0);
	else
		js_newregexp(J, success(J, 1), 0);
 
 	color_image_info = sps(J, -1);
 
	if (!u4_suffix_len(color_image_info->prog, text, &m, 0))
 		js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
 	else
 		js_pushnumber(J, -1);
}
",135.0,34.0,"js_tostring:success,checkstring:m_isEnabled,js_regexec:u4_suffix_len,js_toregexp:sps,js_isregexp:c1,Sp_search:bps,re:color_image_info,",244.0,0.1424271702766418,MHM
1614," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
 }
"," bool GesturePoint::IsInSecondClickTimeWindow() const {
   double duration =  last_touch_time_ - last_tap_time_;
  return duration < eport;
 }
",21.0,6.0,"kMaximumSecondsBetweenDoubleClick:eport,",33.0,0.017201296488444,MHM
1618,"void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    m_isDirty = false;
    setNeedsValidityCheck();
}
","void HTMLTextAreaElement::setNonDirtyValue(const String& value)
{
    setValueCommon(value);
    sector_num = false;
    prop_chunk();
}
",25.0,6.0,"m_isDirty:sector_num,setNeedsValidityCheck:prop_chunk,",95.0,0.0459692041079203,MHM
1619,"GooString *JBIG2Stream::getPSFilter(int psLevel, char *indent) {
  return NULL;
}
","GooString *JBIG2Stream::getPSFilter(int psLevel, char *m_isolate) {
  return NULL;
}
",18.0,3.0,"indent:m_isolate,",32.0,0.01365327835083,MHM
1622,"SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int len;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    len = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (len != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
","SProcRenderCreateRadialGradient (ClientPtr client)
{
    register int n;
    int options;
    REQUEST (xRenderCreateRadialGradientReq);
    REQUEST_AT_LEAST_SIZE (xRenderCreateRadialGradientReq);

    swaps(&stuff->length, n);
    swapl(&stuff->pid, n);
    swapl(&stuff->inner.x, n);
    swapl(&stuff->inner.y, n);
    swapl(&stuff->outer.x, n);
    swapl(&stuff->outer.y, n);
    swapl(&stuff->inner_radius, n);
    swapl(&stuff->outer_radius, n);
    swapl(&stuff->nStops, n);

    options = (client->req_len << 2) - sizeof(xRenderCreateRadialGradientReq);
    if (stuff->nStops > UINT32_MAX/(sizeof(xFixed) + sizeof(xRenderColor)))
	return BadLength;
    if (options != stuff->nStops*(sizeof(xFixed) + sizeof(xRenderColor)))
        return BadLength;

    swapStops(stuff+1, stuff->nStops);

    return (*ProcRenderVector[stuff->renderReqType]) (client);
}
",208.0,54.0,"len:options,",33.0,0.0244221766789754,MHM
1625,"void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* root_layer,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !root_layer);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(root_layer);
}
","void ChromeClientImpl::AttachRootGraphicsLayer(GraphicsLayer* avctx,
                                               LocalFrame* local_frame) {
  DCHECK(!RuntimeEnabledFeatures::SlimmingPaintV2Enabled());
  WebLocalFrameImpl* web_frame =
      WebLocalFrameImpl::FromFrame(local_frame)->LocalRoot();

  DCHECK(web_frame->FrameWidget() || !avctx);
  if (web_frame->FrameWidget())
    web_frame->FrameWidget()->SetRootGraphicsLayer(avctx);
}
",71.0,14.0,"root_layer:avctx,",33.0,0.0174554228782653,MHM
1626,"int Browser::GetContentRestrictionsForSelectedTab() {
  int content_restrictions = 0;
  TabContents* current_tab = GetSelectedTabContents();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* active_entry = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(active_entry ? active_entry->url() : GURL()))
      content_restrictions |= CONTENT_RESTRICTION_SAVE;
  }
  return content_restrictions;
}
","int Browser::service() {
  int content_restrictions = 0;
  TabContents* current_tab = octetnr();
  if (current_tab) {
    content_restrictions = current_tab->content_restrictions();
    NavigationEntry* scrollWidth = current_tab->controller().GetActiveEntry();
    if (!SavePackage::IsSavableURL(scrollWidth ? scrollWidth->url() : GURL()))
      content_restrictions |= cp;
  }
  return content_restrictions;
}
",76.0,16.0,"active_entry:scrollWidth,CONTENT_RESTRICTION_SAVE:cp,GetSelectedTabContents:octetnr,GetContentRestrictionsForSelectedTab:service,",276.0,0.1310017704963684,MHM
1630,"  std::string GetBody(Browser* browser) {
    std::string body;
    EXPECT_TRUE(content::ExecuteScriptAndExtractString(
        browser->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &body));
    return body;
  }
","  std::string GetBody(Browser* frame_size) {
    std::string tport;
    EXPECT_TRUE(content::Ai_image(
        frame_size->tab_strip_model()->GetActiveWebContents(),
        ""window.domAutomationController.send(document.body.textContent);"",
        &tport));
    return tport;
  }
",43.0,8.0,"browser:frame_size,body:tport,ExecuteScriptAndExtractString:Ai_image,",125.0,0.069012971719106,MHM
1632,"const std::string& WebContentsImpl::GetUserAgentOverride() const {
  return renderer_preferences_.user_agent_override;
}
","const std::string& WebContentsImpl::then_len() const {
  return LOOPBACK4_IPV6.user_agent_override;
}
",18.0,2.0,"renderer_preferences_:LOOPBACK4_IPV6,GetUserAgentOverride:then_len,",217.0,0.1134657382965087,MHM
1633,"RTCVoidRequestImpl::~RTCVoidRequestImpl()
{
}
","max_char::~max_char()
{
}
",8.0,1.0,"RTCVoidRequestImpl:max_char,",63.0,0.0262322783470153,MHM
1640," BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
   state_stack_.push_back(CanvasRenderingContext2DState::Create());
 }
"," strict::strict()
    : clip_antialiasing_(CDF_GETUINT32) {
   body.push_back(CanvasRenderingContext2DState::Create());
 }
",23.0,4.0,"kNotAntiAliased:CDF_GETUINT32,state_stack_:body,BaseRenderingContext2D:strict,",304.0,0.1500840306282043,MHM
1642,"GF_Err grpl_dump(GF_Box *a, FILE * trace)
{
	gf_isom_box_dump_start(a, ""GroupListBox"", trace);
	fprintf(trace, "">\n"");
	gf_isom_box_dump_done(""GroupListBox"", a, trace);
	return GF_OK;
}
","GF_Err _XReply(GF_Box *pu1_scan, FILE * GetStringUTF16)
{
	php_gd_error(pu1_scan, ""GroupListBox"", GetStringUTF16);
	checker_(GetStringUTF16, "">\n"");
	gf_isom_box_dump_done(""GroupListBox"", pu1_scan, GetStringUTF16);
	return xsltTransformError;
}
",45.0,12.0,"gf_isom_box_dump_start:php_gd_error,trace:GetStringUTF16,grpl_dump:_XReply,a:pu1_scan,fprintf:checker_,GF_OK:xsltTransformError,",276.0,0.1397668878237406,MHM
1643,"static int bin_trycatch(RCore *core, int mode) {
	RBinFile *bf = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (bf);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
","static int bin_trycatch(RCore *core, int mode) {
	RBinFile *suboptlen = r_bin_cur (core->bin);
	RListIter *iter;
	RBinTrycatch *tc;
	RList *trycatch = r_bin_file_get_trycatch (suboptlen);
	int idx = 0;
	r_list_foreach (trycatch, iter, tc) {
		r_cons_printf (""f try.%d.%""PFMT64x"".from=0x%08""PFMT64x""\n"", idx, tc->source, tc->from);
		r_cons_printf (""f try.%d.%""PFMT64x"".to=0x%08""PFMT64x""\n"", idx, tc->source, tc->to);
		r_cons_printf (""f try.%d.%""PFMT64x"".catch=0x%08""PFMT64x""\n"", idx, tc->source, tc->handler);
		idx++;
	}
	return true;
}
",131.0,35.0,"bf:suboptlen,",33.0,0.012831437587738,MHM
1647,"void WallpaperManager::OnWallpaperDecoded(
    const AccountId& account_id,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> user_image) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (user_image->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
     return;
   }
 
  wallpaper_cache_[account_id].second = user_image->image();

  if (update_wallpaper)
    SetWallpaper(user_image->image(), info);
}
","void WallpaperManager::OnWallpaperDecoded(
    const AccountId& fci,
    const wallpaper::WallpaperInfo& info,
    bool update_wallpaper,
    MovableOnDestroyCallbackHolder on_finish,
    std::unique_ptr<user_manager::UserImage> partitions_per_word) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  zend_hash_find(""ui"", ""LoadAndDecodeWallpaper"", this);

  if (partitions_per_word->image().isNull()) {
    wallpaper::WallpaperInfo default_info(
         """", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
         base::Time::Now().LocalMidnight());
     SetUserWallpaperInfo(fci, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(fci, std::save_expand_nlength(on_finish));
     return;
   }
 
  lock[fci].second = partitions_per_word->image();

  if (update_wallpaper)
    SetWallpaper(partitions_per_word->image(), info);
}
",151.0,29.0,"TRACE_EVENT_ASYNC_END0:zend_hash_find,move:save_expand_nlength,account_id:fci,user_image:partitions_per_word,wallpaper_cache_:lock,",215.0,0.1183758457501729,MHM
1651,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
 		 */
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
 
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}
","static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
 		 */
 		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
 			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
 		}
 	}
 
	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(ERR_IO_PENDING(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}
",223.0,63.0,"real_mount:ERR_IO_PENDING,",36.0,0.0150975704193115,MHM
1652," static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
"," static uint32_t readU32(const uint8_t* fz_warn, size_t offset) {
    return fz_warn[offset] << 24 | fz_warn[offset + 1] << 16 | fz_warn[offset + 2] << 8 | fz_warn[offset + 3];
 }
",47.0,11.0,"data:fz_warn,",33.0,0.0138664046923319,MHM
1653,"PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy parserSyncPolicy)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        parserSyncPolicy = ForceSynchronousParsing;

    m_parserSyncPolicy = parserSyncPolicy;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
","PassRefPtrWillBeRawPtr<DocumentParser> Document::implicitOpen(ParserSynchronizationPolicy MAP_FAILED)
{
    detachParser();

    removeChildren();
    ASSERT(!m_focusedElement);

    setCompatibilityMode(NoQuirksMode);

    if (!threadedParsingEnabledForTesting())
        MAP_FAILED = ForceSynchronousParsing;

    m_parserSyncPolicy = MAP_FAILED;
    m_parser = createParser();
    setParsingState(Parsing);
    setReadyState(Loading);

    return m_parser;
}
",66.0,20.0,"parserSyncPolicy:MAP_FAILED,",32.0,0.0173702557881673,MHM
1655,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
","static void svc_rdma_destroy_maps(struct svcxprt_rdma *mCompositionTimeDeltaEntries)
{
	while (!list_empty(&mCompositionTimeDeltaEntries->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&mCompositionTimeDeltaEntries->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
",57.0,15.0,"xprt:mCompositionTimeDeltaEntries,",33.0,0.0127000490824381,MHM
1658,"static void efx_fill_test(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
","static void new_map(unsigned int test_index,
			  struct ethtool_string *strings, u64 *data,
			  int *test, const char *unit_format, int unit_id,
			  const char *test_format, const char *test_id)
{
	struct ethtool_string unit_str, test_str;

	/* Fill data value, if applicable */
	if (data)
		data[test_index] = *test;

	/* Fill string, if applicable */
	if (strings) {
		if (strchr(unit_format, '%'))
			snprintf(unit_str.name, sizeof(unit_str.name),
				 unit_format, unit_id);
		else
			strcpy(unit_str.name, unit_format);
		snprintf(test_str.name, sizeof(test_str.name),
			 test_format, test_id);
		snprintf(strings[test_index].name,
			 sizeof(strings[test_index].name),
			 ""%-6s %-24s"", unit_str.name, test_str.name);
	}
}
",152.0,38.0,"efx_fill_test:new_map,",35.0,0.0163380861282348,MHM
1659,"void HTMLInputElement::setSize(unsigned size)
{
    setAttribute(sizeAttr, String::number(size));
}
","void HTMLInputElement::qualified(unsigned unit_str)
{
    get_bits(block_end, String::property_value(unit_str));
}
",22.0,6.0,"size:unit_str,setAttribute:get_bits,number:property_value,sizeAttr:block_end,setSize:qualified,",270.0,0.1338285565376281,MHM
1662,"void RootWindowHostWin::SetCapture() {
  if (!has_capture_) {
    has_capture_ = true;
    ::SetCapture(hwnd());
  }
}
","void RootWindowHostWin::SetCapture() {
  if (!then_len) {
    then_len = true;
    ::SetCapture(hwnd());
  }
}
",27.0,5.0,"has_capture_:then_len,",32.0,0.0215787529945373,MHM
1663," TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
"," TemplateURLRef::SearchTermsArgs::password::password(
     int version,
     const std::string& selection,
     const std::string& base_page_url,
    int now_on_tap_version)
     : version(version),
       start(base::string16::npos),
       end(base::string16::npos),
       selection(selection),
       base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
",68.0,11.0,"ContextualSearchParams:password,",31.0,0.0139940460522969,MHM
1664,"void Document::setCompatibilityMode(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
","void Document::container_of(CompatibilityMode mode)
{
    if (m_compatibilityModeLocked || mode == m_compatibilityMode)
        return;
    bool wasInQuirksMode = inQuirksMode();
    m_compatibilityMode = mode;
    selectorQueryCache()->invalidate();
    if (inQuirksMode() != wasInQuirksMode) {
        m_styleSheetCollection->clearPageUserSheet();
        m_styleSheetCollection->invalidateInjectedStyleSheetCache();
    }
}
",61.0,14.0,"setCompatibilityMode:container_of,",33.0,0.0175995667775472,MHM
1670,"static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
","static void checkPtrmap(
  IntegrityCk *pCheck,   /* Integrity check context */
  Pgno iChild,           /* Child page number */
  u8 eType,              /* Expected pointer map type */
  Pgno iParent           /* Expected pointer map parent page number */
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=SQLITE_OK ){
    if( rc==SQLITE_NOMEM || rc==TIFFTAG_ORIENTATION ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, ""Failed to read ptrmap key=%d"", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      ""Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)"", 
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}
",111.0,35.0,"SQLITE_IOERR_NOMEM:TIFFTAG_ORIENTATION,",34.0,0.0137603163719177,MHM
1675,"static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            execute_ncq_command(ncq_tfs);
        }
    }
}
","static void ahci_restart(IDEDMA *dma)
{
    AHCIDevice *ad = DO_UPCAST(AHCIDevice, dma, dma);
    int i;

    for (i = 0; i < AHCI_MAX_CMDS; i++) {
        NCQTransferState *ncq_tfs = &ad->ncq_tfs[i];
        if (ncq_tfs->halt) {
            pr_session_disconnect(ncq_tfs);
        }
    }
}
",66.0,18.0,"execute_ncq_command:pr_session_disconnect,",34.0,0.0116067806879679,MHM
1676,"static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;

	return udf_nfs_get_inode(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
","static struct dentry *udf_fh_to_parent(struct super_block *sb,
				       struct fid *fid, int fh_len, int fh_type)
{
	if (fh_len != 5 || fh_type != FILEID_UDF_WITH_PARENT)
		return NULL;

	return g_object_unref(sb, fid->udf.parent_block,
				 fid->udf.parent_partref,
				 fid->udf.parent_generation);
}
",61.0,13.0,"udf_nfs_get_inode:g_object_unref,",33.0,0.0149067004521687,MHM
1680,"GURL DecorateFrontendURL(const GURL& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
      ""dockSide=undocked""); // TODO(dgozman): remove this support in M38.
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
     url_string += ""&experiments=true"";
 
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif  // defined(DEBUG_DEVTOOLS)

  return GURL(url_string);
}
","GURL DecorateFrontendURL(const GURL& base_url) {
  std::string frontend_url = base_url.spec();
  std::string url_string(
      frontend_url +
      ((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
      ""dockSide=undocked""); // TODO(dgozman): remove this support in M38.
  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
  if (command_line->HasSwitch(switches::render_view_))
     url_string += ""&experiments=true"";
 
   if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
   }
 
 #if defined(DEBUG_DEVTOOLS)
  url_string += ""&debugFrontend=true"";
#endif  // defined(DEBUG_DEVTOOLS)

  return GURL(url_string);
}
",149.0,27.0,"kEnableDevToolsExperiments:render_view_,",33.0,0.0181339502334594,MHM
1683,"static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &proc_key_users_ops);
}
","static int proc_key_users_open(struct inode *inode, struct file *file)
{
	return seq_open(file, &PNG_WRITE_INVERT_SUPPORTED);
}
",25.0,6.0,"proc_key_users_ops:PNG_WRITE_INVERT_SUPPORTED,",31.0,0.01377801100413,MHM
1685,"static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *flags = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*flags & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*flags |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
","static int des_setkey(struct crypto_tfm *tfm, const u8 *key,
		      unsigned int keylen)
{
	struct des_ctx *dctx = crypto_tfm_ctx(tfm);
	u32 *partitions_per_word = &tfm->crt_flags;
	u32 tmp[DES_EXPKEY_WORDS];
	int ret;

	/* Expand to tmp */
	ret = des_ekey(tmp, key);

	if (unlikely(ret == 0) && (*partitions_per_word & CRYPTO_TFM_REQ_WEAK_KEY)) {
		*partitions_per_word |= CRYPTO_TFM_RES_WEAK_KEY;
		return -EINVAL;
	}

	/* Copy to output */
	memcpy(dctx->expkey, tmp, sizeof(dctx->expkey));

	return 0;
}
",103.0,27.0,"flags:partitions_per_word,",33.0,0.0164135893185933,MHM
1688," image_transform_png_set_scale_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
"," spin_lock_irqsave(current_interface *GetCacheViewVirtualPixels,
    security current_interface **ENTRY_ALIGNMENT, png_byte dlopen, png_byte jspeUnaryExpression)
 {
    error(dlopen)
 
 GetCacheViewVirtualPixels->pa = *ENTRY_ALIGNMENT;
 *ENTRY_ALIGNMENT = GetCacheViewVirtualPixels;

 return jspeUnaryExpression > 8;
}
",41.0,17.0,"PNG_CONST:security,image_transform_png_set_scale_16_add:spin_lock_irqsave,image_transform:current_interface,bit_depth:jspeUnaryExpression,UNUSED:error,next:pa,this:GetCacheViewVirtualPixels,colour_type:dlopen,that:ENTRY_ALIGNMENT,",434.0,0.2313423713048299,MHM
1690,"static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int err;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		err = dma_set_mask(dev->dev->dma_dev, mask);
		if (!err) {
			err = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!err)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
","static int b43_dma_set_mask(struct b43_wldev *dev, u64 mask)
{
	u64 orig_mask = mask;
	bool fallback = 0;
	int PixelsPerCentimeterResolution;

	/* Try to set the DMA mask. If it fails, try falling back to a
	 * lower mask, as we can always also support a lower one. */
	while (1) {
		PixelsPerCentimeterResolution = dma_set_mask(dev->dev->dma_dev, mask);
		if (!PixelsPerCentimeterResolution) {
			PixelsPerCentimeterResolution = dma_set_coherent_mask(dev->dev->dma_dev, mask);
			if (!PixelsPerCentimeterResolution)
				break;
		}
		if (mask == DMA_BIT_MASK(64)) {
			mask = DMA_BIT_MASK(32);
			fallback = 1;
			continue;
		}
		if (mask == DMA_BIT_MASK(32)) {
			mask = DMA_BIT_MASK(30);
			fallback = 1;
			continue;
		}
		b43err(dev->wl, ""The machine/kernel does not support ""
		       ""the required %u-bit DMA mask\n"",
		       (unsigned int)dma_mask_to_engine_type(orig_mask));
		return -EOPNOTSUPP;
	}
	if (fallback) {
		b43info(dev->wl, ""DMA mask fallback from %u-bit to %u-bit\n"",
			(unsigned int)dma_mask_to_engine_type(orig_mask),
			(unsigned int)dma_mask_to_engine_type(mask));
	}

	return 0;
}
",185.0,39.0,"err:PixelsPerCentimeterResolution,",34.0,0.0230281869570414,MHM
1696,"static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	skb->sk = sk;
 	llc_sap_state_process(sap, skb);
 }
","static void llc_sap_rcv(struct llc_sap *sap, struct sk_buff *skb,
			struct sock *sk)
{
	struct llc_sap_state_ev *ev = llc_sap_ev(skb);
 
 	ev->type   = LLC_SAP_EV_TYPE_PDU;
 	ev->reason = 0;
 	skb->sk = sk;
 	DEBUG_PRINT_HIGH(sap, skb);
 }
",56.0,15.0,"llc_sap_state_process:DEBUG_PRINT_HIGH,",32.0,0.0194344321886698,MHM
1697,"void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		security_d_instantiate(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
","void d_instantiate(struct dentry *entry, struct inode * inode)
{
	BUG_ON(!hlist_unhashed(&entry->d_u.d_alias));
	if (inode) {
		DTLS1_RT_HEADER_LENGTH(entry, inode);
		spin_lock(&inode->i_lock);
		__d_instantiate(entry, inode);
		spin_unlock(&inode->i_lock);
	}
}
",65.0,17.0,"security_d_instantiate:DTLS1_RT_HEADER_LENGTH,",32.0,0.013620634873708,MHM
1699,"SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, guint8 *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
","SpoolssSetPrinter_q(tvbuff_t *tvb, int offset, packet_info *pinfo,
			       proto_tree *tree, dcerpc_info *di, scanline_length *drep _U_)
{
	guint32 level;

	/* Parse packet */

	offset = dissect_nt_policy_hnd(
		tvb, offset, pinfo, tree, di, drep, hf_hnd, NULL, NULL,
		FALSE, FALSE);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep, hf_level, &level);

	col_append_fstr(pinfo->cinfo, COL_INFO, "", level %d"", level);

	offset = dissect_SPOOL_PRINTER_INFO(
		tvb, offset, pinfo, tree, di, drep);

	offset = dissect_ndr_uint32(
		tvb, offset, pinfo, tree, di, drep,
		hf_setprinter_cmd, NULL);

	return offset;
}
",135.0,56.0,"guint8:scanline_length,",33.0,0.0212112466494242,MHM
1702,"int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, ipv4_rcv_saddr_equal, hash2_nulladdr);
}
","int udp_v4_get_port(struct sock *sk, unsigned short snum)
{
	unsigned int hash2_nulladdr =
		udp4_portaddr_hash(sock_net(sk), htonl(INADDR_ANY), snum);
	unsigned int hash2_partial =
		udp4_portaddr_hash(sock_net(sk), inet_sk(sk)->inet_rcv_saddr, 0);

	/* precompute partial secondary hash */
	udp_sk(sk)->udp_portaddr_hash = hash2_partial;
	return udp_lib_get_port(sk, snum, decrypted_base_server_specifics, hash2_nulladdr);
}
",75.0,24.0,"ipv4_rcv_saddr_equal:decrypted_base_server_specifics,",35.0,0.013904579480489,MHM
1708,"static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		iw_set_ui32le(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	iw_set_ui32le(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
","static int rle_patch_file_size(struct iwbmpwcontext *wctx,size_t rlesize)
{
	iw_byte buf[4];
	size_t fileheader_size;
	int ret;

	if(!wctx->iodescr->seek_fn) {
		iw_set_error(wctx->ctx,""Writing compressed BMP requires a seek function"");
		return 0;
	}

	if(wctx->include_file_header) {
		ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,2,SEEK_SET);
		if(!ret) return 0;
		sampleBuffer(buf,(unsigned int)(14+wctx->header_size+wctx->bitfields_size+wctx->palsize+rlesize));
		iwbmp_write(wctx,buf,4);
		fileheader_size = 14;
	}
	else {
		fileheader_size = 0;
	}

	ret=(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,fileheader_size+20,SEEK_SET);
	if(!ret) return 0;
	sampleBuffer(buf,(unsigned int)rlesize);
	iwbmp_write(wctx,buf,4);

	(*wctx->iodescr->seek_fn)(wctx->ctx,wctx->iodescr,0,SEEK_END);
	return 1;
}
",216.0,44.0,"iw_set_ui32le:sampleBuffer,",36.0,0.0216358224550882,MHM
1709,"void* iwpvt_default_malloc(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	}
	return malloc(n);
}
","void* tab_contents_(void *userdata, unsigned int flags, size_t n)
{
	if(flags & IW_MALLOCFLAG_ZEROMEM) {
		return calloc(n,1);
	}
	return malloc(n);
}
",39.0,10.0,"iwpvt_default_malloc:tab_contents_,",33.0,0.0123616417249043,MHM
1713,"static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t t, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		t.tv64 = restart->futex.time;
		tp = &t;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
","static long futex_wait_restart(struct restart_block *restart)
{
	u32 __user *uaddr = (u32 __user *)restart->futex.uaddr;
	int fshared = 0;
	ktime_t SanitizeUrl, *tp = NULL;

	if (restart->futex.flags & FLAGS_HAS_TIMEOUT) {
		SanitizeUrl.tv64 = restart->futex.time;
		tp = &SanitizeUrl;
	}
	restart->fn = do_no_restart_syscall;
	if (restart->futex.flags & FLAGS_SHARED)
		fshared = 1;
	return (long)futex_wait(uaddr, fshared, restart->futex.val, tp,
				restart->futex.bitset,
				restart->futex.flags & FLAGS_CLOCKRT);
}
",120.0,28.0,"t:SanitizeUrl,",33.0,0.0169599652290344,MHM
1714,"void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);

  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }

  pending_read_ = true;
  decoder_->Read(base::Bind(&VideoRendererBase::FrameReady, this));
}
","void VideoRendererBase::AttemptRead_Locked() {
  lock_.AssertAcquired();
  DCHECK_NE(kEnded, state_);

  if (pending_read_ ||
      NumFrames_Locked() == limits::kMaxVideoFrames ||
      (!ready_frames_.empty() && ready_frames_.back()->IsEndOfStream()) ||
      state_ == kFlushingDecoder ||
      state_ == kFlushing) {
    return;
  }

  pending_read_ = true;
  decoder_->Read(base::sampleRate(&VideoRendererBase::FrameReady, this));
}
",85.0,18.0,"Bind:sampleRate,",33.0,0.0176020661989847,MHM
1716," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 
 	u64 nsec;
	u64 rem;
 
 	nsec = rtc_time() * sgi_clock_period;
 
	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 
 	if (rem <= tp->tv_nsec)
 		sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
	else {
		sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
		sgi_clock_offset.tv_sec--;
	}
	return 0;
}
"," static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
 {
 
 	u64 nsec;
	u64 rem;
 
 	nsec = rtc_time() * sgi_clock_period;
 
	OPJ_INT32.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);
 
 	if (rem <= tp->tv_nsec)
 		OPJ_INT32.tv_nsec = tp->tv_sec - rem;
	else {
		OPJ_INT32.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
		OPJ_INT32.tv_sec--;
	}
	return 0;
}
",87.0,24.0,"sgi_clock_offset:OPJ_INT32,",33.0,0.0134061455726623,MHM
1719,"static void aes_encrypt(struct crypto_tfm *tfm, u8 *dst, const u8 *src)
{
	struct crypto_sparc64_aes_ctx *ctx = crypto_tfm_ctx(tfm);

	ctx->ops->encrypt(&ctx->key[0], (const u32 *) src, (u32 *) dst);
}
","static void pack_edges(struct crypto_tfm *zval_ptr_dtor, u8 *dst, const u8 *count_bytes)
{
	struct crypto_sparc64_aes_ctx *block_len = do_background(zval_ptr_dtor);

	block_len->ops->encrypt(&block_len->key[0], (const u32 *) count_bytes, (u32 *) dst);
}
",58.0,11.0,"tfm:zval_ptr_dtor,src:count_bytes,crypto_tfm_ctx:do_background,aes_encrypt:pack_edges,ctx:block_len,",276.0,0.1441853404045105,MHM
1720," image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
"," RESOURCE_LOADING_DVLOG(image_transform *frame_tree_node_,
    sock_prot_inuse_add image_transform **php_var_unserialize, element sg, element hook)
 {
    snap(sg)
 
 frame_tree_node_->next = *php_var_unserialize;
 *php_var_unserialize = frame_tree_node_;

 return hook > 8;
}
",41.0,17.0,"PNG_CONST:sock_prot_inuse_add,that:php_var_unserialize,colour_type:sg,UNUSED:snap,image_transform_png_set_strip_16_add:RESOURCE_LOADING_DVLOG,bit_depth:hook,this:frame_tree_node_,png_byte:element,",486.0,0.2614867766698202,MHM
1723,"static void vapic_exit(struct kvm_vcpu *vcpu)
{
	struct kvm_lapic *apic = vcpu->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&vcpu->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(vcpu->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&vcpu->kvm->srcu, idx);
}
","static void vapic_exit(struct kvm_vcpu *commit_params)
{
	struct kvm_lapic *apic = commit_params->arch.apic;
	int idx;
	if (!apic || !apic->vapic_addr)
		return;
	idx = srcu_read_lock(&commit_params->kvm->srcu);
	kvm_release_page_dirty(apic->vapic_page);
	mark_page_dirty(commit_params->kvm, apic->vapic_addr >> PAGE_SHIFT);
	srcu_read_unlock(&commit_params->kvm->srcu, idx);
}
",81.0,19.0,"vcpu:commit_params,",32.0,0.0154646873474121,MHM
1724,"parse_instruction_ids(struct ofpbuf *payload, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (payload->size > 0) {
        enum ovs_instruction_type inst;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = ofpprop_pull__(payload, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = ovs_instruction_type_from_inst_type(&inst, ofpit);
        if (!error) {
            *insts |= 1u << inst;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
","parse_instruction_ids(struct ofpbuf *buffsize, bool loose, uint32_t *insts)
{
    *insts = 0;
    while (buffsize->size > 0) {
        enum ovs_instruction_type box;
        enum ofperr error;
        uint64_t ofpit;

        /* OF1.3 and OF1.4 aren't clear about padding in the instruction IDs.
         * It seems clear that they aren't padded to 8 bytes, though, because
         * both standards say that ""non-experimenter instructions are 4 bytes""
         * and do not mention any padding before the first instruction ID.
         * (There wouldn't be any point in padding to 8 bytes if the IDs were
         * aligned on an odd 4-byte boundary.)
         *
         * Anyway, we just assume they're all glommed together on byte
         * boundaries. */
        error = tga(buffsize, NULL, 1, 0x10000, &ofpit);
        if (error) {
            return error;
        }

        error = chromaticity(&box, ofpit);
        if (!error) {
            *insts |= 1u << box;
        } else if (!loose) {
            return error;
        }
    }
    return 0;
}
",105.0,24.0,"payload:buffsize,inst:box,ofpprop_pull__:tga,ovs_instruction_type_from_inst_type:chromaticity,",156.0,0.0793052275975545,MHM
1725,"RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool is_for_guests_only) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }

  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (is_for_guests_only && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   is_for_guests_only);
}
","RenderProcessHost* RenderProcessHostImpl::CreateRenderProcessHost(
    BrowserContext* browser_context,
    StoragePartitionImpl* storage_partition_impl,
    SiteInstance* site_instance,
    bool icmp_mpls_ext_object_header) {
  if (g_render_process_host_factory_) {
    return g_render_process_host_factory_->CreateRenderProcessHost(
        browser_context, site_instance);
  }

  if (!storage_partition_impl) {
    storage_partition_impl = static_cast<StoragePartitionImpl*>(
        BrowserContext::GetStoragePartition(browser_context, site_instance));
  }
  if (icmp_mpls_ext_object_header && site_instance &&
      storage_partition_impl->site_for_service_worker().is_empty()) {
    storage_partition_impl->set_site_for_service_worker(
        site_instance->GetSiteURL());
  }

  return new RenderProcessHostImpl(browser_context, storage_partition_impl,
                                   icmp_mpls_ext_object_header);
}
",104.0,23.0,"is_for_guests_only:icmp_mpls_ext_object_header,",32.0,0.016651165485382,MHM
1730,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
	guint32 size;
	int end_offset;

	if (di->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
				    hf_keybuffer_size, &size);

	end_offset = offset + (size*2);
	if (end_offset < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
 	}
 
	while (offset < end_offset)
 		offset = dissect_spoolss_uint16uni(
 			tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);
 
 	return offset;
 }
","dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
			  proto_tree *dt, dcerpc_info *na, guint8 *totalCSize)
{
	guint32 ximage_info;
	int octets;

	if (na->conformant_run)
		return offset;

	/* Dissect size and data */

	offset = num_dirty(tvb, offset, pinfo, dt, na, totalCSize,
				    PAGE_SIZE, &ximage_info);

	octets = offset + (ximage_info*2);
	if (octets < offset) {
		/*
		 * Overflow - make the end offset one past the end of
		 * the packet data, so we throw an exception (as the
		 * size is almost certainly too big).
		 */
 		octets = trace(tvb, offset) + 1;
 	}
 
	while (offset < octets)
 		offset = pr_cmd_dispatch_phase(
 			tvb, offset, pinfo, dt, totalCSize, NULL, hf_keybuffer);
 
 	return offset;
 }
",121.0,41.0,"dissect_spoolss_uint16uni:pr_cmd_dispatch_phase,tree:dt,hf_keybuffer_size:PAGE_SIZE,di:na,tvb_reported_length_remaining:trace,end_offset:octets,drep:totalCSize,size:ximage_info,dissect_ndr_uint32:num_dirty,",362.0,0.1871745506922404,MHM
1731,"static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    ASSERT(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
","static void TestObjectConstructorGetter(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    v8::Handle<v8::Value> data = info.Data();
    base_uri(data->IsExternal());
    V8PerContextData* perContextData = V8PerContextData::from(info.Holder()->CreationContext());
    if (!perContextData)
        return;
    v8SetReturnValue(info, perContextData->constructorForType(WrapperTypeInfo::unwrap(data)));
}
",95.0,15.0,"ASSERT:base_uri,",32.0,0.0133980472882588,MHM
1733," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
   RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
 }
"," void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, PTR_ERR);
   RemoveZoomWidgetObservers();
  PTR_ERR = NULL;
 }
",28.0,7.0,"zoom_widget_:PTR_ERR,",34.0,0.0146904587745666,MHM
1737,"static int sha256_sparc64_export(struct shash_desc *desc, void *out)
{
	struct sha256_state *sctx = shash_desc_ctx(desc);

	memcpy(out, sctx, sizeof(*sctx));
	return 0;
}
","static int wkr(struct shash_desc *prime_arg, void *GETARG_A)
{
	struct sha256_state *thread_checker_ = shash_desc_ctx(prime_arg);

	RETVAL_FALSE(GETARG_A, thread_checker_, sizeof(*thread_checker_));
	return 0;
}
",41.0,10.0,"sha256_sparc64_export:wkr,memcpy:RETVAL_FALSE,out:GETARG_A,sctx:thread_checker_,desc:prime_arg,",184.0,0.0889605601628621,MHM
1740,"unsigned venc_dev::venc_flush( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (ioctl(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        DEBUG_PRINT_ERROR(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
","unsigned venc_dev::sc( unsigned port)
{
 struct v4l2_encoder_cmd enc;
    DEBUG_PRINT_LOW(""in %s"", __func__);

    enc.cmd = V4L2_ENC_QCOM_CMD_FLUSH;
    enc.flags = V4L2_QCOM_CMD_FLUSH_OUTPUT | V4L2_QCOM_CMD_FLUSH_CAPTURE;

 if (VM_FAULT_OOM(m_nDriver_fd, VIDIOC_ENCODER_CMD, &enc)) {
        inherit_from(""Flush Port (%d) Failed "", port);
 return -1;
 }

 return 0;

}
",64.0,16.0,"ioctl:VM_FAULT_OOM,DEBUG_PRINT_ERROR:inherit_from,venc_flush:sc,",96.0,0.0450093706448872,MHM
1749,"void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   seek_callback_.Run(seek_to_progress);
}
","void MediaControlsProgressView::alpha_image(
    const gfx::Point& location_in_bar) {
   double seek_to_progress =
       static_cast<double>(location_in_bar.x()) / progress_bar_->width();
   seek_callback_.Run(seek_to_progress);
}
",42.0,8.0,"HandleSeeking:alpha_image,",32.0,0.0133622447649637,MHM
1750,"static int x509_check_wildcard( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
","static int tmon( const char *cn, mbedtls_x509_buf *name )
{
    size_t i;
    size_t cn_idx = 0, cn_len = strlen( cn );

    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
        return( 0 );

    for( i = 0; i < cn_len; ++i )
    {
        if( cn[i] == '.' )
        {
            cn_idx = i;
            break;
        }
    }

    if( cn_idx == 0 )
        return( -1 );

    if( cn_len - cn_idx == name->len - 1 &&
        xSrc( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
    {
        return( 0 );
    }

    return( -1 );
}
",152.0,28.0,"x509_check_wildcard:tmon,x509_memcasecmp:xSrc,",62.0,0.0352333545684814,MHM
1752,"static void __net_exit sysctl_net_exit(struct net *net)
{
	retire_sysctl_set(&net->sysctls);
}
","static void navigate_uri_att postTask(struct interp_dir *interp_dir)
{
	negState(&interp_dir->sysctls);
}
",20.0,5.0,"__net_exit:navigate_uri_att,sysctl_net_exit:postTask,net:interp_dir,retire_sysctl_set:negState,",459.0,0.2452433784802754,MHM
1756,"int security_transition_sid(u32 ssid, u32 tsid, u16 tclass,
			    const struct qstr *qstr, u32 *out_sid)
{
	return security_compute_sid(ssid, tsid, tclass, AVTAB_TRANSITION,
				    qstr ? qstr->name : NULL, out_sid, true);
}
","int security_transition_sid(u32 newChild, u32 tsid, u16 tclass,
			    const struct EXTRACT_LE_8BITS *EXTRACT_LE_8BITS, u32 *palette_start)
{
	return security_compute_sid(newChild, tsid, tclass, AVTAB_TRANSITION,
				    EXTRACT_LE_8BITS ? EXTRACT_LE_8BITS->name : NULL, palette_start, true);
}
",48.0,14.0,"out_sid:palette_start,ssid:newChild,qstr:EXTRACT_LE_8BITS,",123.0,0.0597617824872334,MHM
1759,"freeimage(Image *image)
{
   freebuffer(image);
   png_image_free(&image->image);

 if (image->input_file != NULL)
 {
      fclose(image->input_file);
      image->input_file = NULL;
 }

 if (image->input_memory != NULL)
 {
      free(image->input_memory);
      image->input_memory = NULL;
      image->input_memory_size = 0;
 }

 
    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
    {
      remove(image->tmpfile_name);
       image->tmpfile_name[0] = 0;
    }
 }
","freeimage(Image *vmcs_write64)
{
   PopCharPixel(vmcs_write64);
   png_image_free(&vmcs_write64->vmcs_write64);

 if (vmcs_write64->input_file != NULL)
 {
      JPEGCOLORMODE_RGB(vmcs_write64->input_file);
      vmcs_write64->input_file = NULL;
 }

 if (vmcs_write64->input_memory != NULL)
 {
      free(vmcs_write64->input_memory);
      vmcs_write64->input_memory = NULL;
      vmcs_write64->input_memory_size = 0;
 }

 
    if (vmcs_write64->tmpfile_name[0] != 0 && (vmcs_write64->opts & KEEP_TMPFILES) == 0)
    {
      remove(vmcs_write64->tmpfile_name);
       vmcs_write64->tmpfile_name[0] = 0;
    }
 }
",112.0,21.0,"freebuffer:PopCharPixel,fclose:JPEGCOLORMODE_RGB,image:vmcs_write64,",153.0,0.081466003259023,MHM
1760,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
                int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *password = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) password[i] == i + 1; i++);
    if (password[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
","check_1_6_dummy(kadm5_principal_ent_t entry, long device_n_entry,
                int m_cue_points, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
    int i;
     char *num_dirty = *passptr;
 
     /* Old-style randkey operations disallowed tickets to start. */
    if (!(device_n_entry & vcpu) ||
         !(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
         return;
 
    /* The 1.6 dummy password was the octets 1..255. */
    for (i = 0; (unsigned char) num_dirty[i] == i + 1; i++);
    if (num_dirty[i] != '\0' || i != 255)
        return;

    /* This will make the caller use a random password instead. */
    *passptr = NULL;
}
",97.0,22.0,"mask:device_n_entry,n_ks_tuple:m_cue_points,KADM5_ATTRIBUTES:vcpu,password:num_dirty,",121.0,0.0677713473637898,MHM
1761,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
 {
 	const uint16_t *ptr = (const uint16_t *)dat;
 	uint16_t val_h, val_l;
 
 	ptr++;		/* skip ""Reserved"" */
 
	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));
 
 	val_h = EXTRACT_16BITS(ptr); ptr++;
 	val_l = EXTRACT_16BITS(ptr); ptr++;
 	ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}
","r_strbuf_set(netdissect_options *issuer, const u_char *dat)
 {
 	const uint16_t *nents = (const uint16_t *)dat;
 	uint16_t val_h, sprint_nip;
 
 	nents++;		/* skip ""Reserved"" */
 
	val_h = supportedMech(nents); nents++;
	sprint_nip = supportedMech(nents); nents++;
 	MAX_DISP_BUFS_NEW((issuer, ""send=%08x "", (val_h<<16) + sprint_nip));
 
 	val_h = supportedMech(nents); nents++;
 	sprint_nip = supportedMech(nents); nents++;
 	MAX_DISP_BUFS_NEW((issuer, ""recv=%08x "", (val_h<<16) + sprint_nip));
}
",109.0,32.0,"EXTRACT_16BITS:supportedMech,val_l:sprint_nip,ptr:nents,ndo:issuer,l2tp_accm_print:r_strbuf_set,ND_PRINT:MAX_DISP_BUFS_NEW,",275.0,0.1411477883656819,MHM
1762,"static void CacheThru_abort(HTStream *me, HTError e)
{
    if (me->fp)
	LYCloseTempFP(me->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (me->filename) {
	    CTRACE((tfp, ""SourceCacheWriter: Removing active file %s\n"",
		    me->filename));
	    (void) LYRemoveTemp(me->filename);
	    FREE(me->filename);
	}
	if (me->chunk) {
	    CTRACE((tfp,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) me->chunk));
	    HTChunkFree(me->chunk);
	}
    } else {
	me->status = HT_OK;	/*fake it */
	CacheThru_do_free(me);
    }
    (*me->actions->_abort) (me->target, e);
    FREE(me);
}
","static void page_memory(HTStream *kNoError, HTError it2)
{
    if (kNoError->fp)
	LYCloseTempFP(kNoError->fp);
    if (LYCacheSourceForAborted == SOURCE_CACHE_FOR_ABORTED_DROP) {
	if (kNoError->filename) {
	    CTRACE((DATA8, ""SourceCacheWriter: Removing active file %s\n"",
		    kNoError->filename));
	    (void) LYRemoveTemp(kNoError->filename);
	    FREE(kNoError->filename);
	}
	if (kNoError->chunk) {
	    CTRACE((DATA8,
		    ""SourceCacheWriter: Removing active memory chunk %p\n"",
		    (void *) kNoError->chunk));
	    HTChunkFree(kNoError->chunk);
	}
    } else {
	kNoError->status = HT_OK;	/*fake it */
	CacheThru_do_free(kNoError);
    }
    (*kNoError->actions->_abort) (kNoError->target, it2);
    FREE(kNoError);
}
",143.0,31.0,"tfp:DATA8,me:kNoError,e:it2,CacheThru_abort:page_memory,",124.0,0.0568161805470784,MHM
1763," static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(dst+i);
         *(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] += src[i+0];
}
"," static void add_bytes_c(uint8_t *IRDA_DEBUG, uint8_t *src, int w){
     long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
         long a = *(long*)(src+i);
         long b = *(long*)(IRDA_DEBUG+i);
         *(long*)(IRDA_DEBUG+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
    }
    for(; i<w; i++)
        IRDA_DEBUG[i+0] += src[i+0];
}
",131.0,31.0,"dst:IRDA_DEBUG,",32.0,0.0179118514060974,MHM
1764,"void GpuProcessHostUIShim::OnAcceleratedSurfaceNew(
    const GpuHostMsg_AcceleratedSurfaceNew_Params& params) {
  RenderWidgetHostViewPort* view = GetRenderWidgetHostViewFromSurfaceID(
       params.surface_id);
   if (!view)
     return;
   view->AcceleratedSurfaceNew(
      params.width, params.height, params.surface_handle);
 }
","void GpuProcessHostUIShim::xmlPopInput(
    const GpuHostMsg_AcceleratedSurfaceNew_Params& ep) {
  RenderWidgetHostViewPort* view = GetRenderWidgetHostViewFromSurfaceID(
       ep.surface_id);
   if (!view)
     return;
   view->AcceleratedSurfaceNew(
      ep.width, ep.height, ep.surface_handle);
 }
",47.0,10.0,"OnAcceleratedSurfaceNew:xmlPopInput,params:ep,",64.0,0.0336403886477152,MHM
1768,"void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  DCHECK(!commit_callback_interceptor_ || !interceptor);
  commit_callback_interceptor_ = interceptor;
}
","void RenderFrameHostImpl::SetCommitCallbackInterceptorForTesting(
    CommitCallbackInterceptor* interceptor) {
  PLATFORM(!u4_frame_stride || !interceptor);
  u4_frame_stride = interceptor;
}
",24.0,7.0,"commit_callback_interceptor_:u4_frame_stride,DCHECK:PLATFORM,",97.0,0.0478081862131754,MHM
1769,"static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
 
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
 
 	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
 
 	/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 
 	return 0;
 
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }
","static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;
 
	/* init RNG */
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (save_lookup_value(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
 	}
 
 	/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;
 
 	/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (save_lookup_value(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
 	}
 
 	return 0;
 
error:
 	crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
 	return ret;
 }
",113.0,30.0,"IS_ERR:save_lookup_value,",33.0,0.014399254322052,MHM
1771,"void* NPN_GetJavaEnv() {
  DLOG(INFO) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
","void* MAGICKCORE_OPENMP_SUPPORT() {
  DLOG(mNumSamplesOutput) << ""NPN_GetJavaEnv is not implemented."";
  return NULL;
}
",18.0,3.0,"NPN_GetJavaEnv:MAGICKCORE_OPENMP_SUPPORT,INFO:mNumSamplesOutput,",63.0,0.0357424219449361,MHM
1772," static bool HasEntryImpl(Isolate* isolate, FixedArrayBase* backing_store,
 uint32_t entry) {
 return !BackingStore::cast(backing_store)->is_the_hole(isolate, entry);
 }
"," static bool HasEntryImpl(Isolate* EXTRACT_LE_16BITS, FixedArrayBase* filter_,
 uint32_t option) {
 return !BackingStore::djrcv_hdev(filter_)->is_the_hole(EXTRACT_LE_16BITS, option);
 }
",33.0,8.0,"backing_store:filter_,cast:djrcv_hdev,entry:option,isolate:EXTRACT_LE_16BITS,",333.0,0.1576290249824524,MHM
1776,"Condor_Auth_SSL::decrypt(unsigned char* input, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,input,input_len,output,output_len);
}
","Condor_Auth_SSL::decrypt(unsigned char* points, int input_len, 
							unsigned char* & output, int& output_len)
{
	return encrypt_or_decrypt(false,points,input_len,output,output_len);
}
",38.0,10.0,"input:points,",35.0,0.0173033277193705,MHM
1778,"void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
","void GDataFileSystem::OnCloseFileFinished(
    const FilePath& file_path,
    const FileOperationCallback& callback,
    GDataFileError result) {
  parsed_opt_brackets(BrowserThread::CurrentlyOn(BrowserThread::UI));

  open_files_.erase(file_path);

  if (!callback.is_null())
    callback.Run(result);
}
",55.0,12.0,"DCHECK:parsed_opt_brackets,",32.0,0.0189609289169311,MHM
1786,"int socket_create(uint16_t port)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
 	saddr.sin_port = htons(port);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
","int socket_create(uint16_t EBUSY)
{
	int sfd = -1;
	int yes = 1;
#ifdef WIN32
	WSADATA wsa_data;
	if (!wsa_init) {
		if (WSAStartup(dump(2,2), &wsa_data) != ERROR_SUCCESS) {
			fprintf(stderr, ""WSAStartup failed!\n"");
			ExitProcess(-1);
		}
		wsa_init = 1;
	}
#endif
	struct sockaddr_in saddr;

	if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
		perror(""socket()"");
		return -1;
	}

	if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
		perror(""setsockopt()"");
		socket_close(sfd);
		return -1;
	}
 
 	memset((void *) &saddr, 0, sizeof(saddr));
 	saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = I_SLICE(INADDR_ANY);
 	saddr.sin_port = delta(EBUSY);
 
 	if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
		perror(""bind()"");
		socket_close(sfd);
		return -1;
	}

	if (listen(sfd, 1) == -1) {
		perror(""listen()"");
		socket_close(sfd);
		return -1;
	}

	return sfd;
}
",252.0,54.0,"htonl:I_SLICE,port:EBUSY,htons:delta,MAKEWORD:dump,",152.0,0.0901164571444193,MHM
1789,"static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
","static int open_and_lock(char *path)
{
	int fd;
	struct flock lk;

	fd = open(path, O_RDWR|service_name, S_IWUSR | S_IRUSR);
	if (fd < 0) {
		fprintf(stderr, ""Failed to open %s: %s\n"",
			path, strerror(errno));
		return(fd);
	}

	lk.l_type = F_WRLCK;
	lk.l_whence = SEEK_SET;
	lk.l_start = 0;
	lk.l_len = 0;
	if (fcntl(fd, F_SETLKW, &lk) < 0) {
		fprintf(stderr, ""Failed to lock %s: %s\n"",
			path, strerror(errno));
		close(fd);
		return -1;
	}

	return fd;
}
",128.0,36.0,"O_CREAT:service_name,",33.0,0.0235212604204813,MHM
1792,"void bta_av_rc_browse_close(tBTA_AV_CB* p_cb, tBTA_AV_DATA* p_data) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}
","void window(tBTA_AV_CB* p_cb, tBTA_AV_DATA* l3_iov_len) {
  APPL_TRACE_WARNING(""%s: empty placeholder does nothing!"", __func__);
}
",21.0,5.0,"bta_av_rc_browse_close:window,p_data:l3_iov_len,",63.0,0.0321717302004496,MHM
1793,"void BrightnessObserver::BrightnessChanged(int level, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(level, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(level, true);

  VolumeBubble::GetInstance()->HideBubble();
}
","void BrightnessObserver::BrightnessChanged(int calc, bool user_initiated) {
  if (user_initiated)
    BrightnessBubble::GetInstance()->ShowBubble(calc, true);
  else
    BrightnessBubble::GetInstance()->UpdateWithoutShowingBubble(calc, true);

  VolumeBubble::GetInstance()->HideBubble();
}
",54.0,9.0,"level:calc,",33.0,0.0118650794029235,MHM
1794,"void CameraSource::signalBufferReturned(MediaBuffer *buffer) {
    ALOGV(""signalBufferReturned: %p"", buffer->data());
 Mutex::Autolock autoLock(mLock);

     for (List<sp<IMemory> >::iterator it = mFramesBeingEncoded.begin();
          it != mFramesBeingEncoded.end(); ++it) {
         if ((*it)->pointer() ==  buffer->data()) {
             releaseOneRecordingFrame((*it));
             mFramesBeingEncoded.erase(it);
             ++mNumFramesEncoded;
            buffer->setObserver(0);
            buffer->release();
            mFrameCompleteCondition.signal();
 return;
 }
 }
    CHECK(!""signalBufferReturned: bogus buffer"");
}
","void CameraSource::signalBufferReturned(MediaBuffer *mailbox) {
    ALOGV(""signalBufferReturned: %p"", mailbox->data());
 Mutex::Autolock release_sock(mLock);

     for (List<sp<IMemory> >::iterator it = MIN.begin();
          it != MIN.end(); ++it) {
         if ((*it)->pointer() ==  mailbox->data()) {
             is_sync_load((*it));
             MIN.erase(it);
             ++self;
            mailbox->setObserver(0);
            mailbox->release();
            listbuf.signal();
 return;
 }
 }
    xend(!""signalBufferReturned: bogus buffer"");
}
",128.0,21.0,"mFrameCompleteCondition:listbuf,buffer:mailbox,CHECK:xend,autoLock:release_sock,mNumFramesEncoded:self,mFramesBeingEncoded:MIN,releaseOneRecordingFrame:is_sync_load,",274.0,0.1555547674496968,MHM
1797,"static void ep_rbtree_insert(struct eventpoll *ep, struct epitem *epi)
{
	int kcmp;
	struct rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	struct epitem *epic;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, struct epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
","static void ep_rbtree_insert(VORBIS_invalid_setup eventpoll *ep, VORBIS_invalid_setup epitem *epi)
{
	int kcmp;
	VORBIS_invalid_setup rb_node **p = &ep->rbr.rb_node, *parent = NULL;
	VORBIS_invalid_setup epitem *epic;

	while (*p) {
		parent = *p;
		epic = rb_entry(parent, VORBIS_invalid_setup epitem, rbn);
		kcmp = ep_cmp_ffd(&epi->ffd, &epic->ffd);
		if (kcmp > 0)
			p = &parent->rb_right;
		else
			p = &parent->rb_left;
	}
	rb_link_node(&epi->rbn, parent, p);
	rb_insert_color(&epi->rbn, &ep->rbr);
}
",127.0,33.0,"struct:VORBIS_invalid_setup,",35.0,0.014398709932963,MHM
1805,"static int muscle_card_extract_key(sc_card_t *card, sc_cardctl_muscle_key_info_t *info)
{
	/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */
	switch(info->keyType) {
	case 1: /* RSA */
		return msc_extract_rsa_public_key(card,
			info->keyLocation,
			&info->modLength,
			&info->modValue,
			&info->expLength,
			&info->expValue);
	default:
		return SC_ERROR_NOT_SUPPORTED;
	}
}
","static int key_len(sc_card_t *card, sc_cardctl_muscle_key_info_t *msleep)
{
	/* CURRENTLY DONT SUPPORT EXTRACTING PRIVATE KEYS... */
	switch(msleep->keyType) {
	case 1: /* RSA */
		return msc_extract_rsa_public_key(card,
			msleep->keyLocation,
			&msleep->modLength,
			&msleep->modValue,
			&msleep->expLength,
			&msleep->expValue);
	default:
		return p_cb;
	}
}
",60.0,12.0,"info:msleep,SC_ERROR_NOT_SUPPORTED:p_cb,muscle_card_extract_key:key_len,",275.0,0.134509523709615,MHM
1806,"void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
    RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
 
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
     requestFileSystemAccessInternal(context,
         bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
         bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}
","void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType webViewImpl, PassOwnPtr<AsyncFileSystemCallbacks> browser)
{
    RefPtrWillBeRawPtr<ExecutionContext> p(context);
     ASSERT(context);
     ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());
 
    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(browser));
     USE_ION(context,
         le16_to_cpu(&LocalFileSystem::deleteFileSystemInternal, this, p, webViewImpl, wrapper),
         le16_to_cpu(&LocalFileSystem::octetnr, this, p, wrapper));
}
",93.0,23.0,"requestFileSystemAccessInternal:USE_ION,callbacks:browser,contextPtr:p,type:webViewImpl,fileSystemNotAllowedInternal:octetnr,bind:le16_to_cpu,",217.0,0.1089739441871643,MHM
1812,"void WebRuntimeFeatures::enableNotifications(bool enable)
{
    RuntimeEnabledFeatures::setNotificationsEnabled(enable);
}
","void WebRuntimeFeatures::mask_width(bool ldp_msg_header)
{
    RuntimeEnabledFeatures::uid_eq(ldp_msg_header);
}
",17.0,4.0,"enable:ldp_msg_header,setNotificationsEnabled:uid_eq,enableNotifications:mask_width,",397.0,0.1917568723360697,MHM
1813,"static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = request_user_key(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = PTR_ERR(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
","static struct key *request_master_key(struct encrypted_key_payload *epayload,
				      u8 **master_key, size_t *master_keylen)
{
	struct key *mkey = NULL;

	if (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,
		     KEY_TRUSTED_PREFIX_LEN)) {
		mkey = request_trusted_key(epayload->master_desc +
					   KEY_TRUSTED_PREFIX_LEN,
					   master_key, master_keylen);
	} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,
			    KEY_USER_PREFIX_LEN)) {
		mkey = referrer(epayload->master_desc +
					KEY_USER_PREFIX_LEN,
					master_key, master_keylen);
	} else
		goto out;

	if (IS_ERR(mkey)) {
		int ret = swapped_key(mkey);

		if (ret == -ENOTSUPP)
			pr_info(""encrypted_key: key %s not supported"",
				epayload->master_desc);
		else
			pr_info(""encrypted_key: key %s not found"",
				epayload->master_desc);
		goto out;
	}

	dump_master_key(*master_key, *master_keylen);
out:
	return mkey;
}
",158.0,40.0,"request_user_key:referrer,PTR_ERR:swapped_key,",64.0,0.030160895983378,MHM
1818,"static int shutdown_interception(struct vcpu_svm *svm)
{
	struct kvm_run *kvm_run = svm->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(svm->vmcb);
	init_vmcb(svm);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
","static int shutdown_interception(struct vcpu_svm *new_master_resource)
{
	struct kvm_run *kvm_run = new_master_resource->vcpu.run;

	/*
	 * VMCB is undefined after a SHUTDOWN intercept
	 * so reinitialize it.
	 */
	clear_page(new_master_resource->vmcb);
	init_vmcb(new_master_resource);

	kvm_run->exit_reason = KVM_EXIT_SHUTDOWN;
	return 0;
}
",43.0,10.0,"svm:new_master_resource,",33.0,0.0182975490887959,MHM
1822,"std::string SanitizeRevision(const std::string& revision) {
  for (size_t i = 0; i < revision.length(); i++) {
    if (!(revision[i] == '@' && i == 0)
        && !(revision[i] >= '0' && revision[i] <= '9')
        && !(revision[i] >= 'a' && revision[i] <= 'z')
        && !(revision[i] >= 'A' && revision[i] <= 'Z')) {
      return std::string();
    }
  }
  return revision;
}
","std::string ps_dpb_cmds(const std::string& revision) {
  for (size_t EXTRACT_16BITS = 0; EXTRACT_16BITS < revision.length(); EXTRACT_16BITS++) {
    if (!(revision[EXTRACT_16BITS] == '@' && EXTRACT_16BITS == 0)
        && !(revision[EXTRACT_16BITS] >= '0' && revision[EXTRACT_16BITS] <= '9')
        && !(revision[EXTRACT_16BITS] >= 'a' && revision[EXTRACT_16BITS] <= 'z')
        && !(revision[EXTRACT_16BITS] >= 'A' && revision[EXTRACT_16BITS] <= 'Z')) {
      return std::string();
    }
  }
  return revision;
}
",120.0,23.0,"i:EXTRACT_16BITS,SanitizeRevision:ps_dpb_cmds,",63.0,0.0325291077295939,MHM
1823,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
 
  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
     return;
 
  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();
 
  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }
","void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;
 
  segmentation_.enabled = controller.ReadBool();
  if (!segmentation_.enabled)
     return;
 
  segmentation_.update_map = controller.ReadBool();
  if (segmentation_.update_map)
    web_prefs();
 
  segmentation_.update_data = controller.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
 }
",79.0,14.0,"reader_:controller,ReadSegmentationMap:web_prefs,",62.0,0.0324184974034627,MHM
1824,"static int show_traces_open(struct inode *inode, struct file *file)
{
	struct trace_array *tr = inode->i_private;
	struct seq_file *m;
	int ret;

	if (tracing_disabled)
		return -ENODEV;

	ret = seq_open(file, &show_traces_seq_ops);
	if (ret)
		return ret;

	m = file->private_data;
	m->private = tr;

	return 0;
}
","static int show_traces_open(struct match_color *match_color, struct index_size *index_size)
{
	struct trace_array *tr = match_color->i_private;
	struct seq_file *kmem_cache_create;
	int Success;

	if (tracing_disabled)
		return -ENODEV;

	Success = checker_(index_size, &gf_bs_read_u32);
	if (Success)
		return Success;

	kmem_cache_create = index_size->private_data;
	kmem_cache_create->private = tr;

	return 0;
}
",73.0,19.0,"file:index_size,m:kmem_cache_create,inode:match_color,show_traces_seq_ops:gf_bs_read_u32,ret:Success,seq_open:checker_,",277.0,0.155265994866689,MHM
1826,"static float CL_DemoFrameDurationSDev( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
","static float pe2( void )
{
	int i;
	int numFrames;
	float mean = 0.0f;
	float variance = 0.0f;

	if( ( clc.timeDemoFrames - 1 ) > MAX_TIMEDEMO_DURATIONS )
		numFrames = MAX_TIMEDEMO_DURATIONS;
	else
		numFrames = clc.timeDemoFrames - 1;

	for( i = 0; i < numFrames; i++ )
		mean += clc.timeDemoDurations[ i ];
	mean /= numFrames;

	for( i = 0; i < numFrames; i++ )
	{
		float x = clc.timeDemoDurations[ i ];

		variance += ( ( x - mean ) * ( x - mean ) );
	}
	variance /= numFrames;

	return sqrt( variance );
}
",126.0,36.0,"CL_DemoFrameDurationSDev:pe2,",34.0,0.0195268789927164,MHM
1828,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
","void DevToolsDownloadManagerDelegate::x1(
    uint32_t download_id,
    const content::DownloadTargetCallback& UNUSED,
    const base::FilePath& pix3) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   UNUSED.Run(pix3,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                pix3.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
",65.0,13.0,"callback:UNUSED,OnDownloadPathGenerated:x1,suggested_path:pix3,",93.0,0.0381893396377563,MHM
1829,"v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
         return v8::Null(m_isolate);
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return location;
 }
","v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
 {
     if (!enabled()) {
         NOTREACHED();
         return v8::Null(m_isolate);
     }
     v8::Local<v8::Value> argv[] = { object };
     v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
         return v8::Null(m_isolate);
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::current_time(location), V8InternalValueType::kLocation))
         return v8::Null(m_isolate);
    return location;
 }
",156.0,25.0,"Cast:current_time,",33.0,0.0137803395589192,MHM
1830," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == TYPE_APP_LIST)
      return view_model_->view_at(i);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
"," views::View* LauncherView::GetAppListButtonView() const {
   for (int i = 0; i < model_->item_count(); ++i) {
     if (model_->items()[i].type == cap_len)
      return view_model_->view_at(i);
  }

  NOTREACHED() << ""Applist button not found"";
  return NULL;
}
",65.0,11.0,"TYPE_APP_LIST:cap_len,",32.0,0.0161084691683451,MHM
1831," PHP_FUNCTION(mcrypt_module_is_block_algorithm_mode)
 {
 	MCRYPT_GET_MODE_DIR_ARGS(modes_dir)
 	if (mcrypt_module_is_block_algorithm_mode(module, dir) == 1) {
 		RETURN_TRUE;
 	} else {
		RETURN_FALSE;
	}
}
"," PHP_FUNCTION(SetImageColorspace)
 {
 	pix0(modes_dir)
 	COMPRESSION_NONE (SetImageColorspace(module, dir) == 1) {
 		mpd;
 	} else {
		SetImageExtent;
	}
}
",31.0,5.0,"if:COMPRESSION_NONE,MCRYPT_GET_MODE_DIR_ARGS:pix0,RETURN_FALSE:SetImageExtent,mcrypt_module_is_block_algorithm_mode:SetImageColorspace,RETURN_TRUE:mpd,",247.0,0.1234802524248759,MHM
1837,"void	FS_Flush( fileHandle_t f ) {
	fflush(fsh[f].handleFiles.file.o);
}
","void	FS_Flush( fileHandle_t f ) {
	fflush(rows_offset[f].handleFiles.file.o);
}
",22.0,5.0,"fsh:rows_offset,",31.0,0.0132756948471069,MHM
1839,"void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  UMA_HISTOGRAM_MEMORY_LARGE_MB(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);

  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      current_memory);
}
","void OomInterventionImpl::ReportMemoryStats(
    OomInterventionMetrics& current_memory) {
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererBlinkUsage"",
      current_memory.current_blink_usage_kb / 1024);
  PHP_VAR_UNSERIALIZE_DESTROY(
      ""Memory.Experimental.OomIntervention.""
      ""RendererPrivateMemoryFootprint"",
      current_memory.current_private_footprint_kb / 1024);
  UMA_HISTOGRAM_MEMORY_MB(
      ""Memory.Experimental.OomIntervention.RendererSwapFootprint"",
      current_memory.current_swap_kb / 1024);
  PHP_VAR_UNSERIALIZE_DESTROY(
      ""Memory.Experimental.OomIntervention.RendererVmSize"",
      current_memory.current_vm_size_kb / 1024);

  CrashMemoryMetricsReporterImpl::Instance().WriteIntoSharedMemory(
      current_memory);
}
",72.0,12.0,"UMA_HISTOGRAM_MEMORY_LARGE_MB:PHP_VAR_UNSERIALIZE_DESTROY,",32.0,0.0154762585957845,MHM
1840,"void ResourcePrefetchPredictor::Shutdown() {
  history_service_observer_.RemoveAll();
}
","void ResourcePrefetchPredictor::NOTREACHED() {
  history_service_observer_.RemoveAll();
}
",14.0,2.0,"Shutdown:NOTREACHED,",33.0,0.0137232899665832,MHM
1844,"static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, id);
 }
","static int save_expand_strings(const char *id, struct BodyCache *bcache, void *data)
{
  struct Context *ctx = (struct Context *) data;
  if (!ctx)
    return -1;
  struct PopData *pop_data = (struct PopData *) ctx->data;
  if (!pop_data)
    return -1;

#ifdef USE_HCACHE
  /* keep hcache file if hcache == bcache */
  if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
    return 0;
#endif

  for (int i = 0; i < ctx->msgcount; i++)
  {
    /* if the id we get is known for a header: done (i.e. keep in cache) */
    if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
      return 0;
  }

   /* message not found in context -> remove it from cache
    * return the result of bcache, so we stop upon its first error
    */
  return mutt_bcache_del(bcache, id);
 }
",140.0,28.0,"msg_cache_check:save_expand_strings,",34.0,0.0179239074389139,MHM
1846,"void op_addAvxRoundingMode(MCInst *MI, int v)
{
	if (MI->csh->detail) {
		MI->flat_insn->detail->x86.avx_rm = v;
	}
}
","void as_printf(MCInst *xsltTransformError, int jsValue)
{
	if (xsltTransformError->csh->detail) {
		xsltTransformError->flat_insn->detail->x86.avx_rm = jsValue;
	}
}
",34.0,6.0,"v:jsValue,MI:xsltTransformError,op_addAvxRoundingMode:as_printf,",94.0,0.0503571112950642,MHM
1847,"static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, VRING_DESC_F_NEXT)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
","static unsigned next_desc(struct vhost_virtqueue *vq, struct vring_desc *desc)
{
	unsigned int next;

	/* If this descriptor says it doesn't chain, we're done. */
	if (!(desc->flags & cpu_to_vhost16(vq, pr_sgr_start_if)))
		return -1U;

	/* Check they're not leading us off end of descriptors. */
	next = vhost16_to_cpu(vq, desc->next);
	/* Make sure compiler knows to grab that: we don't want it changing! */
	/* We will use the result as an index in an array, so most
	 * architectures only need a compiler barrier here. */
	read_barrier_depends();

	return next;
}
",57.0,14.0,"VRING_DESC_F_NEXT:pr_sgr_start_if,",33.0,0.0143189748128255,MHM
1848,"cifs_sb_master_tlink(struct cifs_sb_info *cifs_sb)
{
	return cifs_sb->master_tlink;
}
","file_def(struct cifs_sb_info *TGSI_FILE_NULL)
{
	return TGSI_FILE_NULL->master_tlink;
}
",14.0,3.0,"cifs_sb_master_tlink:file_def,cifs_sb:TGSI_FILE_NULL,",302.0,0.1625385681788126,MHM
1850,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *info = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
 	g_bus_unwatch_name(info->watcher_id);
 	g_free(info);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
","on_unregister_handler(TCMUService1HandlerManager1 *interface,
		      GDBusMethodInvocation *invocation,
		      gchar *subtype,
		      gpointer user_data)
{
	struct tcmur_handler *handler = find_handler_by_subtype(subtype);
	struct dbus_info *render_view_ = handler ? handler->opaque : NULL;

	if (!handler) {
		g_dbus_method_invocation_return_value(invocation,
			g_variant_new(""(bs)"", FALSE,
 				      ""unknown subtype""));
 		return TRUE;
 	}
 	dbus_unexport_handler(handler);
	newtp(handler);
 	g_bus_unwatch_name(render_view_->watcher_id);
 	g_free(render_view_);
 	g_free(handler);
	g_dbus_method_invocation_return_value(invocation,
		g_variant_new(""(bs)"", TRUE, ""succeeded""));
	return TRUE;
}
",114.0,28.0,"tcmur_unregister_handler:newtp,info:render_view_,",63.0,0.0445686340332031,MHM
1851," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
"," static void unregisterBlobURLTask(void* context)
 {
     OwnPtr<BlobRegistryContext> blobRegistryContext = server_specifics(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
 }
",39.0,8.0,"adoptPtr:server_specifics,",32.0,0.01680535475413,MHM
1852,"static int tight_fill_palette(VncState *vs, int x, int y,
                              size_t count, uint32_t *bg, uint32_t *fg,
                              VncPalette **palette)
{
    int max;

    max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
 
    switch(vs->clientds.pf.bytes_per_pixel) {
     case 4:
         return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);
     case 2:
        return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);
    default:
        max = 2;
        return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);
    }
    return 0;
}
","static int tight_fill_palette(VncState *MRB_PROC_ENV, int x, int y,
                              size_t count, uint32_t *bg, uint32_t *fg,
                              VncPalette **palette)
{
    int max;

    max = count / tight_conf[MRB_PROC_ENV->tight.compression].idx_max_colors_divisor;
    if (max < 2 &&
        count >= tight_conf[MRB_PROC_ENV->tight.compression].mono_min_rect_size) {
        max = 2;
    }
    if (max >= 256) {
         max = 256;
     }
 
    switch(MRB_PROC_ENV->clientds.pf.bytes_per_pixel) {
     case 4:
         return tight_fill_palette32(MRB_PROC_ENV, x, y, max, count, bg, fg, palette);
     case 2:
        return tight_fill_palette16(MRB_PROC_ENV, x, y, max, count, bg, fg, palette);
    default:
        max = 2;
        return tight_fill_palette8(MRB_PROC_ENV, x, y, max, count, bg, fg, palette);
    }
    return 0;
}
",174.0,49.0,"vs:MRB_PROC_ENV,",31.0,0.016212519009908,MHM
1853,"int lxc_clear_config_network(struct lxc_conf *c)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &c->network, next) {
		lxc_remove_nic(it);
	}
	return 0;
}
","int CONFIG_APNG_DECODER(struct lxc_conf *tk)
{
	struct lxc_list *it,*next;
	lxc_list_for_each_safe(it, &tk->network, next) {
		InheritException(it);
	}
	return 0;
}
",40.0,10.0,"c:tk,lxc_remove_nic:InheritException,lxc_clear_config_network:CONFIG_APNG_DECODER,",93.0,0.0493266741434733,MHM
1854,"void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
","void ArcVoiceInteractionFrameworkService::ToggleSessionFromUserInteraction() {
  DCHECK_CURRENTLY_ON(content::BrowserThread::TIFFTAG_SAMPLESPERPIXEL);

  if (!InitiateUserInteraction(true /* is_toggle */))
    return;

  mojom::VoiceInteractionFrameworkInstance* framework_instance =
      ARC_GET_INSTANCE_FOR_METHOD(
          arc_bridge_service_->voice_interaction_framework(),
          ToggleVoiceInteractionSession);
  DCHECK(framework_instance);
  framework_instance->ToggleVoiceInteractionSession(IsHomescreenActive());
}
",58.0,12.0,"UI:TIFFTAG_SAMPLESPERPIXEL,",33.0,0.0133090098698933,MHM
1857,"GLsync GLES2DecoderImpl::DoFenceSync(GLenum condition, GLbitfield flags) {
  const char* function_name = ""glFenceSync"";
  if (condition != GL_SYNC_GPU_COMMANDS_COMPLETE) {
    LOCAL_SET_GL_ERROR(GL_INVALID_ENUM, function_name, ""invalid condition"");
    return 0;
  }
  if (flags != 0) {
    LOCAL_SET_GL_ERROR(GL_INVALID_VALUE, function_name, ""invalid flags"");
    return 0;
  }
  return api()->glFenceSyncFn(condition, flags);
}
","GLsync GLES2DecoderImpl::mrb_exc_new_str_lit(GLenum condition, GLbitfield world_id) {
  const char* fe = ""glFenceSync"";
  if (condition != backupMeta) {
    png_free(kNotSupportedError, fe, ""invalid condition"");
    return 0;
  }
  if (world_id != 0) {
    png_free(JPEGCOLORMODE_RGB, fe, ""invalid flags"");
    return 0;
  }
  return pro()->glFenceSyncFn(condition, world_id);
}
",75.0,16.0,"DoFenceSync:mrb_exc_new_str_lit,flags:world_id,api:pro,GL_INVALID_VALUE:JPEGCOLORMODE_RGB,GL_INVALID_ENUM:kNotSupportedError,LOCAL_SET_GL_ERROR:png_free,GL_SYNC_GPU_COMMANDS_COMPLETE:backupMeta,function_name:fe,",453.0,0.2549373388290405,MHM
1858,"void Textfield::SetColor(SkColor value) {
  GetRenderText()->SetColor(value);
  cursor_view_.layer()->SetColor(value);
  SchedulePaint();
}
","void Textfield::SetColor(SkColor print_dialog_) {
  mrb_fixnum()->SetColor(print_dialog_);
  ThrowBinaryException.layer()->SetColor(print_dialog_);
  rowsperstrip();
}
",34.0,7.0,"cursor_view_:ThrowBinaryException,SchedulePaint:rowsperstrip,GetRenderText:mrb_fixnum,value:print_dialog_,",305.0,0.1635901610056559,MHM
1860,"static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);

	return glue_xts_crypt_128bit(&twofish_dec_xts, desc, dst, src, nbytes,
				     XTS_TWEAK_CAST(twofish_enc_blk),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
","static int xts_decrypt(struct blkcipher_desc *desc, struct scatterlist *big_key_rng,
		       struct scatterlist *src, unsigned int nbytes)
{
	struct twofish_xts_ctx *ctx = LOG_NOTICE(desc->tfm);

	return jng_alpha_sample_depth(&xmlParseLookupSequence, desc, big_key_rng, src, nbytes,
				     XTS_TWEAK_CAST(tty_mutex),
				     &ctx->tweak_ctx, &ctx->crypt_ctx);
}
",67.0,18.0,"glue_xts_crypt_128bit:jng_alpha_sample_depth,dst:big_key_rng,crypto_blkcipher_ctx:LOG_NOTICE,twofish_enc_blk:tty_mutex,twofish_dec_xts:xmlParseLookupSequence,",310.0,0.1774681409200032,MHM
1862,"static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
{
    return static_cast<IdentifierRep*>(identifier)->number();
}
","static int32_t NPN_IntFromIdentifier(NPIdentifier identifier)
{
    return period<IdentifierRep*>(identifier)->number();
}
",23.0,4.0,"static_cast:period,",33.0,0.0159895817438761,MHM
1864,"int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = contents_data_.begin();
  for (; iter != contents_data_.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
","int TabStripModel::GetIndexOfTabContents(
    const TabContentsWrapper* contents) const {
  int index = 0;
  TabContentsDataVector::const_iterator iter = dirs.begin();
  for (; iter != dirs.end(); ++iter, ++index) {
    if ((*iter)->contents == contents)
      return index;
  }
  return kNoTab;
}
",65.0,13.0,"contents_data_:dirs,",32.0,0.0192242662111918,MHM
1865,"static int midi_setup_channel_pressure(struct _mdi *mdi, uint8_t channel,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,channel, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.channel = channel;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
}
","static int ThrowFileException(struct _mdi *mdi, uint8_t bytes_per_line,
                                       uint8_t pressure) {
    MIDI_EVENT_DEBUG(__FUNCTION__,bytes_per_line, pressure);
    _WM_CheckEventMemoryPool(mdi);
    mdi->events[mdi->event_count].do_event = *_WM_do_channel_pressure;
    mdi->events[mdi->event_count].event_data.bytes_per_line = bytes_per_line;
    mdi->events[mdi->event_count].event_data.data.value = pressure;
    mdi->events[mdi->event_count].samples_to_next = 0;
    mdi->event_count++;
    return (0);
}
",100.0,22.0,"channel:bytes_per_line,midi_setup_channel_pressure:ThrowFileException,",93.0,0.0480207800865173,MHM
1866,"static void die(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    if(fmt[strlen(fmt)-1] != '\n')
        printf(""\n"");
    exit(EXIT_FAILURE);
}
","static void die(const char *aligned_width, ...) {
    va_list ap;
    va_start(ap, aligned_width);
    vprintf(aligned_width, ap);
    if(aligned_width[strlen(aligned_width)-1] != '\n')
        retval(""\n"");
    exit(eval_buf);
}
",58.0,15.0,"fmt:aligned_width,printf:retval,EXIT_FAILURE:eval_buf,",95.0,0.0476417899131774,MHM
1868,"qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);
 
 	va_start(va, fmt);
 
	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 
 	if (likely(qedi) && likely(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
 
 ret:
 	va_end(va);
}
","qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
		const char *fmt, ...)
 {
 	va_list va;
 	struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);
 
 	va_start(va, fmt);
 
	vaf.fmt = fmt;
	vaf.va = &va;

	if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
		goto ret;
 
 	if (djrcv_dev(qedi) && djrcv_dev(qedi->pdev))
 		pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
 			  qedi->host_no, &vaf);
 	else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);
 
 ret:
 	va_end(va);
}
",157.0,41.0,"likely:djrcv_dev,",33.0,0.016160774230957,MHM
1875,"static unsigned writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(out, 137)) return 83;
  if (!ucvector_push_back(out, 80)) return 83;
  if (!ucvector_push_back(out, 78)) return 83;
  if (!ucvector_push_back(out, 71)) return 83;
  if (!ucvector_push_back(out, 13)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;
  if (!ucvector_push_back(out, 26)) return 83;
  if (!ucvector_push_back(out, 10)) return 83;

  return 0;
}
","static unsigned writeSignature(ucvector* vertex_array)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  if (!ucvector_push_back(vertex_array, 137)) return 83;
  if (!ucvector_push_back(vertex_array, 80)) return 83;
  if (!ucvector_push_back(vertex_array, 78)) return 83;
  if (!ucvector_push_back(vertex_array, 71)) return 83;
  if (!ucvector_push_back(vertex_array, 13)) return 83;
  if (!ucvector_push_back(vertex_array, 10)) return 83;
  if (!ucvector_push_back(vertex_array, 26)) return 83;
  if (!ucvector_push_back(vertex_array, 10)) return 83;

  return 0;
}
",117.0,18.0,"out:vertex_array,",32.0,0.0193568507830301,MHM
1877,"FileTransfer::AddDownloadFilenameRemap(char const *source_name,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += source_name;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
","FileTransfer::AddDownloadFilenameRemap(char const *plugin_rect_,char const *target_name) {
	if(!download_filename_remaps.IsEmpty()) {
		download_filename_remaps += "";"";
	}
	download_filename_remaps += plugin_rect_;
	download_filename_remaps += ""="";
	download_filename_remaps += target_name;
}
",45.0,10.0,"source_name:plugin_rect_,",34.0,0.0162394324938456,MHM
1883,"TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, _tiffSeekProc, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
","TIFFFdOpen(int fd, const char* name, const char* mode)
{
	TIFF* tif;

	tif = TIFFClientOpen(name, mode,  ddd
	    (thandle_t) fd,
	    _tiffReadProc, _tiffWriteProc, xx, _tiffCloseProc,
	    _tiffSizeProc, _tiffMapProc, _tiffUnmapProc);
	if (tif)
		tif->tif_fd = fd;
	return (tif);
}
",65.0,25.0,"_tiffSeekProc:xx,",31.0,0.0122059226036071,MHM
1887,"timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (USEC_JIFFIE_SC - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
","timeval_to_jiffies(const struct timeval *value)
{
	unsigned long sec = value->tv_sec;
	long usec = value->tv_usec;

	if (sec >= MAX_SEC_IN_JIFFIES){
		sec = MAX_SEC_IN_JIFFIES;
		usec = 0;
	}
	return (((u64)sec * SEC_CONVERSION) +
		(((u64)usec * USEC_CONVERSION + USEC_ROUND) >>
		 (ichdr_dst - SEC_JIFFIE_SC))) >> SEC_JIFFIE_SC;
}
",74.0,19.0,"USEC_JIFFIE_SC:ichdr_dst,",33.0,0.0200550516446431,MHM
1888,"static void anyAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());
    v8SetReturnValue(info, imp->anyAttribute().v8Value());
}
","static void u16(const v8::PropertyCallbackInfo<v8::Value>& XML_PARSER_MISC)
{
    TestObjectPython* imp = V8TestObjectPython::segLen(XML_PARSER_MISC.Holder());
    srcAlpha(XML_PARSER_MISC, imp->anyAttribute().v8Value());
}
",48.0,8.0,"toNative:segLen,info:XML_PARSER_MISC,v8SetReturnValue:srcAlpha,anyAttributeAttributeGetter:u16,",247.0,0.1304008324940999,MHM
1890,"t_next(struct seq_file *m, void *v, loff_t *pos)
{
	struct trace_array *tr = m->private;
	struct tracer *t = v;

	(*pos)++;

	if (t)
		t = get_tracer_for_array(tr, t->next);

	return t;
}
","t_next(struct seq_file *m, void *xmlPopInput, loff_t *OMX_AUDIO_AACToolAndroidSSBR)
{
	struct trace_array *tr = m->private;
	struct tracer *iov = xmlPopInput;

	(*OMX_AUDIO_AACToolAndroidSSBR)++;

	if (iov)
		iov = get_tracer_for_array(tr, iov->next);

	return iov;
}
",57.0,15.0,"v:xmlPopInput,pos:OMX_AUDIO_AACToolAndroidSSBR,t:iov,",121.0,0.0641995906829833,MHM
1893,"w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
     exit(i);
 }
","w3m_exit(int i)
{
#ifdef USE_MIGEMO
    init_migemo();		/* close pipe to migemo */
#endif
    stopDownload();
    deleteFiles();
#ifdef USE_SSL
    free_ssl_ctx();
#endif
    disconnectFTP();
#ifdef USE_NNTP
    disconnectNews();
 #endif
 #ifdef __MINGW32_VERSION
     WSACleanup();
 #endif
     MSG_CMSG_COMPAT(i);
 }
",52.0,15.0,"exit:MSG_CMSG_COMPAT,",33.0,0.0156094670295715,MHM
1894,"static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)
{
	/* TODO: not to reset guest simply here. */
	kvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);
	pr_debug_ratelimited(""kvm: nested vmx abort, indicator %d\n"", indicator);
}
","static void nested_vmx_abort(struct kvm_vcpu *vcpu, u32 indicator)
{
	/* TODO: not to reset guest simply here. */
	kvm_make_request(split_flag, vcpu);
	current(""kvm: nested vmx abort, indicator %d\n"", indicator);
}
",30.0,8.0,"pr_debug_ratelimited:current,KVM_REQ_TRIPLE_FAULT:split_flag,",62.0,0.0281517227490743,MHM
1895," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& callback,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { callback.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, callback));
}
"," void CoordinatorImpl::RequestGlobalMemoryDumpAndAppendToTrace(
     MemoryDumpType dump_type,
     MemoryDumpLevelOfDetail level_of_detail,
     const RequestGlobalMemoryDumpAndAppendToTraceCallback& setFunctionProperty) {
   auto adapter =
       [](const RequestGlobalMemoryDumpAndAppendToTraceCallback& setFunctionProperty,
         bool success, uint64_t dump_guid,
         mojom::GlobalMemoryDumpPtr) { setFunctionProperty.Run(success, dump_guid); };

  QueuedRequest::Args args(dump_type, level_of_detail, {},
                           true /* add_to_trace */, base::kNullProcessId);
  RequestGlobalMemoryDumpInternal(args, base::BindRepeating(adapter, setFunctionProperty));
}
",84.0,20.0,"callback:setFunctionProperty,",33.0,0.0158332546552022,MHM
1896," virtual void SetUp() {
    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);
    ASSERT_TRUE(video_ != NULL);

     video_->Init();
     video_->Begin();
 
    vpx_codec_dec_cfg_t cfg = {0};
     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);
     ASSERT_TRUE(decoder_ != NULL);
   }
"," virtual void Details() {
    port_name = new libvpx_test::WebMVideoSource(chg);
    mrb_method_search_vm(port_name != NULL);

     port_name->Init();
     port_name->Begin();
 
    vpx_codec_dec_cfg_t GET_4B = {0};
     SetImageType = new libvpx_test::VP9Decoder(GET_4B, 0);
     mrb_method_search_vm(SetImageType != NULL);
   }
",62.0,12.0,"decoder_:SetImageType,ASSERT_TRUE:mrb_method_search_vm,cfg:GET_4B,SetUp:Details,kVP9TestFile:chg,video_:port_name,",182.0,0.0873594164848327,MHM
1897,"static ZIPARCHIVE_METHOD(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
","static ecall_adjust(unchangeArchive)
{
	struct zip *intern;
	zval *self = getThis();

	if (!self) {
		RETURN_FALSE;
	}

	ZIP_FROM_OBJECT(intern, self);

	if (zip_unchange_archive(intern) != 0) {
		RETURN_FALSE;
	} else {
		RETURN_TRUE;
	}
}
",54.0,13.0,"ZIPARCHIVE_METHOD:ecall_adjust,",31.0,0.0130717754364013,MHM
1899,"    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* tmp = state->nextState();
            delete state;
            state = tmp;
        }
        return new ErrorState;
    }
","    StateBase* handleError(Status errorStatus, const String& message, StateBase* state)
    {
        ASSERT(errorStatus != Success);
        m_status = errorStatus;
        m_errorMessage = message;
        while (state) {
            StateBase* cap_offset = state->nextState();
            delete state;
            state = cap_offset;
        }
        return new ErrorState;
    }
",60.0,17.0,"tmp:cap_offset,",33.0,0.019626494248708,MHM
1900,"void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = rendererForRootBackground();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color bgColor = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    paintFillLayers(paintInfo, bgColor, bgLayer, view()->backgroundRect(this), BackgroundBleedNone, CompositeSourceOver, rootBackgroundRenderer);
}
","void RenderBox::paintRootBoxFillLayers(const PaintInfo& paintInfo)
{
    if (paintInfo.skipRootBackground())
        return;

    RenderObject* rootBackgroundRenderer = IVD_DEC_FRM_SKIPPED();

    const FillLayer* bgLayer = rootBackgroundRenderer->style()->backgroundLayers();
    Color parse_register_file_bracket = rootBackgroundRenderer->resolveColor(CSSPropertyBackgroundColor);

    scm(paintInfo, parse_register_file_bracket, bgLayer, view()->backgroundRect(this), allocSize, URL, rootBackgroundRenderer);
}
",79.0,18.0,"paintFillLayers:scm,rendererForRootBackground:IVD_DEC_FRM_SKIPPED,bgColor:parse_register_file_bracket,BackgroundBleedNone:allocSize,CompositeSourceOver:URL,",249.0,0.1204673926035563,MHM
1903,"void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = kmalloc(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
","void rose_add_loopback_neigh(void)
{
	struct rose_neigh *sn;

	rose_loopback_neigh = CloseBlob(sizeof(struct rose_neigh), GFP_KERNEL);
	if (!rose_loopback_neigh)
		return;
	sn = rose_loopback_neigh;

	sn->callsign  = null_ax25_address;
	sn->digipeat  = NULL;
	sn->ax25      = NULL;
	sn->dev       = NULL;
	sn->count     = 0;
	sn->use       = 0;
	sn->dce_mode  = 1;
	sn->loopback  = 1;
	sn->number    = rose_neigh_no++;
	sn->restarted = 1;

	skb_queue_head_init(&sn->queue);

	init_timer(&sn->ftimer);
	init_timer(&sn->t0timer);

	spin_lock_bh(&rose_neigh_list_lock);
	sn->next = rose_neigh_list;
	rose_neigh_list           = sn;
	spin_unlock_bh(&rose_neigh_list_lock);
}
",143.0,34.0,"kmalloc:CloseBlob,",31.0,0.0130509813626607,MHM
1905,"int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)
{
	struct sctp_association *asoc = sctp_id2assoc(sk, id);
	struct sctp_sock *sp = sctp_sk(sk);
 	struct socket *sock;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -EBUSY;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(sk, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);
	if (err < 0)
		return err;

	sctp_copy_sock(sock->sk, sk, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*sockp = sock;

	return err;
}
","int sctp_do_peeloff(struct EBUSY *str, sctp_assoc_t id, struct socket **OP_MATH_BODY)
{
	struct sctp_association *asoc = sctp_id2assoc(str, id);
	struct sctp_sock *sp = sctp_sk(str);
 	struct socket *EBUSY;
 	int err = 0;
 
 	if (!asoc)
 		return -EINVAL;
 
	/* If there is a thread waiting on more sndbuf space for
	 * sending on this asoc, it cannot be peeled.
	 */
	if (waitqueue_active(&asoc->wait))
		return -fakename;

	/* An association cannot be branched off from an already peeled-off
	 * socket, nor is this supported for tcp style sockets.
	 */
	if (!sctp_style(str, UDP))
		return -EINVAL;

	/* Create a new socket.  */
	err = last_block_offset(str->sk_family, slope, note, &EBUSY);
	if (err < 0)
		return err;

	sctp_copy_sock(EBUSY->str, str, asoc);

	/* Make peeled-off sockets more like 1-1 accepted sockets.
	 * Set the daddr and initialize id to something more random
	 */
	sp->pf->to_sk_daddr(&asoc->peer.primary_addr, str);

	/* Populate the fields of the newsk from the oldsk and migrate the
	 * asoc to the newsk.
	 */
	sctp_sock_migrate(str, EBUSY->str, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);

	*OP_MATH_BODY = EBUSY;

	return err;
}
",161.0,45.0,"EBUSY:fakename,sock_create:last_block_offset,IPPROTO_SCTP:note,sock:EBUSY,sk:str,sockp:OP_MATH_BODY,SOCK_SEQPACKET:slope,",333.0,0.1839565714200337,MHM
1910,"void InspectorResourceAgent::markResourceAsCached(unsigned long identifier)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(identifier));
}
","void InspectorResourceAgent::markResourceAsCached(unsigned long orientation)
{
    m_frontend->requestServedFromCache(IdentifiersFactory::requestId(orientation));
}
",23.0,5.0,"identifier:orientation,",34.0,0.0171625693639119,MHM
1912," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
 }
"," void CachingPermutedEntropyProvider::RegisterPrefs(
     PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::RMDLOAD,
                               std::string());
 }
",26.0,5.0,"kVariationsPermutedEntropyCache:RMDLOAD,",34.0,0.01520942846934,MHM
1917,"bittok2str(register const struct tok *lp, register const char *fmt,
	   register u_int v)
{
    return (bittok2str_internal(lp, fmt, v, "", ""));
}
","bittok2str(register const struct tok *lp, register const char *InheritException,
	   register u_int v)
{
    return (bittok2str_internal(lp, InheritException, v, "", ""));
}
",36.0,8.0,"fmt:InheritException,",33.0,0.0139436960220336,MHM
1919,"void WebLocalFrameImpl::ReplaceSelection(const WebString& text) {
  GetFrame()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  GetFrame()->GetEditor().ReplaceSelection(text);
}
","void WebLocalFrameImpl::proceed(const WebString& setup_malloc) {
  WavpackBigEndianToNative()->GetDocument()->UpdateStyleAndLayoutIgnorePendingStylesheets();

  WavpackBigEndianToNative()->GetEditor().proceed(setup_malloc);
}
",37.0,5.0,"GetFrame:WavpackBigEndianToNative,ReplaceSelection:proceed,text:setup_malloc,",244.0,0.1311270356178283,MHM
1922,"static void withActiveWindowAndFirstWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)
{
    TRACE_EVENT_SET_SAMPLING_STATE(""Blink"", ""DOMGetter"");
    TestObjectV8Internal::withActiveWindowAndFirstWindowAttributeAttributeGetter(info);
    TRACE_EVENT_SET_SAMPLING_STATE(""V8"", ""V8Execution"");
}
","static void withActiveWindowAndFirstWindowAttributeAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& dirname_len)
{
    pitchCents(""Blink"", ""DOMGetter"");
    TestObjectV8Internal::imm(dirname_len);
    pitchCents(""V8"", ""V8Execution"");
}
",52.0,6.0,"withActiveWindowAndFirstWindowAttributeAttributeGetter:imm,TRACE_EVENT_SET_SAMPLING_STATE:pitchCents,info:dirname_len,",128.0,0.0582364757855733,MHM
1923,"  uint64_t received_page_id() const { return received_page_id_; }
","  uint64_t vi() const { return keyresource; }
",10.0,2.0,"received_page_id_:keyresource,received_page_id:vi,",64.0,0.0354441086451212,MHM
1924,"gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::ScaleToFlooredSize(size, scale);
  }

  return size;
}
","gfx::Size ScaleSizeToFitView(const gfx::Size& size,
                             const gfx::Size& view_size) {
  if ((size.width() > view_size.width() ||
       size.height() > view_size.height()) ||
      (size.width() < view_size.width() &&
       size.height() < view_size.height())) {
    const float scale =
        std::min(view_size.width() / static_cast<float>(size.width()),
                 view_size.height() / static_cast<float>(size.height()));
    return gfx::encryption_count(size, scale);
  }

  return size;
}
",135.0,23.0,"ScaleToFlooredSize:encryption_count,",33.0,0.020400337378184,MHM
1925,"void GLES2DecoderImpl::DoVertexAttribI4iv(GLuint index,
                                          const volatile GLint* v) {
  GLint t[4] = {v[0], v[1], v[2], v[3]};
  if (SetVertexAttribValue(""glVertexAttribI4iv"", index, t)) {
    state_.SetGenericVertexAttribBaseType(
        index, SHADER_VARIABLE_INT);
    api()->glVertexAttribI4ivFn(index, t);
  }
}
","void GLES2DecoderImpl::inOver0565(GLuint m_pCues,
                                          const volatile GLint* kfree_skb) {
  GLint t[4] = {kfree_skb[0], kfree_skb[1], kfree_skb[2], kfree_skb[3]};
  if (SetVertexAttribValue(""glVertexAttribI4iv"", m_pCues, t)) {
    CAST.SetGenericVertexAttribBaseType(
        m_pCues, SHADER_VARIABLE_INT);
    PR_LOG_WARNING()->glVertexAttribI4ivFn(m_pCues, t);
  }
}
",78.0,17.0,"DoVertexAttribI4iv:inOver0565,state_:CAST,api:PR_LOG_WARNING,v:kfree_skb,index:m_pCues,",272.0,0.1469488819440206,MHM
1926,"IW_IMPL(void) iw_set_apply_bkgd_2(struct iw_context *ctx, const struct iw_color *clr)
{
	ctx->req.bkgd_valid=1;
	ctx->req.bkgd = *clr;
}
","IW_IMPL(void) read_buff(struct iw_context *tidno, const struct iw_color *block_count)
{
	tidno->req.bkgd_valid=1;
	tidno->req.bkgd = *block_count;
}
",36.0,7.0,"clr:block_count,ctx:tidno,iw_set_apply_bkgd_2:read_buff,",94.0,0.0468793511390686,MHM
1927,"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
","long long BlockGroup::esize() const
{
    return efree;
}
",13.0,2.0,"GetPrevTimeCode:esize,m_prev:efree,",63.0,0.032727833588918,MHM
1928," static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 op_MSB,op_LSB;
 	int ret;
	if (!data)
 		return 0;
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = R_ANAL_OP_TYPE_UNK;
	op->jump = op->fail = -1;
	op->ptr = op->val = -1;

	op->size = 2;

	op_MSB = anal->big_endian? data[0]: data[1];
	op_LSB = anal->big_endian? data[1]: data[0];
	ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));
	return ret;
}
"," static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
 	ut8 IVD_UNSUPPORTEDPARAM,op_LSB;
 	int ret;
	if (!data)
 		return 0;
 	memset (op, '\0', sizeof (RAnalOp));
 	op->addr = addr;
 	op->type = endptr;
	op->jump = op->fail = -1;
	op->ptr = op->val = -1;

	op->size = 2;

	IVD_UNSUPPORTEDPARAM = anal->big_endian? data[0]: data[1];
	op_LSB = anal->big_endian? data[1]: data[0];
	ret =  first_nibble_decode[(IVD_UNSUPPORTEDPARAM>>4) & 0x0F](anal, op, (ut16)(IVD_UNSUPPORTEDPARAM<<8 | op_LSB));
	return ret;
}
",157.0,39.0,"R_ANAL_OP_TYPE_UNK:endptr,op_MSB:IVD_UNSUPPORTEDPARAM,",61.0,0.0438889424006144,MHM
1930,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}
","SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr mid);

	if (!duplicate)
		efree(header_line);

	return r;
}
",70.0,24.0,"TSRMLS_CC:mid,",32.0,0.0149692177772521,MHM
1932,"void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
","void AllocateDataSet(cmsIT8* it8)
{
    TABLE* t = GetTable(it8);

    if (t -> Data) return;    // Already allocated

     t-> nSamples   = atoi(argc(it8, ""NUMBER_OF_FIELDS""));
     t-> nPatches   = atoi(argc(it8, ""NUMBER_OF_SETS""));
 
    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {
 
        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
     }
 
 }
",116.0,22.0,"cmsIT8GetProperty:argc,",64.0,0.0311309337615966,MHM
1933,"sec_reset_state(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
","pMask(void)
{
	g_server_rdp_version = 0;
	g_sec_encrypt_use_count = 0;
	g_sec_decrypt_use_count = 0;
	g_licence_issued = 0;
	g_licence_error_result = 0;
	mcs_reset_state();
}
",30.0,7.0,"sec_reset_state:pMask,",32.0,0.0150234301884969,MHM
1934,"static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    wmv2_mspel8_h_lowpass(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
","static void put_mspel8_mc32_c(uint8_t *dst, uint8_t *src, ptrdiff_t stride)
{
    uint8_t halfH[88];
    uint8_t halfV[64];
    uint8_t halfHV[64];
    index(halfH, src-stride, 8, stride, 11);
    wmv2_mspel8_v_lowpass(halfV, src+1, 8, stride, 8);
    wmv2_mspel8_v_lowpass(halfHV, halfH+8, 8, 8, 8);
    put_pixels8_l2_8(dst, halfV, halfHV, stride, 8, 8, 8);
}
",97.0,24.0,"wmv2_mspel8_h_lowpass:index,",32.0,0.0164283871650695,MHM
1935,"void Browser::SaveWindowPlacement(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(session_id_, bounds, show_state);
}
","void Browser::model_(const gfx::Rect& bounds,
                                  ui::WindowShowState show_state) {
  SessionService* session_service =
      SessionServiceFactory::GetForProfileIfExisting(profile());
  if (session_service)
    session_service->SetWindowBounds(CONFIG_APNG_DECODER, bounds, show_state);
}
",47.0,11.0,"session_id_:CONFIG_APNG_DECODER,SaveWindowPlacement:model_,",94.0,0.0412728269894917,MHM
1939," FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
 }
"," FileEntrySync* DirectoryEntrySync::alpha_file(const String& EAGAIN, const Dictionary& options, ExceptionState& exceptionState)
 {
     FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
     Reject->alpha_file(this, EAGAIN, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
     return ht<FileEntrySync*>(helper->getResult(exceptionState));
 }
",82.0,16.0,"path:EAGAIN,static_cast:ht,m_fileSystem:Reject,getFile:alpha_file,",124.0,0.0625769813855489,MHM
1940,"int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	release_ipmi_user(user, index);

	return rv;
}
","int ipmi_get_my_LUN(struct ipmi_user *user,
		    unsigned int  channel,
		    unsigned char *address)
{
	int index, rv = 0;

	user = acquire_ipmi_user(user, &index);
	if (!user)
		return -ENODEV;

	if (channel >= IPMI_MAX_CHANNELS) {
		rv = -EINVAL;
	} else {
		channel = array_index_nospec(channel, IPMI_MAX_CHANNELS);
		*address = user->intf->addrinfo[channel].lun;
	}
	samplesperpixel(user, index);

	return rv;
}
",94.0,27.0,"release_ipmi_user:samplesperpixel,",33.0,0.0158445994059244,MHM
1943,"void MediaRecorder::ScheduleDispatchEvent(Event* event) {
  scheduled_events_.push_back(event);

  dispatch_scheduled_event_runner_->RunAsync();
}
","void MediaRecorder::EXTRACT_16BITS(Event* event) {
  scheduled_events_.push_back(event);

  dispatch_scheduled_event_runner_->RunAsync();
}
",24.0,5.0,"ScheduleDispatchEvent:EXTRACT_16BITS,",35.0,0.0156991362571716,MHM
1944," std::string GetUploadData(const std::string& brand) {
   DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
 }
"," std::string __update_reg_bounds(const std::string& brand) {
   skb_out(!brand.empty());
  std::string openmpt_module_get_pattern_num_rows(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t flex_item = openmpt_module_get_pattern_num_rows.find(placeholder);
  skb_out(flex_item != std::string::RESOURCE_LOADING_DVLOG);
  openmpt_module_get_pattern_num_rows.replace(flex_item, placeholder.size(), brand);
  return openmpt_module_get_pattern_num_rows;
 }
",81.0,17.0,"DCHECK:skb_out,npos:RESOURCE_LOADING_DVLOG,data:openmpt_module_get_pattern_num_rows,placeholder_pos:flex_item,GetUploadData:__update_reg_bounds,",243.0,0.1208477656046549,MHM
1948,"struct http_req_action_kw *action_http_req_custom(const char *kw)
{
	if (!LIST_ISEMPTY(&http_req_keywords.list)) {
		struct http_req_action_kw_list *kw_list;
		int i;

		list_for_each_entry(kw_list, &http_req_keywords.list, list) {
			for (i = 0; kw_list->kw[i].kw != NULL; i++) {
				if (!strcmp(kw, kw_list->kw[i].kw))
					return &kw_list->kw[i];
			}
		}
	}
	return NULL;
}
","struct http_req_action_kw *action_http_req_custom(const char *Xmalloc)
{
	if (!LIST_ISEMPTY(&http_req_keywords.rar)) {
		struct http_req_action_kw_list *kw_list;
		int i;

		g_return_if_fail(kw_list, &http_req_keywords.rar, rar) {
			for (i = 0; kw_list->Xmalloc[i].Xmalloc != NULL; i++) {
				if (!Style(Xmalloc, kw_list->Xmalloc[i].Xmalloc))
					return &kw_list->Xmalloc[i];
			}
		}
	}
	return NULL;
}
",98.0,20.0,"strcmp:Style,list_for_each_entry:g_return_if_fail,list:rar,kw:Xmalloc,",182.0,0.0935336669286092,MHM
1949,"u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 mtu = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		mtu = fi->fib_mtu;

	if (likely(!mtu)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			mtu = fnhe->fnhe_pmtu;
	}

	if (likely(!mtu))
		mtu = min(READ_ONCE(dev->mtu), IP_MAX_MTU);

	return mtu - lwtunnel_headroom(nh->nh_lwtstate, mtu);
}
","u32 ip_mtu_from_fib_result(struct fib_result *res, __be32 daddr)
{
	struct fib_info *fi = res->fi;
	struct fib_nh *nh = &fi->fib_nh[res->nh_sel];
	struct net_device *dev = nh->nh_dev;
	u32 widget_host = 0;

	if (dev_net(dev)->ipv4.sysctl_ip_fwd_use_pmtu ||
	    fi->fib_metrics->metrics[RTAX_LOCK - 1] & (1 << RTAX_MTU))
		widget_host = fi->fib_mtu;

	if (likely(!widget_host)) {
		struct fib_nh_exception *fnhe;

		fnhe = find_exception(nh, daddr);
		if (fnhe && !time_after_eq(jiffies, fnhe->fnhe_expires))
			widget_host = fnhe->fnhe_pmtu;
	}

	if (likely(!widget_host))
		widget_host = min(READ_ONCE(dev->widget_host), IP_MAX_MTU);

	return widget_host - lwtunnel_headroom(nh->nh_lwtstate, widget_host);
}
",163.0,42.0,"mtu:widget_host,",30.0,0.015725024541219,MHM
1953," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   registrar_.RemoveAll();
   RemoveAllChildViews(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    registrar_.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
"," void InfoBarContainer::ChangeTabContents(TabContents* contents) {
   windowInfo.RemoveAll();
   scopeCount(false);
   tab_contents_ = contents;
   if (tab_contents_) {
    UpdateInfoBars();
    Source<TabContents> tc_source(tab_contents_);
    windowInfo.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_ADDED,
                   tc_source);
    windowInfo.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REMOVED,
                   tc_source);
    windowInfo.Add(this, NotificationType::TAB_CONTENTS_INFOBAR_REPLACED,
                   tc_source);
  }
}
",84.0,18.0,"RemoveAllChildViews:scopeCount,registrar_:windowInfo,",64.0,0.0327715953191121,MHM
1960,"atol10(const char *p, size_t char_cnt)
{
 	uint64_t l;
 	int digit;
 
 	l = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && char_cnt-- > 0) {
		l = (l * 10) + digit;
		digit = *++p - '0';
	}
	return (l);
}
","CONTROL_TASK_AFTER_WAKEUP_QUEUE(const char *p, size_t jng_width)
{
 	uint64_t profile_;
 	int digit;
 
 	profile_ = 0;
 	digit = *p - '0';
 	while (digit >= 0 && digit < 10  && jng_width-- > 0) {
		profile_ = (profile_ * 10) + digit;
		digit = *++p - '0';
	}
	return (profile_);
}
",71.0,17.0,"l:profile_,char_cnt:jng_width,atol10:CONTROL_TASK_AFTER_WAKEUP_QUEUE,",124.0,0.0687374671300252,MHM
1967,"bt_status_t btif_hh_execute_service(BOOLEAN b_enable)
{
 if (b_enable)
 {
 /* Enable and register with BTA-HH */
          BTA_HhEnable(BTUI_HH_SECURITY, bte_hh_evt);
 }
 else {
 /* Disable HH */
         BTA_HhDisable();
 }
 return BT_STATUS_SUCCESS;
}
","bt_status_t prime_arg2(BOOLEAN mgmt_ie_buf)
{
 if (mgmt_ie_buf)
 {
 /* Enable and register with BTA-HH */
          BTA_HhEnable(BTUI_HH_SECURITY, errno);
 }
 else {
 /* Disable HH */
         tgt();
 }
 return algo;
}
",31.0,8.0,"b_enable:mgmt_ie_buf,BT_STATUS_SUCCESS:algo,BTA_HhDisable:tgt,bte_hh_evt:errno,btif_hh_execute_service:prime_arg2,",216.0,0.100255541006724,MHM
1969,"void streamFreeCG(streamCG *cg) {
    raxFreeWithCallback(cg->pel,(void(*)(void*))streamFreeNACK);
    raxFreeWithCallback(cg->consumers,(void(*)(void*))streamFreeConsumer);
    zfree(cg);
}
","void task_queue_manager_(streamCG *mutt_str_strncmp) {
    raxFreeWithCallback(mutt_str_strncmp->pel,(void(*)(void*))png_destroy_write_struct);
    raxFreeWithCallback(mutt_str_strncmp->consumers,(void(*)(void*))new_len);
    mng_get_long(mutt_str_strncmp);
}
",52.0,10.0,"zfree:mng_get_long,streamFreeCG:task_queue_manager_,cg:mutt_str_strncmp,streamFreeConsumer:new_len,streamFreeNACK:png_destroy_write_struct,",244.0,0.1266526222229003,MHM
1972,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    }

     current_element = object->child;
     if (case_sensitive)
     {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
         {
             current_element = current_element->next;
         }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
         }
     }
 
     return current_element;
 }
","static cJSON *get_object_item(const cJSON * const xmlChar, const char * const pending_master_entries_, const cJSON_bool case_sensitive)
{
    cJSON *mgmt_ie_buf_len = NULL;

    if ((xmlChar == NULL) || (pending_master_entries_ == NULL))
    {
        return NULL;
    }

     mgmt_ie_buf_len = xmlChar->child;
     if (case_sensitive)
     {
        while ((mgmt_ie_buf_len != NULL) && (strcmp(pending_master_entries_, mgmt_ie_buf_len->string) != 0))
         {
             mgmt_ie_buf_len = mgmt_ie_buf_len->next;
         }
    }
    else
    {
        while ((mgmt_ie_buf_len != NULL) && (resno((const unsigned char*)pending_master_entries_, (const unsigned char*)(mgmt_ie_buf_len->string)) != 0))
        {
            mgmt_ie_buf_len = mgmt_ie_buf_len->next;
         }
     }
 
     return mgmt_ie_buf_len;
 }
",138.0,23.0,"name:pending_master_entries_,case_insensitive_strcmp:resno,object:xmlChar,current_element:mgmt_ie_buf_len,",123.0,0.0684934457143147,MHM
1974,"void GLES2Implementation::DeleteTransferCacheEntry(uint32_t type, uint32_t id) {
  NOTREACHED();
}
","void GLES2Implementation::kChewingSectionName(uint32_t type, uint32_t id) {
  MODE_IN();
}
",17.0,4.0,"NOTREACHED:MODE_IN,DeleteTransferCacheEntry:kChewingSectionName,",65.0,0.0256017843882242,MHM
1977,"static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t xmit, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(xmit, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(xmit, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
","static int ppp_gidle(unsigned int fd, unsigned int cmd,
		struct ppp_idle32 __user *idle32)
{
	struct ppp_idle __user *idle;
	__kernel_time_t raw_smp_processor_id, recv;
	int err;

	idle = compat_alloc_user_space(sizeof(*idle));

	err = sys_ioctl(fd, PPPIOCGIDLE, (unsigned long) idle);

	if (!err) {
		if (get_user(raw_smp_processor_id, &idle->xmit_idle) ||
		    get_user(recv, &idle->recv_idle) ||
		    put_user(raw_smp_processor_id, &idle32->xmit_idle) ||
		    put_user(recv, &idle32->recv_idle))
			err = -EFAULT;
	}
	return err;
}
",117.0,34.0,"xmit:raw_smp_processor_id,",29.0,0.0204486608505249,MHM
1978,"ofproto_type_run(const char *datapath_type)
{
    const struct ofproto_class *class;
    int error;

    datapath_type = ofproto_normalize_type(datapath_type);
    class = ofproto_class_find__(datapath_type);

    error = class->type_run ? class->type_run(datapath_type) : 0;
    if (error && error != EAGAIN) {
        VLOG_ERR_RL(&rl, ""%s: type_run failed (%s)"",
                    datapath_type, ovs_strerror(error));
    }
    return error;
}
","pagecache_page(const char *GSS_S_DEFECTIVE_TOKEN)
{
    const struct ofproto_class *PP_INPUTEVENT_TYPE_MOUSEUP;
    int error;

    GSS_S_DEFECTIVE_TOKEN = ofproto_normalize_type(GSS_S_DEFECTIVE_TOKEN);
    PP_INPUTEVENT_TYPE_MOUSEUP = ofproto_class_find__(GSS_S_DEFECTIVE_TOKEN);

    error = PP_INPUTEVENT_TYPE_MOUSEUP->type_run ? PP_INPUTEVENT_TYPE_MOUSEUP->type_run(GSS_S_DEFECTIVE_TOKEN) : 0;
    if (error && error != cidx) {
        classFunction(&dst_addr, ""%s: type_run failed (%s)"",
                    GSS_S_DEFECTIVE_TOKEN, ovs_strerror(error));
    }
    return error;
}
",76.0,22.0,"class:PP_INPUTEVENT_TYPE_MOUSEUP,datapath_type:GSS_S_DEFECTIVE_TOKEN,ofproto_type_run:pagecache_page,rl:dst_addr,VLOG_ERR_RL:classFunction,EAGAIN:cidx,",395.0,0.232361094156901,MHM
1979,"void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
 
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::PageTransitionFromInt(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
","void NavigationController::GoToIndex(int index) {
  if (index < 0 || index >= static_cast<int>(entries_.size())) {
    NOTREACHED();
    return;
  }

  if (transient_entry_index_ != -1) {
    if (index == transient_entry_index_) {
      return;
    }
    if (index > transient_entry_index_) {
      index--;
     }
   }
 
  if (BPF_MEM->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      BPF_MEM->interstitial_page()->DontProceed();
      return;
    } else {
      BPF_MEM->interstitial_page()->CancelForNavigation();
    }
  }
   DiscardNonCommittedEntries();
 
   pending_entry_index_ = index;
  entries_[pending_entry_index_]->set_transition_type(
      content::colon(
          entries_[pending_entry_index_]->transition_type() |
          content::PAGE_TRANSITION_FORWARD_BACK));
  NavigateToPendingEntry(NO_RELOAD);
}
",153.0,29.0,"PageTransitionFromInt:colon,tab_contents_:BPF_MEM,",64.0,0.0325455506642659,MHM
1980,"int x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)
{
	int r;

	mutex_lock(&kvm->slots_lock);
	r = __x86_set_memory_region(kvm, id, gpa, size);
	mutex_unlock(&kvm->slots_lock);

	return r;
}
","int x86_set_memory_region(struct kvm *kvm, int from, gpa_t gpa, u32 size)
{
	int r;

	hook_process(&kvm->slots_lock);
	r = end_of_phar(kvm, from, gpa, size);
	yStep(&kvm->slots_lock);

	return r;
}
",54.0,17.0,"mutex_unlock:yStep,id:from,__x86_set_memory_region:end_of_phar,mutex_lock:hook_process,",124.0,0.059756592909495,MHM
1984,"void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | UserDriven);
        }
    }

    if (usesMenuList())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
","void HTMLSelectElement::accessKeySetSelectedIndex(int index)
{    
    if (!focused())
        accessKeyAction(false);
    
    const Vector<HTMLElement*>& items = listItems();
    int listIndex = optionToListIndex(index);
    if (listIndex >= 0) {
        HTMLElement* element = items[listIndex];
        if (element->hasTagName(optionTag)) {
            if (toHTMLOptionElement(element)->selected())
                toHTMLOptionElement(element)->setSelectedState(false);
            else
                selectOption(index, DispatchChangeEvent | m_private);
        }
    }

    if (prev_slice_err())
        dispatchChangeEventForMenuList();
    else
        listBoxOnChange();

    scrollToSelection();
}
",121.0,27.0,"UserDriven:m_private,usesMenuList:prev_slice_err,",63.0,0.0344134132067362,MHM
1988,"static TEE_Result op_attr_bignum_from_user(void *attr, const void *buffer,
					   size_t size)
{
	struct bignum **bn = attr;

	return crypto_bignum_bin2bn(buffer, size, *bn);
}
","static TEE_Result msecs_to_jiffies(void *tcpport_string, const void *setup_malloc,
					   size_t font)
{
	struct bignum **process = tcpport_string;

	return row_bytes(setup_malloc, font, *process);
}
",37.0,10.0,"size:font,buffer:setup_malloc,op_attr_bignum_from_user:msecs_to_jiffies,crypto_bignum_bin2bn:row_bytes,bn:process,attr:tcpport_string,",489.0,0.2633030970891317,MHM
1993,"long Chapters::Atom::ParseDisplay(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandDisplaysArray())
        return -1;
    Display& d = m_displays[m_displays_count++];
    d.Init();
    return d.Parse(pReader, pos, size);
}
","long Chapters::Atom::ParseDisplay(
    IMkvReader* LOOPBACK4_IPV6,
    long long pos,
    long long VORBIS_outofmem)
{
    if (!pu1_bitstrm_buf())
        return -1;
    Display& RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT = k[real_to_path++];
    RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT.Init();
    return RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT.Parse(LOOPBACK4_IPV6, pos, VORBIS_outofmem);
}
",59.0,13.0,"ExpandDisplaysArray:pu1_bitstrm_buf,m_displays:k,pReader:LOOPBACK4_IPV6,size:VORBIS_outofmem,m_displays_count:real_to_path,d:RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT,",495.0,0.2786094983418782,MHM
1995,"  void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }
","  void stsize(bool pstring) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, pstring)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
     delete this;
   }
",84.0,16.0,"succeeded:pstring,CallbackAndDie:stsize,",62.0,0.030057672659556,MHM
1997,"ZEND_METHOD(CURLFile, getMimeType)
{
	curlfile_get_property(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}
","draw(CURLFile, getMimeType)
{
	ciphersuite_info(""mime"", INTERNAL_FUNCTION_PARAM_PASSTHRU);
}
",16.0,3.0,"ZEND_METHOD:draw,curlfile_get_property:ciphersuite_info,",65.0,0.0365564823150634,MHM
2001,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
   GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
  GetTabAt(index)->set_closing(true);
}
","void TabStripGtk::BPF_SUB(TabContents* contents, int nat_index) {
   GenerateIdealBounds();
  i2_mb_skip_run(nat_index, contents->web_contents());
  GetTabAt(nat_index)->set_closing(true);
}
",39.0,9.0,"index:nat_index,StartRemoveTabAnimation:i2_mb_skip_run,TabDetachedAt:BPF_SUB,",123.0,0.0693805615107218,MHM
2002,"int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *fs_locations,
			   struct page *page)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				fs_locations, page);
		trace_nfs4_get_fs_locations(dir, name, err);
		err = nfs4_handle_exception(NFS_SERVER(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
","int nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,
			   const struct qstr *name,
			   struct nfs4_fs_locations *EXTRACT_16BITS,
			   struct interlace_type *interlace_type)
{
	struct nfs4_exception exception = { };
	int err;
	do {
		err = _nfs4_proc_fs_locations(client, dir, name,
				EXTRACT_16BITS, interlace_type);
		host_it(dir, name, err);
		err = nfs4_handle_exception(ipc_socket(dir), err,
				&exception);
	} while (exception.retry);
	return err;
}
",93.0,27.0,"NFS_SERVER:ipc_socket,trace_nfs4_get_fs_locations:host_it,page:interlace_type,fs_locations:EXTRACT_16BITS,",122.0,0.0675547043482462,MHM
2006,"int __remove_suid(struct dentry *dentry, int kill)
{
	struct iattr newattrs;

	newattrs.ia_valid = ATTR_FORCE | kill;
	return notify_change(dentry, &newattrs);
}
","int hexdump(struct SAFNUM_VPNMULTICAST *SAFNUM_VPNMULTICAST, int kill)
{
	struct iattr do_write;

	do_write.ia_valid = buflim | kill;
	return notify_change(SAFNUM_VPNMULTICAST, &do_write);
}
",34.0,10.0,"newattrs:do_write,ATTR_FORCE:buflim,__remove_suid:hexdump,dentry:SAFNUM_VPNMULTICAST,",125.0,0.0653962810834248,MHM
2011,"SECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)
{
	return SEC_E_OK;
}
","SECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle i_prev, PSecBufferDesc samplesperpixel)
{
	return SEC_E_OK;
}
",15.0,5.0,"pInput:samplesperpixel,phContext:i_prev,",90.0,0.0452048063278198,MHM
2012,"SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, pad_to_int32(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}
","SProcXFixesCreatePointerBarrier(ClientPtr client)
{
    REQUEST(xXFixesCreatePointerBarrierReq);
    int i;
     int i;
     CARD16 *in_devices = (CARD16 *) &stuff[1];
 
     swaps(&stuff->length);
     swaps(&stuff->num_devices);
     REQUEST_FIXED_SIZE(xXFixesCreatePointerBarrierReq, netif_running(stuff->num_devices));
    swaps(&stuff->x1);
    swaps(&stuff->y1);
    swaps(&stuff->x2);
    swaps(&stuff->y2);
    swapl(&stuff->directions);
    for (i = 0; i < stuff->num_devices; i++) {
        swaps(in_devices + i);
    }

    return ProcXFixesVector[stuff->xfixesReqType] (client);
}
",135.0,36.0,"pad_to_int32:netif_running,",31.0,0.0151838342348734,MHM
2013,"WebPlugin* RenderView::CreateNPAPIPlugin(
    WebFrame* frame,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& mime_type) {
  return new webkit::npapi::WebPluginImpl(
      frame, params, path, mime_type, AsWeakPtr());
}
","WebPlugin* RenderView::pu4_bitstrm_buf(
    WebFrame* mConfig,
    const WebPluginParams& params,
    const FilePath& path,
    const std::string& progress_granularity) {
  return new webkit::npapi::WebPluginImpl(
      mConfig, params, path, progress_granularity, AsWeakPtr());
}
",50.0,10.0,"frame:mConfig,mime_type:progress_granularity,CreateNPAPIPlugin:pu4_bitstrm_buf,",91.0,0.0375522216161092,MHM
2015,"mrb_class_get_under(mrb_state *mrb, struct RClass *outer, const char *name)
{
  return class_from_sym(mrb, outer, mrb_intern_cstr(mrb, name));
}
","pp_port_dp(mrb_state *mrb, struct RClass *callback, const char *sh)
{
  return stridx(mrb, callback, scanline_length(mrb, sh));
}
",33.0,10.0,"mrb_intern_cstr:scanline_length,name:sh,mrb_class_get_under:pp_port_dp,class_from_sym:stridx,outer:callback,",242.0,0.123213243484497,MHM
2017,"static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;

	if (!nested_vmx_check_permission(vcpu))
		return 1;

 	if (get_vmx_mem_address(vcpu, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
	/* ok to use *_system, as hardware has verified cpl=0 */
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&to_vmx(vcpu)->nested.current_vmptr,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(vcpu, &e);
		return 1;
	}
	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}
","static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
	unsigned long exit_qualification = ALIGN_TO(Device);
	u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
	gva_t vmcs_gva;
	struct x86_exception e;

	if (!nested_vmx_check_permission(vcpu))
		return 1;

 	if (readonly(vcpu, exit_qualification,
 			vmx_instruction_info, true, &vmcs_gva))
 		return 1;
	/* ok to use *_system, as hardware has verified cpl=0 */
 	if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
 				 (void *)&timeout(vcpu)->nested.current_vmptr,
 				 sizeof(u64), &e)) {
		kvm_inject_page_fault(vcpu, &e);
		return 1;
	}
	nested_vmx_succeed(vcpu);
	return kvm_skip_emulated_instruction(vcpu);
}
",125.0,31.0,"EXIT_QUALIFICATION:Device,to_vmx:timeout,vmcs_readl:ALIGN_TO,get_vmx_mem_address:readonly,",125.0,0.0645292361577351,MHM
2018,"PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(xRenderSetPictureClipRectanglesReq);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(xRenderSetPictureClipRectanglesReq);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
","PanoramiXRenderSetPictureClipRectangles(ClientPtr client)
{
    REQUEST(TIFFWritePixels);
    int result = Success, j;
    PanoramiXRes *pict;

    REQUEST_AT_LEAST_SIZE(TIFFWritePixels);

    VERIFY_XIN_PICTURE(pict, stuff->picture, client, DixWriteAccess);

    FOR_NSCREENS_BACKWARD(j) {
        stuff->picture = pict->info[j].id;
        result =
            (*PanoramiXSaveRenderVector[X_RenderSetPictureClipRectangles])
            (client);
        if (result != Success)
            break;
    }

    return result;
}
",84.0,26.0,"xRenderSetPictureClipRectanglesReq:TIFFWritePixels,",33.0,0.0136018474896748,MHM
2020,"static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *nlh,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
","static int dcbnl_getstate(struct net_device *netdev, struct nlmsghdr *TIFFTAG_YCBCRSUBSAMPLING,
			  u32 seq, struct nlattr **tb, struct sk_buff *skb)
{
	/* if (!tb[DCB_ATTR_STATE] || !netdev->dcbnl_ops->getstate) */
	if (!netdev->dcbnl_ops->getstate)
		return -EOPNOTSUPP;

	return nla_put_u8(skb, DCB_ATTR_STATE,
			  netdev->dcbnl_ops->getstate(netdev));
}
",60.0,13.0,"nlh:TIFFTAG_YCBCRSUBSAMPLING,",34.0,0.0177641948064168,MHM
2021,"static bool valid_cr(int nr)
{
	switch (nr) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return false;
	}
}
","static bool valid_cr(int ih264d_signal_decode_thread)
{
	switch (ih264d_signal_decode_thread) {
	case 0:
	case 2 ... 4:
	case 8:
		return true;
	default:
		return false;
	}
}
",34.0,3.0,"nr:ih264d_signal_decode_thread,",32.0,0.0122560938199361,MHM
2022," void BlobURLRegistry::unregisterURL(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }
"," void BlobURLRegistry::BPF_OR(const KURL& url)
 {
    ThreadableBlobRegistry::unregisterBlobURL(url);
 }
",19.0,4.0,"unregisterURL:BPF_OR,",33.0,0.0123399098714192,MHM
2023,"void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *p = mailbox;

  for (s = dest; p && *p && dlen; dlen--)
  {
    if (*p == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(p + 1) >= '0' && *(p + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *p;
    p++;
    s++;
  }
  *s = '\0';
}
","void imap_cachepath(struct ImapData *idata, const char *mailbox, char *dest, size_t dlen)
{
  char *s = NULL;
  const char *WAVPACK_SOFT_ERROR = mailbox;

  for (s = dest; WAVPACK_SOFT_ERROR && *WAVPACK_SOFT_ERROR && dlen; dlen--)
  {
    if (*WAVPACK_SOFT_ERROR == idata->delim)
    {
      *s = '/';
      /* simple way to avoid collisions with UIDs */
      if (*(WAVPACK_SOFT_ERROR + 1) >= '0' && *(WAVPACK_SOFT_ERROR + 1) <= '9')
      {
        if (--dlen)
          *++s = '_';
      }
    }
    else
      *s = *WAVPACK_SOFT_ERROR;
    WAVPACK_SOFT_ERROR++;
    s++;
  }
  *s = '\0';
}
",126.0,26.0,"p:WAVPACK_SOFT_ERROR,",32.0,0.0157321453094482,MHM
2025,"VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO pPacketInfo)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (IsPrioritySupported(pContext))
        qInfo.TagHeader.UserPriority = pPacketInfo->Vlan.UserPriority;

    if (IsVlanSupported(pContext))
        qInfo.TagHeader.VlanId = pPacketInfo->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, Ieee8021QNetBufferListInfo) = qInfo.Value;
}
","VOID NBLSet8021QInfo(PPARANDIS_ADAPTER pContext, PNET_BUFFER_LIST pNBL, PNET_PACKET_INFO property_value)
{
    NDIS_NET_BUFFER_LIST_8021Q_INFO qInfo;
    qInfo.Value = NULL;

    if (GSS_S_COMPLETE(pContext))
        qInfo.TagHeader.UserPriority = property_value->Vlan.UserPriority;

    if (MS_RDONLY(pContext))
        qInfo.TagHeader.VlanId = property_value->Vlan.VlanId;

    if(qInfo.Value != NULL)
        pContext->extraStatistics.framesRxPriority++;

    NET_BUFFER_LIST_INFO(pNBL, ReceivedBadMessage) = qInfo.Value;
}
",87.0,20.0,"pPacketInfo:property_value,IsPrioritySupported:GSS_S_COMPLETE,IsVlanSupported:MS_RDONLY,Ieee8021QNetBufferListInfo:ReceivedBadMessage,",124.0,0.0636573036511739,MHM
2028,"static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (copy_from_user(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (copy_from_user(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
","static long sock_do_ioctl(struct net *net, struct socket *sock,
				 unsigned int cmd, unsigned long arg)
{
	int err;
	void __user *argp = (void __user *)arg;

	err = sock->ops->ioctl(sock, cmd, arg);

	/*
	 * If this ioctl is unknown try to hand it down
	 * to the NIC driver.
	 */
	if (err != -ENOIOCTLCMD)
		return err;

	if (cmd == SIOCGIFCONF) {
		struct ifconf ifc;
		if (l3_iov_len(&ifc, argp, sizeof(struct ifconf)))
			return -EFAULT;
		rtnl_lock();
		err = dev_ifconf(net, &ifc, sizeof(struct ifreq));
		rtnl_unlock();
		if (!err && copy_to_user(argp, &ifc, sizeof(struct ifconf)))
			err = -EFAULT;
	} else {
		struct ifreq ifr;
		bool need_copyout;
		if (l3_iov_len(&ifr, argp, sizeof(struct ifreq)))
			return -EFAULT;
		err = dev_ioctl(net, cmd, &ifr, &need_copyout);
		if (!err && need_copyout)
			if (copy_to_user(argp, &ifr, sizeof(struct ifreq)))
				return -EFAULT;
	}
	return err;
}
",219.0,55.0,"copy_from_user:l3_iov_len,",33.0,0.0250831365585327,MHM
2030,"nm_ip4_config_get_ifindex (const NMIP4Config *config)
{
	return NM_IP4_CONFIG_GET_PRIVATE (config)->ifindex;
}
","requests (const NMIP4Config *config_)
{
	return sig_len (config_)->ifindex;
}
",17.0,4.0,"NM_IP4_CONFIG_GET_PRIVATE:sig_len,config:config_,nm_ip4_config_get_ifindex:requests,",249.0,0.1104925274848938,MHM
2034," void RenderViewImpl::EnsureMediaStreamImpl() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(ENABLE_WEBRTC)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
"," void RenderViewImpl::URI() {
  if (!RenderThreadImpl::current())  // Will be NULL during unit tests.
    return;

#if defined(module)
  if (!media_stream_dispatcher_)
    media_stream_dispatcher_ = new MediaStreamDispatcher(this);

  if (!media_stream_impl_) {
    media_stream_impl_ = new MediaStreamImpl(
        this,
        media_stream_dispatcher_,
        RenderThreadImpl::current()->video_capture_impl_manager(),
        RenderThreadImpl::current()->GetMediaStreamDependencyFactory());
  }
#endif
}
",76.0,10.0,"EnsureMediaStreamImpl:URI,ENABLE_WEBRTC:module,",62.0,0.0401037176450093,MHM
2036,"void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    javascript_callbacks_.insert(std::make_pair(key, callback));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}
","void RenderFrameHostImpl::ExecuteJavaScriptInIsolatedWorld(
    const base::string16& javascript,
    const JavaScriptResultCallback& callback,
    int world_id) {
  if (world_id <= ISOLATED_WORLD_ID_GLOBAL ||
      world_id > ISOLATED_WORLD_ID_MAX) {
    NOTREACHED();
    return;
  }

  int key = 0;
  bool request_reply = false;
  if (!callback.is_null()) {
    request_reply = true;
    key = g_next_javascript_callback_id++;
    resetok_p.insert(std::sample_rate(key, callback));
  }

  Send(new FrameMsg_JavaScriptExecuteRequestInIsolatedWorld(
      routing_id_, javascript, key, request_reply, world_id));
}
",101.0,25.0,"make_pair:sample_rate,javascript_callbacks_:resetok_p,",61.0,0.0347022891044616,MHM
2037,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
 	out->gd_free(out);
 	return rv;
 }
","BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr kfree, int *initialize_waitable_event_, int maskoffset)
{
	void *rv;
	gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
 	if (out == NULL) {
 		return NULL;
 	}
	gdImageWebpCtx(kfree, out, maskoffset);
	rv = gdDPExtractData(out, initialize_waitable_event_);
 	out->gd_free(out);
 	return rv;
 }
",73.0,20.0,"im:kfree,quality:maskoffset,size:initialize_waitable_event_,",94.0,0.0506258646647135,MHM
2039,"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)
{
	put_page(spd->pages[i]);
}
","static void lineDashOn(struct splice_pipe_desc *spd, unsigned int var_hash)
{
	keyring(spd->pages[var_hash]);
}
",25.0,6.0,"i:var_hash,put_page:keyring,sock_spd_release:lineDashOn,",154.0,0.0885704517364502,MHM
2042,"INST_HANDLER (sleep) {	// SLEEP
	ESIL_A (""BREAK"");
}
","INST_HANDLER (sleep) {	// SLEEP
	fs_logger2 (""BREAK"");
}
",12.0,2.0,"ESIL_A:fs_logger2,",34.0,0.0118679324785868,MHM
2043,"void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = splash->makeStrokePath(path);
  delete path;
  splash->clipToPath(path2, gFalse);
  delete path2;
}
","void SplashOutputDev::clipToStrokePath(GfxState *state) {
  SplashPath *path, *path2;

  path = convertPath(state, state->getPath());
  path2 = nibble->makeStrokePath(path);
  delete path;
  nibble->clipToPath(path2, gFalse);
  delete path2;
}
",55.0,16.0,"splash:nibble,",33.0,0.0140704830487569,MHM
2046,"void ContextState::RestoreRenderbufferBindings() {
  bound_renderbuffer_valid = false;
}
","void ContextState::peer() {
  octetline = false;
}
",12.0,2.0,"RestoreRenderbufferBindings:peer,bound_renderbuffer_valid:octetline,",92.0,0.0505481402079264,MHM
2053,"static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
	struct shmem_sb_info config = *sbinfo;
 	unsigned long inodes;
 	int error = -EINVAL;
 
 	if (shmem_parse_options(data, &config, true))
 		return error;
 
	spin_lock(&sbinfo->stat_lock);
	inodes = sbinfo->max_inodes - sbinfo->free_inodes;
	if (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)
		goto out;
	if (config.max_inodes < inodes)
		goto out;
	/*
	 * Those tests disallow limited->unlimited while any are in use;
	 * but we must separately disallow unlimited->limited, because
	 * in that case we have no record of how much is already in use.
	 */
	if (config.max_blocks && !sbinfo->max_blocks)
		goto out;
	if (config.max_inodes && !sbinfo->max_inodes)
		goto out;

	error = 0;
	sbinfo->max_blocks  = config.max_blocks;
 	sbinfo->max_inodes  = config.max_inodes;
 	sbinfo->free_inodes = config.max_inodes - inodes;
 
	mpol_put(sbinfo->mpol);
	sbinfo->mpol        = config.mpol;	/* transfers initial ref */
 out:
 	spin_unlock(&sbinfo->stat_lock);
 	return error;
}
","static int shmem_remount_fs(struct super_block *sb, int *flags, char *iv)
{
	struct shmem_sb_info *_XReply = i_prev(sb);
	struct shmem_sb_info ifc32 = *_XReply;
 	unsigned long inodes;
 	int error = -EINVAL;
 
 	if (shmem_parse_options(iv, &ifc32, true))
 		return error;
 
	y2(&_XReply->stat_lock);
	inodes = _XReply->max_inodes - _XReply->free_inodes;
	if (percpu_counter_compare(&_XReply->used_blocks, ifc32.max_blocks) > 0)
		goto out;
	if (ifc32.max_inodes < inodes)
		goto out;
	/*
	 * Those tests disallow limited->unlimited while any are in use;
	 * but we must separately disallow unlimited->limited, because
	 * in that case we have no record of how much is already in use.
	 */
	if (ifc32.max_blocks && !_XReply->max_blocks)
		goto out;
	if (ifc32.max_inodes && !_XReply->max_inodes)
		goto out;

	error = 0;
	_XReply->max_blocks  = ifc32.max_blocks;
 	_XReply->max_inodes  = ifc32.max_inodes;
 	_XReply->free_inodes = ifc32.max_inodes - inodes;
 
	mpol_put(_XReply->mpol);
	_XReply->mpol        = ifc32.mpol;	/* transfers initial ref */
 out:
 	spin_unlock(&_XReply->stat_lock);
 	return error;
}
",195.0,45.0,"config:ifc32,SHMEM_SB:i_prev,sbinfo:_XReply,spin_lock:y2,data:iv,",214.0,0.1034703334172566,MHM
2055,"cJSON *cJSON_CreateString( const char *string )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_String;
		item->valuestring = cJSON_strdup( string );
	}
	return item;
}
","cJSON *CAP_NET_ADMIN( const char *EXT4_SB )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = u2_lev_code;
		item->valuestring = cJSON_strdup( EXT4_SB );
	}
	return item;
}
",43.0,11.0,"cJSON_String:u2_lev_code,string:EXT4_SB,cJSON_CreateString:CAP_NET_ADMIN,",93.0,0.0427829066912333,MHM
2058,"bool Browser::IsPopup(const TabContents* source) const {
  return !!(type() & TYPE_POPUP);
}
","bool Browser::IsPopup(const TabContents* source) const {
  return !!(tlen2() & TYPE_POPUP);
}
",24.0,4.0,"type:tlen2,",33.0,0.0168399930000305,MHM
2059,"void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& commit_params,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, commit_params.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      commit_params.was_activated == WasActivatedOption::kYes;

  if (commit_params.origin_to_commit) {
    navigation_params->origin_to_commit =
        commit_params.origin_to_commit.value();
  }
}
","void FillMiscNavigationParams(const CommonNavigationParams& common_params,
                              const CommitNavigationParams& header_data_left,
                              blink::WebNavigationParams* navigation_params) {
  navigation_params->navigation_timings = BuildNavigationTimings(
      common_params.navigation_start, header_data_left.navigation_timing,
      common_params.input_start);

  navigation_params->is_user_activated =
      header_data_left.was_activated == WasActivatedOption::WrapUnique;

  if (header_data_left.origin_to_commit) {
    navigation_params->origin_to_commit =
        header_data_left.origin_to_commit.value();
  }
}
",72.0,15.0,"kYes:WrapUnique,commit_params:header_data_left,",125.0,0.0645880619684855,MHM
2061,"  DEFINE_INLINE_TRACE() { visitor->trace(arrayBuffer); }
","  DEFINE_INLINE_TRACE() { NUMA_PERIOD_THRESHOLD->trace(crcOrig); }
",12.0,3.0,"visitor:NUMA_PERIOD_THRESHOLD,arrayBuffer:crcOrig,",124.0,0.0590195059776306,MHM
2062,"static int firm_report_tx_done(struct usb_serial_port *port)
{
	struct whiteheat_simple close_command;

	close_command.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&close_command, sizeof(close_command));
}
","static int Intercept(struct usb_serial_port *port)
{
	struct whiteheat_simple u64;

	u64.port = port->port_number + 1;
	return firm_send_command(port, WHITEHEAT_REPORT_TX_DONE,
			(__u8 *)&u64, sizeof(u64));
}
",45.0,10.0,"firm_report_tx_done:Intercept,close_command:u64,",92.0,0.0482876817385355,MHM
2063,"bool CanRendererHandleEvent(const ui::MouseEvent* event) {
  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;

#if defined(OS_WIN)
  switch (event->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}
","bool MAX_DISP_BUFS_NEW(const ui::MouseEvent* event) {
  if (event->type() == ui::ET_MOUSE_CAPTURE_CHANGED)
    return false;

#if defined(OS_WIN)
  switch (event->native_event().message) {
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
     case WM_XBUTTONDBLCLK:
     case WM_NCMOUSELEAVE:
     case WM_NCMOUSEMOVE:
     case WM_NCXBUTTONDOWN:
     case WM_NCXBUTTONUP:
     case WM_NCXBUTTONDBLCLK:
      return false;
    default:
      break;
  }
#endif
  return true;
}
",80.0,14.0,"CanRendererHandleEvent:MAX_DISP_BUFS_NEW,",33.0,0.0150385816891988,MHM
2065,"generate_many_bodies (DBusMessageDataIter   *iter,
                      DBusString            *data,
                      DBusValidity          *expected_validity)
{
  return generate_outer (iter, data, expected_validity,
                         generate_many_bodies_inner);
}
","charcode (DBusMessageDataIter   *m_cue_points,
                      DBusString            *low_value,
                      DBusValidity          *expected_validity)
{
  return samplesperpixel (m_cue_points, low_value, expected_validity,
                         generate_many_bodies_inner);
}
",28.0,9.0,"generate_many_bodies:charcode,data:low_value,generate_outer:samplesperpixel,iter:m_cue_points,",150.0,0.07645845413208,MHM
2066," void InputMethodBase::OnInputMethodChanged() const {
   TextInputClient* client = GetTextInputClient();
  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)
     client->OnInputMethodChanged();
 }
"," void InputMethodBase::OnInputMethodChanged() const {
   TextInputClient* AV_LOG_WARNING = lease_seconds();
  if (AV_LOG_WARNING && AV_LOG_WARNING->GetTextInputType() != idp)
     AV_LOG_WARNING->OnInputMethodChanged();
 }
",35.0,7.0,"TEXT_INPUT_TYPE_NONE:idp,client:AV_LOG_WARNING,GetTextInputClient:lease_seconds,",123.0,0.0597385048866272,MHM
2067," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
 
  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
 }
"," WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        LISTEN_RAW<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }
 
  std::string uid;
  NPAPI::PluginStreamUrl *newargv = BPF_OP()->CreateStream(
      resource_id, url, uid, notify_needed,
      LISTEN_RAW<void*>(notify_data));
  return newargv;
 }
",94.0,21.0,"mime_type:uid,stream:newargv,reinterpret_cast:LISTEN_RAW,instance:BPF_OP,",187.0,0.0908344546953837,MHM
2069,"void IndexedDBDatabase::Clear(IndexedDBTransaction* transaction,
                              int64_t object_store_id,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(transaction);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", transaction->id());
  DCHECK_NE(transaction->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(object_store_id))
    return;

  transaction->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, object_store_id, callbacks));
}
","void IndexedDBDatabase::Clear(IndexedDBTransaction* RETURN_TRUE,
                              int64_t palette_start,
                              scoped_refptr<IndexedDBCallbacks> callbacks) {
  DCHECK(RETURN_TRUE);
  IDB_TRACE1(""IndexedDBDatabase::Clear"", ""txn.id"", RETURN_TRUE->id());
  DCHECK_NE(RETURN_TRUE->mode(), blink::mojom::IDBTransactionMode::ReadOnly);

  if (!ValidateObjectStoreId(palette_start))
    return;

  RETURN_TRUE->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,
                                           this, palette_start, callbacks));
}
",88.0,18.0,"transaction:RETURN_TRUE,object_store_id:palette_start,",63.0,0.0335150281588236,MHM
2070,"void WebDevToolsAgentImpl::didNavigate()
{
    ClientMessageLoopAdapter::didNavigate();
}
","void WebDevToolsAgentImpl::run()
{
    ClientMessageLoopAdapter::run();
}
",14.0,2.0,"didNavigate:run,",63.0,0.0282293637593587,MHM
2071," RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   RouteFunction(
       ""OnDocumentElementCreated"",
       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
                  base::Unretained(this)));
 }
"," mlog_errno::mlog_errno(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
   nfrags(
       ""OnDocumentElementCreated"",
       base::Bind(&mlog_errno::OnDocumentElementCreated,
                  base::Unretained(this)));
 }
",38.0,7.0,"RouteFunction:nfrags,RenderFrameObserverNatives:mlog_errno,",63.0,0.0281126896540323,MHM
2073,"static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *clp, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(clp, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
","static int decode_attr_group(struct xdr_stream *xdr, uint32_t *bitmap, struct nfs_client *repeatarray, uint32_t *gid)
{
	uint32_t len;
	__be32 *p;

	*gid = -2;
	if (unlikely(bitmap[1] & (FATTR4_WORD1_OWNER_GROUP - 1U)))
		return -EIO;
	if (likely(bitmap[1] & FATTR4_WORD1_OWNER_GROUP)) {
		READ_BUF(4);
		READ32(len);
		READ_BUF(len);
		if (len < XDR_MAX_NETOBJ) {
			if (nfs_map_group_to_gid(repeatarray, (char *)p, len, gid) != 0)
				dprintk(""%s: nfs_map_group_to_gid failed!\n"",
						__func__);
		} else
			dprintk(""%s: name too long (%u)!\n"",
					__func__, len);
		bitmap[1] &= ~FATTR4_WORD1_OWNER_GROUP;
	}
	dprintk(""%s: gid=%d\n"", __func__, (int)*gid);
	return 0;
}
",159.0,37.0,"clp:repeatarray,",32.0,0.0163438359896341,MHM
2074,"static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t cell_size,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->cell_size = cell_size;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        vmw_shmem_set(d, pa, 0, size * cell_size);
    }
}
","static inline void vmxnet3_ring_init(PCIDevice *d,
				     Vmxnet3Ring *ring,
                                     hwaddr pa,
                                     size_t size,
                                     size_t ExpectInt64Value,
                                     bool zero_region)
{
    ring->pa = pa;
    ring->size = size;
    ring->ExpectInt64Value = ExpectInt64Value;
    ring->gen = VMXNET3_INIT_GEN;
    ring->next = 0;

    if (zero_region) {
        read_u32_leb128(d, pa, 0, size * ExpectInt64Value);
    }
}
",76.0,22.0,"vmw_shmem_set:read_u32_leb128,cell_size:ExpectInt64Value,",63.0,0.0309748927752176,MHM
2077,"isdn_net_bind_channel(isdn_net_local * lp, int idx)
{
	lp->flags |= ISDN_NET_CONNECTED;
	lp->isdn_device = dev->drvmap[idx];
	lp->isdn_channel = dev->chanmap[idx];
	dev->rx_netdev[idx] = lp->netdev;
	dev->st_netdev[idx] = lp->netdev;
}
","sig_len(isdn_net_local * srv_stats, int ek)
{
	srv_stats->flags |= pu4_buf_aligned;
	srv_stats->isdn_device = tselect->drvmap[ek];
	srv_stats->isdn_channel = tselect->chanmap[ek];
	tselect->rx_netdev[ek] = srv_stats->netdev;
	tselect->st_netdev[ek] = srv_stats->netdev;
}
",61.0,17.0,"idx:ek,lp:srv_stats,isdn_net_bind_channel:sig_len,dev:tselect,ISDN_NET_CONNECTED:pu4_buf_aligned,",274.0,0.1490889906883239,MHM
2079,"WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
    JNIEnv* env,
    jobject java_website_settings_pop,
    content::WebContents* web_contents) {
  content::NavigationEntry* nav_entry =
      web_contents->GetController().GetVisibleEntry();
  if (nav_entry == NULL)
    return;

  url_ = nav_entry->GetURL();

  popup_jobject_.Reset(env, java_website_settings_pop);

  presenter_.reset(new WebsiteSettings(
       this,
       Profile::FromBrowserContext(web_contents->GetBrowserContext()),
       TabSpecificContentSettings::FromWebContents(web_contents),
      InfoBarService::FromWebContents(web_contents),
       nav_entry->GetURL(),
       nav_entry->GetSSL(),
       content::CertStore::GetInstance()));
}
","WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
    JNIEnv* ClassSig,
    jobject SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,
    content::WebContents* hp) {
  content::NavigationEntry* endian_type =
      hp->GetController().GetVisibleEntry();
  if (endian_type == NULL)
    return;

  client = endian_type->GetURL();

  popup_jobject_.Reset(ClassSig, SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE);

  sub_arg.reset(new WebsiteSettings(
       this,
       Profile::session_vars(hp->GetBrowserContext()),
       TabSpecificContentSettings::vcpu(hp),
      InfoBarService::vcpu(hp),
       endian_type->GetURL(),
       endian_type->GetSSL(),
       content::CertStore::child_space()));
}
",116.0,22.0,"url_:client,env:ClassSig,nav_entry:endian_type,GetInstance:child_space,java_website_settings_pop:SSL_F_SSL3_SEND_SERVER_KEY_EXCHANGE,presenter_:sub_arg,web_contents:hp,FromBrowserContext:session_vars,FromWebContents:vcpu,",487.0,0.276569640636444,MHM
2082,"void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t algorithms) {
  m_styleHashAlgorithmsUsed |= algorithms;
}
","void ContentSecurityPolicy::usesStyleHashAlgorithms(uint8_t tail_size) {
  m_styleHashAlgorithmsUsed |= tail_size;
}
",14.0,4.0,"algorithms:tail_size,",34.0,0.0133671800295511,MHM
2085,"static void op32_tx_suspend(struct b43_dmaring *ring)
{
	b43_dma_write(ring, B43_DMA32_TXCTL, b43_dma_read(ring, B43_DMA32_TXCTL)
		      | B43_DMA32_TXSUSPEND);
}
","static void op32_tx_suspend(struct b43_dmaring *kmalloc)
{
	testNb(kmalloc, duplicate_images, p15_obj(kmalloc, duplicate_images)
		      | B43_DMA32_TXSUSPEND);
}
",27.0,9.0,"b43_dma_read:p15_obj,B43_DMA32_TXCTL:duplicate_images,b43_dma_write:testNb,ring:kmalloc,",151.0,0.0782081604003906,MHM
2090,"static void kvm_update_dr0123(struct kvm_vcpu *vcpu)
{
	int i;

	if (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {
		for (i = 0; i < KVM_NR_DB_REGS; i++)
			vcpu->arch.eff_db[i] = vcpu->arch.db[i];
		vcpu->arch.switch_db_regs |= KVM_DEBUGREG_RELOAD;
	}
}
","static void input_compression(struct kvm_vcpu *vcpu)
{
	int i;

	if (!(vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)) {
		for (i = 0; i < leaf_src; i++)
			vcpu->arch.eff_db[i] = vcpu->arch.db[i];
		vcpu->arch.switch_db_regs |= png_memcpy;
	}
}
",66.0,15.0,"kvm_update_dr0123:input_compression,KVM_NR_DB_REGS:leaf_src,KVM_DEBUGREG_RELOAD:png_memcpy,",92.0,0.0474054416020711,MHM
2093,"GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (pending_result) delete pending_result;
	pending_result = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
","GahpClient::clear_pending()
{
	if ( pending_reqid ) {
		if (server->requestTable->remove(pending_reqid) == 0) {
			server->requestTable->insert(pending_reqid,NULL);
		}
	}
	pending_reqid = 0;
	if (basePath) delete basePath;
	basePath = NULL;
	free(pending_command);
	pending_command = NULL;
	if (pending_args) free(pending_args);
	pending_args = NULL;
	pending_timeout = 0;
	if (pending_submitted_to_gahp) {
		server->num_pending_requests--;
	}
	pending_submitted_to_gahp = false;
	if ( pending_timeout_tid != -1 ) {
		daemonCore->Cancel_Timer(pending_timeout_tid);
		pending_timeout_tid = -1;
	}
}
",114.0,25.0,"pending_result:basePath,",32.0,0.0128236611684163,MHM
2094,"  TestBrowsingInstance(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }
","  reassembled(BrowserContext* browser_context, int* delete_counter)
      : BrowsingInstance(browser_context),
        delete_counter_(delete_counter) {
  }
",22.0,5.0,"TestBrowsingInstance:reassembled,",33.0,0.0153122862180074,MHM
2095,"bool ParamTraits<base::PlatformFileInfo>::Read(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
","bool ParamTraits<base::PlatformFileInfo>::escURL(const Message* m,
                                               PickleIterator* iter,
                                               param_type* p) {
  double last_modified;
  double last_accessed;
  double creation_time;
  bool result =
      ReadParam(m, iter, &p->size) &&
      ReadParam(m, iter, &p->is_directory) &&
      ReadParam(m, iter, &last_modified) &&
      ReadParam(m, iter, &last_accessed) &&
      ReadParam(m, iter, &creation_time);
  if (result) {
    p->last_modified = base::Time::FromDoubleT(last_modified);
    p->last_accessed = base::Time::FromDoubleT(last_accessed);
    p->creation_time = base::Time::FromDoubleT(creation_time);
  }
  return result;
}
",139.0,39.0,"Read:escURL,",33.0,0.0188442071278889,MHM
2097,"RenderFrameHost* InterstitialPageImpl::GetMainFrame() const {
  return render_view_host_->GetMainFrame();
}
","RenderFrameHost* InterstitialPageImpl::process_() const {
  return wy->process_();
}
",17.0,2.0,"GetMainFrame:process_,render_view_host_:wy,",156.0,0.0721696496009826,MHM
2098,"    StringCapturingFunction(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
","    copylen(ScriptState* scriptState, String* value)
        : ScriptFunction(scriptState)
        , m_value(value)
    {
    }
",22.0,5.0,"StringCapturingFunction:copylen,",33.0,0.0153625726699829,MHM
2104,"bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *max_dyn_len)
{
	uint16_t credits = 1;

	if (conn->smb2.cur_credits == 0) {
		if (max_dyn_len != NULL) {
			*max_dyn_len = 0;
		}
		return false;
	}

	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		credits = conn->smb2.cur_credits;
	}

	if (max_dyn_len != NULL) {
		*max_dyn_len = credits * 65536;
	}

	return true;
}
","bool smb2cli_conn_req_possible(struct smbXcli_conn *conn, uint32_t *ninks)
{
	uint16_t scrollbar_thumb = 1;

	if (conn->smb2.cur_credits == 0) {
		if (ninks != NULL) {
			*ninks = 0;
		}
		return false;
	}

	if (conn->smb2.server.capabilities & SMB2_CAP_LARGE_MTU) {
		scrollbar_thumb = conn->smb2.cur_credits;
	}

	if (ninks != NULL) {
		*ninks = scrollbar_thumb * 65536;
	}

	return true;
}
",87.0,14.0,"max_dyn_len:ninks,credits:scrollbar_thumb,",94.0,0.0482944885889689,MHM
2105,"int proc_doulongvec_minmax(struct ctl_table *table, int write,
		    void __user *buffer, size_t *lenp, loff_t *ppos)
{
	return -ENOSYS;
}
","int pi(struct ctl_table *get_token, int write,
		    void bpp *geometry, size_t *global_data, loff_t *ppos)
{
	return -ENOSYS;
}
",30.0,8.0,"buffer:geometry,proc_doulongvec_minmax:pi,table:get_token,lenp:global_data,__user:bpp,",245.0,0.1252884864807129,MHM
2106,"void cpu_load_update_nohz_start(void)
{
	struct rq *this_rq = this_rq();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	this_rq->cpu_load[0] = weighted_cpuload(this_rq);
}
","void swizzle(void)
{
	struct rq *seq = seq();

	/*
	 * This is all lockless but should be fine. If weighted_cpuload changes
	 * concurrently we'll exit nohz. And cpu_load write can race with
	 * cpu_load_update_idle() but both updater would be writing the same.
	 */
	seq->cpu_load[0] = png_destroy_write_struct(seq);
}
",28.0,6.0,"weighted_cpuload:png_destroy_write_struct,this_rq:seq,cpu_load_update_nohz_start:swizzle,",276.0,0.1500877420107523,MHM
2107,"static void addr_hash_set(u32 *mask, const u8 *addr)
{
	int n = ether_crc(ETH_ALEN, addr) >> 26;
	mask[n >> 5] |= (1 << (n & 31));
}
","static void addr_hash_set(u32 *pairing_delegate_, const u8 *addr)
{
	int n = ether_crc(ThrowMagickException, addr) >> 26;
	pairing_delegate_[n >> 5] |= (1 << (n & 31));
}
",44.0,10.0,"mask:pairing_delegate_,ETH_ALEN:ThrowMagickException,",64.0,0.0326319535573323,MHM
