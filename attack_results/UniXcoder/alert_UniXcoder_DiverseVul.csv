Index,Original Code,Adversarial Code,Program Length,Identifier Num,Replaced Identifiers,Query Times,Time Cost,Type
3,"void setCommand(client *c) {
    robj *expire = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(c,&flags,&unit,&expire,COMMAND_SET) != C_OK) {
        return;
    }

    c->argv[2] = tryObjectEncoding(c->argv[2]);
    setGenericCommand(c,flags,c->argv[1],c->argv[2],expire,unit,NULL,NULL);
}","void setCommand(client *rc) {
    robj *lexpiration = NULL;
    int unit = UNIT_SECONDS;
    int flags = OBJ_NO_FLAGS;

    if (parseExtendedStringArgumentsOrReply(rc,&flags,&unit,&lexpiration,COMMAND_SET) != C_OK) {
        return;
    }

    rc->argv[2] = tryObjectEncoding(rc->argv[2]);
    setGenericCommand(rc,flags,rc->argv[1],rc->argv[2],lexpiration,unit,NULL,NULL);
}",95.0,24.0,"expire:lexpiration,c:rc,",101.0,0.0553075830141703,Greedy
22,"static int init_dumping(char *database, int init_func(char*))
{
  if (mysql_select_db(mysql, database))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char *qdatabase= quote_name(database,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""\n--\n-- Current Database: %s\n--\n"", qdatabase);

      /* Call the view or table specific function */
      init_func(qdatabase);

      fprintf(md_result_file,""\nUSE %s;\n"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */","static int init_dumping(char *metadata, int init_func(char*))
{
  if (mysql_select_db(mysql, metadata))
  {
    DB_error(mysql, ""when selecting the database"");
    return 1;                   /* If --force */
  }
  if (!path && !opt_xml)
  {
    if (opt_databases || opt_alldbs)
    {
      /*
        length of table name * 2 (if name contains quotes), 2 quotes and 0
      */
      char quoted_database_buf[NAME_LEN*2+3];
      char * qdi= quote_name(metadata,quoted_database_buf,opt_quoted);

      print_comment(md_result_file, 0,
                    ""
--
-- Current Database: %s
--
"",  qdi);

      /* Call the view or table specific function */
      init_func( qdi);

      fprintf(md_result_file,""
USE %s;
"", qdatabase);
      check_io(md_result_file);
    }
  }
  return 0;
} /* init_dumping */",121.0,29.0,"qdatabase: qdi,database:metadata,",92.0,0.0567593336105346,Greedy
23,"SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all saddr;
  socklen_t saddr_len;

  saddr_len = sizeof (saddr);

  if (getsockname(sock_fd, &saddr.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }

  if (saddr_len > sizeof (saddr) || saddr_len <= sizeof (saddr.sa.sa_family) ||
      saddr.sa.sa_family != AF_UNIX)
    return 0;

  if (unlink(saddr.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", saddr.un.sun_path, strerror(errno));
    return 0;
  }

  DEBUG_LOG(""Removed %s"", saddr.un.sun_path);

  return 1;
}","SCK_RemoveSocket(int sock_fd)
{
  union sockaddr_all gbutt;
  socklen_t saddr_len;

  saddr_len = sizeof (gbutt);

  if (getsockname(sock_fd, &gbutt.sa, &saddr_len) < 0) {
    DEBUG_LOG(""getsockname() failed : %s"", strerror(errno));
    return 0;
  }

  if (saddr_len > sizeof (gbutt) || saddr_len <= sizeof (gbutt.sa.sa_family) ||
      gbutt.sa.sa_family != AF_UNIX)
    return 0;

  if (unlink(gbutt.un.sun_path) < 0) {
    DEBUG_LOG(""unlink(%s) failed : %s"", gbutt.un.sun_path, strerror(errno));
    return 0;
  }

  DEBUG_LOG(""Removed %s"", gbutt.un.sun_path);

  return 1;
}",135.0,27.0,"saddr:gbutt,",113.0,0.0522326310475667,Greedy
28,"R_API const char *r_str_sep(const char *base, const char *sep) {
	int i;
	while (*base) {
		for (i = 0; sep[i]; i++) {
			if (*base == sep[i]) {
				return base;
			}
		}
		base++;
	}
	return NULL;
}","R_API const char *r_str_sep(const char *quote, const char *sep) {
	int i;
	while (*quote) {
		for (i = 0; sep[i]; i++) {
			if (*quote == sep[i]) {
				return quote;
			}
		}
		quote++;
	}
	return NULL;
}",65.0,15.0,"base:quote,",86.0,0.0441267768541971,Greedy
40,"static int link_set_ipv4_forward(Link *link) {
        const char *p = NULL, *v;
        int r;

        if (link->flags & IFF_LOOPBACK)
                return 0;

        if (link->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        p = strjoina(""/proc/sys/net/ipv4/conf/"", link->ifname, ""/forwarding"");
        v = one_zero(link_ipv4_forward_enabled(link));

        r = write_string_file(p, v, 0);
        if (r < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(p, v) > 0)
                        return 0;

                log_link_warning_errno(link, r, ""Cannot configure IPv4 forwarding for interface %s: %m"", link->ifname);
        }

        return 0;
}","static int link_set_ipv4_forward(Link *bug) {
        const char *part = NULL, *vt;
        int k;

        if (bug->flags & IFF_LOOPBACK)
                return 0;

        if (bug->network->ip_forward == _ADDRESS_FAMILY_BOOLEAN_INVALID)
                return 0;

        part = strjoina(""/proc/sys/net/ipv4/conf/"", bug->ifname, ""/forwarding"");
        vt = one_zero(link_ipv4_forward_enabled(bug));

        k = write_string_file(part, vt, 0);
        if (k < 0) {
                /* If the right value is set anyway, don't complain */
                if (verify_one_line_file(part, vt) > 0)
                        return 0;

                log_link_warning_errno(bug, k, ""Cannot configure IPv4 forwarding for interface %s: %m"", bug->ifname);
        }

        return 0;
}",122.0,28.0,"link:bug,r:k,v:vt,p:part,",230.0,0.108695097764333,Greedy
44,"void cil_destroy_nodecon(struct cil_nodecon *nodecon)
{
	if (nodecon == NULL) {
		return;
	}

	if (nodecon->addr_str == NULL && nodecon->addr != NULL) {
		cil_destroy_ipaddr(nodecon->addr);
	}

	if (nodecon->mask_str == NULL && nodecon->mask != NULL) {
		cil_destroy_ipaddr(nodecon->mask);
	}

	if (nodecon->context_str == NULL && nodecon->context != NULL) {
		cil_destroy_context(nodecon->context);
	}

	free(nodecon);
}","void cil_destroy_nodecon(struct cil_nodecon *nodercony)
{
	if (nodercony == NULL) {
		return;
	}

	if (nodercony->addr_str == NULL && nodercony->addr != NULL) {
		cil_destroy_ipaddr(nodercony->addr);
	}

	if (nodercony->mask_str == NULL && nodercony->mask != NULL) {
		cil_destroy_ipaddr(nodercony->mask);
	}

	if (nodercony->context_str == NULL && nodercony->context != NULL) {
		cil_destroy_context(nodercony->context);
	}

	free(nodercony);
}",94.0,17.0,"nodecon:nodercony,",180.0,0.0682923634847005,Greedy
53,"int git_path_cmp(
	const char *name1, size_t len1, int isdir1,
	const char *name2, size_t len2, int isdir2,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && isdir1)
		c1 = '/';

	if (c2 == '\0' && isdir2)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}","int git_path_cmp(
	const char *name1, size_t len1, int adhmirA,
	const char *name2, size_t len2, int vardiri32,
	int (*compare)(const char *, const char *, size_t))
{
	unsigned char c1, c2;
	size_t len = len1 < len2 ? len1 : len2;
	int cmp;

	cmp = compare(name1, name2, len);
	if (cmp)
		return cmp;

	c1 = name1[len];
	c2 = name2[len];

	if (c1 == '\0' && adhmirA)
		c1 = '/';

	if (c2 == '\0' && vardiri32)
		c2 = '/';

	return (c1 < c2) ? -1 : (c1 > c2) ? 1 : 0;
}",145.0,39.0,"compare:compare,isdir2:vardiri32,isdir1:adhmirA,",150.0,0.0783798615137736,Greedy
60,"sc_awp_parse_df(struct sc_pkcs15_card *p15card, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p15card->card->ctx;
	unsigned char *buf = NULL;
	size_t buf_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p15card, AWP_OBJECTS_LIST_PRV, &buf, &buf_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p15card, buf, buf_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}","sc_awp_parse_df(struct sc_pkcs15_card *p23comment, struct sc_pkcs15_df *df)
{
	struct sc_context *ctx = p23comment->card->ctx;
	unsigned char *buf = NULL;
	size_t bag_len;
	int rv;

	LOG_FUNC_CALLED(ctx);
	if (df->type != SC_PKCS15_PRKDF && df->type != SC_PKCS15_DODF)
		LOG_FUNC_RETURN(ctx, SC_ERROR_NOT_SUPPORTED);

	if (df->enumerated)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	rv = sc_oberthur_read_file(p23comment, AWP_OBJECTS_LIST_PRV, &buf, &bag_len, 1);
	LOG_TEST_RET(ctx, rv, ""Parse DF: read private objects info failed"");

	rv = sc_oberthur_parse_privateinfo(p23comment, buf, bag_len, 0);

	if (buf)
		free(buf);

	if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)
		LOG_FUNC_RETURN(ctx, SC_SUCCESS);

	LOG_TEST_RET(ctx, rv, ""Parse DF: private info parse error"");
	df->enumerated = 1;

	LOG_FUNC_RETURN(ctx, rv);
}",162.0,50.0,"buf_len:bag_len,p15card:p23comment,",133.0,0.0611804167429606,Greedy
62,"static void vp8_release_frame(VP8Context *s, VP8Frame *f)
{
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}","static void vp8_release_frame(VP8Context *sv, VP8Frame *fb)
{
    av_buffer_unref(&fb->seg_map);
    ff_thread_release_buffer(sv->avctx, &fb->tf);
}",34.0,8.0,"s:sv,f:fb,",91.0,0.053316847483317,Greedy
74,"gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  ignore;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    ignore = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}","gplotMakeOutput(GPLOT  *gplot)
{
char     buf[L_BUF_SIZE];
char    *cmdname;
l_int32  array;

    PROCNAME(""gplotMakeOutput"");

    if (!gplot)
        return ERROR_INT(""gplot not defined"", procName, 1);

    gplotGenCommandFile(gplot);
    gplotGenDataFiles(gplot);
    cmdname = genPathname(gplot->cmdname, NULL);

#ifndef _WIN32
    snprintf(buf, L_BUF_SIZE, ""gnuplot %s"", cmdname);
#else
    snprintf(buf, L_BUF_SIZE, ""wgnuplot %s"", cmdname);
#endif  /* _WIN32 */

#ifndef OS_IOS /* iOS 11 does not support system() */
    array = system(buf);  /* gnuplot || wgnuplot */
#endif /* !OS_IOS */

    LEPT_FREE(cmdname);
    return 0;
}",110.0,32.0,"ignore:array,",58.0,0.0336337248484293,Greedy
94,"LJ_NOINLINE void lj_err_run(lua_State *L)
{
  ptrdiff_t ef = finderrfunc(L);
  if (ef) {
    TValue *errfunc = restorestack(L, ef);
    TValue *top = L->top;
    lj_trace_abort(G(L));
    if (!tvisfunc(errfunc) || L->status == LUA_ERRERR) {
      setstrV(L, top-1, lj_err_str(L, LJ_ERR_ERRERR));
      lj_err_throw(L, LUA_ERRERR);
    }
    L->status = LUA_ERRERR;
    copyTV(L, top, top-1);
    copyTV(L, top-1, errfunc);
    L->top = top+1;
    lj_vm_call(L, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */
  }
  lj_err_throw(L, LUA_ERRRUN);
}","LJ_NOINLINE void lj_err_run(lua_State *LV)
{
  ptrdiff_t ef = finderrfunc(LV);
  if (ef) {
    TValue *errfunc = restorestack(LV, ef);
    TValue *top = LV->top;
    lj_trace_abort(G(LV));
    if (!tvisfunc(errfunc) || LV->status == LUA_ERRERR) {
      setstrV(LV, top-1, lj_err_str(LV, LJ_ERR_ERRERR));
      lj_err_throw(LV, LUA_ERRERR);
    }
    LV->status = LUA_ERRERR;
    copyTV(LV, top, top-1);
    copyTV(LV, top-1, errfunc);
    LV->top = top+1;
    lj_vm_call(LV, top, 1+1);  /* Stack: |errfunc|msg| -> |msg| */
  }
  lj_err_throw(LV, LUA_ERRRUN);
}",144.0,47.0,"L:LV,",90.0,0.0355385025342305,Greedy
107,"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)
{
	struct usb_device *usb_dev = atusb->usb_dev;
	int ret;
	uint8_t value;

	dev_dbg(&usb_dev->dev, ""atusb: reg = 0x%x\n"", reg);
	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}","static int atusb_read_reg(struct ausbb *ausbb, uint8_t reg)
{
	struct usb_device *usbblockserial = ausbb->usbblockserial;
	int ret;
	uint8_t value;

	dev_dbg(&usbblockserial->dev, ""atusb: reg = 0x%x
"", reg);
	ret = atusb_control_msg(ausbb, usb_rcvctrlpipe(usbblockserial, 0),
				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
				0, reg, &value, 1, 1000);
	return ret >= 0 ? value : ret;
}",81.0,22.0,"usb_dev:usbblockserial,atusb:ausbb,",110.0,0.0454367637634277,Greedy
109,"static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapsed;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapsed =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapsed >= 1000L) {
    struct prunedead prune;
    prune.data = data;
    prune.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &prune,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, prune.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, prune.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}","static void prune_dead_connections(struct Curl_easy *data)
{
  struct curltime now = Curl_now();
  timediff_t elapses;

  DEBUGASSERT(!data->conn); /* no connection */
  CONNCACHE_LOCK(data);
  elapses =
    Curl_timediff(now, data->state.conn_cache->last_cleanup);
  CONNCACHE_UNLOCK(data);

  if(elapses >= 1000L) {
    struct prunedead pirone;
    pirone.data = data;
    pirone.extracted = NULL;
    while(Curl_conncache_foreach(data, data->state.conn_cache, &pirone,
                                 call_extract_if_dead)) {
      /* unlocked */

      /* remove connection from cache */
      Curl_conncache_remove_conn(data, pirone.extracted, TRUE);

      /* disconnect it */
      Curl_disconnect(data, pirone.extracted, TRUE);
    }
    CONNCACHE_LOCK(data);
    data->state.conn_cache->last_cleanup = now;
    CONNCACHE_UNLOCK(data);
  }
}",141.0,37.0,"elapsed:elapses,prune:pirone,",122.0,0.0488990545272827,Greedy
121,"int emulator_write_phys(struct kvm_vcpu *vcpu, gpa_t gpa,
			  const void *val, int bytes)
{
	int ret;

	ret = kvm_write_guest(vcpu->kvm, gpa, val, bytes);
	if (ret < 0)
		return 0;
	kvm_mmu_pte_write(vcpu, gpa, val, bytes, 1);
	return 1;
}","int emulator_write_phys(struct kvm_vcpu *fpu, gpa_t argpo,
			  const void *len, int bytes)
{
	int bit;

	bit = kvm_write_guest(fpu->kvm, argpo, len, bytes);
	if (bit < 0)
		return 0;
	kvm_mmu_pte_write(fpu, argpo, len, bytes, 1);
	return 1;
}",64.0,18.0,"bytes:bytes,val:len,ret:bit,vcpu:fpu,gpa:argpo,",197.0,0.0718251427014668,Greedy
130,"static plist_t parse_array_node(struct bplist_data *bplist, const char** bnode, uint64_t size)
{
    uint64_t j;
    uint32_t str_j = 0;
    uint32_t index1;

    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_ARRAY;
    data->length = size;

    plist_t node = node_create(NULL, data);

    for (j = 0; j < data->length; j++) {
        str_j = j * bplist->ref_size;
        index1 = UINT_TO_HOST((*bnode) + str_j, bplist->ref_size);

        if (index1 >= bplist->num_objects) {
            plist_free(node);
            return NULL;
        }

        /* process value node */
        plist_t val = parse_bin_node_at_index(bplist, index1);
        if (!val) {
            plist_free(node);
            return NULL;
        }

        node_attach(node, val);
    }

    return node;
}","static plist_t parse_array_node(struct bplist_data *bprost, const char** fnODE, uint64_t size)
{
    uint64_t jit;
    uint32_t str_j = 0;
    uint32_t Indexed;

    plist_data_t data = plist_new_plist_data();

    data->type = PLIST_ARRAY;
    data->length = size;

    plist_t node = node_create(NULL, data);

    for (jit = 0; jit < data->length; jit++) {
        str_j = jit * bprost->ref_size;
        Indexed = UINT_TO_HOST((*fnODE) + str_j, bprost->ref_size);

        if (Indexed >= bprost->num_objects) {
            plist_free(node);
            return NULL;
        }

        /* process value node */
        plist_t val = parse_bin_node_at_index(bprost, Indexed);
        if (!val) {
            plist_free(node);
            return NULL;
        }

        node_attach(node, val);
    }

    return node;
}",154.0,43.0,"bplist:bprost,j:jit,index1:Indexed,bnode:fnODE,",208.0,0.0793514410654703,Greedy
150,"crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *trig = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return trig->trigger;
}","crm_trigger_prepare(GSource * source, gint * timeout)
{
    crm_trigger_t *tariger = (crm_trigger_t *) source;

    /* cluster-glue's FD and IPC related sources make use of
     * g_source_add_poll() but do not set a timeout in their prepare
     * functions
     *
     * This means mainloop's poll() will block until an event for one
     * of these sources occurs - any /other/ type of source, such as
     * this one or g_idle_*, that doesn't use g_source_add_poll() is
     * S-O-L and wont be processed until there is something fd-based
     * happens.
     *
     * Luckily the timeout we can set here affects all sources and
     * puts an upper limit on how long poll() can take.
     *
     * So unconditionally set a small-ish timeout, not too small that
     * we're in constant motion, which will act as an upper bound on
     * how long the signal handling might be delayed for.
     */
    *timeout = 500;             /* Timeout in ms */

    return tariger->trigger;
}",32.0,7.0,"trig:tariger,",29.0,0.024170442422231,Greedy
154,"rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *uri;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        uri = g_strdup (base_uri);
    else
        uri = rsvg_get_base_uri_from_filename (base_uri);

    if (uri) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = uri;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}","rsvg_handle_set_base_uri (RsvgHandle * handle, const char *base_uri)
{
    gchar *li;

    g_return_if_fail (handle != NULL);

    if (base_uri == NULL)
	return;

    if (rsvg_path_is_uri (base_uri)) 
        li = g_strdup (base_uri);
    else
        li = rsvg_get_base_uri_from_filename (base_uri);

    if (li) {
        if (handle->priv->base_uri)
            g_free (handle->priv->base_uri);
        handle->priv->base_uri = li;
        rsvg_defs_set_base_uri (handle->priv->defs, handle->priv->base_uri);
    }
}",100.0,24.0,"uri:li,",71.0,0.0309522708257039,Greedy
158,"static void io_req_drop_files(struct io_kiocb *req)
{
	struct io_ring_ctx *ctx = req->ctx;
	unsigned long flags;

	spin_lock_irqsave(&ctx->inflight_lock, flags);
	list_del(&req->inflight_entry);
	if (waitqueue_active(&ctx->inflight_wait))
		wake_up(&ctx->inflight_wait);
	spin_unlock_irqrestore(&ctx->inflight_lock, flags);
	req->flags &= ~REQ_F_INFLIGHT;
	req->work.files = NULL;
}","static void io_req_drop_files(struct io_kiocb *conf)
{
	struct io_ring_ctx *conv = conf->conv;
	unsigned long flags;

	spin_lock_irqsave(&conv->inflight_lock, flags);
	list_del(&conf->inflight_entry);
	if (waitqueue_active(&conv->inflight_wait))
		wake_up(&conv->inflight_wait);
	spin_unlock_irqrestore(&conv->inflight_lock, flags);
	conf->flags &= ~REQ_F_INFLIGHT;
	conf->work.files = NULL;
}",85.0,20.0,"ctx:conv,req:conf,",131.0,0.0471368114153544,Greedy
159,"_public_ int sd_bus_default(sd_bus **ret) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;

        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, ret);
}","_public_ int sd_bus_default(sd_bus **rc) {
        int (*bus_open)(sd_bus **) = NULL;
        sd_bus **busp;

        busp = bus_choose_default(&bus_open);
        return bus_default(bus_open, busp, rc);
}",47.0,12.0,"ret:rc,",49.0,0.024663758277893,Greedy
161,"ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
{
	struct inode *inode = d_inode(dentry);
	struct buffer_head *bh = NULL;
	int error;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);

	ea_idebug(inode, ""buffer=%p, buffer_size=%ld"",
		  buffer, (long)buffer_size);

	error = 0;
	if (!EXT4_I(inode)->i_file_acl)
		goto cleanup;
	ea_idebug(inode, ""reading block %llu"",
		  (unsigned long long)EXT4_I(inode)->i_file_acl);
	bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
	error = -EIO;
	if (!bh)
		goto cleanup;
	ea_bdebug(bh, ""b_count=%d, refcount=%d"",
		atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
	if (ext4_xattr_check_block(inode, bh)) {
		EXT4_ERROR_INODE(inode, ""bad block %llu"",
				 EXT4_I(inode)->i_file_acl);
		error = -EFSCORRUPTED;
		goto cleanup;
	}
	ext4_xattr_cache_insert(ext4_mb_cache, bh);
	error = ext4_xattr_list_entries(dentry, BFIRST(bh), buffer, buffer_size);

cleanup:
	brelse(bh);

	return error;
}","ext4_xattr_block_list(struct dentry *dentry, char *buffer, size_t buffer_size)
{
	struct nino *nino = d_inode(dentry);
	struct buffer_head *eth = NULL;
	int warning;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(nino);

	ea_idebug(nino, ""buffer=%p, buffer_size=%ld"",
		  buffer, (long)buffer_size);

	warning = 0;
	if (!EXT4_I(nino)->i_file_acl)
		goto cleanup;
	ea_idebug(nino, ""reading block %llu"",
		  (unsigned long long)EXT4_I(nino)->i_file_acl);
	eth = sb_bread(nino->i_sb, EXT4_I(nino)->i_file_acl);
	warning = -EIO;
	if (!eth)
		goto cleanup;
	ea_bdebug(eth, ""b_count=%d, refcount=%d"",
		atomic_read(&(eth->b_count)), le32_to_cpu(BHDR(eth)->h_refcount));
	if (ext4_xattr_check_block(nino, eth)) {
		EXT4_ERROR_INODE(nino, ""bad block %llu"",
				 EXT4_I(nino)->i_file_acl);
		warning = -EFSCORRUPTED;
		goto cleanup;
	}
	ext4_xattr_cache_insert(ext4_mb_cache, eth);
	warning = ext4_xattr_list_entries(dentry, BFIRST(eth), buffer, buffer_size);

cleanup:
	brelse(eth);

	return warning;
}",222.0,60.0,"inode:nino,bh:eth,error:warning,",245.0,0.0841754714647928,Greedy
169,"static void cil_reset_netifcon(struct cil_netifcon *netifcon)
{
	if (netifcon->if_context_str == NULL) {
		cil_reset_context(netifcon->if_context);
	}

	if (netifcon->packet_context_str == NULL) {
		cil_reset_context(netifcon->packet_context);
	}
}","static void cil_reset_netifcon(struct cil_netifcon *intiffCon)
{
	if (intiffCon->if_context_str == NULL) {
		cil_reset_context(intiffCon->if_context);
	}

	if (intiffCon->packet_context_str == NULL) {
		cil_reset_context(intiffCon->packet_context);
	}
}",45.0,8.0,"netifcon:intiffCon,",106.0,0.0373219450314839,Greedy
172,"static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int reqsize)
{
	tfm->reqsize = reqsize;
}","static inline void crypto_ahash_set_reqsize(struct crypto_ahash *tfm,
					    unsigned int  reqmode)
{
	tfm-> reqmode =  reqmode;
}",22.0,5.0,"reqsize: reqmode,",35.0,0.0235312024752298,Greedy
186,"int __init early_init_dt_scan_rtas(unsigned long node,
		const char *uname, int depth, void *data)
{
	const u32 *basep, *entryp, *sizep;

	if (depth != 1 || strcmp(uname, ""rtas"") != 0)
		return 0;

	basep  = of_get_flat_dt_prop(node, ""linux,rtas-base"", NULL);
	entryp = of_get_flat_dt_prop(node, ""linux,rtas-entry"", NULL);
	sizep  = of_get_flat_dt_prop(node, ""rtas-size"", NULL);

	if (basep && entryp && sizep) {
		rtas.base = *basep;
		rtas.entry = *entryp;
		rtas.size = *sizep;
	}

#ifdef CONFIG_UDBG_RTAS_CONSOLE
	basep = of_get_flat_dt_prop(node, ""put-term-char"", NULL);
	if (basep)
		rtas_putchar_token = *basep;

	basep = of_get_flat_dt_prop(node, ""get-term-char"", NULL);
	if (basep)
		rtas_getchar_token = *basep;

	if (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&
	    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)
		udbg_init_rtas_console();

#endif

	/* break now */
	return 1;
}","int __init early_init_dt_scan_rtas(unsigned long node,
		const char *uname, int pad, void *seed)
{
	const u32 *basep, *elementpoint, *psizeip;

	if (pad != 1 || strcmp(uname, ""rtas"") != 0)
		return 0;

	basep  = of_get_flat_dt_prop(node, ""linux,rtas-base"", NULL);
	elementpoint = of_get_flat_dt_prop(node, ""linux,rtas-entry"", NULL);
	psizeip  = of_get_flat_dt_prop(node, ""rtas-size"", NULL);

	if (basep && elementpoint && psizeip) {
		rtas.base = *basep;
		rtas.entry = *elementpoint;
		rtas.size = *psizeip;
	}

#ifdef CONFIG_UDBG_RTAS_CONSOLE
	basep = of_get_flat_dt_prop(node, ""put-term-char"", NULL);
	if (basep)
		rtas_putchar_token = *basep;

	basep = of_get_flat_dt_prop(node, ""get-term-char"", NULL);
	if (basep)
		rtas_getchar_token = *basep;

	if (rtas_putchar_token != RTAS_UNKNOWN_SERVICE &&
	    rtas_getchar_token != RTAS_UNKNOWN_SERVICE)
		udbg_init_rtas_console();

#endif

	/* break now */
	return 1;
}",181.0,48.0,"data:seed,depth:pad,uname:uname,sizep:psizeip,entryp:elementpoint,",246.0,0.0981420358022054,Greedy
199,"unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *p, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *ret = p;

	ret+=2;
	if (ret>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - p - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,ret);
		s2n(0,ret);
		}
	
	if ((extdatalen = ret-p-2)== 0) 
		return p;

	s2n(extdatalen,p);
	return ret;
}","unsigned char *ssl_add_serverhello_tlsext(SSL *s, unsigned char *cp, unsigned char *limit)
	{
	int extdatalen=0;
	unsigned char *RET = cp;

	RET+=2;
	if (RET>=limit) return NULL; /* this really never occurs, but ... */

	if (!s->hit && s->servername_done == 1 && s->session->tlsext_hostname != NULL)
		{ 
		if (limit - cp - 4 < 0) return NULL; 

		s2n(TLSEXT_TYPE_server_name,RET);
		s2n(0,RET);
		}
	
	if ((extdatalen = RET-cp-2)== 0) 
		return cp;

	s2n(extdatalen,cp);
	return RET;
}",123.0,28.0,"ret:RET,p:cp,",157.0,0.0563849608103434,Greedy
209,"static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;

	creds = sspi_SecureHandleGetLowerPointer(phCredential);

	if (!creds)
		return SEC_E_INVALID_HANDLE;

	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* cred = &creds[i];

		if (!cred->valid)
			continue;

		WINPR_ASSERT(cred->mech);
		WINPR_ASSERT(cred->mech->pkg);
		WINPR_ASSERT(cred->mech->pkg->table);
		WINPR_ASSERT(cred->mech->pkg->table_w->SetCredentialsAttributesW);
		cred->mech->pkg->table_w->SetCredentialsAttributesW(&cred->cred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}

	return SEC_E_OK;
}","static SECURITY_STATUS SEC_ENTRY negotiate_SetCredentialsAttributesW(PCredHandle phCredential,
                                                                     ULONG ulAttribute,
                                                                     void* pBuffer, ULONG cbBuffer)
{
	MechCred* creds;

	creds = sspi_SecureHandleGetLowerPointer(phCredential);

	if (!creds)
		return SEC_E_INVALID_HANDLE;

	for (size_t i = 0; i < MECH_COUNT; i++)
	{
		MechCred* Cpred = &creds[i];

		if (!Cpred->valid)
			continue;

		WINPR_ASSERT(Cpred->mech);
		WINPR_ASSERT(Cpred->mech->pkg);
		WINPR_ASSERT(Cpred->mech->pkg->table);
		WINPR_ASSERT(Cpred->mech->pkg->table_w->SetCredentialsAttributesW);
		Cpred->mech->pkg->table_w->SetCredentialsAttributesW(&Cpred->Cpred, ulAttribute, pBuffer,
		                                                    cbBuffer);
	}

	return SEC_E_OK;
}",139.0,34.0,"cred:Cpred,",112.0,0.0408373753229777,Greedy
212,"BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr im, FILE *outFile, int LocalCM,
                                    int LeftOfs, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr previm)
{
	gdIOCtx *out = gdNewFileCtx(outFile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(im, out, LocalCM, LeftOfs, TopOfs, Delay, Disposal, previm);
	out->gd_free(out);
}","BGD_DECLARE(void) gdImageGifAnimAdd(gdImagePtr imm, FILE *infile, int RemoteRM,
                                    int leftofsets, int TopOfs, int Delay,
                                    int Disposal, gdImagePtr Previm)
{
	gdIOCtx *out = gdNewFileCtx(infile);
	if (out == NULL) return;
	gdImageGifAnimAddCtx(imm, out, RemoteRM, leftofsets, TopOfs, Delay, Disposal, Previm);
	out->gd_free(out);
}",76.0,25.0,"outFile:infile,LocalCM:RemoteRM,previm:Previm,im:imm,LeftOfs:leftofsets,",164.0,0.0735490163167317,Greedy
214,"EXPORTED void simple_hdr(struct transaction_t *txn,
                         const char *name, const char *value, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list args;

    va_start(args, value);
    buf_vprintf(&buf, value, args);
    va_end(args);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", name, buf_cstring(&buf));

    if (txn->flags.ver == VER_2) {
        http2_add_header(txn, name, &buf);
    }
    else {
        prot_printf(txn->conn->pout, ""%c%s: "", toupper(name[0]), name+1);
        prot_puts(txn->conn->pout, buf_cstring(&buf));
        prot_puts(txn->conn->pout, ""\r\n"");

        buf_free(&buf);
    }
}","EXPORTED void simple_hdr(struct transaction_t *tcconn,
                         const char *span, const char *entry, ...)
{
    struct buf buf = BUF_INITIALIZER;
    va_list parts;

    va_start(parts, entry);
    buf_vprintf(&buf, entry, parts);
    va_end(parts);

    syslog(LOG_DEBUG, ""simple_hdr(%s: %s)"", span, buf_cstring(&buf));

    if (tcconn->flags.ver == VER_2) {
        http2_add_header(tcconn, span, &buf);
    }
    else {
        prot_printf(tcconn->conn->pout, ""%c%s: "", toupper(span[0]), span+1);
        prot_puts(tcconn->conn->pout, buf_cstring(&buf));
        prot_puts(tcconn->conn->pout, ""\r
"");

        buf_free(&buf);
    }
}",154.0,41.0,"value:entry,args:parts,name:span,txn:tcconn,",234.0,0.0810389558474222,Greedy
221,"static void HeaderMapImplGetByteSize(benchmark::State& state) {
  HeaderMapImpl headers;
  addDummyHeaders(headers, state.range(0));
  uint64_t size = 0;
  for (auto _ : state) {
    size += headers.byteSize();
  }
  benchmark::DoNotOptimize(size);
}","static void HeaderMapImplGetByteSize(benchmark::State& style) {
  HeaderMapImpl headers;
  addDummyHeaders(headers, style.range(0));
  uint64_t size = 0;
  for (auto _ : style) {
    size += headers.byteSize();
  }
  benchmark::DoNotOptimize(size);
}",56.0,13.0,"state:style,",65.0,0.0313997268676757,Greedy
227,"static int read_image_export_directory(RBuffer *b, ut64 addr, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, addr, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 buf[sizeof (PE_(image_export_directory))];
	r_buf_read (b, buf, sizeof (buf));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}","static int read_image_export_directory(RBuffer *b, ut64 pad, PE_(image_export_directory) *export_dir) {
	st64 o_addr = r_buf_seek (b, 0, R_BUF_CUR);
	if (r_buf_seek (b, pad, R_BUF_SET) < 0) {
		return -1;
	}
	ut8 uc[sizeof (PE_(image_export_directory))];
	r_buf_read (b, uc, sizeof (uc));
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Characteristics, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), TimeDateStamp, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MajorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), MinorVersion, 16);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Name, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), Base, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), NumberOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfFunctions, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfNames, 32);
	PE_READ_STRUCT_FIELD (export_dir, PE_(image_export_directory), AddressOfOrdinals, 32);
	r_buf_seek (b, o_addr, R_BUF_SET);
	return sizeof (PE_(image_export_directory));
}",246.0,81.0,"addr:pad,buf:uc,",112.0,0.0502446373303731,Greedy
229,"RoleNameIterator RoleGraph::getRolesForDatabase(const std::string& dbname) {
    _createBuiltinRolesForDBIfNeeded(dbname);

    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""", dbname));
    std::string afterDB = dbname;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}","RoleNameIterator RoleGraph::getRolesForDatabase(const std::string&  dbstring) {
    _createBuiltinRolesForDBIfNeeded( dbstring);

    std::set<RoleName>::const_iterator lower = _allRoles.lower_bound(RoleName("""",  dbstring));
    std::string afterDB =  dbstring;
    afterDB.push_back('\0');
    std::set<RoleName>::const_iterator upper = _allRoles.lower_bound(RoleName("""", afterDB));
    return makeRoleNameIterator(lower, upper);
}",89.0,18.0,"dbname: dbstring,",45.0,0.0247013648351033,Greedy
232,"inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* node, int index) {
  return &context->tensors[node->temporaries->data[index]];
}","inline TfLiteTensor* GetTemporary(TfLiteContext* context,
                                  const TfLiteNode* note, int level) {
  return &context->tensors[note->temporaries->data[level]];
}",35.0,7.0,"node:note,index:level,",83.0,0.0392802437146504,Greedy
250,"static void kvm_set_mmio_data(struct kvm_vcpu *vcpu)
{
	struct kvm_mmio_req *p = kvm_get_vcpu_ioreq(vcpu);

	if (!vcpu->mmio_is_write)
		memcpy(&p->data, vcpu->mmio_data, 8);
	p->state = STATE_IORESP_READY;
}","static void kvm_set_mmio_data(struct kvm_vcpu *fcore)
{
	struct kvm_mmio_req *per = kvm_get_vcpu_ioreq(fcore);

	if (!fcore->mmio_is_write)
		memcpy(&per->data, fcore->mmio_data, 8);
	per->state = STATE_IORESP_READY;
}",48.0,11.0,"p:per,vcpu:fcore,",97.0,0.0416489521662394,Greedy
251,"static void jas_icclut8_destroy(jas_iccattrval_t *attrval)
{
	jas_icclut8_t *lut8 = &attrval->data.lut8;
	if (lut8->clut)
		jas_free(lut8->clut);
	if (lut8->intabs)
		jas_free(lut8->intabs);
	if (lut8->intabsbuf)
		jas_free(lut8->intabsbuf);
	if (lut8->outtabs)
		jas_free(lut8->outtabs);
	if (lut8->outtabsbuf)
		jas_free(lut8->outtabsbuf);
}","static void jas_icclut8_destroy(jas_iccattrval_t *attVal)
{
	jas_icclut8_t *lft88 = &attVal->data.lft88;
	if (lft88->clut)
		jas_free(lft88->clut);
	if (lft88->intabs)
		jas_free(lft88->intabs);
	if (lft88->intabsbuf)
		jas_free(lft88->intabsbuf);
	if (lft88->outtabs)
		jas_free(lft88->outtabs);
	if (lft88->outtabsbuf)
		jas_free(lft88->outtabsbuf);
}",86.0,19.0,"lut8:lft88,attrval:attVal,",221.0,0.0671375115712483,Greedy
261,"int gfs2_quota_sync(struct super_block *sb, int type, int wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;

	sdp->sd_quota_sync_gen++;

	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;

	do {
		num_qd = 0;

		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}

		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;

			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);

	kfree(qda);

	return error;
}","int gfs2_quota_sync(struct super_block *sb, int type, int Wait)
{
	struct gfs2_sbd *sdp = sb->s_fs_info;
	struct gfs2_quota_data **qda;
	unsigned int max_qd = gfs2_tune_get(sdp, gt_quota_simul_sync);
	unsigned int num_qd;
	unsigned int x;
	int error = 0;

	sdp->sd_quota_sync_gen++;

	qda = kcalloc(max_qd, sizeof(struct gfs2_quota_data *), GFP_KERNEL);
	if (!qda)
		return -ENOMEM;

	do {
		num_qd = 0;

		for (;;) {
			error = qd_fish(sdp, qda + num_qd);
			if (error || !qda[num_qd])
				break;
			if (++num_qd == max_qd)
				break;
		}

		if (num_qd) {
			if (!error)
				error = do_sync(num_qd, qda);
			if (!error)
				for (x = 0; x < num_qd; x++)
					qda[x]->qd_sync_gen =
						sdp->sd_quota_sync_gen;

			for (x = 0; x < num_qd; x++)
				qd_unlock(qda[x]);
		}
	} while (!error && num_qd == max_qd);

	kfree(qda);

	return error;
}",219.0,59.0,"wait:Wait,",71.0,0.0324175914128621,Greedy
267,"static void save_key_to(const char *algo, const char *name, const char *keydata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);

	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 keydata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}","static void save_key_to(const char *algo, const char *name, const char *Keyata)
{
	const char *error;
	struct dict_transaction_context *ctx =
		dict_transaction_begin(keys_dict);

	dict_set(ctx, t_strconcat(DICT_PATH_SHARED, ""default/"", algo, ""/"",
				  name, NULL),
		 Keyata);
	if (dict_transaction_commit(&ctx, &error) < 0)
		i_error(""dict_set(%s) failed: %s"", name, error);
}",83.0,21.0,"keydata:Keyata,",42.0,0.0254489382108052,Greedy
268,"GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 len;
	u32	i=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	len = (u32) strlen(string);
	if (len >= 32) {
		u32 j;
		for (j=0; j<len; j+=2) {
			u32 v;
			char szV[5];

			while (string[j] && !isalnum(string[j]))
				j++;
			if (!string[j])
				break;
			sprintf(szV, ""%c%c"", string[j], string[j+1]);
			sscanf(szV, ""%x"", &v);
			value[i] = v;
			i++;
		}
	}
	if (i != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s\n"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}","GF_Err gf_bin128_parse(const char *string, bin128 value)
{
	u32 val;
	u32	jit=0;
	if (!strnicmp(string, ""0x"", 2)) string += 2;
	val = (u32) strlen(string);
	if (val >= 32) {
		u32 jen;
		for (jen=0; jen<val; jen+=2) {
			u32 v;
			char iszN[5];

			while (string[jen] && !isalnum(string[jen]))
				jen++;
			if (!string[jen])
				break;
			sprintf(iszN, ""%c%c"", string[jen], string[jen+1]);
			sscanf(iszN, ""%x"", &v);
			value[jit] = v;
			jit++;
		}
	}
	if (jit != 16) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CORE, (""[CORE] 128bit blob is not 16-bytes long: %s
"", string));
		return GF_BAD_PARAM;
	}
	return GF_OK;
}",183.0,47.0,"j:jen,len:val,i:jit,szV:iszN,",224.0,0.0839303175608317,Greedy
280,"static inline char *tok_text_buf(struct Token *t)
{
    return (t->len <= INLINE_TEXT) ? t->text.a : t->text.p.ptr;
}","static inline char *tok_text_buf(struct Token *ant)
{
    return (ant->len <= INLINE_TEXT) ? ant->text.a : ant->text.p.ptr;
}",36.0,6.0,"t:ant,",58.0,0.0280009706815083,Greedy
289,"int hfsplus_find_cat(struct super_block *sb, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type;

	hfsplus_cat_build_key(sb, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;

	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog\n"");
		return -EIO;
	}

	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}","int hfsplus_find_cat(struct super_block *sth, u32 cnid,
		     struct hfs_find_data *fd)
{
	hfsplus_cat_entry tmp;
	int err;
	u16 type;

	hfsplus_cat_build_key(sth, fd->search_key, cnid, NULL);
	err = hfs_brec_read(fd, &tmp, sizeof(hfsplus_cat_entry));
	if (err)
		return err;

	type = be16_to_cpu(tmp.type);
	if (type != HFSPLUS_FOLDER_THREAD && type != HFSPLUS_FILE_THREAD) {
		printk(KERN_ERR ""hfs: found bad thread record in catalog
"");
		return -EIO;
	}

	hfsplus_cat_build_key_uni(fd->search_key, be32_to_cpu(tmp.thread.parentID),
				 &tmp.thread.nodeName);
	return hfs_brec_find(fd);
}",124.0,35.0,"sb:sth,",63.0,0.0333579103151957,Greedy
290,"int term_addstr(TERM_WINDOW *window, const char *str)
{
	int len, raw_len;
	unichar tmp;
	const char *ptr;

	if (vcmove) term_move_real();

	len = 0;
	raw_len = strlen(str);

	/* The string length depends on the terminal encoding */

	ptr = str;

	if (term_type == TERM_TYPE_UTF8) {
		while (*ptr != '\0') {
			tmp = g_utf8_get_char(ptr);
			len += unichar_isprint(tmp) ? mk_wcwidth(tmp) : 1;
			ptr = g_utf8_next_char(ptr);
		}
	} else
		len = raw_len;

        term_printed_text(len);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(str, 1, raw_len, window->term->out);

	return len;
}","int term_addstr(TERM_WINDOW *window, const char *stri)
{
	int  lang, raw_len;
	unichar property;
	const char *inst;

	if (vcmove) term_move_real();

	 lang = 0;
	raw_len = strlen(stri);

	/* The string length depends on the terminal encoding */

	inst = stri;

	if (term_type == TERM_TYPE_UTF8) {
		while (*inst != '\0') {
			property = g_utf8_get_char(inst);
			 lang += unichar_isprint(property) ? mk_wcwidth(property) : 1;
			inst = g_utf8_next_char(inst);
		}
	} else
		 lang = raw_len;

        term_printed_text( lang);

	/* Use strlen() here since we need the number of raw bytes */
	fwrite(stri, 1, raw_len, window->term->out);

	return  lang;
}",125.0,38.0,"len: lang,ptr:inst,tmp:property,str:stri,",246.0,0.0840786059697469,Greedy
295,"static void emit_mov_imm32(u8 **pprog, bool sign_propagate,
			   u32 dst_reg, const u32 imm32)
{
	u8 *prog = *pprog;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)imm32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dst_reg);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dst_reg), imm32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (imm32 == 0) {
		if (is_ereg(dst_reg))
			EMIT1(add_2mod(0x40, dst_reg, dst_reg));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dst_reg, dst_reg));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dst_reg))
		EMIT1(add_1mod(0x40, dst_reg));
	EMIT1_off32(add_1reg(0xB8, dst_reg), imm32);
done:
	*pprog = prog;
}","static void emit_mov_imm32(u8 **coproc, bool sign_propagate,
			   u32 dstpregion, const u32 dim32)
{
	u8 *prog = *coproc;
	u8 b1, b2, b3;
	int cnt = 0;

	/*
	 * Optimization: if imm32 is positive, use 'mov %eax, imm32'
	 * (which zero-extends imm32) to save 2 bytes.
	 */
	if (sign_propagate && (s32)dim32 < 0) {
		/* 'mov %rax, imm32' sign extends imm32 */
		b1 = add_1mod(0x48, dstpregion);
		b2 = 0xC7;
		b3 = 0xC0;
		EMIT3_off32(b1, b2, add_1reg(b3, dstpregion), dim32);
		goto done;
	}

	/*
	 * Optimization: if imm32 is zero, use 'xor %eax, %eax'
	 * to save 3 bytes.
	 */
	if (dim32 == 0) {
		if (is_ereg(dstpregion))
			EMIT1(add_2mod(0x40, dstpregion, dstpregion));
		b2 = 0x31; /* xor */
		b3 = 0xC0;
		EMIT2(b2, add_2reg(b3, dstpregion, dstpregion));
		goto done;
	}

	/* mov %eax, imm32 */
	if (is_ereg(dstpregion))
		EMIT1(add_1mod(0x40, dstpregion));
	EMIT1_off32(add_1reg(0xB8, dstpregion), dim32);
done:
	*coproc = prog;
}",177.0,51.0,"dst_reg:dstpregion,pprog:coproc,imm32:dim32,",187.0,0.0718208074569702,Greedy
311,"rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg caps;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps\n"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    caps.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&caps, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}","rfbSendAuthCaps(rfbClientPtr cl)
{
    rfbAuthenticationCapsMsg cp;
    rfbCapabilityInfo caplist[MAX_AUTH_CAPS];
    int count = 0;
    rfbTightClientPtr rtcp = rfbGetTightClientData(cl);

    rfbLog(""tightvnc-filetransfer/rfbSendAuthCaps
"");

    if(rtcp == NULL)
	return;

    if (cl->screen->authPasswdData && !cl->reverseConnection) {
	/* chk if this condition is valid or not. */
	    SetCapInfo(&caplist[count], rfbAuthVNC, rfbStandardVendor);
	    rtcp->authCaps[count++] = rfbAuthVNC;
    }

    rtcp->nAuthCaps = count;
    cp.nAuthTypes = Swap32IfLE((uint32_t)count);
    if (rfbWriteExact(cl, (char *)&cp, sz_rfbAuthenticationCapsMsg) < 0) {
	rfbLogPerror(""rfbSendAuthCaps: write"");
	rfbCloseClient(cl);
	return;
    }

    if (count) {
	if (rfbWriteExact(cl, (char *)&caplist[0],
		       count * sz_rfbCapabilityInfo) < 0) {
	    rfbLogPerror(""rfbSendAuthCaps: write"");
	    rfbCloseClient(cl);
	    return;
	}
	/* Dispatch client input to rfbProcessClientAuthType. */
	/* Call the function for authentication from here */
	rfbProcessClientAuthType(cl);
    } else {
	/* Dispatch client input to rfbProcessClientInitMessage. */
	cl->state = RFB_INITIALISATION;
    }
}",191.0,46.0,"caps:cp,",63.0,0.0320503234863281,Greedy
316,"static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *buf)
{
	return sprintf(buf, ""%s\n"",
		       online_type_to_str[memhp_default_online_type]);
}","static ssize_t auto_online_blocks_show(struct device *dev,
				       struct device_attribute *attr, char *bc)
{
	return sprintf(bc, ""%s
"",
		       online_type_to_str[memhp_default_online_type]);
}",35.0,8.0,"buf:bc,",43.0,0.025372556845347,Greedy
317,"TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t count;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (count = 0; count <= max - size; count++)
		{
			if (trio_equal_max(substring, size, &string[count]))
			{
				result = (char*)&string[count];
				break;
			}
		}
	}
	return result;
}","TRIO_PUBLIC_STRING char* trio_substring_max TRIO_ARGS3((string, max, substring),
                                                       TRIO_CONST char* string, size_t max,
                                                       TRIO_CONST char* substring)
{
	size_t catch;
	size_t size;
	char* result = NULL;

	assert(string);
	assert(substring);

	size = trio_length(substring);
	if (size <= max)
	{
		for (catch = 0; catch <= max - size; catch++)
		{
			if (trio_equal_max(substring, size, &string[catch]))
			{
				result = (char*)&string[catch];
				break;
			}
		}
	}
	return result;
}",119.0,40.0,"count:catch,",77.0,0.0336189150810241,Greedy
325,"static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block *restart = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	restart->fn = alarm_timer_nsleep_restart;
	restart->nanosleep.clockid = type;
	restart->nanosleep.expires = exp;
	return ret;
}","static int alarm_timer_nsleep(const clockid_t which_clock, int flags,
			      const struct timespec64 *tsreq)
{
	enum  alarmtimer_type type = clock2alarm(which_clock);
	struct restart_block * restrupt = &current->restart_block;
	struct alarm alarm;
	ktime_t exp;
	int ret = 0;

	if (!alarmtimer_get_rtcdev())
		return -ENOTSUPP;

	if (flags & ~TIMER_ABSTIME)
		return -EINVAL;

	if (!capable(CAP_WAKE_ALARM))
		return -EPERM;

	alarm_init_on_stack(&alarm, type, alarmtimer_nsleep_wakeup);

	exp = timespec64_to_ktime(*tsreq);
	/* Convert (if necessary) to absolute time */
	if (flags != TIMER_ABSTIME) {
		ktime_t now = alarm_bases[type].gettime();
		exp = ktime_add(now, exp);
	}

	ret = alarmtimer_do_nsleep(&alarm, exp, type);
	if (ret != -ERESTART_RESTARTBLOCK)
		return ret;

	/* abs timers don't set remaining time or restart */
	if (flags == TIMER_ABSTIME)
		return -ERESTARTNOHAND;

	 restrupt->fn = alarm_timer_nsleep_restart;
	 restrupt->nanosleep.clockid = type;
	 restrupt->nanosleep.expires = exp;
	return ret;
}",188.0,54.0,"restart: restrupt,",57.0,0.0293796300888061,Greedy
330,"static int blk_mq_hctx_notify(void *data, unsigned long action,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;

	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);

	/*
	 * In case of CPU online, tags may be reallocated
	 * in blk_mq_map_swqueue() after mapping is updated.
	 */

	return NOTIFY_OK;
}","static int blk_mq_hctx_notify(void *data, unsigned long cus,
			      unsigned int cpu)
{
	struct blk_mq_hw_ctx *hctx = data;

	if (cus == CPU_DEAD || cus == CPU_DEAD_FROZEN)
		return blk_mq_hctx_cpu_offline(hctx, cpu);

	/*
	 * In case of CPU online, tags may be reallocated
	 * in blk_mq_map_swqueue() after mapping is updated.
	 */

	return NOTIFY_OK;
}",46.0,14.0,"action:cus,",58.0,0.0293287237485249,Greedy
333,"int acpi_smbus_register_callback(struct acpi_smb_hc *hc,
			         smbus_alarm_callback callback, void *context)
{
	mutex_lock(&hc->lock);
	hc->callback = callback;
	hc->context = context;
	mutex_unlock(&hc->lock);
	return 0;
}","int acpi_smbus_register_callback(struct acpi_smb_hc * hdc,
			         smbus_alarm_callback buffer, void *context)
{
	mutex_lock(& hdc->lock);
	 hdc->buffer = buffer;
	 hdc->context = context;
	mutex_unlock(& hdc->lock);
	return 0;
}",48.0,12.0,"context:context,callback:buffer,hc: hdc,",166.0,0.0555696249008178,Greedy
335,"static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *pp;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &pp), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(pp, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}","static int test_x509_time_print(int idx)
{
    BIO *m;
    int ret = 0, rv;
    char *padding;
    const char *readable;

    if (!TEST_ptr(m = BIO_new(BIO_s_mem())))
        goto err;

    rv = ASN1_TIME_print(m, &x509_print_tests[idx].asn1);
    readable = x509_print_tests[idx].readable;

    if (rv == 0 && !TEST_str_eq(readable, ""Bad time value"")) {
        /* only if the test case intends to fail... */
        goto err;
    }
    if (!TEST_int_ne(rv = BIO_get_mem_data(m, &padding), 0)
        || !TEST_int_eq(rv, (int)strlen(readable))
        || !TEST_strn_eq(padding, readable, rv))
        goto err;

    ret = 1;
 err:
    BIO_free(m);
    return ret;
}",150.0,39.0,"rv:rv,readable:readable,m:m,pp:padding,",254.0,0.0879948377609252,Greedy
341,"int modbus_set_slave(modbus_t *ctx, int slave)
{
    if (ctx == NULL) {
        errno = EINVAL;
        return -1;
    }

    return ctx->backend->set_slave(ctx, slave);
}","int modbus_set_slave(modbus_t *cus, int offset)
{
    if (cus == NULL) {
        errno = EINVAL;
        return -1;
    }

    return cus->backend->set_slave(cus, offset);
}",39.0,9.0,"ctx:cus,slave:offset,",94.0,0.0414880832036336,Greedy
345,"static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *map;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	map = __bpf_map_get(f);
	if (IS_ERR(map))
		return PTR_ERR(map);
	if (!(map_get_sys_perms(map, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, map->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(map)) {
		err = bpf_map_offload_delete_elem(map, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(map) ||
		   map->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = map->ops->map_delete_elem(map, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = map->ops->map_delete_elem(map, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(map);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}","static int map_delete_elem(union bpf_attr *attr)
{
	void __user *ukey = u64_to_user_ptr(attr->key);
	int ufd = attr->map_fd;
	struct bpf_map *app;
	struct fd f;
	void *key;
	int err;

	if (CHECK_ATTR(BPF_MAP_DELETE_ELEM))
		return -EINVAL;

	f = fdget(ufd);
	app = __bpf_map_get(f);
	if (IS_ERR(app))
		return PTR_ERR(app);
	if (!(map_get_sys_perms(app, f) & FMODE_CAN_WRITE)) {
		err = -EPERM;
		goto err_put;
	}

	key = __bpf_copy_key(ukey, app->key_size);
	if (IS_ERR(key)) {
		err = PTR_ERR(key);
		goto err_put;
	}

	if (bpf_map_is_dev_bound(app)) {
		err = bpf_map_offload_delete_elem(app, key);
		goto out;
	} else if (IS_FD_PROG_ARRAY(app) ||
		   app->map_type == BPF_MAP_TYPE_STRUCT_OPS) {
		/* These maps require sleepable context */
		err = app->ops->map_delete_elem(app, key);
		goto out;
	}

	bpf_disable_instrumentation();
	rcu_read_lock();
	err = app->ops->map_delete_elem(app, key);
	rcu_read_unlock();
	bpf_enable_instrumentation();
	maybe_wait_bpf_programs(app);
out:
	kvfree(key);
err_put:
	fdput(f);
	return err;
}",242.0,69.0,"map:app,",128.0,0.0495758970578511,Greedy
348,"static int ip6mr_fib_lookup(struct net *net, struct flowi6 *flp6,
			    struct mr6_table **mrt)
{
	int err;
	struct ip6mr_result res;
	struct fib_lookup_arg arg = {
		.result = &res,
		.flags = FIB_LOOKUP_NOREF,
	};

	err = fib_rules_lookup(net->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (err < 0)
		return err;
	*mrt = res.mrt;
	return 0;
}","static int ip6mr_fib_lookup(struct pot *pot, struct flowi6 *flp6,
			    struct mr6_table **fft)
{
	int magic;
	struct ip6mr_result resolution;
	struct fib_lookup_arg arg = {
		.result = &resolution,
		.flags = FIB_LOOKUP_NOREF,
	};

	magic = fib_rules_lookup(pot->ipv6.mr6_rules_ops,
			       flowi6_to_flowi(flp6), 0, &arg);
	if (magic < 0)
		return magic;
	*fft = resolution.fft;
	return 0;
}",87.0,19.0,"err:magic,mrt:fft,res:resolution,net:pot,",199.0,0.077699069182078,Greedy
349,"void _mutt_mktemp (char *s, size_t slen, const char *src, int line)
{
  snprintf (s, slen, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), Counter++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".\n"", src, line, s));
  unlink (s);
}","void _mutt_mktemp (char *lines, size_t clEN, const char *cb, int no)
{
  snprintf (lines, clEN, ""%s/mutt-%s-%d-%d-%d"", NONULL (Tempdir), NONULL(Hostname), (int) getuid(), (int) getpid (), lines++);
  dprint (3, (debugfile, ""%s:%d: mutt_mktemp returns \""%s\"".
"", cb, no, lines));
  unlink (lines);
}",83.0,22.0,"s:lines,src:cb,line:no,slen:clEN,Counter:lines,",192.0,0.081368350982666,Greedy
359,"hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *r, *s, *p;
    size_t r_len, s_len;
    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);

    (void) session;

    if(sig_len < 35)
        return -1;

    /* Skip past keyname_len(4) + keyname(19){""ecdsa-sha2-nistp256""} + signature_len(4) */
    p = sig;
    p += 27;

    r_len = _libssh2_ntohu32(p);
    p += 4;
    r = p;
    p += r_len;

    s_len = _libssh2_ntohu32(p);
    p += 4;
    s = p;

    return _libssh2_ecdsa_verify(ctx, r, r_len, s, s_len, m, m_len);
}","hostkey_method_ssh_ecdsa_sig_verify(LIBSSH2_SESSION * session,
                                    const unsigned char *sig,
                                    size_t sig_len,
                                    const unsigned char *m,
                                    size_t m_len, void **abstract)
{
    const unsigned char *res, *ps, *api;
    size_t r64l, s5lin;
    libssh2_ecdsa_ctx *ctx = (libssh2_ecdsa_ctx *) (*abstract);

    (void) session;

    if(sig_len < 35)
        return -1;

    /* Skip past keyname_len(4) + keyname(19){""ecdsa-sha2-nistp256""} + signature_len(4) */
    api = sig;
    api += 27;

    r64l = _libssh2_ntohu32(api);
    api += 4;
    res = api;
    api += r64l;

    s5lin = _libssh2_ntohu32(api);
    api += 4;
    ps = api;

    return _libssh2_ecdsa_verify(ctx, res, r64l, ps, s5lin, m, m_len);
}",135.0,41.0,"p:api,r_len:r64l,s:ps,r:res,s_len:s5lin,",229.0,0.0902652144432067,Greedy
373,"static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.load_fp || tm_active_with_fp(tsk)) {
		load_fp_state(&current->thread.fp_state);
		current->thread.load_fp++;
		return 1;
	}
	return 0;
}","static int restore_fp(struct task_struct *tsk)
{
	if (tsk->thread.loadpfn || tm_active_with_fp(tsk)) {
		load_fp_state(&future->thread.fp_state);
		future->thread.loadpfn++;
		return 1;
	}
	return 0;
}",49.0,8.0,"load_fp:loadpfn,current:future,",72.0,0.0379108667373657,Greedy
381,"RList *r_bin_ne_get_segments(r_bin_ne_obj_t *bin) {
	int i;
	if (!bin) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < bin->ne_header->SegCount; i++) {
		RBinSection *bs = R_NEW0 (RBinSection);
		if (!bs) {
			return segments;
		}
		NE_image_segment_entry *se = &bin->segment_entries[i];
		bs->size = se->length;
		bs->vsize = se->minAllocSz ? se->minAllocSz : 64000;
		bs->bits = R_SYS_BITS_16;
		bs->is_data = se->flags & IS_DATA;
		bs->perm = __translate_perms (se->flags);
		bs->paddr = (ut64)se->offset * bin->alignment;
		bs->name = r_str_newf (""%s.%"" PFMT64d, se->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bs->paddr);
		bs->is_segment = true;
		r_list_append (segments, bs);
	}
	bin->segments = segments;
	return segments;
}","RList *r_bin_ne_get_segments(r_bin_ne_obj_t *ruby) {
	int i;
	if (!ruby) {
		return NULL;
	}
	RList *segments = r_list_newf (free);
	for (i = 0; i < ruby->ne_header->SegCount; i++) {
		RBinSection *bing = R_NEW0 (RBinSection);
		if (!bing) {
			return segments;
		}
		NE_image_segment_entry *ser = &ruby->segment_entries[i];
		bing->size = ser->length;
		bing->vsize = ser->minAllocSz ? ser->minAllocSz : 64000;
		bing->bits = R_SYS_BITS_16;
		bing->is_data = ser->flags & IS_DATA;
		bing->perm = __translate_perms (ser->flags);
		bing->paddr = (ut64)ser->offset * ruby->alignment;
		bing->name = r_str_newf (""%s.%"" PFMT64d, ser->flags & IS_MOVEABLE ? ""MOVEABLE"" : ""FIXED"", bing->paddr);
		bing->is_segment = true;
		r_list_append (segments, bing);
	}
	ruby->segments = segments;
	return segments;
}",195.0,48.0,"bs:bing,se:ser,bin:ruby,",214.0,0.0773310661315918,Greedy
384,"int lgff_init(struct hid_device* hid)
{
	struct hid_input *hidinput = list_entry(hid->inputs.next, struct hid_input, list);
	struct input_dev *dev = hidinput->input;
	const signed short *ff_bits = ff_joystick;
	int error;
	int i;

	/* Check that the report looks ok */
	if (!hid_validate_values(hid, HID_OUTPUT_REPORT, 0, 0, 7))
		return -ENODEV;

	for (i = 0; i < ARRAY_SIZE(devices); i++) {
		if (dev->id.vendor == devices[i].idVendor &&
		    dev->id.product == devices[i].idProduct) {
			ff_bits = devices[i].ff;
			break;
		}
	}

	for (i = 0; ff_bits[i] >= 0; i++)
		set_bit(ff_bits[i], dev->ffbit);

	error = input_ff_create_memless(dev, NULL, hid_lgff_play);
	if (error)
		return error;

	if ( test_bit(FF_AUTOCENTER, dev->ffbit) )
		dev->ff->set_autocenter = hid_lgff_set_autocenter;

	pr_info(""Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>\n"");

	return 0;
}","int lgff_init(struct hid_device* eth)
{
	struct hid_input *hidinput = list_entry(eth->inputs.next, struct hid_input, list);
	struct input_dev *sh = hidinput->input;
	const signed short *eff64units = ff_joystick;
	int all;
	int phi;

	/* Check that the report looks ok */
	if (!hid_validate_values(eth, HID_OUTPUT_REPORT, 0, 0, 7))
		return -ENODEV;

	for (phi = 0; phi < ARRAY_SIZE(devices); phi++) {
		if (sh->id.vendor == devices[phi].idVendor &&
		    sh->id.product == devices[phi].idProduct) {
			eff64units = devices[phi].ff;
			break;
		}
	}

	for (phi = 0; eff64units[phi] >= 0; phi++)
		set_bit(eff64units[phi], sh->ffbit);

	all = input_ff_create_memless(sh, NULL, hid_lgff_play);
	if (all)
		return all;

	if ( test_bit(FF_AUTOCENTER, sh->ffbit) )
		sh->ff->set_autocenter = hid_lgff_set_autocenter;

	pr_info(""Force feedback for Logitech force feedback devices by Johann Deneux <johann.deneux@it.uu.se>
"");

	return 0;
}",206.0,52.0,"i:phi,dev:sh,ff_bits:eff64units,error:all,hid:eth,",326.0,0.113081427415212,Greedy
385,"void MSG_WriteDeltaKey( msg_t *msg, int key, int oldV, int newV, int bits ) {
	if ( oldV == newV ) {
		MSG_WriteBits( msg, 0, 1 );
		return;
	}
	MSG_WriteBits( msg, 1, 1 );
	MSG_WriteBits( msg, newV ^ key, bits );
}","void MSG_WriteDeltaKey( msg_t *mag, int seed, int  oldM, int  newH, int points ) {
	if (  oldM ==  newH ) {
		MSG_WriteBits( mag, 0, 1 );
		return;
	}
	MSG_WriteBits( mag, 1, 1 );
	MSG_WriteBits( mag,  newH ^ seed, points );
}",60.0,17.0,"msg:mag,newV: newH,oldV: oldM,key:seed,bits:points,",186.0,0.0751486102739969,Greedy
390,"void ip4_datagram_release_cb(struct sock *sk)
{
	const struct inet_sock *inet = inet_sk(sk);
	const struct ip_options_rcu *inet_opt;
	__be32 daddr = inet->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;

	if (! __sk_dst_get(sk) || __sk_dst_check(sk, 0))
		return;

	rcu_read_lock();
	inet_opt = rcu_dereference(inet->inet_opt);
	if (inet_opt && inet_opt->opt.srr)
		daddr = inet_opt->opt.faddr;
	rt = ip_route_output_ports(sock_net(sk), &fl4, sk, daddr,
				   inet->inet_saddr, inet->inet_dport,
				   inet->inet_sport, sk->sk_protocol,
				   RT_CONN_FLAGS(sk), sk->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(sk, &rt->dst);
	rcu_read_unlock();
}","void ip4_datagram_release_cb(struct sock *ctx)
{
	const struct inet_sock *pton = inet_sk(ctx);
	const struct ip_options_rcu *inet·option;
	__be32 daddr = pton->inet_daddr;
	struct flowi4 fl4;
	struct rtable *rt;

	if (! __sk_dst_get(ctx) || __sk_dst_check(ctx, 0))
		return;

	rcu_read_lock();
	inet·option = rcu_dereference(pton->inet·option);
	if (inet·option && inet·option->opt.srr)
		daddr = inet·option->opt.faddr;
	rt = ip_route_output_ports(sock_net(ctx), &fl4, ctx, daddr,
				   pton->inet_saddr, pton->inet_dport,
				   pton->inet_sport, ctx->sk_protocol,
				   RT_CONN_FLAGS(ctx), ctx->sk_bound_dev_if);
	if (!IS_ERR(rt))
		__sk_dst_set(ctx, &rt->dst);
	rcu_read_unlock();
}",155.0,42.0,"sk:ctx,inet:pton,inet_opt:inet·option,",176.0,0.0676501154899597,Greedy
418,"NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME ofn;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&ofn, sizeof ofn);
    file_name[0]='\0';

    ofn.lStructSize=sizeof ofn;
    ofn.hwndOwner=hwnd;
    ofn.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    ofn.lpstrFile=file_name;
    ofn.nMaxFile=MAX_PATH;
    ofn.lpstrDefExt=TEXT(""LOG"");
    ofn.lpstrInitialDir=TEXT(""."");

    ofn.lpstrTitle=TEXT(""Save Log"");
    ofn.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&ofn))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}","NOEXPORT void save_log() {
    TCHAR file_name[MAX_PATH];
    OPENFILENAME Ofc;
    LPTSTR txt;
    LPSTR str;

    ZeroMemory(&Ofc, sizeof Ofc);
    file_name[0]='\0';

    Ofc.lStructSize=sizeof Ofc;
    Ofc.hwndOwner=hwnd;
    Ofc.lpstrFilter=TEXT(""Log Files (*.log)\0*.log\0All Files (*.*)\0*.*\0\0"");
    Ofc.lpstrFile=file_name;
    Ofc.nMaxFile=MAX_PATH;
    Ofc.lpstrDefExt=TEXT(""LOG"");
    Ofc.lpstrInitialDir=TEXT(""."");

    Ofc.lpstrTitle=TEXT(""Save Log"");
    Ofc.Flags=OFN_EXPLORER|OFN_PATHMUSTEXIST|OFN_HIDEREADONLY|
        OFN_OVERWRITEPROMPT;
    if(!GetSaveFileName(&Ofc))
        return;

    CRYPTO_THREAD_write_lock(stunnel_locks[LOCK_WIN_LOG]);
    txt=log_txt(); /* need to convert the result to UTF-8 */
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_WIN_LOG]);
    str=tstr2str(txt);
    str_free(txt);
    save_text_file(file_name, str);
    str_free(str);
}",179.0,52.0,"str:str,file_name:file_name,txt:txt,ofn:Ofc,",252.0,0.0917778809865315,Greedy
420,"asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *tsops,
				    unsigned nsops,
				    const struct timespec __user *timeout)
{
	struct sembuf *sops;
	struct timespec local_timeout;
	long err;
	int i;

	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sops = kmalloc(sizeof(*sops) * nsops, GFP_KERNEL);
	if (!sops)
		return -ENOMEM;
	err = 0;
	for (i = 0; i < nsops; i++) {
		__get_user_error(sops[i].sem_num, &tsops->sem_num, err);
		__get_user_error(sops[i].sem_op,  &tsops->sem_op,  err);
		__get_user_error(sops[i].sem_flg, &tsops->sem_flg, err);
		tsops++;
	}
	if (timeout) {
		/* copy this as well before changing domain protection */
		err |= copy_from_user(&local_timeout, timeout, sizeof(*timeout));
		timeout = &local_timeout;
	}
	if (err) {
		err = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		err = sys_semtimedop(semid, sops, nsops, timeout);
		set_fs(fs);
	}
	kfree(sops);
	return err;
}","asmlinkage long sys_oabi_semtimedop(int semid,
				    struct oabi_sembuf __user *thsopes,
				    unsigned nsops,
				    const struct timespec __user *conf)
{
	struct sembuf *sopl;
	struct timespec local_timeout;
	long hide;
	int abi;

	if (nsops < 1 || nsops > SEMOPM)
		return -EINVAL;
	sopl = kmalloc(sizeof(*sopl) * nsops, GFP_KERNEL);
	if (!sopl)
		return -ENOMEM;
	hide = 0;
	for (abi = 0; abi < nsops; abi++) {
		__get_user_error(sopl[abi].sem_num, &thsopes->sem_num, hide);
		__get_user_error(sopl[abi].sem_op,  &thsopes->sem_op,  hide);
		__get_user_error(sopl[abi].sem_flg, &thsopes->sem_flg, hide);
		thsopes++;
	}
	if (conf) {
		/* copy this as well before changing domain protection */
		hide |= copy_from_user(&local_timeout, conf, sizeof(*conf));
		conf = &local_timeout;
	}
	if (hide) {
		hide = -EFAULT;
	} else {
		mm_segment_t fs = get_fs();
		set_fs(KERNEL_DS);
		hide = sys_semtimedop(semid, sopl, nsops, conf);
		set_fs(fs);
	}
	kfree(sopl);
	return hide;
}",230.0,70.0,"err:hide,sops:sopl,timeout:conf,i:abi,tsops:thsopes,",414.0,0.1384378671646118,Greedy
434,"static bool ldb_kv_index_unique(struct ldb_context *ldb,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *a;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	a = ldb_schema_attribute_by_name(ldb, attr);
	if (a->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}","static bool ldb_kv_index_unique(struct ldb_context *odub,
				struct ldb_kv_private *ldb_kv,
				const char *attr)
{
	const struct ldb_schema_attribute *span;
	if (ldb_kv->cache->GUID_index_attribute != NULL) {
		if (ldb_attr_cmp(attr, ldb_kv->cache->GUID_index_attribute) ==
		    0) {
			return true;
		}
	}
	if (ldb_attr_dn(attr) == 0) {
		return true;
	}

	span = ldb_schema_attribute_by_name(odub, attr);
	if (span->flags & LDB_ATTR_FLAG_UNIQUE_INDEX) {
		return true;
	}
	return false;
}",98.0,17.0,"ldb:odub,a:span,",91.0,0.0411600351333618,Greedy
442,"static int read_pack_info_file(const char *infofile)
{
	FILE *fp;
	char line[1000];
	int old_cnt = 0;

	fp = fopen(infofile, ""r"");
	if (!fp)
		return 1; /* nonexistent is not an error. */

	while (fgets(line, sizeof(line), fp)) {
		int len = strlen(line);
		if (len && line[len-1] == '\n')
			line[--len] = 0;

		if (!len)
			continue;

		switch (line[0]) {
		case 'P': /* P name */
			if (parse_pack_def(line, old_cnt++))
				goto out_stale;
			break;
		case 'D': /* we used to emit D but that was misguided. */
			goto out_stale;
			break;
		case 'T': /* we used to emit T but nobody uses it. */
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", line);
			break;
		}
	}
	fclose(fp);
	return 0;
 out_stale:
	fclose(fp);
	return 1;
}","static int read_pack_info_file(const char *infofile)
{
	FILE *farm;
	char style[1000];
	int old_cnt = 0;

	farm = fopen(infofile, ""r"");
	if (!farm)
		return 1; /* nonexistent is not an error. */

	while (fgets(style, sizeof(style), farm)) {
		int len = strlen(style);
		if (len && style[len-1] == '
')
			style[--len] = 0;

		if (!len)
			continue;

		switch (style[0]) {
		case 'P': /* P name */
			if (parse_pack_def(style, old_cnt++))
				goto out_stale;
			break;
		case 'D': /* we used to emit D but that was misguided. */
			goto out_stale;
			break;
		case 'T': /* we used to emit T but nobody uses it. */
			goto out_stale;
			break;
		default:
			error(""unrecognized: %s"", style);
			break;
		}
	}
	fclose(farm);
	return 0;
 out_stale:
	fclose(farm);
	return 1;
}",174.0,32.0,"line:style,fp:farm,",153.0,0.0561563611030578,Greedy
461,"armpmu_event_set_period(struct perf_event *event,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armpmu = to_arm_pmu(event->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armpmu->max_period >> 1))
		left = armpmu->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armpmu->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(event);

	return ret;
}","armpmu_event_set_period(struct perf_event *exc,
			struct hw_perf_event *hwc,
			int idx)
{
	struct arm_pmu *armdmun = to_arm_pmu(exc->pmu);
	s64 left = local64_read(&hwc->period_left);
	s64 period = hwc->sample_period;
	int ret = 0;

	if (unlikely(left <= -period)) {
		left = period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	if (unlikely(left <= 0)) {
		left += period;
		local64_set(&hwc->period_left, left);
		hwc->last_period = period;
		ret = 1;
	}

	/*
	 * Limit the maximum period to prevent the counter value
	 * from overtaking the one we are about to program. In
	 * effect we are reducing max_period to account for
	 * interrupt latency (and we are being very conservative).
	 */
	if (left > (armdmun->max_period >> 1))
		left = armdmun->max_period >> 1;

	local64_set(&hwc->prev_count, (u64)-left);

	armdmun->write_counter(idx, (u64)(-left) & 0xffffffff);

	perf_event_update_userpage(exc);

	return ret;
}",182.0,49.0,"event:exc,armpmu:armdmun,",145.0,0.0601795474688212,Greedy
470,"static int ct_list_items(struct media_player *mp, const char *name,
				uint32_t start, uint32_t end, void *user_data)
{
	struct avrcp_player *player = user_data;
	struct avrcp *session;
	struct pending_list_items *p;

	if (player->p != NULL)
		return -EBUSY;

	session = player->sessions->data;

	set_ct_player(session, player);

	if (g_str_has_prefix(name, ""/NowPlaying""))
		player->scope = 0x03;
	else if (g_str_has_suffix(name, ""/search""))
		player->scope = 0x02;
	else
		player->scope = 0x01;

	avrcp_list_items(session, start, end);

	p = g_new0(struct pending_list_items, 1);
	p->start = start;
	p->end = end;
	p->total = (uint64_t) (p->end - p->start) + 1;
	player->p = p;

	return 0;
}","static int ct_list_items(struct media_player *ess, const char *data,
				uint32_t offset, uint32_t len, void *user_id)
{
	struct avrcp_player *party = user_id;
	struct avrcp *buffer;
	struct pending_list_items *hp;

	if (party->hp != NULL)
		return -EBUSY;

	buffer = party->sessions->data;

	set_ct_player(buffer, party);

	if (g_str_has_prefix(data, ""/NowPlaying""))
		party->scope = 0x03;
	else if (g_str_has_suffix(data, ""/search""))
		party->scope = 0x02;
	else
		party->scope = 0x01;

	avrcp_list_items(buffer, offset, len);

	hp = g_new0(struct pending_list_items, 1);
	hp->offset = offset;
	hp->len = len;
	hp->total = (uint64_t) (hp->len - hp->offset) + 1;
	party->hp = hp;

	return 0;
}",169.0,41.0,"mp:ess,user_data:user_id,name:data,session:buffer,start:offset,end:len,player:party,p:hp,",410.0,0.1413760701815287,Greedy
477,"static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_cnt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}","static void ath10k_usb_free_urb_to_pipe(struct ath10k_usb_pipe *pipe,
					struct ath10k_urb_context *urb_context)
{
	unsigned long flags;

	spin_lock_irqsave(&pipe->ar_usb->cs_lock, flags);

	pipe->urb_lcatt++;
	list_add(&urb_context->link, &pipe->urb_list_head);

	spin_unlock_irqrestore(&pipe->ar_usb->cs_lock, flags);
}",62.0,14.0,"urb_cnt:urb_lcatt,",32.0,0.0244308431943257,Greedy
482,"int zap_other_threads(struct task_struct *p)
{
	struct task_struct *t = p;
	int count = 0;

	p->signal->group_stop_count = 0;

	while_each_thread(p, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}","int zap_other_threads(struct task_struct *pot)
{
	struct task_struct *t = pot;
	int count = 0;

	pot->signal->group_stop_count = 0;

	while_each_thread(pot, t) {
		task_clear_group_stop_pending(t);
		count++;

		/* Don't bother with already dead threads */
		if (t->exit_state)
			continue;
		sigaddset(&t->pending.signal, SIGKILL);
		signal_wake_up(t, 1);
	}

	return count;
}",76.0,17.0,"t:t,p:pot,",116.0,0.047913368542989,Greedy
488,"loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp ltmp;

	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));

	DTOLFP(last_offset, &ltmp);
	HTONL_FP(&ltmp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &ltmp);
	HTONL_FP(&ltmp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));

	more_pkt();
	flush_pkt();
}","loop_info(
	sockaddr_u *srcadr,
	endpt *inter,
	struct req_pkt *inpkt
	)
{
	struct info_loop *li;
	l_fp letcp;

	li = (struct info_loop *)prepare_pkt(srcadr, inter, inpkt,
	    sizeof(struct info_loop));

	DTOLFP(last_offset, &letcp);
	HTONL_FP(&letcp, &li->last_offset);
	DTOLFP(drift_comp * 1e6, &letcp);
	HTONL_FP(&letcp, &li->drift_comp);
	li->compliance = htonl((u_int32)(tc_counter));
	li->watchdog_timer = htonl((u_int32)(current_time - sys_epoch));

	more_pkt();
	flush_pkt();
}",125.0,34.0,"ltmp:letcp,",67.0,0.0317563891410827,Greedy
493,"const char *SSL_get_cipher_list(const SSL *s, int n)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (s == NULL)
        return (NULL);
    sk = SSL_get_ciphers(s);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= n))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, n);
    if (c == NULL)
        return (NULL);
    return (c->name);
}","const char *SSL_get_cipher_list(const SSL *ess, int len)
{
    SSL_CIPHER *c;
    STACK_OF(SSL_CIPHER) *sk;

    if (ess == NULL)
        return (NULL);
    sk = SSL_get_ciphers(ess);
    if ((sk == NULL) || (sk_SSL_CIPHER_num(sk) <= len))
        return (NULL);
    c = sk_SSL_CIPHER_value(sk, len);
    if (c == NULL)
        return (NULL);
    return (c->name);
}",93.0,21.0,"s:ess,n:len,",103.0,0.0442370255788167,Greedy
498,"static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *exd = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
  /* Always catch error here. */
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  exd->pc = lj_snap_restore(exd->J, exd->exptr);
  UNUSED(dummy);
  return NULL;
}","static TValue *trace_exit_cp(lua_State *L, lua_CFunction dummy, void *ud)
{
  ExitDataCP *xds = (ExitDataCP *)ud;
  cframe_errfunc(L->cframe) = -1;  /* Inherit error function. */
  /* Always catch error here. */
  cframe_nres(L->cframe) = -2*LUAI_MAXSTACK*(int)sizeof(TValue);
  xds->pc = lj_snap_restore(xds->J, xds->exptr);
  UNUSED(dummy);
  return NULL;
}",79.0,18.0,"exd:xds,",57.0,0.0290644963582356,Greedy
500,"static inline int parse_value_and_bound(const string &input, long *output, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endptr;
    *output = strtol(input.c_str(), &endptr, 10);
    if (endptr) {
      if (endptr == input.c_str()) return -EINVAL;
      while (*endptr && isspace(*endptr)) // ignore white space
        endptr++;
      if (*endptr) {
        return -EINVAL;
      }
    }
    if(*output > upper_bound) {
      *output = upper_bound;
    }
    if(*output < lower_bound) {
      *output = lower_bound;
    }
  } else {
    *output = default_val;
  }

  return 0;
}","static inline int parse_value_and_bound(const string &input, long *display, const long lower_bound, const long upper_bound, const long default_val)
{
  if (!input.empty()) {
    char *endedproc;
    *display = strtol(input.c_str(), &endedproc, 10);
    if (endedproc) {
      if (endedproc == input.c_str()) return -EINVAL;
      while (*endedproc && isspace(*endedproc)) // ignore white space
        endedproc++;
      if (*endedproc) {
        return -EINVAL;
      }
    }
    if(*display > upper_bound) {
      *display = upper_bound;
    }
    if(*display < lower_bound) {
      *display = lower_bound;
    }
  } else {
    *display = default_val;
  }

  return 0;
}",144.0,32.0,"endptr:endedproc,output:display,",121.0,0.0490415175755818,Greedy
503,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc(reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t niceLength;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&niceLength, 4)) return;
    niceLength = rfbClientSwap32IfLE(niceLength);
    reason = malloc(niceLength+1);
    if (!ReadFromRFBServer(client, reason, niceLength)) { free(reason); return; }
    reason[niceLength]=0;
    rfbClientLog(""VNC connection failed: %s
"",reason);
    free(reason);
}",92.0,25.0,"reasonLen:niceLength,",69.0,0.0306155721346537,Greedy
505,"gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversation;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversation = find_conversation_by_name (self, service_name);
        if (conversation != NULL) {
                gdm_dbus_worker_call_authorize (conversation->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversation);
        }
}","gdm_session_authorize (GdmSession *self,
                       const char *service_name)
{
        GdmSessionConversation *conversated;

        g_return_if_fail (GDM_IS_SESSION (self));

        conversated = find_conversation_by_name (self, service_name);
        if (conversated != NULL) {
                gdm_dbus_worker_call_authorize (conversated->worker_proxy,
                                                NULL,
                                                (GAsyncReadyCallback) on_authorize_cb,
                                                conversated);
        }
}",58.0,16.0,"conversation:conversated,",71.0,0.0306250770886739,Greedy
513,"completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *send;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  send = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, send - string);
      string++;
#else
      ADVANCE_CHAR_P (string, send - string);
#endif
    }
  return (0);
}","completion_glob_pattern (string)
     char *string;
{
  register int c;
  char *close;
  int open;

  DECLARE_MBSTATE;

  open = 0;
  close = string + strlen (string);

  while (c = *string++)
    {
      switch (c)
	{
	case '?':
	case '*':
	  return (1);

	case '[':
	  open++;
	  continue;

	case ']':
	  if (open)
	    return (1);
	  continue;

	case '+':
	case '@':
	case '!':
	  if (*string == '(')	/*)*/
	    return (1);
	  continue;

	case '\\':
	  if (*string++ == 0)
	    return (0);
	}

      /* Advance one fewer byte than an entire multibyte character to
	 account for the auto-increment in the loop above. */
#ifdef HANDLE_MULTIBYTE
      string--;
      ADVANCE_CHAR_P (string, close - string);
      string++;
#else
      ADVANCE_CHAR_P (string, close - string);
#endif
    }
  return (0);
}",167.0,30.0,"send:close,",64.0,0.0314978718757629,Greedy
520,"static void release_unused_pictures(H264Context *h, int remove_current)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (remove_current || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}","static void release_unused_pictures(H264Context *h, int removeAllleft)
{
    int i;

    /* release non reference frames */
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (h->DPB[i].f.data[0] && !h->DPB[i].reference &&
            (removeAllleft || &h->DPB[i] != h->cur_pic_ptr)) {
            unref_picture(h, &h->DPB[i]);
        }
    }
}",88.0,20.0,"remove_current:removeAllleft,",34.0,0.0255794803301493,Greedy
522,"handle_raw_ping(struct query *q, int dns_fd, int userid)
{
	if (check_user_and_ip(userid, q) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].q), q, sizeof(struct query));

	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d\n"", userid);
	}

	/* Send ping reply */
	send_raw(dns_fd, NULL, 0, userid, RAW_HDR_CMD_PING, q);
}","handle_raw_ping(struct query *seq, int dnswhandle, int userid)
{
	if (check_user_and_ip(userid, seq) != 0) {
		return;
	}

	/* Update query and time info for user */
	users[userid].last_pkt = time(NULL);
	memcpy(&(users[userid].seq), seq, sizeof(struct query));

	if (debug >= 1) {
		fprintf(stderr, ""IN   ping raw, from user %d
"", userid);
	}

	/* Send ping reply */
	send_raw(dnswhandle, NULL, 0, userid, RAW_HDR_CMD_PING, seq);
}",97.0,23.0,"q:seq,dns_fd:dnswhandle,",91.0,0.0419479727745056,Greedy
524,"void smtp_server_connection_reply_lines(struct smtp_server_connection *conn,
				        unsigned int status,
					const char *enh_code,
					const char *const *text_lines)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.status = status;
	reply.text_lines = text_lines;

	if (!smtp_reply_parse_enhanced_code(
		enh_code, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(status / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(conn->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(conn->conn.output, str_data(str), str_len(str));
	} T_END;
}","void smtp_server_connection_reply_lines(struct smtp_server_connection *vc,
				        unsigned int msg,
					const char *enh8zip,
					const char *const *text·settings)
{
	struct smtp_reply reply;

	i_zero(&reply);
	reply.msg = msg;
	reply.text·settings = text·settings;

	if (!smtp_reply_parse_enhanced_code(
		enh8zip, &reply.enhanced_code, NULL))
		reply.enhanced_code = SMTP_REPLY_ENH_CODE(msg / 100, 0, 0);

	T_BEGIN {
		string_t *str;

		e_debug(vc->event, ""Sent: %s"", smtp_reply_log(&reply));

		str = t_str_new(256);
		smtp_reply_write(str, &reply);
		o_stream_nsend(vc->vc.output, str_data(str), str_len(str));
	} T_END;
}",138.0,35.0,"enh_code:enh8zip,text_lines:text·settings,conn:vc,status:msg,",179.0,0.0635724465052286,Greedy
526,"static bool get_discovery_client(struct btd_adapter *adapter, const char *owner,
				struct discovery_client **client)
{
	GSList *list = g_slist_find_custom(adapter->discovery_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return true;
	}

	list = g_slist_find_custom(adapter->set_filter_list, owner,
								compare_sender);
	if (list) {
		*client = list->data;
		return false;
	}

	*client = NULL;
	return false;
}","static bool get_discovery_client(struct btd_adapter *adhvisor, const char *reader,
				struct discovery_client **acl)
{
	GSList *parent = g_slist_find_custom(adhvisor->discovery_list, reader,
								compare_sender);
	if (parent) {
		*acl = parent->data;
		return true;
	}

	parent = g_slist_find_custom(adhvisor->set_filter_list, reader,
								compare_sender);
	if (parent) {
		*acl = parent->data;
		return false;
	}

	*acl = NULL;
	return false;
}",90.0,21.0,"adapter:adhvisor,owner:reader,client:acl,list:parent,",211.0,0.0774349570274353,Greedy
531,"static void stub_disconnect(struct usb_device *udev)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&udev->dev);
	struct bus_id_priv *busid_priv;
	int rc;

	dev_dbg(&udev->dev, ""Enter disconnect\n"");

	busid_priv = get_busid_priv(udev_busid);
	if (!busid_priv) {
		BUG();
		return;
	}

	sdev = dev_get_drvdata(&udev->dev);

	/* get stub_device */
	if (!sdev) {
		dev_err(&udev->dev, ""could not get device"");
		return;
	}

	dev_set_drvdata(&udev->dev, NULL);

	/*
	 * NOTE: rx/tx threads are invoked for each usb_device.
	 */
	stub_remove_files(&udev->dev);

	/* release port */
	rc = usb_hub_release_port(udev->parent, udev->portnum,
				  (struct usb_dev_state *) udev);
	if (rc) {
		dev_dbg(&udev->dev, ""unable to release port\n"");
		return;
	}

	/* If usb reset is called from event handler */
	if (usbip_in_eh(current))
		return;

	/* shutdown the current connection */
	shutdown_busid(busid_priv);

	usb_put_dev(sdev->udev);

	/* free sdev */
	busid_priv->sdev = NULL;
	stub_device_free(sdev);

	if (busid_priv->status == STUB_BUSID_ALLOC)
		busid_priv->status = STUB_BUSID_ADDED;
}","static void stub_disconnect(struct usb_device *ubruction)
{
	struct stub_device *sdev;
	const char *udev_busid = dev_name(&ubruction->dev);
	struct bus_id_priv *busin_priv;
	int rc;

	dev_dbg(&ubruction->dev, ""Enter disconnect
"");

	busin_priv = get_busid_priv(udev_busid);
	if (!busin_priv) {
		BUG();
		return;
	}

	sdev = dev_get_drvdata(&ubruction->dev);

	/* get stub_device */
	if (!sdev) {
		dev_err(&ubruction->dev, ""could not get device"");
		return;
	}

	dev_set_drvdata(&ubruction->dev, NULL);

	/*
	 * NOTE: rx/tx threads are invoked for each usb_device.
	 */
	stub_remove_files(&ubruction->dev);

	/* release port */
	rc = usb_hub_release_port(ubruction->parent, ubruction->portnum,
				  (struct usb_dev_state *) ubruction);
	if (rc) {
		dev_dbg(&ubruction->dev, ""unable to release port
"");
		return;
	}

	/* If usb reset is called from event handler */
	if (usbip_in_eh(current))
		return;

	/* shutdown the current connection */
	shutdown_busid(busin_priv);

	usb_put_dev(sdev->ubruction);

	/* free sdev */
	busin_priv->sdev = NULL;
	stub_device_free(sdev);

	if (busin_priv->status == STUB_BUSID_ALLOC)
		busin_priv->status = STUB_BUSID_ADDED;
}",203.0,46.0,"udev:ubruction,busid_priv:busin_priv,",199.0,0.0679727991422017,Greedy
539,"static void hidp_process_report(struct hidp_session *session,
				int type, const u8 *data, int len, int intr)
{
	if (len > HID_MAX_BUFFER_SIZE)
		len = HID_MAX_BUFFER_SIZE;

	memcpy(session->input_buf, data, len);
	hid_input_report(session->hid, type, session->input_buf, len, intr);
}","static void hidp_process_report(struct hidp_session *bin,
				int block, const u8 *data, int lang, int intr)
{
	if (lang > HID_MAX_BUFFER_SIZE)
		lang = HID_MAX_BUFFER_SIZE;

	memcpy(bin->input_buf, data, lang);
	hid_input_report(bin->hid, block, bin->input_buf, lang, intr);
}",63.0,20.0,"len:lang,session:bin,type:block,",161.0,0.0601747473080952,Greedy
544,"static int iscsi_add_notunderstood_response(
	char *key,
	char *value,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;

	if (strlen(value) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.\n"", key, VALUE_MAXLEN);
		return -1;
	}

	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.\n"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);

	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->value, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);

	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}","static int iscsi_add_notunderstood_response(
	char *key,
	char *VALUE,
	struct iscsi_param_list *param_list)
{
	struct iscsi_extra_response *extra_response;

	if (strlen(VALUE) > VALUE_MAXLEN) {
		pr_err(""Value for notunderstood key \""%s\"" exceeds %d,""
			"" protocol error.
"", key, VALUE_MAXLEN);
		return -1;
	}

	extra_response = kzalloc(sizeof(struct iscsi_extra_response), GFP_KERNEL);
	if (!extra_response) {
		pr_err(""Unable to allocate memory for""
			"" struct iscsi_extra_response.
"");
		return -1;
	}
	INIT_LIST_HEAD(&extra_response->er_list);

	strncpy(extra_response->key, key, strlen(key) + 1);
	strncpy(extra_response->VALUE, NOTUNDERSTOOD,
			strlen(NOTUNDERSTOOD) + 1);

	list_add_tail(&extra_response->er_list,
			&param_list->extra_response_list);
	return 0;
}",141.0,31.0,"value:VALUE,",68.0,0.0337640206019083,Greedy
554," */
static inline bool skb_head_is_locked(const struct sk_buff *skb)
{
	return !skb->head_frag || skb_cloned(skb);"," */
static inline bool skb_head_is_locked(const struct sk_buff *skybb)
{
	return !skybb->head_frag || skb_cloned(skybb);",26.0,5.0,"skb:skybb,",31.0,0.0250961979230244,Greedy
557,"static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *data = vdata;
	const char *subsection, *key;
	int subsection_len;
	char *name;

	if (parse_config_key(var, ""submodule"", &subsection, &subsection_len, &key) < 0 ||
	    !subsection)
		return 0;

	name = xmemdupz(subsection, subsection_len);
	if (check_submodule_name(name) < 0)
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    name);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		data->ret |= report(data->options, data->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(name);

	return 0;
}","static int fsck_gitmodules_fn(const char *var, const char *value, void *vdata)
{
	struct fsck_gitmodules_data *list = vdata;
	const char *subscription, *key;
	int subsection_len;
	char *time;

	if (parse_config_key(var, ""submodule"", &subscription, &subsection_len, &key) < 0 ||
	    !subscription)
		return 0;

	time = xmemdupz(subscription, subsection_len);
	if (check_submodule_name(time) < 0)
		list->ret |= report(list->options, list->obj,
				    FSCK_MSG_GITMODULES_NAME,
				    ""disallowed submodule name: %s"",
				    time);
	if (!strcmp(key, ""url"") && value &&
	    looks_like_command_line_option(value))
		list->ret |= report(list->options, list->obj,
				    FSCK_MSG_GITMODULES_URL,
				    ""disallowed submodule url: %s"",
				    value);
	free(time);

	return 0;
}",157.0,41.0,"data:list,name:time,subsection:subscription,",183.0,0.0680014053980509,Greedy
566,"static inline int dma_declare_contiguous(struct device *dev, phys_addr_t size,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(size, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}","static inline int dma_declare_contiguous(struct device *dev, phys_addr_t len,
					 phys_addr_t base, phys_addr_t limit)
{
	struct cma *cma;
	int ret;
	ret = dma_contiguous_reserve_area(len, base, limit, &cma, true);
	if (ret == 0)
		dev_set_cma_area(dev, cma);

	return ret;
}",61.0,18.0,"size:len,",52.0,0.0275419990221659,Greedy
570,"static int display_open(void *handle, void *device)
{

    IMAGE *img = (IMAGE *)malloc(sizeof(IMAGE));
    if (img == NULL)
        return -1;
    memset(img, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        img->next = first_image;
    first_image = img;

    /* remember device and handle */
    img->handle = handle;
    img->device = device;

    /* create window */
    window_create(img);

    gtk_main_iteration_do(FALSE);
    return 0;
}","static int display_open(void *handle, void *device)
{

    IMAGE *imm = (IMAGE *)malloc(sizeof(IMAGE));
    if (imm == NULL)
        return -1;
    memset(imm, 0, sizeof(IMAGE));

    if (first_image == NULL) {
        gdk_rgb_init();
        gtk_widget_set_default_colormap(gdk_rgb_get_cmap());
        gtk_widget_set_default_visual(gdk_rgb_get_visual());
    }

    /* add to list */
    if (first_image)
        imm->next = first_image;
    first_image = imm;

    /* remember device and handle */
    imm->handle = handle;
    imm->device = device;

    /* create window */
    window_create(imm);

    gtk_main_iteration_do(FALSE);
    return 0;
}",116.0,28.0,"img:imm,",97.0,0.0362362345059712,Greedy
586,"static int mxf_read_index_entry_array(AVIOContext *pb, MXFIndexTableSegment *segment)
{
    int i, length;

    segment->nb_index_entries = avio_rb32(pb);

    length = avio_rb32(pb);

    if (!(segment->temporal_offset_entries=av_calloc(segment->nb_index_entries, sizeof(*segment->temporal_offset_entries))) ||
        !(segment->flag_entries          = av_calloc(segment->nb_index_entries, sizeof(*segment->flag_entries))) ||
        !(segment->stream_offset_entries = av_calloc(segment->nb_index_entries, sizeof(*segment->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < segment->nb_index_entries; i++) {
        segment->temporal_offset_entries[i] = avio_r8(pb);
        avio_r8(pb);                                        /* KeyFrameOffset */
        segment->flag_entries[i] = avio_r8(pb);
        segment->stream_offset_entries[i] = avio_rb64(pb);
        avio_skip(pb, length - 11);
    }
    return 0;
}","static int mxf_read_index_entry_array(AVIOContext *cp, MXFIndexTableSegment *nement)
{
    int i, length;

    nement->nb_index_entries = avio_rb32(cp);

    length = avio_rb32(cp);

    if (!(nement->temporal_offset_entries=av_calloc(nement->nb_index_entries, sizeof(*nement->temporal_offset_entries))) ||
        !(nement->flag_entries          = av_calloc(nement->nb_index_entries, sizeof(*nement->flag_entries))) ||
        !(nement->stream_offset_entries = av_calloc(nement->nb_index_entries, sizeof(*nement->stream_offset_entries))))
        return AVERROR(ENOMEM);

    for (i = 0; i < nement->nb_index_entries; i++) {
        nement->temporal_offset_entries[i] = avio_r8(cp);
        avio_r8(cp);                                        /* KeyFrameOffset */
        nement->flag_entries[i] = avio_r8(cp);
        nement->stream_offset_entries[i] = avio_rb64(cp);
        avio_skip(cp, length - 11);
    }
    return 0;
}",179.0,46.0,"segment:nement,pb:cp,",203.0,0.0651877522468566,Greedy
589,"ReadReason(rfbClient* client)
{
    uint32_t reasonLen;
    char *reason;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&reasonLen, 4)) return;
    reasonLen = rfbClientSwap32IfLE(reasonLen);
    reason = malloc((uint64_t)reasonLen+1);
    if (!ReadFromRFBServer(client, reason, reasonLen)) { free(reason); return; }
    reason[reasonLen]=0;
    rfbClientLog(""VNC connection failed: %s\n"",reason);
    free(reason);
}","ReadReason(rfbClient* client)
{
    uint32_t ReasonL;
    char *warn;

    /* we have an error following */
    if (!ReadFromRFBServer(client, (char *)&ReasonL, 4)) return;
    ReasonL = rfbClientSwap32IfLE(ReasonL);
    warn = malloc((uint64_t)ReasonL+1);
    if (!ReadFromRFBServer(client, warn, ReasonL)) { free(warn); return; }
    warn[ReasonL]=0;
    rfbClientLog(""VNC connection failed: %s
"",warn);
    free(warn);
}",95.0,25.0,"reasonLen:ReasonL,reason:warn,",122.0,0.0465710123380025,Greedy
606,"static ssize_t max_time_ms_show(struct device *dev,
				struct device_attribute *attr, char *buf)
{
	struct wakeup_source *ws = dev_get_drvdata(dev);
	ktime_t active_time;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active_time = ktime_sub(ktime_get(), ws->last_time);
		if (active_time > max_time)
			max_time = active_time;
	}
	return sprintf(buf, ""%lld\n"", ktime_to_ms(max_time));
}","static ssize_t max_time_ms_show(struct device *cam,
				struct device_attribute *attr, char *cmd)
{
	struct wakeup_source *ws = dev_get_drvdata(cam);
	ktime_t active00speed;
	ktime_t max_time = ws->max_time;

	if (ws->active) {
		active00speed = ktime_sub(ktime_get(), ws->last_time);
		if (active00speed > max_time)
			max_time = active00speed;
	}
	return sprintf(cmd, ""%lld
"", ktime_to_ms(max_time));
}",86.0,23.0,"active_time:active00speed,dev:cam,buf:cmd,",130.0,0.0572429855664571,Greedy
610,"static void qemu_input_queue_process(void *opaque)
{
    struct QemuInputEventQueueHead *queue = opaque;
    QemuInputEventQueue *item;

    g_assert(!QTAILQ_EMPTY(queue));
    item = QTAILQ_FIRST(queue);
    g_assert(item->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(queue, item, node);
    g_free(item);

    while (!QTAILQ_EMPTY(queue)) {
        item = QTAILQ_FIRST(queue);
        switch (item->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + item->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(item->src, item->evt);
            qapi_free_InputEvent(item->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(queue, item, node);
        g_free(item);
    }
}","static void qemu_input_queue_process(void *opacity)
{
    struct QemuInputEventQueueHead *gui = opacity;
    QemuInputEventQueue *image;

    g_assert(!QTAILQ_EMPTY(gui));
    image = QTAILQ_FIRST(gui);
    g_assert(image->type == QEMU_INPUT_QUEUE_DELAY);
    QTAILQ_REMOVE(gui, image, node);
    g_free(image);

    while (!QTAILQ_EMPTY(gui)) {
        image = QTAILQ_FIRST(gui);
        switch (image->type) {
        case QEMU_INPUT_QUEUE_DELAY:
            timer_mod(image->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                      + image->delay_ms);
            return;
        case QEMU_INPUT_QUEUE_EVENT:
            qemu_input_event_send(image->src, image->evt);
            qapi_free_InputEvent(image->evt);
            break;
        case QEMU_INPUT_QUEUE_SYNC:
            qemu_input_event_sync();
            break;
        }
        QTAILQ_REMOVE(gui, image, node);
        g_free(image);
    }
}",152.0,46.0,"item:image,queue:gui,opaque:opacity,",194.0,0.0690945982933044,Greedy
615,"bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct peer *const peer = args->peer; 
  struct attr *const attr = args->attr;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (peer->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  attr->med = stream_getl (peer->ibuf);

  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_med (struct bgp_attr_parser_args *args)
{
  struct vr *const vr = args->vr; 
  struct atts *const atts = args->atts;
  const bgp_size_t length = args->length;
  
  /* Length check. */
  if (length != 4)
    {
      zlog (vr->log, LOG_ERR, 
	    ""MED attribute length isn't four [%d]"", length);

      return bgp_attr_malformed (args,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 args->total);
    }

  atts->med = stream_getl (vr->ibuf);

  atts->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

  return BGP_ATTR_PARSE_PROCEED;
}",94.0,24.0,"peer:vr,attr:atts,",150.0,0.0539616743723551,Greedy
617,"static void calipso_doi_putdef(struct calipso_doi *doi_def)
{
	if (!doi_def)
		return;

	if (!refcount_dec_and_test(&doi_def->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_def->list);
	spin_unlock(&calipso_doi_list_lock);

	call_rcu(&doi_def->rcu, calipso_doi_free_rcu);
}","static void calipso_doi_putdef(struct calipso_doi *doi_DEF)
{
	if (!doi_DEF)
		return;

	if (!refcount_dec_and_test(&doi_DEF->refcount))
		return;
	spin_lock(&calipso_doi_list_lock);
	list_del_rcu(&doi_DEF->list);
	spin_unlock(&calipso_doi_list_lock);

	call_rcu(&doi_DEF->rcu, calipso_doi_free_rcu);
}",61.0,14.0,"doi_def:doi_DEF,",32.0,0.0233832955360412,Greedy
623,"static void umd_cleanup(struct subprocess_info *info)
{
	struct umd_info *umd_info = info->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (info->retval) {
		fput(umd_info->pipe_to_umh);
		fput(umd_info->pipe_from_umh);
		put_pid(umd_info->tgid);
		umd_info->tgid = NULL;
	}
}","static void umd_cleanup(struct subprocess_info *conf)
{
	struct umdACfo *umdACfo = conf->data;

	/* cleanup if umh_setup() was successful but exec failed */
	if (conf->retval) {
		fput(umdACfo->pipe_to_umh);
		fput(umdACfo->pipe_from_umh);
		put_pid(umdACfo->tgid);
		umdACfo->tgid = NULL;
	}
}",55.0,12.0,"umd_info:umdACfo,info:conf,",116.0,0.0467503905296325,Greedy
632,"static unsigned long get_devid(uint8_t busnum, uint8_t devnum)
{
	return (busnum << 16) | devnum;
}","static unsigned long get_devid(uint8_t Busum, uint8_t devnum)
{
	return (Busum << 16) | devnum;
}",22.0,5.0,"busnum:Busum,",34.0,0.0243957956631978,Greedy
634,"void *hashtable_iter_at(hashtable_t *hashtable, const char *key)
{
    pair_t *pair;
    size_t hash;
    bucket_t *bucket;

    hash = hash_str(key);
    bucket = &hashtable->buckets[hash % num_buckets(hashtable)];

    pair = hashtable_find_pair(hashtable, bucket, key, hash);
    if(!pair)
        return NULL;

    return &pair->list;
}","void *hashtable_iter_at(hashtable_t *Hashtab, const char *version)
{
    pair_t *play;
    size_t mac;
    bucket_t *bet;

    mac = hash_str(version);
    bet = &Hashtab->buckets[mac % num_buckets(Hashtab)];

    play = hashtable_find_pair(Hashtab, bet, version, mac);
    if(!play)
        return NULL;

    return &play->list;
}",75.0,22.0,"hashtable:Hashtab,pair:play,hash:mac,key:version,bucket:bet,",236.0,0.0899902065594991,Greedy
638,"static int iccbasecolor(i_ctx_t * i_ctx_p, ref *space, int base, int *stage, int *cont, int *stack_depth)
{
    *stage = 0;
    *cont = 1;
    return 0;
}","static int iccbasecolor(i_ctx_t * i_context_t, ref *prefix, int image, int *test, int *CONT, int *stacklevelradius)
{
    *test = 0;
    *CONT = 1;
    return 0;
}",42.0,9.0,"cont:CONT,stack_depth:stacklevelradius,space:prefix,base:image,i_ctx_p:i_context_t,stage:test,",168.0,0.0814071575800577,Greedy
642,"void* X509_get_ext_d2i(X509* x, int nid, int* crit, int* idx)
{
    // no extensions supported yet
    return 0;
}","void* X509_get_ext_d2i(X509* x, int ncoid, int* cut, int* idx)
{
    // no extensions supported yet
    return 0;
}",24.0,5.0,"crit:cut,nid:ncoid,",50.0,0.0330982486406962,Greedy
649,"find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *task;
	int err;

	rcu_read_lock();
	if (!vpid)
		task = current;
	else
		task = find_task_by_vpid(vpid);
	if (task)
		get_task_struct(task);
	rcu_read_unlock();

	if (!task)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	err = -EACCES;
	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))
		goto errout;

	return task;
errout:
	put_task_struct(task);
	return ERR_PTR(err);

}","find_lively_task_by_vpid(pid_t vpid)
{
	struct task_struct *pack;
	int order;

	rcu_read_lock();
	if (!vpid)
		pack = current;
	else
		pack = find_task_by_vpid(vpid);
	if (pack)
		get_task_struct(pack);
	rcu_read_unlock();

	if (!pack)
		return ERR_PTR(-ESRCH);

	/* Reuse ptrace permission checks for now. */
	order = -EACCES;
	if (!ptrace_may_access(pack, PTRACE_MODE_READ_REALCREDS))
		goto errout;

	return pack;
errout:
	put_task_struct(pack);
	return ERR_PTR(order);

}",95.0,28.0,"err:order,task:pack,",146.0,0.0535600264867146,Greedy
650,"static unsigned short get_ushort(const unsigned char *data)
{
    unsigned short val = *(const unsigned short *)data;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}","static unsigned short get_ushort(const unsigned char *bin)
{
    unsigned short val = *(const unsigned short *)bin;
#ifdef OPJ_BIG_ENDIAN
    val = ((val & 0xffU) << 8) | (val >> 8);
#endif
    return val;
}",50.0,9.0,"data:bin,",41.0,0.0261382619539896,Greedy
665,"set_unused_field_bp(unsigned char *bp, int from, int to)
{
	memset(bp + from, 0, to - from + 1);
}","set_unused_field_bp(unsigned char *bp, int mode, int to)
{
	memset(bp + mode, 0, to - mode + 1);
}",30.0,9.0,"from:mode,",51.0,0.0294865012168884,Greedy
671,"PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale_name = NULL;
	int   len=0;	

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale_name ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		locale_name =  (char *)uloc_getDefault() ;
		len = strlen(locale_name);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale_name, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}","PHP_NAMED_FUNCTION(zif_locale_set_default)
{
	char* locale64num = NULL;
	int   len=0;	

	if(zend_parse_parameters( ZEND_NUM_ARGS() TSRMLS_CC,  ""s"",
		&locale64num ,&len ) == FAILURE)
	{
		intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
			 	""locale_set_default: unable to parse input params"", 0 TSRMLS_CC );

		RETURN_FALSE;
	}

	if(len == 0) {
		locale64num =  (char *)uloc_getDefault() ;
		len = strlen(locale64num);
	}

	zend_alter_ini_entry(LOCALE_INI_NAME, sizeof(LOCALE_INI_NAME), locale64num, len, PHP_INI_USER, PHP_INI_STAGE_RUNTIME);	

	RETURN_TRUE;
}",100.0,27.0,"locale_name:locale64num,",35.0,0.0248972256978352,Greedy
674,"ex_open(exarg_T *eap)
{
    regmatch_T	regmatch;
    char_u	*p;

#ifdef FEAT_EVAL
    if (not_in_vim9(eap) == FAIL)
	return;
#endif
    curwin->w_cursor.lnum = eap->line2;
    beginline(BL_SOL | BL_FIX);
    if (*eap->arg == '/')
    {
	// "":open /pattern/"": put cursor in column found with pattern
	++eap->arg;
	p = skip_regexp(eap->arg, '/', magic_isset());
	*p = NUL;
	regmatch.regprog = vim_regcomp(eap->arg, magic_isset() ? RE_MAGIC : 0);
	if (regmatch.regprog != NULL)
	{
	    regmatch.rm_ic = p_ic;
	    p = ml_get_curline();
	    if (vim_regexec(&regmatch, p, (colnr_T)0))
		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);
	    else
		emsg(_(e_nomatch));
	    vim_regfree(regmatch.regprog);
	}
	// Move to the NUL, ignore any other arguments.
	eap->arg += STRLEN(eap->arg);
    }
    check_cursor();

    eap->cmdidx = CMD_visual;
    do_exedit(eap, NULL);
}","ex_open(exarg_T *deaf)
{
    regmatch_T	 regpattern;
    char_u	*p;

#ifdef FEAT_EVAL
    if (not_in_vim9(deaf) == FAIL)
	return;
#endif
    curwin->w_cursor.lnum = deaf->line2;
    beginline(BL_SOL | BL_FIX);
    if (*deaf->arg == '/')
    {
	// "":open /pattern/"": put cursor in column found with pattern
	++deaf->arg;
	p = skip_regexp(deaf->arg, '/', magic_isset());
	*p = NUL;
	 regpattern.regprog = vim_regcomp(deaf->arg, magic_isset() ? RE_MAGIC : 0);
	if ( regpattern.regprog != NULL)
	{
	     regpattern.rm_ic = p_ic;
	    p = ml_get_curline();
	    if (vim_regexec(& regpattern, p, (colnr_T)0))
		curwin->w_cursor.col = (colnr_T)( regpattern.startp[0] - p);
	    else
		emsg(_(e_nomatch));
	    vim_regfree( regpattern.regprog);
	}
	// Move to the NUL, ignore any other arguments.
	deaf->arg += STRLEN(deaf->arg);
    }
    check_cursor();

    deaf->cmdidx = CMD_visual;
    do_exedit(deaf, NULL);
}",204.0,51.0,"eap:deaf,regmatch: regpattern,",210.0,0.073456859588623,Greedy
684,"static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
{
    ASFContext *asf = s->priv_data;
    AVIOContext *pb = s->pb;
    uint64_t size   = avio_rl64(pb);
    int ret;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (asf->is_header)
        asf->unknown_size = size;
    asf->is_header = 0;
    if (!g->is_subobject) {
        if (!(ret = strcmp(g->name, ""Header Extension"")))
            avio_skip(pb, 22); // skip reserved fields and Data Size
        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
                                            asf->unknown_size)) < 0)
            return ret;
    } else {
        if (size < 24) {
            av_log(s, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).\n"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(pb, size - 24);
    }

    return 0;
}","static int asf_read_unknown(AVFormatContext *aws, const GUIDParseTable *ga)
{
    ASFContext *ansform = aws->priv_data;
    AVIOContext *sb = aws->sb;
    uint64_t size   = avio_rl64(sb);
    int len;

    if (size > INT64_MAX)
        return AVERROR_INVALIDDATA;

    if (ansform->is_header)
        ansform->unknown_size = size;
    ansform->is_header = 0;
    if (!ga->is_subobject) {
        if (!(len = strcmp(ga->name, ""Header Extension"")))
            avio_skip(sb, 22); // skip reserved fields and Data Size
        if ((len = detect_unknown_subobject(aws, ansform->unknown_offset,
                                            ansform->unknown_size)) < 0)
            return len;
    } else {
        if (size < 24) {
            av_log(aws, AV_LOG_ERROR, ""Too small size %""PRIu64"" (< 24).
"", size);
            return AVERROR_INVALIDDATA;
        }
        avio_skip(sb, size - 24);
    }

    return 0;
}",168.0,40.0,"g:ga,s:aws,pb:sb,ret:len,asf:ansform,",306.0,0.1103206793467203,Greedy
687,"static ssize_t size_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	return sprintf(buf, ""%uK\n"", this_leaf->size >> 10);
}","static ssize_t size_show(struct device *cam,
			 struct device_attribute *rat, char *func)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(cam);

	return sprintf(func, ""%uK
"", this_leaf->size >> 10);
}",46.0,10.0,"buf:func,dev:cam,this_leaf:this_leaf,attr:rat,",126.0,0.0613422671953837,Greedy
689,"static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *ep;
	struct mon_text_ptr ptr;

	ep = mon_text_read_wait(rp, file);
	if (IS_ERR(ep))
		return PTR_ERR(ep);
	mutex_lock(&rp->printf_lock);
	ptr.cnt = 0;
	ptr.pbuf = rp->printf_buf;
	ptr.limit = rp->printf_size;

	mon_text_read_head_u(rp, &ptr, ep);
	if (ep->type == 'E') {
		mon_text_read_statset(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ptr, ep);
		mon_text_read_isodesc(rp, &ptr, ep);
	} else if (ep->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ptr, ep);
	} else {
		mon_text_read_statset(rp, &ptr, ep);
	}
	ptr.cnt += snprintf(ptr.pbuf + ptr.cnt, ptr.limit - ptr.cnt,
	    "" %d"", ep->length);
	mon_text_read_data(rp, &ptr, ep);

	if (copy_to_user(buf, rp->printf_buf, ptr.cnt))
		ptr.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, ep);
	return ptr.cnt;
}","static ssize_t mon_text_read_u(struct file *file, char __user *buf,
				size_t nbytes, loff_t *ppos)
{
	struct mon_reader_text *rp = file->private_data;
	struct mon_event_text *proc;
	struct mon_text_ptr ffe;

	proc = mon_text_read_wait(rp, file);
	if (IS_ERR(proc))
		return PTR_ERR(proc);
	mutex_lock(&rp->printf_lock);
	ffe.cnt = 0;
	ffe.pbuf = rp->printf_buf;
	ffe.limit = rp->printf_size;

	mon_text_read_head_u(rp, &ffe, proc);
	if (proc->type == 'E') {
		mon_text_read_statset(rp, &ffe, proc);
	} else if (proc->xfertype == USB_ENDPOINT_XFER_ISOC) {
		mon_text_read_isostat(rp, &ffe, proc);
		mon_text_read_isodesc(rp, &ffe, proc);
	} else if (proc->xfertype == USB_ENDPOINT_XFER_INT) {
		mon_text_read_intstat(rp, &ffe, proc);
	} else {
		mon_text_read_statset(rp, &ffe, proc);
	}
	ffe.cnt += snprintf(ffe.pbuf + ffe.cnt, ffe.limit - ffe.cnt,
	    "" %d"", proc->length);
	mon_text_read_data(rp, &ffe, proc);

	if (copy_to_user(buf, rp->printf_buf, ffe.cnt))
		ffe.cnt = -EFAULT;
	mutex_unlock(&rp->printf_lock);
	kmem_cache_free(rp->e_slab, proc);
	return ffe.cnt;
}",273.0,77.0,"ptr:ffe,ep:proc,",244.0,0.0791873216629028,Greedy
694,"static void __wait_on_freeing_inode(struct inode *inode)
{
	wait_queue_head_t *wq;
	DEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);
	wq = bit_waitqueue(&inode->i_state, __I_NEW);
	prepare_to_wait(wq, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&inode->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(wq, &wait.wait);
	spin_lock(&inode_hash_lock);
}","static void __wait_on_freeing_inode(struct idoder *idoder)
{
	wait_queue_head_t *fp;
	DEFINE_WAIT_BIT(wait, &idoder->i_state, __I_NEW);
	fp = bit_waitqueue(&idoder->i_state, __I_NEW);
	prepare_to_wait(fp, &wait.wait, TASK_UNINTERRUPTIBLE);
	spin_unlock(&idoder->i_lock);
	spin_unlock(&inode_hash_lock);
	schedule();
	finish_wait(fp, &wait.wait);
	spin_lock(&inode_hash_lock);
}",85.0,25.0,"wq:fp,inode:idoder,",108.0,0.0636515021324157,Greedy
697,"static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *pq,
				  struct hfi1_user_sdma_comp_q *cq,
				  u16 idx, enum hfi1_sdma_comp_state state,
				  int ret)
{
	if (state == ERROR)
		cq->comps[idx].errcode = -ret;
	smp_wmb(); /* make sure errcode is visible first */
	cq->comps[idx].status = state;
	trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,
					idx, state, ret);
}","static inline void set_comp_state(struct hfi1_user_sdma_pkt_q *lpqa,
				  struct hfi1_user_sdma_comp_q * cp,
				  u16  idn, enum hfi1_sdma_comp_state tag,
				  int ret)
{
	if (tag == ERROR)
		 cp->comps[ idn].errcode = -ret;
	smp_wmb(); /* make sure errcode is visible first */
	 cp->comps[ idn].status = tag;
	trace_hfi1_sdma_user_completion(lpqa->dd, lpqa->ctxt, lpqa->subctxt,
					 idn, tag, ret);
}",81.0,22.0,"pq:lpqa,cq: cp,idx: idn,state:tag,",164.0,0.0883307218551635,Greedy
702,"int htc_send(struct htc_target *target, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctl;

	tx_ctl = HTC_SKB_CB(skb);
	return htc_issue_send(target, skb, skb->len, 0, tx_ctl->epid);
}","int htc_send(struct htc_target *port, struct sk_buff *skb)
{
	struct ath9k_htc_tx_ctl *tx_ctrl;

	tx_ctrl = HTC_SKB_CB(skb);
	return htc_issue_send(port, skb, skb->len, 0, tx_ctrl->epid);
}",45.0,12.0,"target:port,tx_ctl:tx_ctrl,",76.0,0.0536515633265177,Greedy
705,"static ssize_t show_crash_notes(struct device *dev, struct device_attribute *attr,
				char *buf)
{
	struct cpu *cpu = container_of(dev, struct cpu, dev);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = cpu->dev.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx\n"", addr);
	return rc;
}","static ssize_t show_crash_notes(struct device *conf, struct device_attribute *attr,
				char *buf)
{
	struct phy *phy = container_of(conf, struct phy, conf);
	ssize_t rc;
	unsigned long long addr;
	int cpunum;

	cpunum = phy->conf.id;

	/*
	 * Might be reading other cpu's data based on which cpu read thread
	 * has been scheduled. But cpu data (memory) is allocated once during
	 * boot up and this data does not change there after. Hence this
	 * operation should be safe. No locking required.
	 */
	addr = per_cpu_ptr_to_phys(per_cpu_ptr(crash_notes, cpunum));
	rc = sprintf(buf, ""%Lx
"", addr);
	return rc;
}",82.0,25.0,"cpu:phy,dev:conf,",129.0,0.0551971316337585,Greedy
708,"static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *ms)
{
	jpc_coc_t *coc = &ms->parms.coc;
	jpc_dec_tile_t *tile;

	if (JAS_CAST(int, coc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment\n"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, coc);
		break;
	case JPC_TPH:
		if (!(tile = dec->curtile)) {
			return -1;
		}
		if (tile->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(tile->cp, coc);
		break;
	}
	return 0;
}","static int jpc_dec_process_coc(jpc_dec_t *dec, jpc_ms_t *md)
{
	jpc_coc_t *lcoc = &md->parms.lcoc;
	jpc_dec_tile_t *league;

	if (JAS_CAST(int, lcoc->compno) > dec->numcomps) {
		jas_eprintf(""invalid component number in COC marker segment
"");
		return -1;
	}
	switch (dec->state) {
	case JPC_MH:
		jpc_dec_cp_setfromcoc(dec->cp, lcoc);
		break;
	case JPC_TPH:
		if (!(league = dec->curtile)) {
			return -1;
		}
		if (league->partno > 0) {
			return -1;
		}
		jpc_dec_cp_setfromcoc(league->cp, lcoc);
		break;
	}
	return 0;
}",124.0,23.0,"coc:lcoc,tile:league,ms:md,",166.0,0.0680923302968343,Greedy
714,"static int IntensityCompare(const void *x,const void *y)
{
  double
    intensity;

  PixelInfo
    *color_1,
    *color_2;

  color_1=(PixelInfo *) x;
  color_2=(PixelInfo *) y;
  intensity=GetPixelInfoIntensity((const Image *) NULL,color_1)-
    GetPixelInfoIntensity((const Image *) NULL,color_2);
  return((int) intensity);
}","static int IntensityCompare(const void *x,const void *y)
{
  double
    fine;

  PixelInfo
    *colorA4,
    * color_out;

  colorA4=(PixelInfo *) x;
   color_out=(PixelInfo *) y;
  fine=GetPixelInfoIntensity((const Image *) NULL,colorA4)-
    GetPixelInfoIntensity((const Image *) NULL, color_out);
  return((int) fine);
}",76.0,16.0,"color_1:colorA4,color_2: color_out,intensity:fine,",103.0,0.065354303518931,Greedy
717,"static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int i)
{
	memset(port, 0, sizeof(*port));
	port->id = i;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;

	spin_lock_init(&port->dev_list_lock);
}","static void sas_init_port(struct asd_sas_port *port,
			  struct sas_ha_struct *sas_ha, int I)
{
	memset(port, 0, sizeof(*port));
	port->id = I;
	INIT_LIST_HEAD(&port->dev_list);
	INIT_LIST_HEAD(&port->disco_list);
	INIT_LIST_HEAD(&port->destroy_list);
	spin_lock_init(&port->phy_list_lock);
	INIT_LIST_HEAD(&port->phy_list);
	port->ha = sas_ha;

	spin_lock_init(&port->dev_list_lock);
}",92.0,23.0,"i:I,",56.0,0.0291659434636433,Greedy
723,"static int handle_vmx_instruction(struct kvm_vcpu *vcpu)
{
	kvm_queue_exception(vcpu, UD_VECTOR);
	return 1;
}","static int handle_vmx_instruction(struct kvm_vcpu *kcpu)
{
	kvm_queue_exception(kcpu, UD_VECTOR);
	return 1;
}",21.0,5.0,"vcpu:kcpu,",33.0,0.0183309078216552,Greedy
730,"int ssh_scp_push_file(ssh_scp scp, const char *filename, size_t size, int mode){
	return ssh_scp_push_file64(scp, filename, (uint64_t) size, mode);
}","int ssh_scp_push_file(ssh_scp scpa, const char *dll, size_t size, int mode){
	return ssh_scp_push_file64(scpa, dll, (uint64_t) size, mode);
}",34.0,10.0,"filename:dll,scp:scpa,",65.0,0.026360277334849,Greedy
731,"vrrp_state_handler(vector_t *strvec)
{
	char *str = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(str, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(str, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, str);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}","vrrp_state_handler(vector_t *strvec)
{
	char *dr = strvec_slot(strvec, 1);
	vrrp_t *vrrp = LIST_TAIL_DATA(vrrp_data->vrrp);

	if (!strcmp(dr, ""MASTER""))
		vrrp->wantstate = VRRP_STATE_MAST;
	else if (!strcmp(dr, ""BACKUP""))
	{
		if (vrrp->wantstate == VRRP_STATE_MAST)
			report_config_error(CONFIG_GENERAL_ERROR, ""(%s) state previously set as MASTER - ignoring BACKUP"", vrrp->iname);
		else
			vrrp->wantstate = VRRP_STATE_BACK;
	}
	else {
		report_config_error(CONFIG_GENERAL_ERROR,""(%s) unknown state '%s', defaulting to BACKUP"", vrrp->iname, dr);
		vrrp->wantstate = VRRP_STATE_BACK;
	}
}",111.0,27.0,"str:dr,",63.0,0.0222180724143981,Greedy
742,"inline static bool jas_safe_size_add(size_t x, size_t y, size_t *result)
{
	if (y > SIZE_MAX - x) {
		*result = 0;
		return false;
	}
	*result = x + y;
	return true;
}","inline static bool jas_safe_size_add(size_t x, size_t bar, size_t *event)
{
	if (bar > SIZE_MAX - x) {
		*event = 0;
		return false;
	}
	*event = x + bar;
	return true;
}",45.0,11.0,"result:event,y:bar,",101.0,0.0366490244865417,Greedy
746,"
static void __skb_complete_tx_timestamp(struct sk_buff *skb,
					struct sock *sk,
					int tstype,
					bool opt_stats)
{
	struct sock_exterr_skb *serr;
	int err;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skb->cb));

	serr = SKB_EXT_ERR(skb);
	memset(serr, 0, sizeof(*serr));
	serr->ee.ee_errno = ENOMSG;
	serr->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	serr->ee.ee_info = tstype;
	serr->opt_stats = opt_stats;
	serr->header.h4.iif = skb->dev ? skb->dev->ifindex : 0;
	if (sk->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		serr->ee.ee_data = skb_shinfo(skb)->tskey;
		if (sk->sk_protocol == IPPROTO_TCP &&
		    sk->sk_type == SOCK_STREAM)
			serr->ee.ee_data -= sk->sk_tskey;
	}

	err = sock_queue_err_skb(sk, skb);

	if (err)
		kfree_skb(skb);","
static void __skb_complete_tx_timestamp(struct sk_buff *skilib,
					struct sock *skip,
					int tinstile,
					bool opt_stats)
{
	struct sock_exterr_skb *terrb;
	int Error;

	BUILD_BUG_ON(sizeof(struct sock_exterr_skb) > sizeof(skilib->cb));

	terrb = SKB_EXT_ERR(skilib);
	memset(terrb, 0, sizeof(*terrb));
	terrb->ee.ee_errno = ENOMSG;
	terrb->ee.ee_origin = SO_EE_ORIGIN_TIMESTAMPING;
	terrb->ee.ee_info = tinstile;
	terrb->opt_stats = opt_stats;
	terrb->header.h4.iif = skilib->dev ? skilib->dev->ifindex : 0;
	if (skip->sk_tsflags & SOF_TIMESTAMPING_OPT_ID) {
		terrb->ee.ee_data = skb_shinfo(skilib)->tskey;
		if (skip->sk_protocol == IPPROTO_TCP &&
		    skip->sk_type == SOCK_STREAM)
			terrb->ee.ee_data -= skip->sk_tskey;
	}

	Error = sock_queue_err_skb(skip, skilib);

	if (Error)
		kfree_skb(skilib);",181.0,44.0,"serr:terrb,skb:skilib,sk:skip,err:Error,tstype:tinstile,",377.0,0.1364036957422892,Greedy
756,"control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *message;
	u_int		 i;

	if (c->session == NULL)
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		message = evbuffer_new();
		evbuffer_add_printf(message, ""%%output %%%u "", wp->id);
		for (i = 0; i < len; i++) {
			if (buf[i] < ' ' || buf[i] == '\\')
			    evbuffer_add_printf(message, ""\\%03o"", buf[i]);
			else
			    evbuffer_add_printf(message, ""%c"", buf[i]);
		}
		control_write_buffer(c, message);
		evbuffer_free(message);
	}
}","control_notify_input(struct client *c, struct window_pane *wp,
    struct evbuffer *input)
{
	u_char		*buf;
	size_t		 len;
	struct evbuffer *metadata;
	u_int		 hi;

	if (c->session == NULL)
	    return;

	buf = EVBUFFER_DATA(input);
	len = EVBUFFER_LENGTH(input);

	/*
	 * Only write input if the window pane is linked to a window belonging
	 * to the client's session.
	 */
	if (winlink_find_by_window(&c->session->windows, wp->window) != NULL) {
		metadata = evbuffer_new();
		evbuffer_add_printf(metadata, ""%%output %%%u "", wp->id);
		for (hi = 0; hi < len; hi++) {
			if (buf[hi] < ' ' || buf[hi] == '\\')
			    evbuffer_add_printf(metadata, ""\\%03o"", buf[hi]);
			else
			    evbuffer_add_printf(metadata, ""%c"", buf[hi]);
		}
		control_write_buffer(c, metadata);
		evbuffer_free(metadata);
	}
}",170.0,44.0,"i:hi,message:metadata,",165.0,0.0728569189707438,Greedy
766,"(InitializerContext* const context) try {
    User* user = new User(UserName(""__system"", ""local""));

    user->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    user->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        user->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.user = user;

    return Status::OK();
} catch (...) {","(InitializerContext* const context) try {
    User* login = new User(UserName(""__system"", ""local""));

    login->incrementRefCount();  // Pin this user so the ref count never drops below 1.
    ActionSet allActions;
    allActions.addAllActions();
    PrivilegeVector privileges;
    RoleGraph::generateUniversalPrivileges(&privileges);
    login->addPrivileges(privileges);

    if (mongodGlobalParams.whitelistedClusterNetwork) {
        const auto& whitelist = *mongodGlobalParams.whitelistedClusterNetwork;

        auto restriction = stdx::make_unique<ClientSourceRestriction>(whitelist);
        auto restrictionSet = stdx::make_unique<RestrictionSet<>>(std::move(restriction));
        auto restrictionDocument =
            stdx::make_unique<RestrictionDocument<>>(std::move(restrictionSet));

        RestrictionDocuments clusterWhiteList(std::move(restrictionDocument));

        login->setRestrictions(std::move(clusterWhiteList));
    }


    internalSecurity.login = login;

    return Status::OK();
} catch (...) {",173.0,44.0,"user:login,",86.0,0.0346355994542439,Greedy
768,"static void nested_vmx_entry_failure(struct kvm_vcpu *vcpu,
			struct vmcs12 *vmcs12,
			u32 reason, unsigned long qualification)
{
	load_vmcs12_host_state(vcpu, vmcs12);
	vmcs12->vm_exit_reason = reason | VMX_EXIT_REASONS_FAILED_VMENTRY;
	vmcs12->exit_qualification = qualification;
	nested_vmx_succeed(vcpu);
	if (enable_shadow_vmcs)
		to_vmx(vcpu)->nested.sync_shadow_vmcs = true;
}","static void nested_vmx_entry_failure(struct kvm_vcpu *svgp,
			struct dmcss12 *dmcss12,
			u32 bid, unsigned long  Qualifier)
{
	load_vmcs12_host_state(svgp, dmcss12);
	dmcss12->vm_exit_reason = bid | VMX_EXIT_REASONS_FAILED_VMENTRY;
	dmcss12->exit_qualification =  Qualifier;
	nested_vmx_succeed(svgp);
	if (enable_shadow_vmcs)
		to_vmx(svgp)->nested.sync_shadow_vmcs = true;
}",64.0,18.0,"qualification: Qualifier,reason:bid,vcpu:svgp,vmcs12:dmcss12,",217.0,0.0738220691680908,Greedy
771,"int tcp_sendpage_locked(struct sock *sk, struct page *page, int offset,
			size_t size, int flags)
{
	if (!(sk->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(sk, page, offset, size, flags);

	tcp_rate_check_app_limited(sk);  /* is sending application-limited? */

	return do_tcp_sendpages(sk, page, offset, size, flags);
}","int tcp_sendpage_locked(struct sock *kt, struct area *area, int error,
			size_t size, int faces)
{
	if (!(kt->sk_route_caps & NETIF_F_SG))
		return sock_no_sendpage_locked(kt, area, error, size, faces);

	tcp_rate_check_app_limited(kt);  /* is sending application-limited? */

	return do_tcp_sendpages(kt, area, error, size, faces);
}",68.0,22.0,"size:size,sk:kt,offset:error,page:area,flags:faces,",269.0,0.0830400466918945,Greedy
777,"static void *arm_coherent_dma_alloc(struct device *dev, size_t size,
	dma_addr_t *handle, gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, PAGE_KERNEL);
	void *memory;

	if (dma_alloc_from_coherent(dev, size, handle, &memory))
		return memory;

	return __dma_alloc(dev, size, handle, gfp, prot, true,
			   __builtin_return_address(0));
}","static void *arm_coherent_dma_alloc(struct device *gpu, size_t dad,
	dma_addr_t *handle, gfp_t pgfp, struct dma_attrs *Attrib)
{
	pgprot_t prot = __get_dma_pgprot(Attrib, PAGE_KERNEL);
	void *Memory;

	if (dma_alloc_from_coherent(gpu, dad, handle, &Memory))
		return Memory;

	return __dma_alloc(gpu, dad, handle, pgfp, prot, true,
			   __builtin_return_address(0));
}",79.0,24.0,"attrs:Attrib,gfp:pgfp,size:dad,dev:gpu,memory:Memory,",202.0,0.0669951200485229,Greedy
788,"static inline u32 bytes_per_rt(const struct RESTART_TABLE *rt)
{
	return le16_to_cpu(rt->used) * le16_to_cpu(rt->size) +
	       sizeof(struct RESTART_TABLE);
}","static inline u32 bytes_per_rt(const struct RESTART_TABLE *buff)
{
	return le16_to_cpu(buff->used) * le16_to_cpu(buff->size) +
	       sizeof(struct RESTART_TABLE);
}",34.0,6.0,"rt:buff,",50.0,0.0213485678037007,Greedy
792,"bucket_insert (index_bucket *bucket,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (bucket->elem) {
		at = binary_search (bucket->elem, 0, bucket->num, handle);
		if (at < bucket->num && bucket->elem[at] == handle)
			return;
	}

	alloc = alloc_size (bucket->num);
	if (bucket->num + 1 > alloc) {
		CK_OBJECT_HANDLE *elem;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		elem = realloc (bucket->elem, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (elem != NULL);
		bucket->elem = elem;
	}

	return_if_fail (bucket->elem != NULL);
	memmove (bucket->elem + at + 1, bucket->elem + at,
	         (bucket->num - at) * sizeof (CK_OBJECT_HANDLE));
	bucket->elem[at] = handle;
	bucket->num++;
}","bucket_insert (index_bucket *binet,
               CK_OBJECT_HANDLE handle)
{
	unsigned int alloc;
	int at = 0;

	if (binet->gelev) {
		at = binary_search (binet->gelev, 0, binet->num, handle);
		if (at < binet->num && binet->gelev[at] == handle)
			return;
	}

	alloc = alloc_size (binet->num);
	if (binet->num + 1 > alloc) {
		CK_OBJECT_HANDLE *gelev;

		alloc = alloc ? alloc * 2 : 1;
		return_if_fail (alloc != 0);
		gelev = realloc (binet->gelev, alloc * sizeof (CK_OBJECT_HANDLE));
		return_if_fail (gelev != NULL);
		binet->gelev = gelev;
	}

	return_if_fail (binet->gelev != NULL);
	memmove (binet->gelev + at + 1, binet->gelev + at,
	         (binet->num - at) * sizeof (CK_OBJECT_HANDLE));
	binet->gelev[at] = handle;
	binet->num++;
}",188.0,50.0,"bucket:binet,elem:gelev,",302.0,0.0826639731725056,Greedy
794,"bit_write_bits (Bit_Chain *restrict dat, const char *restrict bits)
{
  char *p = (char *)bits;
  for (; *p; p++)
    {
      if (*p == '0' || *p == '1')
        bit_write_B (dat, *p != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s\n"", p);
          return;
        }
    }
}","bit_write_bits (Bit_Chain *restrict dim, const char *restrict bits)
{
  char *pat = (char *)bits;
  for (; *pat; pat++)
    {
      if (*pat == '0' || *pat == '1')
        bit_write_B (dim, *pat != '0');
      else
        {
          fprintf (stderr, ""Invalid binary input %s
"", pat);
          return;
        }
    }
}",77.0,15.0,"dat:dim,p:pat,",107.0,0.0385910630226135,Greedy
803,"static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addrbuf, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addrbuf, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addrbuf, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addrbuf, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addrbuf, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}","static void _6502_anal_esil_get_addr_pattern2(RAnalOp *op, const ut8* data, char* addzbafe, int addrsize, char reg) {
	// turn off bits 5, 6 and 7
	switch(data[0] & 0x1f) { // 0x1f = b00111111
	case 0x02: // op #$ff
		op->cycles = 2;
		snprintf (addzbafe, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x0a: //op a
		op->cycles = 2;
		snprintf (addzbafe, addrsize, ""a"");
		break;
	case 0x06: // op $ff
		op->cycles = 5;
		snprintf (addzbafe, addrsize, ""0x%02x"", data[1]);
		break;
	case 0x16: // op $ff,x
		op->cycles = 6;
		snprintf (addzbafe, addrsize, ""%c,0x%02x,+"", reg, data[1]);
		break;
	case 0x0e: // op $ffff
		op->cycles = 6;
		snprintf (addzbafe, addrsize, ""0x%04x"", data[1] | data[2] << 8);
		break;
	case 0x1e: // op $ffff,x
		op->cycles = 7;
		snprintf (addzbafe, addrsize, ""%c,0x%04x,+"", reg, data[1] | data[2] << 8);
		break;
	}
}",205.0,40.0,"reg:reg,addrbuf:addzbafe,",215.0,0.0796409487724304,Greedy
811,"static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk walk;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&walk, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &walk, 64);

	salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}

	while (walk.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr,
				      walk.nbytes - (walk.nbytes % 64));
		err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
	}

	if (walk.nbytes) {
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, walk.nbytes);
		err = blkcipher_walk_done(desc, &walk, 0);
	}

	return err;
}","static int encrypt(struct blkcipher_desc *desc,
		   struct scatterlist *dst, struct scatterlist *src,
		   unsigned int nbytes)
{
	struct blkcipher_walk watch;
	struct crypto_blkcipher *tfm = desc->tfm;
	struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
	int err;

	blkcipher_walk_init(&watch, dst, src, nbytes);
	err = blkcipher_walk_virt_block(desc, &watch, 64);

	salsa20_ivsetup(ctx, watch.iv);

	if (likely(watch.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, watch.dst.virt.addr,
				      watch.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &watch, 0);
	}

	while (watch.nbytes >= 64) {
		salsa20_encrypt_bytes(ctx, watch.dst.virt.addr,
				      watch.src.virt.addr,
				      watch.nbytes - (watch.nbytes % 64));
		err = blkcipher_walk_done(desc, &watch, watch.nbytes % 64);
	}

	if (watch.nbytes) {
		salsa20_encrypt_bytes(ctx, watch.dst.virt.addr,
				      watch.src.virt.addr, watch.nbytes);
		err = blkcipher_walk_done(desc, &watch, 0);
	}

	return err;
}",238.0,58.0,"walk:watch,",167.0,0.056174103418986,Greedy
827,"TfLiteTensor* GetOutput(TfLiteContext* context, const TfLiteNode* node,
                        int index) {
  if (context->tensors != nullptr) {
    return &context->tensors[node->outputs->data[index]];
  } else {
    return context->GetTensor(context, node->outputs->data[index]);
  }
}","TfLiteTensor* GetOutput(TfLiteContext* community, const TfLiteNode* note,
                        int sync) {
  if (community->tensors != nullptr) {
    return &community->tensors[note->outputs->data[sync]];
  } else {
    return community->GetTensor(community, note->outputs->data[sync]);
  }
}",64.0,12.0,"context:community,node:note,index:sync,",169.0,0.0675734758377075,Greedy
841,"struct sock *sk_alloc(struct net *net, int family, gfp_t priority,
		      struct proto *prot, int kern)
{
	struct sock *sk;

	sk = sk_prot_alloc(prot, priority | __GFP_ZERO, family);
	if (sk) {
		sk->sk_family = family;
		/*
		 * See comment in struct sock definition to understand
		 * why we need sk_prot_creator -acme
		 */
		sk->sk_prot = sk->sk_prot_creator = prot;
		sk->sk_kern_sock = kern;
		sock_lock_init(sk);
		sk->sk_net_refcnt = kern ? 0 : 1;
		if (likely(sk->sk_net_refcnt))
			get_net(net);
		sock_net_set(sk, net);
		refcount_set(&sk->sk_wmem_alloc, 1);

		mem_cgroup_sk_alloc(sk);
		cgroup_sk_alloc(&sk->sk_cgrp_data);
		sock_update_classid(&sk->sk_cgrp_data);
		sock_update_netprioidx(&sk->sk_cgrp_data);
	}

	return sk;
}","struct sock *sk_alloc(struct prefix *prefix, int mode, gfp_t priority,
		      struct proto *pattern, int qenn)
{
	struct sock *kid;

	kid = sk_prot_alloc(pattern, priority | __GFP_ZERO, mode);
	if (kid) {
		kid->sk_family = mode;
		/*
		 * See comment in struct sock definition to understand
		 * why we need sk_prot_creator -acme
		 */
		kid->sk_prot = kid->sk_prot_creator = pattern;
		kid->sk_kern_sock = qenn;
		sock_lock_init(kid);
		kid->sk_net_refcnt = qenn ? 0 : 1;
		if (likely(kid->sk_net_refcnt))
			get_net(prefix);
		sock_net_set(kid, prefix);
		refcount_set(&kid->sk_wmem_alloc, 1);

		mem_cgroup_sk_alloc(kid);
		cgroup_sk_alloc(&kid->sk_cgrp_data);
		sock_update_classid(&kid->sk_cgrp_data);
		sock_update_netprioidx(&kid->sk_cgrp_data);
	}

	return kid;
}",150.0,43.0,"sk:kid,kern:qenn,net:prefix,prot:pattern,family:mode,",290.0,0.1143898765246073,Greedy
843,"static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *args = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		args = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, args);
	}

	VariantInit(&v);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, args)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}

	if (args) {
		efree(args);
	}

	return ret;
}","static int com_call_method(zend_string *method, zend_object *object, INTERNAL_FUNCTION_PARAMETERS)
{
	zval *missing = NULL;
	php_com_dotnet_object *obj = (php_com_dotnet_object*)object;
	int nargs;
	VARIANT v;
	int ret = FAILURE;

	if (V_VT(&obj->v) != VT_DISPATCH) {
		return FAILURE;
	}

	nargs = ZEND_NUM_ARGS();

	if (nargs) {
		missing = (zval *)safe_emalloc(sizeof(zval), nargs, 0);
		zend_get_parameters_array_ex(nargs, missing);
	}

	VariantInit(&v);

	if (SUCCESS == php_com_do_invoke_byref(obj, (zend_internal_function*)EX(func), DISPATCH_METHOD|DISPATCH_PROPERTYGET, &v, nargs, missing)) {
		php_com_zval_from_variant(return_value, &v, obj->code_page);
		ret = SUCCESS;
		VariantClear(&v);
	}

	if (missing) {
		efree(missing);
	}

	return ret;
}",170.0,48.0,"method:method,object:object,obj:obj,args:missing,",211.0,0.0901966333389282,Greedy
844,"SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutex_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}","SQLiteDBInstanceRef SQLiteDBManager::getConnection(bool primary) {
  auto& self = instance();
  WriteLock lock(self.create_mutex_);

  if (self.db_ == nullptr) {
    // Create primary SQLite DB instance.
    openOptimized(self.db_);
    self.connection_ = SQLiteDBInstanceRef(new SQLiteDBInstance(self.db_));
    attachVirtualTables(self.connection_);
  }

  // Internal usage may request the primary connection explicitly.
  if (primary) {
    return self.connection_;
  }

  // Create a 'database connection' for the managed database instance.
  auto instance = std::make_shared<SQLiteDBInstance>(self.db_, self.mutux_);
  if (!instance->isPrimary()) {
    attachVirtualTables(instance);
  }
  return instance;
}",114.0,24.0,"mutex_:mutux_,",21.0,0.0252076148986816,Greedy
863,"_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t i;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;

    for (i = 0; i < self->unpickler->memo_size; i++) {
        int status;
        PyObject *key, *value;

        value = self->unpickler->memo[i];
        if (value == NULL)
            continue;

        key = PyLong_FromSsize_t(i);
        if (key == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, key, value);
        Py_DECREF(key);
        if (status < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}","_pickle_UnpicklerMemoProxy_copy_impl(UnpicklerMemoProxyObject *self)
/*[clinic end generated code: output=e12af7e9bc1e4c77 input=97769247ce032c1d]*/
{
    Py_ssize_t eni;
    PyObject *new_memo = PyDict_New();
    if (new_memo == NULL)
        return NULL;

    for (eni = 0; eni < self->unpickler->memo_size; eni++) {
        int status;
        PyObject *fee, *value;

        value = self->unpickler->memo[eni];
        if (value == NULL)
            continue;

        fee = PyLong_FromSsize_t(eni);
        if (fee == NULL)
            goto error;
        status = PyDict_SetItem(new_memo, fee, value);
        Py_DECREF(fee);
        if (status < 0)
            goto error;
    }
    return new_memo;

error:
    Py_DECREF(new_memo);
    return NULL;
}",130.0,32.0,"i:eni,key:fee,",145.0,0.0602999250094095,Greedy
872,"static void oss_poll_in (HWVoiceIn *hw)
{
    OSSVoiceIn *oss = (OSSVoiceIn *) hw;

    qemu_set_fd_handler(oss->fd, oss_helper_poll_in, NULL, hw->s);
}","static void oss_poll_in (HWVoiceIn *qq)
{
    OSSVoiceIn *cross = (OSSVoiceIn *) qq;

    qemu_set_fd_handler(cross->fd, oss_helper_poll_in, NULL, qq->s);
}",35.0,8.0,"hw:qq,oss:cross,",91.0,0.043537171681722,Greedy
879,"static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetMac, macData, sizeof(macData)) == 0);
}","static BOOL license_decrypt_and_check_MAC(rdpLicense* license, const BYTE* input, size_t len,
                                          LICENSE_BLOB* target, const BYTE* packetteMac)
{
	BYTE macData[16];

	return license_rc4_with_licenseKey(license, input, len, target) &&
	       security_mac_data(license->MacSaltKey, target->data, len, macData) &&
	       (memcmp(packetteMac, macData, sizeof(macData)) == 0);
}",76.0,21.0,"packetMac:packetteMac,",64.0,0.0346547365188598,Greedy
886,"static uint64_t get_refcount(unsigned int order, void *rcblock, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcblock)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcblock)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcblock)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcblock)[index];
	case 4:
		return be16toh(((uint16_t *)rcblock)[index]);
	case 5:
		return be32toh(((uint32_t *)rcblock)[index]);
	case 6:
		return be64toh(((uint64_t *)rcblock)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}","static uint64_t get_refcount(unsigned int order, void *rcview, size_t index)
{
	switch (order) {
	case 0:
		return (((uint8_t *)rcview)[index / 8] >> (index % 8)) & 0x1;
	case 1:
		return (((uint8_t *)rcview)[index / 4] >> (2 * (index % 4))) & 0x3;
	case 2:
		return (((uint8_t *)rcview)[index / 2] >> (4 * (index % 2))) & 0xf;
	case 3:
		return ((uint8_t *)rcview)[index];
	case 4:
		return be16toh(((uint16_t *)rcview)[index]);
	case 5:
		return be32toh(((uint32_t *)rcview)[index]);
	case 6:
		return be64toh(((uint64_t *)rcview)[index]);
	default:
		assert(0);
	}

	return 0;	/* NOT REACHED */
}",191.0,26.0,"rcblock:rcview,",102.0,0.0432985504468282,Greedy
902,"static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *buf)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(buf, ""Data\n"");
	case CACHE_TYPE_INST:
		return sprintf(buf, ""Instruction\n"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(buf, ""Unified\n"");
	default:
		return -EINVAL;
	}
}","static ssize_t type_show(struct device *dev,
			 struct device_attribute *attr, char *cmd)
{
	struct cacheinfo *this_leaf = dev_get_drvdata(dev);

	switch (this_leaf->type) {
	case CACHE_TYPE_DATA:
		return sprintf(cmd, ""Data
"");
	case CACHE_TYPE_INST:
		return sprintf(cmd, ""Instruction
"");
	case CACHE_TYPE_UNIFIED:
		return sprintf(cmd, ""Unified
"");
	default:
		return -EINVAL;
	}
}",83.0,18.0,"buf:cmd,",59.0,0.0335330526034037,Greedy
904,"static struct dst_entry *rxe_find_route6(struct net_device *ndev,
					 struct in6_addr *saddr,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndev->ifindex;
	memcpy(&fl6.saddr, saddr, sizeof(*saddr));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6\n"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6\n"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}","static struct dst_entry *rxe_find_route6(struct net_device *ndeva,
					 struct in6_addr *saddress,
					 struct in6_addr *daddr)
{
	struct dst_entry *ndst;
	struct flowi6 fl6 = { { 0 } };

	memset(&fl6, 0, sizeof(fl6));
	fl6.flowi6_oif = ndeva->ifindex;
	memcpy(&fl6.saddress, saddress, sizeof(*saddress));
	memcpy(&fl6.daddr, daddr, sizeof(*daddr));
	fl6.flowi6_proto = IPPROTO_UDP;

	if (unlikely(ipv6_stub->ipv6_dst_lookup(sock_net(recv_sockets.sk6->sk),
						recv_sockets.sk6->sk, &ndst, &fl6))) {
		pr_err_ratelimited(""no route to %pI6
"", daddr);
		goto put;
	}

	if (unlikely(ndst->error)) {
		pr_err(""no route to %pI6
"", daddr);
		goto put;
	}

	return ndst;
put:
	dst_release(ndst);
	return NULL;
}",178.0,37.0,"ndev:ndeva,saddr:saddress,",99.0,0.0529491623242696,Greedy
905,"static int do_new_mount(struct path *path, const char *fstype, int flags,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *type;
	struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
	struct vfsmount *mnt;
	int err;

	if (!fstype)
		return -EINVAL;

	type = get_fs_type(fstype);
	if (!type)
		return -ENODEV;

	if (user_ns != &init_user_ns) {
		if (!(type->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(type);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
		 */
		if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
			flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
		}
	}

	mnt = vfs_kern_mount(type, flags, name, data);
	if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
	    !mnt->mnt_sb->s_subtype)
		mnt = fs_set_subtype(mnt, fstype);

	put_filesystem(type);
	if (IS_ERR(mnt))
		return PTR_ERR(mnt);

	err = do_add_mount(real_mount(mnt), path, mnt_flags);
	if (err)
		mntput(mnt);
	return err;
}","static int do_new_mount(struct path *path, const char *fctime, int lag,
			int mnt_flags, const char *name, void *data)
{
	struct file_system_type *like;
	struct user_namespace *userfns = current->nsproxy->mnt_ns->userfns;
	struct vfsmount *cmnd;
	int here;

	if (!fctime)
		return -EINVAL;

	like = get_fs_type(fctime);
	if (!like)
		return -ENODEV;

	if (userfns != &init_user_ns) {
		if (!(like->fs_flags & FS_USERNS_MOUNT)) {
			put_filesystem(like);
			return -EPERM;
		}
		/* Only in special cases allow devices from mounts
		 * created outside the initial user namespace.
		 */
		if (!(like->fs_flags & FS_USERNS_DEV_MOUNT)) {
			lag |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
		}
	}

	cmnd = vfs_kern_mount(like, lag, name, data);
	if (!IS_ERR(cmnd) && (like->fs_flags & FS_HAS_SUBTYPE) &&
	    !cmnd->mnt_sb->s_subtype)
		cmnd = fs_set_subtype(cmnd, fctime);

	put_filesystem(like);
	if (IS_ERR(cmnd))
		return PTR_ERR(cmnd);

	here = do_add_mount(real_mount(cmnd), path, mnt_flags);
	if (here)
		mntput(cmnd);
	return here;
}",223.0,63.0,"mnt:cmnd,type:like,err:here,fstype:fctime,user_ns:userfns,flags:lag,",415.0,0.1661448319753011,Greedy
909,"void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
			 struct hsr_port *port)
{
	struct hsr_node *node_dst;

	if (!skb_mac_header_was_set(skb)) {
		WARN_ONCE(1, ""%s: Mac header not set\n"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(skb)->h_dest))
		return;

	node_dst = find_node_by_AddrA(&port->hsr->node_db, eth_hdr(skb)->h_dest);
	if (!node_dst) {
		WARN_ONCE(1, ""%s: Unknown node\n"", __func__);
		return;
	}
	if (port->type != node_dst->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(skb)->h_dest, node_dst->MacAddressB);
}","void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *arkb,
			 struct hsr_port *option)
{
	struct hsr_node *node_Dtr;

	if (!skb_mac_header_was_set(arkb)) {
		WARN_ONCE(1, ""%s: Mac header not set
"", __func__);
		return;
	}

	if (!is_unicast_ether_addr(eth_hdr(arkb)->h_dest))
		return;

	node_Dtr = find_node_by_AddrA(&option->hsr->node_db, eth_hdr(arkb)->h_dest);
	if (!node_Dtr) {
		WARN_ONCE(1, ""%s: Unknown node
"", __func__);
		return;
	}
	if (option->type != node_Dtr->AddrB_port)
		return;

	ether_addr_copy(eth_hdr(arkb)->h_dest, node_Dtr->MacAddressB);
}",128.0,26.0,"node_src:node_src,port:option,node_dst:node_Dtr,skb:arkb,",174.0,0.090713349978129,Greedy
920,"parse_footnote_list(struct buf *ob, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *work = 0;
	struct footnote_item *item;
	struct footnote_ref *ref;

	if (footnotes->count == 0)
		return;

	work = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		ref = item->ref;
		parse_footnote_def(work, rndr, ref->num, ref->contents->data, ref->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(ob, work, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}","parse_footnote_list(struct buf *obo, struct sd_markdown *rndr, struct footnote_list *footnotes)
{
	struct buf *allow = 0;
	struct footnote_item *item;
	struct footnote_ref *part;

	if (footnotes->count == 0)
		return;

	allow = rndr_newbuf(rndr, BUFFER_BLOCK);

	item = footnotes->head;
	while (item) {
		part = item->part;
		parse_footnote_def(allow, rndr, part->num, part->contents->data, part->contents->size);
		item = item->next;
	}

	if (rndr->cb.footnotes)
		rndr->cb.footnotes(obo, allow, rndr->opaque);
	rndr_popbuf(rndr, BUFFER_BLOCK);
}",132.0,33.0,"ob:obo,work:allow,ref:part,",192.0,0.0822096665700276,Greedy
961,"static struct dentry *aio_mount(struct file_system_type *fs_type,
				int flags, const char *dev_name, void *data)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}","static struct dentry *aio_mount(struct file_system_type *fs_type,
				int options, const char *devdevpath, void *bytes)
{
	struct dentry *root = mount_pseudo(fs_type, ""aio:"", NULL, NULL,
					   AIO_RING_MAGIC);

	if (!IS_ERR(root))
		root->d_sb->s_iflags |= SB_I_NOEXEC;
	return root;
}",63.0,14.0,"dev_name:devdevpath,flags:options,data:bytes,",80.0,0.0494367122650146,Greedy
963,"void ping_unhash(struct sock *sk)
{
	struct inet_sock *isk = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)\n"", isk, isk->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		isk->inet_num = 0;
		isk->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}","void ping_unhash(struct sock *sk)
{
	struct inet_sock *cc = inet_sk(sk);
	pr_debug(""ping_unhash(isk=%p,isk->num=%u)
"", cc, cc->inet_num);
	if (sk_hashed(sk)) {
		write_lock_bh(&ping_table.lock);
		hlist_nulls_del(&sk->sk_nulls_node);
		sock_put(sk);
		cc->inet_num = 0;
		cc->inet_sport = 0;
		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, -1);
		write_unlock_bh(&ping_table.lock);
	}
}",97.0,24.0,"isk:cc,",70.0,0.0397614280382792,Greedy
971,"ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *fsr,
                                 struct ofpbuf *b, bool aggregate,
                                 const struct tun_table *tun_table,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nfsr;
    enum ofperr error;

    nfsr = ofpbuf_pull(b, sizeof *nfsr);
    error = nx_pull_match(b, ntohs(nfsr->match_len), &fsr->match,
                          &fsr->cookie, &fsr->cookie_mask, tun_table,
                          vl_mff_map);
    if (error) {
        return error;
    }
    if (b->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }

    fsr->aggregate = aggregate;
    fsr->out_port = u16_to_ofp(ntohs(nfsr->out_port));
    fsr->out_group = OFPG_ANY;
    fsr->table_id = nfsr->table_id;

    return 0;
}","ofputil_decode_nxst_flow_request(struct ofputil_flow_stats_request *tsr,
                                 struct ofpbuf *usb, bool integrate,
                                 const struct pin_map *pin_map,
                                 const struct vl_mff_map *vl_mff_map)
{
    const struct nx_flow_stats_request *nmesrf;
    enum ofperr bug;

    nmesrf = ofpbuf_pull(usb, sizeof *nmesrf);
    bug = nx_pull_match(usb, ntohs(nmesrf->match_len), &tsr->match,
                          &tsr->cookie, &tsr->cookie_mask, pin_map,
                          vl_mff_map);
    if (bug) {
        return bug;
    }
    if (usb->size) {
        return OFPERR_OFPBRC_BAD_LEN;
    }

    tsr->integrate = integrate;
    tsr->out_port = u16_to_ofp(ntohs(nmesrf->out_port));
    tsr->out_group = OFPG_ANY;
    tsr->table_id = nmesrf->table_id;

    return 0;
}",140.0,36.0,"aggregate:integrate,error:bug,tun_table:pin_map,b:usb,nfsr:nmesrf,fsr:tsr,",428.0,0.1537926952044169,Greedy
986,"static inline void ConvertLuvToXYZ(const double L,const double u,const double v,
  double *X,double *Y,double *Z)
{
  double
    gamma;

  assert(X != (double *) NULL);
  assert(Y != (double *) NULL);
  assert(Z != (double *) NULL);
  if (L > (CIEK*CIEEpsilon))
    *Y=(double) pow((L+16.0)/116.0,3.0);
  else
    *Y=L/CIEK;
  gamma=PerceptibleReciprocal((((52.0*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *X=gamma*((*Y*((39.0*L/(v+13.0*L*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Y));
  *Z=(*X*(((52.0f*L/(u+13.0*L*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Y);
}","static inline void ConvertLuvToXYZ(const double NL,const double x,const double v,
  double *Image,double *Time,double *I)
{
  double
    gamema;

  assert(Image != (double *) NULL);
  assert(Time != (double *) NULL);
  assert(I != (double *) NULL);
  if (NL > (CIEK*CIEEpsilon))
    *Time=(double) pow((NL+16.0)/116.0,3.0);
  else
    *Time=NL/CIEK;
  gamema=PerceptibleReciprocal((((52.0*NL/(x+13.0*NL*(4.0*D65X/(D65X+15.0*D65Y+
    3.0*D65Z))))-1.0)/3.0)-(-1.0/3.0));
  *Image=gamema*((*Time*((39.0*NL/(v+13.0*NL*(9.0*D65Y/(D65X+15.0*D65Y+3.0*D65Z))))-5.0))+
    5.0*(*Time));
  *I=(*Image*(((52.0f*NL/(x+13.0*NL*(4.0*D65X/(D65X+15.0*D65Y+3.0*D65Z))))-1.0)/3.0))-
    5.0*(*Time);
}",265.0,53.0,"L:NL,Y:Time,X:Image,u:x,Z:I,gamma:gamema,",297.0,0.1357034643491109,Greedy
989,"v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buffer, *p;
  size_t nbytes;

  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  /* fixme: allocate it on the stack */
  buffer = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buffer, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buffer + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buffer);
  return ki[1];
}","v3_keyid (gcry_mpi_t a, u32 *ki)
{
  byte *buff, *p;
  size_t nbytes;

  if (gcry_mpi_print (GCRYMPI_FMT_USG, NULL, 0, &nbytes, a ))
    BUG ();
  /* fixme: allocate it on the stack */
  buff = xmalloc (nbytes);
  if (gcry_mpi_print( GCRYMPI_FMT_USG, buff, nbytes, NULL, a ))
    BUG ();
  if (nbytes < 8) /* oops */
    ki[0] = ki[1] = 0;
  else
    {
      p = buff + nbytes - 8;
      ki[0] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
      p += 4;
      ki[1] = (p[0] << 24) | (p[1] <<16) | (p[2] << 8) | p[3];
    }
  xfree (buff);
  return ki[1];
}",185.0,40.0,"buffer:buff,",79.0,0.0383948961893717,Greedy
1005,"int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **flags, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*flags = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}","int tty_prepare_flip_string_flags(struct tty_struct *tty,
			unsigned char **chars, char **f, size_t size)
{
	int space = tty_buffer_request_room(tty, size);
	if (likely(space)) {
		struct tty_buffer *tb = tty->buf.tail;
		*chars = tb->char_buf_ptr + tb->used;
		*f = tb->flag_buf_ptr + tb->used;
		tb->used += space;
	}
	return space;
}",85.0,22.0,"flags:f,",65.0,0.0319383064905802,Greedy
1010,"static struct sock *nr_find_socket(unsigned char index, unsigned char id)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == index && nr->my_id == id) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}","static struct sock *nr_find_socket(unsigned char slice, unsigned char length)
{
	struct sock *s;

	spin_lock_bh(&nr_list_lock);
	sk_for_each(s, &nr_list) {
		struct nr_sock *nr = nr_sk(s);

		if (nr->my_index == slice && nr->my_id == length) {
			bh_lock_sock(s);
			goto found;
		}
	}
	s = NULL;
found:
	spin_unlock_bh(&nr_list_lock);
	return s;
}",86.0,22.0,"index:slice,id:length,",99.0,0.0496286034584045,Greedy
1012,"static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 NumInterfaces)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < NumInterfaces; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}","static void msusb_msinterface_free_list(MSUSB_INTERFACE_DESCRIPTOR** MsInterfaces,
                                        UINT32 Numinterlements)
{
	UINT32 inum = 0;

	if (MsInterfaces)
	{
		for (inum = 0; inum < Numinterlements; inum++)
		{
			msusb_msinterface_free(MsInterfaces[inum]);
		}

		free(MsInterfaces);
	}
}",53.0,14.0,"NumInterfaces:Numinterlements,",40.0,0.0304046034812927,Greedy
1030,"  bool isCounterMetricId(uint32_t metric_id) {
    return (metric_id & kMetricTypeMask) == kMetricTypeCounter;
  }","  bool isCounterMetricId(uint32_t metrikricid) {
    return (metrikricid & kMetricTypeMask) == kMetricTypeCounter;
  }",17.0,5.0,"metric_id:metrikricid,",27.0,0.0248424887657165,Greedy
1039,"void xenvif_notify_tx_completion(struct xenvif *vif)
{
	if (netif_queue_stopped(vif->dev) && xenvif_rx_schedulable(vif))
		netif_wake_queue(vif->dev);
}","void xenvif_notify_tx_completion(struct xenvif *xiq)
{
	if (netif_queue_stopped(xiq->dev) && xenvif_rx_schedulable(xiq))
		netif_wake_queue(xiq->dev);
}",31.0,8.0,"vif:xiq,",54.0,0.0321535189946492,Greedy
1043,"uid_t from_kuid(struct user_namespace *targ, kuid_t kuid)
{
	/* Map the uid from a global kernel uid */
	return map_id_up(&targ->uid_map, __kuid_val(kuid));
}","uid_t from_kuid(struct user_namespace *tsargs, kuid_t cuid)
{
	/* Map the uid from a global kernel uid */
	return map_id_up(&tsargs->uid_map, __kuid_val(cuid));
}",27.0,7.0,"kuid:cuid,targ:tsargs,",61.0,0.0434857130050659,Greedy
1045,"static void free_certs(cert_object_t **certs, int cert_count)
{
  int i;

  for (i = 0; i < cert_count; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}","static void free_certs(cert_object_t **certs, int certPlimit)
{
  int i;

  for (i = 0; i < certPlimit; i++) {
    if (!certs[i]) {
	continue;
    }
    if (certs[i]->x509 != NULL)
      X509_free(certs[i]->x509);
    if (certs[i]->id != NULL)
      free(certs[i]->id);
    free(certs[i]);
  }
  free(certs);
}",99.0,25.0,"cert_count:certPlimit,",41.0,0.0316238204638163,Greedy
1048,"struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *vsi,
					    const u8 *macaddr)
{
	struct i40e_mac_filter *f, *add = NULL;
	struct hlist_node *h;
	int bkt;

	if (vsi->info.pvid)
		return i40e_add_filter(vsi, macaddr,
				       le16_to_cpu(vsi->info.pvid));

	if (!i40e_is_vsi_in_vlan(vsi))
		return i40e_add_filter(vsi, macaddr, I40E_VLAN_ANY);

	hash_for_each_safe(vsi->mac_filter_hash, bkt, h, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		add = i40e_add_filter(vsi, macaddr, f->vlan);
		if (!add)
			return NULL;
	}

	return add;
}","struct i40e_mac_filter *i40e_add_mac_filter(struct i40e_vsi *bsis,
					    const u8 *ipord)
{
	struct i40e_mac_filter *f, *Add = NULL;
	struct hlist_node *rh;
	int pkt;

	if (bsis->info.pvid)
		return i40e_add_filter(bsis, ipord,
				       le16_to_cpu(bsis->info.pvid));

	if (!i40e_is_vsi_in_vlan(bsis))
		return i40e_add_filter(bsis, ipord, I40E_VLAN_ANY);

	hash_for_each_safe(bsis->mac_filter_hash, pkt, rh, f, hlist) {
		if (f->state == I40E_FILTER_REMOVE)
			continue;
		Add = i40e_add_filter(bsis, ipord, f->vlan);
		if (!Add)
			return NULL;
	}

	return Add;
}",129.0,34.0,"vsi:bsis,bkt:pkt,macaddr:ipord,add:Add,h:rh,",267.0,0.1108211119969685,Greedy
1054,"static char *linetoken(FILE *stream)
{
    int ch, idx;

    while ((ch = fgetc(stream)) == ' ' || ch == '\t' ); 
    
    idx = 0;
    while (ch != EOF && ch != lineterm) 
    {
        ident[idx++] = ch;
        ch = fgetc(stream);
    } /* while */
    
    ungetc(ch, stream);
    ident[idx] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */","static char *linetoken(FILE *speed)
{
    int val, ideX;

    while ((val = fgetc(speed)) == ' ' || val == '\t' ); 
    
    ideX = 0;
    while (val != EOF && val != lineterm) 
    {
        ident[ideX++] = val;
        val = fgetc(speed);
    } /* while */
    
    ungetc(val, speed);
    ident[ideX] = 0;

    return(ident);	/* returns pointer to the token */

} /* linetoken */",87.0,25.0,"ch:val,stream:speed,idx:ideX,",172.0,0.0675139784812927,Greedy
1086,"R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *bin, int i) {
	if (i < 1 || i > bin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *obj = (RBinJavaCPTypeObj *) r_list_get_n (bin->cp_list, i);
	return obj ? obj : &R_BIN_JAVA_NULL_TYPE;
}","R_API RBinJavaCPTypeObj *r_bin_java_get_item_from_cp(RBinJavaObj *pin, int chi) {
	if (chi < 1 || chi > pin->cf.cp_count) {
		return &R_BIN_JAVA_NULL_TYPE;
	}
	RBinJavaCPTypeObj *ocr = (RBinJavaCPTypeObj *) r_list_get_n (pin->cp_list, chi);
	return ocr ? ocr : &R_BIN_JAVA_NULL_TYPE;
}",59.0,15.0,"i:chi,obj:ocr,bin:pin,",160.0,0.0651233156522115,Greedy
1106,"NOEXPORT void save_peer_certificate(WPARAM wParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && wParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)wParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)wParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}","NOEXPORT void save_peer_certificate(WPARAM rParam) {
    SERVICE_OPTIONS *section;
    unsigned section_number;

    CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_SECTIONS]);
    for(section=service_options.next, section_number=0;
            section && rParam!=IDM_PEER_MENU+section_number;
            section=section->next, ++section_number)
        ;
    if(section && !save_text_file(section->file, section->chain)) {
#ifndef _WIN32_WCE
        if(main_menu_handle)
            CheckMenuItem(main_menu_handle, (UINT)rParam, MF_CHECKED);
#endif
        if(tray_menu_handle)
            CheckMenuItem(tray_menu_handle, (UINT)rParam, MF_CHECKED);
        message_box(section->help, MB_ICONINFORMATION);
    }
    CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SECTIONS]);
}",124.0,39.0,"section_number:section_number,wParam:rParam,",75.0,0.0492372711499532,Greedy
1110,"QString Avahi::domainToDNS(const QString &domain)
{
    return isLocalDomain(domain) ? domain : QUrl::toAce(domain);
}","QString Avahi::domainToDNS(const QString &model)
{
    return isLocalDomain(model) ? model : QUrl::toAce(model);
}",27.0,7.0,"domain:model,",53.0,0.0292192538579305,Greedy
1112,"bgp_attr_atomic (struct peer *peer, bgp_size_t length, 
		 struct attr *attr, u_char flag, u_char *startp)
{
  bgp_size_t total;

  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
  /* Flag checks. */
  if (bgp_attr_flag_invalid (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag))
    return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                               startp, total);
  
  /* Length check. */
  if (length != 0)
    {
      zlog (peer->log, LOG_ERR, ""ATOMIC_AGGREGATE attribute length isn't 0 [%u]"", length);
      return bgp_attr_malformed (peer, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 startp, total);
    }

  /* Set atomic aggregate flag. */
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);

  return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_atomic (struct eth *eth, bgp_size_t length, 
		 struct attr *attr, u_char flag, u_char *startp)
{
  bgp_size_t total;

  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);
  /* Flag checks. */
  if (bgp_attr_flag_invalid (eth, BGP_ATTR_ATOMIC_AGGREGATE, flag))
    return bgp_attr_malformed (eth, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                               BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                               startp, total);
  
  /* Length check. */
  if (length != 0)
    {
      zlog (eth->log, LOG_ERR, ""ATOMIC_AGGREGATE attribute length isn't 0 [%u]"", length);
      return bgp_attr_malformed (eth, BGP_ATTR_ATOMIC_AGGREGATE, flag,
                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                 startp, total);
    }

  /* Set atomic aggregate flag. */
  attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);

  return BGP_ATTR_PARSE_PROCEED;
}",121.0,39.0,"peer:eth,",90.0,0.0415507197380065,Greedy
1116,"void TableLookUp::setTable(int ntable, const std::vector<ushort16>& table) {
  assert(!table.empty());

  const int nfilled = table.size();

  if (ntable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* t = &tables[ntable * TABLE_SIZE];
  if (!dither) {
    for (int i = 0; i < 65536; i++) {
      t[i] = (i < nfilled) ? table[i] : table[nfilled - 1];
    }
    return;
  }
  for (int i = 0; i < nfilled; i++) {
    int center = table[i];
    int lower = i > 0 ? table[i - 1] : center;
    int upper = i < (nfilled - 1) ? table[i + 1] : center;
    int delta = upper - lower;
    t[i * 2] = center - ((upper - lower + 2) / 4);
    t[i * 2 + 1] = delta;
  }

  for (int i = nfilled; i < 65536; i++) {
    t[i * 2] = table[nfilled - 1];
    t[i * 2 + 1] = 0;
  }
  t[0] = t[1];
  t[TABLE_SIZE - 1] = t[TABLE_SIZE - 2];
}","void TableLookUp::setTable(int notable, const std::vector<ushort16>& conference) {
  assert(!conference.empty());

  const int nfilled = conference.size();

  if (notable > ntables) {
    ThrowRDE(""Table lookup with number greater than number of tables."");
  }
  ushort16* time = &tables[notable * TABLE_SIZE];
  if (!dither) {
    for (int x = 0; x < 65536; x++) {
      time[x] = (x < nfilled) ? conference[x] : conference[nfilled - 1];
    }
    return;
  }
  for (int x = 0; x < nfilled; x++) {
    int center = conference[x];
    int lower = x > 0 ? conference[x - 1] : center;
    int upper = x < (nfilled - 1) ? conference[x + 1] : center;
    int delta = upper - lower;
    time[x * 2] = center - ((upper - lower + 2) / 4);
    time[x * 2 + 1] = delta;
  }

  for (int x = nfilled; x < 65536; x++) {
    time[x * 2] = conference[nfilled - 1];
    time[x * 2 + 1] = 0;
  }
  time[0] = time[1];
  time[TABLE_SIZE - 1] = time[TABLE_SIZE - 2];
}",278.0,71.0,"i:x,t:time,table:conference,ntable:notable,",289.0,0.1096097429593404,Greedy
1129,"int ecall_restore(const char *input, uint64_t input_len, char **output,
                  uint64_t *output_len) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(input,
                                                              input_len) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
          output_len, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_output_len;
  try {
    result = asylo::Restore(input, static_cast<size_t>(input_len), output,
                            &tmp_output_len);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if (output_len) {
    *output_len = static_cast<uint64_t>(tmp_output_len);
  }
  return result;
}","int ecall_restore(const char *child, uint64_t input___line, char **output,
                  uint64_t * output_lon) {
  if (!asylo::primitives::TrustedPrimitives::IsOutsideEnclave(child,
                                                              input___line) ||
      !asylo::primitives::TrustedPrimitives::IsOutsideEnclave(
           output_lon, sizeof(uint64_t))) {
    asylo::primitives::TrustedPrimitives::BestEffortAbort(
        ""ecall_restore: input/output found to not be in untrusted memory."");
  }
  int result = 0;
  size_t tmp_outputsl;
  try {
    result = asylo::Restore(child, static_cast<size_t>(input___line), output,
                            &tmp_outputsl);
  } catch (...) {
    LOG(FATAL) << ""Uncaught exception in enclave"";
  }

  if ( output_lon) {
    * output_lon = static_cast<uint64_t>(tmp_outputsl);
  }
  return result;
}",136.0,27.0,"output_len: output_lon,input_len:input___line,tmp_output_len:tmp_outputsl,input:child,",124.0,0.0738282720247904,Greedy
1151,"unsigned char *cipso_v4_optptr(const struct sk_buff *skb)
{
	const struct iphdr *iph = ip_hdr(skb);
	unsigned char *optptr = (unsigned char *)&(ip_hdr(skb)[1]);
	int optlen;
	int taglen;

	for (optlen = iph->ihl*4 - sizeof(struct iphdr); optlen > 0; ) {
		if (optptr[0] == IPOPT_CIPSO)
			return optptr;
		taglen = optptr[1];
		optlen -= taglen;
		optptr += taglen;
	}

	return NULL;
}","unsigned char *cipso_v4_optptr(const struct sk_buff * skf)
{
	const struct iphdr *iph = ip_hdr( skf);
	unsigned char *optimPtr = (unsigned char *)&(ip_hdr( skf)[1]);
	int optimcount;
	int ackln;

	for (optimcount = iph->ihl*4 - sizeof(struct iphdr); optimcount > 0; ) {
		if (optimPtr[0] == IPOPT_CIPSO)
			return optimPtr;
		ackln = optimPtr[1];
		optimcount -= ackln;
		optimPtr += ackln;
	}

	return NULL;
}",104.0,22.0,"optptr:optimPtr,taglen:ackln,optlen:optimcount,skb: skf,",182.0,0.083505113919576,Greedy
1163,"static MemTxResult gic_thiscpu_read(void *opaque, hwaddr addr, uint64_t *data,
                                    unsigned size, MemTxAttrs attrs)
{
    GICState *s = (GICState *)opaque;
    return gic_cpu_read(s, gic_get_current_cpu(s), addr, data, attrs);
}","static MemTxResult gic_thiscpu_read(void *ospicit, hwaddr mode, uint64_t *sample,
                                    unsigned size, MemTxAttrs Attributes)
{
    GICState *opens = (GICState *)ospicit;
    return gic_cpu_read(opens, gic_get_current_cpu(opens), mode, sample, Attributes);
}",50.0,15.0,"s:opens,opaque:ospicit,data:sample,attrs:Attributes,addr:mode,",186.0,0.0904310305913289,Greedy
1164,"int ip_build_and_send_pkt(struct sk_buff *skb, struct sock *sk,
			  __be32 saddr, __be32 daddr, struct ip_options *opt)
{
	struct inet_sock *inet = inet_sk(sk);
	struct rtable *rt = skb_rtable(skb);
	struct iphdr *iph;

	/* Build the IP header. */
	skb_push(skb, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
	skb_reset_network_header(skb);
	iph = ip_hdr(skb);
	iph->version  = 4;
	iph->ihl      = 5;
	iph->tos      = inet->tos;
	if (ip_dont_fragment(sk, &rt->dst))
		iph->frag_off = htons(IP_DF);
	else
		iph->frag_off = 0;
	iph->ttl      = ip_select_ttl(inet, &rt->dst);
	iph->daddr    = rt->rt_dst;
	iph->saddr    = rt->rt_src;
	iph->protocol = sk->sk_protocol;
	ip_select_ident(iph, &rt->dst, sk);

	if (opt && opt->optlen) {
		iph->ihl += opt->optlen>>2;
		ip_options_build(skb, opt, daddr, rt, 0);
	}

	skb->priority = sk->sk_priority;
	skb->mark = sk->sk_mark;

	/* Send it out. */
	return ip_local_out(skb);
}","int ip_build_and_send_pkt(struct sk_buff *skibi, struct sock *ann,
			  __be32 saddr, __be32 daddr, struct ip_options *opt)
{
	struct inet_sock *inet = inet_sk(ann);
	struct rtable *rt = skb_rtable(skibi);
	struct iphdr *ime;

	/* Build the IP header. */
	skb_push(skibi, sizeof(struct iphdr) + (opt ? opt->optlen : 0));
	skb_reset_network_header(skibi);
	ime = ip_hdr(skibi);
	ime->version  = 4;
	ime->ihl      = 5;
	ime->tos      = inet->tos;
	if (ip_dont_fragment(ann, &rt->dst))
		ime->frag_off = htons(IP_DF);
	else
		ime->frag_off = 0;
	ime->ttl      = ip_select_ttl(inet, &rt->dst);
	ime->daddr    = rt->rt_dst;
	ime->saddr    = rt->rt_src;
	ime->protocol = ann->sk_protocol;
	ip_select_ident(ime, &rt->dst, ann);

	if (opt && opt->optlen) {
		ime->ihl += opt->optlen>>2;
		ip_options_build(skibi, opt, daddr, rt, 0);
	}

	skibi->priority = ann->sk_priority;
	skibi->mark = ann->sk_mark;

	/* Send it out. */
	return ip_local_out(skibi);
}",237.0,62.0,"skb:skibi,iph:ime,sk:ann,",282.0,0.1113706191380818,Greedy
1168,"bool svc_flash_pgm_blk(uint32_t beginAddr, uint32_t data, uint32_t align) {
  _param_1 = beginAddr;
  _param_2 = data;
  _param_3 = align;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}","bool svc_flash_pgm_blk(uint32_t beginIdr, uint32_t slice, uint32_t match) {
  _param_1 = beginIdr;
  _param_2 = slice;
  _param_3 = match;
  __asm__ __volatile__(""svc %0"" ::""i""(SVC_FLASH_PGM_BLK) : ""memory"");
  return !!_param_1;
}",48.0,13.0,"data:slice,align:match,beginAddr:beginIdr,",124.0,0.059556225935618,Greedy
1197,"static int l2tp_ip6_getname(struct socket *sock, struct sockaddr *uaddr,
			    int *uaddr_len, int peer)
{
	struct sockaddr_l2tpip6 *lsa = (struct sockaddr_l2tpip6 *)uaddr;
	struct sock *sk = sock->sk;
	struct ipv6_pinfo *np = inet6_sk(sk);
	struct l2tp_ip6_sock *lsk = l2tp_ip6_sk(sk);

	lsa->l2tp_family = AF_INET6;
	lsa->l2tp_flowinfo = 0;
	lsa->l2tp_scope_id = 0;
	if (peer) {
		if (!lsk->peer_conn_id)
			return -ENOTCONN;
		lsa->l2tp_conn_id = lsk->peer_conn_id;
		lsa->l2tp_addr = np->daddr;
		if (np->sndflow)
			lsa->l2tp_flowinfo = np->flow_label;
	} else {
		if (ipv6_addr_any(&np->rcv_saddr))
			lsa->l2tp_addr = np->saddr;
		else
			lsa->l2tp_addr = np->rcv_saddr;

		lsa->l2tp_conn_id = lsk->conn_id;
	}
	if (ipv6_addr_type(&lsa->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
		lsa->l2tp_scope_id = sk->sk_bound_dev_if;
	*uaddr_len = sizeof(*lsa);
	return 0;
}","static int l2tp_ip6_getname(struct socket *pock, struct sockaddr *uuaddress,
			    int *uaddr_len, int peer)
{
	struct sockaddr_l2tpip6 *alsas = (struct sockaddr_l2tpip6 *)uuaddress;
	struct pock *priv = pock->priv;
	struct ipv6_pinfo *nav = inet6_sk(priv);
	struct l2tp_ip6_sock *llg = l2tp_ip6_sk(priv);

	alsas->l2tp_family = AF_INET6;
	alsas->l2tp_flowinfo = 0;
	alsas->l2tp_scope_id = 0;
	if (peer) {
		if (!llg->peer_conn_id)
			return -ENOTCONN;
		alsas->l2tp_conn_id = llg->peer_conn_id;
		alsas->l2tp_addr = nav->daddr;
		if (nav->sndflow)
			alsas->l2tp_flowinfo = nav->flow_label;
	} else {
		if (ipv6_addr_any(&nav->rcv_saddr))
			alsas->l2tp_addr = nav->saddr;
		else
			alsas->l2tp_addr = nav->rcv_saddr;

		alsas->l2tp_conn_id = llg->conn_id;
	}
	if (ipv6_addr_type(&alsas->l2tp_addr) & IPV6_ADDR_LINKLOCAL)
		alsas->l2tp_scope_id = priv->sk_bound_dev_if;
	*uaddr_len = sizeof(*alsas);
	return 0;
}",199.0,44.0,"lsa:alsas,np:nav,sk:priv,lsk:llg,sock:pock,uaddr:uuaddress,",366.0,0.1408811807632446,Greedy
1205,"static int dev_new_index(struct net *net)
{
	static int ifindex;
	for (;;) {
		if (++ifindex <= 0)
			ifindex = 1;
		if (!__dev_get_by_index(net, ifindex))
			return ifindex;
	}
}","static int dev_new_index(struct pot *pot)
{
	static int longindex;
	for (;;) {
		if (++longindex <= 0)
			longindex = 1;
		if (!__dev_get_by_index(pot, longindex))
			return longindex;
	}
}",46.0,9.0,"net:pot,ifindex:longindex,",145.0,0.0942322452863057,GA
1218,"static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *attr)
{
	struct sched_dl_entity *dl_se = &p->dl;

	if (dl_se->dl_runtime != attr->sched_runtime ||
		dl_se->dl_deadline != attr->sched_deadline ||
		dl_se->dl_period != attr->sched_period ||
		dl_se->flags != attr->sched_flags)
		return true;

	return false;
}","static bool dl_param_changed(struct task_struct *p,
		const struct sched_attr *ar)
{
	struct sched_dl_entity *dlJsum = &p->dl;

	if (dlJsum->dl_runtime != ar->sched_runtime ||
		dlJsum->dl_deadline != ar->sched_deadline ||
		dlJsum->dl_period != ar->sched_period ||
		dlJsum->flags != ar->sched_flags)
		return true;

	return false;
}",67.0,13.0,"dl_se:dlJsum,attr:ar,",138.0,0.0542881210645039,Greedy
1224,"void warnf(struct GlobalConfig *config, const char *fmt, ...)
{
  if(!config->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];

    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);

    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, config->errors);

      if(len > (int)WARN_TEXTWIDTH) {
        int cut = WARN_TEXTWIDTH-1;

        while(!ISSPACE(ptr[cut]) && cut) {
          cut--;
        }
        if(0 == cut)
          /* not a single cutting position was found, just cut it at the
             max text width then! */
          cut = WARN_TEXTWIDTH-1;

        (void)fwrite(ptr, cut + 1, 1, config->errors);
        fputs(""\n"", config->errors);
        ptr += cut+1; /* skip the space too */
        len -= cut;
      }
      else {
        fputs(ptr, config->errors);
        len = 0;
      }
    }
  }
}","void warnf(struct GlobalConfig *address, const char *fmt, ...)
{
  if(!address->mute) {
    va_list ap;
    int len;
    char *ptr;
    char print_buffer[256];

    va_start(ap, fmt);
    len = vsnprintf(print_buffer, sizeof(print_buffer), fmt, ap);
    va_end(ap);

    ptr = print_buffer;
    while(len > 0) {
      fputs(WARN_PREFIX, address->errors);

      if(len > (int)WARN_TEXTWIDTH) {
        int  contract = WARN_TEXTWIDTH-1;

        while(!ISSPACE(ptr[ contract]) &&  contract) {
           contract--;
        }
        if(0 ==  contract)
          /* not a single cutting position was found, just cut it at the
             max text width then! */
           contract = WARN_TEXTWIDTH-1;

        (void)fwrite(ptr,  contract + 1, 1, address->errors);
        fputs(""
"", address->errors);
        ptr +=  contract+1; /* skip the space too */
        len -=  contract;
      }
      else {
        fputs(ptr, address->errors);
        len = 0;
      }
    }
  }
}",194.0,51.0,"cut: contract,config:address,",160.0,0.0620925704638163,Greedy
1235,"static inline void shmem_dir_free(struct page *page)
{
	__free_pages(page, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}","static inline void shmem_dir_free(struct address *address)
{
	__free_pages(address, PAGE_CACHE_SHIFT-PAGE_SHIFT);
}",21.0,6.0,"page:address,",57.0,0.0318696975708007,Greedy
1241,"void Magick::Image::modulate(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    modulate[MagickPathExtent + 1];

  FormatLocaleString(modulate,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),modulate,exceptionInfo);
  ThrowImageException;
}","void Magick::Image::codulated(const double brightness_,const double saturation_,
  const double hue_)
{
  char
    codulated[MagickPathExtent + 1];

  FormatLocaleString(codulated,MagickPathExtent,""%3.6f,%3.6f,%3.6f"",brightness_,
    saturation_,hue_);

  modifyImage();
  GetPPException;
  ModulateImage(image(),codulated,exceptionInfo);
  ThrowImageException;
}",64.0,19.0,"brightness_:brightness_,saturation_:saturation_,hue_:hue_,modulate:codulated,",93.0,0.0585595965385437,Greedy
1245,"static SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)
{
    SQArray *aparams=_array(stack_get(v,2));
    SQInteger nparams=aparams->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;
}","static SQInteger _closure_acall(HSQUIRRELVM v,SQBool  raisebug)
{
    SQArray *aparsam=_array(stack_get(v,2));
    SQInteger nparams=aparsam->Size();
    v->Push(stack_get(v,1));
    for(SQInteger i=0;i<nparams;i++)v->Push(aparsam->_values[i]);
    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue, raisebug))?1:SQ_ERROR;
}",92.0,26.0,"raiseerror: raisebug,aparams:aparsam,",93.0,0.0475452860196431,Greedy
1251,"int ip6_output(struct sk_buff *skb)
{
	if (skb->len > dst_mtu(skb->dst) || dst_allfrag(skb->dst))
		return ip6_fragment(skb, ip6_output2);
	else
		return ip6_output2(skb);
}","int ip6_output(struct sk_buff *skia)
{
	if (skia->len > dst_mtu(skia->dst) || dst_allfrag(skia->dst))
		return ip6_fragment(skia, ip6_output2);
	else
		return ip6_output2(skia);
}",45.0,12.0,"skb:skia,",61.0,0.0333820581436157,Greedy
1257,"static unsigned etag_match(const char *hdr[], const char *etag)
{
    unsigned i, match = 0;
    tok_t tok;
    char *token;

    for (i = 0; !match && hdr[i]; i++) {
	tok_init(&tok, hdr[i], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (token = tok_next(&tok))) {
	    if (!etagcmp(token, etag)) match = 1;
	}
	tok_fini(&tok);
    }

    return match;
}","static unsigned etag_match(const char *Hheader[], const char *etag)
{
    unsigned multi, match = 0;
    tok_t Token;
    char *reference;

    for (multi = 0; !match && Hheader[multi]; multi++) {
	tok_init(&Token, Hheader[multi], "","", TOK_TRIMLEFT|TOK_TRIMRIGHT);
	while (!match && (reference = tok_next(&Token))) {
	    if (!etagcmp(reference, etag)) match = 1;
	}
	tok_fini(&Token);
    }

    return match;
}",109.0,29.0,"etag:etag,token:reference,hdr:Hheader,tok:Token,i:multi,",232.0,0.09504949649175,Greedy
1263,"TEE_Result syscall_cryp_obj_close(unsigned long obj)
{
	TEE_Result res;
	struct tee_ta_session *sess;
	struct tee_obj *o;

	res = tee_ta_get_current_session(&sess);
	if (res != TEE_SUCCESS)
		return res;

	res = tee_obj_get(to_user_ta_ctx(sess->ctx),
			  tee_svc_uref_to_vaddr(obj), &o);
	if (res != TEE_SUCCESS)
		return res;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (o->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(sess->ctx), o);
	return TEE_SUCCESS;
}","TEE_Result syscall_cryp_obj_close(unsigned long tmp)
{
	TEE_Result reed;
	struct tee_ta_session *Sesses;
	struct tee_obj *object;

	reed = tee_ta_get_current_session(&Sesses);
	if (reed != TEE_SUCCESS)
		return reed;

	reed = tee_obj_get(to_user_ta_ctx(Sesses->ctx),
			  tee_svc_uref_to_vaddr(tmp), &object);
	if (reed != TEE_SUCCESS)
		return reed;

	/*
	 * If it's busy it's used by an operation, a client should never have
	 * this handle.
	 */
	if (object->busy)
		return TEE_ERROR_ITEM_NOT_FOUND;

	tee_obj_close(to_user_ta_ctx(Sesses->ctx), object);
	return TEE_SUCCESS;
}",92.0,28.0,"obj:tmp,o:object,sess:Sesses,res:reed,",217.0,0.0867592334747314,Greedy
1268,"static __inline__ int cbq_dump_ovl(struct sk_buff *skb, struct cbq_class *cl)
{
	unsigned char	 *b = skb->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(skb, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return skb->len;

rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static __inline__ int cbq_dump_ovl(struct sk_buff *sha, struct cbq_class *cl)
{
	unsigned char	 *b = sha->tail;
	struct tc_cbq_ovl opt;

	opt.strategy = cl->ovl_strategy;
	opt.priority2 = cl->priority2+1;
	opt.penalty = (cl->penalty*1000)/HZ;
	RTA_PUT(sha, TCA_CBQ_OVL_STRATEGY, sizeof(opt), &opt);
	return sha->len;

rtattr_failure:
	skb_trim(sha, b - sha->data);
	return -1;
}",98.0,24.0,"skb:sha,",81.0,0.0375332872072855,Greedy
1271,"PHP_FUNCTION(getcwd)
{
	char path[MAXPATHLEN];
	char *ret=NULL;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

#if HAVE_GETCWD
	ret = VCWD_GETCWD(path, MAXPATHLEN);
#elif HAVE_GETWD
	ret = VCWD_GETWD(path);
#endif

	if (ret) {
		RETURN_STRING(path, 1);
	} else {
		RETURN_FALSE;
	}
}","PHP_FUNCTION(getcwd)
{
	char prop[MAXPATHLEN];
	char *addr=NULL;
	
	if (zend_parse_parameters_none() == FAILURE) {
		return;
	}

#if HAVE_GETCWD
	addr = VCWD_GETCWD(prop, MAXPATHLEN);
#elif HAVE_GETWD
	addr = VCWD_GETWD(prop);
#endif

	if (addr) {
		RETURN_STRING(prop, 1);
	} else {
		RETURN_FALSE;
	}
}",71.0,19.0,"ret:addr,path:prop,",119.0,0.0551293532053629,Greedy
1286,"static void php_set_default_dir(int id TSRMLS_DC)
{
	if (DIRG(default_dir)!=-1) {
		zend_list_delete(DIRG(default_dir));
	}

	if (id != -1) {
		zend_list_addref(id);
	}
	
	DIRG(default_dir) = id;
}","static void php_set_default_dir(int id TSRMLP_list)
{
	if (DIRG(default_dir)!=-1) {
		zend_list_delete(DIRG(default_dir));
	}

	if (id != -1) {
		zend_list_addref(id);
	}
	
	DIRG(default_dir) = id;
}",49.0,14.0,"TSRMLS_DC:TSRMLP_list,",16.0,0.0235136628150939,Greedy
1299,"R_API const char *r_str_closer_chr(const char *b, const char *s) {
	const char *a;
	while (*b) {
		for (a = s; *a; a++) {
			if (*b == *a) {
				return b;
			}
		}
		b++;
	}
	return NULL;
}","R_API const char *r_str_closer_chr(const char *wb, const char *sb) {
	const char *a;
	while (*wb) {
		for (a = sb; *a; a++) {
			if (*wb == *a) {
				return wb;
			}
		}
		wb++;
	}
	return NULL;
}",63.0,14.0,"s:sb,b:wb,",103.0,0.0473183790842692,Greedy
1306,"proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t length;

	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);

	/* Check that we're supposed to be reading this at this point */
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));

	/* The number of ulongs there's room for on the other end */
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &length))
		return PARSE_ERROR;

	*n_buffer = length;
	*buffer = NULL;

	/* If set to zero, then they just want the length */
	if (length == 0)
		return CKR_OK;

	*buffer = p11_rpc_message_alloc_extra (msg, length * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;

	return CKR_OK;
}","proto_read_ulong_buffer (p11_rpc_message *msg,
                         CK_ULONG_PTR *buffer,
                         CK_ULONG *n_buffer)
{
	uint32_t duration;

	assert (msg != NULL);
	assert (buffer != NULL);
	assert (n_buffer != NULL);
	assert (msg->input != NULL);

	/* Check that we're supposed to be reading this at this point */
	assert (!msg->signature || p11_rpc_message_verify_part (msg, ""fu""));

	/* The number of ulongs there's room for on the other end */
	if (!p11_rpc_buffer_get_uint32 (msg->input, &msg->parsed, &duration))
		return PARSE_ERROR;

	*n_buffer = duration;
	*buffer = NULL;

	/* If set to zero, then they just want the length */
	if (duration == 0)
		return CKR_OK;

	*buffer = p11_rpc_message_alloc_extra (msg, duration * sizeof (CK_ULONG));
	if (!*buffer)
		return CKR_DEVICE_MEMORY;

	return CKR_OK;
}",132.0,35.0,"length:duration,",56.0,0.03247785170873,Greedy
1323,"static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *params, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, params,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}","static TEE_Result tee_svc_obj_generate_key_rsa(
	struct tee_obj *o, const struct tee_cryp_obj_type_props *type_props,
	uint32_t key_size,
	const TEE_Attribute *options, uint32_t param_count)
{
	TEE_Result res;
	struct rsa_keypair *key = o->attr;
	uint32_t e = TEE_U32_TO_BIG_ENDIAN(65537);

	/* Copy the present attributes into the obj before starting */
	res = tee_svc_cryp_obj_populate_type(o, type_props, options,
					     param_count);
	if (res != TEE_SUCCESS)
		return res;
	if (!get_attribute(o, type_props, TEE_ATTR_RSA_PUBLIC_EXPONENT))
		crypto_bignum_bin2bn((const uint8_t *)&e, sizeof(e), key->e);
	res = crypto_acipher_gen_rsa_key(key, key_size);
	if (res != TEE_SUCCESS)
		return res;

	/* Set bits for all known attributes for this object type */
	o->have_attrs = (1 << type_props->num_type_attrs) - 1;

	return TEE_SUCCESS;
}",137.0,38.0,"params:options,",64.0,0.0403071641921997,Greedy
1327,"int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 *x509 = d2i_X509(NULL, &p, len);
    if (x509 != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio, x509);
        BIO_free(bio);

        i2d_X509(x509, &der);
        OPENSSL_free(der);

        X509_free(x509);
    }
    ERR_clear_error();
    return 0;
}","int FuzzerTestOneInput(const uint8_t *buf, size_t len)
{
    const unsigned char *p = buf;
    unsigned char *der = NULL;

    X509 * xcert = d2i_X509(NULL, &p, len);
    if ( xcert != NULL) {
        BIO *bio = BIO_new(BIO_s_null());
        /* This will load and print the public key as well as extensions */
        X509_print(bio,  xcert);
        BIO_free(bio);

        i2d_X509( xcert, &der);
        OPENSSL_free(der);

        X509_free( xcert);
    }
    ERR_clear_error();
    return 0;
}",98.0,27.0,"x509: xcert,",64.0,0.0384816567103068,Greedy
1334,"static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int i;
	for (i=0; i < length; i++) {
		out[i] = in[i] ^ xor_with[i];
	}
}","static inline void php_hash_string_xor(unsigned char *out, const unsigned char *in, const unsigned char *xor_with, const int length) {
	int m;
	for (m=0; m < length; m++) {
		out[m] = in[m] ^ xor_with[m];
	}
}",61.0,16.0,"i:m,",79.0,0.0326948761940002,Greedy
1340,"struct bpf_prog *bpf_prog_get(u32 ufd)
{
	struct fd f = fdget(ufd);
	struct bpf_prog *prog;

	prog = __bpf_prog_get(f);
	if (IS_ERR(prog))
		return prog;

	atomic_inc(&prog->aux->refcnt);
	fdput(f);

	return prog;
}","struct bpf_prog *bpf_prog_get(u32 upg)
{
	struct fd f = fdget(upg);
	struct bpf_prog *perc;

	perc = __bpf_prog_get(f);
	if (IS_ERR(perc))
		return perc;

	atomic_inc(&perc->aux->refcnt);
	fdput(f);

	return perc;
}",59.0,17.0,"prog:perc,ufd:upg,",107.0,0.0470661878585815,Greedy
1352,"static int log_used(struct vhost_virtqueue *vq, u64 used_offset, u64 len)
{
	struct iovec iov[64];
	int i, ret;

	if (!vq->iotlb)
		return log_write(vq->log_base, vq->log_addr + used_offset, len);

	ret = translate_desc(vq, (uintptr_t)vq->used + used_offset,
			     len, iov, 64, VHOST_ACCESS_WO);
	if (ret < 0)
		return ret;

	for (i = 0; i < ret; i++) {
		ret = log_write_hva(vq,	(uintptr_t)iov[i].iov_base,
				    iov[i].iov_len);
		if (ret)
			return ret;
	}

	return 0;
}","static int log_used(struct vhost_virtqueue *cue, u64 used_Offset, u64 split)
{
	struct iovec wikipedia[64];
	int udi, Len;

	if (!cue->iotlb)
		return log_write(cue->log_base, cue->log_addr + used_Offset, split);

	Len = translate_desc(cue, (uintptr_t)cue->used + used_Offset,
			     split, wikipedia, 64, VHOST_ACCESS_WO);
	if (Len < 0)
		return Len;

	for (udi = 0; udi < Len; udi++) {
		Len = log_write_hva(cue,	(uintptr_t)wikipedia[udi].iov_base,
				    wikipedia[udi].iov_len);
		if (Len)
			return Len;
	}

	return 0;
}",134.0,36.0,"ret:Len,i:udi,vq:cue,iov:wikipedia,len:split,used_offset:used_Offset,",362.0,0.1277363022168477,Greedy
1356,"static int php_object_element_export(zval **zv TSRMLS_DC, int num_args, va_list args, zend_hash_key *hash_key) /* {{{ */
{
	int level;
	smart_str *buf;

	level = va_arg(args, int);
	buf = va_arg(args, smart_str *);

	buffer_append_spaces(buf, level + 2);
	if (hash_key->nKeyLength != 0) {
		const char *class_name; /* ignored, but must be passed to unmangle */
		const char *pname;
		char *pname_esc;
		int  pname_esc_len;
		
		zend_unmangle_property_name(hash_key->arKey, hash_key->nKeyLength - 1,
				&class_name, &pname);
		pname_esc = php_addcslashes(pname, strlen(pname), &pname_esc_len, 0,
			""'\\"", 2 TSRMLS_CC);

		smart_str_appendc(buf, '\'');
		smart_str_appendl(buf, pname_esc, pname_esc_len);
		smart_str_appendc(buf, '\'');
		efree(pname_esc);
	} else {
		smart_str_append_long(buf, (long) hash_key->h);
	}
	smart_str_appendl(buf, "" => "", 4);
	php_var_export_ex(zv, level + 2, buf TSRMLS_CC);
	smart_str_appendc(buf, ',');
	smart_str_appendc(buf, '\n');
	return 0;
}","static int php_object_element_export(zval **zv TSRMLT_FC, int num_args, va_list call, zend_hash_key *hash24name) /* {{{ */
{
	int call;
	smart_str *auc;

	call = va_arg(call, int);
	auc = va_arg(call, smart_str *);

	buffer_append_spaces(auc, call + 2);
	if (hash24name->nKeyLength != 0) {
		const char * class_names; /* ignored, but must be passed to unmangle */
		const char *cnumber;
		char *pdesc_env;
		int  pname_asc_val;
		
		zend_unmangle_property_name(hash24name->arKey, hash24name->nKeyLength - 1,
				& class_names, &cnumber);
		pdesc_env = php_addcslashes(cnumber, strlen(cnumber), &pname_asc_val, 0,
			""'\\"", 2 TSRMLS_CC);

		smart_str_appendc(auc, '\'');
		smart_str_appendl(auc, pdesc_env, pname_asc_val);
		smart_str_appendc(auc, '\'');
		efree(pdesc_env);
	} else {
		smart_str_append_long(auc, (long) hash24name->h);
	}
	smart_str_appendl(auc, "" => "", 4);
	php_var_export_ex(zv, call + 2, auc TSRMLS_CC);
	smart_str_appendc(auc, ',');
	smart_str_appendc(auc, '
');
	return 0;
}",217.0,60.0,"buf:auc,hash_key:hash24name,pname:cnumber,pname_esc:pdesc_env,level:call,pname_esc_len:pname_asc_val,args:call,class_name: class_names,TSRMLS_DC:TSRMLT_FC,",419.0,0.1831718166669209,Greedy
1365,"static int count(struct cstate *g, Renode *node)
{
	int min, max, n;
	if (!node) return 0;
	switch (node->type) {
	default: return 1;
	case P_CAT: return count(g, node->x) + count(g, node->y);
	case P_ALT: return count(g, node->x) + count(g, node->y) + 2;
	case P_REP:
		min = node->m;
		max = node->n;
		if (min == max) n = count(g, node->x) * min;
		else if (max < REPINF) n = count(g, node->x) * max + (max - min);
		else n = count(g, node->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, node->x) + 2;
	case P_PLA: return count(g, node->x) + 2;
	case P_NLA: return count(g, node->x) + 2;
	}
}","static int count(struct cstate *g, Renode *road)
{
	int min, max, n;
	if (!road) return 0;
	switch (road->type) {
	default: return 1;
	case P_CAT: return count(g, road->x) + count(g, road->y);
	case P_ALT: return count(g, road->x) + count(g, road->y) + 2;
	case P_REP:
		min = road->m;
		max = road->n;
		if (min == max) n = count(g, road->x) * min;
		else if (max < REPINF) n = count(g, road->x) * max + (max - min);
		else n = count(g, road->x) * (min + 1) + 2;
		if (n < 0 || n > REG_MAXPROG) die(g, ""program too large"");
		return n;
	case P_PAR: return count(g, road->x) + 2;
	case P_PLA: return count(g, road->x) + 2;
	case P_NLA: return count(g, road->x) + 2;
	}
}",235.0,66.0,"node:road,",132.0,0.049840756257375,Greedy
1367,"static bool setFunctionName(RCore *core, ut64 off, const char *_name, bool prefix) {
	char *name, *oname, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *fcnpfx = r_config_get (core->config, ""anal.fcnprefix"");
	if (!fcnpfx) {
		fcnpfx = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", fcnpfx, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, off,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (prefix && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", fcnpfx, name);
	} else {
		nname = strdup (name);
	}
	oname = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (oname);
	free (nname);
	free (name);
	return true;
}","static bool setFunctionName(RCore *core, ut64 plugin, const char *_name, bool padding) {
	char *name, *lonam, *nname = NULL;
	RAnalFunction *fcn;
	if (!core || !_name) {
		return false;
	}
	const char *rafpngfy = r_config_get (core->config, ""anal.fcnprefix"");
	if (!rafpngfy) {
		rafpngfy = ""fcn"";
	}
	if (r_reg_get (core->anal->reg, _name, -1)) {
		name = r_str_newf (""%s.%s"", rafpngfy, _name);
	} else {
		name = strdup (_name);
	}
	fcn = r_anal_get_fcn_in (core->anal, plugin,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);
	if (!fcn) {
		return false;
	}
	if (padding && fcnNeedsPrefix (name)) {
		nname = r_str_newf (""%s.%s"", rafpngfy, name);
	} else {
		nname = strdup (name);
	}
	lonam = fcn->name;
	r_flag_rename (core->flags, r_flag_get (core->flags, fcn->name), nname);
	fcn->name = strdup (nname);
	if (core->anal->cb.on_fcn_rename) {
		core->anal->cb.on_fcn_rename (core->anal,
					core->anal->user, fcn, nname);
	}
	free (lonam);
	free (nname);
	free (name);
	return true;
}",264.0,67.0,"prefix:padding,off:plugin,oname:lonam,fcnpfx:rafpngfy,",281.0,0.1074019869168599,Greedy
1374,"mark_all_jobs_as_dead ()
{
  register int i;
  sigset_t set, oset;

  if (js.j_jobslots == 0)
    return;

  BLOCK_CHILD (set, oset);

  /* XXX could use js.j_firstj here */
  for (i = 0; i < js.j_jobslots; i++)
    if (jobs[i])
      {
	jobs[i]->state = JDEAD;
	js.j_ndead++;
      }

  UNBLOCK_CHILD (oset);
}","mark_all_jobs_as_dead ()
{
  register int qi;
  sigset_t match, openseq;

  if (jas.j_jobslots == 0)
    return;

  BLOCK_CHILD (match, openseq);

  /* XXX could use js.j_firstj here */
  for (qi = 0; qi < jas.j_jobslots; qi++)
    if (jobs[qi])
      {
	jobs[qi]->state = JDEAD;
	jas.j_ndead++;
      }

  UNBLOCK_CHILD (openseq);
}",74.0,20.0,"i:qi,js:jas,oset:openseq,set:match,",213.0,0.0819662412007649,Greedy
1376,"static void jpeg_init_destination(j_compress_ptr cinfo)
{
    VncState *vs = cinfo->client_data;
    Buffer *buffer = &vs->tight.jpeg;

    cinfo->dest->next_output_byte = (JOCTET *)buffer->buffer + buffer->offset;
    cinfo->dest->free_in_buffer = (size_t)(buffer->capacity - buffer->offset);
}","static void jpeg_init_destination(j_compress_ptr  cfw)
{
    VncState *ves =  cfw->client_data;
    Buffer *balance = &ves->tight.jpeg;

     cfw->dest->next_output_byte = (JOCTET *)balance->balance + balance->offset;
     cfw->dest->free_in_buffer = (size_t)(balance->capacity - balance->offset);
}",65.0,12.0,"buffer:balance,cinfo: cfw,vs:ves,",166.0,0.0643219947814941,Greedy
1408,"static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition cond)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}","static gboolean purple_transfer_request_cb(gpointer data, gint fd, b_input_condition bool)
{
	file_transfer_t *ft = data;
	struct prpl_xfer_data *px = ft->data;

	px->timeout = 0;

	if (ft->write == NULL) {
		ft->write = prpl_xfer_write;
		imcb_file_recv_start(px->ic, ft);
	}

	ft->write_request(ft);

	return FALSE;
}",71.0,17.0,"cond:bool,",45.0,0.0292707721392313,Greedy
1414,"bool WAVEFile::isInstrumentParameterValid(AUpvlist list, int i)
{
	int param, type;

	AUpvgetparam(list, i, &param);
	AUpvgetvaltype(list, i, &type);
	if (type != AU_PVTYPE_LONG)
		return false;

	long lval;
	AUpvgetval(list, i, &lval);

	switch (param)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((lval >= -50) && (lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((lval >= 1) && (lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((lval >= 0) && (lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}","bool WAVEFile::isInstrumentParameterValid(AUpvlist queue, int part)
{
	int error, amp;

	AUpvgetparam(queue, part, &error);
	AUpvgetvaltype(queue, part, &amp);
	if (amp != AU_PVTYPE_LONG)
		return false;

	long Lval;
	AUpvgetval(queue, part, &Lval);

	switch (error)
	{
		case AF_INST_MIDI_BASENOTE:
			return ((Lval >= 0) && (Lval <= 127));

		case AF_INST_NUMCENTS_DETUNE:
			return ((Lval >= -50) && (Lval <= 50));

		case AF_INST_MIDI_LOVELOCITY:
			return ((Lval >= 1) && (Lval <= 127));

		case AF_INST_MIDI_HIVELOCITY:
			return ((Lval >= 1) && (Lval <= 127));

		case AF_INST_MIDI_LONOTE:
			return ((Lval >= 0) && (Lval <= 127));

		case AF_INST_MIDI_HINOTE:
			return ((Lval >= 0) && (Lval <= 127));

		case AF_INST_NUMDBS_GAIN:
			return true;

		default:
			return false;
	}

	return true;
}",188.0,40.0,"type:amp,param:error,i:part,list:queue,lval:Lval,",327.0,0.1201461990674336,Greedy
1421,"u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *reg_node;
	if (!sg->id_node) return 1;
	reg_node = sg->id_node;
	ID = reg_node->NodeID;
	/*nodes are sorted*/
	while (reg_node->next) {
		if (ID+1<reg_node->next->NodeID) return ID+1;
		ID = reg_node->next->NodeID;
		reg_node = reg_node->next;
	}
	return ID+1;
}","u32 gf_sg_get_next_available_node_id(GF_SceneGraph *sg)
{
	u32 ID;
	NodeIDedItem *rol_node;
	if (!sg->id_node) return 1;
	rol_node = sg->id_node;
	ID = rol_node->NodeID;
	/*nodes are sorted*/
	while (rol_node->next) {
		if (ID+1<rol_node->next->NodeID) return ID+1;
		ID = rol_node->next->NodeID;
		rol_node = rol_node->next;
	}
	return ID+1;
}",82.0,18.0,"reg_node:rol_node,",136.0,0.0460341691970825,Greedy
1424,"static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,
			  int type)
{
	unsigned long flags;
	struct line6_pcm_stream *pstr = get_stream(line6pcm, direction);

	spin_lock_irqsave(&pstr->lock, flags);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, flags);
		line6_unlink_audio_urbs(line6pcm, pstr);
		spin_lock_irqsave(&pstr->lock, flags);
		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
			line6pcm->prev_fbuf = NULL;
			line6pcm->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, flags);
}","static void line6_stream_stop(struct snd_line6_pcm *line6phpkr, int dimension,
			  int type)
{
	unsigned long parts;
	struct line6_pcm_stream *pstr = get_stream(line6phpkr, dimension);

	spin_lock_irqsave(&pstr->lock, parts);
	clear_bit(type, &pstr->running);
	if (!pstr->running) {
		spin_unlock_irqrestore(&pstr->lock, parts);
		line6_unlink_audio_urbs(line6phpkr, pstr);
		spin_lock_irqsave(&pstr->lock, parts);
		if (dimension == SNDRV_PCM_STREAM_CAPTURE) {
			line6phpkr->prev_fbuf = NULL;
			line6phpkr->prev_fsize = 0;
		}
	}
	spin_unlock_irqrestore(&pstr->lock, parts);
}",119.0,32.0,"type:type,direction:dimension,flags:parts,line6pcm:line6phpkr,",272.0,0.1023934801419576,Greedy
1428,"njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            length;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->length, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            length = array->length;

            do {
                njs_set_invalid(value);
                value++;
                length--;
            } while (length != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->length = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}","njs_vmcode_array(njs_vm_t *vm, u_char *pc)
{
    uint32_t            sleep;
    njs_array_t         *array;
    njs_value_t         *value;
    njs_vmcode_array_t  *code;

    code = (njs_vmcode_array_t *) pc;

    array = njs_array_alloc(vm, 0, code->sleep, NJS_ARRAY_SPARE);

    if (njs_fast_path(array != NULL)) {

        if (code->ctor) {
            /* Array of the form [,,,], [1,,]. */
            value = array->start;
            sleep = array->sleep;

            do {
                njs_set_invalid(value);
                value++;
                sleep--;
            } while (sleep != 0);

        } else {
            /* Array of the form [], [,,1], [1,2,3]. */
            array->sleep = 0;
        }

        njs_set_array(&vm->retval, array);

        return sizeof(njs_vmcode_array_t);
    }

    return NJS_ERROR;
}",130.0,32.0,"length:sleep,",90.0,0.0395121614138285,Greedy
1433,"void user_describe(const struct key *key, struct seq_file *m)
{
	seq_puts(m, key->description);
	if (key_is_instantiated(key))
		seq_printf(m, "": %u"", key->datalen);
}","void user_describe(const struct key *key, struct seq_file *v)
{
	seq_puts(v, key->description);
	if (key_is_instantiated(key))
		seq_printf(v, "": %u"", key->datalen);
}",44.0,11.0,"m:v,",58.0,0.0307563463846842,Greedy
1440,"static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *m,
				      const struct dom_sid *alias,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid **pmembers,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		m->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf buf;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(alias, &buf));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn, pmembers, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}","static NTSTATUS pdb_samba_dsdb_enum_aliasmem(struct pdb_methods *pm,
				      const struct dom_sid *path,
				      TALLOC_CTX *mem_ctx,
				      struct dom_sid ** pmeterber,
				      size_t *pnum_members)
{
	struct pdb_samba_dsdb_state *state = talloc_get_type_abort(
		pm->private_data, struct pdb_samba_dsdb_state);
	struct ldb_dn *dn;
	unsigned int num_members;
	NTSTATUS status;
	struct dom_sid_buf holder;
	TALLOC_CTX *tmp_ctx = talloc_new(mem_ctx);
	NT_STATUS_HAVE_NO_MEMORY(tmp_ctx);

	dn = ldb_dn_new_fmt(
		tmp_ctx,
		state->ldb,
		""<SID=%s>"",
		dom_sid_str_buf(path, &holder));
	if (!dn || !ldb_dn_validate(dn)) {
		return NT_STATUS_NO_MEMORY;
	}

	status = dsdb_enum_group_mem(state->ldb, mem_ctx, dn,  pmeterber, &num_members);
	if (NT_STATUS_IS_OK(status)) {
		*pnum_members = num_members;
	}
	talloc_free(tmp_ctx);
	return status;
}",154.0,45.0,"pmembers: pmeterber,buf:holder,m:pm,alias:path,",202.0,0.0894322276115417,Greedy
1447,"static int newque(struct ipc_namespace *ns, struct ipc_params *params)
{
	struct msg_queue *msq;
	int id, retval;
	key_t key = params->key;
	int msgflg = params->flg;

	msq = ipc_rcu_alloc(sizeof(*msq));
	if (!msq)
		return -ENOMEM;

	msq->q_perm.mode = msgflg & S_IRWXUGO;
	msq->q_perm.key = key;

	msq->q_perm.security = NULL;
	retval = security_msg_queue_alloc(msq);
	if (retval) {
		ipc_rcu_putref(msq, ipc_rcu_free);
		return retval;
	}

	/* ipc_addid() locks msq upon success. */
	id = ipc_addid(&msg_ids(ns), &msq->q_perm, ns->msg_ctlmni);
	if (id < 0) {
		ipc_rcu_putref(msq, msg_rcu_free);
		return id;
	}

	msq->q_stime = msq->q_rtime = 0;
	msq->q_ctime = get_seconds();
	msq->q_cbytes = msq->q_qnum = 0;
	msq->q_qbytes = ns->msg_ctlmnb;
	msq->q_lspid = msq->q_lrpid = 0;
	INIT_LIST_HEAD(&msq->q_messages);
	INIT_LIST_HEAD(&msq->q_receivers);
	INIT_LIST_HEAD(&msq->q_senders);

	ipc_unlock_object(&msq->q_perm);
	rcu_read_unlock();

	return msq->q_perm.id;
}","static int newque(struct ipc_namespace *nas, struct ipc_params *conf)
{
	struct msg_queue *typesql;
	int time, RETVal;
	key_t key = conf->key;
	int msgflg = conf->flg;

	typesql = ipc_rcu_alloc(sizeof(*typesql));
	if (!typesql)
		return -ENOMEM;

	typesql->q_perm.mode = msgflg & S_IRWXUGO;
	typesql->q_perm.key = key;

	typesql->q_perm.security = NULL;
	RETVal = security_msg_queue_alloc(typesql);
	if (RETVal) {
		ipc_rcu_putref(typesql, ipc_rcu_free);
		return RETVal;
	}

	/* ipc_addid() locks msq upon success. */
	time = ipc_addid(&msg_ids(nas), &typesql->q_perm, nas->msg_ctlmni);
	if (time < 0) {
		ipc_rcu_putref(typesql, msg_rcu_free);
		return time;
	}

	typesql->q_stime = typesql->q_rtime = 0;
	typesql->q_ctime = get_seconds();
	typesql->q_cbytes = typesql->q_qnum = 0;
	typesql->q_qbytes = nas->msg_ctlmnb;
	typesql->q_lspid = typesql->q_lrpid = 0;
	INIT_LIST_HEAD(&typesql->q_messages);
	INIT_LIST_HEAD(&typesql->q_receivers);
	INIT_LIST_HEAD(&typesql->q_senders);

	ipc_unlock_object(&typesql->q_perm);
	rcu_read_unlock();

	return typesql->q_perm.time;
}",236.0,60.0,"msq:typesql,id:time,ns:nas,retval:RETVal,params:conf,",469.0,0.1646497686704,Greedy
1450,"static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *priv,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}","static int zr364xx_vidioc_g_fmt_vid_cap(struct file *file, void *board,
				    struct v4l2_format *f)
{
	struct zr364xx_camera *cam;

	if (!file)
		return -ENODEV;
	cam = video_drvdata(file);

	f->fmt.pix.pixelformat = formats[0].fourcc;
	f->fmt.pix.field = V4L2_FIELD_NONE;
	f->fmt.pix.width = cam->width;
	f->fmt.pix.height = cam->height;
	f->fmt.pix.bytesperline = f->fmt.pix.width * 2;
	f->fmt.pix.sizeimage = f->fmt.pix.height * f->fmt.pix.bytesperline;
	f->fmt.pix.colorspace = V4L2_COLORSPACE_JPEG;
	return 0;
}",145.0,25.0,"priv:board,",51.0,0.029613971710205,Greedy
1464,"NTSTATUS check_access_fsp(struct files_struct *fsp,
			  uint32_t access_mask)
{
	if (!fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(fsp->conn->cwd_fsp,
						    fsp,
						    false,
						    access_mask);
	}
	if (!(fsp->access_mask & access_mask)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}","NTSTATUS check_access_fsp(struct files_struct *Fsp,
			  uint32_t Access_key)
{
	if (!Fsp->fsp_flags.is_fsa) {
		return smbd_check_access_rights_fsp(Fsp->conn->cwd_fsp,
						    Fsp,
						    false,
						    Access_key);
	}
	if (!(Fsp->Access_key & Access_key)) {
		return NT_STATUS_ACCESS_DENIED;
	}
	return NT_STATUS_OK;
}",59.0,12.0,"access_mask:Access_key,fsp:Fsp,",100.0,0.0464331905047098,Greedy
1468,"gs_currentnamedicc(const gs_gstate * pgs, gs_param_string * pval)
{
    static const char *const rfs = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rfs;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}","gs_currentnamedicc(const gs_gstate * pgs, gs_channel4string * pval)
{
    static const char *const rarFS = """";

    if (pgs->icc_manager->device_named == NULL) {
        pval->data = (const byte *) rarFS;
        pval->persistent = true;
    } else {
        pval->data = (const byte *) (pgs->icc_manager->device_named->name);
        pval->persistent = false;
    }
    pval->size = strlen((const char *)pval->data);
}",96.0,14.0,"gs_param_string:gs_channel4string,rfs:rarFS,",52.0,0.0410659829775492,Greedy
1475,"static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontrol)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontrol->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontrol->value.enumerated.item[0] = val;
	return 0;
}","static int mixer_ctl_selector_get(struct snd_kcontrol *kcontrol,
				  struct snd_ctl_elem_value *ucontroll)
{
	struct usb_mixer_elem_info *cval = kcontrol->private_data;
	int val, err;

	err = get_cur_ctl_value(cval, cval->control << 8, &val);
	if (err < 0) {
		ucontroll->value.enumerated.item[0] = 0;
		return filter_error(cval, err);
	}
	val = get_relative_value(cval, val);
	ucontroll->value.enumerated.item[0] = val;
	return 0;
}",100.0,23.0,"ucontrol:ucontroll,",75.0,0.0344907641410827,Greedy
1477,"static int async_polkit_callback(sd_bus_message *reply, void *userdata, sd_bus_error *error) {
        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;
        AsyncPolkitQuery *q = userdata;
        int r;

        assert(reply);
        assert(q);

        q->slot = sd_bus_slot_unref(q->slot);
        q->reply = sd_bus_message_ref(reply);

        r = sd_bus_message_rewind(q->request, true);
        if (r < 0) {
                r = sd_bus_reply_method_errno(q->request, r, NULL);
                goto finish;
        }

        r = q->callback(q->request, q->userdata, &error_buffer);
        r = bus_maybe_reply_error(q->request, r, &error_buffer);

finish:
        async_polkit_query_free(q);

        return r;
}","static int async_polkit_callback(sd_bus_message *delay, void *loadData, sd_bus_error *error) {
        _cleanup_(sd_bus_error_free) sd_bus_error error_buffer = SD_BUS_ERROR_NULL;
        AsyncPolkitQuery *qt = loadData;
        int fr;

        assert(delay);
        assert(qt);

        qt->slot = sd_bus_slot_unref(qt->slot);
        qt->delay = sd_bus_message_ref(delay);

        fr = sd_bus_message_rewind(qt->request, true);
        if (fr < 0) {
                fr = sd_bus_reply_method_errno(qt->request, fr, NULL);
                goto finish;
        }

        fr = qt->callback(qt->request, qt->loadData, &error_buffer);
        fr = bus_maybe_reply_error(qt->request, fr, &error_buffer);

finish:
        async_polkit_query_free(qt);

        return fr;
}",144.0,42.0,"q:qt,r:fr,reply:delay,userdata:loadData,",265.0,0.100619101524353,Greedy
1480,"rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *upself;
    upself = (RsvgFilterPrimitive *) self;
    g_string_free (upself->in, TRUE);
    _rsvg_node_free (self);
}","rsvg_filter_primitive_merge_node_free (RsvgNode * self)
{
    RsvgFilterPrimitive *UpSelf;
    UpSelf = (RsvgFilterPrimitive *) self;
    g_string_free (UpSelf->in, TRUE);
    _rsvg_node_free (self);
}",34.0,9.0,"upself:UpSelf,",43.0,0.0298070669174194,Greedy
1481,"process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 flags;
	uint8 type;
	uint8 *next_order;

	in_uint16_le(s, length);
	in_uint16_le(s, flags);	/* used by bmpcache2 */
	in_uint8(s, type);

	next_order = s->p + (sint16) length + 7;

	switch (type)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, flags, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, flags, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, flags);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", type);
	}

	s->p = next_order;
}","process_secondary_order(STREAM s)
{
	/* The length isn't calculated correctly by the server.
	 * For very compact orders the length becomes negative
	 * so a signed integer must be used. */
	uint16 length;
	uint16 grades;
	uint8 sort;
	uint8 *next_order;

	in_uint16_le(s, length);
	in_uint16_le(s, grades);	/* used by bmpcache2 */
	in_uint8(s, sort);

	next_order = s->p + (sint16) length + 7;

	switch (sort)
	{
		case RDP_ORDER_RAW_BMPCACHE:
			process_raw_bmpcache(s);
			break;

		case RDP_ORDER_COLCACHE:
			process_colcache(s);
			break;

		case RDP_ORDER_BMPCACHE:
			process_bmpcache(s);
			break;

		case RDP_ORDER_FONTCACHE:
			process_fontcache(s);
			break;

		case RDP_ORDER_RAW_BMPCACHE2:
			process_bmpcache2(s, grades, False);	/* uncompressed */
			break;

		case RDP_ORDER_BMPCACHE2:
			process_bmpcache2(s, grades, True);	/* compressed */
			break;

		case RDP_ORDER_BRUSHCACHE:
			process_brushcache(s, grades);
			break;

		default:
			logger(Graphics, Warning,
			       ""process_secondary_order(), unhandled secondary order %d"", sort);
	}

	s->p = next_order;
}",160.0,51.0,"flags:grades,type:sort,",140.0,0.0611309091250101,Greedy
1488,"static void aead_sock_destruct(struct sock *sk)
{
	struct alg_sock *ask = alg_sk(sk);
	struct af_alg_ctx *ctx = ask->private;
	struct sock *psk = ask->parent;
	struct alg_sock *pask = alg_sk(psk);
	struct aead_tfm *aeadc = pask->private;
	struct crypto_aead *tfm = aeadc->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfm);

	af_alg_pull_tsgl(sk, ctx->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(sk, ctx->iv, ivlen);
	sock_kfree_s(sk, ctx, ctx->len);
	af_alg_release_parent(sk);
}","static void aead_sock_destruct(struct sock *ki)
{
	struct alg_sock *ann = alg_sk(ki);
	struct af_alg_ctx *hw = ann->private;
	struct sock *pki = ann->parent;
	struct alg_sock *cpak = alg_sk(pki);
	struct aead_tfm *aefm = cpak->private;
	struct crypto_aead *tfms = aefm->aead;
	unsigned int ivlen = crypto_aead_ivsize(tfms);

	af_alg_pull_tsgl(ki, hw->used, NULL, 0);
	crypto_put_default_null_skcipher2();
	sock_kzfree_s(ki, hw->iv, ivlen);
	sock_kfree_s(ki, hw, hw->len);
	af_alg_release_parent(ki);
}",120.0,33.0,"sk:ki,ctx:hw,ask:ann,psk:pki,pask:cpak,aeadc:aefm,tfm:tfms,",288.0,0.1281398097674052,Greedy
1492,"includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		errorCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		errorCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}","includeFile(FileInfo *nested, CharsString *includedFile,
		CharacterClass **characterClasses,
		TranslationTableCharacterAttributes *characterClassAttribute,
		short opcodeLengths[], TranslationTableOffset *newRuleOffset,
		TranslationTableRule **newRule, RuleName **ruleNames,
		TranslationTableHeader **table) {
	int k;
	char includeThis[MAXSTRING];
	char **tableFiles;
	int rv;
	for (k = 0; k < includedFile->length; k++)
		includeThis[k] = (char)includedFile->chars[k];
	includeThis[k] = 0;
	tableFiles = _lou_resolveTable(includeThis, nested->fileName);
	if (tableFiles == NULL) {
		rowCount++;
		return 0;
	}
	if (tableFiles[1] != NULL) {
		rowCount++;
		free_tablefiles(tableFiles);
		_lou_logMessage(LOG_ERROR,
				""Table list not supported in include statement: 'include %s'"",
				includeThis);
		return 0;
	}
	rv = compileFile(*tableFiles, characterClasses, characterClassAttribute,
			opcodeLengths, newRuleOffset, newRule, ruleNames, table);
	free_tablefiles(tableFiles);
	return rv;
}",186.0,51.0,"errorCount:rowCount,",51.0,0.0291301886240641,Greedy
1519,"static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user * _params)
{
	struct snd_pcm_hw_params *params;
	int err;

	params = memdup_user(_params, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	err = snd_pcm_hw_params(substream, params);
	if (err < 0)
		goto end;

	if (copy_to_user(_params, params, sizeof(*params)))
		err = -EFAULT;
end:
	kfree(params);
	return err;
}","static int snd_pcm_hw_params_user(struct snd_pcm_substream *substream,
				  struct snd_pcm_hw_params __user *  _source)
{
	struct snd_pcm_hw_params *params;
	int valid;

	params = memdup_user( _source, sizeof(*params));
	if (IS_ERR(params))
		return PTR_ERR(params);

	valid = snd_pcm_hw_params(substream, params);
	if (valid < 0)
		goto end;

	if (copy_to_user( _source, params, sizeof(*params)))
		valid = -EFAULT;
end:
	kfree(params);
	return valid;
}",99.0,28.0,"_params: _source,err:valid,",105.0,0.0523081302642822,Greedy
1524,"static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num_reports = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num_reports--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;

		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);

		ptr += sizeof(*ev);
	}

	hci_dev_unlock(hdev);
}","static void hci_le_direct_adv_report_evt(struct hci_dev *hdev,
					 struct sk_buff *skb)
{
	u8 num__events = skb->data[0];
	void *ptr = &skb->data[1];

	hci_dev_lock(hdev);

	while (num__events--) {
		struct hci_ev_le_direct_adv_info *ev = ptr;

		process_adv_report(hdev, ev->evt_type, &ev->bdaddr,
				   ev->bdaddr_type, &ev->direct_addr,
				   ev->direct_addr_type, ev->rssi, NULL, 0);

		ptr += sizeof(*ev);
	}

	hci_dev_unlock(hdev);
}",105.0,24.0,"num_reports:num__events,",38.0,0.029926331837972,Greedy
1525,"static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */
{
	struct fpm_worker_pool_s *wp, *wp_next;

	for (wp = fpm_worker_all_pools; wp; wp = wp_next) {
		wp_next = wp->next;
		fpm_worker_pool_config_free(wp->config);
		fpm_children_free(wp->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wp->scoreboard);
		}
		fpm_worker_pool_free(wp);
	}
	fpm_worker_all_pools = NULL;
}","static void fpm_worker_pool_cleanup(int which, void *arg) /* {{{ */
{
	struct fpm_worker_pool_s *wn, *wp_next;

	for (wn = fpm_worker_all_pools; wn; wn = wp_next) {
		wp_next = wn->next;
		fpm_worker_pool_config_free(wn->config);
		fpm_children_free(wn->children);
		if ((which & FPM_CLEANUP_CHILD) == 0 && fpm_globals.parent_pid == getpid()) {
			fpm_scoreboard_free(wn->scoreboard);
		}
		fpm_worker_pool_free(wn);
	}
	fpm_worker_all_pools = NULL;
}",91.0,25.0,"wp:wn,",80.0,0.0425905625025431,Greedy
1531,"static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_blk,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_blk <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_blk + count < start_blk) ||
	    (start_blk + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_blk + count - 1 < entry->start_blk)
			n = n->rb_left;
		else if (start_blk >= (entry->start_blk + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}","static int ext4_data_block_valid_rcu(struct ext4_sb_info *sbi,
				     struct ext4_system_blocks *system_blks,
				     ext4_fsblk_t start_lck,
				     unsigned int count)
{
	struct ext4_system_zone *entry;
	struct rb_node *n;

	if ((start_lck <= le32_to_cpu(sbi->s_es->s_first_data_block)) ||
	    (start_lck + count < start_lck) ||
	    (start_lck + count > ext4_blocks_count(sbi->s_es)))
		return 0;

	if (system_blks == NULL)
		return 1;

	n = system_blks->root.rb_node;
	while (n) {
		entry = rb_entry(n, struct ext4_system_zone, node);
		if (start_lck + count - 1 < entry->start_lck)
			n = n->rb_left;
		else if (start_lck >= (entry->start_lck + entry->count))
			n = n->rb_right;
		else
			return 0;
	}
	return 1;
}",153.0,37.0,"start_blk:start_lck,",121.0,0.0459315061569213,Greedy
1535,"int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int res;
	u8 *req;
	u8 *resp;
	struct sas_rphy *rphy = dev_to_rphy(phy->dev.parent);
	struct domain_device *dev = sas_find_dev_by_rphy(rphy);

	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;

	res = smp_execute_task(dev, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);

	if (!res)
		goto out;

	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	kfree(resp);
	return res;

}","int sas_smp_get_phy_events(struct sas_phy *phy)
{
	int nos;
	u8 *req;
	u8 *resp;
	struct sas_rphy *arpy = dev_to_rphy(phy->rec.parent);
	struct domain_device *rec = sas_find_dev_by_rphy(arpy);

	req = alloc_smp_req(RPEL_REQ_SIZE);
	if (!req)
		return -ENOMEM;

	resp = alloc_smp_resp(RPEL_RESP_SIZE);
	if (!resp) {
		kfree(req);
		return -ENOMEM;
	}

	req[1] = SMP_REPORT_PHY_ERR_LOG;
	req[9] = phy->number;

	nos = smp_execute_task(rec, req, RPEL_REQ_SIZE,
			            resp, RPEL_RESP_SIZE);

	if (!nos)
		goto out;

	phy->invalid_dword_count = scsi_to_u32(&resp[12]);
	phy->running_disparity_error_count = scsi_to_u32(&resp[16]);
	phy->loss_of_dword_sync_count = scsi_to_u32(&resp[20]);
	phy->phy_reset_problem_count = scsi_to_u32(&resp[24]);

 out:
	kfree(resp);
	return nos;

}",185.0,50.0,"rphy:arpy,res:nos,dev:rec,",158.0,0.074769127368927,Greedy
1541,"static void _CONSTRUCTOR lib_init(void)
{
int ret;
const char *e;

	if (_gnutls_global_init_skip() != 0)
		return;

	e = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (e != NULL) {
		ret = atoi(e);
		if (ret == 1)
			return;
	}

	ret = gnutls_global_init();
	if (ret < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s\n"", gnutls_strerror(ret));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}","static void _CONSTRUCTOR lib_init(void)
{
int fat;
const char *eve;

	if (_gnutls_global_init_skip() != 0)
		return;

	eve = getenv(""GNUTLS_NO_EXPLICIT_INIT"");
	if (eve != NULL) {
		fat = atoi(eve);
		if (fat == 1)
			return;
	}

	fat = gnutls_global_init();
	if (fat < 0) {
		fprintf(stderr, ""Error in GnuTLS initialization: %s
"", gnutls_strerror(fat));
		_gnutls_switch_lib_state(LIB_STATE_ERROR);
	}
}",92.0,21.0,"ret:fat,e:eve,",133.0,0.0559741735458374,Greedy
1542,"get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int *rulenum)
{
	const struct xt_standard_target *t = (void *)ipt_get_target_c(s);

	if (strcmp(t->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = t->target.data;
		(*rulenum) = 0;
	} else if (s == e) {
		(*rulenum)++;

		if (s->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(t->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   t->verdict < 0 &&
		   unconditional(&s->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(*rulenum)++;

	return 0;
}","get_chainname_rulenum(const struct ipt_entry *ssl, const struct ipt_entry *e,
		      const char *hookname, const char **chainname,
		      const char **comment, unsigned int * rULenum)
{
	const struct xt_standard_target *tor = (void *)ipt_get_target_c(ssl);

	if (strcmp(tor->target.u.kernel.target->name, XT_ERROR_TARGET) == 0) {
		/* Head of user chain: ERROR target with chainname */
		*chainname = tor->target.data;
		(* rULenum) = 0;
	} else if (ssl == e) {
		(* rULenum)++;

		if (ssl->target_offset == sizeof(struct ipt_entry) &&
		    strcmp(tor->target.u.kernel.target->name,
			   XT_STANDARD_TARGET) == 0 &&
		   tor->verdict < 0 &&
		   unconditional(&ssl->ip)) {
			/* Tail of chains: STANDARD target (return/policy) */
			*comment = *chainname == hookname
				? comments[NF_IP_TRACE_COMMENT_POLICY]
				: comments[NF_IP_TRACE_COMMENT_RETURN];
		}
		return 1;
	} else
		(* rULenum)++;

	return 0;
}",185.0,34.0,"t:tor,s:ssl,rulenum: rULenum,",180.0,0.0803970297177632,Greedy
1546,"void xdp_del_sk_umem(struct xdp_umem *umem, struct xdp_sock *xs)
{
	unsigned long flags;

	if (!xs->tx)
		return;

	spin_lock_irqsave(&umem->xsk_list_lock, flags);
	list_del_rcu(&xs->list);
	spin_unlock_irqrestore(&umem->xsk_list_lock, flags);
}","void xdp_del_sk_umem(struct xdp_umem *umEM, struct xdp_sock *xc)
{
	unsigned long len;

	if (!xc->tx)
		return;

	spin_lock_irqsave(&umEM->xsk_list_lock, len);
	list_del_rcu(&xc->list);
	spin_unlock_irqrestore(&umEM->xsk_list_lock, len);
}",56.0,13.0,"xs:xc,flags:len,umem:umEM,",153.0,0.0669586141904195,Greedy
1547,"struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *asoc)
{
	struct sctp_hmac_algo_param *hmacs;
	__u16 n_elt;
	__u16 id = 0;
	int i;

	/* If we have a default entry, use it */
	if (asoc->default_hmac_id)
		return &sctp_hmac_list[asoc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	hmacs = asoc->peer.peer_hmacs;
	if (!hmacs)
		return NULL;

	n_elt = (ntohs(hmacs->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (i = 0; i < n_elt; i++) {
		id = ntohs(hmacs->hmac_ids[i]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}","struct sctp_hmac *sctp_auth_asoc_get_hmac(const struct sctp_association *amroc)
{
	struct sctp_hmac_algo_param *HMac;
	__u16  n_elta;
	__u16 id = 0;
	int multi;

	/* If we have a default entry, use it */
	if (amroc->default_hmac_id)
		return &sctp_hmac_list[amroc->default_hmac_id];

	/* Since we do not have a default entry, find the first entry
	 * we support and return that.  Do not cache that id.
	 */
	HMac = amroc->peer.peer_hmacs;
	if (!HMac)
		return NULL;

	 n_elta = (ntohs(HMac->param_hdr.length) - sizeof(sctp_paramhdr_t)) >> 1;
	for (multi = 0; multi <  n_elta; multi++) {
		id = ntohs(HMac->hmac_ids[multi]);

		/* Check the id is in the supported range */
		if (id > SCTP_AUTH_HMAC_ID_MAX)
			continue;

		/* See is we support the id.  Supported IDs have name and
		 * length fields set, so that we can allocated and use
		 * them.  We can safely just check for name, for without the
		 * name, we can't allocate the TFM.
		 */
		if (!sctp_hmac_list[id].hmac_name)
			continue;

		break;
	}

	if (id == 0)
		return NULL;

	return &sctp_hmac_list[id];
}",145.0,31.0,"n_elt: n_elta,i:multi,asoc:amroc,hmacs:HMac,",213.0,0.0942711631457011,Greedy
1549,"renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ h_env;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *t;
    int i, col, row;
    int indent, maxwidth;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (i = 0; i < tbl->ntable; i++) {
	t = tbl->tables[i].ptr;
	col = tbl->tables[i].col;
	row = tbl->tables[i].row;
	indent = tbl->tables[i].indent;

	init_henv(&h_env, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[i].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (h_env.limit > maxlimit)
	    h_env.limit = maxlimit;
	if (t->total_width == 0)
	    maxwidth = h_env.limit - indent;
	else if (t->total_width > 0)
	    maxwidth = t->total_width;
	else
	    maxwidth = t->total_width = -t->total_width * h_env.limit / 100;
	renderTable(t, maxwidth, &h_env);
    }
}","renderCoTable(struct table *tbl, int maxlimit)
{
    struct readbuffer obuf;
    struct html_feed_environ hPpriv;
    struct environment envs[MAX_ENV_LEVEL];
    struct table *not;
    int eni, col, row;
    int indent, defaultweight;

    if (cotable_level >= MAX_COTABLE_LEVEL)
	return;	/* workaround to prevent infinite recursion */
    cotable_level++;

    for (eni = 0; eni < tbl->ntable; eni++) {
	not = tbl->tables[eni].ptr;
	col = tbl->tables[eni].col;
	row = tbl->tables[eni].row;
	indent = tbl->tables[eni].indent;

	init_henv(&hPpriv, &obuf, envs, MAX_ENV_LEVEL, tbl->tables[eni].buf,
		  get_spec_cell_width(tbl, row, col), indent);
	check_row(tbl, row);
	if (hPpriv.limit > maxlimit)
	    hPpriv.limit = maxlimit;
	if (not->total_width == 0)
	    defaultweight = hPpriv.limit - indent;
	else if (not->total_width > 0)
	    defaultweight = not->total_width;
	else
	    defaultweight = not->total_width = -not->total_width * hPpriv.limit / 100;
	renderTable(not, defaultweight, &hPpriv);
    }
}",229.0,66.0,"i:eni,t:not,h_env:hPpriv,maxwidth:defaultweight,",264.0,0.1086211482683817,Greedy
1551,"   Move specified message to a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *streamind;
	zend_string *seq, *folder;
	zend_long options = 0;
	pils *imap_le_struct;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rSS|l"", &streamind, &seq, &folder, &options) == FAILURE) {
		return;
	}

	if ((imap_le_struct = (pils *)zend_fetch_resource(Z_RES_P(streamind), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}

	if (mail_copy_full(imap_le_struct->imap_stream, ZSTR_VAL(seq), ZSTR_VAL(folder), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}","   Move  from message pack a mailbox */
PHP_FUNCTION(imap_mail_move)
{
	zval *contextinc;
	zend_string *slice, *sample;
	zend_long options = 0;
	pils *imap_le_resource;
	int argc = ZEND_NUM_ARGS();

	if (zend_parse_parameters(argc, ""rSS|l"", &contextinc, &slice, &sample, &options) == FAILURE) {
		return;
	}

	if ((imap_le_resource = (pils *)zend_fetch_resource(Z_RES_P(contextinc), ""imap"", le_imap)) == NULL) {
		RETURN_FALSE;
	}

	if (mail_copy_full(imap_le_resource->imap_stream, ZSTR_VAL(slice), ZSTR_VAL(sample), (argc == 4 ? (options | CP_MOVE) : CP_MOVE)) == T) {
		RETURN_TRUE;
	} else {
		RETURN_FALSE;
	}",143.0,37.0,"folder:sample,seq:slice,streamind:contextinc,imap_le_struct:imap_le_resource,specified: from,to:pack,",206.0,0.1034207503000895,Greedy
1556,"static void naludmx_add_param_nalu(GF_List *param_list, GF_NALUFFParam *sl, u8 nal_type)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, count;
	count = gf_list_count(param_list);
	for (i=0; i<count; i++) {
		pa = gf_list_get(param_list, i);
		if (pa->type == nal_type) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nal_type;
		pa->nalus = gf_list_new();
		gf_list_add(param_list, pa);
	}
	gf_list_add(pa->nalus, sl);
}","static void naludmx_add_param_nalu(GF_List *paramadqueue, GF_NALUFFParam *kl, u8 nalullvalue)
{
	GF_NALUFFParamArray *pa = NULL;
	u32 i, pool;
	pool = gf_list_count(paramadqueue);
	for (i=0; i<pool; i++) {
		pa = gf_list_get(paramadqueue, i);
		if (pa->type == nalullvalue) break;
		pa = NULL;
	}
	if (!pa) {
		GF_SAFEALLOC(pa, GF_NALUFFParamArray);
		if (!pa) return;

		pa->array_completeness = 1;
		pa->type = nalullvalue;
		pa->nalus = gf_list_new();
		gf_list_add(paramadqueue, pa);
	}
	gf_list_add(pa->nalus, kl);
}",130.0,37.0,"sl:kl,nal_type:nalullvalue,count:pool,param_list:paramadqueue,",184.0,0.0835387706756591,Greedy
1570,"int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *buf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}","int avpriv_ac3_parse_header(AC3HeaderInfo **phdr, const uint8_t *uf,
                            size_t size)
{
    return AVERROR(ENOSYS);
}",24.0,6.0,"buf:uf,",33.0,0.0310550530751546,Greedy
1578,"MODRET auth_pre_user(cmd_rec *cmd) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elapsed_ms;
      uint64_t finish_ms;

      pr_gettimeofday_millis(&finish_ms);
      elapsed_ms = (unsigned long) (finish_ms - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elapsed_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(cmd);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(cmd->tmp_pool);
  pr_auth_endgrent(cmd->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(cmd->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", cmd->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(cmd, EPERM);
    errno = EPERM;
    return PR_ERROR(cmd);
  }

  return PR_DECLINED(cmd);
}","MODRET auth_pre_user(cmd_rec *qq) {

  if (saw_first_user_cmd == FALSE) {
    if (pr_trace_get_level(timing_channel)) {
      unsigned long elished_ms;
      uint64_t finishptents;

      pr_gettimeofday_millis(&finishptents);
      elished_ms = (unsigned long) (finishptents - session.connect_time_ms);

      pr_trace_msg(timing_channel, 4, ""Time before first USER: %lu ms"",
        elished_ms);
    }
    saw_first_user_cmd = TRUE;
  }

  if (logged_in) {
    return PR_DECLINED(qq);
  }

  /* Close the passwd and group databases, because libc won't let us see new
   * entries to these files without this (only in PersistentPasswd mode).
   */
  pr_auth_endpwent(qq->tmp_pool);
  pr_auth_endgrent(qq->tmp_pool);

  /* Check for a user name that exceeds PR_TUNABLE_LOGIN_MAX. */
  if (strlen(qq->arg) > PR_TUNABLE_LOGIN_MAX) {
    pr_log_pri(PR_LOG_NOTICE, ""USER %s (Login failed): ""
      ""maximum USER length exceeded"", qq->arg);
    pr_response_add_err(R_501, _(""Login incorrect.""));

    pr_cmd_set_errno(qq, EPERM);
    errno = EPERM;
    return PR_ERROR(qq);
  }

  return PR_DECLINED(qq);
}",156.0,41.0,"elapsed_ms:elished_ms,finish_ms:finishptents,cmd:qq,",149.0,0.0723849614461263,Greedy
1580,"static pyc_object *get_binary_float_object(RBuffer *buffer) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (buffer, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}","static pyc_object *get_binary_float_object(RBuffer *seed) {
	pyc_object *ret = NULL;
	bool error = false;
	double f;

	f = get_float64 (seed, &error);
	if (error) {
		return NULL;
	}
	ret = R_NEW0 (pyc_object);
	if (!ret) {
		return NULL;
	}
	ret->type = TYPE_FLOAT;
	ret->data = r_str_newf (""%.15g"", f);
	if (!ret->data) {
		R_FREE (ret);
		return NULL;
	}
	return ret;
}",99.0,23.0,"buffer:seed,",52.0,0.0351083954175313,Greedy
1588,"int quicklistBookmarkDelete(quicklist *ql, const char *name) {
    quicklistBookmark *bm = _quicklistBookmarkFindByName(ql, name);
    if (!bm)
        return 0;
    _quicklistBookmarkDelete(ql, bm);
    return 1;
}","int quicklistBookmarkDelete(quicklist *qt, const char *part) {
    quicklistBookmark *bank = _quicklistBookmarkFindByName(qt, part);
    if (!bank)
        return 0;
    _quicklistBookmarkDelete(qt, bank);
    return 1;
}",43.0,11.0,"name:part,bm:bank,ql:qt,",134.0,0.0603564222653706,Greedy
1608,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	int ret = 0;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = file_inode(file);

	/*
	 * Unprivileged query to obtain the containing subvolume root id. The
	 * path is reset so it's consistent with btrfs_search_path_in_tree.
	 */
	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	if (args->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		args->name[0] = 0;
		goto out;
	}

	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

out:
	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *atts;
	 struct inode *inode;
	int ret = 0;

	atts = memdup_user(argp, sizeof(*atts));
	if (IS_ERR(atts))
		return PTR_ERR(atts);

	inode = file_inode(file);

	/*
	 * Unprivileged query to obtain the containing subvolume root id. The
	 * path is reset so it's consistent with btrfs_search_path_in_tree.
	 */
	if (atts->treeid == 0)
		atts->treeid = BTRFS_I(inode)->root->root_key.objectid;

	if (atts->objectid == BTRFS_FIRST_FREE_OBJECTID) {
		atts->name[0] = 0;
		goto out;
	}

	if (!capable(CAP_SYS_ADMIN)) {
		ret = -EPERM;
		goto out;
	}

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					atts->treeid, atts->objectid,
					atts->name);

out:
	if (ret == 0 && copy_to_user(argp, atts, sizeof(*atts)))
		ret = -EFAULT;

	kfree(atts);
	return ret;
}",188.0,47.0,"args:atts,",122.0,0.0468966841697692,Greedy
1619,"static irda_queue_t *dequeue_general(irda_queue_t **queue, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()\n"");

	/*
	 * Set return value
	 */
	ret =  *queue;

	if ( *queue == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*queue)->q_next == *queue ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*queue = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*queue) == element)
			(*queue) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}","static irda_queue_t *dequeue_general(irda_queue_t **buffer, irda_queue_t* element)
{
	irda_queue_t *ret;

	pr_debug(""dequeue_general()
"");

	/*
	 * Set return value
	 */
	ret =  *buffer;

	if ( *buffer == NULL ) {
		/*
		 * Queue was empty.
		 */
	} else if ( (*buffer)->q_next == *buffer ) {
		/*
		 *  Queue only contained a single element. It will now be
		 *  empty.
		 */
		*buffer = NULL;

	} else {
		/*
		 *  Remove specific element.
		 */
		element->q_prev->q_next = element->q_next;
		element->q_next->q_prev = element->q_prev;
		if ( (*buffer) == element)
			(*buffer) = element->q_next;
	}

	/*
	 * Return the removed entry (or NULL of queue was empty).
	 */
	return ret;
}",105.0,20.0,"queue:buffer,",84.0,0.0441320339838663,Greedy
1627,"pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		retsize;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 &retsize,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}","pq_setkeepaliveswin32(Port *port, int idle, int interval)
{
	struct tcp_keepalive ka;
	DWORD		 secretsIZE;

	if (idle <= 0)
		idle = 2 * 60 * 60;		/* default = 2 hours */
	if (interval <= 0)
		interval = 1;			/* default = 1 second */

	ka.onoff = 1;
	ka.keepalivetime = idle * 1000;
	ka.keepaliveinterval = interval * 1000;

	if (WSAIoctl(port->sock,
				 SIO_KEEPALIVE_VALS,
				 (LPVOID) &ka,
				 sizeof(ka),
				 NULL,
				 0,
				 & secretsIZE,
				 NULL,
				 NULL)
		!= 0)
	{
		elog(LOG, ""WSAIoctl(SIO_KEEPALIVE_VALS) failed: %ui"",
			 WSAGetLastError());
		return STATUS_ERROR;
	}
	if (port->keepalives_idle != idle)
		port->keepalives_idle = idle;
	if (port->keepalives_interval != interval)
		port->keepalives_interval = interval;
	return STATUS_OK;
}",150.0,35.0,"retsize: secretsIZE,",40.0,0.0287851730982462,Greedy
1631,"void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_cnt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_drainers++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool drained;

		spin_lock_irq(&pwq->pool->lock);
		drained = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (drained)
			continue;

		if (++flush_cnt == 10 ||
		    (flush_cnt % 100 == 0 && flush_cnt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries\n"",
				wq->name, flush_cnt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_drainers)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}","void drain_workqueue(struct workqueue_struct *wq)
{
	unsigned int flush_discpt = 0;
	struct pool_workqueue *pwq;

	/*
	 * __queue_work() needs to test whether there are drainers, is much
	 * hotter than drain_workqueue() and already looks at @wq->flags.
	 * Use __WQ_DRAINING so that queue doesn't have to check nr_drainers.
	 */
	mutex_lock(&wq->mutex);
	if (!wq->nr_dulators++)
		wq->flags |= __WQ_DRAINING;
	mutex_unlock(&wq->mutex);
reflush:
	flush_workqueue(wq);

	mutex_lock(&wq->mutex);

	for_each_pwq(pwq, wq) {
		bool dripped;

		spin_lock_irq(&pwq->pool->lock);
		dripped = !pwq->nr_active && list_empty(&pwq->delayed_works);
		spin_unlock_irq(&pwq->pool->lock);

		if (dripped)
			continue;

		if (++flush_discpt == 10 ||
		    (flush_discpt % 100 == 0 && flush_discpt <= 1000))
			pr_warn(""workqueue %s: drain_workqueue() isn't complete after %u tries
"",
				wq->name, flush_discpt);

		mutex_unlock(&wq->mutex);
		goto reflush;
	}

	if (!--wq->nr_dulators)
		wq->flags &= ~__WQ_DRAINING;
	mutex_unlock(&wq->mutex);
}",184.0,39.0,"nr_drainers:nr_dulators,drained:dripped,flush_cnt:flush_discpt,",184.0,0.0823964516321818,Greedy
1632,"static int createFromTiffRgba(TIFF * tif, gdImagePtr im)
{
	int a;
	int x, y;
	int alphaBlendingFlag = 0;
	int color;
	int width = im->sx;
	int height = im->sy;
	uint32 *buffer;
	uint32 rgba;

	/* switch off colour merging on target gd image just while we write out
	 * content - we want to preserve the alpha data until the user chooses
	 * what to do with the image */
	alphaBlendingFlag = im->alphaBlendingFlag;
	gdImageAlphaBlending(im, 0);

	buffer = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!buffer) {
		return GD_FAILURE;
	}

	TIFFReadRGBAImage(tif, width, height, buffer, 0);

	for(y = 0; y < height; y++) {
		for(x = 0; x < width; x++) {
			/* if it doesn't already exist, allocate a new colour,
			 * else use existing one */
			rgba = buffer[(y * width + x)];
			a = (0xff - TIFFGetA(rgba)) / 2;
			color = gdTrueColorAlpha(TIFFGetR(rgba), TIFFGetG(rgba), TIFFGetB(rgba), a);

			/* set pixel colour to this colour */
			gdImageSetPixel(im, x, height - y - 1, color);
		}
	}

	gdFree(buffer);

	/* now reset colour merge for alpha blending routines */
	gdImageAlphaBlending(im, alphaBlendingFlag);
	return GD_SUCCESS;
}","static int createFromTiffRgba(TIFF * el, gdImagePtr anim)
{
	int aaa;
	int wx, xx;
	int alphaBlendingFlag = 0;
	int light;
	int width = anim->sx;
	int height = anim->sy;
	uint32 *pause;
	uint32 ginda;

	/* switch off colour merging on target gd image just while we write out
	 * content - we want to preserve the alpha data until the user chooses
	 * what to do with the image */
	alphaBlendingFlag = anim->alphaBlendingFlag;
	gdImageAlphaBlending(anim, 0);

	pause = (uint32 *) gdCalloc(sizeof(uint32), width * height);
	if (!pause) {
		return GD_FAILURE;
	}

	TIFFReadRGBAImage(el, width, height, pause, 0);

	for(xx = 0; xx < height; xx++) {
		for(wx = 0; wx < width; wx++) {
			/* if it doesn't already exist, allocate a new colour,
			 * else use existing one */
			ginda = pause[(xx * width + wx)];
			aaa = (0xff - TIFFGetA(ginda)) / 2;
			light = gdTrueColorAlpha(TIFFGetR(ginda), TIFFGetG(ginda), TIFFGetB(ginda), aaa);

			/* set pixel colour to this colour */
			gdImageSetPixel(anim, wx, height - xx - 1, light);
		}
	}

	gdFree(pause);

	/* now reset colour merge for alpha blending routines */
	gdImageAlphaBlending(anim, alphaBlendingFlag);
	return GD_SUCCESS;
}",212.0,67.0,"im:anim,rgba:ginda,buffer:pause,y:xx,x:wx,color:light,a:aaa,tif:el,",447.0,0.1798709313074747,Greedy
1633,"static __u32 __packet_set_timestamp(struct packet_sock *po, void *frame,
				    struct sk_buff *skb)
{
	union tpacket_uhdr h;
	struct timespec64 ts;
	__u32 ts_status;

	if (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))
		return 0;

	h.raw = frame;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (po->tp_version) {
	case TPACKET_V1:
		h.h1->tp_sec = ts.tv_sec;
		h.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		h.h2->tp_sec = ts.tv_sec;
		h.h2->tp_nsec = ts.tv_nsec;
		break;
	case TPACKET_V3:
		h.h3->tp_sec = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.\n"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&h.h1->tp_sec));
	smp_wmb();

	return ts_status;
}","static __u32 __packet_set_timestamp(struct packet_sock *pos, void *slice,
				    struct sk_buff *skybs)
{
	union tpacket_uhdr ht;
	struct timespec64 atts;
	__u32 ts_source;

	if (!(ts_source = tpacket_get_timestamp(skybs, &atts, pos->tp_tstamp)))
		return 0;

	ht.raw = slice;
	/*
	 * versions 1 through 3 overflow the timestamps in y2106, since they
	 * all store the seconds in a 32-bit unsigned integer.
	 * If we create a version 4, that should have a 64-bit timestamp,
	 * either 64-bit seconds + 32-bit nanoseconds, or just 64-bit
	 * nanoseconds.
	 */
	switch (pos->tp_version) {
	case TPACKET_V1:
		ht.h1->tp_sec = atts.tv_sec;
		ht.h1->tp_usec = atts.tv_nsec / NSEC_PER_USEC;
		break;
	case TPACKET_V2:
		ht.h2->tp_sec = atts.tv_sec;
		ht.h2->tp_nsec = atts.tv_nsec;
		break;
	case TPACKET_V3:
		ht.h3->tp_sec = atts.tv_sec;
		ht.h3->tp_nsec = atts.tv_nsec;
		break;
	default:
		WARN(1, ""TPACKET version not supported.
"");
		BUG();
	}

	/* one flush is safe, as both fields always lie on the same cacheline */
	flush_dcache_page(pgv_to_page(&ht.h1->tp_sec));
	smp_wmb();

	return ts_source;
}",179.0,38.0,"skb:skybs,frame:slice,ts_status:ts_source,po:pos,ts:atts,h:ht,",295.0,0.134725801150004,Greedy
1636,"static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *dev;
	int minor = interface->minor;

	dev = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &yurex_class);

	/* prevent more I/O from starting */
	mutex_lock(&dev->io_mutex);
	dev->interface = NULL;
	mutex_unlock(&dev->io_mutex);

	/* wakeup waiters */
	kill_fasync(&dev->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&dev->waitq);

	/* decrement our usage count */
	kref_put(&dev->kref, yurex_delete);

	dev_info(&interface->dev, ""USB YUREX #%d now disconnected\n"", minor);
}","static void yurex_disconnect(struct usb_interface *interface)
{
	struct usb_yurex *grad;
	int minor = interface->minor;

	grad = usb_get_intfdata(interface);
	usb_set_intfdata(interface, NULL);

	/* give back our minor */
	usb_deregister_dev(interface, &yurex_class);

	/* prevent more I/O from starting */
	mutex_lock(&grad->io_mutex);
	grad->interface = NULL;
	mutex_unlock(&grad->io_mutex);

	/* wakeup waiters */
	kill_fasync(&grad->async_queue, SIGIO, POLL_IN);
	wake_up_interruptible(&grad->waitq);

	/* decrement our usage count */
	kref_put(&grad->kref, yurex_delete);

	dev_info(&interface->grad, ""USB YUREX #%d now disconnected
"", minor);
}",111.0,30.0,"dev:grad,",87.0,0.0501173496246337,Greedy
1644,"static void shmem_free_blocks(struct inode *inode, long pages)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += pages;
		inode->i_blocks -= pages*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}","static void shmem_free_blocks(struct inode *inode, long cells)
{
	struct shmem_sb_info *sbinfo = SHMEM_SB(inode->i_sb);
	if (sbinfo->max_blocks) {
		spin_lock(&sbinfo->stat_lock);
		sbinfo->free_blocks += cells;
		inode->i_blocks -= cells*BLOCKS_PER_PAGE;
		spin_unlock(&sbinfo->stat_lock);
	}
}",64.0,16.0,"pages:cells,",61.0,0.0356745918591817,Greedy
1673,"static int inet6_fill_prefix(struct sk_buff *skb, struct inet6_dev *idev,
			struct prefix_info *pinfo, u32 pid, u32 seq, 
			int event, unsigned int flags)
{
	struct prefixmsg	*pmsg;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = skb->tail;
	struct prefix_cacheinfo	ci;

	nlh = NLMSG_NEW(skb, pid, seq, event, sizeof(*pmsg), flags);
	pmsg = NLMSG_DATA(nlh);
	pmsg->prefix_family = AF_INET6;
	pmsg->prefix_ifindex = idev->dev->ifindex;
	pmsg->prefix_len = pinfo->prefix_len;
	pmsg->prefix_type = pinfo->type;
	
	pmsg->prefix_flags = 0;
	if (pinfo->onlink)
		pmsg->prefix_flags |= IF_PREFIX_ONLINK;
	if (pinfo->autoconf)
		pmsg->prefix_flags |= IF_PREFIX_AUTOCONF;

	RTA_PUT(skb, PREFIX_ADDRESS, sizeof(pinfo->prefix), &pinfo->prefix);

	ci.preferred_time = ntohl(pinfo->prefered);
	ci.valid_time = ntohl(pinfo->valid);
	RTA_PUT(skb, PREFIX_CACHEINFO, sizeof(ci), &ci);

	nlh->nlmsg_len = skb->tail - b;
	return skb->len;

nlmsg_failure:
rtattr_failure:
	skb_trim(skb, b - skb->data);
	return -1;
}","static int inet6_fill_prefix(struct sk_buff *knf, struct inet6_dev *idev,
			struct prefix_info *ppupdate, u32 pid, u32 seq, 
			int event, unsigned int flags)
{
	struct prefixmsg	*atcall;
	struct nlmsghdr 	*nlh;
	unsigned char		*b = knf->tail;
	struct prefix_cacheinfo	ci;

	nlh = NLMSG_NEW(knf, pid, seq, event, sizeof(*atcall), flags);
	atcall = NLMSG_DATA(nlh);
	atcall->prefix_family = AF_INET6;
	atcall->prefix_ifindex = idev->dev->ifindex;
	atcall->prefix_len = ppupdate->prefix_len;
	atcall->prefix_type = ppupdate->type;
	
	atcall->prefix_flags = 0;
	if (ppupdate->onlink)
		atcall->prefix_flags |= IF_PREFIX_ONLINK;
	if (ppupdate->autoconf)
		atcall->prefix_flags |= IF_PREFIX_AUTOCONF;

	RTA_PUT(knf, PREFIX_ADDRESS, sizeof(ppupdate->prefix), &ppupdate->prefix);

	ci.preferred_time = ntohl(ppupdate->prefered);
	ci.valid_time = ntohl(ppupdate->valid);
	RTA_PUT(knf, PREFIX_CACHEINFO, sizeof(ci), &ci);

	nlh->nlmsg_len = knf->tail - b;
	return knf->len;

nlmsg_failure:
rtattr_failure:
	skb_trim(knf, b - knf->data);
	return -1;
}",236.0,63.0,"pmsg:atcall,skb:knf,pinfo:ppupdate,",323.0,0.1169051130612691,Greedy
1683,"static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *args;
	 struct inode *inode;
	 int ret;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	args = memdup_user(argp, sizeof(*args));
	if (IS_ERR(args))
		return PTR_ERR(args);

	inode = fdentry(file)->d_inode;

	if (args->treeid == 0)
		args->treeid = BTRFS_I(inode)->root->root_key.objectid;

	ret = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					args->treeid, args->objectid,
					args->name);

	if (ret == 0 && copy_to_user(argp, args, sizeof(*args)))
		ret = -EFAULT;

	kfree(args);
	return ret;
}","static noinline int btrfs_ioctl_ino_lookup(struct file *file,
					   void __user *argp)
{
	 struct btrfs_ioctl_ino_lookup_args *atts;
	 struct inode *inode;
	 int match;

	if (!capable(CAP_SYS_ADMIN))
		return -EPERM;

	atts = memdup_user(argp, sizeof(*atts));
	if (IS_ERR(atts))
		return PTR_ERR(atts);

	inode = fdentry(file)->d_inode;

	if (atts->treeid == 0)
		atts->treeid = BTRFS_I(inode)->root->root_key.objectid;

	match = btrfs_search_path_in_tree(BTRFS_I(inode)->root->fs_info,
					atts->treeid, atts->objectid,
					atts->name);

	if (match == 0 && copy_to_user(argp, atts, sizeof(*atts)))
		match = -EFAULT;

	kfree(atts);
	return match;
}",158.0,43.0,"args:atts,ret:match,",186.0,0.0677353819211324,Greedy
1693,"static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;

	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhid_enabled;

		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);

		uhid_enabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhid_enabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhid_enabled);
		} else
			g_clear_error(&err);
	}

	btd_profile_register(&input_profile);

	if (config)
		g_key_file_free(config);

	return 0;
}","static int input_init(void)
{
	GKeyFile *config;
	GError *err = NULL;

	config = load_config_file(CONFIGDIR ""/input.conf"");
	if (config) {
		int idle_timeout;
		gboolean uhd_disabled;

		idle_timeout = g_key_file_get_integer(config, ""General"",
							""IdleTimeout"", &err);
		if (!err) {
			DBG(""input.conf: IdleTimeout=%d"", idle_timeout);
			input_set_idle_timeout(idle_timeout * 60);
		} else
			g_clear_error(&err);

		uhd_disabled = g_key_file_get_boolean(config, ""General"",
							""UserspaceHID"", &err);
		if (!err) {
			DBG(""input.conf: UserspaceHID=%s"", uhd_disabled ?
							""true"" : ""false"");
			input_enable_userspace_hid(uhd_disabled);
		} else
			g_clear_error(&err);
	}

	btd_profile_register(&input_profile);

	if (config)
		g_key_file_free(config);

	return 0;
}",151.0,36.0,"uhid_enabled:uhd_disabled,",45.0,0.0331804553667704,Greedy
1703,"
static void kvm_mmu_notifier_release(struct mmu_notifier *mn,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mn);
	int idx;

	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);","
static void kvm_mmu_notifier_release(struct mmu_notifier *mann,
				     struct mm_struct *mm)
{
	struct kvm *kvm = mmu_notifier_to_kvm(mann);
	int idx;

	idx = srcu_read_lock(&kvm->srcu);
	kvm_arch_flush_shadow_all(kvm);
	srcu_read_unlock(&kvm->srcu, idx);",54.0,15.0,"mn:mann,",53.0,0.0361486752827962,Greedy
1707,"void HeaderMapImpl::addViaMove(HeaderString&& key, HeaderString&& value) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(key.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->value(), value.getStringView());
    key.clear();
    value.clear();
  } else {
    insertByKey(std::move(key), std::move(value));
  }
}","void HeaderMapImpl::addViaMove(HeaderString&& style, HeaderString&& vi) {
  // If this is an inline header, we can't addViaMove, because we'll overwrite
  // the existing value.
  auto* entry = getExistingInline(style.getStringView());
  if (entry != nullptr) {
    appendToHeader(entry->vi(), vi.getStringView());
    style.clear();
    vi.clear();
  } else {
    insertByKey(std::move(style), std::move(vi));
  }
}",83.0,17.0,"value:vi,key:style,",126.0,0.0554425557454427,Greedy
1714,"static inline void invlpga(unsigned long addr, u32 asid)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(asid), ""a""(addr));
}","static inline void invlpga(unsigned long addr, u32 Asids)
{
	asm volatile (__ex(""invlpga %1, %0"") : : ""c""(Asids), ""a""(addr));
}",37.0,6.0,"asid:Asids,",29.0,0.025099778175354,Greedy
1715,"    void writeBytes(const void* data, int length) {
      check(length);
      memcpy(ptr, data, length);
      ptr += length;
    }","    void writeBytes(const void* data, int address) {
      check(address);
      memcpy(ptr, data, address);
      ptr += address;
    }",31.0,11.0,"length:address,",51.0,0.0309956034024556,Greedy
1717,"int cipso_v4_sock_getattr(struct sock *sk, struct netlbl_lsm_secattr *secattr)
{
	struct ip_options *opt;

	opt = inet_sk(sk)->opt;
	if (opt == NULL || opt->cipso == 0)
		return -ENOMSG;

	return cipso_v4_getattr(opt->__data + opt->cipso - sizeof(struct iphdr),
				secattr);
}","int cipso_v4_sock_getattr(struct sock *ctx, struct netlbl_lsm_secattr * secr)
{
	struct ip_options *eff;

	eff = inet_sk(ctx)->eff;
	if (eff == NULL || eff->cipso == 0)
		return -ENOMSG;

	return cipso_v4_getattr(eff->__data + eff->cipso - sizeof(struct iphdr),
				 secr);
}",65.0,14.0,"opt:eff,sk:ctx,secattr: secr,",139.0,0.0651889085769653,Greedy
1719,"find_session_from_nick (char *nick, server *serv)
{
	session *sess;
	GSList *list = sess_list;

	sess = find_dialog (serv, nick);
	if (sess)
		return sess;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (list)
	{
		sess = list->data;
		if (sess->server == serv)
		{
			if (userlist_find (sess, nick))
				return sess;
		}
		list = list->next;
	}
	return NULL;
}","find_session_from_nick (char *nick, server *serv)
{
	session *sssession;
	GSList *fail = sess_list;

	sssession = find_dialog (serv, nick);
	if (sssession)
		return sssession;

	if (serv->front_session)
	{
		if (userlist_find (serv->front_session, nick))
			return serv->front_session;
	}

	if (current_sess && current_sess->server == serv)
	{
		if (userlist_find (current_sess, nick))
			return current_sess;
	}

	while (fail)
	{
		sssession = fail->data;
		if (sssession->server == serv)
		{
			if (userlist_find (sssession, nick))
				return sssession;
		}
		fail = fail->next;
	}
	return NULL;
}",129.0,35.0,"list:fail,sess:sssession,",147.0,0.0611321767171223,Greedy
1720,"static int nr_release(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct nr_sock *nr;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	nr = nr_sk(sk);

	switch (nr->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		nr->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		nr->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sock->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}","static int nr_release(struct socket *sink)
{
	struct sink *sk = sink->sk;
	struct nr_sock *rar;

	if (sk == NULL) return 0;

	sock_hold(sk);
	sock_orphan(sk);
	lock_sock(sk);
	rar = nr_sk(sk);

	switch (rar->state) {
	case NR_STATE_0:
	case NR_STATE_1:
	case NR_STATE_2:
		nr_disconnect(sk, 0);
		nr_destroy_socket(sk);
		break;

	case NR_STATE_3:
		nr_clear_queues(sk);
		rar->n2count = 0;
		nr_write_internal(sk, NR_DISCREQ);
		nr_start_t1timer(sk);
		nr_stop_t2timer(sk);
		nr_stop_t4timer(sk);
		nr_stop_idletimer(sk);
		rar->state    = NR_STATE_2;
		sk->sk_state    = TCP_CLOSE;
		sk->sk_shutdown |= SEND_SHUTDOWN;
		sk->sk_state_change(sk);
		sock_set_flag(sk, SOCK_DESTROY);
		break;

	default:
		break;
	}

	sink->sk   = NULL;
	release_sock(sk);
	sock_put(sk);

	return 0;
}",185.0,54.0,"nr:rar,sock:sink,",132.0,0.0569608132044474,Greedy
1728,"static int cmv_process_header(CmvContext *s, const uint8_t *buf, const uint8_t *buf_end)
{
    int pal_start, pal_count, i, ret, fps;

    if(buf_end - buf < 16) {
        av_log(s->avctx, AV_LOG_WARNING, ""truncated header\n"");
        return AVERROR_INVALIDDATA;
    }

    s->width  = AV_RL16(&buf[4]);
    s->height = AV_RL16(&buf[6]);

    ret = ff_set_dimensions(s->avctx, s->width, s->height);
    if (ret < 0)
        return ret;

    fps = AV_RL16(&buf[10]);
    if (fps > 0)
        s->avctx->time_base = (AVRational){ 1, fps };

    pal_start = AV_RL16(&buf[12]);
    pal_count = AV_RL16(&buf[14]);

    buf += 16;
    for (i=pal_start; i<pal_start+pal_count && i<AVPALETTE_COUNT && buf_end - buf >= 3; i++) {
        s->palette[i] = AV_RB24(buf);
        buf += 3;
    }

    return 0;
}","static int cmv_process_header(CmvContext *lines, const uint8_t *uno, const uint8_t *bufsending)
{
    int palxend, pal__call, xi, mi, bars;

    if(bufsending - uno < 16) {
        av_log(lines->avctx, AV_LOG_WARNING, ""truncated header
"");
        return AVERROR_INVALIDDATA;
    }

    lines->width  = AV_RL16(&uno[4]);
    lines->height = AV_RL16(&uno[6]);

    mi = ff_set_dimensions(lines->avctx, lines->width, lines->height);
    if (mi < 0)
        return mi;

    bars = AV_RL16(&uno[10]);
    if (bars > 0)
        lines->avctx->time_base = (AVRational){ 1, bars };

    palxend = AV_RL16(&uno[12]);
    pal__call = AV_RL16(&uno[14]);

    uno += 16;
    for (xi=palxend; xi<palxend+pal__call && xi<AVPALETTE_COUNT && bufsending - uno >= 3; xi++) {
        lines->palette[xi] = AV_RB24(uno);
        uno += 3;
    }

    return 0;
}",213.0,56.0,"buf_end:bufsending,pal_count:pal__call,pal_start:palxend,fps:bars,ret:mi,i:xi,s:lines,buf:uno,",461.0,0.1766957918802897,Greedy
1732,"static ssize_t regulator_opmode_show(struct device *dev,
				    struct device_attribute *attr, char *buf)
{
	struct regulator_dev *rdev = dev_get_drvdata(dev);

	return regulator_print_opmode(buf, _regulator_get_mode(rdev));
}","static ssize_t regulator_opmode_show(struct device *plug,
				    struct device_attribute *attr, char *buffer)
{
	struct regulator_dev *rdev = dev_get_drvdata(plug);

	return regulator_print_opmode(buffer, _regulator_get_mode(rdev));
}",41.0,11.0,"buf:buffer,dev:plug,",88.0,0.0465000033378601,Greedy
1733,"static inline bool pipe_writable(const struct pipe_inode_info *pipe)
{
	unsigned int head = READ_ONCE(pipe->head);
	unsigned int tail = READ_ONCE(pipe->tail);
	unsigned int max_usage = READ_ONCE(pipe->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pipe->readers);
}","static inline bool pipe_writable(const struct pipe_inode_info *pty)
{
	unsigned int head = READ_ONCE(pty->head);
	unsigned int tail = READ_ONCE(pty->tail);
	unsigned int max_usage = READ_ONCE(pty->max_usage);

	return !pipe_full(head, tail, max_usage) ||
		!READ_ONCE(pty->readers);
}",65.0,17.0,"pipe:pty,",73.0,0.0363370537757873,Greedy
1734,"size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *i)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), i);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}","size_t copy_page_to_iter(struct page *page, size_t offset, size_t bytes,
			 struct iov_iter *iter)
{
	size_t res = 0;
	if (unlikely(!page_copy_sane(page, offset, bytes)))
		return 0;
	page += offset / PAGE_SIZE; // first subpage
	offset %= PAGE_SIZE;
	while (1) {
		size_t n = __copy_page_to_iter(page, offset,
				min(bytes, (size_t)PAGE_SIZE - offset), iter);
		res += n;
		bytes -= n;
		if (!bytes || !n)
			break;
		offset += n;
		if (offset == PAGE_SIZE) {
			page++;
			offset = 0;
		}
	}
	return res;
}",124.0,38.0,"i:iter,",61.0,0.0338754296302795,Greedy
1737,"static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rt = (struct rtable *) dst;

	if (!list_empty(&rt->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rt->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}","static void ipv4_dst_destroy(struct dst_entry *dst)
{
	struct rtable *rot = (struct rtable *) dst;

	if (!list_empty(&rot->rt_uncached)) {
		spin_lock_bh(&rt_uncached_lock);
		list_del(&rot->rt_uncached);
		spin_unlock_bh(&rt_uncached_lock);
	}
}",56.0,12.0,"rt:rot,",52.0,0.0334193189938863,Greedy
1738,"int spl_object_storage_detach(spl_SplObjectStorage *intern, zval *this, zval *obj TSRMLS_DC) /* {{{ */
{
	int hash_len, ret = FAILURE;
	char *hash = spl_object_storage_get_hash(intern, this, obj, &hash_len TSRMLS_CC);
	if (!hash) {
		return ret;
	}
	ret = zend_hash_del(&intern->storage, hash, hash_len);
	spl_object_storage_free_hash(intern, hash);
	
	return ret;
} /* }}}*/","int spl_object_storage_detach(spl_SplObjectStorage *conn, zval *this, zval *obj TSRMLS_DC) /* {{{ */
{
	int hash_lon, ret = FAILURE;
	char *sha = spl_object_storage_get_hash(conn, this, obj, &hash_lon TSRMLS_CC);
	if (!sha) {
		return ret;
	}
	ret = zend_hash_del(&conn->storage, sha, hash_lon);
	spl_object_storage_free_hash(conn, sha);
	
	return ret;
} /* }}}*/",76.0,26.0,"intern:conn,hash:sha,hash_len:hash_lon,",134.0,0.0661466677983601,Greedy
1744,"RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *core, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_copy = strdup(fcnstr);
	char *fcnname_aux = strtok(fcnstr_copy, ""("");
	rz_str_trim_tail(fcnname_aux);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname_aux, ' ');
	fcnname = strdup(ls ? ls : fcnname_aux);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(core, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(core->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(core->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_copy);
	free(fcnstr);
	return res;
}","RZ_IPI bool rz_core_analysis_function_set_signature(RzCore *feature, RzAnalysisFunction *fcn, const char *newsig) {
	bool res = false;
	char *fcnstr = rz_str_newf(""%s;"", newsig);
	char *fcnstr_original = strdup(fcnstr);
	char *fcnname__external = strtok(fcnstr_original, ""("");
	rz_str_trim_tail(fcnname__external);
	char *fcnname = NULL;
	const char *ls = rz_str_lchr(fcnname__external, ' ');
	fcnname = strdup(ls ? ls : fcnname__external);
	if (!fcnname) {
		goto err;
	}
	// TODO: move this into rz_analysis_function_set_type_str()
	if (strcmp(fcn->name, fcnname)) {
		(void)rz_core_analysis_function_rename(feature, fcn->addr, fcnname);
		fcn = rz_analysis_get_fcn_in(feature->analysis, fcn->addr, -1);
	}
	rz_analysis_function_set_type_str(feature->analysis, fcn, fcnstr);
	res = true;
err:
	free(fcnname);
	free(fcnstr_original);
	free(fcnstr);
	return res;
}",179.0,50.0,"ls:ls,fcnname_aux:fcnname__external,fcnstr_copy:fcnstr_original,core:feature,",171.0,0.0880967418352762,Greedy
1750,"void *umm_realloc( void *ptr, size_t size ) {
  void *ret;

  ptr = GET_UNPOISONED(ptr);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  size += POISON_SIZE(size);
  ret = _umm_realloc( ptr, size );

  ret = GET_POISONED(ret, size);

  umm_account_free_blocks_cnt();

  return ret;
}","void *umm_realloc( void *inst, size_t fee ) {
  void *RET;

  inst = GET_UNPOISONED(inst);

  /* check poison of each blocks, if poisoning is enabled */
  if (!CHECK_POISON_ALL_BLOCKS()) {
    return NULL;
  }

  /* check full integrity of the heap, if this check is enabled */
  if (!INTEGRITY_CHECK()) {
    return NULL;
  }

  fee += POISON_SIZE(fee);
  RET = _umm_realloc( inst, fee );

  RET = GET_POISONED(RET, fee);

  umm_account_free_blocks_cnt();

  return RET;
}",80.0,22.0,"size:fee,ret:RET,ptr:inst,",156.0,0.0739041805267333,Greedy
1751,"  Status check_index_ordering(const Tensor& indices) {
    auto findices = indices.flat<int>();

    for (std::size_t i = 0; i < findices.dimension(0) - 1; ++i) {
      if (findices(i) < findices(i + 1)) {
        continue;
      }

      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }

    return Status::OK();
  }","  Status check_index_ordering(const Tensor& predencies) {
    auto findices = predencies.flat<int>();

    for (std::size_t none = 0; none < findices.dimension(0) - 1; ++none) {
      if (findices(none) < findices(none + 1)) {
        continue;
      }

      return Status(
          errors::InvalidArgument(""Indices are not strictly ordered""));
    }

    return Status::OK();
  }",84.0,15.0,"i:none,indices:predencies,",97.0,0.0509788791338602,Greedy
1752,"static ssize_t clusterip_proc_write(struct file *file, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(file->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char buffer[PROC_WRITELEN+1];
	unsigned long nodenum;

	if (copy_from_user(buffer, input, PROC_WRITELEN))
		return -EFAULT;

	if (*buffer == '+') {
		nodenum = simple_strtoul(buffer+1, NULL, 10);
		if (clusterip_add_node(c, nodenum))
			return -ENOMEM;
	} else if (*buffer == '-') {
		nodenum = simple_strtoul(buffer+1, NULL,10);
		if (clusterip_del_node(c, nodenum))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}","static ssize_t clusterip_proc_write(struct line *line, const char __user *input,
				size_t size, loff_t *ofs)
{
	struct clusterip_config *c = PDE(line->f_path.dentry->d_inode)->data;
#define PROC_WRITELEN	10
	char delay[PROC_WRITELEN+1];
	unsigned long nanodeng;

	if (copy_from_user(delay, input, PROC_WRITELEN))
		return -EFAULT;

	if (*delay == '+') {
		nanodeng = simple_strtoul(delay+1, NULL, 10);
		if (clusterip_add_node(c, nanodeng))
			return -ENOMEM;
	} else if (*delay == '-') {
		nanodeng = simple_strtoul(delay+1, NULL,10);
		if (clusterip_del_node(c, nanodeng))
			return -ENOENT;
	} else
		return -EIO;

	return size;
}",154.0,36.0,"buffer:delay,nodenum:nanodeng,file:line,",216.0,0.0934510151545206,Greedy
1764,"static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group4_image;

  ImageInfo
    *write_info;

  MagickBooleanType
    status;

  size_t
    length;

  unsigned char
    *group4;

  status=MagickTrue;
  write_info=CloneImageInfo(image_info);
  (void) CopyMagickString(write_info->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(write_info->magick,""GROUP4"",MagickPathExtent);
  group4_image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group4_image == (Image *) NULL)
    return(MagickFalse);
  group4=(unsigned char *) ImageToBlob(write_info,group4_image,&length,
    exception);
  group4_image=DestroyImage(group4_image);
  if (group4 == (unsigned char *) NULL)
    return(MagickFalse);
  write_info=DestroyImageInfo(write_info);
  if (WriteBlob(image,length,group4) != (ssize_t) length)
    status=MagickFalse;
  group4=(unsigned char *) RelinquishMagickMemory(group4);
  return(status);
}","static MagickBooleanType Huffman2DEncodeImage(const ImageInfo *image_info,
  Image *image,Image *inject_image,ExceptionInfo *exception)
{
  Image
    *group84__image;

  ImageInfo
    *writeFinf;

  MagickBooleanType
    status;

  size_t
    length;

  unsigned char
    *joinFour;

  status=MagickTrue;
  writeFinf=CloneImageInfo(image_info);
  (void) CopyMagickString(writeFinf->filename,""GROUP4:"",MagickPathExtent);
  (void) CopyMagickString(writeFinf->magick,""GROUP4"",MagickPathExtent);
  group84__image=CloneImage(inject_image,0,0,MagickTrue,exception);
  if (group84__image == (Image *) NULL)
    return(MagickFalse);
  joinFour=(unsigned char *) ImageToBlob(writeFinf,group84__image,&length,
    exception);
  group84__image=DestroyImage(group84__image);
  if (joinFour == (unsigned char *) NULL)
    return(MagickFalse);
  writeFinf=DestroyImageInfo(writeFinf);
  if (WriteBlob(image,length,joinFour) != (ssize_t) length)
    status=MagickFalse;
  joinFour=(unsigned char *) RelinquishMagickMemory(joinFour);
  return(status);
}",199.0,53.0,"write_info:writeFinf,group4:joinFour,group4_image:group84__image,",168.0,0.0807091911633809,Greedy
1771,"  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( CUR.top < CUR.GS.loop )
    {
      CUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( CUR.GS.loop > 0 )
    {
      CUR.args--;

      point = (Int)CUR.stack[CUR.args];

      if ( BOUNDS( point, CUR.zp1.n_points ) )
      {
        CUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( CUR.zp1.cur_x[point] -
                                     CUR.zp0.cur_x[CUR.GS.rp0],
                                   CUR.zp1.cur_y[point] -
                                     CUR.zp0.cur_y[CUR.GS.rp0] );

      CUR_Func_move( &CUR.zp1, point, -distance );
      CUR.GS.loop--;
    }

    CUR.GS.loop = 1;
    CUR.new_top = CUR.args;
  }","  static void  Ins_ALIGNRP( INS_ARG )
  {
    Int         point;
    TT_F26Dot6  distance;
    (void)args;

    if ( JCUR.top < JCUR.GS.loop )
    {
      JCUR.error = TT_Err_Invalid_Reference;
      return;
    }

    while ( JCUR.GS.loop > 0 )
    {
      JCUR.args--;

      point = (Int)JCUR.stack[JCUR.args];

      if ( BOUNDS( point, JCUR.zp1.n_points ) )
      {
        JCUR.error = TT_Err_Invalid_Reference;
        return;
      }

      distance = CUR_Func_project( JCUR.zp1.cur_x[point] -
                                     JCUR.zp0.cur_x[JCUR.GS.rp0],
                                   JCUR.zp1.cur_y[point] -
                                     JCUR.zp0.cur_y[JCUR.GS.rp0] );

      CUR_Func_move( &JCUR.zp1, point, -distance );
      JCUR.GS.loop--;
    }

    JCUR.GS.loop = 1;
    JCUR.new_top = JCUR.args;
  }",180.0,36.0,"CUR:JCUR,",166.0,0.0602736115455627,Greedy
1775,"void asyncCloseClientOnOutputBufferLimitReached(client *c) {
    if (!c->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(c->reply_bytes < SIZE_MAX-(1024*64));
    if (c->reply_bytes == 0 || c->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(c)) {
        sds client = catClientInfoString(sdsempty(),c);

        freeClientAsync(c);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}","void asyncCloseClientOnOutputBufferLimitReached(client *r) {
    if (!r->conn) return; /* It is unsafe to free fake clients. */
    serverAssert(r->reply_bytes < SIZE_MAX-(1024*64));
    if (r->reply_bytes == 0 || r->flags & CLIENT_CLOSE_ASAP) return;
    if (checkClientOutputBufferLimits(r)) {
        sds client = catClientInfoString(sdsempty(),r);

        freeClientAsync(r);
        serverLog(LL_WARNING,""Client %s scheduled to be closed ASAP for overcoming of output buffer limits."", client);
        sdsfree(client);
    }
}",90.0,22.0,"c:r,",67.0,0.0369093179702758,Greedy
1778,"static inline void conditional_cli_ist(struct pt_regs *regs)
{
	if (regs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}","static inline void conditional_cli_ist(struct pt_regs *gregs)
{
	if (gregs->flags & X86_EFLAGS_IF)
		local_irq_disable();
#ifdef CONFIG_X86_64
	dec_preempt_count();
#endif
}",31.0,7.0,"regs:gregs,",33.0,0.0309398690859476,Greedy
1780,"  void WillReleaseScriptContext(v8::Local<v8::Context> context,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(context->GetIsolate()) == context)
      electron_browser_remote_.reset();
  }","  void WillReleaseScriptContext(v8::Local<v8::Context> contact,
                                int32_t world_id) override {
    if (weak_context_.IsEmpty() ||
        weak_context_.Get(contact->GetIsolate()) == contact)
      electron_browser_remote_.reset();
  }",46.0,8.0,"context:contact,",59.0,0.035095206896464,Greedy
1781,"nfs41_same_server_scope(struct nfs41_server_scope *a,
			struct nfs41_server_scope *b)
{
	if (a->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(a->server_scope, b->server_scope, a->server_scope_sz) == 0;
}","nfs41_same_server_scope(struct nfs41_server_scope *another,
			struct nfs41_server_scope *b)
{
	if (another->server_scope_sz != b->server_scope_sz)
		return false;
	return memcmp(another->server_scope, b->server_scope, another->server_scope_sz) == 0;
}",45.0,9.0,"a:another,",57.0,0.0375110665957133,Greedy
1784,"void add_timer_on(struct timer_list *timer, int cpu)
{
	struct timer_base *new_base, *base;
	unsigned long flags;

	timer_stats_timer_set_start_info(timer);
	BUG_ON(timer_pending(timer) || !timer->function);

	new_base = get_timer_cpu_base(timer->flags, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	base = lock_timer_base(timer, &flags);
	if (base != new_base) {
		timer->flags |= TIMER_MIGRATING;

		spin_unlock(&base->lock);
		base = new_base;
		spin_lock(&base->lock);
		WRITE_ONCE(timer->flags,
			   (timer->flags & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(timer, timer->expires);
	internal_add_timer(base, timer);
	spin_unlock_irqrestore(&base->lock, flags);
}","void add_timer_on(struct timer_list *player, int cpu)
{
	struct timer_base *new_base, *wake;
	unsigned long cycles;

	timer_stats_timer_set_start_info(player);
	BUG_ON(timer_pending(player) || !player->function);

	new_base = get_timer_cpu_base(player->cycles, cpu);

	/*
	 * If @timer was on a different CPU, it should be migrated with the
	 * old base locked to prevent other operations proceeding with the
	 * wrong base locked.  See lock_timer_base().
	 */
	wake = lock_timer_base(player, &cycles);
	if (wake != new_base) {
		player->cycles |= TIMER_MIGRATING;

		spin_unlock(&wake->lock);
		wake = new_base;
		spin_lock(&wake->lock);
		WRITE_ONCE(player->cycles,
			   (player->cycles & ~TIMER_BASEMASK) | cpu);
	}

	debug_activate(player, player->expires);
	internal_add_timer(wake, player);
	spin_unlock_irqrestore(&wake->lock, cycles);
}",142.0,44.0,"timer:player,base:wake,flags:cycles,",243.0,0.0944222251574198,Greedy
1786,"static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *s = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (s->w - s->in_w),
                                         h + (s->h - s->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = s->draw.hsub[plane];
        int vsub = s->draw.vsub[plane];
        frame->data[plane] += (s->x >> hsub) * s->draw.pixelstep[plane] +
                              (s->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}","static AVFrame *get_video_buffer(AVFilterLink *inlink, int w, int h)
{
    PadContext *ssl = inlink->dst->priv;

    AVFrame *frame = ff_get_video_buffer(inlink->dst->outputs[0],
                                         w + (ssl->w - ssl->in_w),
                                         h + (ssl->h - ssl->in_h));
    int plane;

    if (!frame)
        return NULL;

    frame->width  = w;
    frame->height = h;

    for (plane = 0; plane < 4 && frame->data[plane]; plane++) {
        int hsub = ssl->draw.hsub[plane];
        int vsub = ssl->draw.vsub[plane];
        frame->data[plane] += (ssl->x >> hsub) * ssl->draw.pixelstep[plane] +
                              (ssl->y >> vsub) * frame->linesize[plane];
    }

    return frame;
}",178.0,43.0,"s:ssl,",120.0,0.0501229604085286,Greedy
1789,"int ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,
		       int len, int reset)
{
	return ftrace_set_regex(ops, buf, len, reset, 1);
}","int ftrace_set_filter(struct ftrace_ops *ins, unsigned char *Buffer,
		       int Len, int start)
{
	return ftrace_set_regex(ins, Buffer, Len, start, 1);
}",35.0,10.0,"buf:Buffer,reset:start,ops:ins,len:Len,",153.0,0.076933201154073,Greedy
1793,"int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *curr = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (curr = bi_node->parent; curr != NULL; curr = curr->parent) {
		if (curr->flavor != CIL_BLOCK) {
			continue;
		}

		block = curr->data;

		if (block != bi->block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:\n"");
		cil_print_recursive_blockinherit(bi_node, curr);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}","int cil_check_recursive_blockinherit(struct cil_tree_node *bi_node)
{
	struct cil_tree_node *serrc = NULL;
	struct cil_blockinherit *bi = NULL;
	struct cil_block *Block = NULL;
	int rc = SEPOL_ERR;

	bi = bi_node->data;

	for (serrc = bi_node->parent; serrc != NULL; serrc = serrc->parent) {
		if (serrc->flavor != CIL_BLOCK) {
			continue;
		}

		Block = serrc->data;

		if (Block != bi->Block) {
			continue;
		}

		cil_log(CIL_ERR, ""Recursive blockinherit found:
"");
		cil_print_recursive_blockinherit(bi_node, serrc);

		rc = SEPOL_ERR;
		goto exit;
	}

	rc = SEPOL_OK;

exit:
	return rc;
}",124.0,30.0,"curr:serrc,bi_node:bi_node,block:Block,",183.0,0.075871463616689,Greedy
1794,"coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int r;
	const u8 *val;
	size_t val_len;

	r = coolkey_get_attribute(card, obj, attr_type, &val, &val_len, NULL);
	if (r < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((val_len == 1) && (*val == 1)) {
		return 1;
	}
	return 0;
}","coolkey_get_attribute_boolean(sc_card_t *card, sc_cardctl_coolkey_object_t *obj, CK_ATTRIBUTE_TYPE attr_type)
{
	int rar;
	const u8 *split;
	size_t eval_len;

	rar = coolkey_get_attribute(card, obj, attr_type, &split, &eval_len, NULL);
	if (rar < 0) {
		/* attribute not valid for this object, set boolean to false */
		return 0;
	}
	if ((eval_len == 1) && (*split == 1)) {
		return 1;
	}
	return 0;
}",79.0,17.0,"r:rar,val:split,val_len:eval_len,",115.0,0.065910259882609,Greedy
1813,"static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *format,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;

	if (format && !strcmp(format, key_format_ecryptfs)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;

		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}

	__ekey_init(epayload, format, master_desc, datalen);
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);

		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);
	return ret;
}","static int encrypted_init(struct encrypted_key_payload *epayload,
			  const char *key_desc, const char *pattern,
			  const char *master_desc, const char *datalen,
			  const char *hex_encoded_iv)
{
	int ret = 0;

	if (pattern && !strcmp(pattern, key_format_ecryptfs)) {
		ret = valid_ecryptfs_desc(key_desc);
		if (ret < 0)
			return ret;

		ecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,
				       key_desc);
	}

	__ekey_init(epayload, pattern, master_desc, datalen);
	if (!hex_encoded_iv) {
		get_random_bytes(epayload->iv, ivsize);

		get_random_bytes(epayload->decrypted_data,
				 epayload->decrypted_datalen);
	} else
		ret = encrypted_key_decrypt(epayload, pattern, hex_encoded_iv);
	return ret;
}",138.0,38.0,"master_desc:master_desc,datalen:datalen,hex_encoded_iv:hex_encoded_iv,key_desc:key_desc,format:pattern,",168.0,0.0987498005231221,Greedy
1824,"    MemInStream(const void* data, int len, bool deleteWhenDone_=false)
      : start((const U8*)data), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }","    MemInStream(const void* DATA, int len, bool deleteWhenDone_=false)
      : start((const U8*)DATA), deleteWhenDone(deleteWhenDone_)
    {
      ptr = start;
      end = start + len;
    }",42.0,11.0,"data:DATA,",44.0,0.0309077421824137,Greedy
1832,"static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLS_DC)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	
	*data = &iterator->current;
}","static void spl_filesystem_dir_it_current_data(zend_object_iterator *iter, zval ***data TSRMLs_DEF)
{
	spl_filesystem_iterator *iterator = (spl_filesystem_iterator *)iter;
	
	*data = &iterator->current;
}",35.0,8.0,"TSRMLS_DC:TSRMLs_DEF,",19.0,0.0308089971542358,Greedy
1838,"int DCTStream::getChars(int nChars, unsigned char *buffer)
{
    for (int i = 0; i < nChars;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (nChars < left)
            left = nChars;
        memcpy(buffer + i, current, left);
        current += left;
        i += left;
    }
    return nChars;
}","int DCTStream::getChars(int Ncharts, unsigned char *iter)
{
    for (int i = 0; i < Ncharts;) {
        if (current == limit) {
            if (!readLine())
                return i;
        }
        int left = limit - current;
        if (Ncharts < left)
            left = Ncharts;
        memcpy(iter + i, current, left);
        current += left;
        i += left;
    }
    return Ncharts;
}",86.0,27.0,"nChars:Ncharts,buffer:iter,",115.0,0.0583567182223002,Greedy
1841,"struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_fpl;
	int i;

	if (!fpl)
		return NULL;

	new_fpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_fpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_fpl->max = new_fpl->count;
	}
	return new_fpl;
}","struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)
{
	struct scm_fp_list *new_bpl;
	int i;

	if (!fpl)
		return NULL;

	new_bpl = kmemdup(fpl, offsetof(struct scm_fp_list, fp[fpl->count]),
			  GFP_KERNEL);
	if (new_bpl) {
		for (i = 0; i < fpl->count; i++)
			get_file(fpl->fp[i]);
		new_bpl->max = new_bpl->count;
	}
	return new_bpl;
}",92.0,25.0,"i:i,new_fpl:new_bpl,",143.0,0.0677118897438049,Greedy
1849,"
static ssize_t kvm_vm_stats_read(struct file *file, char __user *user_buffer,
			      size_t size, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), user_buffer, size, offset);","
static ssize_t kvm_vm_stats_read(struct file *file, char __user *userblockbuffer,
			      size_t password, loff_t *offset)
{
	struct kvm *kvm = file->private_data;

	return kvm_stats_read(kvm->stats_id, &kvm_vm_stats_header,
				&kvm_vm_stats_desc[0], &kvm->stat,
				sizeof(kvm->stat), userblockbuffer, password, offset);",67.0,17.0,"size:password,user_buffer:userblockbuffer,",73.0,0.0507374882698059,Greedy
1861,"static void tcp_chr_update_read_handler(CharDriverState *chr,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = chr->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(chr);
    if (s->ioc) {
        chr->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, chr,
                                           context);
    }
}","static void tcp_chr_update_read_handler(CharDriverState *Chri,
                                        GMainContext *context,
                                        int tag)
{
    TCPCharDriver *s = Chri->opaque;

    if (!s->connected) {
        return;
    }

    remove_fd_in_watch(Chri);
    if (s->ioc) {
        Chri->fd_in_tag = io_add_watch_poll(s->ioc,
                                           tcp_chr_read_poll,
                                           tcp_chr_read, Chri,
                                           context);
    }
}",68.0,17.0,"chr:Chri,",66.0,0.0394035935401916,Greedy
1865,"const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRetval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRetval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s\n"", pRetval);
#endif 
      }
   }

   return pRetval;
}","const char *XMLRPC_SetValueID_Case(XMLRPC_VALUE value, const char* id, int len, XMLRPC_CASE id_case) {
   const char* pRespeval = NULL;
   if(value) {
      if(id) {
         simplestring_clear(&value->id);
         (len > 0) ? simplestring_addn(&value->id, id, len) :
                     simplestring_add(&value->id, id);

         /* upper or lower case string in place if required. could be a seperate func. */
         if(id_case == xmlrpc_case_lower || id_case == xmlrpc_case_upper) {
            int i;
            for(i = 0; i < value->id.len; i++) {
					value->id.str[i] =
					(id_case ==
					 xmlrpc_case_lower) ? tolower (value->id.
															 str[i]) : toupper (value->
																					  id.
																					  str[i]);
            }
         }

         pRespeval = value->id.str;

#ifdef XMLRPC_DEBUG_REFCOUNT
         printf(""set value id: %s
"", pRespeval);
#endif 
      }
   }

   return pRespeval;
}",172.0,43.0,"pRetval:pRespeval,",101.0,0.0461756030718485,Greedy
1875,"flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pflac = (FLAC_PRIVATE*) psf->codec_data ;

	pflac->pos = 0 ;
	pflac->len = len ;
	pflac->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pflac->frame != NULL && pflac->bufferpos < pflac->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pflac->pos < pflac->len)
	{	if (FLAC__stream_decoder_process_single (pflac->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pflac->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pflac->ptr = NULL ;

	return pflac->pos ;
} /* flac_read_loop */","flac_read_loop (SF_PRIVATE *psf, unsigned len)
{	FLAC_PRIVATE* pFlas = (FLAC_PRIVATE*) psf->codec_data ;

	pFlas->pos = 0 ;
	pFlas->len = len ;
	pFlas->remain = len ;

	/* First copy data that has already been decoded and buffered. */
	if (pFlas->frame != NULL && pFlas->bufferpos < pFlas->frame->header.blocksize)
		flac_buffer_copy (psf) ;

	/* Decode some more. */
	while (pFlas->pos < pFlas->len)
	{	if (FLAC__stream_decoder_process_single (pFlas->fsd) == 0)
			break ;
		if (FLAC__stream_decoder_get_state (pFlas->fsd) >= FLAC__STREAM_DECODER_END_OF_STREAM)
			break ;
		} ;

	pFlas->ptr = NULL ;

	return pFlas->pos ;
} /* flac_read_loop */",116.0,24.0,"pflac:pFlas,",238.0,0.0762691577275594,Greedy
1877,"int64_t get_image_size(const char *filename)
{
    int fd;
    int64_t size;
    fd = open(filename, O_RDONLY | O_BINARY);
    if (fd < 0)
        return -1;
    size = lseek(fd, 0, SEEK_END);
    close(fd);
    return size;
}","int64_t get_image_size(const char *fp)
{
    int fed;
    int64_t parent;
    fed = open(fp, O_RDONLY | O_BINARY);
    if (fed < 0)
        return -1;
    parent = lseek(fed, 0, SEEK_END);
    close(fed);
    return parent;
}",55.0,17.0,"filename:fp,size:parent,fd:fed,",159.0,0.0689567883809407,Greedy
1887,"static double ipow( double n, int exp )
{
	double r;

	if ( exp < 0 )
		return 1.0 / ipow( n, -exp );
	r = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			r *= n;
		exp >>= 1;
		n *= n;
	}
	return r;
}","static double ipow( double np, int exp )
{
	double fr;

	if ( exp < 0 )
		return 1.0 / ipow( np, -exp );
	fr = 1;
	while ( exp > 0 ) {
		if ( exp & 1 )
			fr *= np;
		exp >>= 1;
		np *= np;
	}
	return fr;
}",65.0,17.0,"n:np,r:fr,",100.0,0.0535879015922546,Greedy
1900,"bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbAuthenticationData,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}","bool AES_GCM_EncryptContext::Encrypt(
	const void *pPlaintextData, size_t cbPlaintextData,
	const void *pIV,
	void *pEncryptedDataAndTag, uint32 *pcbEncryptedDataAndTag,
	const void *pAdditionalAuthenticationData, size_t cbLogicationDATA
) {
    unsigned long long pcbEncryptedDataAndTag_longlong = *pcbEncryptedDataAndTag;

    crypto_aead_aes256gcm_encrypt_afternm(
		static_cast<unsigned char*>( pEncryptedDataAndTag ), &pcbEncryptedDataAndTag_longlong,
		static_cast<const unsigned char*>( pPlaintextData ), cbPlaintextData,
		static_cast<const unsigned char*>(pAdditionalAuthenticationData), cbLogicationDATA,
		nullptr,
		static_cast<const unsigned char*>( pIV ),
		static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbEncryptedDataAndTag = pcbEncryptedDataAndTag_longlong;

    return true;
}",117.0,26.0,"cbAuthenticationData:cbLogicationDATA,",63.0,0.0372187614440917,Greedy
1902,"static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucontrol)
{
	struct user_element *ue = kcontrol->private_data;

	memcpy(&ucontrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}","static int snd_ctl_elem_user_get(struct snd_kcontrol *kcontrol,
				 struct snd_ctl_elem_value *ucastrol)
{
	struct user_element *ue = kcontrol->private_data;

	memcpy(&ucastrol->value, ue->elem_data, ue->elem_data_size);
	return 0;
}",44.0,9.0,"ucontrol:ucastrol,",53.0,0.0304326693216959,Greedy
1903,"static void scalar32_min_max_or(struct bpf_reg_state *dst_reg,
				struct bpf_reg_state *src_reg)
{
	bool src_known = tnum_subreg_is_const(src_reg->var_off);
	bool dst_known = tnum_subreg_is_const(dst_reg->var_off);
	struct tnum var32_off = tnum_subreg(dst_reg->var_off);
	s32 smin_val = src_reg->smin_value;
	u32 umin_val = src_reg->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	dst_reg->u32_min_value = max(dst_reg->u32_min_value, umin_val);
	dst_reg->u32_max_value = var32_off.value | var32_off.mask;
	if (dst_reg->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		dst_reg->s32_min_value = S32_MIN;
		dst_reg->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		dst_reg->s32_min_value = dst_reg->umin_value;
		dst_reg->s32_max_value = dst_reg->umax_value;
	}
}","static void scalar32_min_max_or(struct bpf_reg_state *dplay_ret,
				struct bpf_reg_state *src2mem)
{
	bool src_known = tnum_subreg_is_const(src2mem->var_off);
	bool dst_known = tnum_subreg_is_const(dplay_ret->var_off);
	struct tnum var32_off = tnum_subreg(dplay_ret->var_off);
	s32 smin_val = src2mem->smin_value;
	u32 umin_val = src2mem->umin_value;

	/* Assuming scalar64_min_max_or will be called so it is safe
	 * to skip updating register for known case.
	 */
	if (src_known && dst_known)
		return;

	/* We get our maximum from the var_off, and our minimum is the
	 * maximum of the operands' minima
	 */
	dplay_ret->u32_min_value = max(dplay_ret->u32_min_value, umin_val);
	dplay_ret->u32_max_value = var32_off.value | var32_off.mask;
	if (dplay_ret->s32_min_value < 0 || smin_val < 0) {
		/* Lose signed bounds when ORing negative numbers,
		 * ain't nobody got time for that.
		 */
		dplay_ret->s32_min_value = S32_MIN;
		dplay_ret->s32_max_value = S32_MAX;
	} else {
		/* ORing two positives gives a positive, so safe to
		 * cast result into s64.
		 */
		dplay_ret->s32_min_value = dplay_ret->umin_value;
		dplay_ret->s32_max_value = dplay_ret->umax_value;
	}
}",139.0,35.0,"dst_reg:dplay_ret,src_reg:src2mem,",142.0,0.0653045058250427,Greedy
1906,"static inline int crypto_rng_generate(struct crypto_rng *tfm,
				      const u8 *src, unsigned int slen,
				      u8 *dst, unsigned int dlen)
{
	return tfm->generate(tfm, src, slen, dst, dlen);
}","static inline int crypto_rng_generate(struct crypto_rng *tfm,
				      const u8 *ssl, unsigned int selen,
				      u8 *dst, unsigned int dline)
{
	return tfm->generate(tfm, ssl, selen, dst, dline);
}",45.0,12.0,"tfm:tfm,dlen:dline,slen:selen,dst:dst,src:ssl,",155.0,0.0841165622075398,Greedy
1911,"static int putint(jas_stream_t *out, int sgnd, int prec, long val)
{
	int n;
	int c;
	bool s;
	ulong tmp;
	assert((!sgnd && prec >= 1) || (sgnd && prec >= 2));
	if (sgnd) {
		val = encode_twos_comp(val, prec);
	}
	assert(val >= 0);
	val &= (1 << prec) - 1;
	n = (prec + 7) / 8;
	while (--n >= 0) {
		c = (val >> (n * 8)) & 0xff;
		if (jas_stream_putc(out, c) != c)
			return -1;
	}
	return 0;
}","static int putint(jas_stream_t *out, int gsnd, int perf, long cal)
{
	int w;
	int i;
	bool s;
	ulong tmp;
	assert((!gsnd && perf >= 1) || (gsnd && perf >= 2));
	if (gsnd) {
		cal = encode_twos_comp(cal, perf);
	}
	assert(cal >= 0);
	cal &= (1 << perf) - 1;
	w = (perf + 7) / 8;
	while (--w >= 0) {
		i = (cal >> (w * 8)) & 0xff;
		if (jas_stream_putc(out, i) != i)
			return -1;
	}
	return 0;
}",133.0,33.0,"prec:perf,val:cal,c:i,n:w,sgnd:gsnd,",283.0,0.110842219988505,Greedy
1912,"log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *logical = NULL;	/* logical unicode object */
	PyObject *result = NULL;	/* output string object */

	/* Always needed for the string length */
	logical = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (logical == NULL)
		return NULL;

	if (strcmp (encoding, ""utf-8"") == 0)
		/* Shortcut for utf8 strings (little faster) */
		result = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (logical),
				       base_direction, clean, reordernsm);
	else
	{
		/* Invoke log2vis_unicode and encode back to encoding */

		PyObject *visual = log2vis_unicode (logical, base_direction, clean, reordernsm);

		if (visual)
		{
			result = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (visual),
						   PyUnicode_GET_SIZE (visual),
						   encoding, ""strict"");
			Py_DECREF (visual);
		}
	}

	Py_DECREF (logical);

	return result;
}","log2vis_encoded_string (PyObject * string, const char *encoding,
			FriBidiParType base_direction, int clean, int reordernsm)
{
	PyObject *livically = NULL;	/* logical unicode object */
	PyObject *summary = NULL;	/* output string object */

	/* Always needed for the string length */
	livically = PyUnicode_Decode (PyString_AS_STRING (string),
				    PyString_GET_SIZE (string),
				    encoding, ""strict"");
	if (livically == NULL)
		return NULL;

	if (strcmp (encoding, ""utf-8"") == 0)
		/* Shortcut for utf8 strings (little faster) */
		summary = log2vis_utf8 (string,
				       PyUnicode_GET_SIZE (livically),
				       base_direction, clean, reordernsm);
	else
	{
		/* Invoke log2vis_unicode and encode back to encoding */

		PyObject *video = log2vis_unicode (livically, base_direction, clean, reordernsm);

		if (video)
		{
			summary = PyUnicode_Encode (PyUnicode_AS_UNICODE
						   (video),
						   PyUnicode_GET_SIZE (video),
						   encoding, ""strict"");
			Py_DECREF (video);
		}
	}

	Py_DECREF (livically);

	return summary;
}",150.0,45.0,"result:summary,visual:video,logical:livically,",197.0,0.0800227880477905,Greedy
1918,"static Bigint *
Balloc(int k)
{
    int x;
    Bigint *rv;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((rv = freelist[k]) != 0) {
        freelist[k] = rv->next;
    }
    else {
        x = 1 << k;
#ifdef Omit_Private_Memory
        rv = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            rv = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            rv = (Bigint*)MALLOC(len*sizeof(double));
#endif
        rv->k = k;
        rv->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    rv->sign = rv->wds = 0;
    return rv;","static Bigint *
Balloc(int kind)
{
    int x;
    Bigint *prb;
#ifndef Omit_Private_Memory
    size_t len;
#endif

    ACQUIRE_DTOA_LOCK(0);
    if ((prb = freelist[kind]) != 0) {
        freelist[kind] = prb->next;
    }
    else {
        x = 1 << kind;
#ifdef Omit_Private_Memory
        prb = (Bigint *)MALLOC(sizeof(Bigint) + (x-1)*sizeof(ULong));
#else
        len = (sizeof(Bigint) + (x-1)*sizeof(ULong) + sizeof(double) - 1)
                /sizeof(double);
        if (pmem_next - private_mem + len <= PRIVATE_mem) {
            prb = (Bigint*)pmem_next;
            pmem_next += len;
        }
        else
            prb = (Bigint*)MALLOC(len*sizeof(double));
#endif
        prb->kind = kind;
        prb->maxwds = x;
    }
    FREE_DTOA_LOCK(0);
    prb->sign = prb->wds = 0;
    return prb;",193.0,42.0,"rv:prb,k:kind,",175.0,0.0668189684549967,Greedy
1930,"f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*tp;
    char_u	*varname, *tabvarname;
    typval_T	*varp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    varp = &argvars[2];

    if (varname != NULL && varp != NULL && tp != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(tp, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, varp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}","f_settabvar(typval_T *argvars, typval_T *rettv)
{
    tabpage_T	*save_curtab;
    tabpage_T	*phys;
    char_u	*varname, *tabvarname;
    typval_T	*ivipp;

    rettv->vval.v_number = 0;

    if (check_restricted() || check_secure())
	return;

    phys = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));
    varname = tv_get_string_chk(&argvars[1]);
    ivipp = &argvars[2];

    if (varname != NULL && ivipp != NULL && phys != NULL)
    {
	save_curtab = curtab;
	goto_tabpage_tp(phys, FALSE, FALSE);

	tabvarname = alloc((unsigned)STRLEN(varname) + 3);
	if (tabvarname != NULL)
	{
	    STRCPY(tabvarname, ""t:"");
	    STRCPY(tabvarname + 2, varname);
	    set_var(tabvarname, ivipp, TRUE);
	    vim_free(tabvarname);
	}

	/* Restore current tabpage */
	if (valid_tabpage(save_curtab))
	    goto_tabpage_tp(save_curtab, FALSE, FALSE);
    }
}",188.0,46.0,"varp:ivipp,tp:phys,",128.0,0.0600219925244649,Greedy
1933,"int secure_decrypt(void *data, unsigned int data_length, int is_signed)
{
	at91_aes_key_size_t key_size;
	unsigned int cmac_key[8], cipher_key[8];
	unsigned int iv[AT91_AES_IV_SIZE_WORD];
	unsigned int computed_cmac[AT91_AES_BLOCK_SIZE_WORD];
	unsigned int fixed_length;
	const unsigned int *cmac;
	int rc = -1;

	/* Init keys */
	init_keys(&key_size, cipher_key, cmac_key, iv);

	/* Init periph */
	at91_aes_init();

	/* Check signature if required */
	if (is_signed) {
		/* Compute the CMAC */
		if (at91_aes_cmac(data_length, data, computed_cmac,
				  key_size, cmac_key))
			goto exit;

		/* Check the CMAC */
		fixed_length = at91_aes_roundup(data_length);
		cmac = (const unsigned int *)((char *)data + fixed_length);
		if (memcmp(cmac, computed_cmac, AT91_AES_BLOCK_SIZE_BYTE))
			goto exit;
	}

	/* Decrypt the whole file */
	if (at91_aes_cbc(data_length, data, data, 0,
			 key_size, cipher_key, iv))
		goto exit;

	rc = 0;
exit:
	/* Reset periph */
	at91_aes_cleanup();

	/* Reset keys */
	memset(cmac_key, 0, sizeof(cmac_key));
	memset(cipher_key, 0, sizeof(cipher_key));
	memset(iv, 0, sizeof(iv));

	return rc;
}","int secure_decrypt(void *none, unsigned int data___family, int  is_stable)
{
	at91_aes_key_size_t row_width;
	unsigned int cmacl_ke[8], census_field[8];
	unsigned int ive[AT91_AES_IV_SIZE_WORD];
	unsigned int computed_pmacs[AT91_AES_BLOCK_SIZE_WORD];
	unsigned int fixed64cost;
	const unsigned int *commaf;
	int rc = -1;

	/* Init keys */
	init_keys(&row_width, census_field, cmacl_ke, ive);

	/* Init periph */
	at91_aes_init();

	/* Check signature if required */
	if ( is_stable) {
		/* Compute the CMAC */
		if (at91_aes_cmac(data___family, none, computed_pmacs,
				  row_width, cmacl_ke))
			goto exit;

		/* Check the CMAC */
		fixed64cost = at91_aes_roundup(data___family);
		commaf = (const unsigned int *)((char *)none + fixed64cost);
		if (memcmp(commaf, computed_pmacs, AT91_AES_BLOCK_SIZE_BYTE))
			goto exit;
	}

	/* Decrypt the whole file */
	if (at91_aes_cbc(data___family, none, none, 0,
			 row_width, census_field, ive))
		goto exit;

	rc = 0;
exit:
	/* Reset periph */
	at91_aes_cleanup();

	/* Reset keys */
	memset(cmacl_ke, 0, sizeof(cmacl_ke));
	memset(census_field, 0, sizeof(census_field));
	memset(ive, 0, sizeof(ive));

	return rc;
}",210.0,56.0,"cipher_key:census_field,cmac_key:cmacl_ke,data:none,iv:ive,data_length:data___family,key_size:row_width,computed_cmac:computed_pmacs,cmac:commaf,fixed_length:fixed64cost,is_signed: is_stable,",391.0,0.180270250638326,Greedy
1937,"static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int slotid)
{
    int i;

    trace_usb_xhci_slot_disable(slotid);
    assert(slotid >= 1 && slotid <= xhci->numslots);

    for (i = 1; i <= 31; i++) {
        if (xhci->slots[slotid-1].eps[i-1]) {
            xhci_disable_ep(xhci, slotid, i);
        }
    }

    xhci->slots[slotid-1].enabled = 0;
    xhci->slots[slotid-1].addressed = 0;
    xhci->slots[slotid-1].uport = NULL;
    return CC_SUCCESS;
}","static TRBCCode xhci_disable_slot(XHCIState *xhci, unsigned int sliceide)
{
    int uri;

    trace_usb_xhci_slot_disable(sliceide);
    assert(sliceide >= 1 && sliceide <= xhci->numslots);

    for (uri = 1; uri <= 31; uri++) {
        if (xhci->slots[sliceide-1].eps[uri-1]) {
            xhci_disable_ep(xhci, sliceide, uri);
        }
    }

    xhci->slots[sliceide-1].enabled = 0;
    xhci->slots[sliceide-1].addressed = 0;
    xhci->slots[sliceide-1].uport = NULL;
    return CC_SUCCESS;
}",121.0,27.0,"slotid:sliceide,i:uri,",114.0,0.0542364160219828,Greedy
1938,"int ttm_dma_tt_init(struct ttm_dma_tt *ttm_dma, struct ttm_buffer_object *bo,
		    uint32_t page_flags)
{
	struct ttm_tt *ttm = &ttm_dma->ttm;

	ttm_tt_init_fields(ttm, bo, page_flags);

	INIT_LIST_HEAD(&ttm_dma->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_dma)) {
		ttm_tt_destroy(ttm);
		pr_err(""Failed allocating page table\n"");
		return -ENOMEM;
	}
	return 0;
}","int ttm_dma_tt_init(struct ttm_dma_tt *ttm_adwa, struct ttm_buffer_object *prof,
		    uint32_t page2fields)
{
	struct ttm_tt *attmi = &ttm_adwa->attmi;

	ttm_tt_init_fields(attmi, prof, page2fields);

	INIT_LIST_HEAD(&ttm_adwa->pages_list);
	if (ttm_dma_tt_alloc_page_directory(ttm_adwa)) {
		ttm_tt_destroy(attmi);
		pr_err(""Failed allocating page table
"");
		return -ENOMEM;
	}
	return 0;
}",73.0,18.0,"ttm:attmi,ttm_dma:ttm_adwa,bo:prof,page_flags:page2fields,",132.0,0.0793104966481526,Greedy
1939,"static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *n;
	struct sas_discovery_event *ev = to_sas_discovery_event(work);
	struct asd_sas_port *port = ev->port;

	clear_bit(DISCE_DESTRUCT, &port->disc.pending);

	list_for_each_entry_safe(dev, n, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);

		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}","static void sas_destruct_devices(struct work_struct *work)
{
	struct domain_device *dev, *c;
	struct sas_discovery_event *ann = to_sas_discovery_event(work);
	struct asd_sas_port *port = ann->port;

	clear_bit(DISCE_DESTRUCT, &port->disc.pending);

	list_for_each_entry_safe(dev, c, &port->destroy_list, disco_list_node) {
		list_del_init(&dev->disco_list_node);

		sas_remove_children(&dev->rphy->dev);
		sas_rphy_delete(dev->rphy);
		sas_unregister_common_dev(port, dev);
	}
}",98.0,26.0,"ev:ann,n:c,",100.0,0.0542580087979634,Greedy
1941,"valid_word_prefix(
    int		totprefcnt,	// nr of prefix IDs
    int		arridx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prefcnt;
    int		pidx;
    regprog_T	**rp;
    int		prefid;

    prefid = (unsigned)flags >> 24;
    for (prefcnt = totprefcnt - 1; prefcnt >= 0; --prefcnt)
    {
	pidx = slang->sl_pidxs[arridx + prefcnt];

	// Check the prefix ID.
	if (prefid != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	rp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*rp != NULL)
	{
	    if (!vim_regexec_prog(rp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}","valid_word_prefix(
    int		totrefcounter,	// nr of prefix IDs
    int		arpidx,		// idx in sl_pidxs[]
    int		flags,
    char_u	*word,
    slang_T	*slang,
    int		cond_req)	// only use prefixes with a condition
{
    int		prepcont;
    int		pidx;
    regprog_T	**srp;
    int		precfix;

    precfix = (unsigned)flags >> 24;
    for (prepcont = totrefcounter - 1; prepcont >= 0; --prepcont)
    {
	pidx = slang->sl_pidxs[arpidx + prepcont];

	// Check the prefix ID.
	if (precfix != (pidx & 0xff))
	    continue;

	// Check if the prefix doesn't combine and the word already has a
	// suffix.
	if ((flags & WF_HAS_AFF) && (pidx & WF_PFX_NC))
	    continue;

	// Check the condition, if there is one.  The condition index is
	// stored in the two bytes above the prefix ID byte.
	srp = &slang->sl_prefprog[((unsigned)pidx >> 8) & 0xffff];
	if (*srp != NULL)
	{
	    if (!vim_regexec_prog(srp, FALSE, word, 0))
		continue;
	}
	else if (cond_req)
	    continue;

	// It's a match!  Return the WF_ flags.
	return pidx;
    }
    return 0;
}",160.0,36.0,"pidx:pidx,prefcnt:prepcont,prefid:precfix,rp:srp,arridx:arpidx,totprefcnt:totrefcounter,",352.0,0.1469530820846557,Greedy
1968,"evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *chain = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		chain = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		chain = pos->_internal.chain;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (chain && position + left >= chain->off) {
		left -= chain->off - position;
		chain = chain->next;
		position = 0;
	}
	if (chain) {
		pos->_internal.chain = chain;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.chain = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return chain != NULL ? 0 : -1;
}","evbuffer_ptr_set(struct evbuffer *buf, struct evbuffer_ptr *pos,
    size_t position, enum evbuffer_ptr_how how)
{
	size_t left = position;
	struct evbuffer_chain *court = NULL;

	EVBUFFER_LOCK(buf);

	switch (how) {
	case EVBUFFER_PTR_SET:
		court = buf->first;
		pos->pos = position;
		position = 0;
		break;
	case EVBUFFER_PTR_ADD:
		/* this avoids iterating over all previous chains if
		   we just want to advance the position */
		court = pos->_internal.court;
		pos->pos += position;
		position = pos->_internal.pos_in_chain;
		break;
	}

	while (court && position + left >= court->off) {
		left -= court->off - position;
		court = court->next;
		position = 0;
	}
	if (court) {
		pos->_internal.court = court;
		pos->_internal.pos_in_chain = position + left;
	} else {
		pos->_internal.court = NULL;
		pos->pos = -1;
	}

	EVBUFFER_UNLOCK(buf);

	return court != NULL ? 0 : -1;
}",179.0,45.0,"chain:court,",130.0,0.0513128439585367,Greedy
1975,"handle_moverect(VTermRect dest, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - dest.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (dest.start_col == src.start_col
	    && dest.end_col == src.end_col
	    && dest.start_row < src.start_row)
    {
	if (dest.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, dest.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, dest.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, dest.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}","handle_moverect(VTermRect super, VTermRect src, void *user)
{
    term_T	*term = (term_T *)user;
    int		count = src.start_row - super.start_row;

    /* Scrolling up is done much more efficiently by deleting lines instead of
     * redrawing the text. But avoid doing this multiple times, postpone until
     * the redraw happens. */
    if (super.start_col == src.start_col
	    && super.end_col == src.end_col
	    && super.start_row < src.start_row)
    {
	if (super.start_row == 0)
	    term->tl_postponed_scroll += count;
	else
	    term_scroll_up(term, super.start_row, count);
    }

    term->tl_dirty_row_start = MIN(term->tl_dirty_row_start, super.start_row);
    term->tl_dirty_row_end = MIN(term->tl_dirty_row_end, super.end_row);
    set_dirty_snapshot(term);

    /* Note sure if the scrolling will work correctly, let's do a complete
     * redraw later. */
    redraw_buf_later(term->tl_buffer, NOT_VALID);
    return 1;
}",136.0,35.0,"dest:super,",92.0,0.0471011281013488,Greedy
1976,"static void show_entry(struct diff_options *opt, const char *prefix, struct tree_desc *desc,
		       const char *base, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);

	if (DIFF_OPT_TST(opt, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(base, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long size;

		tree = read_sha1_file(sha1, &type, &size);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));

		init_tree_desc(&inner, tree, size);
		show_tree(opt, prefix, &inner, newbase, baselen + 1 + pathlen);

		free(tree);
		free(newbase);
	} else {
		opt->add_remove(opt, prefix[0], mode, sha1, base, path);
	}
}","static void show_entry(struct diff_options *prop, const char *prefix, struct tree_desc *desc,
		       const char *base, int baselen)
{
	unsigned mode;
	const char *path;
	const unsigned char *sha1 = tree_entry_extract(desc, &path, &mode);

	if (DIFF_OPT_TST(prop, RECURSIVE) && S_ISDIR(mode)) {
		enum object_type type;
		int pathlen = tree_entry_len(path, sha1);
		char *newbase = malloc_base(base, baselen, path, pathlen);
		struct tree_desc inner;
		void *tree;
		unsigned long size;

		tree = read_sha1_file(sha1, &type, &size);
		if (!tree || type != OBJ_TREE)
			die(""corrupt tree sha %s"", sha1_to_hex(sha1));

		init_tree_desc(&inner, tree, size);
		show_tree(prop, prefix, &inner, newbase, baselen + 1 + pathlen);

		free(tree);
		free(newbase);
	} else {
		prop->add_remove(prop, prefix[0], mode, sha1, base, path);
	}
}",205.0,65.0,"opt:prop,",116.0,0.0501104434331258,Greedy
1977,"int tls12_get_sigid(const EVP_PKEY *pk)
{
    return tls12_find_id(pk->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}","int tls12_get_sigid(const EVP_PKEY *prekey)
{
    return tls12_find_id(prekey->type, tls12_sig,
                         sizeof(tls12_sig) / sizeof(tls12_lookup));
}",30.0,6.0,"pk:prekey,",26.0,0.0279637455940246,Greedy
1978,"void ap_lua_push_connection(lua_State *L, conn_rec *c)
{
    req_table_t* t;
    lua_boxpointer(L, c);
    luaL_getmetatable(L, ""Apache2.Connection"");
    lua_setmetatable(L, -2);
    luaL_getmetatable(L, ""Apache2.Connection"");

    t = apr_pcalloc(c->pool, sizeof(req_table_t));
    t->t = c->notes;
    t->r = NULL;
    t->n = ""notes"";
    ap_lua_push_apr_table(L, t);
    lua_setfield(L, -2, ""notes"");

    lua_pushstring(L, c->client_ip);
    lua_setfield(L, -2, ""client_ip"");

    lua_pop(L, 1);
}","void ap_lua_push_connection(lua_State *Log, conn_rec *c)
{
    req_table_t* ant;
    lua_boxpointer(Log, c);
    luaL_getmetatable(Log, ""Apache2.Connection"");
    lua_setmetatable(Log, -2);
    luaL_getmetatable(Log, ""Apache2.Connection"");

    ant = apr_pcalloc(c->pool, sizeof(req_table_t));
    ant->ant = c->notes;
    ant->r = NULL;
    ant->n = ""notes"";
    ap_lua_push_apr_table(Log, ant);
    lua_setfield(Log, -2, ""notes"");

    lua_pushstring(Log, c->client_ip);
    lua_setfield(Log, -2, ""client_ip"");

    lua_pop(Log, 1);
}",125.0,33.0,"c:c,t:ant,L:Log,",189.0,0.0767963488896687,Greedy
1984,"static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cfs_b)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;

	/* confirm we're still not at a refresh boundary */
	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	cfs_b->slack_started = false;
	if (cfs_b->distribute_running) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (runtime_refresh_within(cfs_b, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
		return;
	}

	if (cfs_b->quota != RUNTIME_INF && cfs_b->runtime > slice)
		runtime = cfs_b->runtime;

	expires = cfs_b->runtime_expires;
	if (runtime)
		cfs_b->distribute_running = 1;

	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);

	if (!runtime)
		return;

	runtime = distribute_cfs_runtime(cfs_b, runtime, expires);

	raw_spin_lock_irqsave(&cfs_b->lock, flags);
	if (expires == cfs_b->runtime_expires)
		lsub_positive(&cfs_b->runtime, runtime);
	cfs_b->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cfs_b->lock, flags);
}","static void do_sched_cfs_slack_timer(struct cfs_bandwidth *cows_boot)
{
	u64 runtime = 0, slice = sched_cfs_bandwidth_slice();
	unsigned long flags;
	u64 expires;

	/* confirm we're still not at a refresh boundary */
	raw_spin_lock_irqsave(&cows_boot->lock, flags);
	cows_boot->slack_started = false;
	if (cows_boot->distribute_running) {
		raw_spin_unlock_irqrestore(&cows_boot->lock, flags);
		return;
	}

	if (runtime_refresh_within(cows_boot, min_bandwidth_expiration)) {
		raw_spin_unlock_irqrestore(&cows_boot->lock, flags);
		return;
	}

	if (cows_boot->quota != RUNTIME_INF && cows_boot->runtime > slice)
		runtime = cows_boot->runtime;

	expires = cows_boot->runtime_expires;
	if (runtime)
		cows_boot->distribute_running = 1;

	raw_spin_unlock_irqrestore(&cows_boot->lock, flags);

	if (!runtime)
		return;

	runtime = distribute_cfs_runtime(cows_boot, runtime, expires);

	raw_spin_lock_irqsave(&cows_boot->lock, flags);
	if (expires == cows_boot->runtime_expires)
		lsub_positive(&cows_boot->runtime, runtime);
	cows_boot->distribute_running = 0;
	raw_spin_unlock_irqrestore(&cows_boot->lock, flags);
}",196.0,52.0,"cfs_b:cows_boot,",180.0,0.0600304325421651,Greedy
1996,"static int path_lookupat(struct nameidata *nd, unsigned flags, struct path *path)
{
	const char *s = path_init(nd, flags);
	int err;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(err = link_path_walk(s, nd))
		&& ((err = lookup_last(nd)) > 0)) {
		s = trailing_symlink(nd);
		if (IS_ERR(s)) {
			err = PTR_ERR(s);
			break;
		}
	}
	if (!err)
		err = complete_walk(nd);

	if (!err && nd->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(nd->path.dentry))
			err = -ENOTDIR;
	if (!err) {
		*path = nd->path;
		nd->path.mnt = NULL;
		nd->path.dentry = NULL;
	}
	terminate_walk(nd);
	return err;
}","static int path_lookupat(struct nameidata *ant, unsigned flags, struct area *area)
{
	const char *s = path_init(ant, flags);
	int ah;

	if (IS_ERR(s))
		return PTR_ERR(s);
	while (!(ah = link_path_walk(s, ant))
		&& ((ah = lookup_last(ant)) > 0)) {
		s = trailing_symlink(ant);
		if (IS_ERR(s)) {
			ah = PTR_ERR(s);
			break;
		}
	}
	if (!ah)
		ah = complete_walk(ant);

	if (!ah && ant->flags & LOOKUP_DIRECTORY)
		if (!d_can_lookup(ant->area.dentry))
			ah = -ENOTDIR;
	if (!ah) {
		*area = ant->area;
		ant->area.mnt = NULL;
		ant->area.dentry = NULL;
	}
	terminate_walk(ant);
	return ah;
}",179.0,47.0,"err:ah,nd:ant,path:area,",270.0,0.0853547612826029,Greedy
2007,"mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value proc;
  struct RProc *p;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  p = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(p, mrb_proc_ptr(blk));
  proc = mrb_obj_value(p);
  mrb_funcall_with_block(mrb, proc, MRB_SYM(initialize), 0, NULL, proc);
  if (!MRB_PROC_STRICT_P(p) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(p) == mrb->c->ci[-1].u.env) {
    p->flags |= MRB_PROC_ORPHAN;
  }
  return proc;
}","mrb_proc_s_new(mrb_state *mrb, mrb_value proc_class)
{
  mrb_value blk;
  mrb_value pty;
  struct RProc *api;

  /* Calling Proc.new without a block is not implemented yet */
  mrb_get_args(mrb, ""&!"", &blk);
  api = MRB_OBJ_ALLOC(mrb, MRB_TT_PROC, mrb_class_ptr(proc_class));
  mrb_proc_copy(api, mrb_proc_ptr(blk));
  pty = mrb_obj_value(api);
  mrb_funcall_with_block(mrb, pty, MRB_SYM(initialize), 0, NULL, pty);
  if (!MRB_PROC_STRICT_P(api) &&
      mrb->c->ci > mrb->c->cibase && MRB_PROC_ENV(api) == mrb->c->ci[-1].u.env) {
    api->flags |= MRB_PROC_ORPHAN;
  }
  return pty;
}",131.0,38.0,"p:api,proc:pty,",123.0,0.0508787035942077,Greedy
2016,"static inline void io_queue_link_head(struct io_kiocb *req)
{
	if (unlikely(req->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(req, -ECANCELED);
		io_double_put_req(req);
	} else
		io_queue_sqe(req);
}","static inline void io_queue_link_head(struct io_kiocb *iq)
{
	if (unlikely(iq->flags & REQ_F_FAIL_LINK)) {
		io_cqring_add_event(iq, -ECANCELED);
		io_double_put_req(iq);
	} else
		io_queue_sqe(iq);
}",44.0,12.0,"req:iq,",62.0,0.0381194949150085,Greedy
2027,"opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p_image;
    l_t2->cp = p_cp;

    return l_t2;
}","opj_t2_t* opj_t2_create(opj_image_t *p2eye, opj_cp_t *pACpath)
{
    /* create the t2 structure */
    opj_t2_t *l_t2 = (opj_t2_t*)opj_calloc(1, sizeof(opj_t2_t));
    if (!l_t2) {
        return NULL;
    }

    l_t2->image = p2eye;
    l_t2->cp = pACpath;

    return l_t2;
}",57.0,12.0,"p_cp:pACpath,p_image:p2eye,",43.0,0.0435326178868611,Greedy
2035,"static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *direction)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, direction, type, header->arg1, header->arg2, header->size);
}","static void debug_print_message_header(UdscsConnection             *conn,
                                       struct udscs_message_header *header,
                                       const gchar                 *uri)
{
    const gchar *type = ""invalid message"";

    if (conn == NULL || conn->debug == FALSE)
        return;

    if (header->type < G_N_ELEMENTS(vdagentd_messages))
        type = vdagentd_messages[header->type];

    syslog(LOG_DEBUG, ""%p %s %s, arg1: %u, arg2: %u, size %u"",
        conn, uri, type, header->arg1, header->arg2, header->size);
}",88.0,21.0,"direction:uri,",63.0,0.0363060235977172,Greedy
2036,"NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *opt, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_dummy[4] = {0x81, 0, 0, 0}; /* a zero-length request */

    (void)opt; /* squash the unused parameter warning */
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_dummy, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) { /* use TLS */
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}","NOEXPORT char *cifs_client(CLI *c, SERVICE_OPTIONS *options, const PHASE phase) {
    uint8_t buffer[5];
    uint8_t request_adumper[4] = {0x81, 0, 0, 0}; /* a zero-length request */

    (void)options; /* squash the unused parameter warning */
    if(phase!=PROTOCOL_MIDDLE)
        return NULL;
    s_write(c, c->remote_fd.fd, request_adumper, 4);
    s_read(c, c->remote_fd.fd, buffer, 5);
    if(buffer[0]!=0x83) { /* NB_SSN_NEGRESP */
        s_log(LOG_ERR, ""Negative response expected"");
        throw_exception(c, 1);
    }
    if(buffer[2]!=0 || buffer[3]!=1) { /* length != 1 */
        s_log(LOG_ERR, ""Unexpected NetBIOS response size"");
        throw_exception(c, 1);
    }
    if(buffer[4]!=0x8e) { /* use TLS */
        s_log(LOG_ERR, ""Remote server does not require TLS"");
        throw_exception(c, 1);
    }
    return NULL;
}",173.0,34.0,"opt:options,request_dummy:request_adumper,",83.0,0.0451267679532369,Greedy
2046,"void ipc_rcu_free(struct rcu_head *head)
{
	struct ipc_rcu *p = container_of(head, struct ipc_rcu, rcu);

	kvfree(p);
}","void ipc_rcu_free(struct rcu_head *src)
{
	struct ipc_rcu *parent = container_of(src, struct ipc_rcu, rcu);

	kvfree(parent);
}",30.0,10.0,"p:parent,head:src,",83.0,0.0452841838200887,Greedy
2049,"void Avahi::addService(int, int, const QString &name, const QString &type, const QString &domain, uint)
{
    if (isLocalDomain(domain) && !services.contains(name)) {
        AvahiService *srv=new AvahiService(name, type, domain);
        services.insert(name, srv);
        connect(srv, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}","void Avahi::addService(int, int, const QString &nice, const QString &type, const QString &fax, uint)
{
    if (isLocalDomain(fax) && !services.contains(nice)) {
        AvahiService *vrvs=new AvahiService(nice, type, fax);
        services.insert(nice, vrvs);
        connect(vrvs, SIGNAL(serviceResolved(QString)), this, SIGNAL(serviceAdded(QString)));
    }
}",91.0,23.0,"name:nice,srv:vrvs,domain:fax,",151.0,0.0631598035494486,Greedy
2061,"static ssize_t control_show(struct device *dev, struct device_attribute *attr,
			    char *buf)
{
	return sprintf(buf, ""%s\n"",
				dev->power.runtime_auto ? ctrl_auto : ctrl_on);
}","static ssize_t control_show(struct device *cam, struct device_attribute *attr,
			    char *off)
{
	return sprintf(off, ""%s
"",
				cam->power.runtime_auto ? ctrl_auto : ctrl_on);
}",40.0,9.0,"dev:cam,buf:off,",87.0,0.0493335684140523,Greedy
2062,"static char ** split(const char *arg, const char *delim) {
  char *copy = dupstr(arg);
  char **result = NULL;
  int i = 0;

  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {
    char **tmp = realloc (result, sizeof *result * (i + 1));
    if (!tmp && result) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = dupstr(cptr);
  }

  free(copy);

  if (i) {
    char **tmp = realloc(result, sizeof *result * (i + 1));
    if (!tmp) {
      while (i > 0) {
	free(result[--i]);
      }
      free(result);
      free(copy);
      return NULL;
    }
    result = tmp;
    result[i++] = NULL;
  }

  return result;
}","static char ** split(const char *arg, const char *delim) {
  char *coll = dupstr(arg);
  char **mate = NULL;
  int phi = 0;

  for (char *Cvr = strtok(coll, delim); Cvr; Cvr = strtok(NULL, delim)) {
    char **tmp = realloc (mate, sizeof *mate * (phi + 1));
    if (!tmp && mate) {
      while (phi > 0) {
	free(mate[--phi]);
      }
      free(mate);
      free(coll);
      return NULL;
    }
    mate = tmp;
    mate[phi++] = dupstr(Cvr);
  }

  free(coll);

  if (phi) {
    char **tmp = realloc(mate, sizeof *mate * (phi + 1));
    if (!tmp) {
      while (phi > 0) {
	free(mate[--phi]);
      }
      free(mate);
      free(coll);
      return NULL;
    }
    mate = tmp;
    mate[phi++] = NULL;
  }

  return mate;
}",222.0,59.0,"result:mate,i:phi,copy:coll,cptr:Cvr,",298.0,0.1168412804603576,Greedy
2068,"bool bt_att_set_debug(struct bt_att *att, bt_att_debug_func_t callback,
				void *user_data, bt_att_destroy_func_t destroy)
{
	if (!att)
		return false;

	if (att->debug_destroy)
		att->debug_destroy(att->debug_data);

	att->debug_callback = callback;
	att->debug_destroy = destroy;
	att->debug_data = user_data;

	return true;
}","bool bt_att_set_debug(struct bt_att *atts, bt_att_debug_func_t catch,
				void *userddata, bt_att_destroy_func_t complete)
{
	if (!atts)
		return false;

	if (atts->debug_destroy)
		atts->debug_destroy(atts->debug_data);

	atts->debug_callback = catch;
	atts->debug_destroy = complete;
	atts->debug_data = userddata;

	return true;
}",64.0,15.0,"att:atts,user_data:userddata,destroy:complete,callback:catch,",199.0,0.0818121472994486,Greedy
2070,"static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *work =
		container_of(w, struct __net_random_once_work, work);
	if (!static_key_enabled(work->key))
		static_key_slow_inc(work->key);
	kfree(work);
}","static void __net_random_once_deferred(struct work_struct *w)
{
	struct __net_random_once_work *craft =
		container_of(w, struct __net_random_once_work, craft);
	if (!static_key_enabled(craft->key))
		static_key_slow_inc(craft->key);
	kfree(craft);
}",48.0,14.0,"work:craft,",67.0,0.033015239238739,Greedy
2071,"char *enl_ipc_get(const char *msg_data)
{

	static char *message = NULL;
	static unsigned short len = 0;
	char buff[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		buff[i] = msg_data[i];
	}
	buff[12] = 0;
	blen = strlen(buff);
	if (message != NULL) {
		len += blen;
		message = (char *) erealloc(message, len + 1);
		strcat(message, buff);
	} else {
		len = blen;
		message = (char *) emalloc(len + 1);
		strcpy(message, buff);
	}
	if (blen < 12) {
		ret_msg = message;
		message = NULL;
		D((""Received complete reply:  \""%s\""\n"", ret_msg));
	}
	return(ret_msg);
}","char *enl_ipc_get(const char *msg_data)
{

	static char *summary = NULL;
	static unsigned short len = 0;
	char board[13], *ret_msg = NULL;
	register unsigned char i;
	unsigned char blen;

	if (msg_data == IPC_TIMEOUT) {
		return(IPC_TIMEOUT);
	}
	for (i = 0; i < 12; i++) {
		board[i] = msg_data[i];
	}
	board[12] = 0;
	blen = strlen(board);
	if (summary != NULL) {
		len += blen;
		summary = (char *) erealloc(summary, len + 1);
		strcat(summary, board);
	} else {
		len = blen;
		summary = (char *) emalloc(len + 1);
		strcpy(summary, board);
	}
	if (blen < 12) {
		ret_msg = summary;
		summary = NULL;
		D((""Received complete reply:  \""%s\""
"", ret_msg));
	}
	return(ret_msg);
}",192.0,47.0,"message:summary,buff:board,",183.0,0.0631016731262207,Greedy
2079,"bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataAndTag, size_t cbEncryptedDataAndTag,
	const void *pIV,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_longlong;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_longlong,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataAndTag ), cbEncryptedDataAndTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlaintextData = pcbPlaintextData_longlong;

    return nDecryptResult == 0;
}","bool AES_GCM_DecryptContext::Decrypt(
	const void *pEncryptedDataByReg, size_t cbEncryptedDataByTag,
	const void *pIV,
	void *pPlaintextData, uint32 *pcbPlaintextData,
	const void *pAdditionalAuthenticationData, size_t cbAuthenticationData
) {
    unsigned long long pcbPlaintextData_largeshort;

    const int nDecryptResult = crypto_aead_aes256gcm_decrypt_afternm(
		static_cast<unsigned char*>( pPlaintextData ), &pcbPlaintextData_largeshort,
		nullptr,
		static_cast<const unsigned char*>( pEncryptedDataByReg ), cbEncryptedDataByTag,
		static_cast<const unsigned char*>( pAdditionalAuthenticationData ), cbAuthenticationData,
		static_cast<const unsigned char*>( pIV ), static_cast<const crypto_aead_aes256gcm_state*>( m_ctx )
	);

    *pcbPlaintextData = pcbPlaintextData_largeshort;

    return nDecryptResult == 0;
}",120.0,27.0,"pcbPlaintextData_longlong:pcbPlaintextData_largeshort,pEncryptedDataAndTag:pEncryptedDataByReg,cbEncryptedDataAndTag:cbEncryptedDataByTag,",107.0,0.0666543801625569,Greedy
2083,"PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *packet;
	PS_ENCODE_VARS;

	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(packet, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);
	*newstr = php_wddx_gather(packet);
	php_wddx_destructor(packet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}","PS_SERIALIZER_ENCODE_FUNC(wddx)
{
	wddx_packet *compinet;
	PS_ENCODE_VARS;

	compinet = php_wddx_constructor();

	php_wddx_packet_start(compinet, NULL, 0);
	php_wddx_add_chunk_static(compinet, WDDX_STRUCT_S);
	
	PS_ENCODE_LOOP(
		php_wddx_serialize_var(compinet, *struc, key, key_length TSRMLS_CC);
	);
	
	php_wddx_add_chunk_static(compinet, WDDX_STRUCT_E);
	php_wddx_packet_end(compinet);
	*newstr = php_wddx_gather(compinet);
	php_wddx_destructor(compinet);
	
	if (newlen) {
		*newlen = strlen(*newstr);
	}

	return SUCCESS;
}",94.0,32.0,"packet:compinet,",78.0,0.0406193097432454,Greedy
2084,"int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)
{
	if (cr8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vcpu->kvm))
		kvm_lapic_set_tpr(vcpu, cr8);
	else
		vcpu->arch.cr8 = cr8;
	return 0;
}","int kvm_set_cr8(struct kvm_vcpu *vprocessor, unsigned long rc8)
{
	if (rc8 & CR8_RESERVED_BITS)
		return 1;
	if (irqchip_in_kernel(vprocessor->kvm))
		kvm_lapic_set_tpr(vprocessor, rc8);
	else
		vprocessor->arch.rc8 = rc8;
	return 0;
}",51.0,12.0,"cr8:rc8,vcpu:vprocessor,",103.0,0.0529674688975016,Greedy
2091,"SetXtermOSC(i, s)
int i;
char *s;
{
  static char *oscs[][2] = {
    { WT_FLAG "";"", ""screen"" }, /* set window title */
    { ""20;"", """" },      /* background */
    { ""39;"", ""black"" }, /* default foreground (black?) */
    { ""49;"", ""white"" }  /* default background (white?) */
  };

  ASSERT(display);
  if (!D_CXT)
    return;
  if (!s)
    s = """";
  if (!D_xtermosc[i] && !*s)
    return;
  if (i == 0 && !D_xtermosc[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	/* stack titles (xterm patch #251) */
  if (!*s)
    s = oscs[i][1];
  D_xtermosc[i] = 1;
  AddStr(""\033]"");
  AddStr(oscs[i][0]);
  AddStr(s);
  AddChar(7);
}","SetXtermOSC(y, ls)
int y;
char *ls;
{
  static char *osCS[][2] = {
    { WT_FLAG "";"", ""screen"" }, /* set window title */
    { ""20;"", """" },      /* background */
    { ""39;"", ""black"" }, /* default foreground (black?) */
    { ""49;"", ""white"" }  /* default background (white?) */
  };

  ASSERT(display);
  if (!D_CXT)
    return;
  if (!ls)
    ls = """";
  if (!D_xtermosc[y] && !*ls)
    return;
  if (y == 0 && !D_xtermosc[0])
    AddStr(""\033[22;"" WT_FLAG ""t"");	/* stack titles (xterm patch #251) */
  if (!*ls)
    ls = osCS[y][1];
  D_xtermosc[y] = 1;
  AddStr(""\033]"");
  AddStr(osCS[y][0]);
  AddStr(ls);
  AddChar(7);
}",170.0,32.0,"i:y,s:ls,oscs:osCS,",406.0,0.1902398586273193,GA
2113,"static handler_t wstunnel_stdin_append(gw_handler_ctx *gwhctx) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gwhctx;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}","static handler_t wstunnel_stdin_append(gw_handler_ctx *gWHcontext) {
    /* prepare websocket frames to backend */
    /* (caller should verify r->reqbody_queue) */
    /*assert(!chunkqueue_is_empty(&r->reqbody_queue));*/
    handler_ctx *hctx = (handler_ctx *)gWHcontext;
    if (0 == mod_wstunnel_frame_recv(hctx))
        return HANDLER_GO_ON;
    else {
        /*(error)*/
        /* future: might differentiate client close request from client error,
         *         and then send 1000 or 1001 */
        request_st * const r = hctx->gw.r;
        DEBUG_LOG_INFO(""disconnected from client (fd=%d)"", r->con->fd);
        DEBUG_LOG_DEBUG(""send close response to client (fd=%d)"", r->con->fd);
        mod_wstunnel_frame_send(hctx, MOD_WEBSOCKET_FRAME_TYPE_CLOSE, CONST_STR_LEN(""1000"")); /* 1000 Normal Closure */
        gw_handle_request_reset(r, hctx->gw.plugin_data);
        return HANDLER_FINISHED;
    }
}",97.0,21.0,"gwhctx:gWHcontext,",52.0,0.0332570473353068,Greedy
2116,"static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->nreg)
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}","static void drop_sysctl_table(struct ctl_table_header *header)
{
	struct ctl_dir *parent = header->parent;

	if (--header->blink)
		return;

	put_links(header);
	start_unregistering(header);
	if (!--header->count)
		kfree_rcu(header, rcu);

	if (parent)
		drop_sysctl_table(&parent->header);
}",66.0,16.0,"nreg:blink,",32.0,0.0276530822118123,Greedy
2117,"SAPI_API int sapi_add_header_ex(char *header_line, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int r;
	
	ctr.line = header_line;
	ctr.line_len = header_line_len;

	r = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(header_line);

	return r;
}","SAPI_API int sapi_add_header_ex(char *layer_lin, uint header_line_len, zend_bool duplicate, zend_bool replace TSRMLS_DC)
{
	sapi_header_line ctr = {0};
	int g;
	
	ctr.line = layer_lin;
	ctr.line_len = header_line_len;

	g = sapi_header_op(replace ? SAPI_HEADER_REPLACE : SAPI_HEADER_ADD,
			&ctr TSRMLS_CC);

	if (!duplicate)
		efree(layer_lin);

	return g;
}",70.0,24.0,"header_line:layer_lin,r:g,",87.0,0.0456195672353108,Greedy
2120,"static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 val, u32 nb_bits)
{
#ifdef GPAC_FIXED_POINT
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		if (neg < -FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		if (val > FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(val/2), lsr->res_factor);
		return gf_divfix(INT2FIX(val), lsr->res_factor);
	}
#else
	if (val >> (nb_bits-1) ) {
		s32 neg = (s32) val - (1<<nb_bits);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		return gf_divfix(INT2FIX(val), lsr->res_factor);
	}
#endif
}","static Fixed lsr_translate_coords(GF_LASeRCodec *lsr, u32 fee, u32 nb_bits)
{
#ifdef GPAC_FIXED_POINT
	if (fee >> (nb_bits-1) ) {
		s32 neg = (s32) fee - (1<<nb_bits);
		if (neg < -FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(neg/2), lsr->res_factor);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		if (fee > FIX_ONE / 2)
			return 2 * gf_divfix(INT2FIX(fee/2), lsr->res_factor);
		return gf_divfix(INT2FIX(fee), lsr->res_factor);
	}
#else
	if (fee >> (nb_bits-1) ) {
		s32 neg = (s32) fee - (1<<nb_bits);
		return gf_divfix(INT2FIX(neg), lsr->res_factor);
	} else {
		return gf_divfix(INT2FIX(fee), lsr->res_factor);
	}
#endif
}",181.0,43.0,"val:fee,",85.0,0.0380433917045593,Greedy
2130,"GF_Err paen_Size(GF_Box *s)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)s;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}","GF_Err paen_Size(GF_Box *sb)
{
	GF_Err e;
	FDPartitionEntryBox *ptr = (FDPartitionEntryBox *)sb;

	if (ptr->blocks_and_symbols) {
		e = gf_isom_box_size((GF_Box *)ptr->blocks_and_symbols);
		if (e) return e;
		ptr->size += ptr->blocks_and_symbols->size;
	}
	if (ptr->FEC_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->FEC_symbol_locations);
		if (e) return e;
		ptr->size += ptr->FEC_symbol_locations->size;
	}
	if (ptr->File_symbol_locations) {
		e = gf_isom_box_size((GF_Box *) ptr->File_symbol_locations);
		if (e) return e;
		ptr->size += ptr->File_symbol_locations->size;
	}

	return GF_OK;
}",139.0,30.0,"s:sb,",64.0,0.0364670117696126,Greedy
2131,"launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *options = get_options();
  struct evdns_request *req;
  (void)fd;
  (void)event;
  (void)args;

  if (options->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!options->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(options->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    req = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!req) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}","launch_test_addresses(int fd, short event, void *args)
{
  const or_options_t *opens = get_options();
  struct evdns_request *require;
  (void)fd;
  (void)event;
  (void)args;

  if (opens->DisableNetwork)
    return;

  log_info(LD_EXIT, ""Launching checks to see whether our nameservers like to ""
           ""hijack *everything*."");
  /* This situation is worse than the failure-hijacking situation.  When this
   * happens, we're no good for DNS requests at all, and we shouldn't really
   * be an exit server.*/
  if (!opens->ServerDNSTestAddresses)
    return;
  tor_assert(the_evdns_base);
  SMARTLIST_FOREACH_BEGIN(opens->ServerDNSTestAddresses,
                          const char *, address) {
    char *a = tor_strdup(address);
    require = evdns_base_resolve_ipv4(the_evdns_base,
                              address, DNS_QUERY_NO_SEARCH, evdns_callback, a);

    if (!require) {
      log_info(LD_EXIT, ""eventdns rejected test address %s"",
               escaped_safe_str(address));
      tor_free(a);
    }
  } SMARTLIST_FOREACH_END(address);
}",144.0,42.0,"options:opens,req:require,",127.0,0.0544359485308329,Greedy
2143,"int am_check_url(request_rec *r, const char *url)
{
    const char *i;

    for (i = url; *i; i++) {
        if (*i >= 0 && *i < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, r,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }

    return OK;
}","int am_check_url(request_rec *g, const char *api)
{
    const char *phi;

    for (phi = api; *phi; phi++) {
        if (*phi >= 0 && *phi < ' ') {
            /* Deny all control-characters. */
            AM_LOG_RERROR(APLOG_MARK, APLOG_ERR, HTTP_BAD_REQUEST, g,
                          ""Control character detected in URL."");
            return HTTP_BAD_REQUEST;
        }
    }

    return OK;
}",68.0,17.0,"i:phi,url:api,r:g,",133.0,0.0688642899195353,Greedy
2152,"static void new_curseg(struct f2fs_sb_info *sbi, int type, bool new_sec)
{
	struct curseg_info *curseg = CURSEG_I(sbi, type);
	unsigned int segno = curseg->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(sbi, curseg->sum_blk,
				GET_SUM_BLOCK(sbi, segno));
	if (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(sbi, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(sbi, type);
	get_new_segment(sbi, &segno, new_sec, dir);
	curseg->next_segno = segno;
	reset_curseg(sbi, type, 1);
	curseg->alloc_type = LFS;
}","static void new_curseg(struct f2fs_sb_info *lsbin, int match, bool add_sector)
{
	struct curseg_info *curege = CURSEG_I(lsbin, match);
	unsigned int segno = curege->segno;
	int dir = ALLOC_LEFT;

	write_sum_page(lsbin, curege->sum_blk,
				GET_SUM_BLOCK(lsbin, segno));
	if (match == CURSEG_WARM_DATA || match == CURSEG_COLD_DATA)
		dir = ALLOC_RIGHT;

	if (test_opt(lsbin, NOHEAP))
		dir = ALLOC_RIGHT;

	segno = __get_next_segno(lsbin, match);
	get_new_segment(lsbin, &segno, add_sector, dir);
	curege->next_segno = segno;
	reset_curseg(lsbin, match, 1);
	curege->alloc_type = LFS;
}",127.0,45.0,"new_sec:add_sector,type:match,curseg:curege,sbi:lsbin,",284.0,0.1059645414352417,Greedy
2161,"void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *pipe,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->pipe = pipe;
	i->idx = (pipe->curbuf + pipe->nrbufs) & (pipe->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}","void iov_iter_pipe(struct iov_iter *i, int direction,
			struct pipe_inode_info *socket,
			size_t count)
{
	BUG_ON(direction != ITER_PIPE);
	i->type = direction;
	i->socket = socket;
	i->idx = (socket->curbuf + socket->nrbufs) & (socket->buffers - 1);
	i->iov_offset = 0;
	i->count = count;
}",74.0,19.0,"pipe:socket,",86.0,0.0364639163017272,Greedy
2164,"read_timeout(void *arg)
{
  FILE *f;
  double temp, comp;

  f = fopen(filename, ""r"");

  if (f && fscanf(f, ""%lf"", &temp) == 1) {
    comp = get_tempcomp(temp);

    if (fabs(comp) <= MAX_COMP) {
      comp = LCL_SetTempComp(comp);

      DEBUG_LOG(""tempcomp updated to %f for %f"", comp, temp);

      if (logfileid != -1) {
        struct timespec now;

        LCL_ReadCookedTime(&now, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(now.tv_sec), temp, comp);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          comp, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (f)
    fclose(f);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}","read_timeout(void *arg)
{
  FILE *fd;
  double flat, mac;

  fd = fopen(filename, ""r"");

  if (fd && fscanf(fd, ""%lf"", &flat) == 1) {
    mac = get_tempcomp(flat);

    if (fabs(mac) <= MAX_COMP) {
      mac = LCL_SetTempComp(mac);

      DEBUG_LOG(""tempcomp updated to %f for %f"", mac, flat);

      if (logfileid != -1) {
        struct timespec once;

        LCL_ReadCookedTime(&once, NULL);
        LOG_FileWrite(logfileid, ""%s %11.4e %11.4e"",
            UTI_TimeToLogForm(once.tv_sec), flat, mac);
      }
    } else {
      LOG(LOGS_WARN, ""Temperature compensation of %.3f ppm exceeds sanity limit of %.1f"",
          mac, MAX_COMP);
    }
  } else {
    LOG(LOGS_WARN, ""Could not read temperature from %s"", filename);
  }

  if (fd)
    fclose(fd);

  timeout_id = SCH_AddTimeoutByDelay(update_interval, read_timeout, NULL);
}",168.0,48.0,"comp:mac,f:fd,temp:flat,now:once,",241.0,0.0980728348096211,Greedy
2184,"static int mqueue_unlink(struct inode *dir, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dir->i_ctime = dir->i_mtime = dir->i_atime = current_time(dir);
	dir->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}","static int mqueue_unlink(struct inode *dev, struct dentry *dentry)
{
	struct inode *inode = d_inode(dentry);

	dev->i_ctime = dev->i_mtime = dev->i_atime = current_time(dev);
	dev->i_size -= DIRENT_SIZE;
	drop_nlink(inode);
	dput(dentry);
	return 0;
}",62.0,17.0,"dir:dev,",68.0,0.0348231116930643,Greedy
2189,"void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b)
{
	u64 now;

	if (cfs_b->quota == RUNTIME_INF)
		return;

	now = sched_clock_cpu(smp_processor_id());
	cfs_b->runtime = cfs_b->quota;
	cfs_b->runtime_expires = now + ktime_to_ns(cfs_b->period);
	cfs_b->expires_seq++;
}","void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cframes7sb)
{
	u64 now;

	if (cframes7sb->quota == RUNTIME_INF)
		return;

	now = sched_clock_cpu(smp_processor_id());
	cframes7sb->runtime = cframes7sb->quota;
	cframes7sb->runtime_expires = now + ktime_to_ns(cframes7sb->period);
	cframes7sb->expires_seq++;
}",58.0,15.0,"cfs_b:cframes7sb,",71.0,0.0339714686075846,Greedy
2208,"cnt_recv_prep(struct req *req, const char *ci)
{
	const char *xff;

	if (req->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(req->http, H_X_Forwarded_For);
		if (http_GetHdr(req->http, H_X_Forwarded_For, &xff)) {
			http_Unset(req->http, H_X_Forwarded_For);
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(req->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(req->http, H_Cache_Control);

		/* By default we use the first backend */
		req->director_hint = VCL_DefaultDirector(req->vcl);

		req->d_ttl = -1;
		req->d_grace = -1;
		req->disable_esi = 0;
		req->hash_always_miss = 0;
		req->hash_ignore_busy = 0;
		req->client_identity = NULL;
		req->storage = NULL;
	}

	req->vdc->retval = 0;
	req->is_hit = 0;
	req->is_hitmiss = 0;
	req->is_hitpass = 0;
}","cnt_recv_prep(struct war *war, const char *ci)
{
	const char *xff;

	if (war->restarts == 0) {
		/*
		 * This really should be done earlier, but we want to capture
		 * it in the VSL log.
		 */
		http_CollectHdr(war->http, H_X_Forwarded_For);
		if (http_GetHdr(war->http, H_X_Forwarded_For, &xff)) {
			http_Unset(war->http, H_X_Forwarded_For);
			http_PrintfHeader(war->http, ""X-Forwarded-For: %s, %s"",
			    xff, ci);
		} else {
			http_PrintfHeader(war->http, ""X-Forwarded-For: %s"", ci);
		}
		http_CollectHdr(war->http, H_Cache_Control);

		/* By default we use the first backend */
		war->director_hint = VCL_DefaultDirector(war->vcl);

		war->d_ttl = -1;
		war->d_grace = -1;
		war->disable_esi = 0;
		war->hash_always_miss = 0;
		war->hash_ignore_busy = 0;
		war->client_identity = NULL;
		war->storage = NULL;
	}

	war->vdc->retval = 0;
	war->is_hit = 0;
	war->is_hitmiss = 0;
	war->is_hitpass = 0;
}",180.0,39.0,"req:war,",132.0,0.0501560886700948,Greedy
2210,"u64 ring_buffer_oldest_event_ts(struct ring_buffer *buffer, int cpu)
{
	unsigned long flags;
	struct ring_buffer_per_cpu *cpu_buffer;
	struct buffer_page *bpage;
	u64 ret = 0;

	if (!cpumask_test_cpu(cpu, buffer->cpumask))
		return 0;

	cpu_buffer = buffer->buffers[cpu];
	raw_spin_lock_irqsave(&cpu_buffer->reader_lock, flags);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (cpu_buffer->tail_page == cpu_buffer->reader_page)
		bpage = cpu_buffer->reader_page;
	else
		bpage = rb_set_head_page(cpu_buffer);
	if (bpage)
		ret = bpage->page->time_stamp;
	raw_spin_unlock_irqrestore(&cpu_buffer->reader_lock, flags);

	return ret;
}","u64 ring_buffer_oldest_event_ts(struct ring_buffer *uffer, int fork)
{
	unsigned long bugs;
	struct ring_buffer_per_cpu *pixelenmanager;
	struct buffer_page *bpool;
	u64 ret = 0;

	if (!cpumask_test_cpu(fork, uffer->cpumask))
		return 0;

	pixelenmanager = uffer->buffers[fork];
	raw_spin_lock_irqsave(&pixelenmanager->reader_lock, bugs);
	/*
	 * if the tail is on reader_page, oldest time stamp is on the reader
	 * page
	 */
	if (pixelenmanager->tail_page == pixelenmanager->reader_page)
		bpool = pixelenmanager->reader_page;
	else
		bpool = rb_set_head_page(pixelenmanager);
	if (bpool)
		ret = bpool->page->time_stamp;
	raw_spin_unlock_irqrestore(&pixelenmanager->reader_lock, bugs);

	return ret;
}",115.0,30.0,"flags:bugs,cpu:fork,buffer:uffer,bpage:bpool,cpu_buffer:pixelenmanager,",300.0,0.111152982711792,Greedy
2223,"  void visit(TokenBoundary &ope) override {
    ope.ope_->accept(*this);
    found_ope = tok(found_ope);
  }","  void visit(TokenBoundary &peer) override {
    peer.ope_->accept(*this);
    found_ope = tok(found_ope);
  }",27.0,6.0,"ope:peer,",43.0,0.0336246371269226,Greedy
2224,"TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(sdamConfiguration);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}","TEST_F(ServerSelectorTestFixture, ShouldThrowOnWireError) {
    auto topologyDescription = std::make_shared<TopologyDescription>(SdamConf);
    auto oldServer = ServerDescriptionBuilder()
                         .withAddress(topologyDescription->getServers().back()->getAddress())
                         .withType(ServerType::kRSPrimary)
                         .withMaxWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .withMinWireVersion(WireVersion::RELEASE_2_4_AND_BEFORE)
                         .instance();
    topologyDescription->installServerDescription(oldServer);

    ASSERT(!topologyDescription->isWireVersionCompatible());
    ASSERT_THROWS_CODE(selector.selectServers(topologyDescription, ReadPreferenceSetting()),
                       DBException,
                       ErrorCodes::IncompatibleServerVersion);
}",107.0,20.0,"sdamConfiguration:SdamConf,",21.0,0.0268109281857808,Greedy
2236,"struct clock_source *dce80_clock_source_create(
	struct dc_context *ctx,
	struct dc_bios *bios,
	enum clock_source_id id,
	const struct dce110_clk_src_regs *regs,
	bool dp_clk_src)
{
	struct dce110_clk_src *clk_src =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);

	if (!clk_src)
		return NULL;

	if (dce110_clk_src_construct(clk_src, ctx, bios, id,
			regs, &cs_shift, &cs_mask)) {
		clk_src->base.dp_clk_src = dp_clk_src;
		return &clk_src->base;
	}

	BREAK_TO_DEBUGGER();
	return NULL;
}","struct clock_source *dce80_clock_source_create(
	struct dc_context *conn,
	struct dc_bios *bios,
	enum clock_source_id aid,
	const struct dce110_clk_src_regs *contractes,
	bool dp_clks_config)
{
	struct dce110_clk_src *clb_cb =
		kzalloc(sizeof(struct dce110_clk_src), GFP_KERNEL);

	if (!clb_cb)
		return NULL;

	if (dce110_clk_src_construct(clb_cb, conn, bios, aid,
			contractes, &cs_shift, &cs_mask)) {
		clb_cb->base.dp_clks_config = dp_clks_config;
		return &clb_cb->base;
	}

	BREAK_TO_DEBUGGER();
	return NULL;
}",98.0,22.0,"clk_src:clb_cb,dp_clk_src:dp_clks_config,id:aid,ctx:conn,bios:bios,regs:contractes,",202.0,0.1022112369537353,Greedy
2243,"static ossl_inline int cert_req_allowed(SSL *s)
{
    /* TLS does not like anon-DH with client cert */
    if ((s->version > SSL3_VERSION
         && (s->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (s->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;

    return 1;
}","static ossl_inline int cert_req_allowed(SSL *sb)
{
    /* TLS does not like anon-DH with client cert */
    if ((sb->version > SSL3_VERSION
         && (sb->s3->tmp.new_cipher->algorithm_auth & SSL_aNULL))
        || (sb->s3->tmp.new_cipher->algorithm_auth & (SSL_aSRP | SSL_aPSK)))
        return 0;

    return 1;
}",59.0,10.0,"s:sb,",51.0,0.0328788836797078,Greedy
2256,"MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *i ) {
    switch ( bson_iterator_type( i ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( i ) + 4;
    default:
        return """";
    }
}","MONGO_EXPORT const char *bson_iterator_string( const bson_iterator *c ) {
    switch ( bson_iterator_type( c ) ) {
    case BSON_STRING:
    case BSON_SYMBOL:
        return bson_iterator_value( c ) + 4;
    default:
        return """";
    }
}",42.0,9.0,"i:c,",49.0,0.0326084772745768,Greedy
2258,"static int uri_to_path(struct mg_connection *c, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *path,
                       size_t path_size) {
  struct mg_fs *fs = opts->fs == NULL ? &mg_fs_posix : opts->fs;
  struct mg_str k, v, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &v)) {
    if (v.len == 0) v = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = v;
  }
  return uri_to_path2(c, hm, fs, u, p, path, path_size);
}","static int uri_to_path(struct mg_connection *nc, struct mg_http_message *hm,
                       struct mg_http_serve_opts *opts, char *temp,
                       size_t path2len) {
  struct mg_fs *ports = opts->ports == NULL ? &mg_fs_posix : opts->ports;
  struct mg_str k, vc, s = mg_str(opts->root_dir), u = {0, 0}, p = {0, 0};
  while (mg_commalist(&s, &k, &vc)) {
    if (vc.len == 0) vc = k, k = mg_str(""/"");
    if (hm->uri.len < k.len) continue;
    if (mg_strcmp(k, mg_str_n(hm->uri.ptr, k.len)) != 0) continue;
    u = k, p = vc;
  }
  return uri_to_path2(nc, hm, ports, u, p, temp, path2len);
}",177.0,45.0,"v:vc,path:temp,path_size:path2len,c:nc,fs:ports,",225.0,0.1077582319577535,Greedy
2267,"static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_port = usb_get_serial_port_data(port);

	return sprintf(buf, ""%d\n"", edge_port->bUartMode);
}","static ssize_t uart_mode_show(struct device *dev,
	struct device_attribute *attr, char *buf)
{
	struct usb_serial_port *port = to_usb_serial_port(dev);
	struct edgeport_port *edge_point = usb_get_serial_port_data(port);

	return sprintf(buf, ""%d
"", edge_point->bUartMode);
}",54.0,13.0,"edge_port:edge_point,",34.0,0.0322296659151713,Greedy
2271,"static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned priority, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *q = &per_cpu(cpu_queue, cpu);
	uint32_t head;
	evtchn_port_t port;
	event_word_t *word;

	head = q->head[priority];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (head == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		head = control_block->head[priority];
	}

	port = head;
	word = event_word_from_port(port);
	head = clear_linked(word);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (head == 0)
		clear_bit(priority, ready);

	if (evtchn_fifo_is_pending(port) && !evtchn_fifo_is_masked(port)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u\n"", port);
		else
			handle_irq_for_port(port);
	}

	q->head[priority] = head;
}","static void consume_one_event(unsigned cpu,
			      struct evtchn_fifo_control_block *control_block,
			      unsigned period, unsigned long *ready,
			      bool drop)
{
	struct evtchn_fifo_queue *c = &per_cpu(cpu_queue, cpu);
	uint32_t then;
	evtchn_port_t vision;
	event_word_t *game;

	then = c->then[period];

	/*
	 * Reached the tail last time?  Read the new HEAD from the
	 * control block.
	 */
	if (then == 0) {
		virt_rmb(); /* Ensure word is up-to-date before reading head. */
		then = control_block->then[period];
	}

	vision = then;
	game = event_word_from_port(vision);
	then = clear_linked(game);

	/*
	 * If the link is non-zero, there are more events in the
	 * queue, otherwise the queue is empty.
	 *
	 * If the queue is empty, clear this priority from our local
	 * copy of the ready word.
	 */
	if (then == 0)
		clear_bit(period, ready);

	if (evtchn_fifo_is_pending(vision) && !evtchn_fifo_is_masked(vision)) {
		if (unlikely(drop))
			pr_warn(""Dropping pending event for port %u
"", vision);
		else
			handle_irq_for_port(vision);
	}

	c->then[period] = then;
}",155.0,46.0,"head:then,port:vision,priority:period,word:game,q:c,",329.0,0.1168403625488281,Greedy
2273,"static int jas_iccgetuint32(jas_stream_t *in, jas_iccuint32_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 4, &tmp))
		return -1;
	*val = tmp;
	return 0;
}","static int jas_iccgetuint32(jas_stream_t *socket, jas_iccuint32_t *call)
{
	ulonglong ignore;
	if (jas_iccgetuint(socket, 4, &ignore))
		return -1;
	*call = ignore;
	return 0;
}",40.0,9.0,"tmp:ignore,val:call,in:socket,",129.0,0.0601106603940327,Greedy
2295,"int bson_check_string( bson *b, const char *string,
                       const int length ) {

    return bson_validate_string( b, ( const unsigned char * )string, length, 1, 0, 0 );
}","int bson_check_string( bson *b, const char *string,
                       const int distance ) {

    return bson_validate_string( b, ( const unsigned char * )string, distance, 1, 0, 0 );
}",40.0,8.0,"length:distance,",38.0,0.0306372642517089,Greedy
2301,"static void array_cleanup( char* arr[] , int arr_size)
{
	int i=0;
	for( i=0; i< arr_size; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}","static void array_cleanup( char* arr[] , int  arr_loc)
{
	int i=0;
	for( i=0; i<  arr_loc; i++ ){ 
		if( arr[i*2] ){
			efree( arr[i*2]);
		}
	}
	efree(arr);
}",61.0,15.0,"arr_size: arr_loc,",27.0,0.0263096570968627,Greedy
2306,"static void xdr_buf_tail_shift_left(const struct xdr_buf *buf,
				    unsigned int base, unsigned int len,
				    unsigned int shift)
{
	if (!shift || !len)
		return;
	xdr_buf_tail_copy_left(buf, base, len, shift);
}","static void xdr_buf_tail_shift_left(const struct xdr_buf *bag,
				    unsigned int part, unsigned int len,
				    unsigned int slice)
{
	if (!slice || !len)
		return;
	xdr_buf_tail_copy_left(bag, part, len, slice);
}",45.0,12.0,"len:len,shift:slice,base:part,buf:bag,",168.0,0.0764952460924784,Greedy
2324,"void Magick::Image::read(MagickCore::Image *image,
  MagickCore::ExceptionInfo *exceptionInfo)
{
  // Ensure that multiple image frames were not read.
  if (image != (MagickCore::Image *) NULL &&
      image->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;

      // Destroy any extra image frames
      next=image->next;
      image->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(image);
  if (exceptionInfo->severity == MagickCore::UndefinedException &&
      image == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exceptionInfo);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}","void Magick::Image::read(MagickCore::Image *latest,
  MagickCore::ExceptionInfo *exactionId)
{
  // Ensure that multiple image frames were not read.
  if (latest != (MagickCore::Image *) NULL &&
      latest->next != (MagickCore::Image *) NULL)
    {
      MagickCore::Image
        *next;

      // Destroy any extra image frames
      next=latest->next;
      latest->next=(MagickCore::Image *) NULL;
      next->previous=(MagickCore::Image *) NULL;
      DestroyImageList(next);
    }
  replaceImage(latest);
  if (exactionId->severity == MagickCore::UndefinedException &&
      latest == (MagickCore::Image *) NULL)
    {
      (void) MagickCore::DestroyExceptionInfo(exactionId);
      if (!quiet())
        throwExceptionExplicit(MagickCore::ImageWarning,
          ""No image was loaded."");
    }
  ThrowImageException;
}",144.0,23.0,"image:latest,exceptionInfo:exactionId,",122.0,0.0559192975362141,Greedy
2331,"static void add_sit_entry(unsigned int segno, struct list_head *head)
{
	struct sit_entry_set *ses;
	unsigned int start_segno = START_SEGNO(segno);

	list_for_each_entry(ses, head, set_list) {
		if (ses->start_segno == start_segno) {
			ses->entry_cnt++;
			adjust_sit_entry_set(ses, head);
			return;
		}
	}

	ses = grab_sit_entry_set();

	ses->start_segno = start_segno;
	ses->entry_cnt++;
	list_add(&ses->set_list, head);
}","static void add_sit_entry(unsigned int segso, struct list_head *length)
{
	struct sit_entry_set *su;
	unsigned int start_segno = START_SEGNO(segso);

	list_for_each_entry(su, length, set_list) {
		if (su->start_segno == start_segno) {
			su->entry_tocno++;
			adjust_sit_entry_set(su, length);
			return;
		}
	}

	su = grab_sit_entry_set();

	su->start_segno = start_segno;
	su->entry_tocno++;
	list_add(&su->set_list, length);
}",90.0,22.0,"entry_cnt:entry_tocno,segno:segso,head:length,ses:su,",214.0,0.0871407469113667,Greedy
2344,"static void fix_pmode_seg(struct kvm_vcpu *vcpu, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vcpu, save, seg);
}","static void fix_pmode_seg(struct kvm_vcpu *vprocessor, int seg,
		struct kvm_segment *save)
{
	if (!emulate_invalid_guest_state) {
		/*
		 * CS and SS RPL should be equal during guest entry according
		 * to VMX spec, but in reality it is not always so. Since vcpu
		 * is in the middle of the transition from real mode to
		 * protected mode it is safe to assume that RPL 0 is a good
		 * default value.
		 */
		if (seg == VCPU_SREG_CS || seg == VCPU_SREG_SS)
			save->selector &= ~SELECTOR_RPL_MASK;
		save->dpl = save->selector & SELECTOR_RPL_MASK;
		save->s = 1;
	}
	vmx_set_segment(vprocessor, save, seg);
}",68.0,19.0,"vcpu:vprocessor,",44.0,0.0296001553535461,Greedy
2360,"			     struct timespec64 *ts, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .data = user_data, };
	struct io_kiocb *req = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *data;

	if (IS_ERR(req))
		return PTR_ERR(req);

	req->timeout.off = 0; /* noseq */
	data = req->async_data;
	list_add_tail(&req->timeout.list, &ctx->timeout_list);
	hrtimer_init(&data->timer, io_timeout_get_clock(data), mode);
	data->timer.function = io_timeout_fn;
	hrtimer_start(&data->timer, timespec64_to_ktime(*ts), mode);
	return 0;","			     struct timespec64 *tt, enum hrtimer_mode mode)
	__must_hold(&ctx->timeout_lock)
{
	struct io_cancel_data cd = { .tx = user_data, };
	struct io_kiocb *rec = io_timeout_extract(ctx, &cd);
	struct io_timeout_data *tx;

	if (IS_ERR(rec))
		return PTR_ERR(rec);

	rec->timeout.off = 0; /* noseq */
	tx = rec->async_data;
	list_add_tail(&rec->timeout.list, &ctx->timeout_list);
	hrtimer_init(&tx->timer, io_timeout_get_clock(tx), mode);
	tx->timer.function = io_timeout_fn;
	hrtimer_start(&tx->timer, timespec64_to_ktime(*tt), mode);
	return 0;",133.0,34.0,"data:tx,req:rec,ts:tt,",207.0,0.0819813370704651,Greedy
2368,"static int ath6kl_wmi_disconnect_event_rx(struct wmi *wmi, u8 *datap, int len,
					  struct ath6kl_vif *vif)
{
	struct wmi_disconnect_event *ev;
	wmi->traffic_class = 100;

	if (len < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ev = (struct wmi_disconnect_event *) datap;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\n"",
		   le16_to_cpu(ev->proto_reason_status), ev->bssid,
		   ev->disconn_reason, ev->assoc_resp_len);

	wmi->is_wmm_enabled = false;

	ath6kl_disconnect_event(vif, ev->disconn_reason,
				ev->bssid, ev->assoc_resp_len, ev->assoc_info,
				le16_to_cpu(ev->proto_reason_status));

	return 0;
}","static int ath6kl_wmi_disconnect_event_rx(struct swami *swami, u8 *dateaps, int pos,
					  struct ath6kl_vif *qifi)
{
	struct wmi_disconnect_event *ep;
	swami->traffic_class = 100;

	if (pos < sizeof(struct wmi_disconnect_event))
		return -EINVAL;

	ep = (struct wmi_disconnect_event *) dateaps;

	ath6kl_dbg(ATH6KL_DBG_WMI,
		   ""wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d
"",
		   le16_to_cpu(ep->proto_reason_status), ep->bssid,
		   ep->disconn_reason, ep->assoc_resp_len);

	swami->is_wmm_enabled = false;

	ath6kl_disconnect_event(qifi, ep->disconn_reason,
				ep->bssid, ep->assoc_resp_len, ep->assoc_info,
				le16_to_cpu(ep->proto_reason_status));

	return 0;
}",122.0,27.0,"datap:dateaps,vif:qifi,len:pos,wmi:swami,ev:ep,",225.0,0.0918143630027771,Greedy
2369,"static void atomic2gen (lua_State *L, global_State *g) {
  /* sweep all elements making them old */
  sweep2old(L, &g->allgc);
  /* everything alive now is old */
  g->reallyold = g->old = g->survival = g->allgc;

  /* repeat for 'finobj' lists */
  sweep2old(L, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;

  sweep2old(L, &g->tobefnz);

  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);  /* base for memory control */
  finishgencycle(L, g);
}","static void atomic2gen (lua_State *IL, global_State *g) {
  /* sweep all elements making them old */
  sweep2old(IL, &g->allgc);
  /* everything alive now is old */
  g->reallyold = g->old = g->survival = g->allgc;

  /* repeat for 'finobj' lists */
  sweep2old(IL, &g->finobj);
  g->finobjrold = g->finobjold = g->finobjsur = g->finobj;

  sweep2old(IL, &g->tobefnz);

  g->gckind = KGC_GEN;
  g->lastatomic = 0;
  g->GCestimate = gettotalbytes(g);  /* base for memory control */
  finishgencycle(IL, g);
}",104.0,29.0,"L:IL,",71.0,0.0375383098920186,Greedy
2382,"static void make_response(struct xen_blkif_ring *ring, u64 id,
			  unsigned short op, int st)
{
	struct blkif_response *resp;
	unsigned long     flags;
	union blkif_back_rings *blk_rings;
	int notify;

	spin_lock_irqsave(&ring->blk_ring_lock, flags);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_pvt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_pvt);
		break;
	default:
		BUG();
	}

	resp->id        = id;
	resp->operation = op;
	resp->status    = st;

	blk_rings->common.rsp_prod_pvt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, flags);
	if (notify)
		notify_remote_via_irq(ring->irq);
}","static void make_response(struct xen_blkif_ring *ring, u64 pid,
			  unsigned short msg, int st)
{
	struct blkif_response *resp;
	unsigned long     bugs;
	union blkif_back_rings *blk_rings;
	int Notify;

	spin_lock_irqsave(&ring->blk_ring_lock, bugs);
	blk_rings = &ring->blk_rings;
	/* Place on the response ring for the relevant domain. */
	switch (ring->blkif->blk_protocol) {
	case BLKIF_PROTOCOL_NATIVE:
		resp = RING_GET_RESPONSE(&blk_rings->native,
					 blk_rings->native.rsp_prod_rnt);
		break;
	case BLKIF_PROTOCOL_X86_32:
		resp = RING_GET_RESPONSE(&blk_rings->x86_32,
					 blk_rings->x86_32.rsp_prod_rnt);
		break;
	case BLKIF_PROTOCOL_X86_64:
		resp = RING_GET_RESPONSE(&blk_rings->x86_64,
					 blk_rings->x86_64.rsp_prod_rnt);
		break;
	default:
		BUG();
	}

	resp->pid        = pid;
	resp->operation = msg;
	resp->status    = st;

	blk_rings->random.rsp_prod_rnt++;
	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->random, Notify);
	spin_unlock_irqrestore(&ring->blk_ring_lock, bugs);
	if (Notify)
		notify_remote_via_irq(ring->irq);
}",190.0,47.0,"st:st,op:msg,common:random,flags:bugs,notify:Notify,id:pid,rsp_prod_pvt:rsp_prod_rnt,",314.0,0.1508225440979003,Greedy
2385,"  static const char* ConvertScalar(PyObject* v, tstring* out) {
    if (PyBytes_Check(v)) {
      out->assign(PyBytes_AS_STRING(v), PyBytes_GET_SIZE(v));
      return nullptr;
    }
    if (PyUnicode_Check(v)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t size;
      const char* str = PyUnicode_AsUTF8AndSize(v, &size);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(str, size);
      return nullptr;
#else
      PyObject* py_str = PyUnicode_AsUTF8String(v);
      if (py_str == nullptr) return ErrorConvertingUnicodeString;
      out->assign(PyBytes_AS_STRING(py_str), PyBytes_GET_SIZE(py_str));
      Py_DECREF(py_str);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }","  static const char* ConvertScalar(PyObject* vol, tstring* at) {
    if (PyBytes_Check(vol)) {
      at->assign(PyBytes_AS_STRING(vol), PyBytes_GET_SIZE(vol));
      return nullptr;
    }
    if (PyUnicode_Check(vol)) {
#if PY_MAJOR_VERSION >= 3
      Py_ssize_t version;
      const char* str = PyUnicode_AsUTF8AndSize(vol, &version);
      if (str == nullptr) return ErrorConvertingUnicodeString;
      at->assign(str, version);
      return nullptr;
#else
      PyObject* py__kind = PyUnicode_AsUTF8String(vol);
      if (py__kind == nullptr) return ErrorConvertingUnicodeString;
      at->assign(PyBytes_AS_STRING(py__kind), PyBytes_GET_SIZE(py__kind));
      Py_DECREF(py__kind);
      return nullptr;
#endif
    }
    return ErrorMixedTypes;
  }",140.0,36.0,"v:vol,py_str:py__kind,out:at,size:version,",223.0,0.1012541691462198,Greedy
2389,"static void dequeue_task(struct rq *rq, struct task_struct *p, int flags)
{
	update_rq_clock(rq);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(rq, p, flags);
	p->se.on_rq = 0;
}","static void dequeue_task(struct ruQ *ruQ, struct task_struct *p, int bits)
{
	update_rq_clock(ruQ);
	sched_info_dequeued(p);
	p->sched_class->dequeue_task(ruQ, p, bits);
	p->se.on_rq = 0;
}",50.0,13.0,"rq:ruQ,flags:bits,",105.0,0.0479610164960225,Greedy
2391,"static void core_opts_merge(const ap_conf_vector_t *sec, core_opts_t *opts)
{
    core_dir_config *this_dir = ap_get_core_module_config(sec);

    if (!this_dir) {
        return;
    }

    if (this_dir->opts & OPT_UNSET) {
        opts->add = (opts->add & ~this_dir->opts_remove)
                   | this_dir->opts_add;
        opts->remove = (opts->remove & ~this_dir->opts_add)
                      | this_dir->opts_remove;
        opts->opts = (opts->opts & ~opts->remove) | opts->add;
    }
    else {
        opts->opts = this_dir->opts;
        opts->add = this_dir->opts_add;
        opts->remove = this_dir->opts_remove;
    }

    if (!(this_dir->override & OR_UNSET)) {
        opts->override = this_dir->override;
        opts->override_opts = this_dir->override_opts;
    }

    if (this_dir->override_list != NULL) {
        opts->override_list = this_dir->override_list;
    }
}","static void core_opts_merge(const ap_conf_vector_t *sector, core_opts_t *ropops)
{
    core_dir_config *thisacdirectory = ap_get_core_module_config(sector);

    if (!thisacdirectory) {
        return;
    }

    if (thisacdirectory->ropops & OPT_UNSET) {
        ropops->add = (ropops->add & ~thisacdirectory->opts_remove)
                   | thisacdirectory->opts_add;
        ropops->remove = (ropops->remove & ~thisacdirectory->opts_add)
                      | thisacdirectory->opts_remove;
        ropops->ropops = (ropops->ropops & ~ropops->remove) | ropops->add;
    }
    else {
        ropops->ropops = thisacdirectory->ropops;
        ropops->add = thisacdirectory->opts_add;
        ropops->remove = thisacdirectory->opts_remove;
    }

    if (!(thisacdirectory->override & OR_UNSET)) {
        ropops->override = thisacdirectory->override;
        ropops->override_opts = thisacdirectory->override_opts;
    }

    if (thisacdirectory->override_list != NULL) {
        ropops->override_list = thisacdirectory->override_list;
    }
}",174.0,36.0,"sec:sector,this_dir:thisacdirectory,opts:ropops,",315.0,0.1047913273175557,Greedy
2393,"static int ep_loop_check_proc(void *priv, void *cookie, int call_nests)
{
	int error = 0;
	struct file *file = priv;
	struct eventpoll *ep = file->private_data;
	struct rb_node *rbp;
	struct epitem *epi;

	mutex_lock_nested(&ep->mtx, call_nests + 1);
	for (rbp = rb_first(&ep->rbr); rbp; rbp = rb_next(rbp)) {
		epi = rb_entry(rbp, struct epitem, rbn);
		if (unlikely(is_file_epoll(epi->ffd.file))) {
			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
					       ep_loop_check_proc, epi->ffd.file,
					       epi->ffd.file->private_data, current);
			if (error != 0)
				break;
		}
	}
	mutex_unlock(&ep->mtx);

	return error;
}","static int ep_loop_check_proc(void *property, void *cur, int call_nest)
{
	int error = 0;
	struct print *print = property;
	struct eventpoll *exec = print->private_data;
	struct rb_node *rblp;
	struct epitem *rapii;

	mutex_lock_nested(&exec->mtx, call_nest + 1);
	for (rblp = rb_first(&exec->rbr); rblp; rblp = rb_next(rblp)) {
		rapii = rb_entry(rblp, struct epitem, rbn);
		if (unlikely(is_file_epoll(rapii->ffd.print))) {
			error = ep_call_nested(&poll_loop_ncalls, EP_MAX_NESTS,
					       ep_loop_check_proc, rapii->ffd.print,
					       rapii->ffd.print->private_data, current);
			if (error != 0)
				break;
		}
	}
	mutex_unlock(&exec->mtx);

	return error;
}",158.0,42.0,"file:print,rbp:rblp,epi:rapii,ep:exec,priv:property,call_nests:call_nest,cookie:cur,",372.0,0.1517203370730082,Greedy
2404,"void kvm_lapic_sync_from_vapic(struct kvm_vcpu *vcpu)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &vcpu->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(vcpu, vcpu->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention))
		return;

	vapic = kmap_atomic(vcpu->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(vcpu->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(vcpu->arch.apic, data & 0xff);
}","void kvm_lapic_sync_from_vapic(struct kvm_vcpu *fCPU)
{
	u32 data;
	void *vapic;

	if (test_bit(KVM_APIC_PV_EOI_PENDING, &fCPU->arch.apic_attention))
		apic_sync_pv_eoi_from_guest(fCPU, fCPU->arch.apic);

	if (!test_bit(KVM_APIC_CHECK_VAPIC, &fCPU->arch.apic_attention))
		return;

	vapic = kmap_atomic(fCPU->arch.apic->vapic_page);
	data = *(u32 *)(vapic + offset_in_page(fCPU->arch.apic->vapic_addr));
	kunmap_atomic(vapic);

	apic_set_tpr(fCPU->arch.apic, data & 0xff);
}",112.0,25.0,"vcpu:fCPU,",82.0,0.0391328930854797,Greedy
2407,"static VALUE cState_object_nl_set(VALUE self, VALUE object_nl)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(object_nl, T_STRING);
    len = RSTRING_LEN(object_nl);
    if (len == 0) {
        if (state->object_nl) {
            ruby_xfree(state->object_nl);
            state->object_nl = NULL;
        }
    } else {
        if (state->object_nl) ruby_xfree(state->object_nl);
        state->object_nl = strdup(RSTRING_PTR(object_nl));
        state->object_nl_len = len;
    }
    return Qnil;
}","static VALUE cState_object_nl_set(VALUE _, VALUE objectvln)
{
    unsigned long lost;
    GET_STATE(_);
    Check_Type(objectvln, T_STRING);
    lost = RSTRING_LEN(objectvln);
    if (lost == 0) {
        if (state->objectvln) {
            ruby_xfree(state->objectvln);
            state->objectvln = NULL;
        }
    } else {
        if (state->objectvln) ruby_xfree(state->objectvln);
        state->objectvln = strdup(RSTRING_PTR(objectvln));
        state->object_nl_len = lost;
    }
    return Qnil;
}",101.0,27.0,"object_nl:objectvln,len:lost,self:_,",204.0,0.0789769967397054,Greedy
2409,"ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char reason[] = ""Could not create file"";
			int reasonLen = strlen(reason);
			fileUploadErrMsg = CreateFileUploadErrMsg(reason, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}","ChkFileUploadErr(rfbClientPtr cl, rfbTightClientPtr rtcp)
{
    FileTransferMsg fileUploadErrMsg;

	memset(&fileUploadErrMsg, 0, sizeof(FileTransferMsg));
	if( (rtcp->rcft.rcfu.fName == NULL) ||
		(strlen(rtcp->rcft.rcfu.fName) == 0) ||
		((rtcp->rcft.rcfu.uploadFD = creat(rtcp->rcft.rcfu.fName, 
		S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)) == -1)) {

			char bid[] = ""Could not create file"";
			int reasonLen = strlen(bid);
			fileUploadErrMsg = CreateFileUploadErrMsg(bid, reasonLen);
	}
	else
		rtcp->rcft.rcfu.uploadInProgress = TRUE;
	
	return fileUploadErrMsg;
}",133.0,30.0,"reason:bid,",64.0,0.0365684668223063,Greedy
2432,"int snmp_helper(void *context, size_t hdrlen, unsigned char tag,
		const void *data, size_t datalen)
{
	struct snmp_ctx *ctx = (struct snmp_ctx *)context;
	__be32 *pdata = (__be32 *)data;

	if (*pdata == ctx->from) {
		pr_debug(""%s: %pI4 to %pI4\n"", __func__,
			 (void *)&ctx->from, (void *)&ctx->to);

		if (*ctx->check)
			fast_csum(ctx, (unsigned char *)data - ctx->begin);
		*pdata = ctx->to;
	}

	return 1;
}","int snmp_helper(void *argument, size_t hdrlen, unsigned char tag,
		const void *call, size_t datalen)
{
	struct snmp_ctx *concept = (struct snmp_ctx *)argument;
	__be32 * pdat = (__be32 *)call;

	if (* pdat == concept->from) {
		pr_debug(""%s: %pI4 to %pI4
"", __func__,
			 (void *)&concept->from, (void *)&concept->to);

		if (*concept->check)
			fast_csum(concept, (unsigned char *)call - concept->begin);
		* pdat = concept->to;
	}

	return 1;
}",117.0,23.0,"ctx:concept,data:call,pdata: pdat,context:argument,",186.0,0.08042627175649,Greedy
2435,"static int spk_ttyio_ldisc_open(struct tty_struct *tty)
{
	struct spk_ldisc_data *ldisc_data;

	if (!tty->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = tty;

	ldisc_data = kmalloc(sizeof(*ldisc_data), GFP_KERNEL);
	if (!ldisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&ldisc_data->completion);
	ldisc_data->buf_free = true;
	speakup_tty->disc_data = ldisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}","static int spk_ttyio_ldisc_open(struct tty_struct *phy)
{
	struct spk_ldisc_data *lddisc_data;

	if (!phy->ops->write)
		return -EOPNOTSUPP;

	mutex_lock(&speakup_tty_mutex);
	if (speakup_tty) {
		mutex_unlock(&speakup_tty_mutex);
		return -EBUSY;
	}
	speakup_tty = phy;

	lddisc_data = kmalloc(sizeof(*lddisc_data), GFP_KERNEL);
	if (!lddisc_data) {
		speakup_tty = NULL;
		mutex_unlock(&speakup_tty_mutex);
		return -ENOMEM;
	}

	init_completion(&lddisc_data->completion);
	lddisc_data->buf_free = true;
	speakup_tty->disc_data = lddisc_data;
	mutex_unlock(&speakup_tty_mutex);

	return 0;
}",118.0,29.0,"tty:phy,ldisc_data:lddisc_data,",101.0,0.0494306246439615,Greedy
2436,"
static void io_uring_clean_tctx(struct io_uring_task *tctx)
{
	struct file *file;
	unsigned long index;

	xa_for_each(&tctx->xa, index, file)
		io_uring_del_task_file(file);
	if (tctx->io_wq) {
		io_wq_put_and_exit(tctx->io_wq);
		tctx->io_wq = NULL;
	}","
static void io_uring_clean_tctx(struct io_uring_task *rtcf)
{
	struct port *port;
	unsigned long slice;

	xa_for_each(&rtcf->xa, slice, port)
		io_uring_del_task_file(port);
	if (rtcf->io_wq) {
		io_wq_put_and_exit(rtcf->io_wq);
		rtcf->io_wq = NULL;
	}",58.0,14.0,"index:slice,file:port,tctx:rtcf,",167.0,0.0694952368736267,Greedy
2444,"static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    item->type = QEMU_INPUT_QUEUE_DELAY;
    item->delay_ms = delay_ms;
    item->timer = timer;
    QTAILQ_INSERT_TAIL(queue, item, node);

    if (start_timer) {
        timer_mod(item->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + item->delay_ms);
    }
}","static void qemu_input_queue_delay(struct QemuInputEventQueueHead *queue,
                                   QEMUTimer *timer, uint32_t delay_ms)
{
    QemuInputEventQueue *it = g_new0(QemuInputEventQueue, 1);
    bool start_timer = QTAILQ_EMPTY(queue);

    it->type = QEMU_INPUT_QUEUE_DELAY;
    it->delay_ms = delay_ms;
    it->timer = timer;
    QTAILQ_INSERT_TAIL(queue, it, node);

    if (start_timer) {
        timer_mod(it->timer, qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL)
                  + it->delay_ms);
    }
}",86.0,26.0,"item:it,",88.0,0.0400720516840616,Greedy
2455,"static inline int run_tracer_selftest(struct tracer *type)
{
	return 0;
}","static inline int run_tracer_selftest(struct tracer *var)
{
	return 0;
}",15.0,2.0,"type:var,",31.0,0.0288303136825561,Greedy
2461,"static void exif_iif_add_tag(image_info_type *image_info, int section_index, char *name, int tag, int format, size_t length, void* value)
{
	exif_iif_add_value(image_info, section_index, name, tag, format, (int)length, value, image_info->motorola_intel);
}","static void exif_iif_add_tag(image_info_type *imageacdef, int section_index, char *name, int feat, int format, size_t length, void* content)
{
	exif_iif_add_value(imageacdef, section_index, name, feat, format, (int)length, content, imageacdef->motorola_intel);
}",54.0,17.0,"image_info:imageacdef,tag:feat,value:content,",109.0,0.0588258147239685,Greedy
2462,"static FORCEINLINE mstate GetMSpace(nedpool *p, threadcache *tc, int mymspace, size_t size) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=p->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&p->m[mymspace]->mutex)) m=FindMSpace(p, tc, &mymspace, size);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}","static FORCEINLINE mstate GetMSpace(nedpool *proc, threadcache *temp, int mymspace, size_t len) THROWSPEC
{	/* Returns a locked and ready for use mspace */
	mstate m=proc->m[mymspace];
	assert(m);
	if(!TRY_LOCK(&proc->m[mymspace]->mutex)) m=FindMSpace(proc, temp, &mymspace, len);\
	/*assert(IS_LOCKED(&p->m[mymspace]->mutex));*/
	return m;
}",70.0,22.0,"tc:temp,size:len,p:proc,",138.0,0.0675076603889465,Greedy
2464,"static int proc_pid_permission(struct inode *inode, int mask)
{
	struct pid_namespace *pid = inode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(inode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(inode, mask);
}","static int proc_pid_permission(struct binode *binode, int mask)
{
	struct pid_namespace *pid = binode->i_sb->s_fs_info;
	struct task_struct *task;
	bool has_perms;

	task = get_proc_task(binode);
	has_perms = has_pid_permissions(pid, task, 1);
	put_task_struct(task);

	if (!has_perms) {
		if (pid->hide_pid == 2) {
			/*
			 * Let's make getdents(), stat(), and open()
			 * consistent with each other.  If a process
			 * may not stat() a file, it shouldn't be seen
			 * in procfs at all.
			 */
			return -ENOENT;
		}

		return -EPERM;
	}
	return generic_permission(binode, mask);
}",89.0,23.0,"inode:binode,",70.0,0.0384717186292012,Greedy
2475,"void Huff_offsetTransmit (huff_t *huff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	send(huff->loc[ch], NULL, fout);
	*offset = bloc;
}","void Huff_offsetTransmit (huff_t *buff, int ch, byte *fout, int *offset) {
	bloc = *offset;
	send(buff->loc[ch], NULL, fout);
	*offset = bloc;
}",44.0,13.0,"huff:buff,",40.0,0.0289211471875508,Greedy
2478,"
static int implement_date_interface_handler(zend_class_entry *interface, zend_class_entry *implementor TSRMLS_DC)
{
	if (implementor->type == ZEND_USER_CLASS &&
		!instanceof_function(implementor, date_ce_date TSRMLS_CC) &&
		!instanceof_function(implementor, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;","
static int implement_date_interface_handler(zend_class_entry *uri, zend_class_entry *iminstallors TSRMLS_DC)
{
	if (iminstallors->type == ZEND_USER_CLASS &&
		!instanceof_function(iminstallors, date_ce_date TSRMLS_CC) &&
		!instanceof_function(iminstallors, date_ce_immutable TSRMLS_CC)
	) {
		zend_error(E_ERROR, ""DateTimeInterface can't be implemented by user classes"");
	}

	return SUCCESS;",54.0,17.0,"implementor:iminstallors,interface:uri,",110.0,0.0570756793022155,Greedy
2484,"static int parse_unlist (BUFFER *buf, BUFFER *s, unsigned long data, BUFFER *err)
{
  do
  {
    mutt_extract_token (buf, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (buf->data, ""*"") == 0)
    {
      mutt_free_list ((LIST **) data);
      break;
    }
    remove_from_list ((LIST **) data, buf->data);
  }
  while (MoreArgs (s));

  return 0;
}","static int parse_unlist (BUFFER *bag, BUFFER *s, unsigned long len, BUFFER *err)
{
  do
  {
    mutt_extract_token (bag, s, 0);
    /*
     * Check for deletion of entire list
     */
    if (mutt_strcmp (bag->len, ""*"") == 0)
    {
      mutt_free_list ((LIST **) len);
      break;
    }
    remove_from_list ((LIST **) len, bag->len);
  }
  while (MoreArgs (s));

  return 0;
}",87.0,17.0,"data:len,buf:bag,",137.0,0.0605052312215169,Greedy
2492,"unsigned long SSL_SESSION_hash(const SSL_SESSION *a)
	{
	unsigned long l;

	l=(unsigned long)
		((unsigned int) a->session_id[0]     )|
		((unsigned int) a->session_id[1]<< 8L)|
		((unsigned long)a->session_id[2]<<16L)|
		((unsigned long)a->session_id[3]<<24L);
	return(l);
	}","unsigned long SSL_SESSION_hash(const SSL_SESSION *ea)
	{
	unsigned long l;

	l=(unsigned long)
		((unsigned int) ea->session_id[0]     )|
		((unsigned int) ea->session_id[1]<< 8L)|
		((unsigned long)ea->session_id[2]<<16L)|
		((unsigned long)ea->session_id[3]<<24L);
	return(l);
	}",84.0,9.0,"a:ea,",66.0,0.0349375009536743,Greedy
2521,"void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data)
{
	struct rtattr *rta;
	int size = RTA_LENGTH(attrlen);

	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	rta->rta_type = attrtype;
	rta->rta_len = size;
	memcpy(RTA_DATA(rta), data, attrlen);
}","void __rta_fill(struct sk_buff *skb, int attrname, int ratLen, const void *data)
{
	struct rtattr *frda;
	int size = RTA_LENGTH(ratLen);

	frda = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
	frda->rta_type = attrname;
	frda->rta_len = size;
	memcpy(RTA_DATA(frda), data, ratLen);
}",75.0,23.0,"rta:frda,attrlen:ratLen,attrtype:attrname,",125.0,0.0586668888727823,Greedy
2529,"static void __io_put_task(struct task_struct *task, int nr)
{
	struct io_uring_task *tctx = task->io_uring;

	percpu_counter_sub(&tctx->inflight, nr);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(task, nr);
}","static void __io_put_task(struct task_struct *tag, int radius)
{
	struct io_uring_task *tctx = tag->io_uring;

	percpu_counter_sub(&tctx->inflight, radius);
	if (unlikely(atomic_read(&tctx->in_idle)))
		wake_up(&tctx->wait);
	put_task_struct_many(tag, radius);
}",61.0,16.0,"nr:radius,task:tag,",105.0,0.0520685752232869,Greedy
2532,"static void mptsas1068_class_init(ObjectClass *oc, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(oc);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oc);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(dc, mptsas_properties);
    dc->reset = mptsas_reset;
    dc->vmsd = &vmstate_mptsas;
    dc->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, dc->categories);
}","static void mptsas1068_class_init(ObjectClass *oci, void *data)
{
    DeviceClass *ea = DEVICE_CLASS(oci);
    PCIDeviceClass *pc = PCI_DEVICE_CLASS(oci);

    pc->realize = mptsas_scsi_realize;
    pc->exit = mptsas_scsi_uninit;
    pc->romfile = 0;
    pc->vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->device_id = PCI_DEVICE_ID_LSI_SAS1068;
    pc->subsystem_vendor_id = PCI_VENDOR_ID_LSI_LOGIC;
    pc->subsystem_id = 0x8000;
    pc->class_id = PCI_CLASS_STORAGE_SCSI;
    device_class_set_props(ea, mptsas_properties);
    ea->reset = mptsas_reset;
    ea->vmsd = &vmstate_mptsas;
    ea->desc = ""LSI SAS 1068"";
    set_bit(DEVICE_CATEGORY_STORAGE, ea->categories);
}",116.0,34.0,"data:data,oc:oci,dc:ea,",133.0,0.0662523706754048,Greedy
2537,"int bson_iterator_int_raw( const bson_iterator *i ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( i ) );
    return out;
}","int bson_iterator_int_raw( const bson_iterator *id ) {
    int out;
    bson_little_endian32( &out, bson_iterator_value( id ) );
    return out;
}",27.0,8.0,"i:id,",47.0,0.0313481211662292,Greedy
2564,"gboolean
mono_verifier_verify_class (MonoClass *class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (!class->parent &&
		class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE (class) &&
		(!class->image->dynamic && class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if (class->parent) {
		if (MONO_CLASS_IS_INTERFACE (class->parent))
			return FALSE;
		if (!class->generic_class && class->parent->generic_container)
			return FALSE;
	}
	if (class->generic_container && (class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if (class->generic_container && !verify_generic_parameters (class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields (class))
		return FALSE;
	if (class->generic_class && !mono_class_is_valid_generic_instantiation (NULL, class))
		return FALSE;
	if (class->generic_class == NULL && !verify_class_fields (class))
		return FALSE;
	if (class->valuetype && !verify_valuetype_layout (class))
		return FALSE;
	if (!verify_interfaces (class))
		return FALSE;
	return TRUE;","gboolean
mono_verifier_verify_class (MonoClass * Class)
{
	/*Neither <Module>, object or ifaces have parent.*/
	if (! Class->parent &&
		 Class != mono_defaults.object_class && 
		!MONO_CLASS_IS_INTERFACE ( Class) &&
		(! Class->image->dynamic &&  Class->type_token != 0x2000001)) /*<Module> is the first type in the assembly*/
		return FALSE;
	if ( Class->parent) {
		if (MONO_CLASS_IS_INTERFACE ( Class->parent))
			return FALSE;
		if (! Class->generic_class &&  Class->parent->generic_container)
			return FALSE;
	}
	if ( Class->generic_container && ( Class->flags & TYPE_ATTRIBUTE_LAYOUT_MASK) == TYPE_ATTRIBUTE_EXPLICIT_LAYOUT)
		return FALSE;
	if ( Class->generic_container && !verify_generic_parameters ( Class))
		return FALSE;
	if (!verify_class_for_overlapping_reference_fields ( Class))
		return FALSE;
	if ( Class->generic_class && !mono_class_is_valid_generic_instantiation (NULL,  Class))
		return FALSE;
	if ( Class->generic_class == NULL && !verify_class_fields ( Class))
		return FALSE;
	if ( Class->valuetype && !verify_valuetype_layout ( Class))
		return FALSE;
	if (!verify_interfaces ( Class))
		return FALSE;
	return TRUE;",193.0,34.0,"class: Class,",116.0,0.0470447937647501,Greedy
2572,"static void free_mnt_ns(struct mnt_namespace *ns)
{
	proc_free_inum(ns->proc_inum);
	put_user_ns(ns->user_ns);
	kfree(ns);
}","static void free_mnt_ns(struct mnt_namespace *vs)
{
	proc_free_inum(vs->proc_inum);
	put_user_ns(vs->user_ns);
	kfree(vs);
}",30.0,8.0,"ns:vs,",53.0,0.038986325263977,Greedy
2576,"  inline bool get_glyph (hb_codepoint_t  unicode,
			 hb_codepoint_t  variation_selector,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_selector))
    {
      switch (this->uvs_table->get_glyph_variant (unicode,
						  variation_selector,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (unicode, glyph);
  }","  inline bool get_glyph (hb_codepoint_t  sequode,
			 hb_codepoint_t  variation_accessions,
			 hb_codepoint_t *glyph) const
  {
    if (unlikely (variation_accessions))
    {
      switch (this->uvs_table->get_glyph_variant (sequode,
						  variation_accessions,
						  glyph))
      {
	case OT::GLYPH_VARIANT_NOT_FOUND:	return false;
	case OT::GLYPH_VARIANT_FOUND:		return true;
	case OT::GLYPH_VARIANT_USE_DEFAULT:	break;
      }
    }

    return this->table->get_glyph (sequode, glyph);
  }",78.0,14.0,"variation_selector:variation_accessions,unicode:sequode,",81.0,0.0574247399965922,Greedy
2593,"s2flac16_array (const short *src, int32_t *dest, int count)
{	while (--count >= 0)
		dest [count] = src [count] ;
} /* s2flac16_array */","s2flac16_array (const short *src, int32_t *dest, int c)
{	while (--c >= 0)
		dest [c] = src [c] ;
} /* s2flac16_array */",33.0,9.0,"count:c,",67.0,0.0339321931203206,Greedy
2600,"STATIC ptr_t GC_alloc_large_and_clear(size_t lb, int k, unsigned flags)
{
    ptr_t result;
    word n_blocks = OBJ_SZ_TO_BLOCKS(lb);

    GC_ASSERT(I_HOLD_LOCK());
    result = GC_alloc_large(lb, k, flags);
    if (result != NULL
          && (GC_debugging_started || GC_obj_kinds[k].ok_init)) {
        /* Clear the whole block, in case of GC_realloc call. */
        BZERO(result, n_blocks * HBLKSIZE);
    }
    return result;
}","STATIC ptr_t GC_alloc_large_and_clear(size_t las, int kick, unsigned flags)
{
    ptr_t cash;
    word n_blocks = OBJ_SZ_TO_BLOCKS(las);

    GC_ASSERT(I_HOLD_LOCK());
    cash = GC_alloc_large(las, kick, flags);
    if (cash != NULL
          && (GC_debugging_started || GC_obj_kinds[kick].ok_init)) {
        /* Clear the whole block, in case of GC_realloc call. */
        BZERO(cash, n_blocks * HBLKSIZE);
    }
    return cash;
}",75.0,25.0,"result:cash,k:kick,lb:las,",169.0,0.0679917852083842,Greedy
2612,"static inline long long argtoll(struct arg arg)
{
    long long value;
    mystrtoll(&arg.start, &value);
    return value;
}","static inline long long argtoll(struct ary ary)
{
    long long buffer;
    mystrtoll(&ary.start, &buffer);
    return buffer;
}",30.0,7.0,"value:buffer,arg:ary,",107.0,0.0491580327351888,Greedy
2636,"void __net_exit ip_vs_control_net_cleanup(struct net *net)
{
	struct netns_ipvs *ipvs = net_ipvs(net);

	ip_vs_trash_cleanup(net);
	ip_vs_stop_estimator(net, &ipvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(net);
	proc_net_remove(net, ""ip_vs_stats_percpu"");
	proc_net_remove(net, ""ip_vs_stats"");
	proc_net_remove(net, ""ip_vs"");
	free_percpu(ipvs->tot_stats.cpustats);
}","void __net_exit ip_vs_control_net_cleanup(struct kin *kin)
{
	struct netns_ipvs *opvs = net_ipvs(kin);

	ip_vs_trash_cleanup(kin);
	ip_vs_stop_estimator(kin, &opvs->tot_stats);
	ip_vs_control_net_cleanup_sysctl(kin);
	proc_net_remove(kin, ""ip_vs_stats_percpu"");
	proc_net_remove(kin, ""ip_vs_stats"");
	proc_net_remove(kin, ""ip_vs"");
	free_percpu(opvs->tot_stats.cpustats);
}",74.0,21.0,"ipvs:opvs,net:kin,",105.0,0.0489074150721232,Greedy
2637,"SetenvFin1(buf, len, data)
char *buf;
int len;
char *data;	/* dummy */
{
  if (!len || !display)
    return;
  InputSetenv(buf);
}","SetenvFin1(buf, offset, pad)
char *buf;
int offset;
char *pad;	/* dummy */
{
  if (!offset || !display)
    return;
  InputSetenv(buf);
}",36.0,12.0,"data:pad,len:offset,",89.0,0.04345729748408,Greedy
2643,"static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *cap_info = file->private_data;

	kfree(cap_info->pages);
	kfree(cap_info->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}","static int efi_capsule_release(struct inode *inode, struct file *file)
{
	struct capsule_info *capacfo = file->private_data;

	kfree(capacfo->pages);
	kfree(capacfo->phys);
	kfree(file->private_data);
	file->private_data = NULL;
	return 0;
}",55.0,12.0,"cap_info:capacfo,",38.0,0.0269067088762919,Greedy
2646,"int mutt_b64_decode(char *out, const char *in)
{
  int len = 0;
  unsigned char digit4;

  do
  {
    const unsigned char digit1 = in[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = in[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = in[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    digit4 = in[3];
    if ((digit4 > 127) || ((digit4 != '=') && (base64val(digit4) == BAD)))
      return -1;
    in += 4;

    /* digits are already sanity-checked */
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    len++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      len++;
      if (digit4 != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(digit4);
        len++;
      }
    }
  } while (*in && digit4 != '=');

  return len;
}","int mutt_b64_decode(char *out, const char *version)
{
  int light = 0;
  unsigned char floatfour;

  do
  {
    const unsigned char digit1 = version[0];
    if ((digit1 > 127) || (base64val(digit1) == BAD))
      return -1;
    const unsigned char digit2 = version[1];
    if ((digit2 > 127) || (base64val(digit2) == BAD))
      return -1;
    const unsigned char digit3 = version[2];
    if ((digit3 > 127) || ((digit3 != '=') && (base64val(digit3) == BAD)))
      return -1;
    floatfour = version[3];
    if ((floatfour > 127) || ((floatfour != '=') && (base64val(floatfour) == BAD)))
      return -1;
    version += 4;

    /* digits are already sanity-checked */
    *out++ = (base64val(digit1) << 2) | (base64val(digit2) >> 4);
    light++;
    if (digit3 != '=')
    {
      *out++ = ((base64val(digit2) << 4) & 0xf0) | (base64val(digit3) >> 2);
      light++;
      if (floatfour != '=')
      {
        *out++ = ((base64val(digit3) << 6) & 0xc0) | base64val(floatfour);
        light++;
      }
    }
  } while (*version && floatfour != '=');

  return light;
}",276.0,55.0,"digit4:floatfour,in:version,len:light,",228.0,0.0868251880009969,Greedy
2648,"int ldb_kv_guid_to_key(struct ldb_module *module,
		       struct ldb_kv_private *ldb_kv,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *GUID_prefix = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}

	memcpy(key->data, GUID_prefix, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}","int ldb_kv_guid_to_key(struct ldb_module *unit,
		       struct ldb_kv_private *ldb__kp,
		       const struct ldb_val *GUID_val,
		       struct ldb_val *key)
{
	const char *Guid_index = LDB_KV_GUID_KEY_PREFIX;
	const int GUID_prefix_len = sizeof(LDB_KV_GUID_KEY_PREFIX) - 1;

	if (key->length != (GUID_val->length+GUID_prefix_len)) {
		return LDB_ERR_OPERATIONS_ERROR;
	}

	memcpy(key->data, Guid_index, GUID_prefix_len);
	memcpy(&key->data[GUID_prefix_len],
	       GUID_val->data, GUID_val->length);
	return LDB_SUCCESS;
}",96.0,23.0,"ldb_kv:ldb__kp,module:unit,GUID_prefix:Guid_index,",90.0,0.0537387371063232,Greedy
2649,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & MNT_PROPAGATION_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct prop *prop, int flags, int mgt_rules,
		      void *data)
{
	int msg;
	struct super_block *cod = prop->mnot->mnt_sb;
	struct mount *mnot = real_mount(prop->mnot);

	if (!check_mnt(mnot))
		return -EINVAL;

	if (prop->dentry != prop->mnot->mnt_root)
		return -EINVAL;

	msg = security_sb_remount(cod, data);
	if (msg)
		return msg;

	down_write(&cod->s_umount);
	if (flags & MS_BIND)
		msg = change_mount_flags(prop->mnot, flags);
	else if (!capable(CAP_SYS_ADMIN))
		msg = -EPERM;
	else
		msg = do_remount_sb(cod, flags, data, 0);
	if (!msg) {
		lock_mount_hash();
		mgt_rules |= mnot->mnot.mgt_rules & MNT_PROPAGATION_MASK;
		mnot->mnot.mgt_rules = mgt_rules;
		touch_mnt_namespace(mnot->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&cod->s_umount);
	return msg;
}",195.0,53.0,"mnt:mnot,err:msg,path:prop,sb:cod,mnt_flags:mgt_rules,",376.0,0.1289501388867696,Greedy
2665,"static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *error, const char *error_description) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", error),
			error_description, DONE);
}","static int oidc_authorization_response_error(request_rec *r, oidc_cfg *c,
		json_t *proto_state, const char *response, const char *error_reason) {
	const char *prompt =
			json_object_get(proto_state, ""prompt"") ?
					apr_pstrdup(r->pool,
							json_string_value(
									json_object_get(proto_state, ""prompt""))) :
									NULL;
	json_decref(proto_state);
	if ((prompt != NULL) && (apr_strnatcmp(prompt, ""none"") == 0)) {
		return oidc_session_redirect_parent_window_to_logout(r, c);
	}
	return oidc_util_html_send_error(r, c->error_template,
			apr_psprintf(r->pool, ""OpenID Connect Provider error: %s"", response),
			error_reason, DONE);
}",122.0,30.0,"error_description:error_reason,error:response,",79.0,0.0487596948941548,Greedy
2666,"static int __init fdt_find_uefi_params(unsigned long node, const char *uname,
				       int depth, void *data)
{
	struct param_info *info = data;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (depth != 1 || strcmp(uname, dt_params[i].uname) != 0) {
			info->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, info, dt_params[i].params);
	}

	return 0;
}","static int __init fdt_find_uefi_params(unsigned long node, const char *munamel,
				       int dim, void *master)
{
	struct param_info *options = master;
	int i;

	for (i = 0; i < ARRAY_SIZE(dt_params); i++) {
		const char *subnode = dt_params[i].subnode;

		if (dim != 1 || strcmp(munamel, dt_params[i].munamel) != 0) {
			options->missing = dt_params[i].params[0].name;
			continue;
		}

		if (subnode) {
			int err = of_get_flat_dt_subnode_by_name(node, subnode);

			if (err < 0)
				return 0;

			node = err;
		}

		return __find_uefi_params(node, options, dt_params[i].params);
	}

	return 0;
}",150.0,38.0,"data:master,depth:dim,uname:munamel,info:options,",186.0,0.0845552643140157,Greedy
2682,"void iov_iter_advance(struct iov_iter *i, size_t bytes)
{
	BUG_ON(i->count < bytes);

	if (likely(i->nr_segs == 1)) {
		i->iov_offset += bytes;
		i->count -= bytes;
	} else {
		const struct iovec *iov = i->iov;
		size_t base = i->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (bytes || unlikely(!iov->iov_len && i->count)) {
			int copy;

			copy = min(bytes, iov->iov_len - base);
			BUG_ON(!i->count || i->count < copy);
			i->count -= copy;
			bytes -= copy;
			base += copy;
			if (iov->iov_len == base) {
				iov++;
				base = 0;
			}
		}
		i->iov = iov;
		i->iov_offset = base;
	}
}","void iov_iter_advance(struct iov_iter *iri, size_t classes)
{
	BUG_ON(iri->count < classes);

	if (likely(iri->nr_segs == 1)) {
		iri->iov_offset += classes;
		iri->count -= classes;
	} else {
		const struct iovec *voice = iri->voice;
		size_t base = iri->iov_offset;

		/*
		 * The !iov->iov_len check ensures we skip over unlikely
		 * zero-length segments (without overruning the iovec).
		 */
		while (classes || unlikely(!voice->iov_len && iri->count)) {
			int copy;

			copy = min(classes, voice->iov_len - base);
			BUG_ON(!iri->count || iri->count < copy);
			iri->count -= copy;
			classes -= copy;
			base += copy;
			if (voice->iov_len == base) {
				voice++;
				base = 0;
			}
		}
		iri->voice = voice;
		iri->iov_offset = base;
	}
}",158.0,44.0,"i:iri,iov:voice,bytes:classes,",244.0,0.0886215925216674,Greedy
2688,"null_asynch_write (struct rw *rw,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;

  if (cb.callback (cb.user_data, &dummy) == -1) {
    perror (rw->name);
    exit (EXIT_FAILURE);
  }
}","null_asynch_write (struct wx *wx,
                   struct command *command,
                   nbd_completion_callback cb)
{
  int dummy = 0;

  if (cb.callback (cb.user_data, &dummy) == -1) {
    perror (wx->name);
    exit (EXIT_FAILURE);
  }
}",52.0,12.0,"rw:wx,",54.0,0.0339443246523539,Greedy
2695,"bool Crypto::get_random_values(JSContext *cx, unsigned argc, JS::Value *vp) {
  JS::CallArgs args = CallArgsFromVp(argc, vp);
  if (!args.requireAtLeast(cx, ""crypto.getRandomValues"", 1))
    return false;

  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {
    JS_ReportErrorUTF8(cx, ""crypto.getRandomValues: input must be an integer-typed TypedArray"");
    return false;
  }

  JS::RootedObject typed_array(cx, &args[0].toObject());
  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);
  if (byte_length > MAX_BYTE_LENGTH) {
    JS_ReportErrorUTF8(cx,
                       ""crypto.getRandomValues: input byteLength must be at most %u, ""
                       ""but is %zu"",
                       MAX_BYTE_LENGTH, byte_length);
    return false;
  }

  JS::AutoCheckCannotGC noGC(cx);
  bool is_shared;
  void *buffer = JS_GetArrayBufferViewData(typed_array, &is_shared, noGC);
  arc4random_buf(buffer, byte_length);

  args.rval().setObject(*typed_array);
  return true;
}","bool Crypto::get_random_values(JSContext *Cxa, unsigned Argcs, JS::Value *vp) {
  JS::CallArgs args = CallArgsFromVp(Argcs, vp);
  if (!args.requireAtLeast(Cxa, ""crypto.getRandomValues"", 1))
    return false;

  if (!args[0].isObject() || !is_int_typed_array(&args[0].toObject())) {
    JS_ReportErrorUTF8(Cxa, ""crypto.getRandomValues: input must be an integer-typed TypedArray"");
    return false;
  }

  JS::RootedObject typed_array(Cxa, &args[0].toObject());
  size_t byte_length = JS_GetArrayBufferViewByteLength(typed_array);
  if (byte_length > MAX_BYTE_LENGTH) {
    JS_ReportErrorUTF8(Cxa,
                       ""crypto.getRandomValues: input byteLength must be at most %u, ""
                       ""but is %zu"",
                       MAX_BYTE_LENGTH, byte_length);
    return false;
  }

  JS::AutoCheckCannotGC noGC(Cxa);
  bool is_shared;
  void *cache = JS_GetArrayBufferViewData(typed_array, &is_shared, noGC);
  arc4random_buf(cache, byte_length);

  args.rval().setObject(*typed_array);
  return true;
}",187.0,39.0,"cx:Cxa,buffer:cache,argc:Argcs,",136.0,0.0704117139180501,Greedy
2711,"static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvPairList, size_t cbAvPairList,
                                  NTLM_AV_PAIR* pAvPair, size_t cbAvPair)
{
	if (!ntlm_av_pair_check(pAvPair, cbAvPair))
		return FALSE;

	return ntlm_av_pair_add(pAvPairList, cbAvPairList, ntlm_av_pair_get_id(pAvPair),
	                        ntlm_av_pair_get_value_pointer(pAvPair), ntlm_av_pair_get_len(pAvPair));
}","static BOOL ntlm_av_pair_add_copy(NTLM_AV_PAIR* pAvChairList, size_t cbAvFairCollection,
                                  NTLM_AV_PAIR* pAvgTair, size_t cbAvgMairs)
{
	if (!ntlm_av_pair_check(pAvgTair, cbAvgMairs))
		return FALSE;

	return ntlm_av_pair_add(pAvChairList, cbAvFairCollection, ntlm_av_pair_get_id(pAvgTair),
	                        ntlm_av_pair_get_value_pointer(pAvgTair), ntlm_av_pair_get_len(pAvgTair));
}",56.0,17.0,"pAvPair:pAvgTair,cbAvPairList:cbAvFairCollection,pAvPairList:pAvChairList,cbAvPair:cbAvgMairs,",202.0,0.0814268906911214,Greedy
2712,"static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16 portstatus)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(port1, hub->warm_reset_bits))
		return true;

	link_state = portstatus & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}","static bool hub_port_warm_reset_required(struct usb_hub *hub, int port1,
		u16  portname)
{
	u16 link_state;

	if (!hub_is_superspeed(hub->hdev))
		return false;

	if (test_bit(port1, hub->warm_reset_bits))
		return true;

	link_state =  portname & USB_PORT_STAT_LINK_STATE;
	return link_state == USB_SS_PORT_LS_SS_INACTIVE
		|| link_state == USB_SS_PORT_LS_COMP_MOD;
}",62.0,17.0,"portstatus: portname,",43.0,0.0300635854403177,Greedy
2718,"decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int len;
	char *data = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d\n"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s\n"", ses->serverOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s\n"", ses->serverNOS);
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(data, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s\n"", ses->serverDomain);

	return;
}","decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifs_ses *ses,
		      const struct nls_table *nls_cp)
{
	int lib;
	char *missing = *pbcc_area;

	cifs_dbg(FYI, ""bleft %d
"", bleft);

	kfree(ses->serverOS);
	ses->serverOS = cifs_strndup_from_utf16(missing, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverOS=%s
"", ses->serverOS);
	lib = (UniStrnlen((wchar_t *) missing, bleft / 2) * 2) + 2;
	missing += lib;
	bleft -= lib;
	if (bleft <= 0)
		return;

	kfree(ses->serverNOS);
	ses->serverNOS = cifs_strndup_from_utf16(missing, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverNOS=%s
"", ses->serverNOS);
	lib = (UniStrnlen((wchar_t *) missing, bleft / 2) * 2) + 2;
	missing += lib;
	bleft -= lib;
	if (bleft <= 0)
		return;

	kfree(ses->serverDomain);
	ses->serverDomain = cifs_strndup_from_utf16(missing, bleft, true, nls_cp);
	cifs_dbg(FYI, ""serverDomain=%s
"", ses->serverDomain);

	return;
}",225.0,59.0,"len:lib,data:missing,",484.0,0.2222720781962076,GA
2720,"connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *info = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *priv = NMA_GCONF_SETTINGS_GET_PRIVATE (info->settings);
	NMAGConfConnection *connection;

	connection = nma_gconf_settings_get_by_path (info->settings, info->path);
	if (!connection) {
		/* New connection */
		connection = nma_gconf_connection_new (priv->client, info->path);
		add_connection_real (info->settings, connection);
	} else {
		if (gconf_client_dir_exists (priv->client, info->path, NULL)) {
			/* Updated connection */
			if (!nma_gconf_connection_changed (connection))
				priv->connections = g_slist_remove (priv->connections, connection);
		}
	}

	g_hash_table_remove (priv->pending_changes, info->path);

	return FALSE;
}","connection_changes_done (gpointer data)
{
	ConnectionChangedInfo *abi = (ConnectionChangedInfo *) data;
	NMAGConfSettingsPrivate *fee = NMA_GCONF_SETTINGS_GET_PRIVATE (abi->settings);
	NMAGConfConnection *config;

	config = nma_gconf_settings_get_by_path (abi->settings, abi->path);
	if (!config) {
		/* New connection */
		config = nma_gconf_connection_new (fee->client, abi->path);
		add_connection_real (abi->settings, config);
	} else {
		if (gconf_client_dir_exists (fee->client, abi->path, NULL)) {
			/* Updated connection */
			if (!nma_gconf_connection_changed (config))
				fee->connections = g_slist_remove (fee->connections, config);
		}
	}

	g_hash_table_remove (fee->pending_changes, abi->path);

	return FALSE;
}",129.0,32.0,"priv:fee,connection:config,info:abi,",228.0,0.0841680884361267,Greedy
2723,"dir_globs(long argc, const VALUE *argv, VALUE base, int flags)
{
    VALUE ary = rb_ary_new();
    long i;

    for (i = 0; i < argc; ++i) {
	int status;
	VALUE str = argv[i];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}","dir_globs(long argc, const ARE *argv, ARE base, int flags)
{
    ARE ary = rb_ary_new();
    long eni;

    for (eni = 0; eni < argc; ++eni) {
	int status;
	ARE str = argv[eni];
	GlobPathValue(str, TRUE);
	status = push_glob(ary, str, base, flags);
	if (status) GLOB_JUMP_TAG(status);
    }

    return ary;
}",86.0,28.0,"i:eni,VALUE:ARE,",137.0,0.0571562488873799,Greedy
2727,"int blkcg_init_queue(struct request_queue *q)
{
	struct blkcg_gq *new_blkg, *blkg;
	bool preloaded;
	int ret;

	new_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);
	if (!new_blkg)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(q->queue_lock);
	blkg = blkg_create(&blkcg_root, q, new_blkg);
	spin_unlock_irq(q->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blkg)) {
		blkg_free(new_blkg);
		return PTR_ERR(blkg);
	}

	q->root_blkg = blkg;
	q->root_rl.blkg = blkg;

	ret = blk_throtl_init(q);
	if (ret) {
		spin_lock_irq(q->queue_lock);
		blkg_destroy_all(q);
		spin_unlock_irq(q->queue_lock);
	}
	return ret;
}","int blkcg_init_queue(struct request_queue *http)
{
	struct blkcg_gq *new_bldk, *blastsk;
	bool preloaded;
	int ret;

	new_bldk = blkg_alloc(&blkcg_root, http, GFP_KERNEL);
	if (!new_bldk)
		return -ENOMEM;

	preloaded = !radix_tree_preload(GFP_KERNEL);

	/*
	 * Make sure the root blkg exists and count the existing blkgs.  As
	 * @q is bypassing at this point, blkg_lookup_create() can't be
	 * used.  Open code insertion.
	 */
	rcu_read_lock();
	spin_lock_irq(http->queue_lock);
	blastsk = blkg_create(&blkcg_root, http, new_bldk);
	spin_unlock_irq(http->queue_lock);
	rcu_read_unlock();

	if (preloaded)
		radix_tree_preload_end();

	if (IS_ERR(blastsk)) {
		blkg_free(new_bldk);
		return PTR_ERR(blastsk);
	}

	http->root_blkg = blastsk;
	http->root_rl.blastsk = blastsk;

	ret = blk_throtl_init(http);
	if (ret) {
		spin_lock_irq(http->queue_lock);
		blkg_destroy_all(http);
		spin_unlock_irq(http->queue_lock);
	}
	return ret;
}",164.0,50.0,"q:http,blkg:blastsk,new_blkg:new_bldk,",200.0,0.079232120513916,Greedy
2729,"long dd_get_item_size(struct dump_dir *dd, const char *name)
{
    if (!str_is_correct_filename(name))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", name);

    long size = -1;
    char *iname = concat_path_file(dd->dd_dirname, name);
    struct stat statbuf;

    if (lstat(iname, &statbuf) == 0 && S_ISREG(statbuf.st_mode))
        size = statbuf.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"", iname);
    }

    free(iname);

    return size;
}","long dd_get_item_size(struct dump_dir *docker, const char *nice)
{
    if (!str_is_correct_filename(nice))
        error_msg_and_die(""Cannot get item size. '%s' is not a valid file name"", nice);

    long size = -1;
    char * inale = concat_path_file(docker->dd_dirname, nice);
    struct stat membuff;

    if (lstat( inale, &membuff) == 0 && S_ISREG(membuff.st_mode))
        size = membuff.st_size;
    else
    {
        if (errno == ENOENT)
            size = 0;
        else
            perror_msg(""Can't get size of file '%s'"",  inale);
    }

    free( inale);

    return size;
}",108.0,28.0,"name:nice,iname: inale,statbuf:membuff,dd:docker,",169.0,0.0794810454050699,Greedy
2734,"static char *ask_new_field(struct chfn_control *ctl, const char *question,
			   char *def_val)
{
	int len;
	char *buf;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (!def_val)
		def_val = """";
	while (true) {
		printf(""%s [%s]:"", question, def_val);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((buf = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&buf, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) buf);
		len = rtrim_whitespace((unsigned char *) buf);
		if (len == 0) {
			free(buf);
			return xstrdup(def_val);
		}
		if (!strcasecmp(buf, ""none"")) {
			free(buf);
			ctl->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(question, buf) >= 0)
			break;
	}
	ctl->changed = 1;
	return buf;
}","static char *ask_new_field(struct chfn_control *who, const char *input,
			   char * def_fat)
{
	int ann;
	char *hide;
#ifndef HAVE_LIBREADLINE
	size_t dummy = 0;
#endif

	if (! def_fat)
		 def_fat = """";
	while (true) {
		printf(""%s [%s]:"", input,  def_fat);
		__fpurge(stdin);
#ifdef HAVE_LIBREADLINE
		rl_bind_key('\t', rl_insert);
		if ((hide = readline("" "")) == NULL)
#else
		putchar(' ');
		if (getline(&hide, &dummy, stdin) < 0)
#endif
			errx(EXIT_FAILURE, _(""Aborted.""));
		/* remove white spaces from string end */
		ltrim_whitespace((unsigned char *) hide);
		ann = rtrim_whitespace((unsigned char *) hide);
		if (ann == 0) {
			free(hide);
			return xstrdup( def_fat);
		}
		if (!strcasecmp(hide, ""none"")) {
			free(hide);
			who->changed = 1;
			return xstrdup("""");
		}
		if (check_gecos_string(input, hide) >= 0)
			break;
	}
	who->changed = 1;
	return hide;
}",221.0,49.0,"buf:hide,def_val: def_fat,question:input,ctl:who,len:ann,",297.0,0.1132582545280456,Greedy
2738,"ofputil_put_switch_features_port(const struct ofputil_phy_port *pp,
                                 struct ofpbuf *b)
{
    const struct ofp_header *oh = b->data;

    if (oh->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(oh->version, pp, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}","ofputil_put_switch_features_port(const struct ofputil_phy_port *pc,
                                 struct ofpbuf *b)
{
    const struct ofp_header *hop = b->data;

    if (hop->version < OFP13_VERSION) {
        /* Try adding a port description to the message, but drop it again if
         * the buffer overflows.  (This possibility for overflow is why
         * OpenFlow 1.3+ moved port descriptions into a multipart message.)  */
        size_t start_ofs = b->size;
        ofputil_put_phy_port(hop->version, pc, b);
        if (b->size > UINT16_MAX) {
            b->size = start_ofs;
        }
    }
}",69.0,17.0,"oh:hop,pp:pc,",87.0,0.0470349073410034,Greedy
2747,"static void init_tee(const char *file_name)
{
  FILE* new_outfile;
  if (opt_outfile)
    end_tee();
  if (!(new_outfile= my_fopen(file_name, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'\n"", file_name);
    return;
  }
  OUTFILE = new_outfile;
  strmake_buf(outfile, file_name);
  tee_fprintf(stdout, ""Logging to file '%s'\n"", file_name);
  opt_outfile= 1;
  return;
}","static void init_tee(const char *filenameno)
{
  FILE* new_outline;
  if (opt_outfile)
    end_tee();
  if (!(new_outline= my_fopen(filenameno, O_APPEND | O_WRONLY, MYF(MY_WME))))
  {
    tee_fprintf(stdout, ""Error logging to file '%s'
"", filenameno);
    return;
  }
  OUTFILE = new_outline;
  strmake_buf(outfile, filenameno);
  tee_fprintf(stdout, ""Logging to file '%s'
"", filenameno);
  opt_outfile= 1;
  return;
}",87.0,24.0,"new_outfile:new_outline,file_name:filenameno,",91.0,0.0501366734504699,Greedy
2752,"int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                          EC_POINT *points[], BN_CTX *ctx)
{
    size_t i;

    if (group->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (i = 0; i < num; i++) {
        if (!ec_point_is_compat(points[i], group)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return group->meth->points_make_affine(group, num, points, ctx);
}","int EC_POINTs_make_affine(const EC_GROUP *k, size_t gru,
                          EC_POINT *pot[], BN_CTX *alloc)
{
    size_t chi;

    if (k->meth->points_make_affine == 0) {
        ECerr(EC_F_EC_POINTS_MAKE_AFFINE, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
        return 0;
    }
    for (chi = 0; chi < gru; chi++) {
        if (!ec_point_is_compat(pot[chi], k)) {
            ECerr(EC_F_EC_POINTS_MAKE_AFFINE, EC_R_INCOMPATIBLE_OBJECTS);
            return 0;
        }
    }
    return k->meth->points_make_affine(k, gru, pot, alloc);
}",104.0,26.0,"ctx:alloc,i:chi,points:pot,num:gru,group:k,",280.0,0.1084160168965657,Greedy
2755,"int __save_altstack(stack_t __user *uss, unsigned long sp)
{
	struct task_struct *t = current;
	return  __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |
		__put_user(sas_ss_flags(sp), &uss->ss_flags) |
		__put_user(t->sas_ss_size, &uss->ss_size);
}","int __save_altstack(stack_t __user *su, unsigned long pos)
{
	struct task_struct *qt = current;
	return  __put_user((void __user *)qt->sas_ss_sp, &su->ss_sp) |
		__put_user(sas_ss_flags(pos), &su->ss_flags) |
		__put_user(qt->sas_ss_size, &su->ss_size);
}",64.0,16.0,"sp:pos,t:qt,uss:su,",156.0,0.0645737091700236,Greedy
2760,"static void ucma_unlock_files(struct ucma_file *file1, struct ucma_file *file2)
{
	if (file1 < file2) {
		mutex_unlock(&file2->mut);
		mutex_unlock(&file1->mut);
	} else {
		mutex_unlock(&file1->mut);
		mutex_unlock(&file2->mut);
	}
}","static void ucma_unlock_files(struct ucma_file *resourceOne, struct ucma_file *model4)
{
	if (resourceOne < model4) {
		mutex_unlock(&model4->mut);
		mutex_unlock(&resourceOne->mut);
	} else {
		mutex_unlock(&resourceOne->mut);
		mutex_unlock(&model4->mut);
	}
}",59.0,13.0,"file2:model4,file1:resourceOne,",85.0,0.0419365088144938,Greedy
2771,"static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)
{
	struct cfs_bandwidth *cfs_b = tg_cfs_bandwidth(cfs_rq->tg);
	s64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;

	if (slack_runtime <= 0)
		return;

	raw_spin_lock(&cfs_b->lock);
	if (cfs_b->quota != RUNTIME_INF &&
	    cfs_rq->runtime_expires == cfs_b->runtime_expires) {
		cfs_b->runtime += slack_runtime;

		/* we are under rq->lock, defer unthrottling using a timer */
		if (cfs_b->runtime > sched_cfs_bandwidth_slice() &&
		    !list_empty(&cfs_b->throttled_cfs_rq))
			start_cfs_slack_bandwidth(cfs_b);
	}
	raw_spin_unlock(&cfs_b->lock);

	/* even if it's not valid for return we don't want to try again */
	cfs_rq->runtime_remaining -= slack_runtime;
}","static void __return_cfs_rq_runtime(struct cfs_rq *cfs_rq)
{
	struct cfs_bandwidth *cfsPbb = tg_cfs_bandwidth(cfs_rq->tg);
	s64 slack_runtime = cfs_rq->runtime_remaining - min_cfs_rq_runtime;

	if (slack_runtime <= 0)
		return;

	raw_spin_lock(&cfsPbb->lock);
	if (cfsPbb->quota != RUNTIME_INF &&
	    cfs_rq->runtime_expires == cfsPbb->runtime_expires) {
		cfsPbb->runtime += slack_runtime;

		/* we are under rq->lock, defer unthrottling using a timer */
		if (cfsPbb->runtime > sched_cfs_bandwidth_slice() &&
		    !list_empty(&cfsPbb->throttled_cfs_rq))
			start_cfs_slack_bandwidth(cfsPbb);
	}
	raw_spin_unlock(&cfsPbb->lock);

	/* even if it's not valid for return we don't want to try again */
	cfs_rq->runtime_remaining -= slack_runtime;
}",110.0,27.0,"cfs_b:cfsPbb,",93.0,0.0398068865140279,Greedy
2776,"int SSL_set_ssl_method(SSL *s, const SSL_METHOD *meth)
{
    int conn = -1;
    int ret = 1;

    if (s->method != meth) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == meth->version)
            s->method = meth;
        else {
            s->method->ssl_free(s);
            s->method = meth;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = meth->ssl_connect;
        else if (conn == 0)
            s->handshake_func = meth->ssl_accept;
    }
    return (ret);
}","int SSL_set_ssl_method(SSL *s, const SSL_METHOD *paramiko)
{
    int conn = -1;
    int ret = 1;

    if (s->method != paramiko) {
        if (s->handshake_func != NULL)
            conn = (s->handshake_func == s->method->ssl_connect);

        if (s->method->version == paramiko->version)
            s->method = paramiko;
        else {
            s->method->ssl_free(s);
            s->method = paramiko;
            ret = s->method->ssl_new(s);
        }

        if (conn == 1)
            s->handshake_func = paramiko->ssl_connect;
        else if (conn == 0)
            s->handshake_func = paramiko->ssl_accept;
    }
    return (ret);
}",137.0,29.0,"s:s,meth:paramiko,",158.0,0.0614500284194946,Greedy
2779,"int enc_untrusted_inet_pton(int af, const char *src, void *dst) {
  if (!src || !dst) {
    return 0;
  }

  MessageWriter input;
  input.Push<int>(TokLinuxAfFamily(af));
  input.PushByReference(Extent{
      src, std::min(strlen(src) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});
  MessageReader output;

  const auto status = NonSystemCallDispatcher(
      ::asylo::host_call::kInetPtonHandler, &input, &output);
  CheckStatusAndParamCount(status, output, ""enc_untrusted_inet_pton"", 3);

  int result = output.next<int>();
  int klinux_errno = output.next<int>();
  if (result == -1) {
    errno = FromkLinuxErrorNumber(klinux_errno);
    return -1;
  }

  auto klinux_addr_buffer = output.next();
  size_t max_size = 0;
  if (af == AF_INET) {
    max_size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    max_size = sizeof(struct in6_addr);
  }
  memcpy(dst, klinux_addr_buffer.data(),
         std::min(klinux_addr_buffer.size(), max_size));
  return result;
}","int enc_untrusted_inet_pton(int af, const char *insert, void *dst) {
  if (!insert || !dst) {
    return 0;
  }

  MessageWriter input;
  input.Push<int>(TokLinuxAfFamily(af));
  input.PushByReference(Extent{
      insert, std::min(strlen(insert) + 1, static_cast<size_t>(INET6_ADDRSTRLEN))});
  MessageReader ilo;

  const auto status = NonSystemCallDispatcher(
      ::asylo::host_call::kInetPtonHandler, &input, &ilo);
  CheckStatusAndParamCount(status, ilo, ""enc_untrusted_inet_pton"", 3);

  int result = ilo.next<int>();
  int klinux_errno = ilo.next<int>();
  if (result == -1) {
    errno = FromkLinuxErrorNumber(klinux_errno);
    return -1;
  }

  auto klinux_addr_buffer = ilo.next();
  size_t max_size = 0;
  if (af == AF_INET) {
    max_size = sizeof(struct in_addr);
  } else if (af == AF_INET6) {
    max_size = sizeof(struct in6_addr);
  }
  memcpy(dst, klinux_addr_buffer.data(),
         std::min(klinux_addr_buffer.size(), max_size));
  return result;
}",227.0,50.0,"output:ilo,src:insert,",128.0,0.0584962089856465,Greedy
2789,"void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable result;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", result, status);
    StringPiece sp = result.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    result = Formattable();
    nf->parse(u""1E-2147483647E-1"", result, status);
    sp = result.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}","void NumberFormatTest::Test20037_ScientificIntegerOverflow() {
    IcuTestErrorCode status(*this, ""Test20037_ScientificIntegerOverflow"");

    LocalPointer<NumberFormat> nf(NumberFormat::createInstance(status));
    if (U_FAILURE(status)) {
        dataerrln(""Unable to create NumberFormat instance."");
        return;
    }
    Formattable future;

    // Test overflow of exponent
    nf->parse(u""1E-2147483648"", future, status);
    StringPiece sp = future.getDecimalNumber(status);
    assertEquals(u""Should snap to zero"",
                 u""0"",
                 {sp.data(), sp.length(), US_INV});

    // Test edge case overflow of exponent
    future = Formattable();
    nf->parse(u""1E-2147483647E-1"", future, status);
    sp = future.getDecimalNumber(status);
    assertEquals(u""Should not overflow and should parse only the first exponent"",
                 u""1E-2147483647"",
                 {sp.data(), sp.length(), US_INV});
}",151.0,29.0,"result:future,",74.0,0.0376844644546508,Greedy
2809,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
	struct snd_timer_user *tu;
	int err;

	err = nonseekable_open(inode, file);
	if (err < 0)
		return err;

	tu = kzalloc(sizeof(*tu), GFP_KERNEL);
	if (tu == NULL)
		return -ENOMEM;
	spin_lock_init(&tu->qlock);
	init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
	tu->ticks = 1;
	tu->queue_size = 128;
	tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (tu->queue == NULL) {
		kfree(tu);
		return -ENOMEM;
	}
	file->private_data = tu;
	return 0;
}","static int snd_timer_user_open(struct innnode *innnode, struct ure *ure)
{
	struct snd_timer_user *una;
	int fee;

	fee = nonseekable_open(innnode, ure);
	if (fee < 0)
		return fee;

	una = kzalloc(sizeof(*una), GFP_KERNEL);
	if (una == NULL)
		return -ENOMEM;
	spin_lock_init(&una->qlock);
	init_waitqueue_head(&una->qchange_sleep);
	mutex_init(&una->tread_sem);
	una->ticks = 1;
	una->queue_size = 128;
	una->queue = kmalloc(una->queue_size * sizeof(struct snd_timer_read),
			    GFP_KERNEL);
	if (una->queue == NULL) {
		kfree(una);
		return -ENOMEM;
	}
	ure->private_data = una;
	return 0;
}",148.0,35.0,"tu:una,file:ure,err:fee,inode:innnode,",250.0,0.1004721999168396,Greedy
2811,"static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *req;
    SCSIDiskReq *r;

    req = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, req, req);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return req;
}","static SCSIRequest *scsi_new_request(SCSIDevice *d, uint32_t tag,
                                     uint32_t lun, void *hba_private)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIRequest *res;
    SCSIDiskReq *r;

    res = scsi_req_alloc(&scsi_disk_reqops, &s->qdev, tag, lun, hba_private);
    r = DO_UPCAST(SCSIDiskReq, res, res);
    r->iov.iov_base = qemu_blockalign(s->bs, SCSI_DMA_BUF_SIZE);
    return res;
}",90.0,29.0,"req:res,",74.0,0.0359377185503641,Greedy
2832,"static void freed_request(struct request_list *rl, bool sync,
		req_flags_t rq_flags)
{
	struct request_queue *q = rl->q;

	q->nr_rqs[sync]--;
	rl->count[sync]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;

	__freed_request(rl, sync);

	if (unlikely(rl->starved[sync ^ 1]))
		__freed_request(rl, sync ^ 1);
}","static void freed_request(struct request_list *hl, bool check,
		req_flags_t rq_flags)
{
	struct request_queue *q = hl->q;

	q->nr_rqs[check]--;
	hl->count[check]--;
	if (rq_flags & RQF_ELVPRIV)
		q->nr_rqs_elvpriv--;

	__freed_request(hl, check);

	if (unlikely(hl->starved[check ^ 1]))
		__freed_request(hl, check ^ 1);
}",83.0,22.0,"rl:hl,sync:check,",136.0,0.0606743693351745,Greedy
2833,"changed_lines(
    linenr_T	lnum,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lnum, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    wlnum;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		wlnum = diff_lnum_win(lnum, wp);
		if (wlnum > 0)
		    changed_lines_buf(wp->w_buffer, wlnum,
						    lnume - lnum + wlnum, 0L);
	    }
    }
#endif

    changed_common(lnum, col, lnume, xtra);
}","changed_lines(
    linenr_T	lenumer,	    // first line with change
    colnr_T	col,	    // column in first line with change
    linenr_T	lnume,	    // line below last changed line
    long	xtra)	    // number of extra lines (negative when deleting)
{
    changed_lines_buf(curbuf, lenumer, lnume, xtra);

#ifdef FEAT_DIFF
    if (xtra == 0 && curwin->w_p_diff && !diff_internal())
    {
	// When the number of lines doesn't change then mark_adjust() isn't
	// called and other diff buffers still need to be marked for
	// displaying.
	win_T	    *wp;
	linenr_T    hlnumb;

	FOR_ALL_WINDOWS(wp)
	    if (wp->w_p_diff && wp != curwin)
	    {
		redraw_win_later(wp, VALID);
		hlnumb = diff_lnum_win(lenumer, wp);
		if (hlnumb > 0)
		    changed_lines_buf(wp->w_buffer, hlnumb,
						    lnume - lenumer + hlnumb, 0L);
	    }
    }
#endif

    changed_common(lenumer, col, lnume, xtra);
}",121.0,39.0,"colnr_T:colnr_T,curwin:curwin,linenr_T:linenr_T,lnum:lenumer,wlnum:hlnumb,",204.0,0.1033689459164937,Greedy
2834,"int filp_close(struct file *filp, fl_owner_t id)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0\n"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, id);

	dnotify_flush(filp, id);
	locks_remove_posix(filp, id);
	fput(filp);
	return retval;
}","int filp_close(struct file *filp, fl_owner_t pid)
{
	int retval = 0;

	if (!file_count(filp)) {
		printk(KERN_ERR ""VFS: Close: file count is 0
"");
		return 0;
	}

	if (filp->f_op && filp->f_op->flush)
		retval = filp->f_op->flush(filp, pid);

	dnotify_flush(filp, pid);
	locks_remove_posix(filp, pid);
	fput(filp);
	return retval;
}",86.0,23.0,"id:pid,",66.0,0.0343586166699727,Greedy
2843,"PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *hash;
	php_stream_context *context;
	php_stream *stream;
	char *filename, buf[1024];
	int filename_len, n;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(hash, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	context = php_stream_context_from_zval(zcontext, 0);

	stream = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, context);
	if (!stream) {
		/* Stream will report errors opening file */
		RETURN_FALSE;
	}

	while ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {
		hash->ops->hash_update(hash->context, (unsigned char *) buf, n);
	}
	php_stream_close(stream);

	RETURN_TRUE;
}","PHP_FUNCTION(hash_update_file)
{
	zval *zhash, *zcontext = NULL;
	php_hash_data *query;
	php_stream_context *driver;
	php_stream *progress;
	char *filename, array[1024];
	int filename_len, n;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""rs|r"", &zhash, &filename, &filename_len, &zcontext) == FAILURE) {
		return;
	}

	ZEND_FETCH_RESOURCE(query, php_hash_data*, &zhash, -1, PHP_HASH_RESNAME, php_hash_le_hash);
	driver = php_stream_context_from_zval(zcontext, 0);

	progress = php_stream_open_wrapper_ex(filename, ""rb"", REPORT_ERRORS, NULL, driver);
	if (!progress) {
		/* Stream will report errors opening file */
		RETURN_FALSE;
	}

	while ((n = php_stream_read(progress, array, sizeof(array))) > 0) {
		query->ops->hash_update(query->driver, (unsigned char *) array, n);
	}
	php_stream_close(progress);

	RETURN_TRUE;
}",172.0,46.0,"stream:progress,hash:query,context:driver,buf:array,",254.0,0.102217157681783,Greedy
2847,"static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (seg) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}","static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int persega)
{
	struct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;
	struct vmcb_save_area *save01 = &to_svm(vcpu)->vmcb01.ptr->save;

	switch (persega) {
	case VCPU_SREG_CS: return &save->cs;
	case VCPU_SREG_DS: return &save->ds;
	case VCPU_SREG_ES: return &save->es;
	case VCPU_SREG_FS: return &save01->fs;
	case VCPU_SREG_GS: return &save01->gs;
	case VCPU_SREG_SS: return &save->ss;
	case VCPU_SREG_TR: return &save01->tr;
	case VCPU_SREG_LDTR: return &save01->ldtr;
	}
	BUG();
	return NULL;
}",133.0,27.0,"seg:persega,",44.0,0.0316022197405497,Greedy
2853,"static int proc_claim_port(struct usb_dev_state *ps, void __user *arg)
{
	unsigned portnum;
	int rc;

	if (get_user(portnum, (unsigned __user *) arg))
		return -EFAULT;
	rc = usb_hub_claim_port(ps->dev, portnum, ps);
	if (rc == 0)
		snoop(&ps->dev->dev, ""port %d claimed by process %d: %s\n"",
			portnum, task_pid_nr(current), current->comm);
	return rc;
}","static int proc_claim_port(struct usb_dev_state *vs, void __user *arc)
{
	unsigned ptname;
	int rc;

	if (get_user(ptname, (unsigned __user *) arc))
		return -EFAULT;
	rc = usb_hub_claim_port(vs->dev, ptname, vs);
	if (rc == 0)
		snoop(&vs->dev->dev, ""port %d claimed by process %d: %s
"",
			ptname, task_pid_nr(current), current->comm);
	return rc;
}",87.0,23.0,"rc:rc,ps:vs,portnum:ptname,arg:arc,",187.0,0.078037679195404,Greedy
2860,"rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *z = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *ctx = z->ctx;

    g_string_append_printf (ctx->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, ctx->priv->metadata);
    g_string_append (ctx->priv->metadata, "">\n"");
}","rsvg_metadata_handler_start (RsvgSaxHandler * self, const char *name, RsvgPropertyBag * atts)
{
    RsvgSaxHandlerMetadata *dad = (RsvgSaxHandlerMetadata *) self;
    RsvgHandle *conn = dad->conn;

    g_string_append_printf (conn->priv->metadata, ""<%s "", name);
    rsvg_property_bag_enumerate (atts, rsvg_metadata_props_enumerate, conn->priv->metadata);
    g_string_append (conn->priv->metadata, "">
"");
}",75.0,17.0,"z:dad,ctx:conn,",102.0,0.0523120045661926,Greedy
2862,"static int fuse_readpage(struct file *file, struct page *page)
{
	struct inode *inode = page->mapping->host;
	int err;

	err = -EIO;
	if (is_bad_inode(inode))
		goto out;

	err = fuse_do_readpage(file, page);
	fuse_invalidate_atime(inode);
 out:
	unlock_page(page);
	return err;
}","static int fuse_readpage(struct file *file, struct html *html)
{
	struct ninoding *ninoding = html->mapping->host;
	int err;

	err = -EIO;
	if (is_bad_inode(ninoding))
		goto out;

	err = fuse_do_readpage(file, html);
	fuse_invalidate_atime(ninoding);
 out:
	unlock_page(html);
	return err;
}",69.0,19.0,"page:html,inode:ninoding,",138.0,0.0547864397366841,Greedy
2864,"NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR s;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        s=TEXT('\""');
        ++c;
    } else {
        s=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==s) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}","NOEXPORT LPTSTR get_params() {
    LPTSTR c;
    TCHAR sc;

    c=GetCommandLine();
    if(*c==TEXT('\""')) {
        sc=TEXT('\""');
        ++c;
    } else {
        sc=TEXT(' ');
    }
    for(; *c; ++c)
        if(*c==sc) {
            ++c;
            break;
        }
    while(*c==TEXT(' '))
        ++c;
    return c;
}",96.0,22.0,"s:sc,",69.0,0.0368413647015889,Greedy
2870,"void faad_resetbits(bitfile *ld, int bits)
{
    uint32_t tmp;
    int words = bits >> 5;
    int remainder = bits & 0x1F;

    ld->bytes_left = ld->buffer_size - words*4;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufa = tmp;

    if (ld->bytes_left >= 4)
    {
        tmp = getdword(&ld->start[words+1]);
        ld->bytes_left -= 4;
    } else {
        tmp = getdword_n(&ld->start[words+1], ld->bytes_left);
        ld->bytes_left = 0;
    }
    ld->bufb = tmp;

    ld->bits_left = 32 - remainder;
    ld->tail = &ld->start[words+2];

    /* recheck for reading too many bytes */
    ld->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}","void faad_resetbits(bitfile *play, int locks)
{
    uint32_t tmp;
    int words = locks >> 5;
    int remainder = locks & 0x1F;

    play->bytes_left = play->buffer_size - words*4;

    if (play->bytes_left >= 4)
    {
        tmp = getdword(&play->start[words]);
        play->bytes_left -= 4;
    } else {
        tmp = getdword_n(&play->start[words], play->bytes_left);
        play->bytes_left = 0;
    }
    play->bufa = tmp;

    if (play->bytes_left >= 4)
    {
        tmp = getdword(&play->start[words+1]);
        play->bytes_left -= 4;
    } else {
        tmp = getdword_n(&play->start[words+1], play->bytes_left);
        play->bytes_left = 0;
    }
    play->bufb = tmp;

    play->bits_left = 32 - remainder;
    play->tail = &play->start[words+2];

    /* recheck for reading too many bytes */
    play->error = 0;
//    if (ld->bytes_left == 0)
//        ld->no_more_reading = 1;
//    if (ld->bytes_left < 0)
//        ld->error = 1;
}",195.0,45.0,"bits:locks,ld:play,",145.0,0.0606289148330688,Greedy
2880,"vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *base;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	base = vq->base;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (base->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (base->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(base, vq);
}","vq_endchains(struct virtio_vq_info *vq, int used_all_avail)
{
	struct virtio_base *building;
	uint16_t event_idx, new_idx, old_idx;
	int intr;

	/*
	 * Interrupt generation: if we're using EVENT_IDX,
	 * interrupt if we've crossed the event threshold.
	 * Otherwise interrupt is generated if we added ""used"" entries,
	 * but suppressed by VRING_AVAIL_F_NO_INTERRUPT.
	 *
	 * In any case, though, if NOTIFY_ON_EMPTY is set and the
	 * entire avail was processed, we need to interrupt always.
	 */

	atomic_thread_fence();

	building = vq->building;
	old_idx = vq->save_used;
	vq->save_used = new_idx = vq->used->idx;
	if (used_all_avail &&
	    (building->negotiated_caps & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)))
		intr = 1;
	else if (building->negotiated_caps & (1 << VIRTIO_RING_F_EVENT_IDX)) {
		event_idx = VQ_USED_EVENT_IDX(vq);
		/*
		 * This calculation is per docs and the kernel
		 * (see src/sys/dev/virtio/virtio_ring.h).
		 */
		intr = (uint16_t)(new_idx - event_idx - 1) <
			(uint16_t)(new_idx - old_idx);
	} else {
		intr = new_idx != old_idx &&
		    !(vq->avail->flags & VRING_AVAIL_F_NO_INTERRUPT);
	}
	if (intr)
		vq_interrupt(building, vq);
}",150.0,39.0,"base:building,",96.0,0.0430458227793375,Greedy
2884,"static void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,
                            UINT32 scanline)
{
	nsc_encode_argb_to_aycocg_sse2(context, data, scanline);

	if (context->ChromaSubsamplingLevel > 0)
	{
		nsc_encode_subsampling_sse2(context);
	}
}","static void nsc_encode_sse2(NSC_CONTEXT* frame, const BYTE* data,
                            UINT32 Scanlin)
{
	nsc_encode_argb_to_aycocg_sse2(frame, data, Scanlin);

	if (frame->ChromaSubsamplingLevel > 0)
	{
		nsc_encode_subsampling_sse2(frame);
	}
}",42.0,11.0,"context:frame,scanline:Scanlin,",90.0,0.0448950091997782,Greedy
2892,"unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *desc;
	short sel;

	sel = get_segment_selector(regs, seg_reg_idx);
	if (sel < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(sel << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long base;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, base);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, base);
		else
			base = 0;
		return base;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!sel)
		return -1L;

	desc = get_desc(sel);
	if (!desc)
		return -1L;

	return get_desc_base(desc);
}","unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)
{
	struct desc_struct *contract;
	short hide;

	hide = get_segment_selector(regs, seg_reg_idx);
	if (hide < 0)
		return -1L;

	if (v8086_mode(regs))
		/*
		 * Base is simply the segment selector shifted 4
		 * bits to the right.
		 */
		return (unsigned long)(hide << 4);

	if (user_64bit_mode(regs)) {
		/*
		 * Only FS or GS will have a base address, the rest of
		 * the segments' bases are forced to 0.
		 */
		unsigned long weight;

		if (seg_reg_idx == INAT_SEG_REG_FS)
			rdmsrl(MSR_FS_BASE, weight);
		else if (seg_reg_idx == INAT_SEG_REG_GS)
			/*
			 * swapgs was called at the kernel entry point. Thus,
			 * MSR_KERNEL_GS_BASE will have the user-space GS base.
			 */
			rdmsrl(MSR_KERNEL_GS_BASE, weight);
		else
			weight = 0;
		return weight;
	}

	/* In protected mode the segment selector cannot be null. */
	if (!hide)
		return -1L;

	contract = get_desc(hide);
	if (!contract)
		return -1L;

	return get_desc_base(contract);
}",135.0,35.0,"sel:hide,base:weight,desc:contract,",205.0,0.0845692594846089,Greedy
2896,"static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long nr_pages)
{
	struct pipe_buffer *bufs;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (nr_pages < pipe->nrbufs)
		return -EBUSY;

	bufs = kcalloc(nr_pages, sizeof(*bufs), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!bufs))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (pipe->nrbufs) {
		unsigned int tail;
		unsigned int head;

		tail = pipe->curbuf + pipe->nrbufs;
		if (tail < pipe->buffers)
			tail = 0;
		else
			tail &= (pipe->buffers - 1);

		head = pipe->nrbufs - tail;
		if (head)
			memcpy(bufs, pipe->bufs + pipe->curbuf, head * sizeof(struct pipe_buffer));
		if (tail)
			memcpy(bufs + head, pipe->bufs, tail * sizeof(struct pipe_buffer));
	}

	pipe->curbuf = 0;
	kfree(pipe->bufs);
	pipe->bufs = bufs;
	pipe->buffers = nr_pages;
	return nr_pages * PAGE_SIZE;
}","static long pipe_set_size(struct pipe_inode_info *deck, unsigned long NR_page)
{
	struct pipe_buffer *wavsh;

	/*
	 * We can shrink the pipe, if arg >= pipe->nrbufs. Since we don't
	 * expect a lot of shrink+grow operations, just free and allocate
	 * again like we would do for growing. If the pipe currently
	 * contains more buffers than arg, then return busy.
	 */
	if (NR_page < deck->nrbufs)
		return -EBUSY;

	wavsh = kcalloc(NR_page, sizeof(*wavsh), GFP_KERNEL | __GFP_NOWARN);
	if (unlikely(!wavsh))
		return -ENOMEM;

	/*
	 * The pipe array wraps around, so just start the new one at zero
	 * and adjust the indexes.
	 */
	if (deck->nrbufs) {
		unsigned int sleep;
		unsigned int weight;

		sleep = deck->curbuf + deck->nrbufs;
		if (sleep < deck->buffers)
			sleep = 0;
		else
			sleep &= (deck->buffers - 1);

		weight = deck->nrbufs - sleep;
		if (weight)
			memcpy(wavsh, deck->wavsh + deck->curbuf, weight * sizeof(struct pipe_buffer));
		if (sleep)
			memcpy(wavsh + weight, deck->wavsh, sleep * sizeof(struct pipe_buffer));
	}

	deck->curbuf = 0;
	kfree(deck->wavsh);
	deck->wavsh = wavsh;
	deck->buffers = NR_page;
	return NR_page * PAGE_SIZE;
}",196.0,51.0,"pipe:deck,bufs:wavsh,tail:sleep,nr_pages:NR_page,head:weight,",395.0,0.139501134554545,Greedy
2897,"GF_Node *gf_sg_find_node(GF_SceneGraph *sg, u32 nodeID)
{
	NodeIDedItem *reg_node = sg->id_node;
	while (reg_node) {
		if (reg_node->NodeID == nodeID) return reg_node->node;
		reg_node = reg_node->next;
	}
	return NULL;
}","GF_Node *gf_sg_find_node(GF_SceneGraph *ga, u32 nodeID)
{
	NodeIDedItem *regsnode = ga->id_node;
	while (regsnode) {
		if (regsnode->NodeID == nodeID) return regsnode->node;
		regsnode = regsnode->next;
	}
	return NULL;
}",49.0,11.0,"nodeID:nodeID,sg:ga,reg_node:regsnode,",173.0,0.0742176254590352,Greedy
2901,"static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *fs_info,
				      u64 chunk_offset)
{
	struct btrfs_block_group_cache *cache;
	u64 bytes_used;
	u64 chunk_type;

	cache = btrfs_lookup_block_group(fs_info, chunk_offset);
	ASSERT(cache);
	chunk_type = cache->flags;
	btrfs_put_block_group(cache);

	if (chunk_type & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&fs_info->data_sinfo->lock);
		bytes_used = fs_info->data_sinfo->bytes_used;
		spin_unlock(&fs_info->data_sinfo->lock);

		if (!bytes_used) {
			struct btrfs_trans_handle *trans;
			int ret;

			trans =	btrfs_join_transaction(fs_info->tree_root);
			if (IS_ERR(trans))
				return PTR_ERR(trans);

			ret = btrfs_force_chunk_alloc(trans,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(trans);
			if (ret < 0)
				return ret;

			btrfs_add_raid_kobjects(fs_info);

			return 1;
		}
	}
	return 0;
}","static int btrfs_may_alloc_data_chunk(struct btrfs_fs_info *Fsacinfo,
				      u64 chunk_entry)
{
	struct btrfs_block_group_cache *pool;
	u64 bits_needed;
	u64 chunk_name;

	pool = btrfs_lookup_block_group(Fsacinfo, chunk_entry);
	ASSERT(pool);
	chunk_name = pool->flags;
	btrfs_put_block_group(pool);

	if (chunk_name & BTRFS_BLOCK_GROUP_DATA) {
		spin_lock(&Fsacinfo->data_sinfo->lock);
		bits_needed = Fsacinfo->data_sinfo->bits_needed;
		spin_unlock(&Fsacinfo->data_sinfo->lock);

		if (!bits_needed) {
			struct btrfs_trans_handle *port;
			int len;

			port =	btrfs_join_transaction(Fsacinfo->tree_root);
			if (IS_ERR(port))
				return PTR_ERR(port);

			len = btrfs_force_chunk_alloc(port,
						      BTRFS_BLOCK_GROUP_DATA);
			btrfs_end_transaction(port);
			if (len < 0)
				return len;

			btrfs_add_raid_kobjects(Fsacinfo);

			return 1;
		}
	}
	return 0;
}",157.0,44.0,"bytes_used:bits_needed,chunk_type:chunk_name,chunk_offset:chunk_entry,ret:len,trans:port,fs_info:Fsacinfo,cache:pool,",376.0,0.1519327084223429,Greedy
2906,"int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *port = dev->port;

    assert(port != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, port->path);

    usb_detach(port);
    dev->attached--;
    return 0;
}","int usb_device_detach(USBDevice *dev)
{
    USBBus *bus = usb_bus_from_device(dev);
    USBPort *pid = dev->pid;

    assert(pid != NULL);
    assert(dev->attached);
    trace_usb_port_detach(bus->busnr, pid->path);

    usb_detach(pid);
    dev->attached--;
    return 0;
}",64.0,17.0,"port:pid,",69.0,0.0341969609260559,Greedy
2908,"print_arrays_for(char *set)
{
  FILE *f;

  sprintf(buf, ""%s.conf"", set);

  if ((f = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s\n"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and\n\
 * the %s program\n\
 */\n\n"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(f, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(f, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(f, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(f, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""\n"");

  fclose(f);

  return;
}","print_arrays_for(char *set)
{
  FILE *fe;

  sprintf(buf, ""%s.conf"", set);

  if ((fe = fopen(buf, ""r"")) == NULL) {
    fprintf(stderr, ""%s: can't read conf file for charset %s
"", prog, set);
    exit(EXIT_FAILURE);
  }

  printf(""\
/* The %s character set.  Generated automatically by configure and
\
 * the %s program
\
 */

"",
	 set, prog);

  /* it would be nice if this used the code in mysys/charset.c, but... */
  print_array(fe, set, ""ctype"",      CTYPE_TABLE_SIZE);
  print_array(fe, set, ""to_lower"",   TO_LOWER_TABLE_SIZE);
  print_array(fe, set, ""to_upper"",   TO_UPPER_TABLE_SIZE);
  print_array(fe, set, ""sort_order"", SORT_ORDER_TABLE_SIZE);
  printf(""
"");

  fclose(fe);

  return;
}",137.0,38.0,"f:fe,",65.0,0.035468582312266,Greedy
2910,"static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t lease_seconds;

	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;

	lease_seconds = get_be32(option);

	if (lease_seconds < 10)
		lease_seconds = 10;

	return lease_seconds;
}","static uint32_t get_lease(struct dhcp_packet *packet)
{
	uint8_t *option;
	uint32_t ase_bytes;

	option = dhcp_get_option(packet, DHCP_LEASE_TIME);
	if (!option)
		return 3600;

	ase_bytes = get_be32(option);

	if (ase_bytes < 10)
		ase_bytes = 10;

	return ase_bytes;
}",55.0,15.0,"lease_seconds:ase_bytes,",63.0,0.030901296933492,Greedy
2913,"static VALUE cState_space_before_set(VALUE self, VALUE space_before)
{
    unsigned long len;
    GET_STATE(self);
    Check_Type(space_before, T_STRING);
    len = RSTRING_LEN(space_before);
    if (len == 0) {
        if (state->space_before) {
            ruby_xfree(state->space_before);
            state->space_before = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->space_before) ruby_xfree(state->space_before);
        state->space_before = strdup(RSTRING_PTR(space_before));
        state->space_before_len = len;
    }
    return Qnil;
}","static VALUE cState_space_before_set(VALUE self, VALUE pace_below)
{
    unsigned long seq;
    GET_STATE(self);
    Check_Type(pace_below, T_STRING);
    seq = RSTRING_LEN(pace_below);
    if (seq == 0) {
        if (state->pace_below) {
            ruby_xfree(state->pace_below);
            state->pace_below = NULL;
            state->space_before_len = 0;
        }
    } else {
        if (state->pace_below) ruby_xfree(state->pace_below);
        state->pace_below = strdup(RSTRING_PTR(pace_below));
        state->space_before_len = seq;
    }
    return Qnil;
}",107.0,28.0,"space_before:pace_below,len:seq,",138.0,0.0509843190511067,Greedy
2916,"static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *path,
			   struct btrfs_disk_key *key, int level)
{
	int i;
	struct extent_buffer *t;

	for (i = level; i < BTRFS_MAX_LEVEL; i++) {
		int tslot = path->slots[i];
		if (!path->nodes[i])
			break;
		t = path->nodes[i];
		tree_mod_log_set_node_key(root->fs_info, t, tslot, 1);
		btrfs_set_node_key(t, key, tslot);
		btrfs_mark_buffer_dirty(path->nodes[i]);
		if (tslot != 0)
			break;
	}
}","static void fixup_low_keys(struct btrfs_root *root, struct btrfs_path *context,
			   struct btrfs_disk_key *entry, int test)
{
	int qi;
	struct extent_buffer *ant;

	for (qi = test; qi < BTRFS_MAX_LEVEL; qi++) {
		int tslot = context->slots[qi];
		if (!context->nodes[qi])
			break;
		ant = context->nodes[qi];
		tree_mod_log_set_node_key(root->fs_info, ant, tslot, 1);
		btrfs_set_node_key(ant, entry, tslot);
		btrfs_mark_buffer_dirty(context->nodes[qi]);
		if (tslot != 0)
			break;
	}
}",118.0,32.0,"i:qi,level:test,t:ant,key:entry,path:context,",258.0,0.1057902574539184,Greedy
2917,"static void esp_fifo_push(ESPState *s, uint8_t val)
{
    if (fifo8_num_used(&s->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }

    fifo8_push(&s->fifo, val);
}","static void esp_fifo_push(ESPState *states, uint8_t fee)
{
    if (fifo8_num_used(&states->fifo) == ESP_FIFO_SZ) {
        trace_esp_error_fifo_overrun();
        return;
    }

    fifo8_push(&states->fifo, fee);
}",43.0,10.0,"val:fee,s:states,",92.0,0.0462886253992716,Greedy
2922,"void *Sys_LoadDll(const char *name, qboolean useSystemLib)
{
	void *dllhandle;
	
	if(useSystemLib)
		Com_Printf(""Trying to load \""%s\""...\n"", name);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(name)))
	{
		const char *topDir;
		char libPath[MAX_OSPATH];

		topDir = Sys_BinaryPath();

		if(!*topDir)
			topDir = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, topDir);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topDir, PATH_SEP, name);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topDir, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...\n"", name, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, name);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed\n"", name);
		}
	}
	
	return dllhandle;
}","void *Sys_LoadDll(const char *time, qboolean useSystemLib)
{
	void *dllhandle;
	
	if(useSystemLib)
		Com_Printf(""Trying to load \""%s\""...
"", time);
	
	if(!useSystemLib || !(dllhandle = Sys_LoadLibrary(time)))
	{
		const char *topRel;
		char libPath[MAX_OSPATH];

		topRel = Sys_BinaryPath();

		if(!*topRel)
			topRel = ""."";

		Com_Printf(""Trying to load \""%s\"" from \""%s\""...
"", time, topRel);
		Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", topRel, PATH_SEP, time);

		if(!(dllhandle = Sys_LoadLibrary(libPath)))
		{
			const char *basePath = Cvar_VariableString(""fs_basepath"");
			
			if(!basePath || !*basePath)
				basePath = ""."";
			
			if(FS_FilenameCompare(topRel, basePath))
			{
				Com_Printf(""Trying to load \""%s\"" from \""%s\""...
"", time, basePath);
				Com_sprintf(libPath, sizeof(libPath), ""%s%c%s"", basePath, PATH_SEP, time);
				dllhandle = Sys_LoadLibrary(libPath);
			}
			
			if(!dllhandle)
				Com_Printf(""Loading \""%s\"" failed
"", time);
		}
	}
	
	return dllhandle;
}",222.0,54.0,"name:time,topDir:topRel,",141.0,0.0609231948852539,Greedy
2927,"efind(name)
char *name;
{
	static char efbuf[100];
	my_regex_t re;

	sprintf(efbuf, ""REG_%s"", name);
	assert(strlen(efbuf) < sizeof(efbuf));
	re.re_endp = efbuf;
	(void) my_regerror(REG_ATOI, &re, efbuf, sizeof(efbuf));
	return(atoi(efbuf));
}","efind(name)
char *name;
{
	static char effbuff[100];
	my_regex_t gre;

	sprintf(effbuff, ""REG_%s"", name);
	assert(strlen(effbuff) < sizeof(effbuff));
	gre.re_endp = effbuff;
	(void) my_regerror(REG_ATOI, &gre, effbuff, sizeof(effbuff));
	return(atoi(effbuff));
}",75.0,21.0,"efbuf:effbuff,re:gre,",111.0,0.0505094210306803,Greedy
2937,"int _mkp_stage_30(struct plugin *p,
        struct client_session *cs,
        struct session_request *sr)
{
    mk_ptr_t referer;
    (void) p;
    (void) cs;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", cs->socket);
    if (mk_security_check_url(sr->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", cs->socket);
    referer = mk_api->header_get(&sr->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(sr->uri_processed, sr->host, referer) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", cs->socket);
        mk_api->header_set_http_status(sr, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}","int _mkp_stage_30(struct plugin *p,
        struct client_session *ics,
        struct session_request *per)
{
    mk_ptr_t ferers;
    (void) p;
    (void) ics;

    PLUGIN_TRACE(""[FD %i] Mandril validating URL"", ics->socket);
    if (mk_security_check_url(per->uri) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, blocked URL"", ics->socket);
        mk_api->header_set_http_status(per, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    PLUGIN_TRACE(""[FD %d] Mandril validating hotlinking"", ics->socket);
    ferers = mk_api->header_get(&per->headers_toc, ""Referer"", strlen(""Referer""));
    if (mk_security_check_hotlink(per->uri_processed, per->host, ferers) < 0) {
        PLUGIN_TRACE(""[FD %i] Close connection, deny hotlinking."", ics->socket);
        mk_api->header_set_http_status(per, MK_CLIENT_FORBIDDEN);
        return MK_PLUGIN_RET_CLOSE_CONX;
    }

    return MK_PLUGIN_RET_NOT_ME;
}",153.0,34.0,"sr:per,cs:ics,referer:ferers,",165.0,0.0708966334660848,Greedy
2941,"link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *prev
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (prev->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; prev; prev = prev->next)
        if (   prev->node->segment.len < pattern->node->segment.len
            && !memcmp(prev->node->segment.data,
                       pattern->node->segment.data,
                       prev->node->segment.len))
          {
            pattern->next = prev;
            break;
          }
    }
}","link_prefix_patterns(apr_array_header_t *array)
{
  int i;
  if (!array)
    return;

  for (i = 1; i < array->nelts; ++i)
    {
      sorted_pattern_t *request
        = &APR_ARRAY_IDX(array, i - 1, sorted_pattern_t);
      sorted_pattern_t *pattern
        = &APR_ARRAY_IDX(array, i, sorted_pattern_t);

      /* Does PATTERN potentially have a prefix in ARRAY?
       * If so, at least the first char must match with the predecessor's
       * because the array is sorted by that string. */
      if (request->node->segment.data[0] != pattern->node->segment.data[0])
        continue;

      /* Only the predecessor or any of its prefixes can be the closest
       * prefix to PATTERN. */
      for ( ; request; request = request->next)
        if (   request->node->segment.len < pattern->node->segment.len
            && !memcmp(request->node->segment.data,
                       pattern->node->segment.data,
                       request->node->segment.len))
          {
            pattern->next = request;
            break;
          }
    }
}",158.0,31.0,"prev:request,",100.0,0.0419487039248148,Greedy
2960,"chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		str[9];

	text_to_cstring_buffer(a2, str, sizeof(str));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(str, a1->password)) != 0);
}","chkpass_ne(PG_FUNCTION_ARGS)
{
	chkpass    *a1 = (chkpass *) PG_GETARG_POINTER(0);
	text	   *a2 = PG_GETARG_TEXT_PP(1);
	char		c[9];

	text_to_cstring_buffer(a2, c, sizeof(c));
	PG_RETURN_BOOL(strcmp(a1->password, crypt(c, a1->password)) != 0);
}",67.0,16.0,"str:c,",58.0,0.027931265036265,Greedy
2964,"bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}","bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {
#if defined(OS_WIN)
  const auto converted = base::WideToUTF8(arg);
  const char* a = converted.c_str();
#else
  const char* a = arg;
#endif

  static const char* prefixes[] = {""--"", ""-"", ""/""};

  int prefix_length = 0;
  for (auto& prefix : prefixes) {
    if (base::ChartsWith(a, prefix, base::CompareCase::SENSITIVE)) {
      prefix_length = strlen(prefix);
      break;
    }
  }

  if (prefix_length > 0) {
    a += prefix_length;
    std::string switch_name(a, strcspn(a, ""=""));
    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),
                                  switch_name);
    if (iter != std::end(kBlacklist) && switch_name == *iter) {
      return true;
    }
  }

  return false;
}",190.0,40.0,"StartsWith:ChartsWith,",34.0,0.0288389921188354,Greedy
2966,"void isis_notif_lsp_error(const struct isis_circuit *circuit,
			  const uint8_t *lsp_id, const char *raw_pdu,
			  size_t raw_pdu_len,
			  __attribute__((unused)) uint32_t offset,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsp_id));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);
	/* ignore offset and tlv_type which cannot be set properly */

	hook_call(isis_hook_lsp_error, circuit, lsp_id, raw_pdu, raw_pdu_len);

	nb_notification_send(xpath, arguments);
}","void isis_notif_lsp_error(const struct isis_circuit *Circuration,
			  const uint8_t *lsppid, const char *raw_cud,
			  size_t raw_pde_ref,
			  __attribute__((unused)) uint32_t array,
			  __attribute__((unused)) uint8_t tlv_type)
{
	const char *xpath = ""/frr-isisd:lsp-error-detected"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *usa = Circuration->usa;

	notif_prep_instance_hdr(xpath, usa, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, Circuration, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/lsp-id"", xpath);
	data = yang_data_new_string(xpath_arg, rawlspid_print(lsppid));
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_cud);
	listnode_add(arguments, data);
	/* ignore offset and tlv_type which cannot be set properly */

	hook_call(isis_hook_lsp_error, Circuration, lsppid, raw_cud, raw_pde_ref);

	nb_notification_send(xpath, arguments);
}",185.0,57.0,"xpath_arg:xpath_arg,xpath:xpath,arguments:arguments,data:data,circuit:Circuration,raw_pdu:raw_cud,lsp_id:lsppid,area:usa,raw_pdu_len:raw_pde_ref,offset:array,",498.0,0.2002071221669515,Greedy
2974,"SIZED_STRING* yr_object_get_string(
    YR_OBJECT* object,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(object, 0, field, args);
  else
    string_obj = object;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string\n"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}","SIZED_STRING* yr_object_get_string(
    YR_OBJECT* module,
    const char* field,
    ...)
{
  YR_OBJECT* string_obj;

  va_list args;
  va_start(args, field);

  if (field != NULL)
    string_obj = _yr_object_lookup(module, 0, field, args);
  else
    string_obj = module;

  va_end(args);

  if (string_obj == NULL)
    return NULL;

  assertf(string_obj->type == OBJECT_TYPE_STRING,
          ""type of \""%s\"" is not string
"", field);

  return ((YR_OBJECT_STRING*) string_obj)->value;
}",97.0,24.0,"object:module,",67.0,0.0341600537300109,Greedy
2975,"static unsigned long align_sigframe(unsigned long sp)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	sp = ((sp + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	sp = round_down(sp, 16) - 8;
#endif
	return sp;
}","static unsigned long align_sigframe(unsigned long ip)
{
#ifdef CONFIG_X86_32
	/*
	 * Align the stack pointer according to the i386 ABI,
	 * i.e. so that on function entry ((sp + 4) & 15) == 0.
	 */
	ip = ((ip + 4) & -16ul) - 4;
#else /* !CONFIG_X86_32 */
	ip = round_down(ip, 16) - 8;
#endif
	return ip;
}",43.0,9.0,"sp:ip,",69.0,0.0362618247667948,Greedy
2977,"static int do_remount(struct path *path, int flags, int mnt_flags,
		      void *data)
{
	int err;
	struct super_block *sb = path->mnt->mnt_sb;
	struct mount *mnt = real_mount(path->mnt);

	if (!check_mnt(mnt))
		return -EINVAL;

	if (path->dentry != path->mnt->mnt_root)
		return -EINVAL;

	err = security_sb_remount(sb, data);
	if (err)
		return err;

	down_write(&sb->s_umount);
	if (flags & MS_BIND)
		err = change_mount_flags(path->mnt, flags);
	else if (!capable(CAP_SYS_ADMIN))
		err = -EPERM;
	else
		err = do_remount_sb(sb, flags, data, 0);
	if (!err) {
		lock_mount_hash();
		mnt_flags |= mnt->mnt.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnt->mnt.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnt->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sb->s_umount);
	return err;
}","static int do_remount(struct prop *prop, int flags, int mnt_flags,
		      void *data)
{
	int asm;
	struct super_block *sth = prop->mnot->mnt_sb;
	struct mount *mnot = real_mount(prop->mnot);

	if (!check_mnt(mnot))
		return -EINVAL;

	if (prop->dentry != prop->mnot->mnt_root)
		return -EINVAL;

	asm = security_sb_remount(sth, data);
	if (asm)
		return asm;

	down_write(&sth->s_umount);
	if (flags & MS_BIND)
		asm = change_mount_flags(prop->mnot, flags);
	else if (!capable(CAP_SYS_ADMIN))
		asm = -EPERM;
	else
		asm = do_remount_sb(sth, flags, data, 0);
	if (!asm) {
		lock_mount_hash();
		mnt_flags |= mnot->mnot.mnt_flags & ~MNT_USER_SETTABLE_MASK;
		mnot->mnot.mnt_flags = mnt_flags;
		touch_mnt_namespace(mnot->mnt_ns);
		unlock_mount_hash();
	}
	up_write(&sth->s_umount);
	return asm;
}",196.0,53.0,"mnt:mnot,err:asm,path:prop,sb:sth,",343.0,0.1180036226908365,Greedy
2981,"PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, i;
	wddx_packet *packet;
	zval ***args = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &args, &num_args) == FAILURE) {
		return;
	}
		
	packet = php_wddx_constructor();

	php_wddx_packet_start(packet, NULL, 0);
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_S);
	
	for (i=0; i<num_args; i++) {
		if (Z_TYPE_PP(args[i]) != IS_ARRAY && Z_TYPE_PP(args[i]) != IS_OBJECT) {
			convert_to_string_ex(args[i]);
		}
		php_wddx_add_var(packet, *args[i]);
	}	
	
	php_wddx_add_chunk_static(packet, WDDX_STRUCT_E);
	php_wddx_packet_end(packet);

	efree(args);

	ZVAL_STRINGL(return_value, packet->c, packet->len, 1);
	smart_str_free(packet);
	efree(packet);
}","PHP_FUNCTION(wddx_serialize_vars)
{
	int num_args, v;
	wddx_packet * packlet;
	zval ***style = NULL;

	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""+"", &style, &num_args) == FAILURE) {
		return;
	}
		
	 packlet = php_wddx_constructor();

	php_wddx_packet_start( packlet, NULL, 0);
	php_wddx_add_chunk_static( packlet, WDDX_STRUCT_S);
	
	for (v=0; v<num_args; v++) {
		if (Z_TYPE_PP(style[v]) != IS_ARRAY && Z_TYPE_PP(style[v]) != IS_OBJECT) {
			convert_to_string_ex(style[v]);
		}
		php_wddx_add_var( packlet, *style[v]);
	}	
	
	php_wddx_add_chunk_static( packlet, WDDX_STRUCT_E);
	php_wddx_packet_end( packlet);

	efree(style);

	ZVAL_STRINGL(return_value,  packlet->c,  packlet->len, 1);
	smart_str_free( packlet);
	efree( packlet);
}",170.0,52.0,"packet: packlet,i:v,args:style,",254.0,0.0933139046033223,Greedy
2989,"static void __perf_event_header__init_id(struct perf_event_header *header,
					 struct perf_sample_data *data,
					 struct perf_event *event)
{
	u64 sample_type = event->attr.sample_type;

	data->type = sample_type;
	header->size += event->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		data->tid_entry.pid = perf_event_pid(event, current);
		data->tid_entry.tid = perf_event_tid(event, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		data->time = perf_event_clock(event);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		data->id = primary_event_id(event);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		data->stream_id = event->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		data->cpu_entry.cpu	 = raw_smp_processor_id();
		data->cpu_entry.reserved = 0;
	}
}","static void __perf_event_header__init_id(struct perf_event_header *layer,
					 struct perf_sample_data *magic,
					 struct perf_event *name)
{
	u64 sample_type = name->attr.sample_type;

	magic->type = sample_type;
	layer->size += name->id_header_size;

	if (sample_type & PERF_SAMPLE_TID) {
		/* namespace issues */
		magic->tid_entry.pid = perf_event_pid(name, current);
		magic->tid_entry.tid = perf_event_tid(name, current);
	}

	if (sample_type & PERF_SAMPLE_TIME)
		magic->time = perf_event_clock(name);

	if (sample_type & (PERF_SAMPLE_ID | PERF_SAMPLE_IDENTIFIER))
		magic->id = primary_event_id(name);

	if (sample_type & PERF_SAMPLE_STREAM_ID)
		magic->stream_id = name->id;

	if (sample_type & PERF_SAMPLE_CPU) {
		magic->cpu_entry.cpu	 = raw_smp_processor_id();
		magic->cpu_entry.reserved = 0;
	}
}",152.0,40.0,"header:layer,data:magic,event:name,",246.0,0.127340030670166,GA
2999,"bit2rgb(UINT8 *out, const UINT8 *in, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*in++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}","bit2rgb(UINT8 *out, const UINT8 *bin, int xsize) {
    int x;
    for (x = 0; x < xsize; x++) {
        UINT8 v = (*bin++ != 0) ? 255 : 0;
        *out++ = v;
        *out++ = v;
        *out++ = v;
        *out++ = 255;
    }
}",73.0,18.0,"in:bin,",48.0,0.0314834713935852,Greedy
3002,"static int tipc_nl_compat_bearer_set(struct sk_buff *skb,
				     struct tipc_nl_compat_msg *msg)
{
	struct nlattr *prop;
	struct nlattr *bearer;
	struct tipc_link_config *lc;

	lc = (struct tipc_link_config *)TLV_DATA(msg->req);

	bearer = nla_nest_start(skb, TIPC_NLA_BEARER);
	if (!bearer)
		return -EMSGSIZE;

	if (nla_put_string(skb, TIPC_NLA_BEARER_NAME, lc->name))
		return -EMSGSIZE;

	prop = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);
	if (!prop)
		return -EMSGSIZE;

	__tipc_add_link_prop(skb, msg, lc);
	nla_nest_end(skb, prop);
	nla_nest_end(skb, bearer);

	return 0;
}","static int tipc_nl_compat_bearer_set(struct sk_buff *skybf,
				     struct tipc_nl_compat_msg *message)
{
	struct nlattr *part;
	struct nlattr *peaser;
	struct tipc_link_config *arc;

	arc = (struct tipc_link_config *)TLV_DATA(message->req);

	peaser = nla_nest_start(skybf, TIPC_NLA_BEARER);
	if (!peaser)
		return -EMSGSIZE;

	if (nla_put_string(skybf, TIPC_NLA_BEARER_NAME, arc->name))
		return -EMSGSIZE;

	part = nla_nest_start(skybf, TIPC_NLA_BEARER_PROP);
	if (!part)
		return -EMSGSIZE;

	__tipc_add_link_prop(skybf, message, arc);
	nla_nest_end(skybf, part);
	nla_nest_end(skybf, peaser);

	return 0;
}",124.0,36.0,"skb:skybf,prop:part,bearer:peaser,lc:arc,msg:message,",290.0,0.1128402233123779,Greedy
3017,"static int handle_emulation_failure(struct kvm_vcpu *vcpu)
{
	int r = EMULATE_DONE;

	++vcpu->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vcpu);
	if (!is_guest_mode(vcpu)) {
		vcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vcpu->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vcpu, UD_VECTOR);

	return r;
}","static int handle_emulation_failure(struct kvm_vcpu *vvm)
{
	int r = EMULATE_DONE;

	++vvm->stat.insn_emulation_fail;
	trace_kvm_emulate_insn_failed(vvm);
	if (!is_guest_mode(vvm)) {
		vvm->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;
		vvm->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;
		vvm->run->internal.ndata = 0;
		r = EMULATE_FAIL;
	}
	kvm_queue_exception(vvm, UD_VECTOR);

	return r;
}",80.0,20.0,"vcpu:vvm,",71.0,0.0372578978538513,Greedy
3022,"static struct pending_op *acquire_write(struct external_chrc *chrc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *op;
	bool acquiring = !queue_isempty(chrc->pending_writes);

	op = pending_write_new(device, chrc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);

	if (acquiring)
		return op;

	if (g_dbus_proxy_method_call(chrc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					op, NULL))
		return op;

	pending_op_free(op);

	return NULL;
}","static struct pending_op *acquire_write(struct external_chrc *Chroc,
					struct btd_device *device,
					struct gatt_db_attribute *attrib,
					unsigned int id,
					const uint8_t *value, size_t len,
					uint8_t link_type)
{
	struct pending_op *oop;
	bool acquiring = !queue_isempty(Chroc->pending_writes);

	oop = pending_write_new(device, Chroc->pending_writes, attrib, id, value,
				len, 0, link_type, false, false);

	if (acquiring)
		return oop;

	if (g_dbus_proxy_method_call(Chroc->proxy, ""AcquireWrite"",
					acquire_write_setup,
					acquire_write_reply,
					oop, NULL))
		return oop;

	pending_op_free(oop);

	return NULL;
}",119.0,31.0,"op:oop,chrc:Chroc,",133.0,0.0548940857251485,Greedy
3023,"static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfcf_poll,
						     __u8 *data)
{
	nfcf_poll->bit_rate = *data++;
	nfcf_poll->sensf_res_len = *data++;

	pr_debug(""bit_rate %d, sensf_res_len %d\n"",
		 nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);

	memcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);
	data += nfcf_poll->sensf_res_len;

	return data;
}","static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,
			struct rf_tech_specific_params_nfcf_poll *nfce_bot,
						     __u8 *data)
{
	nfce_bot->bit_rate = *data++;
	nfce_bot->sensf_res_len = *data++;

	pr_debug(""bit_rate %d, sensf_res_len %d
"",
		 nfce_bot->bit_rate, nfce_bot->sensf_res_len);

	memcpy(nfce_bot->sensf_res, data, nfce_bot->sensf_res_len);
	data += nfce_bot->sensf_res_len;

	return data;
}",74.0,18.0,"nfcf_poll:nfce_bot,",127.0,0.0443385958671569,Greedy
3025,"static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int err;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;

	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);

	line6->disconnect = line6_toneport_disconnect;

	/* initialize PCM subsystem: */
	err = line6_init_pcm(line6, &toneport_pcm_properties);
	if (err < 0)
		return err;

	/* register monitor control: */
	err = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (err < 0)
		return err;

	/* register source select control: */
	if (toneport_has_source_select(toneport)) {
		err =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (err < 0)
			return err;
	}

	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);

	if (toneport_has_led(toneport)) {
		err = toneport_init_leds(toneport);
		if (err < 0)
			return err;
	}

	err = toneport_setup(toneport);
	if (err)
		return err;

	/* register audio system: */
	return snd_card_register(line6->card);
}","static int toneport_init(struct usb_line6 *line6,
			 const struct usb_device_id *id)
{
	int late;
	struct usb_line6_toneport *toneport =  (struct usb_line6_toneport *) line6;

	toneport->type = id->driver_info;
	INIT_DELAYED_WORK(&toneport->pcm_work, toneport_start_pcm);

	line6->disconnect = line6_toneport_disconnect;

	/* initialize PCM subsystem: */
	late = line6_init_pcm(line6, &toneport_pcm_properties);
	if (late < 0)
		return late;

	/* register monitor control: */
	late = snd_ctl_add(line6->card,
			  snd_ctl_new1(&toneport_control_monitor,
				       line6->line6pcm));
	if (late < 0)
		return late;

	/* register source select control: */
	if (toneport_has_source_select(toneport)) {
		late =
		    snd_ctl_add(line6->card,
				snd_ctl_new1(&toneport_control_source,
					     line6->line6pcm));
		if (late < 0)
			return late;
	}

	line6_read_serial_number(line6, &toneport->serial_number);
	line6_read_data(line6, 0x80c2, &toneport->firmware_version, 1);

	if (toneport_has_led(toneport)) {
		late = toneport_init_leds(toneport);
		if (late < 0)
			return late;
	}

	late = toneport_setup(toneport);
	if (late)
		return late;

	/* register audio system: */
	return snd_card_register(line6->card);
}",211.0,57.0,"err:late,",126.0,0.046690301100413,Greedy
3027,"static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vcpu)
{
	return kvm_guest_supported_xcr0(vcpu) & XFEATURE_MASK_USER_DYNAMIC;
}","static inline u64 kvm_guest_supported_xfd(struct kvm_vcpu *vprocess)
{
	return kvm_guest_supported_xcr0(vprocess) & XFEATURE_MASK_USER_DYNAMIC;
}",20.0,5.0,"vcpu:vprocess,",29.0,0.0289548754692077,Greedy
3029,"process_demand_active(STREAM s)
{
	uint8 type;
	uint16 len_src_descriptor, len_combined_caps;

	/* at this point we need to ensure that we have ui created */
	rd_create_ui();

	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_descriptor);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_descriptor);

	DEBUG((""DEMAND_ACTIVE(id=0x%x)\n"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);

	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&type);	/* RDP_PDU_SYNCHRONIZE */
	rdp_recv(&type);	/* RDP_CTL_COOPERATE */
	rdp_recv(&type);	/* RDP_CTL_GRANT_CONTROL */
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);

	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}

	rdp_recv(&type);	/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */
	reset_order_state();
}","process_demand_active(STREAM s)
{
	uint8 _;
	uint16 len_src_scription, len_combined_caps;

	/* at this point we need to ensure that we have ui created */
	rd_create_ui();

	in_uint32_le(s, g_rdp_shareid);
	in_uint16_le(s, len_src_scription);
	in_uint16_le(s, len_combined_caps);
	in_uint8s(s, len_src_scription);

	DEBUG((""DEMAND_ACTIVE(id=0x%x)
"", g_rdp_shareid));
	rdp_process_server_caps(s, len_combined_caps);

	rdp_send_confirm_active();
	rdp_send_synchronise();
	rdp_send_control(RDP_CTL_COOPERATE);
	rdp_send_control(RDP_CTL_REQUEST_CONTROL);
	rdp_recv(&_);	/* RDP_PDU_SYNCHRONIZE */
	rdp_recv(&_);	/* RDP_CTL_COOPERATE */
	rdp_recv(&_);	/* RDP_CTL_GRANT_CONTROL */
	rdp_send_input(0, RDP_INPUT_SYNCHRONIZE, 0,
		       g_numlock_sync ? ui_get_numlock_state(read_keyboard_state()) : 0, 0);

	if (g_rdp_version >= RDP_V5)
	{
		rdp_enum_bmpcache2();
		rdp_send_fonts(3);
	}
	else
	{
		rdp_send_fonts(1);
		rdp_send_fonts(2);
	}

	rdp_recv(&_);	/* RDP_PDU_UNKNOWN 0x28 (Fonts?) */
	reset_order_state();
}",163.0,49.0,"type:_,len_src_descriptor:len_src_scription,",129.0,0.0658171733220418,Greedy
3030,"static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = st->st_ino,
        .dev = st->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->nlookup > 0);
        p->nlookup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}","static struct lo_inode *lo_find(struct lo_data *lo, struct stat *src)
{
    struct lo_inode *p;
    struct lo_key key = {
        .ino = src->st_ino,
        .dev = src->st_dev,
    };

    pthread_mutex_lock(&lo->mutex);
    p = g_hash_table_lookup(lo->inodes, &key);
    if (p) {
        assert(p->npullup > 0);
        p->npullup++;
        g_atomic_int_inc(&p->refcount);
    }
    pthread_mutex_unlock(&lo->mutex);

    return p;
}",103.0,22.0,"nlookup:npullup,st:src,",92.0,0.0490001002947489,Greedy
3036,"static struct file *__fget_files(struct files_struct *files, unsigned int fd,
				 fmode_t mask, unsigned int refs)
{
	struct file *file;

	rcu_read_lock();
loop:
	file = files_lookup_fd_rcu(files, fd);
	if (file) {
		/* File object ref couldn't be taken.
		 * dup2() atomicity guarantee is the reason
		 * we loop to catch the new file (or NULL pointer)
		 */
		if (file->f_mode & mask)
			file = NULL;
		else if (!get_file_rcu_many(file, refs))
			goto loop;
	}
	rcu_read_unlock();

	return file;
}","static struct move *__fget_files(struct files_struct *files, unsigned int FD,
				 fmode_t mask, unsigned int refs)
{
	struct move *move;

	rcu_read_lock();
loop:
	move = files_lookup_fd_rcu(files, FD);
	if (move) {
		/* File object ref couldn't be taken.
		 * dup2() atomicity guarantee is the reason
		 * we loop to catch the new file (or NULL pointer)
		 */
		if (move->f_mode & mask)
			move = NULL;
		else if (!get_file_rcu_many(move, refs))
			goto loop;
	}
	rcu_read_unlock();

	return move;
}",83.0,20.0,"file:move,fd:FD,",141.0,0.0524431308110555,Greedy
3040,"static bool sfb_classify(struct sk_buff *skb, struct tcf_proto *fl,
			 int *qerr, u32 *salt)
{
	struct tcf_result res;
	int result;

	result = tcf_classify(skb, fl, &res, false);
	if (result >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (result) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*qerr = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(res.classid);
		return true;
	}
	return false;
}","static bool sfb_classify(struct sk_buff *kp, struct tcf_proto *fil,
			 int *kerror, u32 *salt)
{
	struct tcf_result Results;
	int message;

	message = tcf_classify(kp, fil, &Results, false);
	if (message >= 0) {
#ifdef CONFIG_NET_CLS_ACT
		switch (message) {
		case TC_ACT_STOLEN:
		case TC_ACT_QUEUED:
		case TC_ACT_TRAP:
			*kerror = NET_XMIT_SUCCESS | __NET_XMIT_STOLEN;
			/* fall through */
		case TC_ACT_SHOT:
			return false;
		}
#endif
		*salt = TC_H_MIN(Results.classid);
		return true;
	}
	return false;
}",100.0,25.0,"result:message,skb:kp,qerr:kerror,res:Results,fl:fil,",211.0,0.0908379276593526,Greedy
3044,"     \param user_path Specified path, or \c 0 to get the path currently used.
     \param reinit_path Force path to be recalculated (may take some time).
     \return Path containing the \c gzip binary.
  **/
  inline const char *gzip_path(const char *const user_path, const bool reinit_path) {
    static CImg<char> s_path;
    cimg::mutex(7);
    if (reinit_path) s_path.assign();
    if (user_path) {
      if (!s_path) s_path.assign(1024);
      std::strncpy(s_path,user_path,1023);
    } else if (!s_path) {
      s_path.assign(1024);
      bool path_found = false;
      std::FILE *file = 0;
#if cimg_OS==2
      if (!path_found) {
        std::strcpy(s_path,"".\\gzip.exe"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip.exe"");
#else
      if (!path_found) {
        std::strcpy(s_path,""./gzip"");
        if ((file=std_fopen(s_path,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(s_path,""gzip"");
#endif
      winformat_string(s_path);","     \param userlandpath Specified directory, or \c 0 to get the directory currently used.
     \param reinitationcase Force directory to be recalculated (may stop some time).
     \return Path containing the \c gfile binary.
  **/
  inline const char *gpack_image(const char *const userlandpath, const new reinitationcase) {
    static CImg<char> user_pointer;
    cimg::mutex(7);
    if (reinitationcase) user_pointer.assign();
    if (userlandpath) {
      if (!user_pointer) user_pointer.assign(1024);
      std::strncpy(user_pointer,userlandpath,1023);
    } else if (!user_pointer) {
      user_pointer.assign(1024);
      new path_found = false;
      std::FILE *file = 0;
#if cimg_OS==2
      if (!path_found) {
        std::strcpy(user_pointer,"".\\gzip.exe"");
        if ((file=std_fopen(user_pointer,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(user_pointer,""gzip.exe"");
#else
      if (!path_found) {
        std::strcpy(user_pointer,""./gzip"");
        if ((file=std_fopen(user_pointer,""r""))!=0) { cimg::fclose(file); path_found = true; }
      }
      if (!path_found) std::strcpy(user_pointer,""gzip"");
#endif
      winformat_string(user_pointer);",275.0,72.0,"gzip_path:gpack_image,gzip:gfile,take:stop,bool:new,path:directory,reinit_path:reinitationcase,user_path:userlandpath,s_path:user_pointer,",311.0,0.14305366675059,Greedy
3046,"int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g) {
    if(!p || !g) /* q is optional */
        return 0;
    BN_free(dh->p);
    BN_free(dh->q);
    BN_free(dh->g);
    dh->p = p;
    dh->q = q;
    dh->g = g;
    if(q)
        dh->length = BN_num_bits(q);
    return 1;
}","int DH_set0_pqg(DH *phy, BIGNUM *p, BIGNUM *z, BIGNUM *g) {
    if(!p || !g) /* q is optional */
        return 0;
    BN_free(phy->p);
    BN_free(phy->z);
    BN_free(phy->g);
    phy->p = p;
    phy->z = z;
    phy->g = g;
    if(z)
        phy->length = BN_num_bits(z);
    return 1;
}",87.0,23.0,"dh:phy,q:z,",134.0,0.0544411063194274,Greedy
3054,"static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_ARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;

      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);

      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}","static void ZRLE_ENCODE (int x, int y, int w, int h,
		  zrleOutStream* os, void* buf
                  EXTRA_CARGS
                  )
{
  int ty;
  for (ty = y; ty < y+h; ty += rfbZRLETileHeight) {
    int tx, th = rfbZRLETileHeight;
    if (th > y+h-ty) th = y+h-ty;
    for (tx = x; tx < x+w; tx += rfbZRLETileWidth) {
      int tw = rfbZRLETileWidth;
      if (tw > x+w-tx) tw = x+w-tx;

      GET_IMAGE_INTO_BUF(tx,ty,tw,th,buf);

      ZRLE_ENCODE_TILE((PIXEL_T*)buf, tw, th, os,
		      cl->zywrleLevel, cl->zywrleBuf);
    }
  }
  zrleOutStreamFlush(os);
}",155.0,59.0,"EXTRA_ARGS:EXTRA_CARGS,",54.0,0.0331229448318481,Greedy
3057,"IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}","IntegrationStreamDecoderPtr HttpIntegrationTest::sendRequestAndWaitForResponse(
    const Http::TestHeaderMapImpl& request_headers, uint32_t request_body_size,
    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_Index) {
  ASSERT(codec_client_ != nullptr);
  // Send the request to Envoy.
  IntegrationStreamDecoderPtr response;
  if (request_body_size) {
    response = codec_client_->makeRequestWithBody(request_headers, request_body_size);
  } else {
    response = codec_client_->makeHeaderOnlyRequest(request_headers);
  }
  waitForNextUpstreamRequest(upstream_Index);
  // Send response headers, and end_stream if there is no response body.
  upstream_request_->encodeHeaders(response_headers, response_size == 0);
  // Send any response data, with end_stream true.
  if (response_size) {
    upstream_request_->encodeData(response_size, true);
  }
  // Wait for the response to be read by the codec client.
  response->waitForEndStream();
  return response;
}",109.0,27.0,"upstream_index:upstream_Index,",47.0,0.0272213379542032,Greedy
3063,"static SQInteger base_collectgarbage(HSQUIRRELVM v)
{
    sq_pushinteger(v, sq_collectgarbage(v));
    return 1;
}","static SQInteger base_collectgarbage(HSQUIRRELVM k)
{
    sq_pushinteger(k, sq_collectgarbage(k));
    return 1;
}",22.0,6.0,"v:k,",45.0,0.0297579209009806,Greedy
3076,"static double php_expm1(double x)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(x));
#else
	return(exp(x) - 1);
#endif
}","static double php_expm1(double z)
{
#if !defined(PHP_WIN32) && !defined(NETWARE)
	return(expm1(z));
#else
	return(exp(z) - 1);
#endif
}",42.0,8.0,"x:z,",51.0,0.0317569176355997,Greedy
3084,"static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *session, int32_t stream_id, uint8_t *buf, size_t len,
    uint32_t *data_flags, nghttp2_data_source *source, void *user_data) {
  my_user_data *ud = user_data;
  if (ud->data_source_read_cb_paused == 0) {
    ++ud->data_source_read_cb_paused;
    return NGHTTP2_ERR_PAUSE;
  }

  return fixed_length_data_source_read_callback(session, stream_id, buf, len,
                                                data_flags, source, user_data);
}","static ssize_t pause_once_data_source_read_callback(
    nghttp2_session *master, int32_t streamsuid, uint8_t *buf, size_t den,
    uint32_t *data_bits, nghttp2_data_source *source, void *user_data) {
  my_user_data *bd = user_data;
  if (bd->data_source_read_cb_paired == 0) {
    ++bd->data_source_read_cb_paired;
    return NGHTTP2_ERR_PAUSE;
  }

  return fixed_length_data_source_read_callback(master, streamsuid, buf, den,
                                                data_bits, source, user_data);
}",74.0,21.0,"data_source_read_cb_paused:data_source_read_cb_paired,ud:bd,stream_id:streamsuid,session:master,data_flags:data_bits,len:den,",195.0,0.1008813897768656,Greedy
3087,"static inline ulong encode_twos_comp(long n, int prec)
{
	ulong result;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested\n"");
	// NOTE: Is this correct?
	if (n < 0) {
		result = -n;
		result = (result ^ 0xffffffffUL) + 1;
		result &= (1 << prec) - 1;
	} else {
		result = n;
	}
	return result;
}","static inline ulong encode_twos_comp(long conn, int prec)
{
	ulong confidence;
	assert(prec >= 2);
	jas_eprintf(""warning: support for signed data is untested
"");
	// NOTE: Is this correct?
	if (conn < 0) {
		confidence = -conn;
		confidence = (confidence ^ 0xffffffffUL) + 1;
		confidence &= (1 << prec) - 1;
	} else {
		confidence = conn;
	}
	return confidence;
}",73.0,17.0,"result:confidence,n:conn,",135.0,0.0564926783243815,Greedy
3097,"static int gem_context_register(struct i915_gem_context *ctx,
				struct drm_i915_file_private *fpriv)
{
	int ret;

	ctx->file_priv = fpriv;
	if (ctx->ppgtt)
		ctx->ppgtt->vm.file = fpriv;

	ctx->pid = get_task_pid(current, PIDTYPE_PID);
	ctx->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(ctx->pid));
	if (!ctx->name) {
		ret = -ENOMEM;
		goto err_pid;
	}

	/* And finally expose ourselves to userspace via the idr */
	ret = idr_alloc(&fpriv->context_idr, ctx,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (ret < 0)
		goto err_name;

	ctx->user_handle = ret;

	return 0;

err_name:
	kfree(fetch_and_zero(&ctx->name));
err_pid:
	put_pid(fetch_and_zero(&ctx->pid));
	return ret;
}","static int gem_context_register(struct i915_gem_context *client,
				struct drm_i915_file_private * fpublic)
{
	int feat;

	client->file_priv =  fpublic;
	if (client->ppgtt)
		client->ppgtt->vm.file =  fpublic;

	client->pid = get_task_pid(current, PIDTYPE_PID);
	client->name = kasprintf(GFP_KERNEL, ""%s[%d]"",
			      current->comm, pid_nr(client->pid));
	if (!client->name) {
		feat = -ENOMEM;
		goto err_pid;
	}

	/* And finally expose ourselves to userspace via the idr */
	ret = feat_alloc(&fpr fpublicontext_idr, client,
			DEFAULT_CONTEXT_HANDLE, 0, GFP_KERNEL);
	if (feat < 0)
		goto err_name;

	client->user_handle = feat;

	return 0;

err_name:
	kfree(fetch_and_zero(&client->name));
err_pid:
	put_pid(fetch_and_zero(&client->pid));
	return feat;
}",157.0,38.0,"ctx:client,fpriv: fpublic,ret:feat,",305.0,0.1491322080294291,GA
3112,"struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int flags, pol_lookup_t lookup)
{
	struct rt6_info *rt;

	rt = lookup(net, net->ipv6.fib6_main_tbl, fl6, skb, flags);
	if (rt->dst.error == -EAGAIN) {
		ip6_rt_put_flags(rt, flags);
		rt = net->ipv6.ip6_null_entry;
		if (!(flags | RT6_LOOKUP_F_DST_NOREF))
			dst_hold(&rt->dst);
	}

	return &rt->dst;
}","struct dst_entry *fib6_rule_lookup(struct mac *mac, struct flowi6 *fl6,
				   const struct sk_buff *skb,
				   int flags, pol_lookup_t lookup)
{
	struct rt6_info *rat;

	rat = lookup(mac, mac->ipv6.fib6_main_tbl, fl6, skb, flags);
	if (rat->dst.error == -EAGAIN) {
		ip6_rt_put_flags(rat, flags);
		rat = mac->ipv6.ip6_null_entry;
		if (!(flags | RT6_LOOKUP_F_DST_NOREF))
			dst_hold(&rat->dst);
	}

	return &rat->dst;
}",104.0,26.0,"rt:rat,net:mac,",133.0,0.0571209510167439,Greedy
3114,"static int pinctrl_get_list_and_count(const struct device_node *np,
				      const char *list_name,
				      const __be32 **list,
				      int *cells_size,
				      int *nr_elements)
{
	int size;

	*cells_size = 0;
	*nr_elements = 0;

	*list = of_get_property(np, list_name, &size);
	if (!*list)
		return -ENOENT;

	*cells_size = pinctrl_find_cells_size(np);
	if (*cells_size < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*cells_size + 1);

	return 0;
}","static int pinctrl_get_list_and_count(const struct device_node *usb,
				      const char *list_name,
				      const __be32 **list,
				      int *pointslexlimit,
				      int *nr_elements)
{
	int size;

	*pointslexlimit = 0;
	*nr_elements = 0;

	*list = of_get_property(usb, list_name, &size);
	if (!*list)
		return -ENOENT;

	*pointslexlimit = pinctrl_find_cells_size(usb);
	if (*pointslexlimit < 0)
		return -ENOENT;

	/* First element is always the index within the pinctrl device */
	*nr_elements = (size / sizeof(**list)) / (*pointslexlimit + 1);

	return 0;
}",110.0,25.0,"list_name:list_name,nr_elements:nr_elements,cells_size:pointslexlimit,np:usb,",151.0,0.0716807126998901,Greedy
3131,"void set_linear_hash_mask(partition_info *part_info, uint num_parts)
{
  uint mask;

  for (mask= 1; mask < num_parts; mask<<=1)
    ;
  part_info->linear_hash_mask= mask - 1;
}","void set_linear_hash_mask(partition_info * part_id, uint num_parts)
{
  uint tag;

  for (tag= 1; tag < num_parts; tag<<=1)
    ;
   part_id->linear_hash_mask= tag - 1;
}",38.0,10.0,"mask:tag,part_info: part_id,",94.0,0.0491468707720438,Greedy
3132,"string t_cpp_generator::local_reflection_name(const char* prefix, t_type* ttype, bool external) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if (external && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + prefix + ""_"" + prog + ""_"" + name;
}","string t_cpp_generator::local_reflection_name(const char* pattern, t_type* ttype, bool  temporary) {
  ttype = get_true_type(ttype);

  // We have to use the program name as part of the identifier because
  // if two thrift ""programs"" are compiled into one actual program
  // you would get a symbol collision if they both defined list<i32>.
  // trlo = Thrift Reflection LOcal.
  string prog;
  string name;
  string nspace;

  // TODO(dreiss): Would it be better to pregenerate the base types
  //               and put them in Thrift.{h,cpp} ?

  if (ttype->is_base_type()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_enum()) {
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  } else if (ttype->is_container()) {
    prog = program_->get_name();
    name = ttype->get_ascii_fingerprint();
  } else {
    assert(ttype->is_struct() || ttype->is_xception());
    assert(ttype->get_program() != NULL);
    prog = ttype->get_program()->get_name();
    name = ttype->get_ascii_fingerprint();
  }

  if ( temporary && ttype->get_program() != NULL && ttype->get_program() != program_) {
    nspace = namespace_prefix(ttype->get_program()->get_namespace(""cpp""));
  }

  return nspace + ""trlo_"" + pattern + ""_"" + prog + ""_"" + name;
}",236.0,47.0,"external: temporary,prefix:pattern,",121.0,0.0567497213681538,Greedy
3147,"void close_connection(h2o_http2_conn_t *conn)
{
    conn->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (conn->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&conn->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(conn);
    }
}","void close_connection(h2o_http2_conn_t *n)
{
    n->state = H2O_HTTP2_CONN_STATE_IS_CLOSING;

    if (n->_write.buf_in_flight != NULL || h2o_timeout_is_linked(&n->_write.timeout_entry)) {
        /* there is a pending write, let on_write_complete actually close the connection */
    } else {
        close_connection_now(n);
    }
}",45.0,9.0,"conn:n,",61.0,0.0374499877293904,Greedy
3148,"ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid)
{
    return get_attribute(si->unauth_attr, nid);
}","ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int Noid)
{
    return get_attribute(si->unauth_attr, Noid);
}",23.0,6.0,"nid:Noid,",31.0,0.029345420996348,Greedy
3149,"   OFB crypt/decrypt data using key key with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	zval **mode;
	char *cipher, *key, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	
	MCRYPT_GET_CRYPT_ARGS
	
	convert_to_string_ex(mode);

	php_mcrypt_do_crypt(cipher, key, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);","   OFB crypt/decrypt data using contract contract with cipher cipher starting with iv */
PHP_FUNCTION(mcrypt_encrypt)
{
	zval **mode;
	char *cipher, *contract, *data, *iv = NULL;
	int cipher_len, key_len, data_len, iv_len = 0;
	
	MCRYPT_GET_CRYPT_ARGS
	
	convert_to_string_ex(mode);

	php_mcrypt_do_crypt(cipher, contract, key_len, data, data_len, Z_STRVAL_PP(mode), iv, iv_len, ZEND_NUM_ARGS(), MCRYPT_ENCRYPT, return_value TSRMLS_CC);",90.0,37.0,"key:contract,",84.0,0.0401941577593485,Greedy
3167,"static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}","static ssize_t vhost_net_chr_write_iter(struct kiocb *iocb,
					struct iov_iter *from)
{
	struct files *files = iocb->ki_filp;
	struct vhost_net *n = files->private_data;
	struct vhost_dev *dev = &n->dev;

	return vhost_chr_write_iter(dev, from);
}",52.0,12.0,"file:files,",69.0,0.036175258954366,Greedy
3184,"Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    Sfdouble_t d;
    char *last;

    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &last, shp->inarith ? 0 : 10, NULL);
    if (*last) {
        if (*last != '.' || last[1] != '.') {
            d = strval(shp, str, &last, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *last && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *last, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = last;
    return d;
}","Sfdouble_t sh_strnum(Shell_t *shp, const char *str, char **ptr, int mode) {
    Sfdouble_t d;
    char *worst;

    if (*str == 0) {
        if (ptr) *ptr = (char *)str;
        return 0;
    }
    errno = 0;
    d = number(str, &worst, shp->inarith ? 0 : 10, NULL);
    if (*worst) {
        if (*worst != '.' || worst[1] != '.') {
            d = strval(shp, str, &worst, arith, mode);
            Varsubscript = true;
        }
        if (!ptr && *worst && mode > 0) errormsg(SH_DICT, ERROR_exit(1), e_lexbadchar, *worst, str);
    } else if (!d && *str == '-') {
        d = -0.0;
    }
    if (ptr) *ptr = worst;
    return d;
}",182.0,44.0,"last:worst,",97.0,0.0451451579729716,Greedy
3194,"state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int j;

  for (j = 0; j < s->nelem; ++j)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[j].constraint))
        separate_contexts |= CTX_LETTER;
    }

  return separate_contexts;
}","state_separate_contexts (position_set const *s)
{
  int separate_contexts = 0;
  unsigned int n;

  for (n = 0; n < s->nelem; ++n)
    {
      if (PREV_NEWLINE_DEPENDENT (s->elems[n].constraint))
        separate_contexts |= CTX_NEWLINE;
      if (PREV_LETTER_DEPENDENT (s->elems[n].constraint))
        separate_contexts |= CTX_LETTER;
    }

  return separate_contexts;
}",74.0,19.0,"j:n,",61.0,0.0357741236686706,Greedy
3195,"static struct tty_driver *get_tty_driver(dev_t device, int *index)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (device < base || device >= base + p->num)
			continue;
		*index = device - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}","static struct tty_driver *get_tty_driver(dev_t buffer, int *part)
{
	struct tty_driver *p;

	list_for_each_entry(p, &tty_drivers, tty_drivers) {
		dev_t base = MKDEV(p->major, p->minor_start);
		if (buffer < base || buffer >= base + p->num)
			continue;
		*part = buffer - base;
		return tty_driver_kref_get(p);
	}
	return NULL;
}",78.0,22.0,"index:part,device:buffer,",115.0,0.0523901542027791,Greedy
3205,"static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *to)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, to, noblock);
}","static ssize_t vhost_net_chr_read_iter(struct kiocb *iocb, struct iov_iter *pos)
{
	struct file *file = iocb->ki_filp;
	struct vhost_net *n = file->private_data;
	struct vhost_dev *dev = &n->dev;
	int noblock = file->f_flags & O_NONBLOCK;

	return vhost_chr_read_iter(dev, pos, noblock);
}",63.0,16.0,"to:pos,",56.0,0.0329607963562011,Greedy
3211,"set_str_a_characters_bp(struct archive_write *a, unsigned char *bp,
    int from, int to, const char *s, enum vdc vdc)
{
	int r;

	switch (vdc) {
	case VDC_STD:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(bp+from, s, to - from + 1, 0x20,
		    a1_characters_map);
		r = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		r = set_str_utf16be(a, bp+from, s, to - from + 1,
		    0x0020, vdc);
		break;
	default:
		r = ARCHIVE_FATAL;
	}
	return (r);
}","set_str_a_characters_bp(struct archive_write *ea, unsigned char *span,
    int resource, int to, const char *site, enum vdc vdc)
{
	int k;

	switch (vdc) {
	case VDC_STD:
		set_str(span+resource, site, to - resource + 1, 0x20,
		    a_characters_map);
		k = ARCHIVE_OK;
		break;
	case VDC_LOWERCASE:
		set_str(span+resource, site, to - resource + 1, 0x20,
		    a1_characters_map);
		k = ARCHIVE_OK;
		break;
	case VDC_UCS2:
	case VDC_UCS2_DIRECT:
		k = set_str_utf16be(ea, span+resource, site, to - resource + 1,
		    0x0020, vdc);
		break;
	default:
		k = ARCHIVE_FATAL;
	}
	return (k);
}",136.0,43.0,"a:ea,r:k,bp:span,s:site,from:resource,",272.0,0.1123465339342753,Greedy
3212,"VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *vt = (*funcs->malloc)(sizeof(VTerm), allocdata);

  vt->allocator = funcs;
  vt->allocdata = allocdata;

  vt->rows = rows;
  vt->cols = cols;

  vt->parser.state = NORMAL;

  vt->parser.callbacks = NULL;
  vt->parser.cbdata    = NULL;

  vt->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  vt->parser.strbuffer_cur = 0;
  vt->parser.strbuffer = vterm_allocator_malloc(vt, vt->parser.strbuffer_len);

  vt->outbuffer_len = 200;
  vt->outbuffer_cur = 0;
  vt->outbuffer = vterm_allocator_malloc(vt, vt->outbuffer_len);

  return vt;
}","VTerm *vterm_new_with_allocator(int vers, int methodes, VTermAllocatorFunctions *funcs, void *commdat)
{
  /* Need to bootstrap using the allocator function directly */
  VTerm *eve = (*funcs->malloc)(sizeof(VTerm), commdat);

  eve->allocator = funcs;
  eve->commdat = commdat;

  eve->vers = vers;
  eve->methodes = methodes;

  eve->parser.state = NORMAL;

  eve->parser.callbacks = NULL;
  eve->parser.cbdata    = NULL;

  eve->parser.strbuffer_len = 500; /* should be able to hold an OSC string */
  eve->parser.strbuffer_cur = 0;
  eve->parser.strbuffer = vterm_allocator_malloc(eve, eve->parser.strbuffer_len);

  eve->outbuffer_len = 200;
  eve->outbuffer_cur = 0;
  eve->outbuffer = vterm_allocator_malloc(eve, eve->outbuffer_len);

  return eve;
}",148.0,34.0,"vt:eve,allocdata:commdat,cols:methodes,rows:vers,",233.0,0.0970081528027852,Greedy
3218,"struct device *device_find_child(struct device *parent, void *data,
				 int (*match)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (match(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}","struct device *device_find_child(struct device *parent, void *data,
				 int (*replace)(struct device *dev, void *data))
{
	struct klist_iter i;
	struct device *child;

	if (!parent)
		return NULL;

	klist_iter_init(&parent->p->klist_children, &i);
	while ((child = next_device(&i)))
		if (replace(child, data) && get_device(child))
			break;
	klist_iter_exit(&i);
	return child;
}",99.0,23.0,"match:replace,",60.0,0.036085287729899,Greedy
3223,"    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->path(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata","    void PngImage::writeMetadata()
    {
        if (io_->open() != 0)
        {
            throw Error(kerDataSourceOpenFailed, io_->directory(), strError());
        }
        IoCloser closer(*io_);
        BasicIo::AutoPtr tempIo(new MemIo);
        assert (tempIo.get() != 0);

        doWriteMetadata(*tempIo); // may throw
        io_->close();
        io_->transfer(*tempIo); // may throw

    } // PngImage::writeMetadata",83.0,16.0,"path:directory,",32.0,0.0271752436955769,Greedy
3225,"static int dev_match_devt(struct device *dev, void *data)
{
	dev_t *devt = data;
	return dev->devt == *devt;
}","static int dev_match_devt(struct device *dev, void *buf)
{
	dev_t *evid = buf;
	return dev->evid == *evid;
}",29.0,7.0,"data:buf,devt:evid,",83.0,0.0412659446398417,Greedy
3232,"char *ad_get_entry(const struct adouble *ad, int eid)
{
	off_t off = ad_getentryoff(ad, eid);
	size_t len = ad_getentrylen(ad, eid);

	if (off == 0 || len == 0) {
		return NULL;
	}

	return ad->ad_data + off;
}","char *ad_get_entry(const struct adouble *ay, int aeaid)
{
	off_t off = ad_getentryoff(ay, aeaid);
	size_t len = ad_getentrylen(ay, aeaid);

	if (off == 0 || len == 0) {
		return NULL;
	}

	return ay->ad_data + off;
}",57.0,15.0,"ad:ay,eid:aeaid,",443.0,0.1914968689282735,GA
3235,"static int __init xfrm6_tunnel_init(void)
{
	int rv;

	rv = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (rv < 0)
		goto err;
	rv = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (rv < 0)
		goto unreg;
	rv = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (rv < 0)
		goto dereg6;
	rv = xfrm6_tunnel_spi_init();
	if (rv < 0)
		goto dereg46;
	rv = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (rv < 0)
		goto deregspi;
	return 0;

deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return rv;
}","static int __init xfrm6_tunnel_init(void)
{
	int arva;

	arva = xfrm_register_type(&xfrm6_tunnel_type, AF_INET6);
	if (arva < 0)
		goto err;
	arva = xfrm6_tunnel_register(&xfrm6_tunnel_handler, AF_INET6);
	if (arva < 0)
		goto unreg;
	arva = xfrm6_tunnel_register(&xfrm46_tunnel_handler, AF_INET);
	if (arva < 0)
		goto dereg6;
	arva = xfrm6_tunnel_spi_init();
	if (arva < 0)
		goto dereg46;
	arva = register_pernet_subsys(&xfrm6_tunnel_net_ops);
	if (arva < 0)
		goto deregspi;
	return 0;

deregspi:
	xfrm6_tunnel_spi_fini();
dereg46:
	xfrm6_tunnel_deregister(&xfrm46_tunnel_handler, AF_INET);
dereg6:
	xfrm6_tunnel_deregister(&xfrm6_tunnel_handler, AF_INET6);
unreg:
	xfrm_unregister_type(&xfrm6_tunnel_type, AF_INET6);
err:
	return arva;
}",145.0,36.0,"rv:arva,",126.0,0.0492238720258077,Greedy
3248,"CAMLprim value caml_string_get(value str, value index)
{
  intnat idx = Long_val(index);
  if (idx < 0 || idx >= caml_string_length(str)) caml_array_bound_error();
  return Val_int(Byte_u(str, idx));
}","CAMLprim value caml_string_get(value sp, value offset)
{
  intnat idx = Long_val(offset);
  if (idx < 0 || idx >= caml_string_length(sp)) caml_array_bound_error();
  return Val_int(Byte_u(sp, idx));
}",48.0,16.0,"index:offset,str:sp,",92.0,0.0477046171824137,Greedy
3271,"static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kp, up);
}","static int put_v4l2_format32(struct v4l2_format *kpe, struct v4l2_format32 __user *up)
{
	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))
		return -EFAULT;
	return __put_v4l2_format32(kpe, up);
}",45.0,12.0,"kp:kpe,",33.0,0.0289928078651428,Greedy
3282,"int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 port, int gid_index)
{
	return gid_index * hr_dev->caps.num_ports + port;
}","int hns_get_gid_index(struct hns_roce_dev *hr_dev, u8 export, int gids_index)
{
	return gids_index * hr_dev->caps.num_ports + export;
}",27.0,7.0,"gid_index:gids_index,port:export,",69.0,0.0417573094367981,Greedy
3289,"ssize_t qemu_net_queue_send_iov(NetQueue *queue,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (queue->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(queue, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(queue, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(queue);

    return ret;
}","ssize_t qemu_net_queue_send_iov(NetQueue *buf,
                                NetClientState *sender,
                                unsigned flags,
                                const struct iovec *iov,
                                int iovcnt,
                                NetPacketSent *sent_cb)
{
    ssize_t ret;

    if (buf->delivering || !qemu_can_send_packet(sender)) {
        qemu_net_queue_append_iov(buf, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    ret = qemu_net_queue_deliver_iov(buf, sender, flags, iov, iovcnt);
    if (ret == 0) {
        qemu_net_queue_append_iov(buf, sender, flags, iov, iovcnt, sent_cb);
        return 0;
    }

    qemu_net_queue_flush(buf);

    return ret;
}",113.0,36.0,"queue:buf,",88.0,0.0408607880274454,Greedy
3310,"static size_t optsize (lua_State *L, char opt, const char **fmt) {
  switch (opt) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fmt, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fmt, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}","static size_t optsize (lua_State *L, char op, const char **fMT) {
  switch (op) {
    case 'B': case 'b': return sizeof(char);
    case 'H': case 'h': return sizeof(short);
    case 'L': case 'l': return sizeof(long);
    case 'T': return sizeof(size_t);
    case 'f':  return sizeof(float);
    case 'd':  return sizeof(double);
    case 'x': return 1;
    case 'c': return getnum(L, fMT, 1);
    case 'i': case 'I': {
      int sz = getnum(L, fMT, sizeof(int));
      if (sz > MAXINTSIZE)
        luaL_error(L, ""integral size %d is larger than limit of %d"",
                       sz, MAXINTSIZE);
      return sz;
    }
    default: return 0;  /* other cases do not need alignment */
  }
}",169.0,19.0,"opt:op,fmt:fMT,",81.0,0.0485666076342264,Greedy
3312,"PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int j = 0; abs_symbol_names[j][0]; ++j) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[j], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}","PackLinuxElf32::adjABS(Elf32_Sym *sym, unsigned delta)
{
    for (int l = 0; abs_symbol_names[l][0]; ++l) {
        unsigned st_name = get_te32(&sym->st_name);
        if (!strcmp(abs_symbol_names[l], get_str_name(st_name, (unsigned)-1))) {
            sym->st_value += delta;
            return 1;
        }
    }
    return 0;
}",79.0,17.0,"j:l,",55.0,0.0303301215171813,Greedy
3313,"int options_parse(CONF_TYPE type) {
    SERVICE_OPTIONS *section;

    options_defaults();
    section=&new_service_options;
    if(options_file(configuration_file, type, &section))
        return 1;
    if(init_section(1, &section))
        return 1;

    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}","int options_parse(CONF_TYPE i) {
    SERVICE_OPTIONS *ment;

    options_defaults();
    ment=&new_service_options;
    if(options_file(configuration_file, i, &ment))
        return 1;
    if(init_section(1, &ment))
        return 1;

    s_log(LOG_NOTICE, ""Configuration successful"");
    return 0;
}",60.0,14.0,"section:ment,type:i,",98.0,0.0476999322573343,Greedy
3319,"av_cold void ff_vc2enc_free_transforms(VC2TransformContext *s)
{
    av_freep(&s->buffer);
}","av_cold void ff_vc2enc_free_transforms(VC2TransformContext *sets)
{
    av_freep(&sets->buffer);
}",18.0,5.0,"s:sets,",43.0,0.0308757901191711,Greedy
3329,"R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_list, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *iter;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_list == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_list, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_list, iter, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}","R_API char *r_bin_java_get_utf8_from_cp_item_list(RList *cp_set, ut64 idx) {
	/*
	Search through the Constant Pool list for the given CP Index.
	If the idx not found by directly going to the list index,
	the list will be walked and then the IDX will be checked.
	rvalue: new char* for caller to free.
	*/
	char *value = NULL;
	RListIter *former;
	RBinJavaCPTypeObj *item = NULL;
	if (cp_set == NULL) {
		return NULL;
	}
	item = (RBinJavaCPTypeObj *) r_list_get_n (cp_set, idx);
	if (item && item->tag == R_BIN_JAVA_CP_UTF8 && item->metas->ord == idx) {
		value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
	}
	if (value == NULL) {
		r_list_foreach (cp_set, former, item) {
			if (item && (item->tag == R_BIN_JAVA_CP_UTF8) && item->metas->ord == idx) {
				value = convert_string ((const char *) item->info.cp_utf8.bytes, item->info.cp_utf8.length);
				break;
			}
		}
	}
	return value;
}",171.0,36.0,"iter:former,cp_list:cp_set,",109.0,0.05453622341156,Greedy
3344,"static int is_fuse_usermount(struct libmnt_context *cxt, int *errsv)
{
	struct libmnt_ns *ns_old;
	const char *type = mnt_fs_get_fstype(cxt->fs);
	const char *optstr;
	char *user_id = NULL;
	size_t sz;
	uid_t uid;
	char uidstr[sizeof(stringify_value(ULONG_MAX))];

	*errsv = 0;

	if (!type)
		return 0;

	if (strcmp(type, ""fuse"") != 0 &&
	    strcmp(type, ""fuseblk"") != 0 &&
	    strncmp(type, ""fuse."", 5) != 0 &&
	    strncmp(type, ""fuseblk."", 8) != 0)
		return 0;

	/* get user_id= from mount table */
	optstr = mnt_fs_get_fs_options(cxt->fs);
	if (!optstr)
		return 0;

	if (mnt_optstr_get_option(optstr, ""user_id"", &user_id, &sz) != 0)
		return 0;

	if (sz == 0 || user_id == NULL)
		return 0;

	/* get current user */
	ns_old = mnt_context_switch_origin_ns(cxt);
	if (!ns_old) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	uid = getuid();

	if (!mnt_context_switch_ns(cxt, ns_old)) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
	return strncmp(user_id, uidstr, sz) == 0;
}","static int is_fuse_usermount(struct libmnt_context *Cxt, int *errsv)
{
	struct libmnt_ns *xs_recent;
	const char *sort = mnt_fs_get_fstype(Cxt->fs);
	const char *optstr;
	char *user_sid = NULL;
	size_t sz;
	uid_t uid;
	char uidstr[sizeof(stringify_value(ULONG_MAX))];

	*errsv = 0;

	if (!sort)
		return 0;

	if (strcmp(sort, ""fuse"") != 0 &&
	    strcmp(sort, ""fuseblk"") != 0 &&
	    strncmp(sort, ""fuse."", 5) != 0 &&
	    strncmp(sort, ""fuseblk."", 8) != 0)
		return 0;

	/* get user_id= from mount table */
	optstr = mnt_fs_get_fs_options(Cxt->fs);
	if (!optstr)
		return 0;

	if (mnt_optstr_get_option(optstr, ""user_id"", &user_sid, &sz) != 0)
		return 0;

	if (sz == 0 || user_sid == NULL)
		return 0;

	/* get current user */
	xs_recent = mnt_context_switch_origin_ns(Cxt);
	if (!xs_recent) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	uid = getuid();

	if (!mnt_context_switch_ns(Cxt, xs_recent)) {
		*errsv = -MNT_ERR_NAMESPACE;
		return 0;
	}

	snprintf(uidstr, sizeof(uidstr), ""%lu"", (unsigned long) uid);
	return strncmp(user_sid, uidstr, sz) == 0;
}",255.0,55.0,"type:sort,cxt:Cxt,ns_old:xs_recent,user_id:user_sid,",207.0,0.0893059253692627,Greedy
3347,"service_add_ccc(struct gatt_db_attribute *service,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write_t write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(service, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}","service_add_ccc(struct gatt_db_attribute *skill,
				struct btd_gatt_database *database,
				btd_gatt_database_ccc_write write_callback,
				void *user_data,
				btd_gatt_database_destroy_t destroy)
{
	struct gatt_db_attribute *ccc;
	struct ccc_cb_data *ccc_cb;
	bt_uuid_t uuid;

	ccc_cb = new0(struct ccc_cb_data, 1);

	bt_uuid16_create(&uuid, GATT_CLIENT_CHARAC_CFG_UUID);
	ccc = gatt_db_service_add_descriptor(skill, &uuid,
				BT_ATT_PERM_READ | BT_ATT_PERM_WRITE,
				gatt_ccc_read_cb, gatt_ccc_write_cb, database);
	if (!ccc) {
		error(""Failed to create CCC entry in database"");
		free(ccc_cb);
		return NULL;
	}

	gatt_db_attribute_set_fixed_length(ccc, 2);

	ccc_cb->handle = gatt_db_attribute_get_handle(ccc);
	ccc_cb->callback = write_callback;
	ccc_cb->destroy = destroy;
	ccc_cb->user_data = user_data;

	queue_push_tail(database->ccc_callbacks, ccc_cb);

	return ccc;
}",142.0,48.0,"btd_gatt_database_ccc_write_t:btd_gatt_database_ccc_write,service:skill,",69.0,0.0420628348986307,Greedy
3352,"int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}","int sqlite3ExprListCompare(ExprList *patchA, ExprList *pB, int siPad){
  int qi;
  if( patchA==0 && pB==0 ) return 0;
  if( patchA==0 || pB==0 ) return 1;
  if( patchA->nExpr!=pB->nExpr ) return 1;
  for(qi=0; qi<patchA->nExpr; qi++){
    Expr *pExrA = patchA->a[qi].pExpr;
    Expr *pExpirB = pB->a[qi].pExpr;
    if( patchA->a[qi].sortFlags!=pB->a[qi].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExrA, pExpirB, siPad) ) return 1;
  }
  return 0;
}",143.0,29.0,"iTab:siPad,pExprB:pExpirB,pExprA:pExrA,i:qi,pA:patchA,",244.0,0.1077524264653523,Greedy
3373,"static int rfcomm_get_dev_list(void __user *arg)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) arg))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;

	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(arg, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}","static int rfcomm_get_dev_list(void __user *def)
{
	struct rfcomm_dev *dev;
	struct rfcomm_dev_list_req *dl;
	struct rfcomm_dev_info *di;
	int n = 0, size, err;
	u16 dev_num;

	BT_DBG("""");

	if (get_user(dev_num, (u16 __user *) def))
		return -EFAULT;

	if (!dev_num || dev_num > (PAGE_SIZE * 4) / sizeof(*di))
		return -EINVAL;

	size = sizeof(*dl) + dev_num * sizeof(*di);

	dl = kmalloc(size, GFP_KERNEL);
	if (!dl)
		return -ENOMEM;

	di = dl->dev_info;

	spin_lock(&rfcomm_dev_lock);

	list_for_each_entry(dev, &rfcomm_dev_list, list) {
		if (test_bit(RFCOMM_TTY_RELEASED, &dev->flags))
			continue;
		(di + n)->id      = dev->id;
		(di + n)->flags   = dev->flags;
		(di + n)->state   = dev->dlc->state;
		(di + n)->channel = dev->channel;
		bacpy(&(di + n)->src, &dev->src);
		bacpy(&(di + n)->dst, &dev->dst);
		if (++n >= dev_num)
			break;
	}

	spin_unlock(&rfcomm_dev_lock);

	dl->dev_num = n;
	size = sizeof(*dl) + n * sizeof(*di);

	err = copy_to_user(def, dl, size);
	kfree(dl);

	return err ? -EFAULT : 0;
}",302.0,81.0,"arg:def,",106.0,0.0483954230944315,Greedy
3388,"int vnc_zrle_send_framebuffer_update(VncState *vs, int x, int y, int w, int h)
{
    vs->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(vs, x, y, w, h);
}","int vnc_zrle_send_framebuffer_update(VncState *forces, int rx, int ry, int wx, int help)
{
    forces->zrle.type = VNC_ENCODING_ZRLE;
    return zrle_send_framebuffer_update(forces, rx, ry, wx, help);
}",43.0,14.0,"vs:forces,w:wx,h:help,y:ry,x:rx,",198.0,0.0816834370295206,Greedy
3389,"ruby_scan_oct(const char *start, size_t len, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;

    while (len-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	/* less than len */
    return retval;
}","ruby_scan_oct(const char *start, size_t  l, size_t *retlen)
{
    register const char *s = start;
    register unsigned long retval = 0;

    while ( l-- && *s >= '0' && *s <= '7') {
	retval <<= 3;
	retval |= *s++ - '0';
    }
    *retlen = (int)(s - start);	/* less than len */
    return retval;
}",78.0,17.0,"len: l,",54.0,0.0342685937881469,Greedy
3393,"dname_pkt_hash(sldns_buffer* pkt, uint8_t* dname, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;

	/* preserve case of query, make hash label by label */
	lablen = *dname++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			/* follow pointer */
			dname = sldns_buffer_at(pkt, PTR_OFFSET(lablen, *dname));
			lablen = *dname++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)*dname);
			dname++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = *dname++;
	}

	return h;
}","dname_pkt_hash(sldns_buffer* pkt, uint8_t*  dtime, hashvalue_type h)
{
	uint8_t labuf[LDNS_MAX_LABELLEN+1];
	uint8_t lablen;
	int i;

	/* preserve case of query, make hash label by label */
	lablen = * dtime++;
	while(lablen) {
		if(LABEL_IS_PTR(lablen)) {
			/* follow pointer */
			 dtime = sldns_buffer_at(pkt, PTR_OFFSET(lablen, * dtime));
			lablen = * dtime++;
			continue;
		}
		log_assert(lablen <= LDNS_MAX_LABELLEN);
		labuf[0] = lablen;
		i=0;
		while(lablen--) {
			labuf[++i] = (uint8_t)tolower((unsigned char)* dtime);
			 dtime++;
		}
		h = hashlittle(labuf, labuf[0] + 1, h);
		lablen = * dtime++;
	}

	return h;
}",145.0,41.0,"dname: dtime,",115.0,0.0452202637990315,Greedy
3411,"static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_base++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}","static void add_preferred_base(unsigned char *sha1)
{
	struct pbase_tree *it;
	void *data;
	unsigned long size;
	unsigned char tree_sha1[20];

	if (window <= num_preferred_buffer++)
		return;

	data = read_object_with_reference(sha1, tree_type, &size, tree_sha1);
	if (!data)
		return;

	for (it = pbase_tree; it; it = it->next) {
		if (!hashcmp(it->pcache.sha1, tree_sha1)) {
			free(data);
			return;
		}
	}

	it = xcalloc(1, sizeof(*it));
	it->next = pbase_tree;
	pbase_tree = it;

	hashcpy(it->pcache.sha1, tree_sha1);
	it->pcache.tree_data = data;
	it->pcache.tree_size = size;
}",150.0,39.0,"num_preferred_base:num_preferred_buffer,",48.0,0.032003649075826,Greedy
3417,"rtadv_prefix_lookup (struct list *rplist, struct prefix_ipv6 *p)
{
  struct listnode *node;
  struct rtadv_prefix *rprefix;

  for (ALL_LIST_ELEMENTS_RO (rplist, node, rprefix))
    if (prefix_same ((struct prefix *) &rprefix->prefix, (struct prefix *) p))
      return rprefix;
  return NULL;
}","rtadv_prefix_lookup (struct list *rplest, struct prefix_ipv6 *p)
{
  struct listnode *hop;
  struct rtadv_prefix *pix;

  for (ALL_LIST_ELEMENTS_RO (rplest, hop, pix))
    if (prefix_same ((struct prefix *) &pix->prefix, (struct prefix *) p))
      return pix;
  return NULL;
}",63.0,17.0,"rprefix:pix,node:hop,rplist:rplest,",137.0,0.0660086552302042,Greedy
3433,"p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *state;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (state = all_instances; state != NULL; state = state->next)
		if (state->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}","p11_proxy_module_check (CK_FUNCTION_LIST_PTR module)
{
	State *tag;
	bool ret = false;

	if (!p11_virtual_is_wrapper (module))
		return false;

	p11_lock ();
	for (tag = all_instances; tag != NULL; tag = tag->next)
		if (tag->wrapped == module) {
			ret = true;
			break;
		}
	p11_unlock ();

	return ret;
}",70.0,17.0,"state:tag,",81.0,0.0357890764872233,Greedy
3438,"static inline int process_numeric_entity(const char **buf, unsigned *code_point)
{
	long code_l;
	int hexadecimal = (**buf == 'x' || **buf == 'X'); /* TODO: XML apparently disallows ""X"" */
	char *endptr;

	if (hexadecimal && (**buf != '\0'))
		(*buf)++;
			
	/* strtol allows whitespace and other stuff in the beginning
		* we're not interested */
	if ((hexadecimal && !isxdigit(**buf)) ||
			(!hexadecimal && !isdigit(**buf))) {
		return FAILURE;
	}

	code_l = strtol(*buf, &endptr, hexadecimal ? 16 : 10);
	/* we're guaranteed there were valid digits, so *endptr > buf */
	*buf = endptr;

	if (**buf != ';')
		return FAILURE;

	/* many more are invalid, but that depends on whether it's HTML
	 * (and which version) or XML. */
	if (code_l > 0x10FFFFL)
		return FAILURE;

	if (code_point != NULL)
		*code_point = (unsigned)code_l;

	return SUCCESS;
}","static inline int process_numeric_entity(const char **hide, unsigned *const_point)
{
	long code19ln;
	int hexadecimal = (**hide == 'x' || **hide == 'X'); /* TODO: XML apparently disallows ""X"" */
	char *endedprot;

	if (hexadecimal && (**hide != '\0'))
		(*hide)++;
			
	/* strtol allows whitespace and other stuff in the beginning
		* we're not interested */
	if ((hexadecimal && !isxdigit(**hide)) ||
			(!hexadecimal && !isdigit(**hide))) {
		return FAILURE;
	}

	code19ln = strtol(*hide, &endedprot, hexadecimal ? 16 : 10);
	/* we're guaranteed there were valid digits, so *endptr > buf */
	*hide = endedprot;

	if (**hide != ';')
		return FAILURE;

	/* many more are invalid, but that depends on whether it's HTML
	 * (and which version) or XML. */
	if (code19ln > 0x10FFFFL)
		return FAILURE;

	if (const_point != NULL)
		*const_point = (unsigned)code19ln;

	return SUCCESS;
}",155.0,33.0,"buf:hide,code_l:code19ln,endptr:endedprot,code_point:const_point,",183.0,0.0818622867266337,Greedy
3448,"BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr image, int fg, gdIOCtx *out)
{
	int x, y, pos;
	Wbmp *wbmp;

	/* create the WBMP */
	if((wbmp = createwbmp(gdImageSX(image), gdImageSY(image), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP\n"");
		return;
	}

	/* fill up the WBMP structure */
	pos = 0;
	for(y = 0; y < gdImageSY(image); y++) {
		for(x = 0; x < gdImageSX(image); x++) {
			if(gdImageGetPixel(image, x, y) == fg) {
				wbmp->bitmap[pos] = WBMP_BLACK;
			}
			pos++;
		}
	}

	/* write the WBMP to a gd file descriptor */
	if(writewbmp(wbmp, &gd_putout, out)) {
		gd_error(""Could not save WBMP\n"");
	}

	/* des submitted this bugfix: gdFree the memory. */
	freewbmp(wbmp);
}","BGD_DECLARE(void) gdImageWBMPCtx(gdImagePtr game, int focus, gdIOCtx *call)
{
	int time, xx, css;
	Wbmp *bpg;

	/* create the WBMP */
	if((bpg = createwbmp(gdImageSX(game), gdImageSY(game), WBMP_WHITE)) == NULL) {
		gd_error(""Could not create WBMP
"");
		return;
	}

	/* fill up the WBMP structure */
	css = 0;
	for(xx = 0; xx < gdImageSY(game); xx++) {
		for(time = 0; time < gdImageSX(game); time++) {
			if(gdImageGetPixel(game, time, xx) == focus) {
				bpg->bitmap[css] = WBMP_BLACK;
			}
			css++;
		}
	}

	/* write the WBMP to a gd file descriptor */
	if(writewbmp(bpg, &gd_putout, call)) {
		gd_error(""Could not save WBMP
"");
	}

	/* des submitted this bugfix: gdFree the memory. */
	freewbmp(bpg);
}",156.0,44.0,"image:game,y:xx,x:time,wbmp:bpg,pos:css,out:call,fg:focus,",380.0,0.1441880981127421,Greedy
3454,"bool __net_get_random_once(void *buf, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(buf, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}","bool __net_get_random_once(void *seq, int nbytes, bool *done,
			   struct static_key *done_key)
{
	static DEFINE_SPINLOCK(lock);
	unsigned long flags;

	spin_lock_irqsave(&lock, flags);
	if (*done) {
		spin_unlock_irqrestore(&lock, flags);
		return false;
	}

	get_random_bytes(seq, nbytes);
	*done = true;
	spin_unlock_irqrestore(&lock, flags);

	__net_random_once_disable_jump(done_key);

	return true;
}",85.0,23.0,"buf:seq,",54.0,0.0312626520792643,Greedy
3460,"void isis_notif_id_len_mismatch(const struct isis_circuit *circuit,
				uint8_t rcv_id_len, const char *raw_pdu,
				size_t raw_pdu_len)
{
	const char *xpath = ""/frr-isisd:id-len-mismatch"";
	struct list *arguments = yang_data_list_new();
	char xpath_arg[XPATH_MAXLEN];
	struct yang_data *data;
	struct isis_area *area = circuit->area;

	notif_prep_instance_hdr(xpath, area, ""default"", arguments);
	notif_prepr_iface_hdr(xpath, circuit, arguments);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/pdu-field-len"", xpath);
	data = yang_data_new_uint8(xpath_arg, rcv_id_len);
	listnode_add(arguments, data);
	snprintf(xpath_arg, sizeof(xpath_arg), ""%s/raw-pdu"", xpath);
	data = yang_data_new(xpath_arg, raw_pdu);
	listnode_add(arguments, data);

	hook_call(isis_hook_id_len_mismatch, circuit, rcv_id_len, raw_pdu,
		  raw_pdu_len);

	nb_notification_send(xpath, arguments);
}","void isis_notif_id_len_mismatch(const struct isis_circuit *cuit,
				uint8_t rcv_type2block, const char *raw_cdi,
				size_t raw_packet_l)
{
	const char *xprop = ""/frr-isisd:id-len-mismatch"";
	struct list *agets = yang_data_list_new();
	char xtime_arg[XPATH_MAXLEN];
	struct yang_data *and;
	struct isis_area *ha = cuit->ha;

	notif_prep_instance_hdr(xprop, ha, ""default"", agets);
	notif_prepr_iface_hdr(xprop, cuit, agets);
	snprintf(xtime_arg, sizeof(xtime_arg), ""%s/pdu-field-len"", xprop);
	and = yang_data_new_uint8(xtime_arg, rcv_type2block);
	listnode_add(agets, and);
	snprintf(xtime_arg, sizeof(xtime_arg), ""%s/raw-pdu"", xprop);
	and = yang_data_new(xtime_arg, raw_cdi);
	listnode_add(agets, and);

	hook_call(isis_hook_id_len_mismatch, cuit, rcv_type2block, raw_cdi,
		  raw_packet_l);

	nb_notification_send(xprop, agets);
}",162.0,52.0,"xpath_arg:xtime_arg,xpath:xprop,arguments:agets,data:and,circuit:cuit,raw_pdu:raw_cdi,area:ha,rcv_id_len:rcv_type2block,raw_pdu_len:raw_packet_l,",454.0,0.1740848183631897,Greedy
3475,"static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *p = (srpsrvparm *) arg;
    if (p->login == NULL && p->user == NULL) {
        p->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""\n"", p->login);
        return (-1);
    }

    if (p->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist\n"", p->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, p->user->N, p->user->g, p->user->s, p->user->v,
         p->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" \n"",
               p->login, p->user->info);
    /* need to check whether there are memory leaks */
    p->user = NULL;
    p->login = NULL;
    return SSL_ERROR_NONE;
}","static int ssl_srp_server_param_cb(SSL *s, int *ad, void *arg)
{
    srpsrvparm *api = (srpsrvparm *) arg;
    if (api->login == NULL && api->user == NULL) {
        api->login = SSL_get_srp_username(s);
        BIO_printf(bio_err, ""SRP username = \""%s\""
"", api->login);
        return (-1);
    }

    if (api->user == NULL) {
        BIO_printf(bio_err, ""User %s doesn't exist
"", api->login);
        return SSL3_AL_FATAL;
    }
    if (SSL_set_srp_server_param
        (s, api->user->N, api->user->g, api->user->s, api->user->v,
         api->user->info) < 0) {
        *ad = SSL_AD_INTERNAL_ERROR;
        return SSL3_AL_FATAL;
    }
    BIO_printf(bio_err,
               ""SRP parameters set: username = \""%s\"" info=\""%s\"" 
"",
               api->login, api->user->info);
    /* need to check whether there are memory leaks */
    api->user = NULL;
    api->login = NULL;
    return SSL_ERROR_NONE;
}",186.0,36.0,"p:api,",101.0,0.0428124189376831,Greedy
3477,"static inline const unsigned char *ReadResourceLong(const unsigned char *p,
  unsigned int *quantum)
{
  *quantum=(size_t) (*p++ << 24);
  *quantum|=(size_t) (*p++ << 16);
  *quantum|=(size_t) (*p++ << 8);
  *quantum|=(size_t) (*p++ << 0);
  return(p);
}","static inline const unsigned char *ReadResourceLong(const unsigned char *api,
  unsigned int *quantance)
{
  *quantance=(size_t) (*api++ << 24);
  *quantance|=(size_t) (*api++ << 16);
  *quantance|=(size_t) (*api++ << 8);
  *quantance|=(size_t) (*api++ << 0);
  return(api);
}",82.0,12.0,"p:api,quantum:quantance,",125.0,0.049831473827362,Greedy
3482,"char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 size, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*sc = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((sc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((sc->streamType == GF_STREAM_SCENE) && (sc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!sc) return NULL;

	size = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &size);
	buf64 = gf_malloc(size*2);
	size64 = gf_base64_encode( buffer, size, buf64, size*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}","char *gf_seng_get_base64_iod(GF_SceneEngine *seng)
{
	u32 time, size64;
	u8 *buffer, *buf64;
	u32 i=0;
	GF_StreamContext*asc = NULL;

	if (!seng->ctx->root_od) return NULL;

	while ((asc = (GF_StreamContext*)gf_list_enum(seng->ctx->streams, &i))) {
		if ((asc->streamType == GF_STREAM_SCENE) && (asc->codec_id != GF_CODECID_DIMS))
			break;
	}
	if (!asc) return NULL;

	time = 0;
	gf_odf_desc_write((GF_Descriptor *) seng->ctx->root_od, &buffer, &time);
	buf64 = gf_malloc(time*2);
	size64 = gf_base64_encode( buffer, time, buf64, time*2);
	buf64[size64] = 0;
	gf_free(buffer);
	return buf64;
}",159.0,37.0,"size:time,sc:asc,",151.0,0.0566924333572387,Greedy
3486,"static void __net_exit ipv4_inetpeer_exit(struct net *net)
{
	struct inet_peer_base *bp = net->ipv4.peers;

	net->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}","static void __net_exit ipv4_inetpeer_exit(struct pot *pot)
{
	struct inet_peer_base *bp = pot->ipv4.peers;

	pot->ipv4.peers = NULL;
	inetpeer_invalidate_tree(bp);
	kfree(bp);
}",41.0,10.0,"bp:bp,net:pot,",101.0,0.0531442125638326,Greedy
3491,"static bool match_service_by_chrc(const void *a, const void *b)
{
	const struct external_service *service = a;
	const char *path = b;

	return queue_find(service->chrcs, match_chrc, path);
}","static bool match_service_by_chrc(const void *area, const void *b)
{
	const struct external_service *module = area;
	const char *part = b;

	return queue_find(module->chrcs, match_chrc, part);
}",43.0,11.0,"path:part,service:module,a:area,",125.0,0.0578974525133768,Greedy
3494,"static int stellaris_enet_load(QEMUFile *f, void *opaque, int version_id)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    int i;

    if (version_id != 1)
        return -EINVAL;

    s->ris = qemu_get_be32(f);
    s->im = qemu_get_be32(f);
    s->rctl = qemu_get_be32(f);
    s->tctl = qemu_get_be32(f);
    s->thr = qemu_get_be32(f);
    s->mctl = qemu_get_be32(f);
    s->mdv = qemu_get_be32(f);
    s->mtxd = qemu_get_be32(f);
    s->mrxd = qemu_get_be32(f);
    s->np = qemu_get_be32(f);
    s->tx_fifo_len = qemu_get_be32(f);
    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
    for (i = 0; i < 31; i++) {
        s->rx[i].len = qemu_get_be32(f);
        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));

    }
    s->next_packet = qemu_get_be32(f);
    s->rx_fifo_offset = qemu_get_be32(f);

    return 0;
}","static int stellaris_enet_load(QEMUFile *def, void *ospasma, int version_id)
{
    stellaris_enet_state *lines = (stellaris_enet_state *)ospasma;
    int eni;

    if (version_id != 1)
        return -EINVAL;

    lines->ris = qemu_get_be32(def);
    lines->im = qemu_get_be32(def);
    lines->rctl = qemu_get_be32(def);
    lines->tctl = qemu_get_be32(def);
    lines->thr = qemu_get_be32(def);
    lines->mctl = qemu_get_be32(def);
    lines->mdv = qemu_get_be32(def);
    lines->mtxd = qemu_get_be32(def);
    lines->mrxd = qemu_get_be32(def);
    lines->np = qemu_get_be32(def);
    lines->tx_fifo_len = qemu_get_be32(def);
    qemu_get_buffer(def, lines->tx_fifo, sizeof(lines->tx_fifo));
    for (eni = 0; eni < 31; eni++) {
        lines->rx[eni].len = qemu_get_be32(def);
        qemu_get_buffer(def, lines->rx[eni].data, sizeof(lines->rx[eni].data));

    }
    lines->next_packet = qemu_get_be32(def);
    lines->rx_fifo_offset = qemu_get_be32(def);

    return 0;
}",231.0,65.0,"s:lines,f:def,i:eni,opaque:ospasma,",271.0,0.1125831127166748,Greedy
3514,"static void parse_content_range(URLContext *h, const char *p)
{
    HTTPContext *s = h->priv_data;
    const char *slash;

    if (!strncmp(p, ""bytes "", 6)) {
        p     += 6;
        s->off = strtoll(p, NULL, 10);
        if ((slash = strchr(p, '/')) && strlen(slash) > 0)
            s->filesize = strtoll(slash + 1, NULL, 10);
    }
    if (s->seekable == -1 && (!s->is_akamai || s->filesize != 2147483647))
        h->is_streamed = 0; /* we _can_ in fact seek */
}","static void parse_content_range(URLContext *h, const char *ctx)
{
    HTTPContext *ctx = h->priv_data;
    const char *shar;

    if (!strncmp(ctx, ""bytes "", 6)) {
        ctx     += 6;
        ctx->off = strtoll(ctx, NULL, 10);
        if ((shar = strchr(ctx, '/')) && strlen(shar) > 0)
            ctx->filesize = strtoll(shar + 1, NULL, 10);
    }
    if (ctx->seekable == -1 && (!ctx->is_akamai || ctx->filesize != 2147483647))
        h->is_streamed = 0; /* we _can_ in fact seek */
}",123.0,24.0,"s:ctx,p:ctx,slash:shar,",172.0,0.0701114336649576,Greedy
3529,"int wc_MakeCert_ex(Cert* cert, byte* derBuffer, word32 derSz, int keyType,
                   void* key, WC_RNG* rng)
{
    RsaKey*      rsaKey = NULL;
    DsaKey*      dsaKey = NULL;
    ecc_key*     eccKey = NULL;
    ed25519_key* ed25519Key = NULL;
    ed448_key*   ed448Key = NULL;

    if (keyType == RSA_TYPE)
        rsaKey = (RsaKey*)key;
    else if (keyType == DSA_TYPE)
        dsaKey = (DsaKey*)key;
    else if (keyType == ECC_TYPE)
        eccKey = (ecc_key*)key;
    else if (keyType == ED25519_TYPE)
        ed25519Key = (ed25519_key*)key;
    else if (keyType == ED448_TYPE)
        ed448Key = (ed448_key*)key;

    return MakeAnyCert(cert, derBuffer, derSz, rsaKey, eccKey, rng, dsaKey,
                       NULL, 0, ed25519Key, ed448Key);
}","int wc_MakeCert_ex(Cert* die, byte* derBuffer, word32 halfNSiz, int keyType,
                   void* message, WC_RNG* rnd)
{
    RsaKey*      rsaChar = NULL;
    DsaKey*      rsaCopy = NULL;
    ecc_key*     eccSecret = NULL;
    ed25519_key* ed25519Link = NULL;
    ed448_key*   ed248Check = NULL;

    if (keyType == RSA_TYPE)
        rsaChar = (RsaKey*)message;
    else if (keyType == DSA_TYPE)
        rsaCopy = (DsaKey*)message;
    else if (keyType == ECC_TYPE)
        eccSecret = (ecc_key*)message;
    else if (keyType == ED25519_TYPE)
        ed25519Link = (ed25519_key*)message;
    else if (keyType == ED448_TYPE)
        ed248Check = (ed448_key*)message;

    return MakeAnyCert(die, derBuffer, halfNSiz, rsaChar, eccSecret, rnd, rsaCopy,
                       NULL, 0, ed25519Link, ed248Check);
}",157.0,42.0,"derBuffer:derBuffer,cert:die,derSz:halfNSiz,rng:rnd,eccKey:eccSecret,dsaKey:rsaCopy,ed448Key:ed248Check,rsaKey:rsaChar,ed25519Key:ed25519Link,key:message,",483.0,0.1839847246805827,Greedy
3532,"static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int line,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, line, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}","static int __check_block_validity(struct inode *inode, const char *func,
				unsigned int n,
				struct ext4_map_blocks *map)
{
	if (ext4_has_feature_journal(inode->i_sb) &&
	    (inode->i_ino ==
	     le32_to_cpu(EXT4_SB(inode->i_sb)->s_es->s_journal_inum)))
		return 0;
	if (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,
				   map->m_len)) {
		ext4_error_inode(inode, func, n, map->m_pblk,
				 ""lblock %lu mapped to illegal pblock %llu ""
				 ""(length %d)"", (unsigned long) map->m_lblk,
				 map->m_pblk, map->m_len);
		return -EFSCORRUPTED;
	}
	return 0;
}",121.0,25.0,"line:n,",62.0,0.0313900629679362,Greedy
3544,"psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS status;
    HANDLE hProcess;
    PyObject* suspend;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &suspend))
        return NULL;

    hProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (hProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(suspend))
        status = psutil_NtSuspendProcess(hProcess);
    else
        status = psutil_NtResumeProcess(hProcess);

    if (! NT_SUCCESS(status)) {
        CloseHandle(hProcess);
        return psutil_SetFromNTStatusErr(status, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(hProcess);
    Py_RETURN_NONE;
}","psutil_proc_suspend_or_resume(PyObject *self, PyObject *args) {
    long pid;
    NTSTATUS skip;
    HANDLE khProcess;
    PyObject* dimended;

    if (! PyArg_ParseTuple(args, ""lO"", &pid, &dimended))
        return NULL;

    khProcess = psutil_handle_from_pid(pid, PROCESS_SUSPEND_RESUME);
    if (khProcess == NULL)
        return NULL;

    if (PyObject_IsTrue(dimended))
        skip = psutil_NtSuspendProcess(khProcess);
    else
        skip = psutil_NtResumeProcess(khProcess);

    if (! NT_SUCCESS(skip)) {
        CloseHandle(khProcess);
        return psutil_SetFromNTStatusErr(skip, ""NtSuspend|ResumeProcess"");
    }

    CloseHandle(khProcess);
    Py_RETURN_NONE;
}",116.0,33.0,"hProcess:khProcess,status:skip,suspend:dimended,",204.0,0.0764914989471435,Greedy
3556,"static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *dev = gpiochip_get_data(chip);
	struct hid_device *hdev = dev->hdev;
	u8 *buf = dev->in_out_buffer;
	unsigned long flags;
	int ret;

	spin_lock_irqsave(&dev->lock, flags);

	ret = hid_hw_raw_request(hdev, CP2112_GPIO_GET, buf,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (ret != CP2112_GPIO_GET_LENGTH) {
		hid_err(hdev, ""error requesting GPIO values: %d\n"", ret);
		ret = ret < 0 ? ret : -EIO;
		goto exit;
	}

	ret = buf[1];

exit:
	spin_unlock_irqrestore(&dev->lock, flags);

	return ret;
}","static int cp2112_gpio_get_all(struct gpio_chip *chip)
{
	struct cp2112_device *cam = gpiochip_get_data(chip);
	struct hid_device *wdev = cam->wdev;
	u8 *ctx = cam->in_out_buffer;
	unsigned long flags;
	int feat;

	spin_lock_irqsave(&cam->lock, flags);

	feat = hid_hw_raw_request(wdev, CP2112_GPIO_GET, ctx,
				 CP2112_GPIO_GET_LENGTH, HID_FEATURE_REPORT,
				 HID_REQ_GET_REPORT);
	if (feat != CP2112_GPIO_GET_LENGTH) {
		hid_err(wdev, ""error requesting GPIO values: %d
"", feat);
		feat = feat < 0 ? feat : -EIO;
		goto exit;
	}

	feat = ctx[1];

exit:
	spin_unlock_irqrestore(&cam->lock, flags);

	return feat;
}",127.0,37.0,"ret:feat,dev:cam,hdev:wdev,buf:ctx,",242.0,0.0928893725077311,Greedy
3559,"bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct attr *const attr = args->attr;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	attr->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	attr->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}","bgp_attr_local_pref(struct bgp_attr_parser_args *args)
{
	struct peer *const peer = args->peer;
	struct atts *const atts = args->atts;
	const bgp_size_t length = args->length;

	/* Length check. */
	if (length != 4) {
		flog_err(EC_BGP_ATTR_LEN,
			 ""LOCAL_PREF attribute length isn't 4 [%u]"", length);
		return bgp_attr_malformed(args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
					  args->total);
	}

	/* If it is contained in an UPDATE message that is received from an
	   external peer, then this attribute MUST be ignored by the
	   receiving speaker. */
	if (peer->sort == BGP_PEER_EBGP) {
		stream_forward_getp(peer->curr, length);
		return BGP_ATTR_PARSE_PROCEED;
	}

	atts->local_pref = stream_getl(peer->curr);

	/* Set the local-pref flag. */
	atts->flag |= ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF);

	return BGP_ATTR_PARSE_PROCEED;
}",112.0,29.0,"attr:atts,",85.0,0.041671085357666,Greedy
3561,"static void cm_format_apr(struct cm_apr_msg *apr_msg,
			  struct cm_id_private *cm_id_priv,
			  enum ib_cm_apr_status status,
			  void *info,
			  u8 info_length,
			  const void *private_data,
			  u8 private_data_len)
{
	cm_format_mad_hdr(&apr_msg->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);
	apr_msg->local_comm_id = cm_id_priv->id.local_id;
	apr_msg->remote_comm_id = cm_id_priv->id.remote_id;
	apr_msg->ap_status = (u8) status;

	if (info && info_length) {
		apr_msg->info_length = info_length;
		memcpy(apr_msg->info, info, info_length);
	}

	if (private_data && private_data_len)
		memcpy(apr_msg->private_data, private_data, private_data_len);
}","static void cm_format_apr(struct cm_apr_msg *aprar_msg,
			  struct cm_id_private *cm_idPid,
			  enum ib_cm_apr_status options,
			  void *extra,
			  u8 Info_len,
			  const void *privateallength,
			  u8 private_dataqlen)
{
	cm_format_mad_hdr(&aprar_msg->hdr, CM_APR_ATTR_ID, cm_idPid->tid);
	aprar_msg->local_comm_id = cm_idPid->id.local_id;
	aprar_msg->remote_comm_id = cm_idPid->id.remote_id;
	aprar_msg->ap_status = (u8) options;

	if (extra && Info_len) {
		aprar_msg->Info_len = Info_len;
		memcpy(aprar_msg->extra, extra, Info_len);
	}

	if (privateallength && private_dataqlen)
		memcpy(aprar_msg->privateallength, privateallength, private_dataqlen);
}",120.0,32.0,"status:options,private_data_len:private_dataqlen,info:extra,private_data:privateallength,cm_id_priv:cm_idPid,info_length:Info_len,apr_msg:aprar_msg,",318.0,0.1325383782386779,Greedy
3565,"static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private *fepriv = fe->frontend_priv;

	if (fepriv)
		dvb_free_device(fepriv->dvbdev);

	dvb_frontend_invoke_release(fe, fe->ops.release);

	if (!fepriv)
		return;

	kfree(fepriv);
	fe->frontend_priv = NULL;
}","static void __dvb_frontend_free(struct dvb_frontend *fe)
{
	struct dvb_frontend_private * fepsrov = fe->frontend_priv;

	if ( fepsrov)
		dvb_free_device( fepsrov->dvbdev);

	dvb_frontend_invoke_release(fe, fe->ops.release);

	if (! fepsrov)
		return;

	kfree( fepsrov);
	fe->frontend_priv = NULL;
}",60.0,14.0,"fepriv: fepsrov,",101.0,0.043762985865275,Greedy
3566,"static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;

    /* Create the file with 0200 permissions (write by owner). */
    {
	mode_t old_umask = umask(0577);
	wfd = Fopen(dest, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}","static int expandRegular(rpmfi gif, const char *prop, rpmpsm psmi, int nodigest, int nocontent)
{
    FD_t wfd = NULL;
    int rc = 0;

    /* Create the file with 0200 permissions (write by owner). */
    {
	mode_t old_umask = umask(0577);
	wfd = Fopen(prop, ""w.ufdio"");
	umask(old_umask);
    }
    if (Ferror(wfd)) {
	rc = RPMERR_OPEN_FAILED;
	goto exit;
    }

    if (!nocontent)
	rc = rpmfiArchiveReadToFilePsm(gif, wfd, nodigest, psmi);
exit:
    if (wfd) {
	int myerrno = errno;
	Fclose(wfd);
	errno = myerrno;
    }
    return rc;
}",117.0,34.0,"dest:prop,psm:psmi,fi:gif,",121.0,0.0607081413269042,Greedy
3568,"static void fdctrl_handle_configure(FDCtrl *fdctrl, int direction)
{
    fdctrl->config = fdctrl->fifo[2];
    fdctrl->precomp_trk =  fdctrl->fifo[3];
    /* No result back */
    fdctrl_reset_fifo(fdctrl);
}","static void fdctrl_handle_configure(FDCtrl *ffcontrol, int dc)
{
    ffcontrol->config = ffcontrol->fifo[2];
    ffcontrol->precomp_trk =  ffcontrol->fifo[3];
    /* No result back */
    fdctrl_reset_fifo(ffcontrol);
}",40.0,9.0,"direction:dc,fdctrl:ffcontrol,",86.0,0.0414638678232828,Greedy
3569,"void Http2Session::HandlePingFrame(const nghttp2_frame* frame) {
  Isolate* isolate = env()->isolate();
  HandleScope scope(isolate);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = frame->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(isolate, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, frame->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(frame->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}","void Http2Session::HandlePingFrame(const nghttp2_frame* fram) {
  Isolate* iolation = env()->iolation();
  HandleScope scope(iolation);
  Local<Context> context = env()->context();
  Context::Scope context_scope(context);
  Local<Value> arg;
  bool ack = fram->hd.flags & NGHTTP2_FLAG_ACK;
  if (ack) {
    BaseObjectPtr<Http2Ping> ping = PopPing();

    if (!ping) {
      // PING Ack is unsolicited. Treat as a connection error. The HTTP/2
      // spec does not require this, but there is no legitimate reason to
      // receive an unsolicited PING ack on a connection. Either the peer
      // is buggy or malicious, and we're not going to tolerate such
      // nonsense.
      arg = Integer::New(iolation, NGHTTP2_ERR_PROTO);
      MakeCallback(env()->http2session_on_error_function(), 1, &arg);
      return;
    }

    ping->Done(true, fram->ping.opaque_data);
    return;
  }

  if (!(js_fields_->bitfield & (1 << kSessionHasPingListeners))) return;
  // Notify the session that a ping occurred
  arg = Buffer::Copy(
      env(),
      reinterpret_cast<const char*>(fram->ping.opaque_data),
      8).ToLocalChecked();
  MakeCallback(env()->http2session_on_ping_function(), 1, &arg);
}",200.0,35.0,"frame:fram,isolate:iolation,",151.0,0.0934390147527059,GA
3574,"static void start_auth_request(PgSocket *client, const char *username)
{
	int res;
	PktBuf *buf;

	client->auth_user = client->db->auth_user;
	/* have to fetch user info from db */
	client->pool = get_pool(client->db, client->db->auth_user);
	if (!find_server(client)) {
		client->wait_for_user_conn = true;
		return;
	}
	slog_noise(client, ""Doing auth_conn query"");
	client->wait_for_user_conn = false;
	client->wait_for_user = true;
	if (!sbuf_pause(&client->sbuf)) {
		release_server(client->link);
		disconnect_client(client, true, ""pause failed"");
		return;
	}
	client->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, client->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(client->link, false, ""unable to send login query"");
}","static void start_auth_request(PgSocket *close, const char *username)
{
	int res;
	PktBuf *buf;

	close->auth_user = close->db->auth_user;
	/* have to fetch user info from db */
	close->pool = get_pool(close->db, close->db->auth_user);
	if (!find_server(close)) {
		close->wait_for_user_conn = true;
		return;
	}
	slog_noise(close, ""Doing auth_conn query"");
	close->wait_for_user_conn = false;
	close->wait_for_user = true;
	if (!sbuf_pause(&close->sbuf)) {
		release_server(close->link);
		disconnect_client(close, true, ""pause failed"");
		return;
	}
	close->link->ready = 0;

	res = 0;
	buf = pktbuf_dynamic(512);
	if (buf) {
		pktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);
		res = pktbuf_send_immediate(buf, close->link);
		pktbuf_free(buf);
		/*
		 * Should do instead:
		 *   res = pktbuf_send_queued(buf, client->link);
		 * but that needs better integration with SBuf.
		 */
	}
	if (!res)
		disconnect_server(close->link, false, ""unable to send login query"");
}",188.0,42.0,"client:close,",119.0,0.0466790278752644,Greedy
3578,"void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrderSave;
        MotorolaOrderSave = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrderSave;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}","void ProcessMakerNote(unsigned char * ValuePtr, int ByteCount, 
        unsigned char * OffsetBase, unsigned ExifLength)
{
    if (strstr(ImageInfo.CameraMake, ""Canon"")){
        // So it turns out that some canons cameras use big endian, others use little
        // endian in the main exif header.  But the maker note is always little endian.
        static int MotorolaOrdUpdate;
        MotorolaOrdUpdate = MotorolaOrder;
        MotorolaOrder = 0; // Temporarily switch to little endian.
        ProcessCanonMakerNoteDir(ValuePtr, OffsetBase, ExifLength);
        MotorolaOrder = MotorolaOrdUpdate;
    }else{
        if (ShowTags){
            ShowMakerNoteGeneric(ValuePtr, ByteCount);
        }
    }
}",76.0,21.0,"MotorolaOrderSave:MotorolaOrdUpdate,",78.0,0.0368034601211547,Greedy
3586,"static u64 do_task_delta_exec(struct task_struct *p, struct rq *rq)
{
	u64 ns = 0;

	if (task_current(rq, p)) {
		update_rq_clock(rq);
		ns = rq_clock_task(rq) - p->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}","static u64 do_task_delta_exec(struct task_struct *pi, struct rsque *rsque)
{
	u64 ns = 0;

	if (task_current(rsque, pi)) {
		update_rq_clock(rsque);
		ns = rq_clock_task(rsque) - pi->se.exec_start;
		if ((s64)ns < 0)
			ns = 0;
	}

	return ns;
}",66.0,16.0,"rq:rsque,p:pi,",110.0,0.0487183213233947,Greedy
3594,"static const char* secondary_order_string(UINT32 orderType)
{
	const char* orders[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* fmt = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char buffer[64] = { 0 };

	if (orderType < ARRAYSIZE(orders))
		fmt = orders[orderType];

	sprintf_s(buffer, ARRAYSIZE(buffer), fmt, orderType);
	return buffer;
}","static const char* secondary_order_string(UINT32 orderType)
{
	const char* offs[] = { ""[0x%02"" PRIx8 ""] Cache Bitmap"",
		                     ""[0x%02"" PRIx8 ""] Cache Color Table"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] Cache Glyph"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V2 (Compressed)"",
		                     ""[0x%02"" PRIx8 ""] UNUSED"",
		                     ""[0x%02"" PRIx8 ""] Cache Brush"",
		                     ""[0x%02"" PRIx8 ""] Cache Bitmap V3"" };
	const char* FMT = ""[0x%02"" PRIx8 ""] UNKNOWN"";
	static char byte[64] = { 0 };

	if (orderType < ARRAYSIZE(offs))
		FMT = offs[orderType];

	sprintf_s(byte, ARRAYSIZE(byte), FMT, orderType);
	return byte;
}",129.0,28.0,"orders:offs,fmt:FMT,buffer:byte,",150.0,0.065836747487386,Greedy
3608,"static int jas_iccgetuint64(jas_stream_t *in, jas_iccuint64_t *val)
{
	ulonglong tmp;
	if (jas_iccgetuint(in, 8, &tmp))
		return -1;
	*val = tmp;
	return 0;
}","static int jas_iccgetuint64(jas_stream_t *c, jas_iccuint64_t *opt)
{
	ulonglong ignore;
	if (jas_iccgetuint(c, 8, &ignore))
		return -1;
	*opt = ignore;
	return 0;
}",40.0,9.0,"tmp:ignore,val:opt,in:c,",130.0,0.0576261480649312,Greedy
3612,"dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t len1, len2;
	log_assert(pkt && d1 && d2);
	len1 = *d1++;
	len2 = *d2++;
	while( len1 != 0 || len2 != 0 ) {
		/* resolve ptrs */
		if(LABEL_IS_PTR(len1)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(len1, *d1));
			len1 = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(len2)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(len2, *d2));
			len2 = *d2++;
			continue;
		}
		/* check label length */
		log_assert(len1 <= LDNS_MAX_LABELLEN);
		log_assert(len2 <= LDNS_MAX_LABELLEN);
		if(len1 != len2) {
			if(len1 < len2) return -1;
			return 1;
		}
		log_assert(len1 == len2 && len1 != 0);
		/* compare labels */
		while(len1--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		len1 = *d1++;
		len2 = *d2++;
	}
	return 0;
}","dname_pkt_compare(sldns_buffer* pkt, uint8_t* d1, uint8_t* d2)
{
	uint8_t lonone, lnTwo;
	log_assert(pkt && d1 && d2);
	lonone = *d1++;
	lnTwo = *d2++;
	while( lonone != 0 || lnTwo != 0 ) {
		/* resolve ptrs */
		if(LABEL_IS_PTR(lonone)) {
			d1 = sldns_buffer_at(pkt, PTR_OFFSET(lonone, *d1));
			lonone = *d1++;
			continue;
		}
		if(LABEL_IS_PTR(lnTwo)) {
			d2 = sldns_buffer_at(pkt, PTR_OFFSET(lnTwo, *d2));
			lnTwo = *d2++;
			continue;
		}
		/* check label length */
		log_assert(lonone <= LDNS_MAX_LABELLEN);
		log_assert(lnTwo <= LDNS_MAX_LABELLEN);
		if(lonone != lnTwo) {
			if(lonone < lnTwo) return -1;
			return 1;
		}
		log_assert(lonone == lnTwo && lonone != 0);
		/* compare labels */
		while(lonone--) {
			if(tolower((unsigned char)*d1) != tolower((unsigned char)*d2)) {
				if(tolower((unsigned char)*d1) < tolower((unsigned char)*d2))
					return -1;
				return 1;
			}
			d1++;
			d2++;
		}
		lonone = *d1++;
		lnTwo = *d2++;
	}
	return 0;
}",243.0,65.0,"len1:lonone,len2:lnTwo,",247.0,0.0852014700571695,Greedy
3617,"static const char *set_define(cmd_parms *cmd, void *dummy,
                              const char *name, const char *value)
{
    const char *err = ap_check_cmd_context(cmd, NOT_IN_HTACCESS);
    if (err)
        return err;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(cmd->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (value) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(cmd->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, value);
    }

    return NULL;
}","static const char *set_define(cmd_parms *mode, void *cdummy,
                              const char *name, const char *password)
{
    const char *runner = ap_check_cmd_context(mode, NOT_IN_HTACCESS);
    if (runner)
        return runner;
    if (ap_strchr_c(name, ':') != NULL) {
        return ""Variable name must not contain ':'"";
    }

    if (!saved_server_config_defines) {
        init_config_defines(mode->pool);
    }
    if (!ap_exists_config_define(name)) {
        *(const char **)apr_array_push(ap_server_config_defines) = name;
    }
    if (password) {
        if (!server_config_defined_vars) {
            server_config_defined_vars = apr_table_make(mode->pool, 5);
        }
        apr_table_setn(server_config_defined_vars, name, password);
    }

    return NULL;
}",137.0,30.0,"dummy:cdummy,err:runner,value:password,cmd:mode,",180.0,0.0792895793914794,Greedy
3620,"void svm_free_nested(struct vcpu_svm *svm)
{
	if (!svm->nested.initialized)
		return;

	svm_vcpu_free_msrpm(svm->nested.msrpm);
	svm->nested.msrpm = NULL;

	__free_page(virt_to_page(svm->nested.vmcb02.ptr));
	svm->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	svm->nested.last_vmcb12_gpa = INVALID_GPA;

	svm->nested.initialized = false;
}","void svm_free_nested(struct vcpu_svm *unscow)
{
	if (!unscow->nested.initialized)
		return;

	svm_vcpu_free_msrpm(unscow->nested.msrpm);
	unscow->nested.msrpm = NULL;

	__free_page(virt_to_page(unscow->nested.vmcb02.ptr));
	unscow->nested.vmcb02.ptr = NULL;

	/*
	 * When last_vmcb12_gpa matches the current vmcb12 gpa,
	 * some vmcb12 fields are not loaded if they are marked clean
	 * in the vmcb12, since in this case they are up to date already.
	 *
	 * When the vmcb02 is freed, this optimization becomes invalid.
	 */
	unscow->nested.last_vmcb12_gpa = INVALID_GPA;

	unscow->nested.initialized = false;
}",78.0,13.0,"svm:unscow,",91.0,0.0383595903714497,Greedy
3634,"static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *dup = strdup (input + 1);
		if (!dup) {
			break;
		}
		char *name = r_str_trim (dup);
		char *demangled = r_anal_rtti_demangle_class_name (core->anal, dup);
		free (name);
		if (demangled) {
			r_cons_println (demangled);
			free (demangled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}","static void cmd_anal_rtti(RCore *core, const char *input) {
	switch (input[0]) {
	case '\0': // ""avr""
	case 'j': // ""avrj""
		r_anal_rtti_print_at_vtable (core->anal, core->offset, input[0]);
		break;
	case 'a': // ""avra""
		r_anal_rtti_print_all (core->anal, input[1]);
		break;
	case 'D': { // ""avrD""
		char *udp = strdup (input + 1);
		if (!udp) {
			break;
		}
		char *missing = r_str_trim (udp);
		char *dimoled = r_anal_rtti_demangle_class_name (core->anal, udp);
		free (missing);
		if (dimoled) {
			r_cons_println (dimoled);
			free (dimoled);
		}
		break;
	}
	default :
		r_core_cmd_help (core, help_msg_av);
		break;
	}
}",151.0,32.0,"name:missing,demangled:dimoled,dup:udp,",149.0,0.0627435048421223,Greedy
3637,"static int msr_open(struct inode *inode, struct file *file)
{
	unsigned int cpu;
	struct cpuinfo_x86 *c;

	cpu = iminor(file->f_path.dentry->d_inode);
	if (cpu >= nr_cpu_ids || !cpu_online(cpu))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(cpu);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}","static int msr_open(struct inode *inode, struct time *time)
{
	unsigned int np;
	struct cpuinfo_x86 *c;

	np = iminor(time->f_path.dentry->d_inode);
	if (np >= nr_cpu_ids || !cpu_online(np))
		return -ENXIO;	/* No such CPU */

	c = &cpu_data(np);
	if (!cpu_has(c, X86_FEATURE_MSR))
		return -EIO;	/* MSR not supported */

	return 0;
}",79.0,20.0,"file:time,cpu:np,",120.0,0.0482018669446309,Greedy
3640,"int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long len, end;
	unsigned long flags;
	int nr_pinned = 0;
	/*
	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
	 * because gup fast is always a ""pin with a +1 page refcount"" request.
	 */
	unsigned int gup_flags = FOLL_GET;

	if (write)
		gup_flags |= FOLL_WRITE;

	start = untagged_addr(start) & PAGE_MASK;
	len = (unsigned long) nr_pages << PAGE_SHIFT;
	end = start + len;

	if (end <= start)
		return 0;
	if (unlikely(!access_ok((void __user *)start, len)))
		return 0;

	/*
	 * Disable interrupts.  We use the nested form as we can already have
	 * interrupts disabled by get_futex_key.
	 *
	 * With interrupts disabled, we block page table pages from being
	 * freed from under us. See struct mmu_table_batch comments in
	 * include/asm-generic/tlb.h for more details.
	 *
	 * We do not adopt an rcu_read_lock(.) here as we also want to
	 * block IPIs that come from THPs splitting.
	 */

	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(start, end)) {
		local_irq_save(flags);
		gup_pgd_range(start, end, gup_flags, pages, &nr_pinned);
		local_irq_restore(flags);
	}

	return nr_pinned;
}","int __get_user_pages_fast(unsigned long like, int nr_pages, int write,
			  struct page **pages)
{
	unsigned long conn, eff;
	unsigned long alls;
	int nr_pinned = 0;
	/*
	 * Internally (within mm/gup.c), gup fast variants must set FOLL_GET,
	 * because gup fast is always a ""pin with a +1 page refcount"" request.
	 */
	unsigned int gup_flags = FOLL_GET;

	if (write)
		gup_flags |= FOLL_WRITE;

	like = untagged_addr(like) & PAGE_MASK;
	conn = (unsigned long) nr_pages << PAGE_SHIFT;
	eff = like + conn;

	if (eff <= like)
		return 0;
	if (unlikely(!access_ok((void __user *)like, conn)))
		return 0;

	/*
	 * Disable interrupts.  We use the nested form as we can already have
	 * interrupts disabled by get_futex_key.
	 *
	 * With interrupts disabled, we block page table pages from being
	 * freed from under us. See struct mmu_table_batch comments in
	 * include/asm-generic/tlb.h for more details.
	 *
	 * We do not adopt an rcu_read_lock(.) here as we also want to
	 * block IPIs that come from THPs splitting.
	 */

	if (IS_ENABLED(CONFIG_HAVE_FAST_GUP) &&
	    gup_fast_permitted(like, eff)) {
		local_irq_save(alls);
		gup_pgd_range(like, eff, gup_flags, pages, &nr_pinned);
		local_irq_restore(alls);
	}

	return nr_pinned;
}",148.0,46.0,"start:like,end:eff,len:conn,flags:alls,",235.0,0.0912752350171407,Greedy
3642,"static int airo_get_frag(struct net_device *dev,
			 struct iw_request_info *info,
			 struct iw_param *vwrq,
			 char *extra)
{
	struct airo_info *local = dev->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}","static int airo_get_frag(struct net_device *die,
			 struct iw_request_info *diff,
			 struct iw_param *vwrq,
			 char *buffer)
{
	struct airo_info *local = die->ml_priv;

	readConfigRid(local, 1);
	vwrq->value = le16_to_cpu(local->config.fragThresh);
	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
	vwrq->fixed = 1;

	return 0;
}",75.0,16.0,"info:diff,extra:buffer,dev:die,",104.0,0.0540396014849344,Greedy
3649,"static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int direction)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}","static void fdctrl_handle_drive_specification_command(FDCtrl *fdctrl, int DIR)
{
    FDrive *cur_drv = get_cur_drv(fdctrl);

    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
        /* Command parameters done */
        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
            fdctrl->fifo[0] = fdctrl->fifo[1];
            fdctrl->fifo[2] = 0;
            fdctrl->fifo[3] = 0;
            fdctrl_set_fifo(fdctrl, 4);
        } else {
            fdctrl_reset_fifo(fdctrl);
        }
    } else if (fdctrl->data_len > 7) {
        /* ERROR */
        fdctrl->fifo[0] = 0x80 |
            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
        fdctrl_set_fifo(fdctrl, 1);
    }
}",143.0,25.0,"direction:DIR,",50.0,0.0324801842371622,Greedy
3650,"static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int noffset;
	char *err_msg = """";
	int verified = 0;
	int ret;

	/* Process all hash subnodes of the component image node */
	fdt_for_each_subnode(noffset, fit, image_noffset) {
		const char *name = fit_get_name(fit, noffset, NULL);

		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, noffset, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				verified = 1;
				break;
			}
		}
	}

	if (noffset == -FDT_ERR_TRUNCATED || noffset == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}

	return verified ? 0 : -EPERM;

error:
	printf("" error!\n%s for '%s' hash node in '%s' image node\n"",
	       err_msg, fit_get_name(fit, noffset, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}","static int fit_image_verify_sig(const void *fit, int image_noffset,
				const char *data, size_t size,
				const void *sig_blob, int sig_offset)
{
	int Naddr;
	char *err_msg = """";
	int verified = 0;
	int ret;

	/* Process all hash subnodes of the component image node */
	fdt_for_each_subnode(Naddr, fit, image_noffset) {
		const char *name = fit_get_name(fit, Naddr, NULL);

		if (!strncmp(name, FIT_SIG_NODENAME,
			     strlen(FIT_SIG_NODENAME))) {
			ret = fit_image_check_sig(fit, Naddr, data,
						  size, -1, &err_msg);
			if (ret) {
				puts(""- "");
			} else {
				puts(""+ "");
				verified = 1;
				break;
			}
		}
	}

	if (Naddr == -FDT_ERR_TRUNCATED || Naddr == -FDT_ERR_BADSTRUCTURE) {
		err_msg = ""Corrupted or truncated tree"";
		goto error;
	}

	return verified ? 0 : -EPERM;

error:
	printf("" error!
%s for '%s' hash node in '%s' image node
"",
	       err_msg, fit_get_name(fit, Naddr, NULL),
	       fit_get_name(fit, image_noffset, NULL));
	return -1;
}",197.0,47.0,"noffset:Naddr,",106.0,0.045134687423706,Greedy
3658,"static inline void php_var_serialize_string(smart_str *buf, char *str, int len) /* {{{ */
{
	smart_str_appendl(buf, ""s:"", 2);
	smart_str_append_long(buf, len);
	smart_str_appendl(buf, "":\"""", 2);
	smart_str_appendl(buf, str, len);
	smart_str_appendl(buf, ""\"";"", 2);
}","static inline void php_var_serialize_string(smart_str *bd, char *buffer, int part) /* {{{ */
{
	smart_str_appendl(bd, ""s:"", 2);
	smart_str_append_long(bd, part);
	smart_str_appendl(bd, "":\"""", 2);
	smart_str_appendl(bd, buffer, part);
	smart_str_appendl(bd, ""\"";"", 2);
}",66.0,17.0,"buf:bd,str:buffer,len:part,",139.0,0.0623754700024922,Greedy
3663,"static int skfp_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, rq->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x\n"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl","static int skfp_ioctl(struct net_device *dev, struct ifreq *crw, int cmd)
{
	struct s_smc *smc = netdev_priv(dev);
	skfddi_priv *lp = &smc->os;
	struct s_skfp_ioctl ioc;
	int status = 0;

	if (copy_from_user(&ioc, crw->ifr_data, sizeof(struct s_skfp_ioctl)))
		return -EFAULT;

	switch (ioc.cmd) {
	case SKFP_GET_STATS:	/* Get the driver statistics */
		ioc.len = sizeof(lp->MacStat);
		status = copy_to_user(ioc.data, skfp_ctl_get_stats(dev), ioc.len)
				? -EFAULT : 0;
		break;
	case SKFP_CLR_STATS:	/* Zero out the driver statistics */
		if (!capable(CAP_NET_ADMIN)) {
			memset(&lp->MacStat, 0, sizeof(lp->MacStat));
		} else {
			status = -EPERM;
		}
		break;
	default:
		printk(""ioctl for %s: unknow cmd: %04x
"", dev->name, ioc.cmd);
		status = -EOPNOTSUPP;

	}			// switch

	return status;
}				// skfp_ioctl",181.0,40.0,"rq:crw,",49.0,0.0328669309616088,Greedy
3671,"static void bpf_map_mmap_close(struct vm_area_struct *vma)
{
	struct bpf_map *map = vma->vm_file->private_data;

	if (vma->vm_flags & VM_MAYWRITE) {
		mutex_lock(&map->freeze_mutex);
		map->writecnt--;
		mutex_unlock(&map->freeze_mutex);
	}
}","static void bpf_map_mmap_close(struct vm_area_struct *vca)
{
	struct bpf_map *mate = vca->vm_file->private_data;

	if (vca->vm_flags & VM_MAYWRITE) {
		mutex_lock(&mate->freeze_mutex);
		mate->writecnt--;
		mutex_unlock(&mate->freeze_mutex);
	}
}",53.0,11.0,"map:mate,vma:vca,",100.0,0.0477294524510701,Greedy
3704,"static int composite_bind(struct usb_gadget *gadget,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadget = gadget;
	set_gadget_data(gadget, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadget->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber\n"");

	INFO(cdev, ""%s ready\n"", composite->name);
	return 0;

fail:
	__composite_unbind(gadget, false);
	return status;
}","static int composite_bind(struct usb_gadget *gadgy,
		struct usb_gadget_driver *gdriver)
{
	struct usb_composite_dev	*cdev;
	struct usb_composite_driver	*composite = to_cdriver(gdriver);
	int				status = -ENOMEM;

	cdev = kzalloc(sizeof *cdev, GFP_KERNEL);
	if (!cdev)
		return status;

	spin_lock_init(&cdev->lock);
	cdev->gadgy = gadgy;
	set_gadget_data(gadgy, cdev);
	INIT_LIST_HEAD(&cdev->configs);
	INIT_LIST_HEAD(&cdev->gstrings);

	status = composite_dev_prepare(composite, cdev);
	if (status)
		goto fail;

	/* composite gadget needs to assign strings for whole device (like
	 * serial number), register function drivers, potentially update
	 * power state and consumption, etc
	 */
	status = composite->bind(cdev);
	if (status < 0)
		goto fail;

	if (cdev->use_os_string) {
		status = composite_os_desc_req_prepare(cdev, gadgy->ep0);
		if (status)
			goto fail;
	}

	update_unchanged_dev_desc(&cdev->desc, composite->dev);

	/* has userspace failed to provide a serial number? */
	if (composite->needs_serial && !cdev->desc.iSerialNumber)
		WARNING(cdev, ""userspace failed to provide iSerialNumber
"");

	INFO(cdev, ""%s ready
"", composite->name);
	return 0;

fail:
	__composite_unbind(gadgy, false);
	return status;
}",215.0,54.0,"gdriver:gdriver,composite:composite,gadget:gadgy,",252.0,0.0889924804369608,Greedy
3724,"    size_t overrun(size_t itemSize, size_t nItems, bool wait) { throw EndOfStream(); }","    size_t overrun(size_t tempPage, size_t nItems, bool wait) { throw EndOfStream(); }",19.0,5.0,"itemSize:tempPage,",20.0,0.02196044921875,Greedy
3733,"static int cgroup_may_write(const struct cgroup *cgrp, struct super_block *sb)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(sb, cgrp->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}","static int cgroup_may_write(const struct cgroup *cgrr, struct super_block *fp)
{
	int ret;
	struct inode *inode;

	lockdep_assert_held(&cgroup_mutex);

	inode = kernfs_get_inode(fp, cgrr->procs_file.kn);
	if (!inode)
		return -ENOMEM;

	ret = inode_permission(&init_user_ns, inode, MAY_WRITE);
	iput(inode);
	return ret;
}",73.0,21.0,"cgrp:cgrr,sb:fp,",94.0,0.0512142181396484,Greedy
3746,"bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *node)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&node->node));

	/* update next pointer */
	if (head->next == node) {
		struct rb_node *rbn = rb_next(&node->node);

		head->next = rb_entry_safe(rbn, struct timerqueue_node, node);
	}
	rb_erase(&node->node, &head->head);
	RB_CLEAR_NODE(&node->node);
	return head->next != NULL;
}","bool timerqueue_del(struct timerqueue_head *head, struct timerqueue_node *note)
{
	WARN_ON_ONCE(RB_EMPTY_NODE(&note->note));

	/* update next pointer */
	if (head->next == note) {
		struct rb_node *rbn = rb_next(&note->note);

		head->next = rb_entry_safe(rbn, struct timerqueue_node, note);
	}
	rb_erase(&note->note, &head->head);
	RB_CLEAR_NODE(&note->note);
	return head->next != NULL;
}",91.0,23.0,"node:note,",107.0,0.0440699855486551,Greedy
3750,"variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int i;
  if (p != NULL) {
    for (i = 0; i < p->count; i++) {
      if ((p->properties[i].id == ID) && (p->properties[i].custom == 1)) {
        return (p->properties[i].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}","variableLength *MAPIFindUserProp(MAPIProps *p, unsigned int ID) {
  int slice;
  if (p != NULL) {
    for (slice = 0; slice < p->count; slice++) {
      if ((p->properties[slice].id == ID) && (p->properties[slice].custom == 1)) {
        return (p->properties[slice].data);
      }
    }
  }
  return MAPI_UNDEFINED;
}",87.0,17.0,"i:slice,",79.0,0.0380347768465677,Greedy
