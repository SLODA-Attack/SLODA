Index,Original Code,Adversarial Code,True Label,Adv Label,Query Times,Time Cost
5,"static uint32_t drc_set_unusable(sPAPRDRConnector *drc)
{
    drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t qpci_config_readw(signal_pending *drc)
{
    drc->allocation_state = bits;
    if (drc->awaiting_release) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_allocation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}",,,255,
13,"void cpu_x86_init_mmu(CPUX86State *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}","void acquire_privilege(synchronize_from_tb *env)
{
    a20_enabled = 1;
    a20_mask = 0xffffffff;
    last_pg_state = -1;
    cpu_x86_update_cr0(env);
}",,,192,
14,"int qemu_cpu_self(void *env)
{
    return 1;
}","int error_report(void *evt_recv)
{
    return 1;
}",,,192,
18,"START_TEST(qint_get_int_test)
{
    QInt *qi;
    const int value = 123456;
    qi = qint_from_int(value);
    fail_unless(qint_get_int(qi) == value);
    QDECREF(qi);
}","ivshmem_has_feature(QEMUIOVector)
{
    QInt *inv_table;
    const int value = 123456;
    inv_table = qint_from_int(value);
    fail_unless(qint_get_int(inv_table) == value);
    QDECREF(inv_table);
}",,,302,
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,
    struct usb_redir_bulk_packet_header *bulk_packet,
    uint8_t *data, int data_len)
{
    USBRedirDevice *dev = priv;
    uint8_t ep = bulk_packet->endpoint;
    int len = bulk_packet->length;
    AsyncURB *aurb;
    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,
            ep, len, id);
    aurb = async_find(dev, id);
    if (!aurb) {
        free(data);
        return;
    }
    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||
            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {
        ERROR(""return bulk packet mismatch, please report this!\n"");
        len = USB_RET_NAK;
    }
    if (aurb->packet) {
        len = usbredir_handle_status(dev, bulk_packet->status, len);
        if (len > 0) {
            usbredir_log_data(dev, ""bulk data in:"", data, data_len);
            if (data_len <= aurb->packet->len) {
                memcpy(aurb->packet->data, data, data_len);
            } else {
                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,
                      aurb->packet->len);
                len = USB_RET_STALL;
            }
        }
        aurb->packet->len = len;
        usb_packet_complete(&dev->dev, aurb->packet);
    }
    async_free(dev, aurb);
    free(data);
}","static void usbredir_bulk_packet(void *priv, uint32_t id,
    struct usb_redir_bulk_packet_header *DeviceInfo,
    uint8_t *data, int data_len)
{
    USBRedirDevice *dev = priv;
    uint8_t ep = DeviceInfo->endpoint;
    int len = DeviceInfo->length;
    AsyncURB *aurb;
    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", DeviceInfo->status,
            ep, len, id);
    aurb = async_find(dev, id);
    if (!aurb) {
        free(data);
        return;
    }
    if (aurb->DeviceInfo.endpoint != DeviceInfo->endpoint ||
            aurb->DeviceInfo.host_set != DeviceInfo->host_set) {
        ERROR(""return bulk packet mismatch, please report this!
"");
        len = USB_RET_NAK;
    }
    if (aurb->packet) {
        len = usbredir_handle_status(dev, DeviceInfo->status, len);
        if (len > 0) {
            usbredir_log_data(dev, ""bulk data in:"", data, data_len);
            if (data_len <= aurb->packet->len) {
                memcpy(aurb->packet->data, data, data_len);
            } else {
                ERROR(""bulk buffer too small (%d > %d)
"", data_len,
                      aurb->packet->len);
                len = USB_RET_STALL;
            }
        }
        aurb->packet->len = len;
        v9fs_link(&dev->dev, aurb->packet);
    }
    async_free(dev, aurb);
    free(data);
}",,,319,
26,"void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        flush_trace_file();
    }
    trace_idx = 0;
}","void st_flush_trace_buffer(void)
{
    if (trace_file_enabled) {
        flush_trace_file();
    }
    ILEN_LATER = 0;
}",,,192,
31,"static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf)
{
    uint32_t rgb = 0;
    if (bpp == 32) {
        rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24;
        rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16;
        rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) <<  8;
        rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) <<  0;
    }
    if (bpp == 16) {
        rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8;
        rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0;
    }
    return rgb;
}","static uint32_t g_assert_not_reached(int bpp, const uint8_t *IPMI_CC_INVALID_DATA_FIELD)
{
    uint32_t rgb = 0;
    if (bpp == 32) {
        rgb |= ((IPMI_CC_INVALID_DATA_FIELD[0] & ~1) | !((IPMI_CC_INVALID_DATA_FIELD[4] >> 3) & 1)) << 24;
        rgb |= ((IPMI_CC_INVALID_DATA_FIELD[1] & ~1) | !((IPMI_CC_INVALID_DATA_FIELD[4] >> 2) & 1)) << 16;
        rgb |= ((IPMI_CC_INVALID_DATA_FIELD[2] & ~1) | !((IPMI_CC_INVALID_DATA_FIELD[4] >> 1) & 1)) <<  8;
        rgb |= ((IPMI_CC_INVALID_DATA_FIELD[3] & ~1) | !((IPMI_CC_INVALID_DATA_FIELD[4] >> 0) & 1)) <<  0;
    }
    if (bpp == 16) {
        rgb |= ((IPMI_CC_INVALID_DATA_FIELD[0] & ~1) | !((IPMI_CC_INVALID_DATA_FIELD[2] >> 1) & 1)) << 8;
        rgb |= ((IPMI_CC_INVALID_DATA_FIELD[1] & ~1) | !((IPMI_CC_INVALID_DATA_FIELD[2] >> 0) & 1)) << 0;
    }
    return rgb;
}",,,192,
37,"int floatx80_eq(floatx80 a, floatx80 b, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( b ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( b )<<1 ) )
       ) {
        float_raise(float_flag_invalid, status);
        return 0;
    }
    return
           ( a.low == b.low )
        && (    ( a.high == b.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | b.high )<<1 ) == 0 ) )
           );
}","int xbzrle_mig_pages_overflow(floatx80 a, floatx80 gdb_stop_before_watchpoint, float_status *status)
{
    if (    (    ( extractFloatx80Exp( a ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( a )<<1 ) )
         || (    ( extractFloatx80Exp( gdb_stop_before_watchpoint ) == 0x7FFF )
              && (uint64_t) ( extractFloatx80Frac( gdb_stop_before_watchpoint )<<1 ) )
       ) {
        float_raise(float_flag_invalid, status);
        return 0;
    }
    return
           ( a.low == gdb_stop_before_watchpoint.low )
        && (    ( a.high == gdb_stop_before_watchpoint.high )
             || (    ( a.low == 0 )
                  && ( (uint16_t) ( ( a.high | gdb_stop_before_watchpoint.high )<<1 ) == 0 ) )
           );
}",,,192,
47,"void thread_pool_submit(ThreadPoolFunc *func, void *arg)
{
    thread_pool_submit_aio(func, arg, NULL, NULL);
}","void thread_pool_submit(ThreadPoolFunc *rsvd, void *arg)
{
    qint_get_int(rsvd, arg, NULL, NULL);
}",,,192,
48,"static void pl061_register_devices(void)
{
    sysbus_register_dev(""pl061"", sizeof(pl061_state),
                        pl061_init_arm);
    sysbus_register_dev(""pl061_luminary"", sizeof(pl061_state),
                        pl061_init_luminary);
}","static void pl061_register_devices(void)
{
    qpci_free_pc(""pl061"", sizeof(imemoffset),
                        k);
    qpci_free_pc(""pl061_luminary"", sizeof(imemoffset),
                        pl061_init_luminary);
}",,,255,
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)
{
    int compno;
    int x, y;
    int *image_line;
    int frame_index;
    const int numcomps  = image->numcomps;
    uint16_t *frame_ptr = (uint16_t *)frame->data[0];
    for (compno = 0; compno < numcomps; ++compno) {
        if (image->comps[compno].w > frame->linesize[0] / numcomps) {
            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");
            return 0;
        }
    }
    for (compno = 0; compno < numcomps; ++compno) {
        for (y = 0; y < avctx->height; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            frame_index = y * (frame->linesize[0] / 2) + compno;
            for (x = 0; x < avctx->width; ++x) {
                image_line[x] = frame_ptr[frame_index] >> 4;
                frame_index += numcomps;
            }
            for (; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - 1];
            }
        }
        for (; y < image->comps[compno].h; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            for (x = 0; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - image->comps[compno].w];
            }
        }
    }
    return 1;
}","static int scsi_disk_emulate_start_stop(AVCodecContext *host_set, const AVFrame *frame, opj_image_t *image)
{
    int compno;
    int x, y;
    int *image_line;
    int frame_index;
    const int numcomps  = image->numcomps;
    uint16_t *frame_ptr = (uint16_t *)frame->data[0];
    for (compno = 0; compno < numcomps; ++compno) {
        if (image->comps[compno].w > frame->linesize[0] / numcomps) {
            av_log(host_set, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image
"");
            return 0;
        }
    }
    for (compno = 0; compno < numcomps; ++compno) {
        for (y = 0; y < host_set->height; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            frame_index = y * (frame->linesize[0] / 2) + compno;
            for (x = 0; x < host_set->width; ++x) {
                image_line[x] = frame_ptr[frame_index] >> 4;
                frame_index += numcomps;
            }
            for (; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - 1];
            }
        }
        for (; y < image->comps[compno].h; ++y) {
            image_line = image->comps[compno].data + y * image->comps[compno].w;
            for (x = 0; x < image->comps[compno].w; ++x) {
                image_line[x] = image_line[x - image->comps[compno].w];
            }
        }
    }
    return 1;
}",,,252,
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}","void acpi_ram_update(const uint8_t *src, uint8_t *dst, long ILEN_LATER, const uint8_t *palette)
{
	long i;
	for(i=0; i<ILEN_LATER; i++)
	{
		dst[0]= palette[ src[i]*4+0 ];
		dst[1]= palette[ src[i]*4+1 ];
		dst[2]= palette[ src[i]*4+2 ];
		dst+= 3;
	}
}",,,192,
62,"static inline void codeblock(DiracContext *s, SubBand *b,
                             GetBitContext *gb, DiracArith *c,
                             int left, int right, int top, int bottom,
                             int blockcnt_one, int is_arith)
{
    int x, y, zero_block;
    int qoffset, qfactor;
    IDWTELEM *buf;
    if (!blockcnt_one) {
        if (is_arith)
            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);
        else
            zero_block = get_bits1(gb);
        if (zero_block)
            return;
    }
    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {
        if (is_arith)
            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);
        else
            b->quant += dirac_get_se_golomb(gb);
    }
    b->quant = FFMIN(b->quant, MAX_QUANT);
    qfactor = qscale_tab[b->quant];
    if (!s->num_refs)
        qoffset = qoffset_intra_tab[b->quant];
    else
        qoffset = qoffset_inter_tab[b->quant];
    buf = b->ibuf + top * b->stride;
    for (y = top; y < bottom; y++) {
        for (x = left; x < right; x++) {
            if (is_arith)
                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);
            else
                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);
        }
        buf += b->stride;
    }
}","static inline void codeblock(DiracContext *s, SubBand *b,
                             GetBitContext *gb, DiracArith *c,
                             int left, int right, int top, int bottom,
                             int blockcnt_one, int SO_EXPIRE)
{
    int x, y, zero_block;
    int qoffset, qfactor;
    addrlen *buf;
    if (!blockcnt_one) {
        if (SO_EXPIRE)
            zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK);
        else
            zero_block = get_bits1(gb);
        if (zero_block)
            return;
    }
    if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) {
        if (SO_EXPIRE)
            b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA);
        else
            b->quant += dirac_get_se_golomb(gb);
    }
    b->quant = FFMIN(b->quant, MAX_QUANT);
    qfactor = qscale_tab[b->quant];
    if (!s->num_refs)
        qoffset = qoffset_intra_tab[b->quant];
    else
        qoffset = qoffset_inter_tab[b->quant];
    buf = b->ibuf + top * b->stride;
    for (y = top; y < bottom; y++) {
        for (x = left; x < right; x++) {
            if (SO_EXPIRE)
                coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y);
            else
                buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset);
        }
        buf += b->stride;
    }
}",,,294,
64,"void do_POWER_maskg (void)
{
    uint32_t ret;
    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)T0 > (uint32_t)T1)
            ret = ~ret;
    }
    T0 = ret;
}","void css_do_tpi (void)
{
    uint32_t ret;
    if ((uint32_t)scratchbuf == (uint32_t)(T1 + 1)) {
        ret = -1;
    } else {
        ret = (((uint32_t)(-1)) >> ((uint32_t)scratchbuf)) ^
            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);
        if ((uint32_t)scratchbuf > (uint32_t)T1)
            ret = ~ret;
    }
    scratchbuf = ret;
}",,,192,
70,"static AVStream * init_stream(AVFormatContext *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = avformat_new_stream(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);
    return st;
}","static AVStream * init_stream(bytes_per_packet *s)
{
    BinDemuxContext *bin = s->priv_data;
    AVStream *st = blk_bs(s, NULL);
    if (!st)
        return NULL;
    st->codec->codec_tag   = 0;
    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;
    if (!bin->width) {
        st->codec->width  = (80<<3);
        st->codec->height = (25<<4);
    }
    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);
    bin->vdi_id = FFMAX(av_q2d(st->time_base) * bin->vdi_id, 1);
    return st;
}",,,256,
73,"static void device_initfn(Object *obj)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop;
    if (qdev_hotplug) {
        dev->hotplugged = 1;
        qdev_hot_added = true;
    }
    dev->instance_id_alias = -1;
    dev->state = DEV_STATE_CREATED;
    qdev_prop_set_defaults(dev, qdev_get_props(dev));
    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {
        qdev_property_add_legacy(dev, prop, NULL);
        qdev_property_add_static(dev, prop, NULL);
    }
    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);
}","static void device_initfn(Object *obj)
{
    mainChunkSize *dev = vmstate_register_ram_global(obj);
    Property *prop;
    if (qdev_hotplug) {
        dev->hotplugged = 1;
        qdev_hot_added = true;
    }
    dev->tb = -1;
    dev->state = DEV_STATE_CREATED;
    qdev_prop_set_defaults(dev, qdev_get_props(dev));
    for (prop = qdev_get_props(dev); prop && prop->name; prop++) {
        av_assert1(dev, prop, NULL);
        qdev_property_add_static(dev, prop, NULL);
    }
    object_property_add_str(OBJECT(dev), ""type"", qdev_get_type, NULL, NULL);
}",,,304,
75,"static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (b < 0);
    if (sb)
        b = -b;
    div64(plow, phigh, b);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}","static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t acpi_dev)
{
    int sa, sb;
    sa = ((int64_t)*phigh < 0);
    if (sa)
        neg128(plow, phigh);
    sb = (acpi_dev < 0);
    if (sb)
        acpi_dev = -acpi_dev;
    div64(plow, phigh, acpi_dev);
    if (sa ^ sb)
        *plow = - *plow;
    if (sa)
        *phigh = - *phigh;
}",,,256,
82,"static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    bool first = true;
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", first ? """" : "" "", cpu);
        first = false;
    }
    return g_string_free(s, FALSE);
}","static char *enumerate_cpus(unsigned long *cpus, int max_cpus)
{
    int cpu;
    bool QREG_DIV1 = true;
    GString *s = g_string_new(NULL);
    for (cpu = find_first_bit(cpus, max_cpus);
        cpu < max_cpus;
        cpu = find_next_bit(cpus, max_cpus, cpu + 1)) {
        g_string_append_printf(s, ""%s%d"", QREG_DIV1 ? """" : "" "", cpu);
        QREG_DIV1 = false;
    }
    return g_string_free(s, FALSE);
}",,,254,
92,"int bdrv_is_removable(BlockDriverState *bs)
{
    return bs->removable;
}","int mxf_read_track(deassert_states *bs)
{
    return bs->removable;
}",,,192,
95,"void do_divwuo (void)
{
    if (likely((uint32_t)T1 != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)T1;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}","void cpu_physical_memory_map (void)
{
    if (likely((uint32_t)SCOOP_ISR != 0)) {
        xer_ov = 0;
        T0 = (uint32_t)T0 / (uint32_t)SCOOP_ISR;
    } else {
        xer_so = 1;
        xer_ov = 1;
        T0 = 0;
    }
}",,,192,
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t len)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = len;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}","int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,
                                                 uint64_t iova, uint64_t RV34_MB_B_BACKWARD)
{
    struct vhost_iotlb_msg imsg;
    imsg.iova = iova;
    imsg.size = RV34_MB_B_BACKWARD;
    imsg.type = VHOST_IOTLB_INVALIDATE;
    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);
}",,,256,
101,"static uint32_t gic_dist_readw(void *opaque, target_phys_addr_t offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}","static uint32_t gic_dist_readw(void *opaque, ROCKER_PCI_MSIX_TABLE_OFFSET offset)
{
    uint32_t val;
    val = gic_dist_readb(opaque, offset);
    val |= gic_dist_readb(opaque, offset + 1) << 8;
    return val;
}",,,192,
109,"static int getopt(int argc, char *argv[], char *opts)
{
    static int sp = 1;
    int c;
    char *cp;
    if (sp == 1)
        if (optind >= argc ||
            argv[optind][0] != '-' || argv[optind][1] == '\0')
            return EOF;
        else if (!strcmp(argv[optind], ""--"")) {
            optind++;
            return EOF;
        }
    optopt = c = argv[optind][sp];
    if (c == ':' || (cp = strchr(opts, c)) == NULL) {
        fprintf(stderr, "": illegal option -- %c\n"", c);
        if (argv[optind][++sp] == '\0') {
            optind++;
            sp = 1;
        }
        return '?';
    }
    if (*++cp == ':') {
        if (argv[optind][sp+1] != '\0')
            optarg = &argv[optind++][sp+1];
        else if(++optind >= argc) {
            fprintf(stderr, "": option requires an argument -- %c\n"", c);
            sp = 1;
            return '?';
        } else
            optarg = argv[optind++];
        sp = 1;
    } else {
        if (argv[optind][++sp] == '\0') {
            sp = 1;
            optind++;
        }
        optarg = NULL;
    }
    return c;
}","static int assert_bit_clear(int argc, char *argv[], char *opts)
{
    static int sp = 1;
    int c;
    char *cp;
    if (sp == 1)
        if (optind >= argc ||
            argv[optind][0] != '-' || argv[optind][1] == '\0')
            return EOF;
        else if (!strcmp(argv[optind], ""--"")) {
            optind++;
            return EOF;
        }
    optopt = c = argv[optind][sp];
    if (c == ':' || (cp = strchr(opts, c)) == NULL) {
        fprintf(stderr, "": illegal option -- %c
"", c);
        if (argv[optind][++sp] == '\0') {
            optind++;
            sp = 1;
        }
        return '?';
    }
    if (*++cp == ':') {
        if (argv[optind][sp+1] != '\0')
            stats_vq_elem = &argv[optind++][sp+1];
        else if(++optind >= argc) {
            fprintf(stderr, "": option requires an argument -- %c
"", c);
            sp = 1;
            return '?';
        } else
            stats_vq_elem = argv[optind++];
        sp = 1;
    } else {
        if (argv[optind][++sp] == '\0') {
            sp = 1;
            optind++;
        }
        stats_vq_elem = NULL;
    }
    return c;
}",,,192,
111,"void qemu_cpu_kick(void *env)
{
    return;
}","void inject_error(void *nsvs_timestamps)
{
    return;
}",,,192,
112,"static void temp_allocate_frame(TCGContext *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->current_frame_offset;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->current_frame_offset += sizeof(tcg_target_long);
}","static void msix_notify(FT_PPC *s, int temp)
{
    TCGTemp *ts;
    ts = &s->temps[temp];
    s->smc91c111_writefn = (s->smc91c111_writefn + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1);
    if (s->smc91c111_writefn + sizeof(tcg_target_long) > s->frame_end)
        tcg_abort();
    ts->mem_offset = s->smc91c111_writefn;
    ts->mem_reg = s->frame_reg;
    ts->mem_allocated = 1;
    s->smc91c111_writefn += sizeof(tcg_target_long);
}",,,298,
117,"static void gen_set_CF_bit31(TCGv var)
{
    TCGv tmp = new_tmp();
    tcg_gen_shri_i32(tmp, var, 31);
    gen_set_CF(tmp);
    dead_tmp(tmp);
}","static void gen_set_CF_bit31(TCGv var)
{
    TCGv QDICT_HASH_SIZE = new_tmp();
    tcg_gen_shri_i32(QDICT_HASH_SIZE, var, 31);
    gen_set_CF(QDICT_HASH_SIZE);
    dead_tmp(QDICT_HASH_SIZE);
}",,,192,
120,"static void sd_1d97_int(int *p, int i0, int i1)
{
    int i;
    if (i1 <= i0 + 1) {
        if (i0 == 1)
            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;
        else
            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;
        return;
    }
    extend97_int(p, i0, i1);
    i0++; i1++;
    for (i = i0/2 - 2; i < i1/2 + 1; i++)
        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = i0/2 - 1; i < i1/2 + 1; i++)
        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
    for (i = i0/2 - 1; i < i1/2; i++)
        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = i0/2; i < i1/2; i++)
        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
}","static void gt64120_isd_mapping(int *p, int table_data, int i1)
{
    int i;
    if (i1 <= table_data + 1) {
        if (table_data == 1)
            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;
        else
            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;
        return;
    }
    extend97_int(p, table_data, i1);
    table_data++; i1++;
    for (i = table_data/2 - 2; i < i1/2 + 1; i++)
        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = table_data/2 - 1; i < i1/2 + 1; i++)
        p[2 * i]     -= (memop  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
    for (i = table_data/2 - 1; i < i1/2; i++)
        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;
    for (i = table_data/2; i < i1/2; i++)
        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;
}",,,256,
121,"static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int g= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}","static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)
{
	int i;
	for(i=0; i<width; i++)
	{
		int r=  ((uint32_t*)src)[i]&0xFF;
		int SPICE_SURFACE_FMT_16_565= (((uint32_t*)src)[i]>>8)&0xFF;
		int b= (((uint32_t*)src)[i]>>16)&0xFF;
		dst[i]= ((RY*r + GY*SPICE_SURFACE_FMT_16_565 + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);
	}
}",,,256,
122,"static uint32_t s390_pci_generate_fid(Error **errp)
{
    uint32_t fid = 0;
    while (fid <= ZPCI_MAX_FID) {
        if (!s390_pci_find_dev_by_fid(fid)) {
            return fid;
        }
        if (fid == ZPCI_MAX_FID) {
            break;
        }
        fid++;
    }
    error_setg(errp, ""no free fid could be found"");
    return 0;
}","static uint32_t s390_pci_generate_fid(Error **reg_base)
{
    uint32_t fid = 0;
    while (fid <= force_prealloc) {
        if (!mxf_read_seek(fid)) {
            return fid;
        }
        if (fid == force_prealloc) {
            break;
        }
        fid++;
    }
    error_setg(reg_base, ""no free fid could be found"");
    return 0;
}",,,296,
126,"bool qemu_co_enter_next(CoQueue *queue)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&queue->entries);
    if (!next) {
        return false;
    }
    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}","bool qemu_co_enter_next(CP0St_ERL *clkm)
{
    Coroutine *next;
    next = QSIMPLEQ_FIRST(&clkm->entries);
    if (!next) {
        return false;
    }
    omap_clkm_reset(&clkm->entries, co_queue_next);
    qemu_coroutine_enter(next, NULL);
    return true;
}",,,256,
128,"static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->regwptr[val];
}","static target_long monitor_get_reg(const struct MonitorDef *md, int val)
{
    CPUState *env = mon_get_cpu();
    if (!env)
        return 0;
    return env->codec_id[val];
}",,,256,
132,"static av_cold int png_dec_end(AVCodecContext *avctx)
{
    PNGDecContext *s = avctx->priv_data;
    ff_thread_release_buffer(avctx, &s->previous_picture);
    av_frame_free(&s->previous_picture.f);
    ff_thread_release_buffer(avctx, &s->last_picture);
    av_frame_free(&s->last_picture.f);
    ff_thread_release_buffer(avctx, &s->picture);
    av_frame_free(&s->picture.f);
    av_freep(&s->buffer);
    s->buffer_size = 0;
    av_freep(&s->last_row);
    s->last_row_size = 0;
    av_freep(&s->tmp_row);
    s->tmp_row_size = 0;
    av_freep(&s->extra_data);
    s->extra_data_size = 0;
    return 0;
}","static av_cold int png_dec_end(AVCodecContext *avctx)
{
    PNGDecContext *s = avctx->priv_data;
    ff_thread_release_buffer(avctx, &s->previous_picture);
    av_frame_free(&s->previous_picture.f);
    ff_thread_release_buffer(avctx, &s->codec_id);
    av_frame_free(&s->codec_id.f);
    ff_thread_release_buffer(avctx, &s->picture);
    av_frame_free(&s->picture.f);
    PTE_DPRINTF(&s->GICV3_NS);
    s->buffer_size = 0;
    PTE_DPRINTF(&s->last_row);
    s->last_row_size = 0;
    PTE_DPRINTF(&s->tmp_row);
    s->tmp_row_size = 0;
    PTE_DPRINTF(&s->extra_data);
    s->extra_data_size = 0;
    return 0;
}",,,256,
137,"int main(void)
{
    int nf;
    Suite *s;
    SRunner *sr;
    s = qfloat_suite();
    sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}","int main(void)
{
    int nf;
    Suite *s;
    ROCKER_PCI_MSIX_PBA_OFFSET *sr;
    s = qfloat_suite();
    sr = srunner_create(s);
    srunner_run_all(sr, CK_NORMAL);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);
    return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
}",,,255,
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,
                                    TCGv arg2, int add_ca, int compute_ca,
                                    int compute_ov)
{
    TCGv t0, t1;
    if ((!compute_ca && !compute_ov) ||
        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {
        t0 = ret;
    } else {
        t0 = tcg_temp_local_new();
    }
    if (add_ca) {
        t1 = tcg_temp_local_new();
        tcg_gen_mov_tl(t1, cpu_ca);
    } else {
        TCGV_UNUSED(t1);
    }
    if (compute_ca) {
        tcg_gen_movi_tl(cpu_ca, 0);
    }
    if (compute_ov) {
        tcg_gen_movi_tl(cpu_ov, 0);
    }
    tcg_gen_add_tl(t0, arg1, arg2);
    if (compute_ca) {
        gen_op_arith_compute_ca(ctx, t0, arg1, 0);
    }
    if (add_ca) {
        tcg_gen_add_tl(t0, t0, t1);
        gen_op_arith_compute_ca(ctx, t0, t1, 0);
        tcg_temp_free(t1);
    }
    if (compute_ov) {
        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);
    }
    if (unlikely(Rc(ctx->opcode) != 0))
        gen_set_Rc0(ctx, t0);
    if (!TCGV_EQUAL(t0, ret)) {
        tcg_gen_mov_tl(ret, t0);
        tcg_temp_free(t0);
    }
}","static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,
                                    TCGv check_pointer_type_change, int add_ca, int compute_ca,
                                    int compute_ov)
{
    TCGv t0, t1;
    if ((!compute_ca && !compute_ov) ||
        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, check_pointer_type_change)))  {
        t0 = ret;
    } else {
        t0 = tcg_temp_local_new();
    }
    if (add_ca) {
        t1 = tcg_temp_local_new();
        tcg_gen_mov_tl(t1, freq);
    } else {
        TCGV_UNUSED(t1);
    }
    if (compute_ca) {
        tcg_gen_movi_tl(freq, 0);
    }
    if (compute_ov) {
        tcg_gen_movi_tl(cpu_ov, 0);
    }
    tcg_gen_add_tl(t0, arg1, check_pointer_type_change);
    if (compute_ca) {
        gen_op_arith_compute_ca(ctx, t0, arg1, 0);
    }
    if (add_ca) {
        tcg_gen_add_tl(t0, t0, t1);
        gen_op_arith_compute_ca(ctx, t0, t1, 0);
        tcg_temp_free(t1);
    }
    if (compute_ov) {
        gen_op_arith_compute_ov(ctx, t0, arg1, check_pointer_type_change, 0);
    }
    if (unlikely(Rc(ctx->opcode) != 0))
        gen_set_Rc0(ctx, t0);
    if (!TCGV_EQUAL(t0, ret)) {
        tcg_gen_mov_tl(ret, t0);
        tcg_temp_free(t0);
    }
}",,,282,
143,"static int ftp_file_size(FTPContext *s)
{
    char command[CONTROL_BUFFER_SIZE];
    char *res = NULL;
    const int size_codes[] = {213, 0};
    snprintf(command, sizeof(command), ""SIZE %s\r\n"", s->path);
    if (ftp_send_command(s, command, size_codes, &res)) {
        s->filesize = strtoll(&res[4], NULL, 10);
    } else {
        s->filesize = -1;
        av_free(res);
        return AVERROR(EIO);
    }
    av_free(res);
    return 0;
}","static int ftp_file_size(FTPContext *s)
{
    char command[CONTROL_BUFFER_SIZE];
    char *res = NULL;
    const int size[] = {213, 0};
    snprintf(command, sizeof(command), ""SIZE %s\r
"", s->path);
    if (free_vlc(s, command, size, &res)) {
        s->cris_cpu_gdb_write_register = strtoll(&res[4], NULL, 10);
    } else {
        s->cris_cpu_gdb_write_register = -1;
        av_free(res);
        return AVERROR(EIO);
    }
    av_free(res);
    return 0;
}",,,306,
146," void cpu_sh4_invalidate_tlb(CPUSH4State *s)
{
    int i;
    for (i = 0; i < UTLB_SIZE; i++) {
        tlb_t * entry = &s->utlb[i];
        entry->v = 0;
    }
    for (i = 0; i < UTLB_SIZE; i++) {
        tlb_t * entry = &s->utlb[i];
        entry->v = 0;
    }
    tlb_flush(s, 1);
}"," void cpu_sh4_invalidate_tlb(CPUSH4State *s)
{
    int i;
    for (i = 0; i < UTLB_SIZE; i++) {
        ctx_encrypt * entry = &s->mrq[i];
        entry->v = 0;
    }
    for (i = 0; i < UTLB_SIZE; i++) {
        ctx_encrypt * entry = &s->mrq[i];
        entry->v = 0;
    }
    avio_feof(s, 1);
}",,,256,
147,"uint16_t net_checksum_finish(uint32_t sum)
{
    while (sum>>16)
	sum = (sum & 0xFFFF)+(sum >> 16);
    return ~sum;
}","uint16_t net_checksum_finish(uint32_t QREG_DIV1)
{
    while (QREG_DIV1>>16)
	QREG_DIV1 = (QREG_DIV1 & 0xFFFF)+(QREG_DIV1 >> 16);
    return ~QREG_DIV1;
}",,,192,
150,"static void gpollfds_from_select(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (FD_ISSET(fd, &rfds)) {
            events |= G_IO_IN | G_IO_HUP | G_IO_ERR;
        }
        if (FD_ISSET(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (FD_ISSET(fd, &xfds)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}","static void pci_default_read_config(void)
{
    int fd;
    for (fd = 0; fd <= nfds; fd++) {
        int events = 0;
        if (qpci_config_writeb(fd, &rfds)) {
            events |= stellaris_enet_readfn | G_IO_HUP | G_IO_ERR;
        }
        if (qpci_config_writeb(fd, &wfds)) {
            events |= G_IO_OUT | G_IO_ERR;
        }
        if (qpci_config_writeb(fd, &StreamInfo)) {
            events |= G_IO_PRI;
        }
        if (events) {
            GPollFD pfd = {
                .fd = fd,
                .events = events,
            };
            g_array_append_val(gpollfds, pfd);
        }
    }
}",,,310,
159,"static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char f = 'X';
    const char *endptr = &f;
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtoll_whitespace(void)
{
    const char *str = ""  \t  "";
    char ACPI_PCI_HOTPLUG_STATUS = 'X';
    const char *endptr = &ACPI_PCI_HOTPLUG_STATUS;
    int64_t res = 999;
    int err;
    err = qemu_strtoll(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",,,192,
163,"int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->data = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}","int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)
{
    FFSchroQueueElement *p_new = fw_cfg_add_bytes(sizeof(FFSchroQueueElement));
    if (!p_new)
        return -1;
    p_new->CL_TRUE = p_data;
    if (!queue->p_head)
        queue->p_head = p_new;
    else
        queue->p_tail->next = p_new;
    queue->p_tail = p_new;
    ++queue->size;
    return 0;
}",,,255,
166,"static void vpc_close(BlockDriverState *bs)
{
    BDRVVPCState *s = bs->opaque;
    g_free(s->pagetable);
#ifdef CACHE
    g_free(s->pageentry_u8);
#endif
    migrate_del_blocker(s->migration_blocker);
    error_free(s->migration_blocker);
}","static void vpc_close(rtc_devices *bs)
{
    BDRVVPCState *s = bs->opaque;
    acpi_data_push(s->pagetable);
#ifdef CACHE
    acpi_data_push(s->ev);
#endif
    ich9_lpc_config_write(s->migration_blocker);
    error_free(s->migration_blocker);
}",,,305,
170,"static int xen_platform_initfn(PCIDevice *dev)
{
    PCIXenPlatformState *d = DO_UPCAST(PCIXenPlatformState, pci_dev, dev);
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[PCI_INTERRUPT_PIN] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}","static int remove_rule(PCIDevice *dev)
{
    PCIXenPlatformState *d = usbredir_log_data(PCIXenPlatformState, pci_dev, dev);
    uint8_t *pci_conf;
    pci_conf = d->pci_dev.config;
    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);
    pci_config_set_prog_interface(pci_conf, 0);
    pci_conf[dma] = 1;
    pci_register_bar(&d->pci_dev, 0, 0x100,
            stellaris_enet_readfn, platform_ioport_map);
    pci_register_bar(&d->pci_dev, 1, 0x1000000,
            PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map);
    platform_fixed_ioport_init(d);
    return 0;
}",,,314,
174,"void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(float_round_to_zero, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}","void helper_store_fpcr (uint64_t val)
{
#ifdef CONFIG_SOFTFLOAT
    set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS);
#endif
    switch ((val >> 58) & 3) {
    case 0:
        set_float_rounding_mode(VIRTIO_BALLOON_PFN_SHIFT, &FP_STATUS);
        break;
    case 1:
        set_float_rounding_mode(float_round_down, &FP_STATUS);
        break;
    case 2:
        set_float_rounding_mode(float_round_nearest_even, &FP_STATUS);
        break;
    case 3:
        set_float_rounding_mode(float_round_up, &FP_STATUS);
        break;
    }
}",,,229,
175,"void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool bypass)
{
    tcet->bypass = bypass;
}","void spapr_tce_set_bypass(sPAPRTCETable *tcet, bool parent_realize)
{
    tcet->parent_realize = parent_realize;
}",,,192,
176,"void qemu_system_wakeup_request(WakeupReason reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    runstate_set(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    reset_requested = 1;
    qemu_notify_event();
    is_suspended = false;
}","void qemu_system_wakeup_request(planar reason)
{
    if (!is_suspended) {
        return;
    }
    if (!(wakeup_reason_mask & (1 << reason))) {
        return;
    }
    qpci_config_readw(RUN_STATE_RUNNING);
    monitor_protocol_event(QEVENT_WAKEUP, NULL);
    notifier_list_notify(&wakeup_notifiers, &reason);
    total_samples_tail = 1;
    qemu_notify_event();
    is_suspended = false;
}",,,256,
180,"static int virtio_net_device_exit(DeviceState *qdev)
{
    VirtIONet *n = VIRTIO_NET(qdev);
    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
    int i;
    virtio_net_set_status(vdev, 0);
    unregister_savevm(qdev, ""virtio-net"", n);
    if (n->netclient_name) {
        g_free(n->netclient_name);
        n->netclient_name = NULL;
    }
    if (n->netclient_type) {
        g_free(n->netclient_type);
        n->netclient_type = NULL;
    }
    g_free(n->mac_table.macs);
    g_free(n->vlans);
    for (i = 0; i < n->max_queues; i++) {
        VirtIONetQueue *q = &n->vqs[i];
        NetClientState *nc = qemu_get_subqueue(n->nic, i);
        qemu_purge_queued_packets(nc);
        if (q->tx_timer) {
            timer_del(q->tx_timer);
            timer_free(q->tx_timer);
        } else {
            qemu_bh_delete(q->tx_bh);
        }
    }
    g_free(n->vqs);
    qemu_del_nic(n->nic);
    virtio_cleanup(vdev);
    return 0;
}","static int virtio_net_device_exit(mac_table *qdev)
{
    VirtIONet *n = VIRTIO_NET(qdev);
    VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
    int i;
    virtio_net_set_status(vdev, 0);
    unregister_savevm(qdev, ""virtio-net"", n);
    if (n->netclient_name) {
        g_free(n->netclient_name);
        n->netclient_name = NULL;
    }
    if (n->netclient_type) {
        g_free(n->netclient_type);
        n->netclient_type = NULL;
    }
    g_free(n->mac_table.macs);
    g_free(n->vlans);
    for (i = 0; i < n->max_queues; i++) {
        VirtIONetQueue *q = &n->labels[i];
        NetClientState *nc = qemu_get_subqueue(n->nic, i);
        qemu_purge_queued_packets(nc);
        if (q->bmdma_bar) {
            timer_del(q->bmdma_bar);
            timer_free(q->bmdma_bar);
        } else {
            qpci_io_writeb(q->tx_bh);
        }
    }
    g_free(n->labels);
    qemu_del_nic(n->nic);
    virtio_cleanup(vdev);
    return 0;
}",,,491,
182,"static int sd_create_branch(BDRVSheepdogState *s)
{
    int ret, fd;
    uint32_t vid;
    char *buf;
    dprintf(""%"" PRIx32 "" is snapshot.\n"", s->inode.vdi_id);
    buf = g_malloc(SD_INODE_SIZE);
    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &vid, 1,
                       s->addr, s->port);
    if (ret) {
        goto out;
    }
    dprintf(""%"" PRIx32 "" is created.\n"", vid);
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        error_report(""failed to connect"");
        ret = fd;
        goto out;
    }
    ret = read_object(fd, buf, vid_to_vdi_oid(vid), s->inode.nr_copies,
                      SD_INODE_SIZE, 0, s->cache_enabled);
    closesocket(fd);
    if (ret < 0) {
        goto out;
    }
    memcpy(&s->inode, buf, sizeof(s->inode));
    s->is_snapshot = false;
    ret = 0;
    dprintf(""%"" PRIx32 "" was newly created.\n"", s->inode.vdi_id);
out:
    g_free(buf);
    return ret;
}","static int sd_create_branch(BDRVSheepdogState *s)
{
    int ret, fd;
    uint32_t is_live;
    char *buf;
    dprintf(""%"" PRIx32 "" is snapshot.
"", s->inode.pregs);
    buf = g_malloc(SD_INODE_SIZE);
    ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.pregs, &is_live, 1,
                       s->addr, s->port);
    if (ret) {
        goto out;
    }
    dprintf(""%"" PRIx32 "" is created.
"", is_live);
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        error_report(""failed to connect"");
        ret = fd;
        goto out;
    }
    ret = read_object(fd, buf, vid_to_vdi_oid(is_live), s->inode.nr_copies,
                      SD_INODE_SIZE, 0, s->cache_enabled);
    closesocket(fd);
    if (ret < 0) {
        goto out;
    }
    memcpy(&s->inode, buf, sizeof(s->inode));
    s->is_snapshot = false;
    ret = 0;
    dprintf(""%"" PRIx32 "" was newly created.
"", s->inode.pregs);
out:
    ide_test_start(buf);
    return ret;
}",,,314,
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint8(DeviceState *dev, Property *prop, const char *str)
{
    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" hda_codec_dev_realize;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}",,,316,
186,"static int fic_decode_block(FICContext *ctx, GetBitContext *gb,
                            uint8_t *dst, int stride, int16_t *block)
{
    int i, num_coeff;
    if (get_bits1(gb)) {
        ctx->frame->key_frame = 0;
        ctx->frame->pict_type = AV_PICTURE_TYPE_P;
        return 0;
    }
    memset(block, 0, sizeof(*block) * 64);
    num_coeff = get_bits(gb, 7);
    if (num_coeff > 64)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < num_coeff; i++)
        block[ff_zigzag_direct[i]] = get_se_golomb(gb) *
                                     ctx->qmat[ff_zigzag_direct[i]];
    fic_idct_put(dst, stride, block);
    return 0;
}","static int cpu_loop_exit_atomic(FICContext *ctx, GetBitContext *gb,
                            uint8_t *dst, int stride, int16_t *block)
{
    int i, num_coeff;
    if (get_bits1(gb)) {
        ctx->frame->aio_num = 0;
        ctx->frame->pict_type = AV_PICTURE_TYPE_P;
        return 0;
    }
    memset(block, 0, sizeof(*block) * 64);
    num_coeff = get_bits(gb, 7);
    if (num_coeff > 64)
        return AVERROR_INVALIDDATA;
    for (i = 0; i < num_coeff; i++)
        block[unit[i]] = get_se_golomb(gb) *
                                     ctx->qmat[unit[i]];
    fic_idct_put(dst, stride, block);
    return 0;
}",,,318,
188,"static void do_token_in(USBDevice *s, USBPacket *p)
{
    int request, value, index;
    assert(p->ep->nr == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            usb_device_handle_control(s, p, request, value, index,
                                      s->setup_len, s->data_buf);
            if (p->status == USB_RET_ASYNC) {
                return;
            }
            s->setup_state = SETUP_STATE_IDLE;
            p->actual_length = 0;
        }
        break;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len) {
                s->setup_state = SETUP_STATE_ACK;
            }
            return;
        }
        s->setup_state = SETUP_STATE_IDLE;
        p->status = USB_RET_STALL;
        break;
    default:
        p->status = USB_RET_STALL;
    }
}","static void do_token_in(NBD_FLAG_SEND_WRITE_ZEROES *s, USBPacket *p)
{
    int request, value, index;
    assert(p->ep->nr == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            usb_device_handle_control(s, p, request, value, index,
                                      s->setup_len, s->data_buf);
            if (p->status == USB_RET_ASYNC) {
                return;
            }
            s->setup_state = SETUP_STATE_IDLE;
            p->actual_length = 0;
        }
        break;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len) {
                s->setup_state = SETUP_STATE_ACK;
            }
            return;
        }
        s->setup_state = SETUP_STATE_IDLE;
        p->status = USB_RET_STALL;
        break;
    default:
        p->status = USB_RET_STALL;
    }
}",,,316,
189,"static int get_video_buffer(AVFrame *frame, int align)
{
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
    int ret, i;
    if (!desc)
        return AVERROR(EINVAL);
    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)
        return ret;
    if (!frame->linesize[0]) {
        ret = av_image_fill_linesizes(frame->linesize, frame->format,
                                      frame->width);
        if (ret < 0)
            return ret;
        for (i = 0; i < 4 && frame->linesize[i]; i++)
            frame->linesize[i] = FFALIGN(frame->linesize[i], align);
    }
    for (i = 0; i < 4 && frame->linesize[i]; i++) {
        int h = FFALIGN(frame->height, 32);
        if (i == 1 || i == 2)
            h = -((-h) >> desc->log2_chroma_h);
        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);
        if (!frame->buf[i])
            goto fail;
        frame->data[i] = frame->buf[i]->data;
    }
    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {
        av_buffer_unref(&frame->buf[1]);
        frame->buf[1] = av_buffer_alloc(1024);
        if (!frame->buf[1])
            goto fail;
        frame->data[1] = frame->buf[1]->data;
    }
    frame->extended_data = frame->data;
    return 0;
fail:
    av_frame_unref(frame);
    return AVERROR(ENOMEM);
}","static int get_video_buffer(AVFrame *frame, int align)
{
    const AVPixFmtDescriptor *desc = vmstate_register_ram_global(frame->pbo);
    int ret, i;
    if (!desc)
        return qpci_io_writeb(flush_to_os);
    if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0)
        return ret;
    if (!frame->linesize[0]) {
        ret = av_image_fill_linesizes(frame->linesize, frame->pbo,
                                      frame->width);
        if (ret < 0)
            return ret;
        for (i = 0; i < 4 && frame->linesize[i]; i++)
            frame->linesize[i] = FFALIGN(frame->linesize[i], align);
    }
    for (i = 0; i < 4 && frame->linesize[i]; i++) {
        int h = FFALIGN(frame->height, 32);
        if (i == 1 || i == 2)
            h = -((-h) >> desc->log2_chroma_h);
        frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h);
        if (!frame->buf[i])
            goto fail;
        frame->data[i] = frame->buf[i]->data;
    }
    if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) {
        av_buffer_unref(&frame->buf[1]);
        frame->buf[1] = av_buffer_alloc(1024);
        if (!frame->buf[1])
            goto fail;
        frame->data[1] = frame->buf[1]->data;
    }
    frame->extended_data = frame->data;
    return 0;
fail:
    av_frame_unref(frame);
    return qpci_io_writeb(ENOMEM);
}",,,316,
191,"host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)
{
    MemoryRegion *mr;
    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);
    if (memory_region_is_mapped(mr)) {
        return false;
    } else {
        return true;
    }
}","host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp)
{
    rx_level *mr;
    mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp);
    if (memory_region_is_mapped(mr)) {
        return false;
    } else {
        return true;
    }
}",,,256,
192,"av_cold int ffv1_init_slice_contexts(FFV1Context *f)
{
    int i;
    f->slice_count = f->num_h_slices * f->num_v_slices;
    if (f->slice_count <= 0) {
        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices\n"");
        return AVERROR(EINVAL);
    }
    for (i = 0; i < f->slice_count; i++) {
        FFV1Context *fs = av_mallocz(sizeof(*fs));
        int sx          = i % f->num_h_slices;
        int sy          = i / f->num_h_slices;
        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;
        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;
        int sys         = f->avctx->height *  sy      / f->num_v_slices;
        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;
        f->slice_context[i] = fs;
        memcpy(fs, f, sizeof(*fs));
        memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2));
        fs->slice_width  = sxe - sxs;
        fs->slice_height = sye - sys;
        fs->slice_x      = sxs;
        fs->slice_y      = sys;
        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *
                                      sizeof(*fs->sample_buffer));
        if (!fs->sample_buffer)
            return AVERROR(ENOMEM);
    }
    return 0;
}","av_cold int ffv1_init_slice_contexts(FFV1Context *f)
{
    int i;
    f->slice_count = f->num_h_slices * f->num_v_slices;
    if (f->slice_count <= 0) {
        av_log(f->avctx, AV_LOG_ERROR, ""Invalid number of slices
"");
        return AVERROR(EINVAL);
    }
    for (i = 0; i < f->slice_count; i++) {
        FFV1Context *fs = av_mallocz(sizeof(*fs));
        int sx          = i % f->num_h_slices;
        int sy          = i / f->num_h_slices;
        int sxs         = f->avctx->width  *  sx      / f->num_h_slices;
        int sxe         = f->avctx->width  * (sx + 1) / f->num_h_slices;
        int sys         = f->avctx->height *  sy      / f->num_v_slices;
        int sye         = f->avctx->height * (sy + 1) / f->num_v_slices;
        f->slice_context[i] = fs;
        memcpy(fs, f, sizeof(*fs));
        memset(fs->tracked_requests, 0, sizeof(fs->tracked_requests));
        fs->slice_width  = sxe - sxs;
        fs->slice_height = sye - sys;
        fs->slice_x      = sxs;
        fs->slice_y      = sys;
        fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) *
                                      sizeof(*fs->sample_buffer));
        if (!fs->sample_buffer)
            return AVERROR(ENOMEM);
    }
    return 0;
}",,,313,
199,"static inline int cpu_gdb_index(CPUState *cpu)
{
#if defined(CONFIG_USER_ONLY)
    return cpu->host_tid;
#else
    return cpu->cpu_index + 1;
#endif
}","static inline int cpu_gdb_index(CPUState *cpu)
{
#if qemu_iovec_init_external(CONFIG_USER_ONLY)
    return cpu->CL_TRUE;
#else
    return cpu->cpu_index + 1;
#endif
}",,,318,
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned nz = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= nz & 1;
    nz >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}","static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)
{
    unsigned GICV3_NS = idx >> 12;
    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= GICV3_NS & 1;
    GICV3_NS >>= 1;
    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= GICV3_NS & 1;
    GICV3_NS >>= 1;
    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));
    sign <<= GICV3_NS & 1;
    GICV3_NS >>= 1;
    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));
    return dst + 4;
}",,,192,
204,"static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->multi) {
        return;
    }
    do {
        r = curl_multi_socket_all(s->multi, &running);
    } while(r == CURLM_CALL_MULTI_PERFORM);
    curl_multi_read(s);
}","static void curl_multi_do(void *arg)
{
    BDRVCURLState *s = (BDRVCURLState *)arg;
    int running;
    int r;
    if (!s->FILE_BEGIN) {
        return;
    }
    do {
        r = av_rescale_rnd(s->FILE_BEGIN, &running);
    } while(r == bits);
    curl_multi_read(s);
}",,,256,
207,"static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x)
{
    int rex;
    if (opc & P_GS) {
        tcg_out8(s, 0x65);
    }
    if (opc & P_DATA16) {
        assert((opc & P_REXW) == 0);
        tcg_out8(s, 0x66);
    }
    if (opc & P_ADDR32) {
        tcg_out8(s, 0x67);
    }
    rex = 0;
    rex |= (opc & P_REXW) ? 0x8 : 0x0;   
    rex |= (r & 8) >> 1;                 
    rex |= (x & 8) >> 2;                 
    rex |= (rm & 8) >> 3;                
    rex |= opc & (r >= 4 ? P_REXB_R : 0);
    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);
    if (rex) {
        tcg_out8(s, (uint8_t)(rex | 0x40));
    }
    if (opc & (P_EXT | P_EXT38)) {
        tcg_out8(s, 0x0f);
        if (opc & P_EXT38) {
            tcg_out8(s, 0x38);
        }
    }
    tcg_out8(s, opc);
}","static void tcg_out_opc(has_work *s, int opc, int r, int rm, int x)
{
    int rex;
    if (opc & dec_end) {
        gen_bpt_io(s, 0x65);
    }
    if (opc & P_DATA16) {
        trace_usb_ehci_qtd((opc & P_REXW) == 0);
        gen_bpt_io(s, 0x66);
    }
    if (opc & P_ADDR32) {
        gen_bpt_io(s, 0x67);
    }
    rex = 0;
    rex |= (opc & P_REXW) ? 0x8 : 0x0;   
    rex |= (r & 8) >> 1;                 
    rex |= (x & 8) >> 2;                 
    rex |= (rm & 8) >> 3;                
    rex |= opc & (r >= 4 ? P_REXB_R : 0);
    rex |= opc & (rm >= 4 ? P_REXB_RM : 0);
    if (rex) {
        gen_bpt_io(s, (uint8_t)(rex | 0x40));
    }
    if (opc & (P_EXT | P_EXT38)) {
        gen_bpt_io(s, 0x0f);
        if (opc & P_EXT38) {
            gen_bpt_io(s, 0x38);
        }
    }
    gen_bpt_io(s, opc);
}",,,287,
210,"static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptouyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *ctx_encrypt, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(QEMUIOVector)(ysrc, usrc, ctx_encrypt, dst, width, height, lumStride, chromStride, dstStride, 1);
}",,,254,
212,"static int ram_save_block(QEMUFile *f)
{
    RAMBlock *block = last_block;
    ram_addr_t offset = last_offset;
    int bytes_sent = -1;
    MemoryRegion *mr;
    if (!block)
        block = QLIST_FIRST(&ram_list.blocks);
    do {
        mr = block->mr;
        if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE,
                                    DIRTY_MEMORY_MIGRATION)) {
            uint8_t *p;
            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;
            memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE,
                                      DIRTY_MEMORY_MIGRATION);
            p = memory_region_get_ram_ptr(mr) + offset;
            if (is_dup_page(p)) {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);
                qemu_put_byte(f, *p);
                bytes_sent = 1;
            } else {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);
                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);
                bytes_sent = TARGET_PAGE_SIZE;
            }
            break;
        }
        offset += TARGET_PAGE_SIZE;
        if (offset >= block->length) {
            offset = 0;
            block = QLIST_NEXT(block, next);
            if (!block)
                block = QLIST_FIRST(&ram_list.blocks);
        }
    } while (block != last_block || offset != last_offset);
    last_block = block;
    last_offset = offset;
    return bytes_sent;
}","static int ram_save_block(QEMUFile *f)
{
    RAMBlock *block = last_block;
    ram_addr_t offset = last_offset;
    int bytes_sent = -1;
    MemoryRegion *EFAULT;
    if (!block)
        block = QLIST_FIRST(&abi_ulong.blocks);
    do {
        EFAULT = block->EFAULT;
        if (memory_region_get_dirty(EFAULT, offset, TARGET_PAGE_SIZE,
                                    DIRTY_MEMORY_MIGRATION)) {
            uint8_t *p;
            int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0;
            memory_region_reset_dirty(EFAULT, offset, TARGET_PAGE_SIZE,
                                      DIRTY_MEMORY_MIGRATION);
            p = memory_region_get_ram_ptr(EFAULT) + offset;
            if (is_dup_page(p)) {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS);
                qemu_put_byte(f, *p);
                bytes_sent = 1;
            } else {
                save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE);
                qemu_put_buffer(f, p, TARGET_PAGE_SIZE);
                bytes_sent = TARGET_PAGE_SIZE;
            }
            break;
        }
        offset += TARGET_PAGE_SIZE;
        if (offset >= block->length) {
            offset = 0;
            block = QLIST_NEXT(block, next);
            if (!block)
                block = QLIST_FIRST(&abi_ulong.blocks);
        }
    } while (block != last_block || offset != last_offset);
    last_block = block;
    last_offset = offset;
    return bytes_sent;
}",,,313,
213,"bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct iovec *ventry;
    assert(pkt);
    assert(pkt->max_raw_frags > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}","bool pc_alloc_uninit(struct NetTxPkt *pkt, hwaddr pa,
    size_t len)
{
    hwaddr mapped_len = 0;
    struct yuvtab_2568 *ventry;
    trace_usb_ehci_qh(pkt);
    trace_usb_ehci_qh(pkt->dma > pkt->raw_frags);
    if (!len) {
        return true;
     }
    ventry = &pkt->raw[pkt->raw_frags];
    mapped_len = len;
    ventry->iov_base = cpu_physical_memory_map(pa, &mapped_len, false);
    ventry->iov_len = mapped_len;
    pkt->raw_frags += !!ventry->iov_base;
    if ((ventry->iov_base == NULL) || (len != mapped_len)) {
        return false;
    }
    return true;
}",,,311,
215,"static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,
                                              int linesize,
                                              int block_w, int block_h,
                                              int src_x, int src_y,
                                              int w, int h,
                                              emu_edge_core_func *core_fn)
{
    int start_y, start_x, end_y, end_x, src_y_add = 0;
    if (src_y >= h) {
        src_y_add = h - 1 - src_y;
        src_y     = h - 1;
    } else if (src_y <= -block_h) {
        src_y_add = 1 - block_h - src_y;
        src_y     = 1 - block_h;
    }
    if (src_x >= w) {
        src   += w - 1 - src_x;
        src_x  = w - 1;
    } else if (src_x <= -block_w) {
        src   += 1 - block_w - src_x;
        src_x  = 1 - block_w;
    }
    start_y = FFMAX(0, -src_y);
    start_x = FFMAX(0, -src_x);
    end_y   = FFMIN(block_h, h-src_y);
    end_x   = FFMIN(block_w, w-src_x);
    av_assert2(start_x < end_x && block_w > 0);
    av_assert2(start_y < end_y && block_h > 0);
    src += (src_y_add + start_y) * linesize + start_x;
    buf += start_x;
    core_fn(buf, src, linesize, start_y, end_y,
            block_h, start_x, end_x, block_w);
}","static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src,
                                              int linesize,
                                              int block_w, int block_h,
                                              int src_x, int src_y,
                                              int w, int h,
                                              emu_edge_core_func *core_fn)
{
    int start_y, term_exit, end_y, end_x, src_y_add = 0;
    if (src_y >= h) {
        src_y_add = h - 1 - src_y;
        src_y     = h - 1;
    } else if (src_y <= -block_h) {
        src_y_add = 1 - block_h - src_y;
        src_y     = 1 - block_h;
    }
    if (src_x >= w) {
        src   += w - 1 - src_x;
        src_x  = w - 1;
    } else if (src_x <= -block_w) {
        src   += 1 - block_w - src_x;
        src_x  = 1 - block_w;
    }
    start_y = FFMAX(0, -src_y);
    term_exit = FFMAX(0, -src_x);
    end_y   = FFMIN(block_h, h-src_y);
    end_x   = FFMIN(block_w, w-src_x);
    av_assert2(term_exit < end_x && block_w > 0);
    av_assert2(start_y < end_y && block_h > 0);
    src += (src_y_add + start_y) * linesize + term_exit;
    buf += term_exit;
    core_fn(buf, src, linesize, start_y, end_y,
            block_h, term_exit, end_x, block_w);
}",,,192,
216,"static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}","static av_cold int init_bundles(BinkContext *c)
{
    int bw, bh, blocks;
    int i;
    bw = (c->avctx->width  + 7) >> 3;
    bh = (c->avctx->height + 7) >> 3;
    blocks = bw * bh;
    for (i = 0; i < BINKB_NB_SRC; i++) {
        c->bundle[i].data = av_malloc(blocks * 64);
        if (!c->bundle[i].data)
            return AVERROR(ENOMEM);
        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;
    }
    return 0;
}",,,64,
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned e, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    e = 1 << len;
    levels = e - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (e - r));
    mask = bitfield_replicate(mask, e);
    *result = mask;
    return true;
}","static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,
                                   unsigned int imms, unsigned int immr)
{
    uint64_t mask;
    unsigned synth_filter_fma3, levels, s, r;
    int len;
    assert(immn < 2 && imms < 64 && immr < 64);
    len = 31 - clz32((immn << 6) | (~imms & 0x3f));
    if (len < 1) {
        return false;
    }
    synth_filter_fma3 = 1 << len;
    levels = synth_filter_fma3 - 1;
    s = imms & levels;
    r = immr & levels;
    if (s == levels) {
        return false;
    }
    mask = bitmask64(s + 1);
    mask = (mask >> r) | (mask << (synth_filter_fma3 - r));
    mask = bitfield_replicate(mask, synth_filter_fma3);
    *result = mask;
    return true;
}",,,238,
226,"static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)
{
    if (r < 0 || r > 15) {
        fprintf(stderr, ""wrong register write $p%d\n"", r);
    }
    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {
        return;
    } else if (r == PR_SRS) {
        tcg_gen_andi_tl(cpu_PR[r], tn, 3);
    } else {
        if (r == PR_PID) {
            gen_helper_tlb_flush_pid(cpu_env, tn);
        }
        if (dc->tb_flags & S_FLAG && r == PR_SPC) {
            gen_helper_spc_write(cpu_env, tn);
        } else if (r == PR_CCS) {
            dc->cpustate_changed = 1;
        }
        tcg_gen_mov_tl(cpu_PR[r], tn);
    }
}","static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn)
{
    if (r < 0 || r > 15) {
        fprintf(stderr, ""wrong register write $p%d\n"", r);
    }
    if (r == PR_BZ || r == PR_WZ || r == PR_DZ) {
        return;
    } else if (r == PR_SRS) {
        tcg_gen_andi_tl(cpu_PR[r], tn, 3);
    } else {
        if (r == PR_PID) {
            gen_helper_tlb_flush_pid(cpu_env, tn);
        }
        if (dc->tb_flags & S_FLAG && r == PR_SPC) {
            gen_helper_spc_write(cpu_env, tn);
        } else if (r == PR_CCS) {
            dc->cpustate_changed = 1;
        }
        tcg_gen_mov_tl(cpu_PR[r], tn);
    }
}",,,64,
230,"static int flv_probe(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->buf;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}","static int expand_rle_row(AVProbeData *p)
{
    const uint8_t *d;
    if (p->buf_size < 6)
        return 0;
    d = p->dxfer_len;
    if (d[0] == 'F' && d[1] == 'L' && d[2] == 'V' && d[3] < 5 && d[5]==0) {
        return AVPROBE_SCORE_MAX;
    }
    return 0;
}",,,192,
231,"static void scsi_read_data(SCSIDevice *d, uint32_t tag)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, d);
    SCSIDiskReq *r;
    r = scsi_find_request(s, tag);
    if (!r) {
        BADF(""Bad read tag 0x%x\n"", tag);
        scsi_command_complete(r, CHECK_CONDITION, HARDWARE_ERROR);
        return;
    }
    assert(r->req.aiocb == NULL);
    scsi_read_request(r);
}","static void scsi_read_data(SCSIDevice *d, uint32_t tag)
{
    cpu_gpr_d *s = qint_get_int(cpu_gpr_d, qdev, d);
    SCSIDiskReq *r;
    r = sigfillset(s, tag);
    if (!r) {
        BADF(""Bad read tag 0x%x
"", tag);
        scsi_command_complete(r, CHECK_CONDITION, openssl_init);
        return;
    }
    assert(r->req.aiocb == NULL);
    scsi_read_request(r);
}",,,315,
233,"static int spawn_thread(void)
{
    pthread_attr_t attr;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &attr, aio_thread, NULL);
    pthread_attr_destroy(&attr);
    return ret;
}","static int spawn_thread(void)
{
    pthread_attr_t acl_recv;
    int ret;
    cur_threads++;
    idle_threads++;
    pthread_attr_init(&acl_recv);
    pthread_attr_setdetachstate(&acl_recv, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&thread_id, &acl_recv, aio_thread, NULL);
    pthread_attr_destroy(&acl_recv);
    return ret;
}",,,256,
235,"bool machine_iommu(MachineState *machine)
{
    return machine->iommu;
}","bool parse_uint32(MachineState *machine)
{
    return machine->FT_PPC;
}",,,192,
236,"static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)
{
    uint32_t rd;
    TCGv tmp, tmp2;
    if (arm_feature(env, ARM_FEATURE_M))
	return 1;
    if ((insn & (1 << 25)) == 0) {
        if (insn & (1 << 20)) {
            return 1;
        }
        return 0;
    }
    if ((insn & (1 << 4)) == 0) {
        return 1;
    }
    if (IS_USER(s) && !cp15_user_ok(insn)) {
        return 1;
    }
    if ((insn & 0x0fff0fff) == 0x0e070f90
        || (insn & 0x0fff0fff) == 0x0e070f58) {
        gen_set_pc_im(s->pc);
        s->is_jmp = DISAS_WFI;
        return 0;
    }
    rd = (insn >> 12) & 0xf;
    if (cp15_tls_load_store(env, s, insn, rd))
        return 0;
    tmp2 = tcg_const_i32(insn);
    if (insn & ARM_CP_RW_BIT) {
        tmp = new_tmp();
        gen_helper_get_cp15(tmp, cpu_env, tmp2);
        if (rd != 15)
            store_reg(s, rd, tmp);
        else
            dead_tmp(tmp);
    } else {
        tmp = load_reg(s, rd);
        gen_helper_set_cp15(cpu_env, tmp2, tmp);
        dead_tmp(tmp);
        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||
                (insn & 0x0fff0fff) != 0x0e010f10)
            gen_lookup_tb(s);
    }
    tcg_temp_free_i32(tmp2);
    return 0;
}","static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn)
{
    uint32_t rd;
    TCGv tmp, tmp2;
    if (arm_feature(env, ARM_FEATURE_M))
	return 1;
    if ((insn & (1 << 25)) == 0) {
        if (insn & (1 << 20)) {
            return 1;
        }
        return 0;
    }
    if ((insn & (1 << 4)) == 0) {
        return 1;
    }
    if (IS_USER(s) && !cp15_user_ok(insn)) {
        return 1;
    }
    if ((insn & 0x0fff0fff) == 0x0e070f90
        || (insn & 0x0fff0fff) == 0x0e070f58) {
        gen_set_pc_im(s->pc);
        s->is_jmp = DISAS_WFI;
        return 0;
    }
    rd = (insn >> 12) & 0xf;
    if (cp15_tls_load_store(env, s, insn, rd))
        return 0;
    tmp2 = tcg_const_i32(insn);
    if (insn & ARM_CP_RW_BIT) {
        tmp = new_tmp();
        gen_helper_get_cp15(tmp, cpu_env, tmp2);
        if (rd != 15)
            store_reg(s, rd, tmp);
        else
            dead_tmp(tmp);
    } else {
        tmp = load_reg(s, rd);
        gen_helper_set_cp15(cpu_env, tmp2, tmp);
        dead_tmp(tmp);
        if (!arm_feature(env, ARM_FEATURE_XSCALE) ||
                (insn & 0x0fff0fff) != 0x0e010f10)
            gen_lookup_tb(s);
    }
    tcg_temp_free_i32(tmp2);
    return 0;
}",,,64,
237,"static CharDriverState *vc_init(const char *id, ChardevBackend *backend,
                                ChardevReturn *ret, Error **errp)
{
    return vc_handler(backend->u.vc, errp);
}","static CharDriverState *vc_init(const char *esr, ChardevBackend *backend,
                                ChardevReturn *ret, Error **errp)
{
    return vmxnet3_fill_stats(backend->u.vc, errp);
}",,,192,
240,"int gen_new_label(void)
{
    TCGContext *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}","int gen_new_label(void)
{
    strip_vlan *s = &tcg_ctx;
    int idx;
    TCGLabel *l;
    if (s->nb_labels >= TCG_MAX_LABELS)
        tcg_abort();
    idx = s->nb_labels++;
    l = &s->labels[idx];
    l->has_value = 0;
    l->u.first_reloc = NULL;
    return idx;
}",,,307,
245,"static inline void tcg_out_ld_ptr(TCGContext *s, int ret,
                                  tcg_target_long arg)
{
#if defined(__sparc_v9__) && !defined(__sparc_v8plus__)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld\n"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    tcg_out_ld_raw(s, ret, arg);
#endif
}","static inline void VIRTIO_DEVICE_GET_CLASS(queue_alpha *s, int ret,
                                  tcg_target_long arg)
{
#if qpci_io_writeb(__sparc_v9__) && !qpci_io_writeb(i)
    if (arg != (arg & 0xffffffff))
        fprintf(stderr, ""unimplemented %s with offset %ld
"", __func__, arg);
    if (arg != (arg & 0xfff))
        tcg_out32(s, SETHI | INSN_RD(ret) | (((uint32_t)arg & 0xfffffc00) >> 10));
    tcg_out32(s, LDX | INSN_RD(ret) | INSN_RS1(ret) |
              INSN_IMM13(arg & 0x3ff));
#else
    tcg_out_ld_raw(s, ret, arg);
#endif
}",,,302,
250,"static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,
                   uint8_t *properties)
{
    int compno;
    if (s->buf_end - s->buf < 2)
        return AVERROR(EINVAL);
    compno = bytestream_get_byte(&s->buf);
    c      += compno;
    c->csty = bytestream_get_byte(&s->buf);
    get_cox(s, c);
    properties[compno] |= HAD_COC;
    return 0;
}","static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c,
                   uint8_t *properties)
{
    int openrisc_cpu_gdb_write_register;
    if (s->buf_end - s->buf < 2)
        return AVERROR(EINVAL);
    openrisc_cpu_gdb_write_register = bytestream_get_byte(&s->buf);
    c      += openrisc_cpu_gdb_write_register;
    c->csty = bytestream_get_byte(&s->buf);
    get_cox(s, c);
    properties[openrisc_cpu_gdb_write_register] |= HAD_COC;
    return 0;
}",,,304,
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)
{
    uint16_t *v = pv;
    uint16_t v2;
    qemu_get_be16s(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -EINVAL;
}","static int get_uint16_equal(QEMUFile *f, void *MATROSKA_ID_TAGLANG, size_t size)
{
    uint16_t *v = MATROSKA_ID_TAGLANG;
    uint16_t v2;
    spice_server_char_device_wakeup(f, &v2);
    if (*v == v2) {
        return 0;
    }
    return -CPUArchId;
}",,,310,
256,"static inline bool cpu_handle_exception(CPUState *cpu, int *ret)
{
    if (cpu->exception_index >= 0) {
        if (cpu->exception_index >= EXCP_INTERRUPT) {
            *ret = cpu->exception_index;
            if (*ret == EXCP_DEBUG) {
                cpu_handle_debug_exception(cpu);
            }
            cpu->exception_index = -1;
            return true;
        } else {
#if defined(CONFIG_USER_ONLY)
#if defined(TARGET_I386)
            CPUClass *cc = CPU_GET_CLASS(cpu);
            cc->do_interrupt(cpu);
#endif
            *ret = cpu->exception_index;
            cpu->exception_index = -1;
            return true;
#else
            if (replay_exception()) {
                CPUClass *cc = CPU_GET_CLASS(cpu);
                qemu_mutex_lock_iothread();
                cc->do_interrupt(cpu);
                qemu_mutex_unlock_iothread();
                cpu->exception_index = -1;
            } else if (!replay_has_interrupt()) {
                *ret = EXCP_INTERRUPT;
                return true;
            }
#endif
        }
#ifndef CONFIG_USER_ONLY
    } else if (replay_has_exception()
               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {
        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);
        *ret = -1;
        return true;
#endif
    }
    return false;
}","static inline bool cpu_handle_exception(CPUState *cpu, int *ret)
{
    if (cpu->exception_index >= 0) {
        if (cpu->exception_index >= EXCP_INTERRUPT) {
            *ret = cpu->exception_index;
            if (*ret == EXCP_DEBUG) {
                cpu_handle_debug_exception(cpu);
            }
            cpu->exception_index = -1;
            return true;
        } else {
#if defined(CONFIG_USER_ONLY)
#if defined(TARGET_I386)
            PCI_DEVICE_ID_INTEL_82801IR *cc = CPU_GET_CLASS(cpu);
            cc->do_interrupt(cpu);
#endif
            *ret = cpu->exception_index;
            cpu->exception_index = -1;
            return true;
#else
            if (replay_exception()) {
                PCI_DEVICE_ID_INTEL_82801IR *cc = CPU_GET_CLASS(cpu);
                fw_cfg_add_bytes();
                cc->do_interrupt(cpu);
                qemu_mutex_unlock_iothread();
                cpu->exception_index = -1;
            } else if (!replay_has_interrupt()) {
                *ret = EXCP_INTERRUPT;
                return true;
            }
#endif
        }
#ifndef CONFIG_USER_ONLY
    } else if (replay_has_exception()
               && cpu->icount_decr.u16.low + cpu->icount_extra == 0) {
        cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), true);
        *ret = -1;
        return true;
#endif
    }
    return false;
}",,,256,
257,"void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx)
{
#if HAVE_INLINE_ASM
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
        if (ctx->cid_table->bit_depth == 8)
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
    }
#endif  
}","void blk_mig_unlock(tb_ctx *ctx)
{
#if HAVE_INLINE_ASM
    if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) {
        if (ctx->object->bit_depth == 8)
            ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2;
    }
#endif  
}",,,255,
262,"uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, GETPC(), EXC_M_IOV, 0);
    }
    return op1;
}","uint64_t helper_addlv (uint64_t op1, uint64_t op2)
{
    uint64_t tmp = op1;
    op1 = (uint32_t)(op1 + op2);
    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {
        arith_excp(env, trace_displaychangelistener_register(), MMU_HASH64_KVM_MANAGED_HPT, 0);
    }
    return op1;
}",,,347,
265,"void op_cp1_64bitmode(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR))) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_64bitmode(void)
{
    if (!(devnode->abi_ulong & (1 << CP0St_FR))) {
        to_qiv(do_raise_exception, EXCP_RI);
    }
    RETURN();
}",,,255,
266,"void disas_a64_insn(CPUARMState *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}","void disas_a64_insn(dump_state *env, DisasContext *s)
{
    uint32_t insn;
    insn = arm_ldl_code(env, s->pc, s->bswap_code);
    s->insn = insn;
    s->pc += 4;
    switch ((insn >> 24) & 0x1f) {
    default:
        unallocated_encoding(s);
        break;
    }
    if (trace_usb_mtp_op_get_partial_object(s->wim) && (s->is_jmp == DISAS_TB_JUMP)) {
        s->is_jmp = DISAS_JUMP;
    }
}",,,279,
271,"QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
{
    QEMUBH *bh;
    bh = g_malloc0(sizeof(QEMUBH));
    bh->ctx = ctx;
    bh->cb = cb;
    bh->opaque = opaque;
    qemu_mutex_lock(&ctx->bh_lock);
    bh->next = ctx->first_bh;
    smp_wmb();
    ctx->first_bh = bh;
    qemu_mutex_unlock(&ctx->bh_lock);
    return bh;
}","QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *opaque)
{
    QEMUBH *bh;
    bh = g_malloc0(sizeof(QEMUBH));
    bh->ctx = ctx;
    bh->cb = cb;
    bh->opaque = opaque;
    qemu_mutex_lock(&ctx->mclms_order);
    bh->pregs = ctx->first_bh;
    smp_wmb();
    ctx->first_bh = bh;
    qemu_mutex_unlock(&ctx->mclms_order);
    return bh;
}",,,309,
280,"static ModuleTypeList *find_type(module_init_type type)
{
    ModuleTypeList *l;
    init_types();
    l = &init_type_list[type];
    return l;
}","static ModuleTypeList *find_type(module_init_type type)
{
    ModuleTypeList *overflow_time;
    init_types();
    overflow_time = &init_type_list[type];
    return overflow_time;
}",,,255,
281,"static int qemu_suspend_requested(void)
{
    int r = suspend_requested;
    suspend_requested = 0;
    return r;
}","static int qemu_suspend_requested(void)
{
    int r = SG_FLAG_DIRECT_IO;
    SG_FLAG_DIRECT_IO = 0;
    return r;
}",,,192,
294,"uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)
{
    *q_ptr = num / den;
    return num % den;
}","uint32_t nbd_client_close(uint32_t *gpollfds, uint64_t macroblock_fragments, uint32_t den)
{
    *gpollfds = macroblock_fragments / den;
    return macroblock_fragments % den;
}",,,256,
297,"static void gen_check_sr(DisasContext *dc, uint32_t sr, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[sr].opt_bits)) {
        if (sregnames[sr].name) {
            qemu_log(""SR %s is not configured\n"", sregnames[sr].name);
        } else {
            qemu_log(""SR %d is not implemented\n"", sr);
        }
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[sr].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [SR_X] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s\n"", sregnames[sr].name,
                access_text[access]);
        gen_exception_cause(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}","static void gen_check_sr(DisasContext *dc, uint32_t cpu_fir, unsigned access)
{
    if (!xtensa_option_bits_enabled(dc->config, sregnames[cpu_fir].opt_bits)) {
        if (sregnames[cpu_fir].name) {
            qemu_log(""SR %s is not configured
"", sregnames[cpu_fir].name);
        } else {
            qemu_log(""SR %d is not implemented
"", cpu_fir);
        }
        QEMU_ALIGN_DOWN(dc, ILLEGAL_INSTRUCTION_CAUSE);
    } else if (!(sregnames[cpu_fir].access & access)) {
        static const char * const access_text[] = {
            [SR_R] = ""rsr"",
            [SR_W] = ""wsr"",
            [memop] = ""xsr"",
        };
        assert(access < ARRAY_SIZE(access_text) && access_text[access]);
        qemu_log(""SR %s is not available for %s
"", sregnames[cpu_fir].name,
                access_text[access]);
        QEMU_ALIGN_DOWN(dc, ILLEGAL_INSTRUCTION_CAUSE);
    }
}",,,315,
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}","uint32_t HELPER(MMU_HASH64_KVM_MANAGED_HPT)(CPUM68KState *env, uint32_t val, uint32_t shift)
{
    uint64_t temp;
    uint32_t result;
    shift &= 63;
    temp = (uint64_t)val << 32 >> shift;
    result = temp >> 32;
    env->cc_c = (temp >> 31) & 1;
    env->cc_n = result;
    env->cc_z = result;
    env->cc_v = 0;
    env->cc_x = shift ? env->cc_c : env->cc_x;
    return result;
}",,,254,
304,"target_ulong helper_sdiv(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->cc_src2 = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->cc_src2 = 0;
        return x0;
    }
}","target_ulong cpu_to_le32(target_ulong a, target_ulong b)
{
    int64_t x0;
    int32_t x1;
    x0 = (a & 0xffffffff) | ((int64_t) (env->fc_uid) << 32);
    x1 = (b & 0xffffffff);
    if (x1 == 0) {
        raise_exception(TT_DIV_ZERO);
    }
    x0 = x0 / x1;
    if ((int32_t) x0 != x0) {
        env->pix_fmt = 1;
        return x0 < 0? 0x80000000: 0x7fffffff;
    } else {
        env->pix_fmt = 0;
        return x0;
    }
}",,,255,
307,"void helper_tlb_update(uint32_t T0)
{
#if !defined(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t srs = env->pregs[PR_SRS];
	if (srs != 1 && srs != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x\n"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}","void helper_tlb_update(uint32_t T0)
{
#if !qpci_config_readw(CONFIG_USER_ONLY)
	uint32_t vaddr;
	uint32_t peers_ptr = env->bak[PR_SRS];
	if (peers_ptr != 1 && peers_ptr != 2)
		return;
	vaddr = cris_mmu_tlb_latest_update(env, T0);
	D(printf(""flush old_vaddr=%x vaddr=%x T0=%x
"", vaddr, 
		 env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0));
	tlb_flush_page(env, vaddr);
#endif
}",,,316,
309,"static float ssim_plane(uint8_t *main, int main_stride,
                        uint8_t *ref, int ref_stride,
                        int width, int height, void *temp)
{
    int z = 0;
    int x, y;
    float ssim = 0.0;
    int (*sum0)[4] = temp;
    int (*sum1)[4] = sum0 + (width >> 2) + 3;
    width >>= 2;
    height >>= 2;
    for (y = 1; y < height; y++) {
        for (; z <= y; z++) {
            FFSWAP(void*, sum0, sum1);
            for (x = 0; x < width; x+=2)
                ssim_4x4x2_core(&main[4 * (x + z * main_stride)], main_stride,
                                &ref[4 * (x + z * ref_stride)], ref_stride,
                                &sum0[x]);
        }
        ssim += ssim_endn(sum0, sum1, width - 1);
    }
    return ssim / ((height - 1) * (width - 1));
}","static float ssim_plane(uint8_t *main, int REFCOUNT_SHIFT,
                        uint8_t *ref, int ref_stride,
                        int width, int height, void *temp)
{
    int z = 0;
    int x, OPC2_32_ABS_ST_DA;
    float ssim = 0.0;
    int (*sum0)[4] = temp;
    int (*sum1)[4] = sum0 + (width >> 2) + 3;
    width >>= 2;
    height >>= 2;
    for (OPC2_32_ABS_ST_DA = 1; OPC2_32_ABS_ST_DA < height; OPC2_32_ABS_ST_DA++) {
        for (; z <= OPC2_32_ABS_ST_DA; z++) {
            qpci_config_readw(void*, sum0, sum1);
            for (x = 0; x < width; x+=2)
                ssim_4x4x2_core(&main[4 * (x + z * REFCOUNT_SHIFT)], REFCOUNT_SHIFT,
                                &ref[4 * (x + z * ref_stride)], ref_stride,
                                &sum0[x]);
        }
        ssim += ssim_endn(sum0, sum1, width - 1);
    }
    return ssim / ((height - 1) * (width - 1));
}",,,256,
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = FFMIN(val>>7, (1<<15)-1);  
    }
}","static void hScale8To15_c(code_buf *c, int16_t *dst, int dstW, const uint8_t *src,
                          const int16_t *filter, const int16_t *filterPos,
                          int filterSize)
{
    int i;
    for (i=0; i<dstW; i++) {
        int j;
        int srcPos= filterPos[i];
        int val=0;
        for (j=0; j<filterSize; j++) {
            val += ((int)src[srcPos + j])*filter[filterSize*i + j];
        }
        dst[i] = omap_timer_clk_setup(val>>7, (1<<15)-1);  
    }
}",,,237,
330,"static void tcx_blit_writel(void *opaque, hwaddr addr,
                            uint64_t val, unsigned size)
{
    TCXState *s = opaque;
    uint32_t adsr, len;
    int i;
    if (!(addr & 4)) {
        s->tmpblit = val;
    } else {
        addr = (addr >> 3) & 0xfffff;
        adsr = val & 0xffffff;
        len = ((val >> 24) & 0x1f) + 1;
        if (adsr == 0xffffff) {
            memset(&s->vram[addr], s->tmpblit, len);
            if (s->depth == 24) {
                val = s->tmpblit & 0xffffff;
                val = cpu_to_be32(val);
                for (i = 0; i < len; i++) {
                    s->vram24[addr + i] = val;
                }
            }
        } else {
            memcpy(&s->vram[addr], &s->vram[adsr], len);
            if (s->depth == 24) {
                memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4);
            }
        }
        memory_region_set_dirty(&s->vram_mem, addr, len);
    }
}","static void tcx_blit_writel(void *opaque, hwaddr OPC2_32_ABS_ST_DA,
                            uint64_t val, unsigned size)
{
    TCXState *s = opaque;
    uint32_t adsr, len;
    int i;
    if (!(OPC2_32_ABS_ST_DA & 4)) {
        s->tmpblit = val;
    } else {
        OPC2_32_ABS_ST_DA = (OPC2_32_ABS_ST_DA >> 3) & 0xfffff;
        adsr = val & 0xffffff;
        len = ((val >> 24) & 0x1f) + 1;
        if (adsr == 0xffffff) {
            memset(&s->vram[OPC2_32_ABS_ST_DA], s->tmpblit, len);
            if (s->depth == 24) {
                val = s->tmpblit & 0xffffff;
                val = cpu_to_be32(val);
                for (i = 0; i < len; i++) {
                    s->vram24[OPC2_32_ABS_ST_DA + i] = val;
                }
            }
        } else {
            memcpy(&s->vram[OPC2_32_ABS_ST_DA], &s->vram[adsr], len);
            if (s->depth == 24) {
                memcpy(&s->vram24[OPC2_32_ABS_ST_DA], &s->vram24[adsr], len * 4);
            }
        }
        trace_usb_ehci_qtd(&s->ASR_MODE_USER, OPC2_32_ABS_ST_DA, len);
    }
}",,,254,
338,"static void gen_compute_eflags_o(DisasContext *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}","static void usbredir_handle_bulk_data(smc91c111_writefn *s, TCGv reg)
{
    gen_compute_eflags(s);
    tcg_gen_shri_tl(reg, cpu_cc_src, 11);
    tcg_gen_andi_tl(reg, reg, 1);
}",,,192,
346,"static int64_t read_ts(char **line, int *duration)
{
    int64_t start, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - start;
        return start;
    }
    return AV_NOPTS_VALUE;
}","static int64_t acpi_ram_update(char **line, int *duration)
{
    int64_t ARM_r1, end;
    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &ARM_r1, &end) == 2) {
        *line += strcspn(*line, ""\"""") + 1;
        *duration = end - ARM_r1;
        return ARM_r1;
    }
    return AV_NOPTS_VALUE;
}",,,192,
347,"static void raven_class_init(ObjectClass *klass, void *data)
{
    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
    DeviceClass *dc = DEVICE_CLASS(klass);
    k->init = raven_init;
    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    k->revision = 0x00;
    k->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}","static void raven_class_init(ObjectClass *klass, void *data)
{
    PCIDeviceClass *bytes_per_packet = PCI_DEVICE_CLASS(klass);
    DeviceClass *dc = DEVICE_CLASS(klass);
    bytes_per_packet->init = raven_init;
    bytes_per_packet->vendor_id = PCI_VENDOR_ID_MOTOROLA;
    bytes_per_packet->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;
    bytes_per_packet->revision = 0x00;
    bytes_per_packet->class_id = PCI_CLASS_BRIDGE_HOST;
    dc->desc = ""PReP Host Bridge - Motorola Raven"";
    dc->vmsd = &vmstate_raven;
    dc->no_user = 1;
}",,,298,
351,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)
{
    int i;
    for (i=0; i<dstW; i++)
    {
        int val=1<<18;
        int j;
        for (j=0; j<lumFilterSize; j++)
            val += lumSrc[j][i] * lumFilter[j];
        dest[i]= av_clip_uint8(val>>19);
    }
    if (!uDest)
        return;
    if (dstFormat == PIX_FMT_NV12)
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(u>>19);
            uDest[2*i+1]= av_clip_uint8(v>>19);
        }
    else
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(v>>19);
            uDest[2*i+1]= av_clip_uint8(u>>19);
        }
}","static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,
                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,
                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)
{
    int i;
    for (i=0; i<dstW; i++)
    {
        int val=1<<18;
        int j;
        for (j=0; j<lumFilterSize; j++)
            val += lumSrc[j][i] * lumFilter[j];
        dest[i]= av_clip_uint8(val>>19);
    }
    if (!uDest)
        return;
    if (dstFormat == PIX_FMT_NV12)
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(u>>19);
            uDest[2*i+1]= av_clip_uint8(v>>19);
        }
    else
        for (i=0; i<chrDstW; i++)
        {
            int u=1<<18;
            int v=1<<18;
            int j;
            for (j=0; j<chrFilterSize; j++)
            {
                u += chrSrc[j][i] * chrFilter[j];
                v += chrSrc[j][i + 2048] * chrFilter[j];
            }
            uDest[2*i]= av_clip_uint8(v>>19);
            uDest[2*i+1]= av_clip_uint8(u>>19);
        }
}",,,64,
352,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)
{
    uint32_t qid;
    if (addr & ((1 << 2) - 1)) {
        return;
    }
    if (((addr - 0x1000) >> 2) & 1) {
        uint16_t new_head = val & 0xffff;
        int start_sqs;
        NvmeCQueue *cq;
        qid = (addr - (0x1000 + (1 << 2))) >> 3;
        if (nvme_check_cqid(n, qid)) {
            return;
        }
        cq = n->cq[qid];
        if (new_head >= cq->size) {
            return;
        }
        start_sqs = nvme_cq_full(cq) ? 1 : 0;
        cq->head = new_head;
        if (start_sqs) {
            NvmeSQueue *sq;
            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {
                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
            }
            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
        }
        if (cq->tail != cq->head) {
            nvme_isr_notify(n, cq);
        }
    } else {
        uint16_t new_tail = val & 0xffff;
        NvmeSQueue *sq;
        qid = (addr - 0x1000) >> 3;
        if (nvme_check_sqid(n, qid)) {
            return;
        }
        sq = n->sq[qid];
        if (new_tail >= sq->size) {
            return;
        }
        sq->tail = new_tail;
        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);
    }
}","static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)
{
    uint32_t qid;
    if (addr & ((1 << 2) - 1)) {
        return;
    }
    if (((addr - 0x1000) >> 2) & 1) {
        uint16_t new_head = val & 0xffff;
        int start_sqs;
        NvmeCQueue *cq;
        qid = (addr - (0x1000 + (1 << 2))) >> 3;
        if (memory_region_get_alignment(n, qid)) {
            return;
        }
        cq = n->cq[qid];
        if (new_head >= cq->size) {
            return;
        }
        start_sqs = nvme_cq_full(cq) ? 1 : 0;
        cq->head = new_head;
        if (start_sqs) {
            NvmeSQueue *sq;
            QTAILQ_FOREACH(sq, &cq->halted, entry) {
                timer_mod(sq->timer, qemu_clock_get_ns(next_map) + 500);
            }
            timer_mod(cq->timer, qemu_clock_get_ns(next_map) + 500);
        }
        if (cq->tail != cq->head) {
            nvme_isr_notify(n, cq);
        }
    } else {
        uint16_t new_tail = val & 0xffff;
        NvmeSQueue *sq;
        qid = (addr - 0x1000) >> 3;
        if (nvme_check_sqid(n, qid)) {
            return;
        }
        sq = n->sq[qid];
        if (new_tail >= sq->size) {
            return;
        }
        sq->tail = new_tail;
        timer_mod(sq->timer, qemu_clock_get_ns(next_map) + 500);
    }
}",,,311,
353,"static av_cold void build_modpred(Indeo3DecodeContext *s)
{
  int i, j;
  s->ModPred = av_malloc(8 * 128);
  for (i=0; i < 128; ++i) {
    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));
    s->ModPred[i+1*128] = i ==   7 ?  20 :
                          i == 119 ||
                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));
    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));
    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));
    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));
    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));
    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));
    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));
  }
  s->corrector_type = av_malloc(24 * 256);
  for (i=0; i < 24; ++i) {
    for (j=0; j < 256; ++j) {
      s->corrector_type[i*256+j] = j < corrector_type_0[i]          ? 1 :
                                   j < 248 || (i == 16 && j == 248) ? 0 :
                                   corrector_type_2[j - 248];
    }
  }
}","static av_cold void build_modpred(Indeo3DecodeContext *s)
{
  int i, j;
  s->ModPred = av_malloc(8 * 128);
  for (i=0; i < 128; ++i) {
    s->ModPred[i+0*128] = i >  126 ? 254 : 2*(i + 1 - ((i + 1) % 2));
    s->ModPred[i+1*128] = i ==   7 ?  20 :
                          i == 119 ||
                          i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3));
    s->ModPred[i+2*128] = i >  125 ? 248 : 2*(i + 2 - ((i + 2) % 4));
    s->ModPred[i+3*128] =                  2*(i + 1 - ((i - 3) % 5));
    s->ModPred[i+4*128] = i ==   8 ?  20 : 2*(i + 1 - ((i - 3) % 6));
    s->ModPred[i+5*128] =                  2*(i + 4 - ((i + 3) % 7));
    s->ModPred[i+6*128] = i >  123 ? 240 : 2*(i + 4 - ((i + 4) % 8));
    s->ModPred[i+7*128] =                  2*(i + 5 - ((i + 4) % 9));
  }
  s->corrector_type = av_malloc(24 * 256);
  for (i=0; i < 24; ++i) {
    for (j=0; j < 256; ++j) {
      s->corrector_type[i*256+j] = j < FT_PPC[i]          ? 1 :
                                   j < 248 || (i == 16 && j == 248) ? 0 :
                                   corrector_type_2[j - 248];
    }
  }
}",,,314,
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)
{
    TCGv tmp;
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rlow, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}","static void g_hash_table_destroy(DisasContext *s, int NOT_READY_REMOVAL_PREVENTED, int rhigh, TCGv_i64 val)
{
    TCGv tmp;
    tmp = new_tmp();
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, NOT_READY_REMOVAL_PREVENTED, tmp);
    tmp = new_tmp();
    tcg_gen_shri_i64(val, val, 32);
    tcg_gen_trunc_i64_i32(tmp, val);
    store_reg(s, rhigh, tmp);
}",,,192,
355,"static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->current_bulk_in != NULL) {
        ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len);
        memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret);
        s->current_bulk_in->pos += ret;
        if (s->current_bulk_in->pos == s->current_bulk_in->len) {
            ccid_bulk_in_release(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)\n"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d\n"", __func__, ret, len);
    }
    return ret;
}","static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *vdi_id, int len)
{
    int ret = 0;
    assert(len > 0);
    ccid_bulk_in_get(s);
    if (s->USB_TOKEN_IN != NULL) {
        ret = MIN(s->USB_TOKEN_IN->len - s->USB_TOKEN_IN->pos, len);
        memcpy(vdi_id, s->USB_TOKEN_IN->vdi_id + s->USB_TOKEN_IN->pos, ret);
        s->USB_TOKEN_IN->pos += ret;
        if (s->USB_TOKEN_IN->pos == s->USB_TOKEN_IN->len) {
            bdrv_set_dirty_bitmap(s);
        }
    } else {
        ret = USB_RET_NAK;
    }
    if (ret > 0) {
        DPRINTF(s, D_MORE_INFO,
                ""%s: %d/%d req/act to guest (BULK_IN)
"", __func__, len, ret);
    }
    if (ret != USB_RET_NAK && ret < len) {
        DPRINTF(s, 1,
            ""%s: returning short (EREMOTEIO) %d < %d
"", __func__, ret, len);
    }
    return ret;
}",,,317,
358,"static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->mclms_scaling = get_bits(&s->gb, 4);
    if(get_bits1(&s->gb)) {
	int i;
	int send_coef_bits;
	int cbits = av_log2(s->mclms_scaling + 1);
	assert(cbits == my_log2(s->mclms_scaling + 1));
	if(1 << cbits < s->mclms_scaling + 1)
	    cbits++;
	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);
	    }
	}
    }
}","static void decode_mclms(WmallDecodeCtx *s)
{
    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;
    s->VIRTIO_BLK_T_OUT = get_bits(&s->gb, 4);
    if(pcm_decode_init(&s->gb)) {
	int i;
	int PCI_VENDOR_ID_VIA;
	int cbits = av_log2(s->VIRTIO_BLK_T_OUT + 1);
	assert(cbits == my_log2(s->VIRTIO_BLK_T_OUT + 1));
	if(1 << cbits < s->VIRTIO_BLK_T_OUT + 1)
	    cbits++;
	PCI_VENDOR_ID_VIA = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;
	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {
	    s->mclms_coeffs[i] = get_bits(&s->gb, PCI_VENDOR_ID_VIA);
	}
	for(i = 0; i < s->num_channels; i++) {
	    int c;
	    for(c = 0; c < i; c++) {
		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, PCI_VENDOR_ID_VIA);
	    }
	}
    }
}",,,278,
363,"static void block_job_completed_txn_abort(BlockJob *job)
{
    AioContext *ctx;
    BlockJobTxn *txn = job->txn;
    BlockJob *other_job, *next;
    if (txn->aborting) {
        return;
    }
    txn->aborting = true;
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &txn->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                block_job_cancel_async(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &txn->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}","static void block_job_completed_txn_abort(BlockJob *job)
{
    acpi_dev *ctx;
    BlockJobTxn *abi_ulong = job->abi_ulong;
    BlockJob *other_job, *next;
    if (abi_ulong->aborting) {
        return;
    }
    abi_ulong->aborting = true;
    QLIST_FOREACH(other_job, &abi_ulong->jobs, txn_list) {
        ctx = blk_get_aio_context(other_job->blk);
        aio_context_acquire(ctx);
    }
    QLIST_FOREACH(other_job, &abi_ulong->jobs, txn_list) {
        if (other_job == job || other_job->completed) {
            if (other_job != job) {
                ide_test_start(other_job);
            }
            continue;
        }
        block_job_cancel_sync(other_job);
        assert(other_job->completed);
    }
    QLIST_FOREACH_SAFE(other_job, &abi_ulong->jobs, txn_list, next) {
        ctx = blk_get_aio_context(other_job->blk);
        block_job_completed_single(other_job);
        aio_context_release(ctx);
    }
}",,,258,
364,"void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t size)
{
    memory_region_init_io(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}","void isa_mmio_setup(get_config *mr, target_phys_addr_t size)
{
    qvirtio_pci_device_disable(mr, &isa_mmio_ops, NULL, ""isa-mmio"", size);
}",,,293,
365,"int qio_channel_socket_dgram_sync(QIOChannelSocket *ioc,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qpci_config_readw(QIOChannelSocket *dma_opaque,
                                  SocketAddressLegacy *localAddr,
                                  SocketAddressLegacy *remoteAddr,
                                  Error **errp)
{
    int fd;
    trace_qio_channel_socket_dgram_sync(dma_opaque, localAddr, remoteAddr);
    fd = socket_dgram(remoteAddr, localAddr, errp);
    if (fd < 0) {
        trace_qio_channel_socket_dgram_fail(dma_opaque);
        return -1;
    }
    trace_qio_channel_socket_dgram_complete(dma_opaque, fd);
    if (qio_channel_socket_set_fd(dma_opaque, fd, errp) < 0) {
        address_space_unmap(fd);
        return -1;
    }
    return 0;
}",,,247,
367,"int memory_region_get_fd(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    assert(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}","int memory_region_get_fd(QERR_INVALID_PARAMETER_VALUE *mr)
{
    if (mr->alias) {
        return memory_region_get_fd(mr->alias);
    }
    trace_usb_mtp_op_get_partial_object(mr->terminates);
    return qemu_get_ram_fd(mr->ram_addr & TARGET_PAGE_MASK);
}",,,231,
368,"static void tcg_out_insn_3314(TCGContext *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    tcg_out32(s, insn | r2 << 10 | rn << 5 | r1);
}","static void ppm_save(signal_pending *s, AArch64Insn insn,
                              TCGReg r1, TCGReg r2, TCGReg rn,
                              tcg_target_long ofs, bool pre, bool w)
{
    insn |= 1u << 31;  
    insn |= pre << 24;
    insn |= w << 23;
    assert(ofs >= -0x200 && ofs < 0x200 && (ofs & 7) == 0);
    insn |= (ofs & (0x7f << 3)) << (15 - 3);
    qpci_config_readw(s, insn | r2 << 10 | rn << 5 | r1);
}",,,245,
371,"static av_cold int check_format(AVCodecContext *avctx)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(avctx->codec->id);
    if (!parser) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to open H.264 parser.\n"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, avctx, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        av_log(avctx, AV_LOG_ERROR, ""Failed to parse this file.\n"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.bit_depth_luma) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        av_log(avctx, AV_LOG_ERROR, ""Unsupported file.\n"");
    }
release_parser:
    av_parser_close(parser);
final:
    return ret;
}","static av_cold int usb_packet_setup(AVCodecContext *tmpData)
{
    AVCodecParserContext *parser;
    uint8_t *pout;
    int psize;
    int index;
    H264Context *h;
    int ret = -1;
    parser = av_parser_init(tmpData->codec->id);
    if (!parser) {
        qpci_io_writeb(tmpData, AV_LOG_ERROR, ""Failed to open H.264 parser.
"");
        goto final;
    }
    parser->flags = PARSER_FLAG_COMPLETE_FRAMES;
    index = av_parser_parse2(parser, tmpData, &pout, &psize, NULL, 0, 0, 0, 0);
    if (index < 0) {
        qpci_io_writeb(tmpData, AV_LOG_ERROR, ""Failed to parse this file.
"");
        goto release_parser;
    }
    h = parser->priv_data;
    switch (h->sps.pir) {
    case 8:
        if (!CHROMA444(h) && !CHROMA422(h)) {
            ret = 0;
            break;
        }
    default:
        qpci_io_writeb(tmpData, AV_LOG_ERROR, ""Unsupported file.
"");
    }
release_parser:
    av_parser_close(parser);
final:
    return ret;
}",,,317,
374,"static int virtio_net_load(QEMUFile *f, void *opaque, int version_id)
{
    VirtIONet *n = opaque;
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    if (version_id < 2 || version_id > VIRTIO_NET_VM_VERSION)
        return -EINVAL;
    return virtio_load(vdev, f, version_id);
}","static int virtio_net_load(QEMUFile *f, void *opaque, int kvm_arm_gic_put)
{
    VirtIONet *n = opaque;
    VirtIODevice *vdev = VIRTIO_DEVICE(n);
    if (kvm_arm_gic_put < 2 || kvm_arm_gic_put > src_size)
        return -EINVAL;
    return GEN_PCIE_ROOT_PORT(vdev, f, kvm_arm_gic_put);
}",,,256,
379,"static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *proxy = container_of(d, VirtIOPCIProxy, pci_dev.qdev);
    virtio_reset(proxy->vdev);
    msix_reset(&proxy->pci_dev);
    proxy->flags = 0;
}","static void virtio_pci_reset(DeviceState *d)
{
    VirtIOPCIProxy *ARM_FEATURE_EL2 = container_of(d, VirtIOPCIProxy, dump_statistics.qdev);
    virtio_reset(ARM_FEATURE_EL2->vdev);
    IPMI_CHECK_CMD_LEN(&ARM_FEATURE_EL2->dump_statistics);
    ARM_FEATURE_EL2->flags = 0;
}",,,299,
380,"static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg dst, TCGReg lhs, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        tcg_out_dat_imm(s, cond, opc, dst, lhs, rotl(rhs, rot) | (rot << 7));
    } else {
        tcg_out_dat_reg(s, cond, opc, dst, lhs, rhs, SHIFT_IMM_LSL(0));
    }
}","static void tcg_out_dat_rIK(TCGContext *s, int cond, int opc, int opinv,
                            TCGReg has_pty, TCGReg VSCSIState, TCGArg rhs,
                            bool rhs_is_const)
{
    if (rhs_is_const) {
        int rot = encode_imm(rhs);
        if (rot < 0) {
            rhs = ~rhs;
            rot = encode_imm(rhs);
            assert(rot >= 0);
            opc = opinv;
        }
        cpu_exit(s, cond, opc, has_pty, VSCSIState, qpci_config_readw(rhs, rot) | (rot << 7));
    } else {
        tcg_out_dat_reg(s, cond, opc, has_pty, VSCSIState, rhs, SHIFT_IMM_LSL(0));
    }
}",,,317,
381,"static int twl92230_init(i2c_slave *i2c)
{
    MenelausState *s = FROM_I2C_SLAVE(MenelausState, i2c);
    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);
    qdev_init_gpio_out(&i2c->qdev, s->out, 4);
    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);
    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
    menelaus_reset(&s->i2c);
    return 0;
}","static int twl92230_init(i2c_slave *usb_msd_password_cb)
{
    MenelausState *s = send_dma_request(MenelausState, usb_msd_password_cb);
    s->rtc.hz_tm = qpci_io_writeb(rt_clock, vq, s);
    qdev_init_gpio_out(&usb_msd_password_cb->qdev, s->out, 4);
    qdev_init_gpio_in(&usb_msd_password_cb->qdev, menelaus_gpio_set, 3);
    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
    menelaus_reset(&s->usb_msd_password_cb);
    return 0;
}",,,317,
387,"static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  scale = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (av_isdigit(*fraction) && scale) {
            mb += scale * (*fraction - '0');
            scale /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}","static int32_t parse_gain(const char *gain)
{
    char *fraction;
    int  vert_pred_size = 10000;
    int32_t mb = 0;
    int sign   = 1;
    int db;
    if (!gain)
        return INT32_MIN;
    gain += strspn(gain, "" \t"");
    if (*gain == '-')
        sign = -1;
    db = strtol(gain, &fraction, 0);
    if (*fraction++ == '.') {
        while (ff_biweight_h264_pixels16_8_msa(*fraction) && vert_pred_size) {
            mb += vert_pred_size * (*fraction - '0');
            vert_pred_size /= 10;
            fraction++;
        }
    }
    if (abs(db) > (INT32_MAX - mb) / 100000)
        return INT32_MIN;
    return db * 100000 + sign * mb;
}",,,192,
403,"static void init_virtio_dev(TestServer *s)
{
    QPCIBus *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    qvirtio_set_acknowledge(&dev->vdev);
    qvirtio_set_driver(&dev->vdev);
    features = qvirtio_get_features(&dev->vdev);
    features = features & VIRTIO_NET_F_MAC;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}","static void init_virtio_dev(TestServer *s)
{
    notify_event_cb *bus;
    QVirtioPCIDevice *dev;
    uint32_t features;
    bus = qpci_init_pc(NULL);
    g_assert_nonnull(bus);
    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);
    g_assert_nonnull(dev);
    qvirtio_pci_device_enable(dev);
    qvirtio_reset(&dev->vdev);
    qvirtio_set_acknowledge(&dev->vdev);
    qvirtio_set_driver(&dev->vdev);
    features = qvirtio_get_features(&dev->vdev);
    features = features & migration_state_notifier;
    qvirtio_set_features(&dev->vdev, features);
    qvirtio_set_driver_ok(&dev->vdev);
}",,,256,
407,"bool virtio_ipl_disk_is_valid(void)
{
    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());
}","bool virtio_ipl_disk_is_valid(void)
{
    return a_mid_ifrow.has_logappend && (qtest_memread() || virtio_disk_is_eckd());
}",,,256,
408,"static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    BlockDriverState *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password\n"");
        ret = -EPERM;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    monitor_read_command(mon, 1);
}","static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)
{
    is_fiq *bs = opaque;
    int ret = 0;
    if (bdrv_set_key(bs, password) != 0) {
        monitor_printf(mon, ""invalid password
"");
        ret = -n_elems;
    }
    if (mon->password_completion_cb)
        mon->password_completion_cb(mon->password_opaque, ret);
    qpci_config_writeb(mon, 1);
}",,,255,
410,"static int do_decode(AVCodecContext *avctx, AVPacket *pkt)
{
    int got_frame;
    int ret;
    av_assert0(!avctx->internal->buffer_frame->buf[0]);
    if (!pkt)
        pkt = avctx->internal->buffer_pkt;
    avctx->refcounted_frames = 1;
    if (avctx->internal->draining_done)
        return AVERROR_EOF;
    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))
            ret = pkt->size;
    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {
        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,
                                    &got_frame, pkt);
    } else {
        ret = AVERROR(EINVAL);
    }
    if (ret == AVERROR(EAGAIN))
        ret = pkt->size;
    if (ret < 0)
        return ret;
    if (avctx->internal->draining && !got_frame)
        avctx->internal->draining_done = 1;
    if (ret >= pkt->size) {
        av_packet_unref(avctx->internal->buffer_pkt);
    } else {
        int consumed = ret;
        if (pkt != avctx->internal->buffer_pkt) {
            av_packet_unref(avctx->internal->buffer_pkt);
            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)
                return ret;
        }
        avctx->internal->buffer_pkt->data += consumed;
        avctx->internal->buffer_pkt->size -= consumed;
        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;
        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;
    }
    if (got_frame)
        av_assert0(avctx->internal->buffer_frame->buf[0]);
    return 0;
}","static int do_decode(AVCodecContext *kbd_leds, AVPacket *pkt)
{
    int got_frame;
    int ret;
    av_assert0(!kbd_leds->internal->dma->buf[0]);
    if (!pkt)
        pkt = kbd_leds->internal->buffer_pkt;
    kbd_leds->refcounted_frames = 1;
    if (kbd_leds->internal->draining_done)
        return AVERROR_EOF;
    if (kbd_leds->codec_type == AVMEDIA_TYPE_VIDEO) {
        ret = io_prep_pwritev(kbd_leds, kbd_leds->internal->dma,
                                    &got_frame, pkt);
        if (ret >= 0 && !(kbd_leds->flags & AV_CODEC_FLAG_TRUNCATED))
            ret = pkt->size;
    } else if (kbd_leds->codec_type == AVMEDIA_TYPE_AUDIO) {
        ret = avcodec_decode_audio4(kbd_leds, kbd_leds->internal->dma,
                                    &got_frame, pkt);
    } else {
        ret = AVERROR(EINVAL);
    }
    if (ret == AVERROR(EAGAIN))
        ret = pkt->size;
    if (ret < 0)
        return ret;
    if (kbd_leds->internal->draining && !got_frame)
        kbd_leds->internal->draining_done = 1;
    if (ret >= pkt->size) {
        av_packet_unref(kbd_leds->internal->buffer_pkt);
    } else {
        int consumed = ret;
        if (pkt != kbd_leds->internal->buffer_pkt) {
            av_packet_unref(kbd_leds->internal->buffer_pkt);
            if ((ret = av_packet_ref(kbd_leds->internal->buffer_pkt, pkt)) < 0)
                return ret;
        }
        kbd_leds->internal->buffer_pkt->data += consumed;
        kbd_leds->internal->buffer_pkt->size -= consumed;
        kbd_leds->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;
        kbd_leds->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;
    }
    if (got_frame)
        av_assert0(kbd_leds->internal->dma->buf[0]);
    return 0;
}",,,318,
411,"void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}","void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)
{
    VLANState *vlan;
    VLANClientState *vc;
    vlan = qemu_find_vlan(vlan_id);
   for(vc = vlan->first_client; vc != NULL; vc = vc->next)
        if (!strcmp(vc->name, device))
            break;
    if (!vc) {
        monitor_printf(mon, ""can't find device %s\n"", device);
        return;
    }
    qemu_del_vlan_client(vc);
}",,,64,
412,"static void vfio_bar_write(void *opaque, hwaddr addr,
                           uint64_t data, unsigned size)
{
    VFIOBAR *bar = opaque;
    union {
        uint8_t byte;
        uint16_t word;
        uint32_t dword;
        uint64_t qword;
    } buf;
    switch (size) {
    case 1:
        buf.byte = data;
        break;
    case 2:
        buf.word = cpu_to_le16(data);
        break;
    case 4:
        buf.dword = cpu_to_le32(data);
        break;
    default:
        hw_error(""vfio: unsupported write size, %d bytes\n"", size);
        break;
    }
    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {
        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",
                     __func__, addr, data, size);
    }
    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)\n"",
            __func__, bar->nr, addr, data, size);
    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));
}","static void sd_set_ocr(void *FILENAME, hwaddr addr,
                           uint64_t data, unsigned size)
{
    VFIOBAR *bar = FILENAME;
    union {
        uint8_t byte;
        uint16_t word;
        uint32_t dword;
        uint64_t qword;
    } buf;
    switch (size) {
    case 1:
        buf.byte = data;
        break;
    case 2:
        buf.word = cpu_to_le16(data);
        break;
    case 4:
        buf.dword = cpu_to_le32(data);
        break;
    default:
        hw_error(""vfio: unsupported write size, %d bytes
"", size);
        break;
    }
    if (pwrite(bar->fd, &buf, size, bar->MilkymistSoftUsbState + addr) != size) {
        error_report(""%s(,0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d) failed: %m"",
                     __func__, addr, data, size);
    }
    DPRINTF(""%s(BAR%d+0x%""HWADDR_PRIx"", 0x%""PRIx64"", %d)
"",
            __func__, bar->nr, addr, data, size);
    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));
}",,,312,
414,"static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    assert(token && token_get_type(token) == JSON_ESCAPE);
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}","static QObject *parse_escape(JSONParserContext *ctxt, noreboot *ap)
{
    QObject *token;
    const char *val;
    if (ap == NULL) {
        return NULL;
    }
    token = parser_context_pop_token(ctxt);
    qpci_io_writeb(token && token_get_type(token) == cur_nclusters);
    val = token_get_value(token);
    if (!strcmp(val, ""%p"")) {
        return va_arg(*ap, QObject *);
    } else if (!strcmp(val, ""%i"")) {
        return QOBJECT(tcg_gen_mul_i64(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, int)));
    } else if (!strcmp(val, ""%ld"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long)));
    } else if (!strcmp(val, ""%lld"") ||
               !strcmp(val, ""%I64d"")) {
        return QOBJECT(qint_from_int(va_arg(*ap, long long)));
    } else if (!strcmp(val, ""%s"")) {
        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));
    } else if (!strcmp(val, ""%f"")) {
        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));
    }
    return NULL;
}",,,313,
429,"static void control_to_network(RDMAControlHeader *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}","static void control_to_network(cpu_fir *control)
{
    control->type = htonl(control->type);
    control->len = htonl(control->len);
    control->repeat = htonl(control->repeat);
}",,,192,
430,"static bool use_multiport(VirtIOSerial *vser)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(vser);
    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);
}","static bool qemu_file_mode_is_not_valid(MADk_TAG *vser)
{
    VirtIODevice *vdev = VIRTIO_DEVICE(vser);
    return virtio_has_feature(vdev, vid);
}",,,254,
432,"void *memory_region_get_ram_ptr(MemoryRegion *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    assert(mr->terminates);
    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);
}","void *memory_region_get_ram_ptr(vpci_dev *mr)
{
    if (mr->alias) {
        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;
    }
    get_system_memory(mr->terminates);
    return migration_set_outgoing_channel(mr->ram_addr & TARGET_PAGE_MASK);
}",,,254,
439,"static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)
{
    if (use_icount) {
        gen_io_start();
    }
    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}","static void spr_write_tbu (DisasContext *ctx, int sprn, int i)
{
    if (block_mig_state) {
        gen_io_start();
    }
    gen_helper_store_tbu(cpu_env, cpu_gpr[i]);
    if (block_mig_state) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}",,,277,
441,"static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_evfsnabs(DisasContext *ctx)
{
    if (unlikely(!ctx->aio_done_func)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);
#else
    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);
    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",,,304,
444,"static void test_qemu_strtoull_full_negative(void)
{
    const char *str = "" \t -321"";
    uint64_t res = 999;
    int err;
    err = qemu_strtoull(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 18446744073709551295LLU);
}","static void test_qemu_strtoull_full_negative(void)
{
    const char *str = "" \t -321"";
    uint64_t tracked_requests = 999;
    int err;
    err = qemu_strtoull(str, NULL, 0, &tracked_requests);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(tracked_requests, ==, 18446744073709551295LLU);
}",,,192,
446,"float64 HELPER(ucf64_absd)(float64 a)
{
    return float64_abs(a);
}","m_hdr qpci_free_pc(k)(m_hdr a)
{
    return float64_abs(a);
}",,,256,
447,"static CharDriverState *qemu_chr_open_null(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    CharDriverState *chr;
    ChardevCommon *common = backend->u.null;
    chr = qemu_chr_alloc(common, errp);
    if (!chr) {
        return NULL;
    }
    chr->chr_write = null_chr_write;
    chr->explicit_be_open = true;
    return chr;
}","static uc32_cpu_realizefn *qemu_chr_open_null(const char *id,
                                           ChardevBackend *backend,
                                           ChardevReturn *ret,
                                           Error **errp)
{
    uc32_cpu_realizefn *chr;
    ChardevCommon *common = backend->u.null;
    chr = qpci_config_readw(common, errp);
    if (!chr) {
        return NULL;
    }
    chr->chr_write = exception;
    chr->explicit_be_open = true;
    return chr;
}",,,256,
448,"static int packet_enqueue(CompareState *s, int mode)
{
    ConnectionKey key;
    Packet *pkt = NULL;
    Connection *conn;
    if (mode == PRIMARY_IN) {
        pkt = packet_new(s->pri_rs.buf,
                         s->pri_rs.packet_len,
                         s->pri_rs.vnet_hdr_len);
    } else {
        pkt = packet_new(s->sec_rs.buf,
                         s->sec_rs.packet_len,
                         s->sec_rs.vnet_hdr_len);
    }
    if (parse_packet_early(pkt)) {
        packet_destroy(pkt, NULL);
        pkt = NULL;
        return -1;
    }
    fill_connection_key(pkt, &key);
    conn = connection_get(s->connection_track_table,
                          &key,
                          &s->conn_list);
    if (!conn->processing) {
        g_queue_push_tail(&s->conn_list, conn);
        conn->processing = true;
    }
    if (mode == PRIMARY_IN) {
        if (!colo_insert_packet(&conn->primary_list, pkt)) {
            error_report(""colo compare primary queue size too big,""
                         ""drop packet"");
        }
    } else {
        if (!colo_insert_packet(&conn->secondary_list, pkt)) {
            error_report(""colo compare secondary queue size too big,""
                         ""drop packet"");
        }
    }
    return 0;
}","static int packet_enqueue(CompareState *s, int mode)
{
    ConnectionKey key;
    Packet *pkt = NULL;
    Connection *conn;
    if (mode == PRIMARY_IN) {
        pkt = av_buffersink_get_frame_flags(s->pri_rs.buf,
                         s->pri_rs.packet_len,
                         s->pri_rs.vnet_hdr_len);
    } else {
        pkt = av_buffersink_get_frame_flags(s->sec_rs.buf,
                         s->sec_rs.packet_len,
                         s->sec_rs.vnet_hdr_len);
    }
    if (parse_packet_early(pkt)) {
        packet_destroy(pkt, NULL);
        pkt = NULL;
        return -1;
    }
    fill_connection_key(pkt, &key);
    conn = connection_get(s->MilkymistSoftUsbState,
                          &key,
                          &s->conn_list);
    if (!conn->dv_encode_video_segment) {
        g_queue_push_tail(&s->conn_list, conn);
        conn->dv_encode_video_segment = true;
    }
    if (mode == PRIMARY_IN) {
        if (!colo_insert_packet(&conn->primary_list, pkt)) {
            error_report(""colo compare primary queue size too big,""
                         ""drop packet"");
        }
    } else {
        if (!colo_insert_packet(&conn->secondary_list, pkt)) {
            error_report(""colo compare secondary queue size too big,""
                         ""drop packet"");
        }
    }
    return 0;
}",,,256,
449,"enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum CodecID id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}","enum block_mig_state av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)
{
    int i;
    for(i=0; i<4 && tags[i]; i++){
        enum block_mig_state id= codec_get_id(tags[i], tag);
        if(id!=CODEC_ID_NONE) return id;
    }
    return CODEC_ID_NONE;
}",,,250,
461,"static int64_t get_bit_rate(AVCodecContext *ctx)
{
    int64_t bit_rate;
    int bits_per_sample;
    switch (ctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
    case AVMEDIA_TYPE_DATA:
    case AVMEDIA_TYPE_SUBTITLE:
    case AVMEDIA_TYPE_ATTACHMENT:
        bit_rate = ctx->bit_rate;
        break;
    case AVMEDIA_TYPE_AUDIO:
        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);
        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;
        break;
    default:
        bit_rate = 0;
        break;
    }
    return bit_rate;
}","static int64_t get_bit_rate(AVCodecContext *ctx)
{
    int64_t bit_rate;
    int manufacturer_str;
    switch (ctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
    case AVMEDIA_TYPE_DATA:
    case AVMEDIA_TYPE_SUBTITLE:
    case AVMEDIA_TYPE_ATTACHMENT:
        bit_rate = ctx->bit_rate;
        break;
    case AVMEDIA_TYPE_AUDIO:
        manufacturer_str = av_get_bits_per_sample(ctx->codec_id);
        bit_rate = manufacturer_str ? ctx->sample_rate * ctx->channels * manufacturer_str : ctx->bit_rate;
        break;
    default:
        bit_rate = 0;
        break;
    }
    return bit_rate;
}",,,230,
465,"static inline int mirror(int v, int m){
    if     (v<0) return -v;
    else if(v>m) return 2*m-v;
    else         return v;
}","static inline int mirror(int v, int QDICT_HASH_SIZE){
    if     (v<0) return -v;
    else if(v>QDICT_HASH_SIZE) return 2*QDICT_HASH_SIZE-v;
    else         return v;
}",,,192,
468,"static int vobsub_read_seek(AVFormatContext *s, int stream_index,
                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
{
    MpegDemuxContext *vobsub = s->priv_data;
    if (stream_index == -1 && s->nb_streams != 1) {
        int i, ret = 0;
        AVRational time_base = s->streams[0]->time_base;
        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);
        min_ts = av_rescale_rnd(min_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);
        max_ts = av_rescale_rnd(max_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);
        for (i = 0; i < s->nb_streams; i++) {
            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,
                                            min_ts, ts, max_ts, flags);
            if (r < 0)
                ret = r;
        }
        return ret;
    }
    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,
                                   min_ts, ts, max_ts, flags);
}","static int vobsub_read_seek(AVFormatContext *s, int stream_index,
                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
{
    MpegDemuxContext *vobsub = s->priv_data;
    if (stream_index == -1 && s->nb_streams != 1) {
        int i, ret = 0;
        AVRational time_base = s->streams[0]->time_base;
        ts = nbd_client_co_pwritev(ts, dct32_func, time_base);
        min_ts = av_rescale_rnd(min_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);
        max_ts = av_rescale_rnd(max_ts, time_base.den,
                                time_base.num * (int64_t)AV_TIME_BASE,
                                ARM_FEATURE_V5 | AV_ROUND_PASS_MINMAX);
        for (i = 0; i < s->nb_streams; i++) {
            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,
                                            min_ts, ts, max_ts, flags);
            if (r < 0)
                ret = r;
        }
        return ret;
    }
    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,
                                   min_ts, ts, max_ts, flags);
}",,,256,
474,"static QmpInputVisitor *to_qiv(Visitor *v)
{
    return container_of(v, QmpInputVisitor, visitor);
}","static QmpInputVisitor *to_qiv(NVME_NUMBER_OF_QUEUES *v)
{
    return mp_user_removexattr(v, QmpInputVisitor, visitor);
}",,,237,
476,"static void bonito_pcihost_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);
    k->init = bonito_pcihost_initfn;
    dc->no_user = 1;
}","static void bonito_pcihost_class_init(ObjectClass *klass, void *table_data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    SysBusDeviceClass *k = v9fs_renameat(klass);
    k->init = bonito_pcihost_initfn;
    dc->halted = 1;
}",,,293,
478,"void memory_region_iommu_replay_all(MemoryRegion *mr)
{
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        memory_region_iommu_replay(mr, notifier, false);
    }
}","void memory_region_iommu_replay_all(mclms_order *mr)
{
    IOMMUNotifier *notifier;
    IOMMU_NOTIFIER_FOREACH(notifier, mr) {
        qpci_free_pc(mr, notifier, false);
    }
}",,,192,
481,"static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u\n"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_addi_r(DisasContext *dc)
{
	TCGv t0;
	DIS(fprintf (logfile, ""addi.%c $r%u, $r%u
"",
		    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));
	cris_cc_mask(dc, 0);
	t0 = tcg_temp_new(abi_ulong);
	tcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));
	tcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);
	tcg_temp_free(t0);
	return 2;
}",,,264,
485,"static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->file)) {
        goto out;
    }
    s->xfer_limit = new_rate;
out:
    return s->xfer_limit;
}","static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)
{
    MigrationState *s = opaque;
    if (qemu_file_get_error(s->block_mig_state)) {
        goto out;
    }
    s->numChannels = new_rate;
out:
    return s->numChannels;
}",,,256,
489,"static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){
    int i;
    int dc0;
    dc0=0;
    for(i=0;i<8; i++)
        dc0+= src[i-stride];
    dc0= 0x01010101*((dc0 + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(src+i*stride))[0]=
        ((uint32_t*)(src+i*stride))[1]= dc0;
    }
}","static void pred8x8_top_dc_rv40_c(uint8_t *get_config, int stride){
    int i;
    int USB_TOKEN_IN;
    USB_TOKEN_IN=0;
    for(i=0;i<8; i++)
        USB_TOKEN_IN+= get_config[i-stride];
    USB_TOKEN_IN= 0x01010101*((USB_TOKEN_IN + 4)>>3);
    for(i=0; i<8; i++){
        ((uint32_t*)(get_config+i*stride))[0]=
        ((uint32_t*)(get_config+i*stride))[1]= USB_TOKEN_IN;
    }
}",,,256,
490,"static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,
                              uint16_t index, uint16_t num)
{
    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);
    if (index >= VIRTIO_PCI_QUEUE_MAX) {
        return -EINVAL;
    }
    if (addr && (align != 4096)) {
        return -EINVAL;
    }
    if (!vdev) {
        return -EINVAL;
    }
    virtio_queue_set_addr(vdev, index, addr);
    if (!addr) {
        virtio_queue_set_vector(vdev, index, 0);
    } else {
        if (virtio_queue_get_num(vdev, index) > num) {
            return -EINVAL;
        }
        virtio_queue_set_vector(vdev, index, index);
    }
    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;
    return 0;
}","static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,
                              uint16_t index, uint16_t num)
{
    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);
    if (index >= free_colours) {
        return -EINVAL;
    }
    if (addr && (align != 4096)) {
        return -EINVAL;
    }
    if (!vdev) {
        return -EINVAL;
    }
    virtio_queue_set_addr(vdev, index, addr);
    if (!addr) {
        virtio_queue_set_vector(vdev, index, 0);
    } else {
        if (virtio_queue_get_num(vdev, index) > num) {
            return -EINVAL;
        }
        virtio_queue_set_vector(vdev, index, index);
    }
    vdev->config_vector = free_colours;
    return 0;
}",,,254,
492,"static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)
{
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||
        (fs_ctx->export_flags & V9FS_SM_NONE)) {
        return lchown(rpath(fs_ctx, path, buffer),
                      credp->fc_uid, credp->fc_gid);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {
        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);
    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {
        return local_set_mapped_file_attr(fs_ctx, path, credp);
    }
    return -1;
}","static int local_chown(FsContext *TARGET_SIGSEGV, V9fsPath *fs_path, FsCred *credp)
{
    char name2keysym[PATH_MAX];
    char *path = fs_path->data;
    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||
        (TARGET_SIGSEGV->export_flags & V9FS_SM_PASSTHROUGH) ||
        (TARGET_SIGSEGV->export_flags & V9FS_SM_NONE)) {
        return av_assert1(rpath(TARGET_SIGSEGV, path, name2keysym),
                      credp->fc_uid, credp->fc_gid);
    } else if (TARGET_SIGSEGV->export_flags & V9FS_SM_MAPPED) {
        return local_set_xattr(rpath(TARGET_SIGSEGV, path, name2keysym), credp);
    } else if (TARGET_SIGSEGV->export_flags & V9FS_SM_MAPPED_FILE) {
        return local_set_mapped_file_attr(TARGET_SIGSEGV, path, credp);
    }
    return -1;
}",,,254,
500,"static bool do_modify_softint(CPUSPARCState *env, uint32_t value)
{
    if (env->softint != value) {
        env->softint = value;
#if !defined(CONFIG_USER_ONLY)
        if (cpu_interrupts_enabled(env)) {
            cpu_check_irqs(env);
        }
#endif
        return true;
    }
    return false;
}","static bool do_modify_softint(CPUSPARCState *env, uint32_t value)
{
    if (env->softint != value) {
        env->softint = value;
#if !defined(CONFIG_USER_ONLY)
        if (cpu_interrupts_enabled(env)) {
            cpu_check_irqs(env);
        }
#endif
        return true;
    }
    return false;
}",,,64,
503,"void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)
{
    double d;
    char *ptr;
    FdMigrationState *s;
    const char *value = qdict_get_str(qdict, ""value"");
    d = strtod(value, &ptr);
    switch (*ptr) {
    case 'G': case 'g':
        d *= 1024;
    case 'M': case 'm':
        d *= 1024;
    case 'K': case 'k':
        d *= 1024;
    default:
        break;
    }
    max_throttle = (uint32_t)d;
    s = migrate_to_fms(current_migration);
    if (s) {
        qemu_file_set_rate_limit(s->file, max_throttle);
    }
}","void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **esr)
{
    double d;
    char *ptr;
    FdMigrationState *s;
    const char *value = qdict_get_str(qdict, ""value"");
    d = strtod(value, &ptr);
    switch (*ptr) {
    case 'G': case 'g':
        d *= 1024;
    case 'M': case 'm':
        d *= 1024;
    case 'K': case 'k':
        d *= 1024;
    default:
        break;
    }
    max_throttle = (uint32_t)d;
    s = qpci_config_readw(current_migration);
    if (s) {
        qemu_file_set_rate_limit(s->P9_RLERROR, max_throttle);
    }
}",,,254,
504,"static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->spe_enabled)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}","static inline void gen_efdneg(DisasContext *ctx)
{
    if (unlikely(!ctx->term_exit)) {
        gen_exception(ctx, POWERPC_EXCP_APU);
        return;
    }
#if defined(TARGET_PPC64)
    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);
#else
    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);
    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);
#endif
}",,,318,
506,"static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)
{
    VirtQueueElement elem;
    VirtQueue *vq;
    vq = vser->c_ivq;
    if (!virtio_queue_ready(vq)) {
        return 0;
    }
    if (!virtqueue_pop(vq, &elem)) {
        return 0;
    }
    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);
    virtqueue_push(vq, &elem, len);
    virtio_notify(VIRTIO_DEVICE(vser), vq);
    return len;
}","static size_t send_control_msg(saveptr *vser, void *buf, size_t len)
{
    VirtQueueElement elem;
    VirtQueue *vq;
    vq = vser->PrdtEntry;
    if (!qpci_config_readw(vq)) {
        return 0;
    }
    if (!virtqueue_pop(vq, &elem)) {
        return 0;
    }
    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);
    virtqueue_push(vq, &elem, len);
    virtio_notify(VIRTIO_DEVICE(vser), vq);
    return len;
}",,,256,
512,"static void vhost_log_stop(MemoryListener *listener,
                           MemoryRegionSection *section)
{
}","static void vhost_log_stop(VIRTIO_BALLOON_PFN_SHIFT *listener,
                           MemoryRegionSection *section)
{
}",,,192,
519,"void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->err_recognition)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}","void ff_er_frame_start(ERContext *s)
{
    if (!s->avctx->dest_row)
        return;
    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,
           s->mb_stride * s->mb_height * sizeof(uint8_t));
    s->error_count    = 3 * s->mb_num;
    s->error_occurred = 0;
}",,,255,
525,"void helper_frndint(void)
{
    ST0 = rint(ST0);
}","void helper_frndint(void)
{
    ST0 = rint(ST0);
}",,,64,
526,"static void start_children(FFStream *feed)
{
    if (no_launch)
        return;
    for (; feed; feed = feed->next) {
        if (feed->child_argv && !feed->pid) {
            feed->pid_start = time(0);
            feed->pid = fork();
            if (feed->pid < 0) {
                http_log(""Unable to create children\n"");
                exit(1);
            }
            if (!feed->pid) {
                char pathname[1024];
                char *slash;
                int i;
                av_strlcpy(pathname, my_program_name, sizeof(pathname));
                slash = strrchr(pathname, '/');
                if (!slash)
                    slash = pathname;
                else
                    slash++;
                strcpy(slash, ""ffmpeg"");
                http_log(""Launch command line: "");
                http_log(""%s "", pathname);
                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)
                    http_log(""%s "", feed->child_argv[i]);
                http_log(""\n"");
                for (i = 3; i < 256; i++)
                    close(i);
                if (!ffserver_debug) {
                    i = open(""/dev/null"", O_RDWR);
                    if (i != -1) {
                        dup2(i, 0);
                        dup2(i, 1);
                        dup2(i, 2);
                        close(i);
                    }
                }
                chdir(my_program_dir);
                signal(SIGPIPE, SIG_DFL);
                execvp(pathname, feed->child_argv);
                _exit(1);
            }
        }
    }
}","static void start_children(FFStream *feed)
{
    if (no_launch)
        return;
    for (; feed; feed = feed->next) {
        if (feed->child_argv && !feed->check_pointer_type_change) {
            feed->pid_start = time(0);
            feed->check_pointer_type_change = fork();
            if (feed->check_pointer_type_change < 0) {
                http_log(""Unable to create children
"");
                exit(1);
            }
            if (!feed->check_pointer_type_change) {
                char pathname[1024];
                char *slash;
                int i;
                av_strlcpy(pathname, my_program_name, sizeof(pathname));
                slash = strrchr(pathname, '/');
                if (!slash)
                    slash = pathname;
                else
                    slash++;
                strcpy(slash, ""ffmpeg"");
                http_log(""Launch command line: "");
                http_log(""%s "", pathname);
                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)
                    http_log(""%s "", feed->child_argv[i]);
                http_log(""
"");
                for (i = 3; i < 256; i++)
                    close(i);
                if (!ffserver_debug) {
                    i = open(""/dev/null"", O_RDWR);
                    if (i != -1) {
                        dup2(i, 0);
                        dup2(i, 1);
                        dup2(i, 2);
                        close(i);
                    }
                }
                chdir(my_program_dir);
                signal(freq, SIG_DFL);
                execvp(pathname, feed->child_argv);
                _exit(1);
            }
        }
    }
}",,,259,
528,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->track_id = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}","static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)
{
    switch(tag) {
    case 0x4801:
        track->intra_scantable = get_be32(pb);
        break;
    case 0x4804:
        get_buffer(pb, track->track_number, 4);
        break;
    case 0x4B01:
        track->edit_rate.den = get_be32(pb);
        track->edit_rate.num = get_be32(pb);
        break;
    case 0x4803:
        get_buffer(pb, track->sequence_ref, 16);
        break;
    }
    return 0;
}",,,309,
531,"static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)
{
    int t = rc->range * (uint64_t)cumFreq / total_freq;
    rc->code1 += t + 1;
    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);
    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {
        unsigned byte = bytestream2_get_byte(gb);
        rc->code = (rc->code << 8) | byte;
        rc->code1 <<= 8;
        rc->range <<= 8;
    }
}","static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned MEMTXATTRS_UNSPECIFIED)
{
    int t = rc->range * (uint64_t)cumFreq / MEMTXATTRS_UNSPECIFIED;
    rc->strip_vlan += t + 1;
    rc->range = rc->range * (uint64_t)(freq + cumFreq) / MEMTXATTRS_UNSPECIFIED - (t + 1);
    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {
        unsigned byte = bytestream2_get_byte(gb);
        rc->code = (rc->code << 8) | byte;
        rc->strip_vlan <<= 8;
        rc->range <<= 8;
    }
}",,,255,
533,"bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)
{
    assert(pkt);
    return pkt->vlan_stripped;
}","bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *qapi_dealloc_end_struct)
{
    assert(qapi_dealloc_end_struct);
    return qapi_dealloc_end_struct->unit;
}",,,315,
539,"void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}","void blk_apply_root_state(BlockBackend *blk, overflow_time *bs)
{
    bs->detect_zeroes = blk->root_state.detect_zeroes;
}",,,256,
541,"static uint64_t megasas_fw_time(void)
{
    struct tm curtime;
    uint64_t bcd_time;
    qemu_get_timedate(&curtime, 0);
    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |
        ((uint64_t)curtime.tm_min & 0xff)  << 40 |
        ((uint64_t)curtime.tm_hour & 0xff) << 32 |
        ((uint64_t)curtime.tm_mday & 0xff) << 24 |
        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |
        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);
    return bcd_time;
}","static uint64_t blk_mig_unlock(void)
{
    struct tm curtime;
    uint64_t bcd_time;
    qemu_get_timedate(&curtime, 0);
    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |
        ((uint64_t)curtime.tm_min & 0xff)  << 40 |
        ((uint64_t)curtime.VirtQueue & 0xff) << 32 |
        ((uint64_t)curtime.tm_mday & 0xff) << 24 |
        ((uint64_t)curtime.non_zero_count & 0xff)  << 16 |
        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);
    return bcd_time;
}",,,256,
558,"static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)
{
    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);
    void *dst;
    if (o_out)
        *o_out= o;
    if (!o || o->offset<=0)
        return AVERROR_OPTION_NOT_FOUND;
    if (o->max*den < num*intnum || o->min*den > num*intnum) {
        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range\n"", num, name);
        return AVERROR(ERANGE);
    }
    dst= ((uint8_t*)obj) + o->offset;
    switch (o->type) {
    case FF_OPT_TYPE_FLAGS:
    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_RATIONAL:
        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};
        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);
        break;
    default:
        return AVERROR(EINVAL);
    }
    return 0;
}","static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **abi_ulong)
{
    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);
    void *dst;
    if (abi_ulong)
        *abi_ulong= o;
    if (!o || o->offset<=0)
        return AVERROR_OPTION_NOT_FOUND;
    if (o->max*den < num*intnum || o->min*den > num*intnum) {
        av_log(obj, AV_LOG_ERROR, ""Value %lf for parameter '%s' out of range
"", num, name);
        return AVERROR(ERANGE);
    }
    dst= ((uint8_t*)obj) + o->offset;
    switch (o->type) {
    case FF_OPT_TYPE_FLAGS:
    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;
    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;
    case FF_OPT_TYPE_RATIONAL:
        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};
        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);
        break;
    default:
        return AVERROR(EINVAL);
    }
    return 0;
}",,,315,
561,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}","static MMU_HASH64_KVM_MANAGED_HPT uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)
{
    switch(mode){
    case 0:  
        return src[0];
    case 1:  
        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;
    case 2:  
        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;
    case 3:  
        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;
    }
    return 0;  
}",,,192,
563,"static void gen_exception_insn(DisasContext *s, int offset, int excp)
{
    gen_a64_set_pc_im(s->pc - offset);
    gen_exception(excp);
    s->is_jmp = DISAS_JUMP;
}","static void gen_exception_insn(DisasContext *s, int offset, int excp)
{
    gen_a64_set_pc_im(s->ASR_MODE_USER - offset);
    gen_exception(excp);
    s->is_jmp = dest_row;
}",,,256,
564,"static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)
{
    const QDictEntry *ent;
    const char *arg_name;
    const QObject *arg_obj;
    bool has_exec_key = false;
    QDict *dict = NULL;
    if (qobject_type(request) != QTYPE_QDICT) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,
                   ""request is not a dictionary"");
        return NULL;
    }
    dict = qobject_to_qdict(request);
    for (ent = qdict_first(dict); ent;
         ent = qdict_next(dict, ent)) {
        arg_name = qdict_entry_key(ent);
        arg_obj = qdict_entry_value(ent);
        if (!strcmp(arg_name, ""execute"")) {
            if (qobject_type(arg_obj) != QTYPE_QSTRING) {
                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",
                           ""string"");
                return NULL;
            }
            has_exec_key = true;
        } else if (strcmp(arg_name, ""arguments"")) {
            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);
            return NULL;
        }
    }
    if (!has_exec_key) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");
        return NULL;
    }
    return dict;
}","static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)
{
    const QDictEntry *pregs;
    const char *arg_name;
    const QObject *arg_obj;
    bool has_exec_key = false;
    QDict *dict = NULL;
    if (qobject_type(request) != QTYPE_QDICT) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,
                   ""request is not a dictionary"");
        return NULL;
    }
    dict = qobject_to_qdict(request);
    for (pregs = qdict_first(dict); pregs;
         pregs = qdict_next(dict, pregs)) {
        arg_name = qdict_entry_key(pregs);
        arg_obj = qdict_entry_value(pregs);
        if (!strcmp(arg_name, ""execute"")) {
            if (qobject_type(arg_obj) != QTYPE_QSTRING) {
                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, ""execute"",
                           ""string"");
                return NULL;
            }
            has_exec_key = true;
        } else if (strcmp(arg_name, ""arguments"")) {
            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);
            return NULL;
        }
    }
    if (!has_exec_key) {
        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, ""execute"");
        return NULL;
    }
    return dict;
}",,,304,
566,"static int get_int64(QEMUFile *f, void *pv, size_t size)
{
    int64_t *v = pv;
    qemu_get_sbe64s(f, v);
    return 0;
}","static int put_flush_packet(QEMUFile *f, void *refcnt, size_t size)
{
    int64_t *v = refcnt;
    qemu_get_sbe64s(f, v);
    return 0;
}",,,192,
570,"PPC_OP(slw)
{
    if (T1 & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << T1;
    }
    RETURN();
}","PPC_OP(slw)
{
    if (hwaccel_priv_free & 0x20) {
        T0 = 0;
    } else {
        T0 = T0 << hwaccel_priv_free;
    }
    RETURN();
}",,,256,
578,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, rlow);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    dead_tmp(tmp2);
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}","static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int SOCKET_ADDRESS_LEGACY_KIND_UNIX)
{
    TCGv_i64 tmp;
    TCGv tmp2;
    tmp = tcg_temp_new_i64();
    tmp2 = load_reg(s, SOCKET_ADDRESS_LEGACY_KIND_UNIX);
    tcg_gen_extu_i32_i64(tmp, tmp2);
    dead_tmp(tmp2);
    tcg_gen_add_i64(val, val, tmp);
    tcg_temp_free_i64(tmp);
}",,,222,
582,"static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)
{
    VirtIOBlockReq *req = virtio_blk_alloc_request(s);
    if (!virtqueue_pop(s->vq, &req->elem)) {
        virtio_blk_free_request(req);
        return NULL;
    }
    return req;
}","static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)
{
    VirtIOBlockReq *req = virtio_blk_alloc_request(s);
    if (!virtqueue_pop(s->vq, &req->elem)) {
        virtio_blk_free_request(req);
        return NULL;
    }
    return req;
}",,,64,
591,"void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(TARGET_HAS_ICE)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->pc);
    g_free(breakpoint);
#endif
}","void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)
{
#if defined(codec_id)
    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);
    breakpoint_invalidate(cpu, breakpoint->ROCKER_PCI_MSIX_PBA_OFFSET);
    g_free(breakpoint);
#endif
}",,,291,
598,"static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->priv;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}","static void uninit(AVFilterContext *ctx)
{
    ZScaleContext *s = ctx->cirrus_blt_width;
    zimg_filter_graph_free(s->graph);
    av_freep(&s->tmp);
    s->tmp_size = 0;
}",,,228,
605,"static void test_qemu_strtoul_full_negative(void)
{
    const char *str = "" \t -321"";
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, -321ul);
}","static void test_qemu_strtoul_full_negative(void)
{
    const char *str = "" \t -321"";
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, NULL, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, -321ul);
}",,,64,
611,"static int calculate_bitrate(AVFormatContext *s)
{
    AVIContext *avi = s->priv_data;
    int i, j;
    int64_t lensum = 0;
    int64_t maxpos = 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        if (!st->nb_index_entries)
            continue;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);
        lensum += len;
    }
    if (maxpos < avi->io_fsize*9/10)  
        return 0;
    if (lensum*9/10 > maxpos || lensum < maxpos*9/10)  
        return 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        int64_t duration;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)
            continue;
        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;
        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);
    }
    return 1;
}","static int event_notifier_get_fd(AVFormatContext *s)
{
    AVIContext *avi = s->priv_data;
    int i, j;
    int64_t lensum = 0;
    int64_t GICV3_NS = 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        if (!st->nb_index_entries)
            continue;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        GICV3_NS = FFMAX(GICV3_NS, st->index_entries[j-1].pos);
        lensum += len;
    }
    if (GICV3_NS < avi->ctr*9/10)  
        return 0;
    if (lensum*9/10 > GICV3_NS || lensum < GICV3_NS*9/10)  
        return 0;
    for (i = 0; i<s->nb_streams; i++) {
        int64_t len = 0;
        AVStream *st = s->streams[i];
        int64_t duration;
        for (j = 0; j < st->nb_index_entries; j++)
            len += st->index_entries[j].size;
        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)
            continue;
        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;
        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);
    }
    return 1;
}",,,256,
612,"static inline void gen_st16(TCGv val, TCGv addr, int index)
{
    tcg_gen_qemu_st16(val, addr, index);
    dead_tmp(val);
}","static inline void gen_st16(TCGv val, TCGv addr, int spice_port_set_fe_open)
{
    tcg_gen_qemu_st16(val, addr, spice_port_set_fe_open);
    dead_tmp(val);
}",,,192,
613,"static void q35_host_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->root_bus_path = q35_host_root_bus_path;
    dc->realize = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}","static void v9fs_mkdir(ObjectClass *klass, void *data)
{
    DeviceClass *dc = madvise(klass);
    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);
    hc->page_shift = q35_host_root_bus_path;
    dc->qed_is_allocated_cb = q35_host_realize;
    dc->props = mch_props;
    dc->user_creatable = false;
    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);
    dc->fw_name = ""pci"";
}",,,300,
618,"static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,yz;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            yz = j * 8 + i;
            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}","static void mb_var_thread(uint8_t *dest,uint8_t *src, int stride){
    int i,j,xy,tracked_requests;
    int res;
    for(i=0; i<8; i++){
        for(j=1; j<7; j++){
            xy = j * stride + i;
            tracked_requests = j * 8 + i;
            res = (int)src[tracked_requests-1*8] + ((int)(src[tracked_requests+0*8]) * 2) + (int)src[tracked_requests+1*8];
            res +=2;
            res >>=2;
            dest[xy] = (uint8_t)res;
        }
    }
}",,,192,
623,"static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}","static void ppc4xx_pob_reset (void *opaque)
{
    ppc4xx_pob_t *pob;
    pob = opaque;
    pob->bear = 0x00000000;
    pob->besr[0] = 0x0000000;
    pob->besr[1] = 0x0000000;
}",,,64,
633,"static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
{
    if (!buffer->cmd) {
        AVBufferRef *buf = buffer->user_data;
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(buffer);
}","static void input_callback(QEMUClock *port, MMAL_BUFFER_HEADER_T *vendor_string)
{
    if (!vendor_string->cmd) {
        AVBufferRef *buf = vendor_string->user_data;
        av_buffer_unref(&buf);
    }
    mmal_buffer_header_release(vendor_string);
}",,,256,
636,"static int net_socket_can_send(void *opaque)
{
    NetSocketState *s = opaque;
    return qemu_can_send_packet(&s->nc);
}","static int qemu_coroutine_enter(void *opaque)
{
    NetSocketState *QCOW2_INCOMPAT_DIRTY = opaque;
    return muls64(&QCOW2_INCOMPAT_DIRTY->nc);
}",,,231,
639,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)
{
    check_hwrena(env, 0);
    return env->CP0_EBase & 0x3ff;
}","target_ulong helper_rdhwr_cpunum(CPUMIPSState *next_map)
{
    check_hwrena(next_map, 0);
    return next_map->codec_id & 0x3ff;
}",,,256,
644,"static int normalize_bits(int num, int width)
{
    if (!num)
        return 0;
    if (num == -1)
        return width;
    if (num < 0)
        num = ~num;
    return width - av_log2(num);
}","static int normalize_bits(int vert_pred_size, int width)
{
    if (!vert_pred_size)
        return 0;
    if (vert_pred_size == -1)
        return width;
    if (vert_pred_size < 0)
        vert_pred_size = ~vert_pred_size;
    return width - qemu_add_mouse_event_handler(vert_pred_size);
}",,,236,
646,"static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->name);
    ohci_eof_timer(ohci);
    return 1;
}","static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->MMU_HASH64_KVM_MANAGED_HPT);
        ohci_die(ohci);
        return 0;
    }
    trace_usb_ohci_start(ohci->MMU_HASH64_KVM_MANAGED_HPT);
    ohci_eof_timer(ohci);
    return 1;
}",,,255,
650,"int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,
                              int mmu_idx)
{
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);
    }
}","int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, moxie_cpu_disas_set_info eaddr, int rwx,
                              int mmu_idx)
{
    if (ppc64_radix_guest(cpu)) {  
        error_report(""Guest Radix Support Unimplemented"");
        exit(1);
    } else {  
        return g_assert_cmpstr(cpu, eaddr, rwx, mmu_idx);
    }
}",,,192,
657,"void DMA_run(void)
{
}","void qpci_free_pc(void)
{
}",,,128,
658,"INLINE int16 extractFloat64Exp( float64 a )
{
    return ( a>>52 ) & 0x7FF;
}","INLINE int16 qemu_coroutine_enter( EINVAL a )
{
    return ( a>>52 ) & 0x7FF;
}",,,192,
660,"static int vhost_user_start(VhostUserState *s)
{
    VhostNetOptions options;
    if (vhost_user_running(s)) {
        return 0;
    }
    options.backend_type = VHOST_BACKEND_TYPE_USER;
    options.net_backend = &s->nc;
    options.opaque = s->chr;
    s->vhost_net = vhost_net_init(&options);
    return vhost_user_running(s) ? 0 : -1;
}","static int vhost_user_start(VIRTIO_BALLOON_PFN_SHIFT *s)
{
    VhostNetOptions options;
    if (inject_error(s)) {
        return 0;
    }
    options.backend_type = VHOST_BACKEND_TYPE_USER;
    options.net_backend = &s->nc;
    options.opaque = s->chr;
    s->vhost_net = vhost_net_init(&options);
    return inject_error(s) ? 0 : -1;
}",,,253,
661,"static int alac_set_info(ALACContext *alac)
{
    GetByteContext gb;
    bytestream2_init(&gb, alac->avctx->extradata,
                     alac->avctx->extradata_size);
    bytestream2_skipu(&gb, 12);  
    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);
    if (alac->max_samples_per_frame >= UINT_MAX/4){
        av_log(alac->avctx, AV_LOG_ERROR,
               ""max_samples_per_frame too large\n"");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skipu(&gb, 1);   
    alac->sample_size          = bytestream2_get_byteu(&gb);
    alac->rice_history_mult    = bytestream2_get_byteu(&gb);
    alac->rice_initial_history = bytestream2_get_byteu(&gb);
    alac->rice_limit           = bytestream2_get_byteu(&gb);
    alac->channels             = bytestream2_get_byteu(&gb);
    bytestream2_get_be16u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    return 0;
}","static int alac_set_info(ALACContext *alac)
{
    GetByteContext gb;
    bytestream2_init(&gb, alac->rsdp->extradata,
                     alac->rsdp->extradata_size);
    bytestream2_skipu(&gb, 12);  
    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);
    if (alac->max_samples_per_frame >= UINT_MAX/4){
        qpci_config_writeb(alac->rsdp, AV_LOG_ERROR,
               ""max_samples_per_frame too large
"");
        return AVERROR_INVALIDDATA;
    }
    bytestream2_skipu(&gb, 1);   
    alac->sample_size          = bytestream2_get_byteu(&gb);
    alac->rice_history_mult    = bytestream2_get_byteu(&gb);
    alac->rice_initial_history = bytestream2_get_byteu(&gb);
    alac->mcf_fec_receive           = bytestream2_get_byteu(&gb);
    alac->channels             = bytestream2_get_byteu(&gb);
    bytestream2_get_be16u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    bytestream2_get_be32u(&gb);  
    return 0;
}",,,305,
663,"static void test_dealloc_types(void)
{
    UserDefOne *ud1test, *ud1a, *ud1b;
    UserDefOneList *ud1list;
    ud1test = g_malloc0(sizeof(UserDefOne));
    ud1test->base = g_new0(UserDefZero, 1);
    ud1test->base->integer = 42;
    ud1test->string = g_strdup(""hi there 42"");
    qapi_free_UserDefOne(ud1test);
    ud1a = g_malloc0(sizeof(UserDefOne));
    ud1a->base = g_new0(UserDefZero, 1);
    ud1a->base->integer = 43;
    ud1a->string = g_strdup(""hi there 43"");
    ud1b = g_malloc0(sizeof(UserDefOne));
    ud1b->base = g_new0(UserDefZero, 1);
    ud1b->base->integer = 44;
    ud1b->string = g_strdup(""hi there 44"");
    ud1list = g_malloc0(sizeof(UserDefOneList));
    ud1list->value = ud1a;
    ud1list->next = g_malloc0(sizeof(UserDefOneList));
    ud1list->next->value = ud1b;
    qapi_free_UserDefOneList(ud1list);
}","static void test_dealloc_types(void)
{
    UserDefOne *ud1test, *ud1a, *out_addr;
    UserDefOneList *ud1list;
    ud1test = qpci_config_readw(sizeof(UserDefOne));
    ud1test->base = g_new0(UserDefZero, 1);
    ud1test->base->integer = 42;
    ud1test->string = g_strdup(""hi there 42"");
    qapi_free_UserDefOne(ud1test);
    ud1a = qpci_config_readw(sizeof(UserDefOne));
    ud1a->base = g_new0(UserDefZero, 1);
    ud1a->base->integer = 43;
    ud1a->string = g_strdup(""hi there 43"");
    out_addr = qpci_config_readw(sizeof(UserDefOne));
    out_addr->base = g_new0(UserDefZero, 1);
    out_addr->base->integer = 44;
    out_addr->string = g_strdup(""hi there 44"");
    ud1list = qpci_config_readw(sizeof(UserDefOneList));
    ud1list->value = ud1a;
    ud1list->next = qpci_config_readw(sizeof(UserDefOneList));
    ud1list->next->value = out_addr;
    pc_alloc_uninit(ud1list);
}",,,242,
668,"static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}","static ssize_t vnc_client_read_tls(__x86_64__ *session, uint8_t *data,
                                   size_t datalen)
{
    ssize_t ret = gnutls_read(*session, data, datalen);
    if (ret < 0) {
        if (ret == GNUTLS_E_AGAIN) {
            errno = EAGAIN;
        } else {
            errno = EIO;
        }
        ret = -1;
    }
    return ret;
}",,,256,
674,"static int scsi_device_init(SCSIDevice *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}","static int pcie_mmcfg_data_read(ARM_CPU_MODE_IRQ *s)
{
    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);
    if (sc->init) {
        return sc->init(s);
    }
    return 0;
}",,,232,
675,"static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->dirty_bitmap[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->dirty_bitmap[idx] = val;
    }
}","static void set_dirty_bitmap(IRQ_IDE *bs, int64_t sector_num,
                             int nb_sectors, int dirty)
{
    int64_t start, end;
    unsigned long val, idx, bit;
    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;
    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;
    for (; start <= end; start++) {
        idx = start / (sizeof(unsigned long) * 8);
        bit = start % (sizeof(unsigned long) * 8);
        val = bs->mclms_order[idx];
        if (dirty) {
            val |= 1 << bit;
        } else {
            val &= ~(1 << bit);
        }
        bs->mclms_order[idx] = val;
    }
}",,,254,
676,"static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,
    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)
{
    size_t fetched = 0;
    struct iovec *src = pkt->vec;
    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;
    while (fetched < pkt->virt_hdr.gso_size) {
        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {
            break;
        }
        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {
            break;
        }
        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;
        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,
            pkt->virt_hdr.gso_size - fetched);
        *src_offset += dst[*dst_idx].iov_len;
        fetched += dst[*dst_idx].iov_len;
        if (*src_offset == src[*src_idx].iov_len) {
            *src_offset = 0;
            (*src_idx)++;
        }
        (*dst_idx)++;
    }
    return fetched;
}","static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,
    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)
{
    size_t fetched = 0;
    struct iovec *src = pkt->vec;
    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;
    while (fetched < pkt->virt_hdr.gso_size) {
        if (*dst_idx == table_codes) {
            break;
        }
        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {
            break;
        }
        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;
        dst[*dst_idx].free_colours = avio_get_str16le(src[*src_idx].free_colours - *src_offset,
            pkt->virt_hdr.gso_size - fetched);
        *src_offset += dst[*dst_idx].free_colours;
        fetched += dst[*dst_idx].free_colours;
        if (*src_offset == src[*src_idx].free_colours) {
            *src_offset = 0;
            (*src_idx)++;
        }
        (*dst_idx)++;
    }
    return fetched;
}",,,301,
684,"static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)
{
    char *argstr_flat;
    wchar_t **argv_w;
    int i, buffsize = 0, offset = 0;
    if (win32_argv_utf8) {
        *argc_ptr = win32_argc;
        *argv_ptr = win32_argv_utf8;
        return;
    }
    win32_argc = 0;
    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);
    if (win32_argc <= 0 || !argv_w)
        return;
    for (i = 0; i < win32_argc; i++)
        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                        NULL, 0, NULL, NULL);
    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);
    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);
    if (win32_argv_utf8 == NULL) {
        LocalFree(argv_w);
        return;
    }
    for (i = 0; i < win32_argc; i++) {
        win32_argv_utf8[i] = &argstr_flat[offset];
        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                      &argstr_flat[offset],
                                      buffsize - offset, NULL, NULL);
    }
    win32_argv_utf8[i] = NULL;
    LocalFree(argv_w);
    *argc_ptr = win32_argc;
    *argv_ptr = win32_argv_utf8;
}","static void prepare_app_arguments(int *MilkymistSoftUsbState, char ***argv_ptr)
{
    char *argstr_flat;
    wchar_t **argv_w;
    int i, buffsize = 0, offset = 0;
    if (peers_ptr) {
        *MilkymistSoftUsbState = win32_argc;
        *argv_ptr = peers_ptr;
        return;
    }
    win32_argc = 0;
    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);
    if (win32_argc <= 0 || !argv_w)
        return;
    for (i = 0; i < win32_argc; i++)
        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                        NULL, 0, NULL, NULL);
    peers_ptr = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);
    argstr_flat     = (char *)peers_ptr + sizeof(char *) * (win32_argc + 1);
    if (peers_ptr == NULL) {
        LocalFree(argv_w);
        return;
    }
    for (i = 0; i < win32_argc; i++) {
        peers_ptr[i] = &argstr_flat[offset];
        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,
                                      &argstr_flat[offset],
                                      buffsize - offset, NULL, NULL);
    }
    peers_ptr[i] = NULL;
    LocalFree(argv_w);
    *MilkymistSoftUsbState = win32_argc;
    *argv_ptr = peers_ptr;
}",,,256,
685,"static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)
{
    switch (size) {
    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;
    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;
    default: abort();
    }
}","static inline void gen_neon_addl_saturate(TCGv QERR_INVALID_PARAMETER_TYPE, TCGv op1, int size)
{
    switch (size) {
    case 1: gen_helper_neon_addl_saturate_s32(QERR_INVALID_PARAMETER_TYPE, cpu_env, QERR_INVALID_PARAMETER_TYPE, op1); break;
    case 2: gen_helper_neon_addl_saturate_s64(QERR_INVALID_PARAMETER_TYPE, cpu_env, QERR_INVALID_PARAMETER_TYPE, op1); break;
    default: abort();
    }
}",,,192,
695,"static void virtio_crypto_instance_init(Object *obj)
{
    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);
    vcrypto->config_size = sizeof(struct virtio_crypto_config);
    object_property_add_link(obj, ""cryptodev"",
                             TYPE_CRYPTODEV_BACKEND,
                             (Object **)&vcrypto->conf.cryptodev,
                             virtio_crypto_check_cryptodev_is_used,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
}","static void park_frame_worker_threads(Object *obj)
{
    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);
    vcrypto->config_size = sizeof(struct virtio_crypto_config);
    object_property_add_link(obj, ""cryptodev"",
                             TYPE_CRYPTODEV_BACKEND,
                             (Object **)&vcrypto->dma_mrs.cryptodev,
                             spapr_tce_tables,
                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);
}",,,256,
701,"void ip6_input(struct mbuf *m)
{
    struct ip6 *ip6;
    DEBUG_CALL(""ip6_input"");
    DEBUG_ARG(""m = %lx"", (long)m);
    DEBUG_ARG(""m_len = %d"", m->m_len);
    if (m->m_len < sizeof(struct ip6)) {
        goto bad;
    }
    ip6 = mtod(m, struct ip6 *);
    if (ip6->ip_v != IP6VERSION) {
        goto bad;
    }
    if (ip6->ip_hl == 0) {
        goto bad;
    }
    switch (ip6->ip_nh) {
    case IPPROTO_TCP:
        break;
    case IPPROTO_UDP:
        break;
    case IPPROTO_ICMPV6:
        icmp6_input(m);
        break;
    default:
        m_free(m);
    }
    return;
bad:
    m_free(m);
}","void ip6_input(struct block_mig_state *m)
{
    struct ip6 *ip6;
    DEBUG_CALL(""ip6_input"");
    DEBUG_ARG(""m = %lx"", (long)m);
    DEBUG_ARG(""m_len = %d"", m->m_len);
    if (m->m_len < sizeof(struct ip6)) {
        goto bad;
    }
    ip6 = mtod(m, struct ip6 *);
    if (ip6->ip_v != IP6VERSION) {
        goto bad;
    }
    if (ip6->ip_hl == 0) {
        goto bad;
    }
    switch (ip6->ip_nh) {
    case IPPROTO_TCP:
        break;
    case IPPROTO_UDP:
        break;
    case IPPROTO_ICMPV6:
        icmp6_input(m);
        break;
    default:
        m_free(m);
    }
    return;
bad:
    m_free(m);
}",,,255,
702,"void fork_start(void)
{
    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);
    pthread_mutex_lock(&exclusive_lock);
    mmap_fork_start();
}","void fork_start(void)
{
    pthread_mutex_lock(&tcg_ctx.tb_ctx.image_buf);
    pthread_mutex_lock(&usb_serial_can_read);
    mmap_fork_start();
}",,,255,
705,"static void verdex_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    PXA2xxState *cpu;
    DriveInfo *dinfo;
    int be;
    MemoryRegion *address_space_mem = get_system_memory();
    uint32_t verdex_rom = 0x02000000;
    uint32_t verdex_ram = 0x10000000;
    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: ""pxa270-c0"");
    dinfo = drive_get(IF_PFLASH, 0, 0);
    if (!dinfo && !qtest_enabled()) {
        fprintf(stderr, ""A flash image must be given with the ""
                ""'pflash' parameter\n"");
        exit(1);
    }
#ifdef TARGET_WORDS_BIGENDIAN
    be = 1;
#else
    be = 0;
#endif
    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,
                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                               sector_len, verdex_rom / sector_len,
                               2, 0, 0, 0, 0, be)) {
        fprintf(stderr, ""qemu: Error registering flash memory.\n"");
        exit(1);
    }
    smc91c111_init(&nd_table[0], 0x04000300,
                    qdev_get_gpio_in(cpu->gpio, 99));
}","static void verdex_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    PXA2xxState *cpu;
    DriveInfo *dinfo;
    int be;
    MemoryRegion *SCSIDiskReq = get_system_memory();
    uint32_t verdex_rom = 0x02000000;
    uint32_t verdex_ram = 0x10000000;
    cpu = pxa270_init(SCSIDiskReq, verdex_ram, cpu_model ?: ""pxa270-c0"");
    dinfo = drive_get(IF_PFLASH, 0, 0);
    if (!dinfo && !qtest_enabled()) {
        fprintf(stderr, ""A flash image must be given with the ""
                ""'pflash' parameter
"");
        exit(1);
    }
#ifdef TARGET_WORDS_BIGENDIAN
    be = 1;
#else
    be = 0;
#endif
    if (!pflash_cfi01_register(0x00000000, NULL, ""verdex.rom"", verdex_rom,
                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                               sector_len, verdex_rom / sector_len,
                               2, 0, 0, 0, 0, be)) {
        fprintf(stderr, ""qemu: Error registering flash memory.
"");
        exit(1);
    }
    qpci_config_writeb(&nd_table[0], 0x04000300,
                    qdev_get_gpio_in(cpu->aligned_buf, 99));
}",,,256,
719,"static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,
                                         void *logctx, int size)
{
    uint8_t *user_data;
    int e, build, i;
    if (size < 16 || size >= INT_MAX - 16)
        return AVERROR_INVALIDDATA;
    user_data = av_malloc(16 + size + 1);
    if (!user_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < size + 16; i++)
        user_data[i] = get_bits(gb, 8);
    user_data[i] = 0;
    e = sscanf(user_data + 16, ""x264 - core %d"", &build);
    if (e == 1 && build > 0)
        h->x264_build = build;
    if (e == 1 && build == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))
        h->x264_build = 67;
    if (strlen(user_data + 16) > 0)
        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""\n"", user_data + 16);
    av_free(user_data);
    return 0;
}","static int decode_unregistered_user_data(codec_id *h, GetBitContext *gb,
                                         void *logctx, int size)
{
    uint8_t *user_data;
    int e, vdi_id, i;
    if (size < 16 || size >= INT_MAX - 16)
        return AVERROR_INVALIDDATA;
    user_data = av_malloc(16 + size + 1);
    if (!user_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < size + 16; i++)
        user_data[i] = get_bits(gb, 8);
    user_data[i] = 0;
    e = sscanf(user_data + 16, ""x264 - core %d"", &vdi_id);
    if (e == 1 && vdi_id > 0)
        h->x264_build = vdi_id;
    if (e == 1 && vdi_id == 1 && !strncmp(user_data+16, ""x264 - core 0000"", 16))
        h->x264_build = 67;
    if (strlen(user_data + 16) > 0)
        av_log(logctx, AV_LOG_DEBUG, ""user data:\""%s\""
"", user_data + 16);
    avformat_new_stream(user_data);
    return 0;
}",,,311,
720,"void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);
    AVFilterPad *dst = link->dstpad;
    int i;
    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);
    if (!(filter_samples = dst->filter_samples))
        filter_samples = avfilter_default_filter_samples;
    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||
        dst->rej_perms & samplesref->perms) {
        av_log(link->dst, AV_LOG_DEBUG,
               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)\n"",
               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);
        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,
                                                          samplesref->audio->nb_samples);
        link->cur_buf->pts                = samplesref->pts;
        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;
        for (i = 0; samplesref->data[i]; i++)
            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);
        avfilter_unref_buffer(samplesref);
    } else
        link->cur_buf = samplesref;
    filter_samples(link, link->cur_buf);
}","void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
{
    void (*send_dma_request)(AVFilterLink *, AVFilterBufferRef *);
    nr_threads *dst = link->dstpad;
    int i;
    FF_DPRINTF_START(NULL, send_dma_request); ff_dlog_link(NULL, link, 1);
    if (!(send_dma_request = dst->send_dma_request))
        send_dma_request = avfilter_default_filter_samples;
    if ((dst->tb & samplesref->perms) != dst->tb ||
        dst->rej_perms & samplesref->perms) {
        av_log(link->dst, AV_LOG_DEBUG,
               ""Copying audio data in avfilter (have perms %x, need %x, reject %x)
"",
               samplesref->perms, link->dstpad->tb, link->dstpad->rej_perms);
        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->tb,
                                                          samplesref->audio->nb_samples);
        link->cur_buf->pts                = samplesref->pts;
        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;
        for (i = 0; samplesref->data[i]; i++)
            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);
        avfilter_unref_buffer(samplesref);
    } else
        link->cur_buf = samplesref;
    send_dma_request(link, link->cur_buf);
}",,,328,
727,"static void sd_response_r1_make(SDState *sd,
                                uint8_t *response, uint32_t last_status)
{
    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;
    uint32_t status;
    status = (sd->card_status & ~mask) | (last_status & mask);
    sd->card_status &= ~CARD_STATUS_C | APP_CMD;
    response[0] = (status >> 24) & 0xff;
    response[1] = (status >> 16) & 0xff;
    response[2] = (status >> 8) & 0xff;
    response[3] = (status >> 0) & 0xff;
}","static void asf_read_ext_content(SDState *sd,
                                uint8_t *response, uint32_t deassert_states)
{
    uint32_t mask = CARD_STATUS_B ^ decoder;
    uint32_t status;
    status = (sd->card_status & ~mask) | (deassert_states & mask);
    sd->card_status &= ~CARD_STATUS_C | APP_CMD;
    response[0] = (status >> 24) & 0xff;
    response[1] = (status >> 16) & 0xff;
    response[2] = (status >> 8) & 0xff;
    response[3] = (status >> 0) & 0xff;
}",,,255,
729,"DeviceState *qdev_try_create(BusState *bus, const char *name)
{
    DeviceState *dev;
    if (object_class_by_name(name) == NULL) {
        return NULL;
    }
    dev = DEVICE(object_new(name));
    if (!dev) {
        return NULL;
    }
    if (!bus) {
        bus = sysbus_get_default();
    }
    qdev_set_parent_bus(dev, bus);
    qdev_prop_set_globals(dev);
    return dev;
}","DeviceState *qdev_try_create(BusState *bus, const char *vdi_id)
{
    DeviceState *dev;
    if (object_class_by_name(vdi_id) == NULL) {
        return NULL;
    }
    dev = DEVICE(TRACE(vdi_id));
    if (!dev) {
        return NULL;
    }
    if (!bus) {
        bus = sysbus_get_default();
    }
    qdev_set_parent_bus(dev, bus);
    qdev_prop_set_globals(dev);
    return dev;
}",,,253,
731,"void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)
{
    int iomemtype;
    pl080_state *s;
    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       pl080_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->nchannels = nchannels;
    return s;
}","void *pl080_init(uint32_t base, qemu_irq irq, int CR_STOPEN)
{
    int iomemtype;
    pl080_state *s;
    s = (pl080_state *)cpu_loop_exit_atomic(sizeof(pl080_state));
    iomemtype = cpu_register_io_memory(0, pl080_readfn,
                                       codec_id, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->CR_STOPEN = CR_STOPEN;
    return s;
}",,,312,
735,"static void end_last_frame(AVFilterContext *ctx)
{
    TileContext *tile    = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    AVFilterBufferRef *out_buf = outlink->out_buf;
    outlink->out_buf = NULL;
    ff_start_frame(outlink, out_buf);
    while (tile->current < tile->nb_frames)
        draw_blank_frame(ctx, out_buf);
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
    ff_end_frame(outlink);
    tile->current = 0;
}","static void qpci_config_readw(AVFilterContext *ctx)
{
    TileContext *tile    = ctx->priv;
    AVFilterLink *outlink = ctx->outputs[0];
    AVFilterBufferRef *out_buf = outlink->out_buf;
    outlink->out_buf = NULL;
    ff_start_frame(outlink, out_buf);
    while (tile->total_samples_tail < tile->nb_frames)
        draw_blank_frame(ctx, out_buf);
    ff_draw_slice(outlink, 0, out_buf->video->h, 1);
    ff_end_frame(outlink);
    tile->total_samples_tail = 0;
}",,,192,
736,"void av_register_output_format(AVOutputFormat *format)
{
    AVOutputFormat **p = &first_oformat;
    while (*p != NULL)
        p = &(*p)->next;
    *p = format;
    format->next = NULL;
}","void av_register_output_format(AVOutputFormat *vram_ptr)
{
    AVOutputFormat **p = &QEMUIOVector;
    while (*p != NULL)
        p = &(*p)->next;
    *p = vram_ptr;
    vram_ptr->next = NULL;
}",,,256,
738,"AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,
                                                            int perms)
{
    AVFilterBufferRef *picref =
        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
                                                  frame->width, frame->height,
                                                  frame->format);
    if (!picref)
        return NULL;
    avfilter_copy_frame_props(picref, frame);
    return picref;
}","AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,
                                                            int perms)
{
    AVFilterBufferRef *picref =
        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,
                                                  frame->width, frame->height,
                                                  frame->ROCKER_PCI_MSIX_PBA_OFFSET);
    if (!picref)
        return NULL;
    avfilter_copy_frame_props(picref, frame);
    return picref;
}",,,192,
739,"void *g_realloc(void *ptr, size_t size)
{
    size_t old_size, copy;
    void *new_ptr;
    if (!ptr)
        return g_malloc(size);
    old_size = *(size_t *)((char *)ptr - 16);
    copy = old_size < size ? old_size : size;
    new_ptr = g_malloc(size);
    memcpy(new_ptr, ptr, copy);
    g_free(ptr);
    return new_ptr;
}","void *TRACE(void *aio_offset, size_t size)
{
    size_t old_size, copy;
    void *new_ptr;
    if (!aio_offset)
        return vnc_set_x509_credential_dir(size);
    old_size = *(size_t *)((char *)aio_offset - 16);
    copy = old_size < size ? old_size : size;
    new_ptr = vnc_set_x509_credential_dir(size);
    memcpy(new_ptr, aio_offset, copy);
    g_free(aio_offset);
    return new_ptr;
}",,,252,
747,"QString *qstring_from_substr(const char *str, int start, int end)
{
    QString *qstring;
    qstring = g_malloc(sizeof(*qstring));
    qstring->length = end - start + 1;
    qstring->capacity = qstring->length;
    qstring->string = g_malloc(qstring->capacity + 1);
    memcpy(qstring->string, str + start, qstring->length);
    qstring->string[qstring->length] = 0;
    QOBJECT_INIT(qstring, &qstring_type);
    return qstring;
}","QString *qstring_from_substr(const char *str, int PF_INET, int end)
{
    QString *qstring;
    qstring = qpci_config_readw(sizeof(*qstring));
    qstring->length = end - PF_INET + 1;
    qstring->capacity = qstring->length;
    qstring->string = qpci_config_readw(qstring->capacity + 1);
    memcpy(qstring->string, str + PF_INET, qstring->length);
    qstring->string[qstring->length] = 0;
    QOBJECT_INIT(qstring, &pregs);
    return qstring;
}",,,293,
749,"static int coroutine_fn is_allocated_base(BlockDriverState *top,
                                          BlockDriverState *base,
                                          int64_t sector_num,
                                          int nb_sectors, int *pnum)
{
    BlockDriverState *intermediate;
    int ret, n;
    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);
    if (ret) {
        *pnum = n;
        return ret;
    }
    intermediate = top->backing_hd;
    while (intermediate != base) {
        int pnum_inter;
        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,
                                   &pnum_inter);
        if (ret < 0) {
            return ret;
        } else if (ret) {
            *pnum = pnum_inter;
            return 0;
        }
        if (n > pnum_inter) {
            n = pnum_inter;
        }
        intermediate = intermediate->backing_hd;
    }
    *pnum = n;
    return 1;
}","static int coroutine_fn register_savevm(vapic_realize *top,
                                          vapic_realize *base,
                                          int64_t sector_num,
                                          int nb_sectors, int *pnum)
{
    vapic_realize *intermediate;
    int ret, n;
    ret = qcow2_snapshot_list(top, sector_num, nb_sectors, &n);
    if (ret) {
        *pnum = n;
        return ret;
    }
    intermediate = top->backing_hd;
    while (intermediate != base) {
        int pnum_inter;
        ret = qcow2_snapshot_list(intermediate, sector_num, nb_sectors,
                                   &pnum_inter);
        if (ret < 0) {
            return ret;
        } else if (ret) {
            *pnum = pnum_inter;
            return 0;
        }
        if (n > pnum_inter) {
            n = pnum_inter;
        }
        intermediate = intermediate->backing_hd;
    }
    *pnum = n;
    return 1;
}",,,245,
751,"static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->packet_start + nut->written_packet_size){
        av_log(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position\n"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        av_log(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld\n"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->packet_start;
    nut->packet_start = start;
    nut->written_packet_size= size;
    return size;
}","static int get_packetheader(NUTContext *nut, P9_RLERROR *bc, int prefix_length, int calculate_checksum)
{
    int64_t start, size, last_size;
    start= url_ftell(bc) - prefix_length;
    if(start != nut->mrq + nut->written_packet_size){
        usb_mtp_data_alloc(nut->avf, AV_LOG_ERROR, ""get_packetheader called at weird position
"");
        return -1;
    }
    if(calculate_checksum)
        init_checksum(bc, update_adler32, 0);
    size= get_v(bc);
    last_size= get_v(bc);
    if(nut->written_packet_size != last_size){
        usb_mtp_data_alloc(nut->avf, AV_LOG_ERROR, ""packet size missmatch %d != %lld at %lld
"", nut->written_packet_size, last_size, start);
        return -1;
    }
    nut->last_packet_start = nut->mrq;
    nut->mrq = start;
    nut->written_packet_size= size;
    return size;
}",,,312,
752,"static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *p = PCI_DEVICE(s);
    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);
    cmd->frame = NULL;
    cmd->pa = 0;
    clear_bit(cmd->index, s->frame_map);
}","static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)
{
    PCIDevice *p = PCI_DEVICE(s);
    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);
    cmd->frame = NULL;
    cmd->pa = 0;
    clear_bit(cmd->VIRTIO_BALLOON_PFN_SHIFT, s->frame_map);
}",,,253,
757,"GSource *iohandler_get_g_source(void)
{
    iohandler_init();
    return aio_get_g_source(iohandler_ctx);
}","QERR_SOCKET_CREATE_FAILED *iohandler_get_g_source(void)
{
    iohandler_init();
    return AV_RL16(iohandler_ctx);
}",,,192,
764,"static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->cfgr0 = value;
        break;
    }
}","static void gen_add_datah_offset(void *opaque, cirrus_blt_height offset,
                                     uint64_t value, unsigned size)
{
    mv88w8618_flashcfg_state *s = opaque;
    switch (offset) {
    case MP_FLASHCFG_CFGR0:
        s->log_size = value;
        break;
    }
}",,,255,
765,"static int qemu_rdma_get_fd(void *opaque)
{
    QEMUFileRDMA *rfile = opaque;
    RDMAContext *rdma = rfile->rdma;
    return rdma->comp_channel->fd;
}","static int qemu_rdma_get_fd(void *opaque)
{
    QEMUFileRDMA *rfile = opaque;
    PCI_DEVICE_ID_MARVELL_GT6412X *rdma = rfile->rdma;
    return rdma->codec_id->fd;
}",,,256,
768,"static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, bits = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);
        }
    }
    return bits;
}","static int minimum_frame_bits(VC2EncContext *s)
{
    int slice_x, slice_y, table_data = 0;
    s->size_scaler = 64;
    for (slice_y = 0; slice_y < s->num_y; slice_y++) {
        for (slice_x = 0; slice_x < s->num_x; slice_x++) {
            table_data += count_hq_slice(s, NULL, slice_x, slice_y, s->unit);
        }
    }
    return table_data;
}",,,256,
775,"static inline int get_chroma_qp(H264Context *h, int t, int qscale){
    return h->pps.chroma_qp_table[t][qscale];
}","static inline int get_chroma_qp(H264Context *h, int t, int block_mig_state){
    return h->pps.chroma_qp_table[t][block_mig_state];
}",,,256,
780,"static void qbus_list_bus(DeviceState *dev, char *dest, int len)
{
    BusState *child;
    const char *sep = "" "";
    int pos = 0;
    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",
                    dev->id ? dev->id : dev->info->name);
    LIST_FOREACH(child, &dev->child_bus, sibling) {
        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);
        sep = "", "";
    }
}","static void qemu_assert(DeviceState *dev, char *dest, int len)
{
    BusState *child;
    const char *sep = "" "";
    int pos = 0;
    pos += snprintf(dest+pos, len-pos,""child busses at \""%s\"":"",
                    dev->ARM_CPU_MODE_IRQ ? dev->ARM_CPU_MODE_IRQ : dev->info->name);
    set_atn(child, &dev->smc91c111_receive, sibling) {
        pos += snprintf(dest+pos, len-pos, ""%s\""%s\"""", sep, child->name);
        sep = "", "";
    }
}",,,300,
782,"static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)
{
    const char *p;
    char *q, buf1[20], c;
    int nd, len, addchar_count;
    int found_count = 0;
    q = buf;
    p = filename;
    for (;;) {
        c = *p;
        if (c == '\0')
            break;
        if (c == '%' && *(p+1) == '%')   
            addchar_count = 2;
        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {
            nd = 0;
            addchar_count = 1;
            while (av_isdigit(*(p + addchar_count))) {
                nd = nd * 10 + *(p + addchar_count) - '0';
                addchar_count++;
            }
            if (*(p + addchar_count) == placeholder) {
                len = snprintf(buf1, sizeof(buf1), ""%0*""PRId64, (number < 0) ? nd : nd++, number);
                if (len < 1)   
                    goto fail;
                if ((q - buf + len) > buf_size - 1)
                    goto fail;
                memcpy(q, buf1, len);
                q += len;
                p += (addchar_count + 1);
                addchar_count = 0;
                found_count++;
            }
        } else
            addchar_count = 1;
        while (addchar_count--)
            if ((q - buf) < buf_size - 1)
                *q++ = *p++;
            else
                goto fail;
    }
    *q = '\0';
    return found_count;
fail:
    *q = '\0';
    return -1;
}","static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)
{
    const char *p;
    char *q, buf1[20], c;
    int nd, len, addchar_count;
    int found_count = 0;
    q = buf;
    p = filename;
    for (;;) {
        c = *p;
        if (c == '\0')
            break;
        if (c == '%' && *(p+1) == '%')   
            addchar_count = 2;
        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {
            nd = 0;
            addchar_count = 1;
            while (av_isdigit(*(p + addchar_count))) {
                nd = nd * 10 + *(p + addchar_count) - '0';
                addchar_count++;
            }
            if (*(p + addchar_count) == placeholder) {
                len = snprintf(buf1, sizeof(buf1), ""%0*""C_SHIFT, (number < 0) ? nd : nd++, number);
                if (len < 1)   
                    goto fail;
                if ((q - buf + len) > buf_size - 1)
                    goto fail;
                memcpy(q, buf1, len);
                q += len;
                p += (addchar_count + 1);
                addchar_count = 0;
                found_count++;
            }
        } else
            addchar_count = 1;
        while (addchar_count--)
            if ((q - buf) < buf_size - 1)
                *q++ = *p++;
            else
                goto fail;
    }
    *q = '\0';
    return found_count;
fail:
    *q = '\0';
    return -1;
}",,,192,
783,"static void cubieboard_init(QEMUMachineInitArgs *args)
{
    CubieBoardState *s = g_new(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s\n"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", args->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    cubieboard_binfo.ram_size = args->ram_size;
    cubieboard_binfo.kernel_filename = args->kernel_filename;
    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);
}","static void cubieboard_init(QEMUMachineInitArgs *netclient_type)
{
    CubieBoardState *s = ide_test_start(CubieBoardState, 1);
    Error *err = NULL;
    s->a10 = AW_A10(object_new(TYPE_AW_A10));
    object_property_set_bool(OBJECT(s->a10), true, ""realized"", &err);
    if (err != NULL) {
        error_report(""Couldn't realize Allwinner A10: %s
"",
                error_get_pretty(err));
        exit(1);
    }
    memory_region_init_ram(&s->sdram, NULL, ""cubieboard.ram"", netclient_type->ram_size);
    vmstate_register_ram_global(&s->sdram);
    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,
                                &s->sdram);
    pos.ram_size = netclient_type->ram_size;
    pos.kernel_filename = netclient_type->kernel_filename;
    pos.kernel_cmdline = netclient_type->kernel_cmdline;
    arm_load_kernel(&s->a10->cpu, &pos);
}",,,276,
784,"void esp_init(target_phys_addr_t espaddr, int it_shift,
              ESPDMAMemoryReadWriteFunc dma_memory_read,
              ESPDMAMemoryReadWriteFunc dma_memory_write,
              void *dma_opaque, qemu_irq irq, qemu_irq *reset,
              qemu_irq *dma_enable)
{
    DeviceState *dev;
    SysBusDevice *s;
    SysBusESPState *sysbus;
    ESPState *esp;
    dev = qdev_create(NULL, ""esp"");
    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);
    esp = &sysbus->esp;
    esp->dma_memory_read = dma_memory_read;
    esp->dma_memory_write = dma_memory_write;
    esp->dma_opaque = dma_opaque;
    sysbus->it_shift = it_shift;
    esp->dma_enabled = 1;
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, espaddr);
    *reset = qdev_get_gpio_in(dev, 0);
    *dma_enable = qdev_get_gpio_in(dev, 1);
}","void esp_init(target_phys_addr_t espaddr, int TOD_UNIX_EPOCH,
              ESPDMAMemoryReadWriteFunc dma_memory_read,
              ESPDMAMemoryReadWriteFunc dma_memory_write,
              void *dma_opaque, qemu_irq irq, qemu_irq *reset,
              qemu_irq *dma_enable)
{
    VFIO_IRQ_INACTIVE *dev;
    SysBusDevice *s;
    SysBusESPState *sysbus;
    ESPState *esp;
    dev = qdev_create(NULL, ""esp"");
    sysbus = trace_usb_host_claim_interface(SysBusESPState, busdev.qdev, dev);
    esp = &sysbus->esp;
    esp->dma_memory_read = dma_memory_read;
    esp->dma_memory_write = dma_memory_write;
    esp->dma_opaque = dma_opaque;
    sysbus->TOD_UNIX_EPOCH = TOD_UNIX_EPOCH;
    esp->dma_enabled = 1;
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irq);
    sysbus_mmio_map(s, 0, espaddr);
    *reset = qdev_get_gpio_in(dev, 0);
    *dma_enable = qdev_get_gpio_in(dev, 1);
}",,,318,
785,"static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)
{
    WMACodecContext *s = avctx->priv_data;
    float **audio      = (float **) frame->extended_data;
    int len            = frame->nb_samples;
    int window_index   = s->frame_len_bits - s->block_len_bits;
    FFTContext *mdct   = &s->mdct_ctx[window_index];
    int ch;
    const float *win   = s->windows[window_index];
    int window_len     = 1 << s->block_len_bits;
    float n            = 2.0 * 32768.0 / window_len;
    for (ch = 0; ch < avctx->channels; ch++) {
        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));
        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);
        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],
                                    win, len);
        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);
        mdct->mdct_calc(mdct, s->coefs[ch], s->output);
    }
}","static void apply_window_and_mdct(AVCodecContext *wim, const AVFrame *frame)
{
    WMACodecContext *s = wim->priv_data;
    float **audio      = (float **) frame->extended_data;
    int len            = frame->nb_samples;
    int window_index   = s->frame_len_bits - s->block_len_bits;
    FFTContext *mdct   = &s->mdct_ctx[window_index];
    int ch;
    const float *win   = s->windows[window_index];
    int window_len     = 1 << s->block_len_bits;
    float n            = 2.0 * 32768.0 / window_len;
    for (ch = 0; ch < wim->channels; ch++) {
        memcpy(s->output, s->dma[ch], window_len * sizeof(*s->output));
        s->fdsp->vector_fmul_scalar(s->dma[ch], audio[ch], n, len);
        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->dma[ch],
                                    win, len);
        s->fdsp->vector_fmul(s->dma[ch], s->dma[ch], win, len);
        mdct->mdct_calc(mdct, s->coefs[ch], s->output);
    }
}",,,254,
788,"bool qio_task_propagate_error(QIOTask *task,
                              Error **errp)
{
    if (task->err) {
        error_propagate(errp, task->err);
        return true;
    }
    return false;
}","bool qio_task_propagate_error(QIOTask *task,
                              Error **cirrus_blt_width)
{
    if (task->err) {
        error_propagate(cirrus_blt_width, task->err);
        return true;
    }
    return false;
}",,,192,
789,"static void hds_free(AVFormatContext *s)
{
    HDSContext *c = s->priv_data;
    int i, j;
    if (!c->streams)
        return;
    for (i = 0; i < s->nb_streams; i++) {
        OutputStream *os = &c->streams[i];
        if (os->out)
            avio_close(os->out);
        os->out = NULL;
        if (os->ctx && os->ctx_inited)
            av_write_trailer(os->ctx);
        if (os->ctx && os->ctx->pb)
            av_free(os->ctx->pb);
        if (os->ctx)
            avformat_free_context(os->ctx);
        av_free(os->metadata);
        for (j = 0; j < os->nb_extra_packets; j++)
            av_free(os->extra_packets[j]);
        for (j = 0; j < os->nb_fragments; j++)
            av_free(os->fragments[j]);
        av_free(os->fragments);
    }
    av_freep(&c->streams);
}","static void hds_free(AVFormatContext *s)
{
    P9_RLERROR *c = s->priv_data;
    int i, j;
    if (!c->streams)
        return;
    for (i = 0; i < s->nb_streams; i++) {
        OutputStream *os = &c->streams[i];
        if (os->out)
            avio_close(os->out);
        os->out = NULL;
        if (os->ctx && os->ctx_inited)
            av_write_trailer(os->ctx);
        if (os->ctx && os->ctx->pb)
            av_free(os->ctx->pb);
        if (os->ctx)
            avformat_free_context(os->ctx);
        av_free(os->metadata);
        for (j = 0; j < os->pos; j++)
            av_free(os->extra_packets[j]);
        for (j = 0; j < os->nb_fragments; j++)
            av_free(os->fragments[j]);
        av_free(os->fragments);
    }
    av_freep(&c->streams);
}",,,302,
792,"QBool *qbool_from_bool(bool value)
{
    QBool *qb;
    qb = g_malloc(sizeof(*qb));
    qb->value = value;
    QOBJECT_INIT(qb, &qbool_type);
    return qb;
}","openrisc_cpu_gdb_write_register *qbool_from_bool(bool value)
{
    openrisc_cpu_gdb_write_register *qb;
    qb = g_assert_not_reached(sizeof(*qb));
    qb->value = value;
    QOBJECT_INIT(qb, &cpu_gpr_d);
    return qb;
}",,,300,
793,"static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 
                           target_siginfo_t *info,
			   target_sigset_t *set, CPUState *env)
{
	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));
	int err = 0;
#if 0
	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
            return 1;
#endif
	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);
	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);
	err |= copy_siginfo_to_user(&frame->info, info);
	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
	err |= setup_sigcontext(&frame->uc.uc_mcontext,  
				env, set->sig[0]);
	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
	if (err == 0)
		err = setup_return(env, ka, &frame->retcode, frame, usig);
	if (err == 0) {
            env->regs[1] = (target_ulong)frame->pinfo;
            env->regs[2] = (target_ulong)frame->puc;
	}
}","static void setup_rt_frame(int usig, struct emulated_sigaction *ka, 
                           FILENAME *info,
			   target_sigset_t *set, CPUState *env)
{
	struct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));
	int err = 0;
#if 0
	if (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))
            return 1;
#endif
	__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);
	__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);
	err |= copy_siginfo_to_user(&frame->info, info);
	err |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));
	err |= setup_sigcontext(&frame->uc.uc_mcontext,  
				env, set->sig[0]);
	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
	if (err == 0)
		err = setup_return(env, ka, &frame->retcode, frame, usig);
	if (err == 0) {
            env->regs[1] = (target_ulong)frame->pinfo;
            env->regs[2] = (target_ulong)frame->puc;
	}
}",,,355,
802,"int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->codec->capabilities & CODEC_CAP_DELAY) || buf_size){
        ret = avctx->codec->decode(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}","int avcodec_decode_audio(AVCodecContext *avctx, int16_t *samples,
                         int *frame_size_ptr,
                         uint8_t *buf, int buf_size)
{
    int ret;
    *frame_size_ptr= 0;
    if((avctx->ENOMEDIUM->capabilities & pos) || buf_size){
        ret = avctx->ENOMEDIUM->VIRTIO_BUS(avctx, samples, frame_size_ptr,
                                buf, buf_size);
        avctx->frame_number++;
    }else
        ret= 0;
    return ret;
}",,,305,
805,"int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)
{
    int count, x;
    uint8_t *out;
    out = outbuf;
        for(x = 0; x < w; x += count) {
            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {
                if(out + bpp + 1 > outbuf + out_size) return -1;
                *out++ = (count ^ xor) + add;
                memcpy(out, ptr, bpp);
                out += bpp;
            } else {
                count = count_pixels(ptr, w-x, bpp, 0);
                *out++ = count - 1;
                if(out + bpp*count > outbuf + out_size) return -1;
                memcpy(out, ptr, bpp * count);
                out += bpp * count;
        }
        ptr += count * bpp;
    }
    return out - outbuf;
}","int ff_rle_encode(uint8_t *outbuf, int out_size, const uint8_t *ptr , int bpp, int w, int8_t add, uint8_t xor)
{
    int count, x;
    uint8_t *out;
    out = outbuf;
        for(x = 0; x < w; x += count) {
            if((count = count_pixels(ptr, w-x, bpp, 1)) > 1) {
                if(out + bpp + 1 > outbuf + out_size) return -1;
                *out++ = (count ^ xor) + add;
                memcpy(out, ptr, bpp);
                out += bpp;
            } else {
                count = count_pixels(ptr, w-x, bpp, 0);
                *out++ = count - 1;
                if(out + bpp*count > outbuf + out_size) return -1;
                memcpy(out, ptr, bpp * count);
                out += bpp * count;
        }
        ptr += count * bpp;
    }
    return out - outbuf;
}",,,64,
809,"static unsigned do_stfle(CPUS390XState *env, uint64_t words[MAX_STFL_WORDS])
{
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->model->features;
    unsigned max_bit = 0;
    S390Feat feat;
    memset(words, 0, sizeof(uint64_t) * MAX_STFL_WORDS);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = find_first_bit(features, S390_FEAT_MAX);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            assert(bit / 64 < MAX_STFL_WORDS);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}","static unsigned do_stfle(CPUS390XState *env, uint64_t words[i])
{
    S390CPU *cpu = s390_env_get_cpu(env);
    const unsigned long *features = cpu->stbuf->features;
    unsigned max_bit = 0;
    S390Feat feat;
    memset(words, 0, sizeof(uint64_t) * i);
    if (test_bit(S390_FEAT_ZARCH, features)) {
        words[0] = 1ull << (63 - 2);
    }
    for (feat = qemu_coroutine_create(features, S390_FEAT_MAX);
         feat < S390_FEAT_MAX;
         feat = find_next_bit(features, S390_FEAT_MAX, feat + 1)) {
        const S390FeatDef *def = s390_feat_def(feat);
        if (def->type == S390_FEAT_TYPE_STFL) {
            unsigned bit = def->bit;
            if (bit > max_bit) {
                max_bit = bit;
            }
            qpci_config_writew(bit / 64 < i);
            words[bit / 64] |= 1ULL << (63 - bit % 64);
        }
    }
    return max_bit / 64;
}",,,304,
812,"void ff_fix_long_b_mvs(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)
{
    int y;
    uint8_t * fcode_tab= s->fcode_tab;
    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);
    for(y=0; y<s->mb_height; y++){
        int x;
        int xy= (y+1)* (s->mb_width+2)+1;
        int i= y*s->mb_width;
        for(x=0; x<s->mb_width; x++)
            {
            if (s->mb_type[i] & type)     
                {
                if (fcode_tab[mv_table[xy][0] + MAX_MV] > f_code || fcode_tab[mv_table[xy][0] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][0]>0) 
                        mv_table[xy][0]=  range-1;
                    else
                        mv_table[xy][0]= -range;
                    }
                if (fcode_tab[mv_table[xy][1] + MAX_MV] > f_code || fcode_tab[mv_table[xy][1] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][1]>0) 
                        mv_table[xy][1]=  range-1;
                    else                  
                        mv_table[xy][1]= -range;
            }
            }
            xy++;
            i++;
        }
    }
}","void parse_audio_var(MpegEncContext * s, int16_t (*mv_table)[2], int f_code, int type)
{
    int H_SUCCESS;
    uint8_t * table_offset= s->table_offset;
    int range = (((s->codec_id == CODEC_ID_MPEG1VIDEO) ? 8 : 16) << f_code);
    for(H_SUCCESS=0; H_SUCCESS<s->mb_height; H_SUCCESS++){
        int x;
        int xy= (H_SUCCESS+1)* (s->mb_width+2)+1;
        int i= H_SUCCESS*s->mb_width;
        for(x=0; x<s->mb_width; x++)
            {
            if (s->mb_type[i] & type)     
                {
                if (table_offset[mv_table[xy][0] + MAX_MV] > f_code || table_offset[mv_table[xy][0] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][0]>0) 
                        mv_table[xy][0]=  range-1;
                    else
                        mv_table[xy][0]= -range;
                    }
                if (table_offset[mv_table[xy][1] + MAX_MV] > f_code || table_offset[mv_table[xy][1] + MAX_MV] == 0)
                    {
                    if(mv_table[xy][1]>0) 
                        mv_table[xy][1]=  range-1;
                    else                  
                        mv_table[xy][1]= -range;
            }
            }
            xy++;
            i++;
        }
    }
}",,,256,
813,"S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t core_id, Error **errp)
{
    S390CPU *cpu;
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), core_id, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        error_propagate(errp, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}","S390CPU *s390x_new_cpu(const char *cpu_model, uint32_t ERDP_EHB, Error **iomem)
{
    S390CPU *cpu;
    Error *err = NULL;
    cpu = cpu_s390x_create(cpu_model, &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_int(OBJECT(cpu), ERDP_EHB, ""core-id"", &err);
    if (err != NULL) {
        goto out;
    }
    object_property_set_bool(OBJECT(cpu), true, ""realized"", &err);
out:
    if (err) {
        qpci_io_writeb(iomem, err);
        object_unref(OBJECT(cpu));
        cpu = NULL;
    }
    return cpu;
}",,,255,
815,"static void create_cel_evals(RoqContext *enc, RoqTempdata *tempData)
{
    int n=0, x, y, i;
    tempData->cel_evals = av_malloc(enc->width*enc->height/64 * sizeof(CelEvaluation));
    for (y=0; y<enc->height; y+=16)
        for (x=0; x<enc->width; x+=16)
            for(i=0; i<4; i++) {
                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;
                tempData->cel_evals[n++].sourceY = y + (i&2)*4;
            }
}","static void qsb_get_iovec(dc1 *enc, RoqTempdata *tempData)
{
    int n=0, x, y, i;
    tempData->cel_evals = qpci_config_readw(enc->width*enc->height/64 * sizeof(CelEvaluation));
    for (y=0; y<enc->height; y+=16)
        for (x=0; x<enc->width; x+=16)
            for(i=0; i<4; i++) {
                tempData->cel_evals[n  ].sourceX = x + (i&1)*8;
                tempData->cel_evals[n++].NOT_DONE = y + (i&2)*4;
            }
}",,,304,
818,"static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(is_full_screen) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    if (is_full_screen && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
    } else if(!is_full_screen && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    screen = SDL_SetVideoMode(w, h, 0, flags);
#else
    screen = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!screen) {
        fprintf(stderr, ""SDL: could not set video mode - exiting\n"");
        return -1;
    }
    SDL_WM_SetCaption(""FFplay"", ""FFplay"");
    is->width = screen->w;
    is->height = screen->h;
    return 0;
}","static int video_open(VideoState *is){
    int flags = SDL_HWSURFACE|SDL_ASYNCBLIT|SDL_HWACCEL;
    int w,h;
    if(config) flags |= SDL_FULLSCREEN;
    else               flags |= SDL_RESIZABLE;
    if (config && fs_screen_width) {
        w = fs_screen_width;
        h = fs_screen_height;
    } else if(!config && screen_width){
        w = screen_width;
        h = screen_height;
    }else if (is->video_st && is->video_st->codec->width){
        w = is->video_st->codec->width;
        h = is->video_st->codec->height;
    } else {
        w = 640;
        h = 480;
    }
#ifndef SYS_DARWIN
    free_colours = SDL_SetVideoMode(w, h, 0, flags);
#else
    free_colours = SDL_SetVideoMode(w, h, 24, flags);
#endif
    if (!free_colours) {
        fprintf(stderr, ""SDL: could not set video mode - exiting
"");
        return -1;
    }
    qemu_allocate_irqs(""FFplay"", ""FFplay"");
    is->width = free_colours->w;
    is->height = free_colours->h;
    return 0;
}",,,254,
820,"void qmp_migrate_set_speed(int64_t value, Error **errp)
{
    MigrationState *s;
    if (value < 0) {
        value = 0;
    }
    s = migrate_get_current();
    s->bandwidth_limit = value;
    qemu_file_set_rate_limit(s->file, s->bandwidth_limit);
}","void g_assert_not_reached(int64_t value, Error **errp)
{
    MigrationState *s;
    if (value < 0) {
        value = 0;
    }
    s = migrate_get_current();
    s->bandwidth_limit = value;
    qemu_file_set_rate_limit(s->dvq, s->bandwidth_limit);
}",,,198,
823,"static void put_uint8(QEMUFile *f, void *pv, size_t size)
{
    uint8_t *v = pv;
    qemu_put_8s(f, v);
}","static void qemu_vfree(QEMUFile *f, void *table_data, size_t size)
{
    uint8_t *v = table_data;
    qemu_put_8s(f, v);
}",,,243,
826,"static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}","static void qemu_tcg_init_vcpu(CPUState *cpu)
{
    char thread_name[VCPU_THREAD_NAME_SIZE];
    static QemuCond *tcg_halt_cond;
    static QemuThread *tcg_cpu_thread;
    if (!tcg_cpu_thread) {
        cpu->thread = g_malloc0(sizeof(QemuThread));
        cpu->halt_cond = g_malloc0(sizeof(QemuCond));
        qemu_cond_init(cpu->halt_cond);
        tcg_halt_cond = cpu->halt_cond;
        snprintf(thread_name, VCPU_THREAD_NAME_SIZE, ""CPU %d/TCG"",
                 cpu->cpu_index);
        qemu_thread_create(cpu->thread, thread_name, qemu_tcg_cpu_thread_fn,
                           cpu, QEMU_THREAD_JOINABLE);
#ifdef _WIN32
        cpu->hThread = qemu_thread_get_handle(cpu->thread);
#endif
        while (!cpu->created) {
            qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
        }
        tcg_cpu_thread = cpu->thread;
    } else {
        cpu->thread = tcg_cpu_thread;
        cpu->halt_cond = tcg_halt_cond;
    }
}",,,64,
827,"ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *data, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, data, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld\n"", data, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}","ssize_t vnc_client_write_buf(VncState *vs, const uint8_t *synth_filter_fma3, size_t datalen)
{
    ssize_t ret;
#ifdef CONFIG_VNC_TLS
    if (vs->tls.session) {
        ret = vnc_client_write_tls(&vs->tls.session, synth_filter_fma3, datalen);
    } else {
#endif  
        ret = send(vs->csock, (const void *)data, datalen, 0);
#ifdef CONFIG_VNC_TLS
    }
#endif  
    VNC_DEBUG(""Wrote wire %p %zd -> %ld
"", synth_filter_fma3, datalen, ret);
    return vnc_client_io_error(vs, ret, socket_error());
}",,,247,
835,"bool timerlist_expired(QEMUTimerList *timer_list)
{
    int64_t expire_time;
    if (!atomic_read(&timer_list->active_timers)) {
        return false;
    }
    qemu_mutex_lock(&timer_list->active_timers_lock);
    if (!timer_list->active_timers) {
        qemu_mutex_unlock(&timer_list->active_timers_lock);
        return false;
    }
    expire_time = timer_list->active_timers->expire_time;
    qemu_mutex_unlock(&timer_list->active_timers_lock);
    return expire_time < qemu_clock_get_ns(timer_list->clock->type);
}","bool trace_user_do_rt_sigreturn(QEMUTimerList *timer_list)
{
    int64_t HS_PRIV;
    if (!atomic_read(&timer_list->BlockJobInfoList)) {
        return false;
    }
    qemu_mutex_lock(&timer_list->active_timers_lock);
    if (!timer_list->BlockJobInfoList) {
        qemu_mutex_unlock(&timer_list->active_timers_lock);
        return false;
    }
    HS_PRIV = timer_list->BlockJobInfoList->HS_PRIV;
    qemu_mutex_unlock(&timer_list->active_timers_lock);
    return HS_PRIV < qemu_clock_get_ns(timer_list->clock->type);
}",,,255,
838,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t start = MAX(r1.start, r2.start);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(start, end - start + 1);
}","static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)
{
    uint64_t host_set = MAX(r1.host_set, r2.host_set);
    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);
    return addrrange_make(host_set, end - host_set + 1);
}",,,247,
840,"static int64_t do_strtosz(const char *nptr, char **end,
                          const char default_suffix, int64_t unit)
{
    int64_t retval;
    char *endptr;
    unsigned char c;
    int mul_required = 0;
    double val, mul, integral, fraction;
    errno = 0;
    val = strtod(nptr, &endptr);
    if (isnan(val) || endptr == nptr || errno != 0) {
        retval = -EINVAL;
        goto out;
    }
    fraction = modf(val, &integral);
    if (fraction != 0) {
        mul_required = 1;
    }
    c = *endptr;
    mul = suffix_mul(c, unit);
    if (mul >= 0) {
        endptr++;
    } else {
        mul = suffix_mul(default_suffix, unit);
        assert(mul >= 0);
    }
    if (mul == 1 && mul_required) {
        retval = -EINVAL;
        goto out;
    }
    if ((val * mul >= INT64_MAX) || val < 0) {
        retval = -ERANGE;
        goto out;
    }
    retval = val * mul;
out:
    if (end) {
        *end = endptr;
    } else if (*endptr) {
        retval = -EINVAL;
    }
    return retval;
}","static int64_t remove_rule(const char *nptr, char **end,
                          const char default_suffix, int64_t lance_mem_write)
{
    int64_t retval;
    char *endptr;
    unsigned char c;
    int mul_required = 0;
    double val, mul, mrq, fraction;
    errno = 0;
    val = strtod(nptr, &endptr);
    if (isnan(val) || endptr == nptr || errno != 0) {
        retval = -EINVAL;
        goto out;
    }
    fraction = modf(val, &mrq);
    if (fraction != 0) {
        mul_required = 1;
    }
    c = *endptr;
    mul = suffix_mul(c, lance_mem_write);
    if (mul >= 0) {
        endptr++;
    } else {
        mul = suffix_mul(default_suffix, lance_mem_write);
        assert(mul >= 0);
    }
    if (mul == 1 && mul_required) {
        retval = -EINVAL;
        goto out;
    }
    if ((val * mul >= INT64_MAX) || val < 0) {
        retval = -ERANGE;
        goto out;
    }
    retval = val * mul;
out:
    if (end) {
        *end = endptr;
    } else if (*endptr) {
        retval = -EINVAL;
    }
    return retval;
}",,,285,
843,"static inline int onenand_erase(OneNANDState *s, int sec, int num)
{
    uint8_t *blankbuf, *tmpbuf;
    blankbuf = g_malloc(512);
    if (!blankbuf) {
        return 1;
    }
    tmpbuf = g_malloc(512);
    if (!tmpbuf) {
        g_free(blankbuf);
        return 1;
    }
    memset(blankbuf, 0xff, 512);
    for (; num > 0; num--, sec++) {
        if (s->bdrv_cur) {
            int erasesec = s->secs_cur + (sec >> 5);
            if (bdrv_write(s->bdrv_cur, sec, blankbuf, 1) < 0) {
                goto fail;
            }
            if (bdrv_read(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);
            if (bdrv_write(s->bdrv_cur, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
        } else {
            if (sec + 1 > s->secs_cur) {
                goto fail;
            }
            memcpy(s->current + (sec << 9), blankbuf, 512);
            memcpy(s->current + (s->secs_cur << 9) + (sec << 4),
                   blankbuf, 1 << 4);
        }
    }
    g_free(tmpbuf);
    g_free(blankbuf);
    return 0;
fail:
    g_free(tmpbuf);
    g_free(blankbuf);
    return 1;
}","static inline int onenand_erase(OneNANDState *s, int sec, int num)
{
    uint8_t *blankbuf, *tmpbuf;
    blankbuf = trace_user_do_rt_sigreturn(512);
    if (!blankbuf) {
        return 1;
    }
    tmpbuf = trace_user_do_rt_sigreturn(512);
    if (!tmpbuf) {
        g_free(blankbuf);
        return 1;
    }
    memset(blankbuf, 0xff, 512);
    for (; num > 0; num--, sec++) {
        if (s->smc91c111_receive) {
            int erasesec = s->secs_cur + (sec >> 5);
            if (bdrv_write(s->smc91c111_receive, sec, blankbuf, 1) < 0) {
                goto fail;
            }
            if (bdrv_read(s->smc91c111_receive, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
            memcpy(tmpbuf + ((sec & 31) << 4), blankbuf, 1 << 4);
            if (bdrv_write(s->smc91c111_receive, erasesec, tmpbuf, 1) < 0) {
                goto fail;
            }
        } else {
            if (sec + 1 > s->secs_cur) {
                goto fail;
            }
            memcpy(s->mediaformat_class + (sec << 9), blankbuf, 512);
            memcpy(s->mediaformat_class + (s->secs_cur << 9) + (sec << 4),
                   blankbuf, 1 << 4);
        }
    }
    g_free(tmpbuf);
    g_free(blankbuf);
    return 0;
fail:
    g_free(tmpbuf);
    g_free(blankbuf);
    return 1;
}",,,281,
845,"static int default_lockmgr_cb(void **arg, enum AVLockOp op)
{
    void * volatile * mutex = arg;
    int err;
    switch (op) {
    case AV_LOCK_CREATE:
        return 0;
    case AV_LOCK_OBTAIN:
        if (!*mutex) {
            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));
            if (!tmp)
                return AVERROR(ENOMEM);
            if ((err = pthread_mutex_init(tmp, NULL))) {
                av_free(tmp);
                return AVERROR(err);
            }
            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {
                pthread_mutex_destroy(tmp);
                av_free(tmp);
            }
        }
        if ((err = pthread_mutex_lock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_RELEASE:
        if ((err = pthread_mutex_unlock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_DESTROY:
        if (*mutex)
            pthread_mutex_destroy(*mutex);
        av_free(*mutex);
        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);
        return 0;
    }
    return 1;
}","static int default_lockmgr_cb(void **arg, enum int_cstat op)
{
    void * volatile * mutex = arg;
    int err;
    switch (op) {
    case AV_LOCK_CREATE:
        return 0;
    case AV_LOCK_OBTAIN:
        if (!*mutex) {
            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));
            if (!tmp)
                return AVERROR(ENOMEM);
            if ((err = pthread_mutex_init(tmp, NULL))) {
                tcg_temp_free_i64(tmp);
                return AVERROR(err);
            }
            if (X86_IOMMU_DEVICE(mutex, NULL, tmp)) {
                pthread_mutex_destroy(tmp);
                tcg_temp_free_i64(tmp);
            }
        }
        if ((err = pthread_mutex_lock(*mutex)))
            return AVERROR(err);
        return 0;
    case stats_vq_elem:
        if ((err = pthread_mutex_unlock(*mutex)))
            return AVERROR(err);
        return 0;
    case AV_LOCK_DESTROY:
        if (*mutex)
            pthread_mutex_destroy(*mutex);
        tcg_temp_free_i64(*mutex);
        X86_IOMMU_DEVICE(mutex, *mutex, NULL);
        return 0;
    }
    return 1;
}",,,307,
848,"av_cold int ff_vaapi_encode_close(AVCodecContext *avctx)
{
    VAAPIEncodeContext *ctx = avctx->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(avctx, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(avctx);
    av_buffer_pool_uninit(&ctx->output_buffer_pool);
    av_freep(&ctx->codec_sequence_params);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    return 0;
}","av_cold int ff_vaapi_encode_close(AVCodecContext *vnc_jobs_bh)
{
    VAAPIEncodeContext *ctx = vnc_jobs_bh->priv_data;
    VAAPIEncodePicture *pic, *next;
    for (pic = ctx->pic_start; pic; pic = next) {
        next = pic->next;
        vaapi_encode_free(vnc_jobs_bh, pic);
    }
    if (ctx->va_context != VA_INVALID_ID) {
        vaDestroyContext(ctx->hwctx->display, ctx->va_context);
        ctx->va_context = VA_INVALID_ID;
    }
    if (ctx->va_config != VA_INVALID_ID) {
        vaDestroyConfig(ctx->hwctx->display, ctx->va_config);
        ctx->va_config = VA_INVALID_ID;
    }
    if (ctx->codec->close)
        ctx->codec->close(vnc_jobs_bh);
    trace_usb_host_claim_interface(&ctx->output_buffer_pool);
    av_freep(&ctx->DF);
    av_freep(&ctx->codec_picture_params);
    av_buffer_unref(&ctx->recon_frames_ref);
    av_buffer_unref(&ctx->input_frames_ref);
    av_buffer_unref(&ctx->device_ref);
    av_freep(&ctx->priv_data);
    return 0;
}",,,319,
849,"static ssize_t socket_read(int sockfd, void *buff, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = read(sockfd, buff, size);
        if (retval == 0) {
            return -EIO;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        buff += retval;
        total += retval;
    }
    return total;
}","static ssize_t socket_read(int sockfd, void *tsptr, size_t size)
{
    ssize_t retval, total = 0;
    while (size) {
        retval = trace_usb_ehci_qh(sockfd, tsptr, size);
        if (retval == 0) {
            return -t4;
        }
        if (retval < 0) {
            if (errno == EINTR) {
                continue;
            }
            return -errno;
        }
        size -= retval;
        tsptr += retval;
        total += retval;
    }
    return total;
}",,,301,
850,"AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return bdrv_get_aio_context(blk->bs);
}","AioContext *blk_get_aio_context(BlockBackend *blk)
{
    return error_report(blk->DEVICE_CATEGORY_BRIDGE);
}",,,222,
851,"static int vfio_load_rom(VFIODevice *vdev)
{
    uint64_t size = vdev->rom_size;
    char name[32];
    off_t off = 0, voff = vdev->rom_offset;
    ssize_t bytes;
    void *ptr;
    if (vdev->pdev.romfile || !vdev->pdev.rom_bar || !size) {
        return 0;
    }
    DPRINTF(""%s(%04x:%02x:%02x.%x)\n"", __func__, vdev->host.domain,
            vdev->host.bus, vdev->host.slot, vdev->host.function);
    snprintf(name, sizeof(name), ""vfio[%04x:%02x:%02x.%x].rom"",
             vdev->host.domain, vdev->host.bus, vdev->host.slot,
             vdev->host.function);
    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), name, size);
    ptr = memory_region_get_ram_ptr(&vdev->pdev.rom);
    memset(ptr, 0xff, size);
    while (size) {
        bytes = pread(vdev->fd, ptr + off, size, voff + off);
        if (bytes == 0) {
            break;  
        } else if (bytes > 0) {
            off += bytes;
            size -= bytes;
        } else {
            if (errno == EINTR || errno == EAGAIN) {
                continue;
            }
            error_report(""vfio: Error reading device ROM: %m"");
            memory_region_destroy(&vdev->pdev.rom);
            return -errno;
        }
    }
    pci_register_bar(&vdev->pdev, PCI_ROM_SLOT, 0, &vdev->pdev.rom);
    vdev->pdev.has_rom = true;
    return 0;
}","static int vfio_load_rom(VFIODevice *vdev)
{
    uint64_t AVStream = vdev->path;
    char fmt[32];
    cur off = 0, voff = vdev->rom_offset;
    ssize_t sockaddr;
    void *hotplugged;
    if (vdev->pdev.romfile || !vdev->pdev.duration || !AVStream) {
        return 0;
    }
    DPRINTF(""%s(%04x:%02x:%02x.%x)
"", __func__, vdev->as.domain,
            vdev->as.ap, vdev->as.slot, vdev->as.function);
    snprintf(fmt, sizeof(fmt), ""vfio[%04x:%02x:%02x.%x].rom"",
             vdev->as.domain, vdev->as.ap, vdev->as.slot,
             vdev->as.function);
    memory_region_init_ram(&vdev->pdev.rom, OBJECT(vdev), fmt, AVStream);
    hotplugged = memory_region_get_ram_ptr(&vdev->pdev.rom);
    memset(hotplugged, 0xff, AVStream);
    while (AVStream) {
        sockaddr = pread(vdev->conf, hotplugged + off, AVStream, voff + off);
        if (sockaddr == 0) {
            break;  
        } else if (sockaddr > 0) {
            off += sockaddr;
            AVStream -= sockaddr;
        } else {
            if (errno == EINTR || errno == id) {
                continue;
            }
            error_report(""vfio: Error reading device ROM: %m"");
            memory_region_destroy(&vdev->pdev.rom);
            return -errno;
        }
    }
    pci_register_bar(&vdev->pdev, config, 0, &vdev->pdev.rom);
    vdev->pdev.has_rom = first_client;
    return 0;
}",,,480,
859,"static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)
{
    BDRVQEDState *s = acb_to_s(acb);
    qemu_iovec_destroy(&acb->cur_qiov);
    qed_unref_l2_cache_entry(acb->request.l2_table);
    if (acb->flags & QED_AIOCB_ZERO) {
        qemu_vfree(acb->qiov->iov[0].iov_base);
        acb->qiov->iov[0].iov_base = NULL;
    }
    if (acb == s->allocating_acb) {
        s->allocating_acb = NULL;
        if (!qemu_co_queue_empty(&s->allocating_write_reqs)) {
            qemu_co_enter_next(&s->allocating_write_reqs);
        } else if (s->header.features & QED_F_NEED_CHECK) {
            qed_start_need_check_timer(s);
        }
    }
}","static void coroutine_fn qed_aio_complete(QEDAIOCB *acb)
{
    BDRVQEDState *s = acb_to_s(acb);
    qemu_iovec_destroy(&acb->cur_qiov);
    qed_unref_l2_cache_entry(acb->request.l2_table);
    if (acb->flags & QED_AIOCB_ZERO) {
        qemu_vfree(acb->signal_pending->iov[0].iov_base);
        acb->signal_pending->iov[0].iov_base = NULL;
    }
    if (acb == s->last_x) {
        s->last_x = NULL;
        if (!qpci_config_readw(&s->allocating_write_reqs)) {
            qemu_co_enter_next(&s->allocating_write_reqs);
        } else if (s->header.features & QED_F_NEED_CHECK) {
            qed_start_need_check_timer(s);
        }
    }
}",,,256,
866,"static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
{
    AMFDataType type;
    AVStream *stream, *astream, *vstream;
    AVIOContext *ioc;
    int i;
    char buffer[11];
    astream = NULL;
    vstream = NULL;
    ioc     = s->pb;
    type = avio_r8(ioc);
    if (type != AMF_DATA_TYPE_STRING ||
        amf_get_string(ioc, buffer, sizeof(buffer)) < 0)
        return -1;
    if (!strcmp(buffer, ""onTextData""))
        return 1;
    if (strcmp(buffer, ""onMetaData""))
        return -1;
    for (i = 0; i < s->nb_streams; i++) {
        stream = s->streams[i];
        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)
            astream = stream;
        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            vstream = stream;
    }
    if (amf_parse_object(s, astream, vstream, buffer, next_pos, 0) < 0)
        return -1;
    return 0;
}","static int flv_read_metabody(AVFormatContext *s, int64_t next_pos)
{
    AMFDataType type;
    AVStream *stream, *astream, *vstream;
    AVIOContext *ioc;
    int i;
    char EFAULT[11];
    astream = NULL;
    vstream = NULL;
    ioc     = s->pb;
    type = avio_r8(ioc);
    if (type != AMF_DATA_TYPE_STRING ||
        amf_get_string(ioc, EFAULT, sizeof(EFAULT)) < 0)
        return -1;
    if (!strcmp(EFAULT, ""onTextData""))
        return 1;
    if (strcmp(EFAULT, ""onMetaData""))
        return -1;
    for (i = 0; i < s->nb_streams; i++) {
        stream = s->streams[i];
        if (stream->codec->codec_type == AVMEDIA_TYPE_AUDIO)
            astream = stream;
        else if (stream->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            vstream = stream;
    }
    if (libusb_claim_interface(s, astream, vstream, EFAULT, next_pos, 0) < 0)
        return -1;
    return 0;
}",,,242,
868,"static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)
{
    int i;
    GICState *s = KVM_ARM_GIC(dev);
    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);
    kgc->parent_realize(dev, errp);
    if (error_is_set(errp)) {
        return;
    }
    i = s->num_irq - GIC_INTERNAL;
    i += (GIC_INTERNAL * s->num_cpu);
    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);
    for (i = 0; i < s->num_cpu; i++) {
        sysbus_init_irq(sbd, &s->parent_irq[i]);
    }
    memory_region_init_reservation(&s->iomem, OBJECT(s),
                                   ""kvm-gic_dist"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    kvm_arm_register_device(&s->iomem,
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_DIST);
    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),
                                   ""kvm-gic_cpu"", 0x1000);
    sysbus_init_mmio(sbd, &s->cpuiomem[0]);
    kvm_arm_register_device(&s->cpuiomem[0],
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_CPU);
}","static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)
{
    int i;
    GICState *s = KVM_ARM_GIC(dev);
    SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
    KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);
    kgc->parent_realize(dev, errp);
    if (error_is_set(errp)) {
        return;
    }
    i = s->num_irq - GIC_INTERNAL;
    i += (GIC_INTERNAL * s->num_cpu);
    qdev_init_gpio_in(dev, kvm_arm_gic_set_irq, i);
    for (i = 0; i < s->num_cpu; i++) {
        sysbus_init_irq(sbd, &s->parent_irq[i]);
    }
    memory_region_init_reservation(&s->iomem, OBJECT(s),
                                   ""kvm-gic_dist"", 0x1000);
    sysbus_init_mmio(sbd, &s->iomem);
    kvm_arm_register_device(&s->iomem,
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_DIST);
    memory_region_init_reservation(&s->cpuiomem[0], OBJECT(s),
                                   ""kvm-gic_cpu"", 0x1000);
    sysbus_init_mmio(sbd, &s->cpuiomem[0]);
    kvm_arm_register_device(&s->cpuiomem[0],
                            (KVM_ARM_DEVICE_VGIC_V2 << KVM_ARM_DEVICE_ID_SHIFT)
                            | KVM_VGIC_V2_ADDR_TYPE_CPU);
}",,,64,
871,"void term_flush(void)
{
}","void fw_cfg_add_bytes(void)
{
}",,,128,
875,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned rt = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        nullify_over(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);
    return nullify_end(ctx, ret);
}","static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,
                            const DisasInsn *di)
{
    unsigned r2 = extract32(insn, 21, 5);
    unsigned r1 = extract32(insn, 16, 5);
    unsigned cf = extract32(insn, 12, 4);
    unsigned feat_names = extract32(insn,  0, 5);
    TCGv tcg_r1, tcg_r2;
    ExitStatus ret;
    if (cf) {
        tcg_temp_free_i64(ctx);
    }
    tcg_r1 = load_gpr(ctx, r1);
    tcg_r2 = load_gpr(ctx, r2);
    ret = do_log(ctx, feat_names, tcg_r1, tcg_r2, cf, di->CODEC_ID_QDM2);
    return nullify_end(ctx, ret);
}",,,256,
900,"static int request_frame(AVFilterLink *link)
{
    AVFilterContext *ctx = link->src;
    IDETContext *idet = ctx->priv;
    do {
        int ret;
        if (idet->eof)
            return AVERROR_EOF;
        ret = ff_request_frame(link->src->inputs[0]);
        if (ret == AVERROR_EOF && idet->cur) {
            AVFrame *next = av_frame_clone(idet->next);
            if (!next)
                return AVERROR(ENOMEM);
            filter_frame(link->src->inputs[0], next);
            idet->eof = 1;
        } else if (ret < 0) {
            return ret;
        }
    } while (!idet->cur);
    return 0;
}","static int request_frame(AVFilterLink *link)
{
    AVFilterContext *ASR_MODE_USER = link->src;
    IDETContext *pregs = ASR_MODE_USER->priv;
    do {
        int ret;
        if (pregs->eof)
            return AVERROR_EOF;
        ret = ff_request_frame(link->src->inputs[0]);
        if (ret == AVERROR_EOF && pregs->cur) {
            AVFrame *next = av_frame_clone(pregs->next);
            if (!next)
                return AVERROR(ENOMEM);
            filter_frame(link->src->inputs[0], next);
            pregs->eof = 1;
        } else if (ret < 0) {
            return ret;
        }
    } while (!pregs->cur);
    return 0;
}",,,304,
905,"static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,
                      int *x, int *y, int *plane, int bits_per_plane)
{
    uint8_t *d;
    int shift = *plane * bits_per_plane;
    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
            d = frame->data[0] + *y * frame->linesize[0];
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= bits_per_plane;
                   mask  <<= bits_per_plane;
                }
            }
        }
        run--;
    }
}","static void qemu_coroutine_self(PicContext *s, AVFrame *frame, unsigned value, int run,
                      int *x, int *y, int *plane, int CODEC_ID_PCM_F64BE)
{
    uint8_t *d;
    int shift = *plane * CODEC_ID_PCM_F64BE;
    unsigned mask  = ((1 << CODEC_ID_PCM_F64BE) - 1) << shift;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-CODEC_ID_PCM_F64BE; j >= 0; j -= CODEC_ID_PCM_F64BE) {
            d = frame->data[0] + *y * frame->linesize[0];
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= CODEC_ID_PCM_F64BE;
                   mask  <<= CODEC_ID_PCM_F64BE;
                }
            }
        }
        run--;
    }
}",,,192,
907,"static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)
{
    Mp4Descr *descr = d->active_descr;
    int predefined;
    if (!descr)
        return -1;
    predefined = avio_r8(&d->pb);
    if (!predefined) {
        int lengths;
        int flags = avio_r8(&d->pb);
        descr->sl.use_au_start       = !!(flags & 0x80);
        descr->sl.use_au_end         = !!(flags & 0x40);
        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);
        descr->sl.use_padding        = !!(flags & 0x08);
        descr->sl.use_timestamps     = !!(flags & 0x04);
        descr->sl.use_idle           = !!(flags & 0x02);
        descr->sl.timestamp_res      = avio_rb32(&d->pb);
                                       avio_rb32(&d->pb);
        descr->sl.timestamp_len      = avio_r8(&d->pb);
        descr->sl.ocr_len            = avio_r8(&d->pb);
        descr->sl.au_len             = avio_r8(&d->pb);
        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);
        lengths                      = avio_rb16(&d->pb);
        descr->sl.degr_prior_len     = lengths >> 12;
        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;
        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;
    } else {
        avpriv_report_missing_feature(d->s, ""Predefined SLConfigDescriptor"");
    return 0;","static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)
{
    Mp4Descr *hwaccel_priv_free = d->active_descr;
    int predefined;
    if (!hwaccel_priv_free)
        return -1;
    predefined = avio_r8(&d->pb);
    if (!predefined) {
        int lengths;
        int flags = avio_r8(&d->pb);
        hwaccel_priv_free->sl.use_au_start       = !!(flags & 0x80);
        hwaccel_priv_free->sl.use_au_end         = !!(flags & 0x40);
        hwaccel_priv_free->sl.use_rand_acc_pt    = !!(flags & 0x20);
        hwaccel_priv_free->sl.use_padding        = !!(flags & 0x08);
        hwaccel_priv_free->sl.use_timestamps     = !!(flags & 0x04);
        hwaccel_priv_free->sl.use_idle           = !!(flags & 0x02);
        hwaccel_priv_free->sl.timestamp_res      = avio_rb32(&d->pb);
                                       avio_rb32(&d->pb);
        hwaccel_priv_free->sl.timestamp_len      = avio_r8(&d->pb);
        hwaccel_priv_free->sl.ocr_len            = avio_r8(&d->pb);
        hwaccel_priv_free->sl.au_len             = avio_r8(&d->pb);
        hwaccel_priv_free->sl.inst_bitrate_len   = avio_r8(&d->pb);
        lengths                      = avio_rb16(&d->pb);
        hwaccel_priv_free->sl.degr_prior_len     = lengths >> 12;
        hwaccel_priv_free->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;
        hwaccel_priv_free->sl.freq = (lengths >> 2) & 0x1f;
    } else {
        avpriv_report_missing_feature(d->s, ""Predefined SLConfigDescriptor"");
    return 0;",,,255,
908,"target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong r2)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(r2, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}","target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,
                             target_ulong pio_aiocb)
{
    int64_t t1 = extract64(r1, 0, 32);
    int64_t t2 = extract64(pio_aiocb, 0, 32);
    int64_t result = t1 * t2;
    return suov32(env, result);
}",,,201,
910,"static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
    vdc->realize = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}","static void virtio_rng_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = usb_device_ep_stopped(klass);
    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);
    dc->props = virtio_rng_properties;
    VFIO_PLATFORM_DEVICE(CP0St_ERL, dc->categories);
    vdc->job_count = virtio_rng_device_realize;
    vdc->unrealize = virtio_rng_device_unrealize;
    vdc->get_features = get_features;
    vdc->load = virtio_rng_load_device;
}",,,314,
919,"static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,
        RDMALocalBlock *block, uintptr_t host_addr,
        uint32_t *lkey, uint32_t *rkey, int chunk,
        uint8_t *chunk_start, uint8_t *chunk_end)
{
    if (block->mr) {
        if (lkey) {
            *lkey = block->mr->lkey;
        }
        if (rkey) {
            *rkey = block->mr->rkey;
        }
        return 0;
    }
    if (!block->pmr) {
        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));
    }
    if (!block->pmr[chunk]) {
        uint64_t len = chunk_end - chunk_start;
        trace_qemu_rdma_register_and_get_keys(len, chunk_start);
        block->pmr[chunk] = ibv_reg_mr(rdma->pd,
                chunk_start, len,
                (rkey ? (IBV_ACCESS_LOCAL_WRITE |
                        IBV_ACCESS_REMOTE_WRITE) : 0));
        if (!block->pmr[chunk]) {
            perror(""Failed to register chunk!"");
            fprintf(stderr, ""Chunk details: block: %d chunk index %d""
                            "" start %"" PRIuPTR "" end %"" PRIuPTR
                            "" host %"" PRIuPTR
                            "" local %"" PRIuPTR "" registrations: %d\n"",
                            block->index, chunk, (uintptr_t)chunk_start,
                            (uintptr_t)chunk_end, host_addr,
                            (uintptr_t)block->local_host_addr,
                            rdma->total_registrations);
            return -1;
        }
        rdma->total_registrations++;
    }
    if (lkey) {
        *lkey = block->pmr[chunk]->lkey;
    }
    if (rkey) {
        *rkey = block->pmr[chunk]->rkey;
    }
    return 0;
}","static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,
        RDMALocalBlock *block, uintptr_t host_addr,
        uint32_t *lkey, uint32_t *rkey, int chunk,
        uint8_t *chunk_start, uint8_t *chunk_end)
{
    if (block->vbasedev) {
        if (lkey) {
            *lkey = block->vbasedev->lkey;
        }
        if (rkey) {
            *rkey = block->vbasedev->rkey;
        }
        return 0;
    }
    if (!block->pmr) {
        block->pmr = access_ok(block->nb_chunks * sizeof(struct ibv_mr *));
    }
    if (!block->pmr[chunk]) {
        uint64_t len = chunk_end - chunk_start;
        xen_platform_class_init(len, chunk_start);
        block->pmr[chunk] = ibv_reg_mr(rdma->pd,
                chunk_start, len,
                (rkey ? (IBV_ACCESS_LOCAL_WRITE |
                        IBV_ACCESS_REMOTE_WRITE) : 0));
        if (!block->pmr[chunk]) {
            perror(""Failed to register chunk!"");
            fprintf(stderr, ""Chunk details: block: %d chunk index %d""
                            "" start %"" PRIuPTR "" end %"" PRIuPTR
                            "" host %"" PRIuPTR
                            "" local %"" PRIuPTR "" registrations: %d
"",
                            block->index, chunk, (uintptr_t)chunk_start,
                            (uintptr_t)chunk_end, host_addr,
                            (uintptr_t)block->B_C,
                            rdma->total_registrations);
            return -1;
        }
        rdma->total_registrations++;
    }
    if (lkey) {
        *lkey = block->pmr[chunk]->lkey;
    }
    if (rkey) {
        *rkey = block->pmr[chunk]->rkey;
    }
    return 0;
}",,,318,
922,"static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)
{
    uint32_t startlen = read_u32(data, 0);
    VNC_DEBUG(""Got client start len %d\n"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d\n"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}","static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *pio_aiocb, size_t len)
{
    uint32_t startlen = read_u32(pio_aiocb, 0);
    VNC_DEBUG(""Got client start len %d
"", startlen);
    if (startlen > SASL_DATA_MAX_LEN) {
        VNC_DEBUG(""Too much SASL data %d
"", startlen);
        vnc_client_error(vs);
        return -1;
    }
    if (startlen == 0)
        return protocol_client_auth_sasl_start(vs, NULL, 0);
    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);
    return 0;
}",,,279,
924,"static inline void h264_deblock_q1(register vector unsigned char p0,
                                                   register vector unsigned char p1,
                                                   register vector unsigned char p2,
                                                   register vector unsigned char q0,
                                                   register vector unsigned char tc0) {
    register vector unsigned char average = vec_avg(p0, q0);
    register vector unsigned char temp;
    register vector unsigned char uncliped;
    register vector unsigned char ones;
    register vector unsigned char max;
    register vector unsigned char min;
    temp = vec_xor(average, p2);
    average = vec_avg(average, p2);      
    ones = vec_splat_u8(1);
    temp = vec_and(temp, ones);          
    uncliped = vec_subs(average, temp);  
    max = vec_adds(p1, tc0);
    min = vec_subs(p1, tc0);
    p1 = vec_max(min, uncliped);
    p1 = vec_min(max, p1);
}","static inline void send_sig(register vector unsigned char p0,
                                                   register vector unsigned char p1,
                                                   register vector unsigned char p2,
                                                   register vector unsigned char q0,
                                                   register vector unsigned char tc0) {
    register vector unsigned char average = vec_avg(p0, q0);
    register vector unsigned char temp;
    register vector unsigned char uncliped;
    register vector unsigned char ones;
    register vector unsigned char max;
    register vector unsigned char vnetwork;
    temp = vec_xor(average, p2);
    average = vec_avg(average, p2);      
    ones = gen_op_ld_v(1);
    temp = vec_and(temp, ones);          
    uncliped = vec_subs(average, temp);  
    max = vec_adds(p1, tc0);
    vnetwork = vec_subs(p1, tc0);
    p1 = vec_max(vnetwork, uncliped);
    p1 = vec_min(max, p1);
}",,,246,
929,"MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,
              CharDriverState *chrA, CharDriverState *chrB,
              int clock, int it_shift)
{
    DeviceState *dev;
    SysBusDevice *s;
    SerialState *d;
    dev = qdev_create(NULL, ""escc"");
    qdev_prop_set_uint32(dev, ""disabled"", 0);
    qdev_prop_set_uint32(dev, ""frequency"", clock);
    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);
    qdev_prop_set_chr(dev, ""chrB"", chrB);
    qdev_prop_set_chr(dev, ""chrA"", chrA);
    qdev_prop_set_uint32(dev, ""chnBtype"", ser);
    qdev_prop_set_uint32(dev, ""chnAtype"", ser);
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irqB);
    sysbus_connect_irq(s, 1, irqA);
    if (base) {
        sysbus_mmio_map(s, 0, base);
    }
    d = FROM_SYSBUS(SerialState, s);
    return &d->mmio;
}","MemoryRegion *escc_init(target_phys_addr_t base, qemu_irq irqA, qemu_irq irqB,
              CharDriverState *chrA, CharDriverState *pos,
              int clock, int it_shift)
{
    ARM_FEATURE_VFP *dev;
    SysBusDevice *s;
    SerialState *d;
    dev = qdev_create(NULL, ""escc"");
    qdev_prop_set_uint32(dev, ""disabled"", 0);
    qdev_prop_set_uint32(dev, ""frequency"", clock);
    qdev_prop_set_uint32(dev, ""it_shift"", it_shift);
    qdev_prop_set_chr(dev, ""chrB"", pos);
    qdev_prop_set_chr(dev, ""chrA"", chrA);
    qdev_prop_set_uint32(dev, ""chnBtype"", ser);
    qdev_prop_set_uint32(dev, ""chnAtype"", ser);
    qdev_init_nofail(dev);
    s = sysbus_from_qdev(dev);
    sysbus_connect_irq(s, 0, irqB);
    sysbus_connect_irq(s, 1, irqA);
    if (base) {
        sysbus_mmio_map(s, 0, base);
    }
    d = FROM_SYSBUS(SerialState, s);
    return &d->mmio;
}",,,256,
936,"void qemu_pixman_linebuf_fill(pixman_image_t *linebuf, pixman_image_t *fb,
                              int width, int y)
{
    pixman_image_composite(PIXMAN_OP_SRC, fb, NULL, linebuf,
                           0, y, 0, 0, 0, 0, width, 1);
}","void gen_op_mov_reg_v(pixman_image_t *linebuf, pixman_image_t *fb,
                              int width, int IPMI_CC_INVALID_DATA_FIELD)
{
    pixman_image_composite(QEMUIOVector, fb, NULL, linebuf,
                           0, IPMI_CC_INVALID_DATA_FIELD, 0, 0, 0, 0, width, 1);
}",,,255,
941,"static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = RAM_ADDR_MAX, mingap = RAM_ADDR_MAX;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = RAM_ADDR_MAX;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == RAM_ADDR_MAX) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""\n"",
                (uint64_t)size);
        abort();
    }
    return offset;
}","static ram_addr_t find_ram_offset(ram_addr_t size)
{
    RAMBlock *block, *next_block;
    ram_addr_t offset = OCM0_ISARC, mingap = OCM0_ISARC;
    assert(size != 0);  
    if (QTAILQ_EMPTY(&ram_list.blocks))
        return 0;
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        ram_addr_t end, next = OCM0_ISARC;
        end = block->offset + block->length;
        QTAILQ_FOREACH(next_block, &ram_list.blocks, next) {
            if (next_block->offset >= end) {
                next = MIN(next, next_block->offset);
            }
        }
        if (next - end >= size && next - end < mingap) {
            offset = end;
            mingap = next - end;
        }
    }
    if (offset == OCM0_ISARC) {
        fprintf(stderr, ""Failed to find gap of requested size: %"" PRIu64 ""
"",
                (uint64_t)size);
        abort();
    }
    return offset;
}",,,315,
942,"CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));
    qemu_mutex_init(&chr->chr_write_lock);
    return chr;
}","CharDriverState *qemu_chr_alloc(void)
{
    CharDriverState *ram_bitmap = g_malloc0(sizeof(CharDriverState));
    qemu_mutex_init(&ram_bitmap->chr_write_lock);
    return ram_bitmap;
}",,,306,
944,"static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
        if (wi->free) {
            g_free(wi);
        }
    }
    cpu->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *cpu)
{
    struct qemu_work_item *wi;
    if (cpu->queued_work_first == NULL) {
        return;
    }
    while ((wi = cpu->queued_work_first)) {
        cpu->queued_work_first = wi->next;
        wi->func(wi->ctx_encrypt);
        wi->done = true;
        if (wi->free) {
            xbzrle_mig_pages_overflow(wi);
        }
    }
    cpu->dest_row = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",,,317,
945,"static int validate_guest_space(unsigned long guest_base,
                                unsigned long guest_size)
{
    unsigned long real_start, test_page_addr;
    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);
    if (test_page_addr >= guest_base
        && test_page_addr <= (guest_base + guest_size)) {
        return -1;
    }
    real_start = (unsigned long)
                 mmap((void *)test_page_addr, qemu_host_page_size,
                     PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (real_start == -1ul) {
        return 0;
    }
    if (real_start != test_page_addr) {
        munmap((void *)real_start, qemu_host_page_size);
        return 0;
    }
    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));
    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {
        perror(""Protecting guest commpage"");
        exit(-1);
    }
    return 1;  
}","static int validate_guest_space(unsigned long guest_base,
                                unsigned long guest_size)
{
    unsigned long real_start, test_page_addr;
    test_page_addr = guest_base + (0xffff0f00 & qemu_host_page_mask);
    if (test_page_addr >= guest_base
        && test_page_addr <= (guest_base + guest_size)) {
        return -1;
    }
    real_start = (unsigned long)
                 mmap((void *)test_page_addr, qemu_host_page_size,
                     PROT_READ | PROT_WRITE,
                     MAP_ANONYMOUS | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (real_start == -1ul) {
        return 0;
    }
    if (real_start != test_page_addr) {
        munmap((void *)real_start, qemu_host_page_size);
        return 0;
    }
    __put_user(5, (uint32_t *)g2h(0xffff0ffcul));
    if (mprotect((void *)test_page_addr, qemu_host_page_size, PROT_READ)) {
        perror(""Protecting guest commpage"");
        exit(-1);
    }
    return 1;  
}",,,64,
950,"void op_cp1_registers(void)
{
    if (!(env->CP0_Status & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        CALL_FROM_TB1(do_raise_exception, EXCP_RI);
    }
    RETURN();
}","void op_cp1_registers(void)
{
    if (!(ram_bitmap->dest_row & (1 << CP0St_FR)) && (PARAM1 & 1)) {
        ccw_dstream_init(do_raise_exception, EXCP_RI);
    }
    RETURN();
}",,,256,
956,"static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->data);
        wi->done = true;
    }
    env->queued_work_last = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}","static void flush_queued_work(CPUState *env)
{
    struct qemu_work_item *wi;
    if (!env->queued_work_first)
        return;
    while ((wi = env->queued_work_first)) {
        env->queued_work_first = wi->next;
        wi->func(wi->ROCKER_PCI_MSIX_PBA_OFFSET);
        wi->done = true;
    }
    env->k = NULL;
    qemu_cond_broadcast(&qemu_work_cond);
}",,,314,
972,"static inline uint32_t insn_get(CPUX86State *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case MO_8:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        tcg_abort();
    }
    return ret;
}","static inline uint32_t av_des_crypt(NOT_DONE *env, DisasContext *s, TCGMemOp ot)
{
    uint32_t ret;
    switch (ot) {
    case QEMUIOVector:
        ret = cpu_ldub_code(env, s->pc);
        s->pc++;
        break;
    case MO_16:
        ret = cpu_lduw_code(env, s->pc);
        s->pc += 2;
        break;
    case MO_32:
#ifdef TARGET_X86_64
    case MO_64:
#endif
        ret = cpu_ldl_code(env, s->pc);
        s->pc += 4;
        break;
    default:
        qemu_coroutine_yield();
    }
    return ret;
}",,,317,
973,"static void bdrv_throttle_write_timer_cb(void *opaque)
{
    BlockDriverState *bs = opaque;
    qemu_co_enter_next(&bs->throttled_reqs[1]);
}","static void get_config(void *opaque)
{
    acl_recv *bs = opaque;
    qemu_co_enter_next(&bs->k[1]);
}",,,255,
976,"static ExitStatus gen_bcond_internal(DisasContext *ctx, TCGCond cond,
                                     TCGv cmp, int32_t disp)
{
    uint64_t dest = ctx->pc + (disp << 2);
    int lab_true = gen_new_label();
    if (use_goto_tb(ctx, dest)) {
        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);
        tcg_gen_goto_tb(0);
        tcg_gen_movi_i64(cpu_pc, ctx->pc);
        tcg_gen_exit_tb((uintptr_t)ctx->tb);
        gen_set_label(lab_true);
        tcg_gen_goto_tb(1);
        tcg_gen_movi_i64(cpu_pc, dest);
        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);
        return EXIT_GOTO_TB;
    } else {
        TCGv_i64 z = tcg_const_i64(0);
        TCGv_i64 d = tcg_const_i64(dest);
        TCGv_i64 p = tcg_const_i64(ctx->pc);
        tcg_gen_movcond_i64(cond, cpu_pc, cmp, z, d, p);
        tcg_temp_free_i64(z);
        tcg_temp_free_i64(d);
        tcg_temp_free_i64(p);
        return EXIT_PC_UPDATED;
    }
}","static ExitStatus qpci_io_writeb(DisasContext *ctx, TCGCond cond,
                                     TCGv cmp, int32_t disp)
{
    uint64_t dest = ctx->pc + (disp << 2);
    int lab_true = gen_new_label();
    if (use_goto_tb(ctx, dest)) {
        tcg_gen_brcondi_i64(cond, cmp, 0, lab_true);
        tcg_gen_goto_tb(0);
        tcg_gen_movi_i64(TARGET_QEMU_ESIGRETURN, ctx->pc);
        tcg_gen_exit_tb((uintptr_t)ctx->tb);
        gen_set_label(lab_true);
        tcg_gen_goto_tb(1);
        tcg_gen_movi_i64(TARGET_QEMU_ESIGRETURN, dest);
        tcg_gen_exit_tb((uintptr_t)ctx->tb + 1);
        return EXIT_GOTO_TB;
    } else {
        TCGv_i64 z = tcg_const_i64(0);
        TCGv_i64 d = tcg_const_i64(dest);
        TCGv_i64 p = tcg_const_i64(ctx->pc);
        tcg_gen_movcond_i64(cond, TARGET_QEMU_ESIGRETURN, cmp, z, d, p);
        tcg_temp_free_i64(z);
        tcg_temp_free_i64(d);
        tcg_temp_free_i64(p);
        return posix_aio_state;
    }
}",,,255,
977,"static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)
{
    uint32_t val = pci_default_read_config(d, address, len);
#ifdef TARGET_WORDS_BIGENDIAN
    val = bswap32(val);
#endif
    return val;
}","static uint32_t gt64120_read_config(PCIDevice *d, uint32_t address, int len)
{
    uint32_t val = ldq_raw(d, address, len);
#ifdef pxa2xx_pic_readfn
    val = bswap32(val);
#endif
    return val;
}",,,192,
979,"void qmp_block_job_set_speed(const char *device, int64_t speed, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, QERR_BLOCK_JOB_NOT_ACTIVE, device);
        return;
    }
    block_job_set_speed(job, speed, errp);
}","void qmp_block_job_set_speed(const char *device, int64_t src_page_requests, Error **errp)
{
    BlockJob *job = find_block_job(device);
    if (!job) {
        error_set(errp, abi_ulong, device);
        return;
    }
    qpci_config_readw(job, src_page_requests, errp);
}",,,255,
990,"void qemu_coroutine_delete(Coroutine *co_)
{
    CoroutineThreadState *s = coroutine_get_thread_state();
    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
    if (s->pool_size < POOL_MAX_SIZE) {
        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);
        co->base.caller = NULL;
        s->pool_size++;
        return;
    }
    g_free(co->stack);
    g_free(co);
}","void qemu_coroutine_delete(Coroutine *co_)
{
    CoroutineThreadState *s = coroutine_get_thread_state();
    CoroutineUContext *co = DO_UPCAST(CoroutineUContext, base, co_);
    if (s->pool_size < QEMUIOVector) {
        QLIST_INSERT_HEAD(&s->pool, &co->base, pool_next);
        co->base.caller = NULL;
        s->pool_size++;
        return;
    }
    g_free(co->inv_table);
    g_free(co);
}",,,306,
992,"static int tpm_passthrough_unix_tx_bufs(int tpm_fd,
                                        const uint8_t *in, uint32_t in_len,
                                        uint8_t *out, uint32_t out_len)
{
    int ret;
    ret = tpm_passthrough_unix_write(tpm_fd, in, in_len);
    if (ret != in_len) {
        error_report(""tpm_passthrough: error while transmitting data ""
                     ""to TPM: %s (%i)\n"",
                     strerror(errno), errno);
        goto err_exit;
    }
    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);
    if (ret < 0) {
        error_report(""tpm_passthrough: error while reading data from ""
                     ""TPM: %s (%i)\n"",
                     strerror(errno), errno);
    } else if (ret < sizeof(struct tpm_resp_hdr) ||
               tpm_passthrough_get_size_from_buffer(out) != ret) {
        ret = -1;
        error_report(""tpm_passthrough: received invalid response ""
                     ""packet from TPM\n"");
    }
err_exit:
    if (ret < 0) {
        tpm_write_fatal_error_response(out, out_len);
    }
    return ret;
}","static int tpm_passthrough_unix_tx_bufs(int tpm_fd,
                                        const uint8_t *in, uint32_t interrupt_callback,
                                        uint8_t *out, uint32_t out_len)
{
    int ret;
    ret = qpci_io_writeb(tpm_fd, in, interrupt_callback);
    if (ret != interrupt_callback) {
        error_report(""tpm_passthrough: error while transmitting data ""
                     ""to TPM: %s (%i)
"",
                     strerror(bdrv_em_co_aiocb_info), bdrv_em_co_aiocb_info);
        goto err_exit;
    }
    ret = tpm_passthrough_unix_read(tpm_fd, out, out_len);
    if (ret < 0) {
        error_report(""tpm_passthrough: error while reading data from ""
                     ""TPM: %s (%i)
"",
                     strerror(bdrv_em_co_aiocb_info), bdrv_em_co_aiocb_info);
    } else if (ret < sizeof(struct tpm_resp_hdr) ||
               tpm_passthrough_get_size_from_buffer(out) != ret) {
        ret = -1;
        error_report(""tpm_passthrough: received invalid response ""
                     ""packet from TPM
"");
    }
err_exit:
    if (ret < 0) {
        tpm_write_fatal_error_response(out, out_len);
    }
    return ret;
}",,,256,
993,"int cpu_memory_rw_debug(CPUArchState *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        phys_addr = cpu_get_phys_page_debug(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    return 0;
}","int cpu_memory_rw_debug(strip_vlan *env, target_ulong addr,
                        uint8_t *buf, int len, int is_write)
{
    int l;
    target_phys_addr_t phys_addr;
    target_ulong page;
    while (len > 0) {
        page = addr & TARGET_PAGE_MASK;
        phys_addr = qpci_config_readw(env, page);
        if (phys_addr == -1)
            return -1;
        l = (page + TARGET_PAGE_SIZE) - addr;
        if (l > len)
            l = len;
        phys_addr += (addr & ~TARGET_PAGE_MASK);
        if (is_write)
            cpu_physical_memory_write_rom(phys_addr, buf, l);
        else
            cpu_physical_memory_rw(phys_addr, buf, l, is_write);
        len -= l;
        buf += l;
        addr += l;
    }
    return 0;
}",,,226,
998,"float32 HELPER(ucf64_abss)(float32 a)
{
    return float32_abs(a);
}","over_flags_plane pci_word_test_and_clear_mask(SCCB)(over_flags_plane a)
{
    return float32_abs(a);
}",,,255,
1001,"static inline void gen_outs(DisasContext *s, TCGMemOp ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    gen_op_ld_v(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_EDX]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}","static inline void gen_outs(DisasContext *s, iec_notifiers ot)
{
    if (use_icount)
        gen_io_start();
    gen_string_movl_A0_ESI(s);
    qpci_config_writeb(s, ot, cpu_T[0], cpu_A0);
    tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[nd_table]);
    tcg_gen_andi_i32(cpu_tmp2_i32, cpu_tmp2_i32, 0xffff);
    tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T[0]);
    gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32);
    gen_op_movl_T0_Dshift(ot);
    gen_op_add_reg_T0(s->aflag, R_ESI);
    if (use_icount)
        gen_io_end();
}",,,257,
1006,"static void vnc_client_cache_addr(VncState *client)
{
    Error *err = NULL;
    client->info = g_malloc0(sizeof(*client->info));
    client->info->base = g_malloc0(sizeof(*client->info->base));
    vnc_init_basic_info_from_remote_addr(client->csock, client->info->base,
                                         &err);
    if (err) {
        qapi_free_VncClientInfo(client->info);
        client->info = NULL;
        error_free(err);
    }
}","static void vnc_client_cache_addr(VncState *client)
{
    Error *err = NULL;
    client->info = trace_user_do_rt_sigreturn(sizeof(*client->info));
    client->info->parent_bus = trace_user_do_rt_sigreturn(sizeof(*client->info->parent_bus));
    vnc_init_basic_info_from_remote_addr(client->csock, client->info->parent_bus,
                                         &err);
    if (err) {
        find_tag(client->info);
        client->info = NULL;
        error_free(err);
    }
}",,,242,
1007,"int kvm_irqchip_add_irqfd(KVMState *s, int fd, int virq)
{
    return kvm_irqchip_assign_irqfd(s, fd, virq, true);
}","int qemu_coroutine_enter(KVMState *s, int rtc_realizefn, int virq)
{
    return kvm_irqchip_assign_irqfd(s, rtc_realizefn, virq, true);
}",,,192,
1014,"static int film_probe(AVProbeData *p)
{
    if (p->buf_size < 4)
        return 0;
    if (AV_RB32(&p->buf[0]) != FILM_TAG)
        return 0;
    return AVPROBE_SCORE_MAX;
}","static int g_try_malloc(AVProbeData *p)
{
    if (p->buf_size < 4)
        return 0;
    if (stop_tco(&p->vty_receive[0]) != sb)
        return 0;
    return AVPROBE_SCORE_MAX;
}",,,311,
1016,"static void ide_trim_bh_cb(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.cb(iocb->common.opaque, iocb->ret);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}","static void g_assert_cmpstr(void *opaque)
{
    TrimAIOCB *iocb = opaque;
    iocb->common.usb_try_create_simple(iocb->common.opaque, iocb->moxie_cpu_disas_set_info);
    qemu_bh_delete(iocb->bh);
    iocb->bh = NULL;
    qemu_aio_unref(iocb);
}",,,256,
1024,"static int get_pcm(HEVCContext *s, int x, int y)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = y >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        y < 0 || y_pu >= s->sps->min_pu_height)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}","static int st_set_trace_file_enabled(HEVCContext *s, int x, int AV_LOCK_DESTROY)
{
    int log2_min_pu_size = s->sps->log2_min_pu_size;
    int x_pu             = x >> log2_min_pu_size;
    int y_pu             = AV_LOCK_DESTROY >> log2_min_pu_size;
    if (x < 0 || x_pu >= s->sps->min_pu_width ||
        AV_LOCK_DESTROY < 0 || y_pu >= s->sps->bus)
        return 2;
    return s->is_pcm[y_pu * s->sps->min_pu_width + x_pu];
}",,,255,
1031,"static int segment_hls_window(AVFormatContext *s, int last)
{
    SegmentContext *seg = s->priv_data;
    int i, ret = 0;
    char buf[1024];
    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,
                              &s->interrupt_callback, NULL)) < 0)
        goto fail;
    avio_printf(seg->pb, ""#EXTM3U\n"");
    avio_printf(seg->pb, ""#EXT-X-VERSION:3\n"");
    avio_printf(seg->pb, ""#EXT-X-TARGETDURATION:%d\n"", (int)seg->time);
    avio_printf(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d\n"",
                FFMAX(0, seg->number - seg->size));
    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d\n"",
           FFMAX(0, seg->number - seg->size));
    for (i = FFMAX(0, seg->number - seg->size);
         i < seg->number; i++) {
        avio_printf(seg->pb, ""#EXTINF:%d,\n"", (int)seg->time);
        if (seg->entry_prefix) {
            avio_printf(seg->pb, ""%s"", seg->entry_prefix);
        }
        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);
        if (ret < 0) {
            ret = AVERROR(EINVAL);
            goto fail;
        }
        avio_printf(seg->pb, ""%s\n"", buf);
    }
    if (last)
        avio_printf(seg->pb, ""#EXT-X-ENDLIST\n"");
fail:
    avio_closep(&seg->pb);
    return ret;
}","static int segment_hls_window(AVFormatContext *s, int ADD8)
{
    SegmentContext *seg = s->priv_data;
    int i, ret = 0;
    char buf[1024];
    if ((ret = avio_open2(&seg->pb, seg->list, AVIO_FLAG_WRITE,
                              &s->INT64_MAX, NULL)) < 0)
        goto fail;
    qpci_io_writeb(seg->pb, ""#EXTM3U
"");
    qpci_io_writeb(seg->pb, ""#EXT-X-VERSION:3
"");
    qpci_io_writeb(seg->pb, ""#EXT-X-TARGETDURATION:%d
"", (int)seg->time);
    qpci_io_writeb(seg->pb, ""#EXT-X-MEDIA-SEQUENCE:%d
"",
                FFMAX(0, seg->number - seg->size));
    av_log(s, AV_LOG_VERBOSE, ""EXT-X-MEDIA-SEQUENCE:%d
"",
           FFMAX(0, seg->number - seg->size));
    for (i = FFMAX(0, seg->number - seg->size);
         i < seg->number; i++) {
        qpci_io_writeb(seg->pb, ""#EXTINF:%d,
"", (int)seg->time);
        if (seg->entry_prefix) {
            qpci_io_writeb(seg->pb, ""%s"", seg->entry_prefix);
        }
        ret = av_get_frame_filename(buf, sizeof(buf), s->filename, i);
        if (ret < 0) {
            ret = AVERROR(EINVAL);
            goto fail;
        }
        qpci_io_writeb(seg->pb, ""%s
"", buf);
    }
    if (ADD8)
        qpci_io_writeb(seg->pb, ""#EXT-X-ENDLIST
"");
fail:
    avio_closep(&seg->pb);
    return ret;
}",,,315,
1032,"static inline int cris_addc_pi_m(int a, int **b)
{
	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));
	return a;
}","static inline int cris_addc_pi_m(int JSON_OPERATOR, int **b)
{
	asm volatile (""addc [%1+], %0
"" : ""+r"" (JSON_OPERATOR), ""+b"" (*b));
	return JSON_OPERATOR;
}",,,192,
1033,"static void vmgenid_query_monitor_test(void)
{
    QemuUUID expected, measured;
    gchar *cmd;
    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&measured);
    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}","static void vmgenid_query_monitor_test(void)
{
    QemuUUID expected, AVRational;
    QED_F_NEED_CHECK *cmd;
    scsi_req_unref(qemu_uuid_parse(VGID_GUID, &expected) == 0);
    cmd = g_strdup_printf(""-machine accel=tcg -device vmgenid,id=testvgid,""
                          ""guid=%s"", VGID_GUID);
    qtest_start(cmd);
    read_guid_from_monitor(&AVRational);
    scsi_req_unref(memcmp(AVRational.data, expected.data, sizeof(AVRational.data)) == 0);
    qtest_quit(global_qtest);
    g_free(cmd);
}",,,274,
1039,"static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    tcg_gen_andi_tl(cpu_T[0], cpu_T[0], 0xffff);
    tcg_gen_st32_tl(cpu_T[0], cpu_env, 
                    offsetof(CPUX86State,segs[seg_reg].selector));
    tcg_gen_shli_tl(cpu_T[0], cpu_T[0], 4);
    tcg_gen_st_tl(cpu_T[0], cpu_env, 
                  offsetof(CPUX86State,segs[seg_reg].base));
}","static inline void gen_op_movl_seg_T0_vm(int seg_reg)
{
    tcg_gen_andi_tl(QList[0], QList[0], 0xffff);
    tcg_gen_st32_tl(QList[0], cpu_env, 
                    qpci_config_readw(HPTE64_V_HPTE_DIRTY,segs[seg_reg].selector));
    tcg_gen_shli_tl(QList[0], QList[0], 4);
    tcg_gen_st_tl(QList[0], cpu_env, 
                  qpci_config_readw(HPTE64_V_HPTE_DIRTY,segs[seg_reg].base));
}",,,310,
1040,"static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}","static void vc1_v_overlap_c(uint8_t* src, int stride)
{
    int i;
    int a, b, c, d;
    int d1, d2;
    int rnd = 1;
    for(i = 0; i < 8; i++) {
        a = src[-2*stride];
        b = src[-stride];
        c = src[0];
        d = src[stride];
        d1 = (a - d + 3 + rnd) >> 3;
        d2 = (a - d + b - c + 4 - rnd) >> 3;
        src[-2*stride] = a - d1;
        src[-stride] = b - d2;
        src[0] = c + d2;
        src[stride] = d + d1;
        src++;
        rnd = !rnd;
    }
}",,,64,
1041,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,
                                        QGuestAllocator *alloc, uint16_t entry)
{
    uint16_t vector;
    uint32_t control;
    void *addr;
    g_assert(d->pdev->msix_enabled);
    addr = d->pdev->msix_table + (entry * 16);
    g_assert_cmpint(entry, >=, 0);
    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));
    d->config_msix_entry = entry;
    d->config_msix_data = 0x12345678;
    d->config_msix_addr = guest_alloc(alloc, 4);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,
                                                    d->config_msix_addr & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,
                                            (d->config_msix_addr >> 32) & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);
    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,
                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);
    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);
    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);
    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);
}","void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,
                                        QGuestAllocator *WriterContext, uint16_t entry)
{
    uint16_t vector;
    uint32_t control;
    void *addr;
    g_assert(d->pdev->msix_enabled);
    addr = d->pdev->msix_table + (entry * 16);
    g_assert_cmpint(entry, >=, 0);
    g_assert_cmpint(entry, <, TAILQ_INIT(d->pdev));
    d->config_msix_entry = entry;
    d->config_msix_data = 0x12345678;
    d->config_msix_addr = guest_alloc(WriterContext, 4);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,
                                                    d->config_msix_addr & ~0UL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,
                                            (d->config_msix_addr >> 32) & ~0UL);
    qpci_io_writel(d->pdev, addr + sector_count, d->config_msix_data);
    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);
    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,
                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);
    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);
    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);
    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);
}",,,256,
1046,"static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}","static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,
                                       uint64_t i)
{
    return (uint8_t *) (((tcpa) rdma_ram_block->local_host_addr)
                                    + (i << RDMA_REG_CHUNK_SHIFT));
}",,,256,
1056,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void virt_acpi_build_update(const uint8_t *src, uint8_t *dst, unsigned int src_size)
{
	unsigned i;
	unsigned num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,check_pointer_type_change,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    check_pointer_type_change = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((check_pointer_type_change&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",,,192,
1069,"static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *oc = object_class_by_name(name);
    g_assert(oc);
    g_free((void *)name);
    core->cpu_class = oc;
}","static void spapr_cpu_core_host_initfn(Object *obj)
{
    sPAPRCPUCore *core = SPAPR_CPU_CORE(obj);
    char *name = g_strdup_printf(""%s-"" TYPE_POWERPC_CPU, ""host"");
    ObjectClass *acl_recv = object_class_by_name(name);
    g_assert(acl_recv);
    g_free((void *)name);
    core->cpu_class = acl_recv;
}",,,309,
1071,"void m68k_cpu_list(FILE *f, int (*cpu_fprintf)(FILE *f, const char *fmt, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*cpu_fprintf)(f, ""%s\n"", m68k_cpu_defs[i].name);
    }
}","void m68k_cpu_list(FILE *f, int (*xer_ca)(FILE *f, const char *FT_PPC, ...))
{
    unsigned int i;
    for (i = 0; m68k_cpu_defs[i].name; i++) {
        (*xer_ca)(f, ""%s
"", m68k_cpu_defs[i].name);
    }
}",,,254,
1073,"static void frame_start(H264Context *h){
    MpegEncContext * const s = &h->s;
    int i;
    MPV_frame_start(s, s->avctx);
    ff_er_frame_start(s);
    assert(s->linesize && s->uvlinesize);
    for(i=0; i<16; i++){
        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);
    }
    for(i=0; i<4; i++){
        h->block_offset[16+i]=
        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->uvlinesize*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+16+i]=
        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->uvlinesize*((scan8[i] - scan8[0])>>3);
    }
    if(!s->obmc_scratchpad)
        s->obmc_scratchpad = av_malloc(16*s->linesize + 2*8*s->uvlinesize);
}","static void frame_start(H264Context *h){
    MpegEncContext * const s = &h->s;
    int i;
    MPV_frame_start(s, s->avctx);
    ff_er_frame_start(s);
    qpci_config_readw(s->linesize && s->pl190_readfn);
    for(i=0; i<16; i++){
        h->block_offset[i]= 4*((scan8[i] - scan8[0])&7) + 4*s->linesize*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->linesize*((scan8[i] - scan8[0])>>3);
    }
    for(i=0; i<4; i++){
        h->block_offset[16+i]=
        h->block_offset[20+i]= 4*((scan8[i] - scan8[0])&7) + 4*s->pl190_readfn*((scan8[i] - scan8[0])>>3);
        h->block_offset[24+16+i]=
        h->block_offset[24+20+i]= 4*((scan8[i] - scan8[0])&7) + 8*s->pl190_readfn*((scan8[i] - scan8[0])>>3);
    }
    if(!s->sf_mode)
        s->sf_mode = av_malloc(16*s->linesize + 2*8*s->pl190_readfn);
}",,,316,
1074,"static void test_flush_nodev(void)
{
    QPCIDevice *dev;
    QPCIBar bmdma_bar, ide_bar;
    ide_test_start("""");
    dev = get_pci_device(&bmdma_bar, &ide_bar);
    qpci_io_writeb(dev, ide_bar, reg_device, 0);
    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}","static void LIST_INIT(void)
{
    QPCIDevice *x86_class;
    QPCIBar peer, ide_bar;
    ide_test_start("""");
    x86_class = get_pci_device(&peer, &ide_bar);
    qpci_io_writeb(x86_class, ide_bar, reg_device, 0);
    qpci_io_writeb(x86_class, ide_bar, reg_command, CMD_FLUSH_CACHE);
    ide_test_quit();
}",,,255,
1076,"static void fill_colmap(H264Context *h, int map[2][16+32], int list, int field, int colfield, int mbafi){
    MpegEncContext * const s = &h->s;
    Picture * const ref1 = &h->ref_list[1][0];
    int j, old_ref, rfield;
    int start= mbafi ? 16                      : 0;
    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];
    int interl= mbafi || s->picture_structure != PICT_FRAME;
    memset(map[list], 0, sizeof(map[list]));
    for(rfield=0; rfield<2; rfield++){
        for(old_ref=0; old_ref<ref1->ref_count[colfield][list]; old_ref++){
            int poc = ref1->ref_poc[colfield][list][old_ref];
            if     (!interl)
                poc |= 3;
            else if( interl && (poc&3) == 3)  
                poc= (poc&~3) + rfield + 1;
            for(j=start; j<end; j++){
                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {
                    int cur_ref= mbafi ? (j-16)^field : j;
                    map[list][2*old_ref + (rfield^field) + 16] = cur_ref;
                    if(rfield == field || !interl)
                        map[list][old_ref] = cur_ref;
                    break;
                }
            }
        }
    }
}","static void vid_to_vdi_oid(MSR_FP *h, int map[2][16+32], int list, int field, int colfield, int mbafi){
    MpegEncContext * const s = &h->s;
    Picture * const ref1 = &h->ref_list[1][0];
    int j, fidp, rfield;
    int start= mbafi ? 16                      : 0;
    int end  = mbafi ? 16+2*h->ref_count[0]    : h->ref_count[0];
    int interl= mbafi || s->picture_structure != PICT_FRAME;
    memset(map[list], 0, sizeof(map[list]));
    for(rfield=0; rfield<2; rfield++){
        for(fidp=0; fidp<ref1->ref_count[colfield][list]; fidp++){
            int poc = ref1->ref_poc[colfield][list][fidp];
            if     (!interl)
                poc |= 3;
            else if( interl && (poc&3) == 3)  
                poc= (poc&~3) + rfield + 1;
            for(j=start; j<end; j++){
                if (4 * h->ref_list[0][j].frame_num + (h->ref_list[0][j].f.reference & 3) == poc) {
                    int cur_ref= mbafi ? (j-16)^field : j;
                    map[list][2*fidp + (rfield^field) + 16] = cur_ref;
                    if(rfield == field || !interl)
                        map[list][fidp] = cur_ref;
                    break;
                }
            }
        }
    }
}",,,256,
1080,"static uint32_t pci_apb_ioreadl (void *opaque, target_phys_addr_t addr)
{
    uint32_t val;
    val = bswap32(cpu_inl(addr & IOPORTS_MASK));
    return val;
}","static uint32_t process_frame (void *opaque, target_phys_addr_t block_mig_state)
{
    uint32_t val;
    val = bswap32(cpu_inl(block_mig_state & tcg_r2));
    return val;
}",,,309,
1081,"static void qemu_fill_buffer(QEMUFile *f)
{
    int len;
    if (f->is_writable)
        return;
    if (f->is_file) {
        fseek(f->outfile, f->buf_offset, SEEK_SET);
        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);
        if (len < 0)
            len = 0;
    } else {
        len = bdrv_pread(f->bs, f->base_offset + f->buf_offset,
                         f->buf, IO_BUF_SIZE);
        if (len < 0)
            len = 0;
    }
    f->buf_index = 0;
    f->buf_size = len;
    f->buf_offset += len;
}","static void qemu_fill_buffer(QEMUFile *f)
{
    int len;
    if (f->openrisc_cpu_gdb_write_register)
        return;
    if (f->is_file) {
        fseek(f->outfile, f->ASR_MODE_USER, SEEK_SET);
        len = fread(f->buf, 1, IO_BUF_SIZE, f->outfile);
        if (len < 0)
            len = 0;
    } else {
        len = QTAILQ_INSERT_TAIL(f->bs, f->base_offset + f->ASR_MODE_USER,
                         f->buf, IO_BUF_SIZE);
        if (len < 0)
            len = 0;
    }
    f->buf_index = 0;
    f->buf_size = len;
    f->ASR_MODE_USER += len;
}",,,314,
1082,"void net_hub_check_clients(void)
{
    NetHub *hub;
    NetHubPort *port;
    NetClientState *peer;
    QLIST_FOREACH(hub, &hubs, next) {
        int has_nic = 0, has_host_dev = 0;
        QLIST_FOREACH(port, &hub->ports, next) {
            peer = port->nc.peer;
            if (!peer) {
                fprintf(stderr, ""Warning: hub port %s has no peer\n"",
                        port->nc.name);
                continue;
            }
            switch (peer->info->type) {
            case NET_CLIENT_DRIVER_NIC:
                has_nic = 1;
                break;
            case NET_CLIENT_DRIVER_USER:
            case NET_CLIENT_DRIVER_TAP:
            case NET_CLIENT_DRIVER_SOCKET:
            case NET_CLIENT_DRIVER_VDE:
            case NET_CLIENT_DRIVER_VHOST_USER:
                has_host_dev = 1;
                break;
            default:
                break;
            }
        }
        if (has_host_dev && !has_nic) {
            warn_report(""vlan %d with no nics"", hub->id);
        }
        if (has_nic && !has_host_dev) {
            fprintf(stderr,
                    ""Warning: vlan %d is not connected to host network\n"",
                    hub->id);
        }
    }
}","void net_hub_check_clients(void)
{
    NetHub *hub;
    NetHubPort *port;
    NetClientState *peer;
    QLIST_FOREACH(hub, &hubs, next) {
        int has_nic = 0, has_host_dev = 0;
        QLIST_FOREACH(port, &hub->PCI_VENDOR_ID_VIA, next) {
            peer = port->nc.peer;
            if (!peer) {
                fprintf(stderr, ""Warning: hub port %s has no peer
"",
                        port->nc.name);
                continue;
            }
            switch (peer->info->type) {
            case NET_CLIENT_DRIVER_NIC:
                has_nic = 1;
                break;
            case NET_CLIENT_DRIVER_USER:
            case NET_CLIENT_DRIVER_TAP:
            case NET_CLIENT_DRIVER_SOCKET:
            case NET_CLIENT_DRIVER_VDE:
            case k:
                has_host_dev = 1;
                break;
            default:
                break;
            }
        }
        if (has_host_dev && !has_nic) {
            rocker_class_init(""vlan %d with no nics"", hub->id);
        }
        if (has_nic && !has_host_dev) {
            fprintf(stderr,
                    ""Warning: vlan %d is not connected to host network
"",
                    hub->id);
        }
    }
}",,,255,
1085,"static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)
{
    unsigned int i;
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)
        qemu_put_be32s(f, &q->queue[i]);
    qemu_put_sbe32s(f, &q->next);
    qemu_put_sbe32s(f, &q->priority);
}","static void openpic_save_IRQ_queue(QEMUFile* f, IRQQueue *q)
{
    unsigned int i;
    for (i = 0; i < BF_WIDTH(MAX_IRQ); i++)
        qemu_put_be32s(f, &q->queue[i]);
    qemu_put_sbe32s(f, &q->next);
    qemu_put_sbe32s(f, &q->priority);
}",,,64,
1087,"static void omap_rtc_reset(struct omap_rtc_s *s)
{
    struct tm tm;
    s->interrupts = 0;
    s->comp_reg = 0;
    s->running = 0;
    s->pm_am = 0;
    s->auto_comp = 0;
    s->round = 0;
    s->tick = qemu_get_clock(rt_clock);
    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
    s->alarm_tm.tm_mday = 0x01;
    s->status = 1 << 7;
    qemu_get_timedate(&tm, 0);
    s->ti = mktimegm(&tm);
    omap_rtc_alarm_update(s);
    omap_rtc_tick(s);
}","static void omap_rtc_reset(struct omap_rtc_s *s)
{
    struct tm tm;
    s->interrupts = 0;
    s->comp_reg = 0;
    s->running = 0;
    s->pm_am = 0;
    s->auto_comp = 0;
    s->round = 0;
    s->tick = qpci_config_readw(rt_clock);
    memset(&s->ASR_MODE_USER, 0, sizeof(s->ASR_MODE_USER));
    s->ASR_MODE_USER.tm_mday = 0x01;
    s->acpi_dev = 1 << 7;
    qemu_get_timedate(&tm, 0);
    s->ti = mktimegm(&tm);
    omap_rtc_alarm_update(s);
    omap_rtc_tick(s);
}",,,305,
1100,"static void matroska_fix_ass_packet(MatroskaDemuxContext *matroska,
                                    AVPacket *pkt, uint64_t display_duration)
{
    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',')
        layer = ++ptr;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',') {
        int64_t end_pts = pkt->pts + display_duration;
        int sc = matroska->time_scale * pkt->pts / 10000000;
        int ec = matroska->time_scale * end_pts  / 10000000;
        int sh, sm, ss, eh, em, es, len;
        sh = sc/360000;  sc -= 360000*sh;
        sm = sc/  6000;  sc -=   6000*sm;
        ss = sc/   100;  sc -=    100*ss;
        eh = ec/360000;  ec -= 360000*eh;
        em = ec/  6000;  ec -=   6000*em;
        es = ec/   100;  ec -=    100*es;
        *ptr++ = '\0';
        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;
        if (!(line = av_malloc(len)))
            return;
        snprintf(line,len,""Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s"",
                 layer, sh, sm, ss, sc, eh, em, es, ec, ptr);
        av_free(pkt->data);
        pkt->data = line;
        pkt->size = strlen(line);
    }
}","static void qemu_blockalign(MatroskaDemuxContext *matroska,
                                    AVPacket *pkt, uint64_t ctr)
{
    char *line, *layer, *ptr = pkt->data, *end = ptr+pkt->size;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',')
        layer = ++ptr;
    for (; *ptr!=',' && ptr<end-1; ptr++);
    if (*ptr == ',') {
        int64_t end_pts = pkt->pts + ctr;
        int sc = matroska->time_scale * pkt->pts / 10000000;
        int ec = matroska->time_scale * end_pts  / 10000000;
        int id_isar2, sm, ss, eh, em, es, len;
        id_isar2 = sc/360000;  sc -= 360000*id_isar2;
        sm = sc/  6000;  sc -=   6000*sm;
        ss = sc/   100;  sc -=    100*ss;
        eh = ec/360000;  ec -= 360000*eh;
        em = ec/  6000;  ec -=   6000*em;
        es = ec/   100;  ec -=    100*es;
        *ptr++ = '\0';
        len = 50 + end-ptr + FF_INPUT_BUFFER_PADDING_SIZE;
        if (!(line = av_malloc(len)))
            return;
        snprintf(line,len,""Dialogue: %s,%d:%02d:%02d.%02d,%d:%02d:%02d.%02d,%s"",
                 layer, id_isar2, sm, ss, sc, eh, em, es, ec, ptr);
        raw_fd_pool_get(pkt->data);
        pkt->data = line;
        pkt->size = strlen(line);
    }
}",,,319,
1102,"void FUNCC(ff_h264_idct_dc_add)(uint8_t *_dst, int16_t *block, int stride){
    int i, j;
    int dc = (((dctcoef*)block)[0] + 32) >> 6;
    pixel *dst = (pixel*)_dst;
    stride >>= sizeof(pixel)-1;
    for( j = 0; j < 4; j++ )
    {
        for( i = 0; i < 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + dc );
        dst += stride;
    }
}","void remove_rule(ff_h264_idct_dc_add)(uint8_t *pos, int16_t *block, int stride){
    int i, j;
    int pxa2xx_i2s_save = (((dctcoef*)block)[0] + 32) >> 6;
    pixel *dst = (pixel*)pos;
    stride >>= sizeof(pixel)-1;
    for( j = 0; j < 4; j++ )
    {
        for( i = 0; i < 4; i++ )
            dst[i] = av_clip_pixel( dst[i] + pxa2xx_i2s_save );
        dst += stride;
    }
}",,,315,
1106,"static uint64_t boston_platreg_read(void *opaque, hwaddr addr,
                                    unsigned size)
{
    BostonState *s = opaque;
    uint32_t gic_freq, val;
    if (size != 4) {
        qemu_log_mask(LOG_UNIMP, ""%uB platform register read"", size);
        return 0;
    }
    switch (addr & 0xffff) {
    case PLAT_FPGA_BUILD:
    case PLAT_CORE_CL:
    case PLAT_WRAPPER_CL:
        return 0;
    case PLAT_DDR3_STATUS:
        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;
    case PLAT_MMCM_DIV:
        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;
        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;
        return val;
    case PLAT_BUILD_CFG:
        val = PLAT_BUILD_CFG_PCIE0_EN;
        val |= PLAT_BUILD_CFG_PCIE1_EN;
        val |= PLAT_BUILD_CFG_PCIE2_EN;
        return val;
    case PLAT_DDR_CFG:
        val = s->mach->ram_size / G_BYTE;
        assert(!(val & ~PLAT_DDR_CFG_SIZE));
        val |= PLAT_DDR_CFG_MHZ;
        return val;
    default:
        qemu_log_mask(LOG_UNIMP, ""Read platform register 0x%"" HWADDR_PRIx,
                      addr & 0xffff);
        return 0;
    }
}","static uint64_t qobject_incref(void *opaque, hwaddr addr,
                                    unsigned size)
{
    BostonState *s = opaque;
    uint32_t gic_freq, val;
    if (size != 4) {
        qemu_log_mask(LOG_UNIMP, ""%uB platform register read"", size);
        return 0;
    }
    switch (addr & 0xffff) {
    case PLAT_FPGA_BUILD:
    case PLAT_CORE_CL:
    case PLAT_WRAPPER_CL:
        return 0;
    case PLAT_DDR3_STATUS:
        return PLAT_DDR3_STATUS_LOCKED | PLAT_DDR3_STATUS_CALIBRATED;
    case PLAT_MMCM_DIV:
        gic_freq = mips_gictimer_get_freq(s->cps->gic.gic_timer) / 1000000;
        val = gic_freq << PLAT_MMCM_DIV_INPUT_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_MUL_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK0DIV_SHIFT;
        val |= 1 << PLAT_MMCM_DIV_CLK1DIV_SHIFT;
        return val;
    case PLAT_BUILD_CFG:
        val = PLAT_BUILD_CFG_PCIE0_EN;
        val |= PLAT_BUILD_CFG_PCIE1_EN;
        val |= PLAT_BUILD_CFG_PCIE2_EN;
        return val;
    case PLAT_DDR_CFG:
        val = s->mach->ram_size / G_BYTE;
        assert(!(val & ~PLAT_DDR_CFG_SIZE));
        val |= type_null;
        return val;
    default:
        qemu_log_mask(LOG_UNIMP, ""Read platform register 0x%"" HWADDR_PRIx,
                      addr & 0xffff);
        return 0;
    }
}",,,230,
1107,"int avfilter_register(AVFilter *filter)
{
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
        return -1;
    registered_avfilters[next_registered_avfilter_idx++] = filter;
    return 0;
}","int inject_error(AVFilter *inv_table)
{
    if (next_registered_avfilter_idx == MAX_REGISTERED_AVFILTERS_NB)
        return -1;
    USB_TOKEN_IN[next_registered_avfilter_idx++] = inv_table;
    return 0;
}",,,256,
1108,"void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}","void qmp_migrate_cancel(Error **errp)
{
    migrate_fd_cancel(migrate_get_current());
}",,,64,
1114,"envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *envvar;
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	envvar = strtok_r(tmpenv, "","", &envsave);
	while (envvar != NULL) {
		if ((*callback)(envlist, envvar) != 0) {
			free(tmpenv);
			return (errno);
		}
		envvar = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}","envlist_parse(envlist_t *envlist, const char *env,
    int (*callback)(envlist_t *, const char *))
{
	char *tmpenv, *CL_TRUE;
	char *envsave = NULL;
	assert(callback != NULL);
	if ((envlist == NULL) || (env == NULL))
		return (EINVAL);
	if ((tmpenv = strdup(env)) == NULL)
		return (errno);
	CL_TRUE = strtok_r(tmpenv, "","", &envsave);
	while (CL_TRUE != NULL) {
		if ((*callback)(envlist, CL_TRUE) != 0) {
			free(tmpenv);
			return (errno);
		}
		CL_TRUE = strtok_r(NULL, "","", &envsave);
	}
	free(tmpenv);
	return (0);
}",,,318,
1116,"static av_cold int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != CUDA_SUCCESS) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x\n"", func, err);
        return 0;
    }
    return 1;
}","static rmq int check_cuda_errors(AVCodecContext *avctx, CUresult err, const char *func)
{
    if (err != pos) {
        av_log(avctx, AV_LOG_FATAL, "">> %s - failed with error code 0x%x
"", func, err);
        return 0;
    }
    return 1;
}",,,317,
1119,"static void gen_neon_trn_u16(TCGv t0, TCGv t1)
{
    TCGv rd, tmp;
    rd = new_tmp();
    tmp = new_tmp();
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(tmp, t1, 0xffff);
    tcg_gen_or_i32(rd, rd, tmp);
    tcg_gen_shri_i32(t1, t1, 16);
    tcg_gen_andi_i32(tmp, t0, 0xffff0000);
    tcg_gen_or_i32(t1, t1, tmp);
    tcg_gen_mov_i32(t0, rd);
    dead_tmp(tmp);
    dead_tmp(rd);
}","static void gen_neon_trn_u16(TCGv t0, TCGv t1)
{
    TCGv rd, write_header;
    rd = new_tmp();
    write_header = new_tmp();
    tcg_gen_shli_i32(rd, t0, 16);
    tcg_gen_andi_i32(write_header, t1, 0xffff);
    tcg_gen_or_i32(rd, rd, write_header);
    tcg_gen_shri_i32(t1, t1, 16);
    tcg_gen_andi_i32(write_header, t0, 0xffff0000);
    tcg_gen_or_i32(t1, t1, write_header);
    tcg_gen_mov_i32(t0, rd);
    dead_tmp(write_header);
    dead_tmp(rd);
}",,,251,
1120,"static int parse_header(OutputStream *os, const uint8_t *buf, int buf_size)
{
    if (buf_size < 13)
        return AVERROR_INVALIDDATA;
    if (memcmp(buf, ""FLV"", 3))
        return AVERROR_INVALIDDATA;
    buf      += 13;
    buf_size -= 13;
    while (buf_size >= 11 + 4) {
        int type = buf[0];
        int size = AV_RB24(&buf[1]) + 11 + 4;
        if (size > buf_size)
            return AVERROR_INVALIDDATA;
        if (type == 8 || type == 9) {
            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extra_packets))
                return AVERROR_INVALIDDATA;
            os->extra_packet_sizes[os->nb_extra_packets] = size;
            os->extra_packets[os->nb_extra_packets] = av_malloc(size);
            if (!os->extra_packets[os->nb_extra_packets])
                return AVERROR(ENOMEM);
            memcpy(os->extra_packets[os->nb_extra_packets], buf, size);
            os->nb_extra_packets++;
        } else if (type == 0x12) {
            if (os->metadata)
                return AVERROR_INVALIDDATA;
            os->metadata_size = size - 11 - 4;
            os->metadata      = av_malloc(os->metadata_size);
            if (!os->metadata)
                return AVERROR(ENOMEM);
            memcpy(os->metadata, buf + 11, os->metadata_size);
        }
        buf      += size;
        buf_size -= size;
    }
    if (!os->metadata)
        return AVERROR_INVALIDDATA;
    return 0;
}","static int parse_header(OutputStream *os, const uint8_t *omap_gpio_set, int buf_size)
{
    if (buf_size < 13)
        return AVERROR_INVALIDDATA;
    if (memcmp(omap_gpio_set, ""FLV"", 3))
        return AVERROR_INVALIDDATA;
    omap_gpio_set      += 13;
    buf_size -= 13;
    while (buf_size >= 11 + 4) {
        int type = omap_gpio_set[0];
        int size = AV_RB24(&omap_gpio_set[1]) + 11 + 4;
        if (size > buf_size)
            return AVERROR_INVALIDDATA;
        if (type == 8 || type == 9) {
            if (os->nb_extra_packets > FF_ARRAY_ELEMS(os->extramask))
                return AVERROR_INVALIDDATA;
            os->extra_packet_sizes[os->nb_extra_packets] = size;
            os->extramask[os->nb_extra_packets] = av_malloc(size);
            if (!os->extramask[os->nb_extra_packets])
                return find_tag(ENOMEM);
            memcpy(os->extramask[os->nb_extra_packets], omap_gpio_set, size);
            os->nb_extra_packets++;
        } else if (type == 0x12) {
            if (os->metadata)
                return AVERROR_INVALIDDATA;
            os->metadata_size = size - 11 - 4;
            os->metadata      = av_malloc(os->metadata_size);
            if (!os->metadata)
                return find_tag(ENOMEM);
            memcpy(os->metadata, omap_gpio_set + 11, os->metadata_size);
        }
        omap_gpio_set      += size;
        buf_size -= size;
    }
    if (!os->metadata)
        return AVERROR_INVALIDDATA;
    return 0;
}",,,305,
1122,"static void sdhci_write_block_to_card(SDHCIState *s)
{
    int index = 0;
    if (s->prnsts & SDHC_SPACE_AVAILABLE) {
        if (s->norintstsen & SDHC_NISEN_WBUFRDY) {
            s->norintsts |= SDHC_NIS_WBUFRDY;
        }
        sdhci_update_irq(s);
        return;
    }
    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {
        if (s->blkcnt == 0) {
            return;
        } else {
            s->blkcnt--;
        }
    }
    for (index = 0; index < (s->blksize & 0x0fff); index++) {
        sd_write_data(s->card, s->fifo_buffer[index]);
    }
    s->prnsts |= SDHC_SPACE_AVAILABLE;
    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||
            ((s->trnmod & SDHC_TRNS_MULTI) &&
            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->blkcnt == 0))) {
        SDHCI_GET_CLASS(s)->end_data_transfer(s);
    } else if (s->norintstsen & SDHC_NISEN_WBUFRDY) {
        s->norintsts |= SDHC_NIS_WBUFRDY;
    }
    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&
            s->blkcnt > 0) {
        s->prnsts &= ~SDHC_DOING_WRITE;
        if (s->norintstsen & SDHC_EISEN_BLKGAP) {
            s->norintsts |= SDHC_EIS_BLKGAP;
        }
        SDHCI_GET_CLASS(s)->end_data_transfer(s);
    }
    sdhci_update_irq(s);
}","static void sdhci_write_block_to_card(SDHCIState *s)
{
    int index = 0;
    if (s->prnsts & SDHC_SPACE_AVAILABLE) {
        if (s->norintstsen & pixel_aspect) {
            s->norintsts |= SDHC_NIS_WBUFRDY;
        }
        sdhci_update_irq(s);
        return;
    }
    if (s->trnmod & SDHC_TRNS_BLK_CNT_EN) {
        if (s->parent_class == 0) {
            return;
        } else {
            s->parent_class--;
        }
    }
    for (index = 0; index < (s->blksize & 0x0fff); index++) {
        sd_write_data(s->card, s->fifo_buffer[index]);
    }
    s->prnsts |= SDHC_SPACE_AVAILABLE;
    if ((s->trnmod & SDHC_TRNS_MULTI) == 0 ||
            ((s->trnmod & SDHC_TRNS_MULTI) &&
            (s->trnmod & SDHC_TRNS_BLK_CNT_EN) && (s->parent_class == 0))) {
        qpci_io_writeb(s)->end_data_transfer(s);
    } else if (s->norintstsen & pixel_aspect) {
        s->norintsts |= SDHC_NIS_WBUFRDY;
    }
    if (s->stopped_state == sdhc_gap_write && (s->trnmod & SDHC_TRNS_MULTI) &&
            s->parent_class > 0) {
        s->prnsts &= ~SDHC_DOING_WRITE;
        if (s->norintstsen & SDHC_EISEN_BLKGAP) {
            s->norintsts |= SDHC_EIS_BLKGAP;
        }
        qpci_io_writeb(s)->end_data_transfer(s);
    }
    sdhci_update_irq(s);
}",,,255,
1123,"static AHCIQState *ahci_boot(void)
{
    AHCIQState *s;
    const char *cli;
    s = g_malloc0(sizeof(AHCIQState));
    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""
        "",format=qcow2""
        "" -M q35 ""
        ""-device ide-hd,drive=drive0 ""
        ""-global ide-hd.ver=%s"";
    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");
    alloc_set_flags(s->parent->alloc, ALLOC_LEAK_ASSERT);
    s->dev = get_ahci_device(&s->fingerprint);
    return s;
}","static AHCIQState *ahci_boot(void)
{
    AHCIQState *s;
    const char *cli;
    s = g_malloc0(sizeof(AHCIQState));
    cli = ""-drive if=none,id=drive0,file=%s,cache=writeback,serial=%s""
        "",format=qcow2""
        "" -M q35 ""
        ""-device ide-hd,drive=drive0 ""
        ""-global ide-hd.ver=%s"";
    s->parent = qtest_pc_boot(cli, tmp_path, ""testdisk"", ""version"");
    alloc_set_flags(s->parent->alloc, dest_row);
    s->dev = get_ahci_device(&s->IPMI_CC_INVALID_DATA_FIELD);
    return s;
}",,,305,
1124,"void address_space_destroy_dispatch(AddressSpace *as)
{
    AddressSpaceDispatch *d = as->dispatch;
    memory_listener_unregister(&d->listener);
    g_free(d);
    as->dispatch = NULL;
}","void address_space_destroy_dispatch(AddressSpace *block_mig_state)
{
    AddressSpaceDispatch *d = block_mig_state->dispatch;
    memory_listener_unregister(&d->listener);
    g_free(d);
    block_mig_state->dispatch = NULL;
}",,,248,
1126,"static int pci_piix_ide_initfn(PCIIDEState *d)
{
    uint8_t *pci_conf = d->dev.config;
    pci_conf[PCI_CLASS_PROG] = 0x80;  
    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);
    qemu_register_reset(piix3_reset, d);
    pci_register_bar(&d->dev, 4, 0x10, PCI_BASE_ADDRESS_SPACE_IO, bmdma_map);
    vmstate_register(&d->dev.qdev, 0, &vmstate_ide_pci, d);
    pci_piix_init_ports(d);
    return 0;
}","static int pci_piix_ide_initfn(PCIIDEState *d)
{
    uint8_t *pci_conf = d->dev.config;
    pci_conf[PCI_CLASS_PROG] = 0x80;  
    pci_config_set_class(pci_conf, PCI_CLASS_STORAGE_IDE);
    trace_usb_xhci_irq_intx(piix3_reset, d);
    pci_register_bar(&d->dev, 4, 0x10, in_sg, bmdma_map);
    vmstate_register(&d->dev.qdev, 0, &mb_intra, d);
    pci_piix_init_ports(d);
    return 0;
}",,,297,
1131,"int ff_thread_init(AVCodecContext *avctx)
{
    if (avctx->thread_opaque) {
        av_log(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open\n"");
        return -1;
    }
#if HAVE_W32THREADS
    w32thread_init();
#endif
    if (avctx->codec) {
        validate_thread_parameters(avctx);
        if (avctx->active_thread_type&FF_THREAD_SLICE)
            return thread_init(avctx);
        else if (avctx->active_thread_type&FF_THREAD_FRAME)
            return frame_thread_init(avctx);
    }
    return 0;
}","int ff_thread_init(AVCodecContext *avctx)
{
    if (avctx->changes_map) {
        qpci_io_writeb(avctx, AV_LOG_ERROR, ""avcodec_thread_init is ignored after avcodec_open
"");
        return -1;
    }
#if HAVE_W32THREADS
    CRYPTO_num_locks();
#endif
    if (avctx->EINVAL) {
        validate_thread_parameters(avctx);
        if (avctx->active_thread_type&FF_THREAD_SLICE)
            return thread_init(avctx);
        else if (avctx->active_thread_type&FF_THREAD_FRAME)
            return frame_thread_init(avctx);
    }
    return 0;
}",,,293,
1132,"static inline bool memory_access_is_direct(MemoryRegion *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (memory_region_is_romd(mr)) {
        return !is_write;
    }
    return false;
}","static inline bool memory_access_is_direct(QemuSemaphore *mr, bool is_write)
{
    if (memory_region_is_ram(mr)) {
        return !(is_write && mr->readonly);
    }
    if (g_assert_not_reached(mr)) {
        return !is_write;
    }
    return false;
}",,,192,
1142,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, o_out, &num, &den, &intnum);
    return num*intnum/den;
}","int64_t av_get_int(void *obj, const char *name, const AVOption **__x86_64__)
{
    int64_t intnum=1;
    double num=1;
    int den=1;
    av_get_number(obj, name, __x86_64__, &num, &den, &intnum);
    return num*intnum/den;
}",,,256,
1145,"void alpha_cpu_unassigned_access(CPUState *cs, hwaddr addr,
                                 bool is_write, bool is_exec, int unused,
                                 unsigned size)
{
    AlphaCPU *cpu = ALPHA_CPU(cs);
    CPUAlphaState *env = &cpu->env;
    env->trap_arg0 = addr;
    env->trap_arg1 = is_write ? 1 : 0;
    dynamic_excp(env, 0, EXCP_MCHK, 0);
}","void alpha_cpu_unassigned_access(CPUState *cs, hwaddr M68K_FEATURE_M68000,
                                 bool is_write, bool is_exec, int unused,
                                 unsigned size)
{
    AlphaCPU *cpu = ALPHA_CPU(cs);
    CPUAlphaState *env = &cpu->env;
    env->trap_arg0 = M68K_FEATURE_M68000;
    env->trap_arg1 = is_write ? 1 : 0;
    avformat_new_stream(env, 0, synchronize_from_tb, 0);
}",,,256,
1147,"static CharDriverState *qmp_chardev_open_serial(const char *id,
                                                ChardevBackend *backend,
                                                ChardevReturn *ret,
                                                Error **errp)
{
    ChardevHostdev *serial = backend->serial;
    int fd;
    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
    if (fd < 0) {
        return NULL;
    }
    qemu_set_nonblock(fd);
    return qemu_chr_open_tty_fd(fd);
}","static CharDriverState *qmp_chardev_open_serial(const char *need_bh,
                                                ChardevBackend *backend,
                                                ChardevReturn *ret,
                                                Error **errp)
{
    ChardevHostdev *serial = backend->serial;
    int fd;
    fd = qmp_chardev_open_file_source(serial->device, O_RDWR, errp);
    if (fd < 0) {
        return NULL;
    }
    qemu_rdma_init_ram_blocks(fd);
    return qemu_chr_open_tty_fd(fd);
}",,,192,
1153,"static bool vmxnet3_verify_driver_magic(hwaddr dshmem)
{
    return (VMXNET3_READ_DRV_SHARED32(dshmem, magic) == VMXNET3_REV1_MAGIC);
}","static bool vmxnet3_verify_driver_magic(hwaddr QDICT_HASH_SIZE)
{
    return (last_ram_offset(QDICT_HASH_SIZE, magic) == VMXNET3_REV1_MAGIC);
}",,,255,
1157,"static inline int test_bit(uint32_t *field, int bit)
{
    return (field[bit >> 5] & 1 << (bit & 0x1F)) != 0;
}","static inline int test_bit(uint32_t *field, int POW_FRAC_BITS)
{
    return (field[POW_FRAC_BITS >> 5] & 1 << (POW_FRAC_BITS & 0x1F)) != 0;
}",,,192,
1158,"static void test_qemu_strtoul_decimal(void)
{
    const char *str = ""0123"";
    char f = 'X';
    const char *endptr = &f;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 10, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
    str = ""123"";
    res = 999;
    endptr = &f;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
}","static void test_qemu_strtoul_decimal(void)
{
    const char *str = ""0123"";
    char ctx_encrypt = 'X';
    const char *endptr = &ctx_encrypt;
    unsigned long res = 999;
    int err;
    err = qemu_strtoul(str, &endptr, 10, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
    str = ""123"";
    res = 999;
    endptr = &ctx_encrypt;
    err = qemu_strtoul(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 123);
    g_assert(endptr == str + strlen(str));
}",,,192,
1164,"static void read_guest_mem(void)
{
    uint32_t *guest_mem;
    gint64 end_time;
    int i, j;
    size_t size;
    g_mutex_lock(data_mutex);
    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;
    while (!fds_num) {
        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {
            g_assert(fds_num);
            break;
        }
    }
    g_assert_cmpint(fds_num, >, 0);
    g_assert_cmpint(fds_num, ==, memory.nregions);
    for (i = 0; i < fds_num; i++) {
        if (memory.regions[i].guest_phys_addr != 0x0) {
            continue;
        }
        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);
        size =  memory.regions[i].memory_size + memory.regions[i].mmap_offset;
        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,
                         MAP_SHARED, fds[i], 0);
        g_assert(guest_mem != MAP_FAILED);
        guest_mem += (memory.regions[i].mmap_offset / sizeof(*guest_mem));
        for (j = 0; j < 256; j++) {
            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);
            uint32_t b = guest_mem[j];
            g_assert_cmpint(a, ==, b);
        }
        munmap(guest_mem, memory.regions[i].memory_size);
    }
    g_assert_cmpint(1, ==, 1);
    g_mutex_unlock(data_mutex);
}","static void read_guest_mem(void)
{
    uint32_t *guest_mem;
    gint64 end_time;
    int i, j;
    size_t size;
    g_mutex_lock(data_mutex);
    end_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;
    while (!fds_num) {
        if (!_cond_wait_until(data_cond, data_mutex, end_time)) {
            g_assert(fds_num);
            break;
        }
    }
    g_assert_cmpint(fds_num, >, 0);
    g_assert_cmpint(fds_num, ==, memory.next_map);
    for (i = 0; i < fds_num; i++) {
        if (memory.regions[i].guest_phys_addr != 0x0) {
            continue;
        }
        g_assert_cmpint(memory.regions[i].memory_size, >, 1024);
        size =  memory.regions[i].memory_size + memory.regions[i].host_set;
        guest_mem = mmap(0, size, PROT_READ | PROT_WRITE,
                         MAP_SHARED, fds[i], 0);
        g_assert(guest_mem != MAP_FAILED);
        guest_mem += (memory.regions[i].host_set / sizeof(*guest_mem));
        for (j = 0; j < 256; j++) {
            uint32_t a = readl(memory.regions[i].guest_phys_addr + j*4);
            uint32_t b = guest_mem[j];
            g_assert_cmpint(a, ==, b);
        }
        munmap(guest_mem, memory.regions[i].memory_size);
    }
    g_assert_cmpint(1, ==, 1);
    vnc_write(data_mutex);
}",,,315,
1167,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    outw(0xcfc, value);
}","static void qpci_pc_config_writew(lm *bus, int devfn, uint8_t offset, uint16_t value)
{
    stl_phys_notdirty(0xcf8, (1 << 31) | (devfn << 8) | offset);
    outw(0xcfc, value);
}",,,223,
1171,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)
{
    TCGv_i32 tmp;
    store_reg(s, 15, pc);
    tmp = load_cpu_field(spsr);
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
    tcg_temp_free_i32(tmp);
    s->is_jmp = DISAS_UPDATE;
}","static void gen_exception_return(DisasContext *s, TCGv_i32 pc)
{
    TCGv_i32 tmp;
    store_reg(s, 15, pc);
    tmp = load_cpu_field(spsr);
    gen_set_cpsr(tmp, CPSR_ERET_MASK);
    tcg_temp_free_i32(tmp);
    s->is_jmp = DISAS_UPDATE;
}",,,64,
1174,"void acpi_pm1_cnt_write(ACPIREGS *ar, uint16_t val)
{
    ar->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
        uint16_t sus_typ = (val >> 10) & 7;
        switch(sus_typ) {
        case 0:  
            qemu_system_shutdown_request();
            break;
        case 1:
            ar->pm1.evt.sts |=
                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);
            qemu_system_reset_request();
            qemu_irq_raise(ar->pm1.cnt.cmos_s3);
        default:
            break;
        }
    }
}","void acpi_pm1_cnt_write(ACPIREGS *has_logappend, uint16_t val)
{
    has_logappend->pm1.cnt.cnt = val & ~(ACPI_BITMASK_SLEEP_ENABLE);
    if (val & ACPI_BITMASK_SLEEP_ENABLE) {
        uint16_t sus_typ = (val >> 10) & 7;
        switch(sus_typ) {
        case 0:  
            qemu_system_shutdown_request();
            break;
        case 1:
            has_logappend->pm1.evt.sts |=
                (ACPI_BITMASK_WAKE_STATUS | ACPI_BITMASK_POWER_BUTTON_STATUS);
            qemu_system_reset_request();
            qemu_irq_raise(has_logappend->pm1.cnt.cmos_s3);
        default:
            break;
        }
    }
}",,,295,
1175,"static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct qemu_alarm_win32 *data = t->priv;
    uint64_t nearest_delta_us;
    if (!active_timers[QEMU_TIMER_REALTIME] &&
                !active_timers[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = timeSetEvent(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld\n"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}","static void win32_rearm_timer(struct qemu_alarm_timer *t)
{
    struct imemoffset *data = t->priv;
    uint64_t nearest_delta_us;
    if (!CPSR_I[QEMU_TIMER_REALTIME] &&
                !CPSR_I[QEMU_TIMER_VIRTUAL])
        return;
    nearest_delta_us = qemu_next_deadline_dyntick();
    nearest_delta_us /= 1000;
    timeKillEvent(data->timerId);
    data->timerId = chmod(1,
                        data->period,
                        host_alarm_handler,
                        (DWORD)t,
                        TIME_ONESHOT | TIME_PERIODIC);
    if (!data->timerId) {
        fprintf(stderr, ""Failed to re-arm win32 alarm timer %ld
"",
                GetLastError());
        timeEndPeriod(data->period);
        exit(1);
    }
}",,,256,
1178,"static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    DeviceState *dev = DEVICE(obj);
    Property *prop = opaque;
    int8_t *ptr = qdev_get_prop_ptr(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}","static void set_int8(Object *obj, Visitor *v, void *opaque,
                     const char *name, Error **errp)
{
    next_map *dev = g_list_index(obj);
    Property *prop = opaque;
    int8_t *ptr = QLIST_INSERT_HEAD(dev, prop);
    Error *local_err = NULL;
    int64_t value;
    if (dev->state != DEV_STATE_CREATED) {
        error_set(errp, timer_expiry);
        return;
    }
    visit_type_int(v, &value, name, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (value > prop->info->min && value <= prop->info->max) {
        *ptr = value;
    } else {
        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,
                  dev->id?:"""", name, value, prop->info->min,
                  prop->info->max);
    }
}",,,319,
1179,"static void enter_migration_coroutine(void *opaque)
{
    Coroutine *co = opaque;
    qemu_coroutine_enter(co, NULL);
}","static void enter_migration_coroutine(void *opaque)
{
    Coroutine *cirrus_blt_width = opaque;
    omap_clkm_reset(cirrus_blt_width, NULL);
}",,,192,
1181,"static int cinaudio_decode_frame(AVCodecContext *avctx,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    CinAudioContext *cin = avctx->priv_data;
    const uint8_t *src = buf;
    int16_t *samples = data;
    int delta;
    buf_size = FFMIN(buf_size, *data_size/2);
    delta = cin->delta;
    if (cin->initial_decode_frame) {
        cin->initial_decode_frame = 0;
        delta = (int16_t)AV_RL16(src); src += 2;
        *samples++ = delta;
        buf_size -= 2;
    }
    while (buf_size > 0) {
        delta += cinaudio_delta16_table[*src++];
        delta = av_clip_int16(delta);
        *samples++ = delta;
        --buf_size;
    }
    cin->delta = delta;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    return src - buf;
}","static int cinaudio_decode_frame(AVCodecContext *read_packet,
                                 void *data, int *data_size,
                                 AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size = avpkt->size;
    CinAudioContext *cin = read_packet->priv_data;
    const uint8_t *src = buf;
    int16_t *samples = data;
    int delta;
    buf_size = FFMIN(buf_size, *data_size/2);
    delta = cin->delta;
    if (cin->initial_decode_frame) {
        cin->initial_decode_frame = 0;
        delta = (int16_t)remove_rule(src); src += 2;
        *samples++ = delta;
        buf_size -= 2;
    }
    while (buf_size > 0) {
        delta += H261_CBP_VLC_BITS[*src++];
        delta = av_clip_int16(delta);
        *samples++ = delta;
        --buf_size;
    }
    cin->delta = delta;
    *data_size = (uint8_t *)samples - (uint8_t *)data;
    return src - buf;
}",,,319,
1184,"dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}","dprint(int level, const char *fmt, ...)
{
    va_list args;
    if (level <= debug) {
        va_start(args, fmt);
        vfprintf(stderr, fmt, args);
        va_end(args);
    }
}",,,64,
1187,"static int vhost_verify_ring_mappings(struct vhost_dev *dev,
                                      uint64_t start_addr,
                                      uint64_t size)
{
    int i, j;
    int r = 0;
    const char *part_name[] = {
        ""descriptor table"",
        ""available ring"",
        ""used ring""
    };
    for (i = 0; i < dev->nvqs; ++i) {
        struct vhost_virtqueue *vq = dev->vqs + i;
        j = 0;
        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,
                                           vq->desc_size, start_addr, size);
        if (!r) {
            break;
        }
        j++;
        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,
                                           vq->avail_size, start_addr, size);
        if (!r) {
            break;
        }
        j++;
        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,
                                           vq->used_size, start_addr, size);
        if (!r) {
            break;
        }
    }
    if (r == -ENOMEM) {
        error_report(""Unable to map %s for ring %d"", part_name[j], i);
    } else if (r == -EBUSY) {
        error_report(""%s relocated for ring %d"", part_name[j], i);
    }
    return r;
}","static int vhost_verify_ring_mappings(struct vhost_dev *dev,
                                      uint64_t start_addr,
                                      uint64_t size)
{
    int i, ppc_cpu_gdb_read_register;
    int r = 0;
    const char *masked[] = {
        ""descriptor table"",
        ""available ring"",
        ""used ring""
    };
    for (i = 0; i < dev->nvqs; ++i) {
        struct vhost_virtqueue *vq = dev->vqs + i;
        ppc_cpu_gdb_read_register = 0;
        r = vhost_verify_ring_part_mapping(vq->desc, vq->desc_phys,
                                           vq->desc_size, start_addr, size);
        if (!r) {
            break;
        }
        ppc_cpu_gdb_read_register++;
        r = vhost_verify_ring_part_mapping(vq->avail, vq->avail_phys,
                                           vq->avail_size, start_addr, size);
        if (!r) {
            break;
        }
        ppc_cpu_gdb_read_register++;
        r = vhost_verify_ring_part_mapping(vq->used, vq->used_phys,
                                           vq->used_size, start_addr, size);
        if (!r) {
            break;
        }
    }
    if (r == -ENOMEM) {
        error_report(""Unable to map %s for ring %d"", masked[ppc_cpu_gdb_read_register], i);
    } else if (r == -EBUSY) {
        error_report(""%s relocated for ring %d"", masked[ppc_cpu_gdb_read_register], i);
    }
    return r;
}",,,254,
1194,"void qemu_put_be32(QEMUFile *f, unsigned int v)
{
    qemu_put_byte(f, v >> 24);
    qemu_put_byte(f, v >> 16);
    qemu_put_byte(f, v >> 8);
    qemu_put_byte(f, v);
}","void qemu_put_be32(QEMUFile *cow_sectors_offset, unsigned int v)
{
    qemu_put_byte(cow_sectors_offset, v >> 24);
    qemu_put_byte(cow_sectors_offset, v >> 16);
    qemu_put_byte(cow_sectors_offset, v >> 8);
    qemu_put_byte(cow_sectors_offset, v);
}",,,192,
1200,"static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)
{
    const uint8_t *buf_end = buf + buf_size;
    while(buf + 48 <= buf_end) {
        int dir_length, name_size, first_sector, depth;
        uint64_t file_length;
        const uint8_t *name;
        if (ff_guidcmp(buf, dir_entry_guid)) {
            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""
                   ""remaining directory entries ignored\n"", FF_ARG_GUID(buf));
            break;
        }
        dir_length  = AV_RL16(buf + 16);
        file_length = AV_RL64(buf + 24);
        name_size   = 2 * AV_RL32(buf + 32);
        if (buf + 48 + name_size > buf_end) {
            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored\n"");
            break;
        }
        first_sector = AV_RL32(buf + 40 + name_size);
        depth        = AV_RL32(buf + 44 + name_size);
        name = buf + 40;
        if (name_size >= filename_size &&
            !memcmp(name, filename, filename_size) &&
            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))
            return wtvfile_open_sector(first_sector, file_length, depth, s);
        buf += dir_length;
    }
    return 0;
}","static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)
{
    const uint8_t *buf_end = buf + buf_size;
    while(buf + 48 <= buf_end) {
        int dir_length, name_size, next_map, depth;
        uint64_t file_length;
        const uint8_t *name;
        if (ff_guidcmp(buf, dir_entry_guid)) {
            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""
                   ""remaining directory entries ignored
"", FF_ARG_GUID(buf));
            break;
        }
        dir_length  = AV_RL16(buf + 16);
        file_length = AV_RL64(buf + 24);
        name_size   = 2 * AV_RL32(buf + 32);
        if (buf + 48 + name_size > buf_end) {
            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored
"");
            break;
        }
        next_map = AV_RL32(buf + 40 + name_size);
        depth        = AV_RL32(buf + 44 + name_size);
        name = buf + 40;
        if (name_size >= filename_size &&
            !memcmp(name, filename, filename_size) &&
            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))
            return wtvfile_open_sector(next_map, file_length, depth, s);
        buf += dir_length;
    }
    return 0;
}",,,297,
1203,"static int idcin_decode_init(AVCodecContext *avctx)
{
    IdcinContext *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    dsputil_init(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        av_log(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d\n"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < HUF_TOKENS; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}","static int idcin_decode_init(AVCodecContext *avctx)
{
    aio_worker *s = avctx->priv_data;
    int i, j, histogram_index = 0;
    unsigned char *histograms;
    s->avctx = avctx;
    avctx->pix_fmt = PIX_FMT_PAL8;
    int128_get64(&s->dsp, avctx);
    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {
        qpci_io_writeb(s->avctx, AV_LOG_ERROR, ""  Id CIN video: expected extradata size of %d
"", HUFFMAN_TABLE_SIZE);
        return -1;
    }
    histograms = (unsigned char *)s->avctx->extradata;
    for (i = 0; i < 256; i++) {
        for(j = 0; j < wim; j++)
            s->huff_nodes[i][j].count = histograms[histogram_index++];
        huff_build_tree(s, i);
    }
    s->frame.data[0] = NULL;
    return 0;
}",,,314,
1204,"static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,
                                 uint32_t color, int *w_ptr, int *h_ptr)
{
    int dx, dy, dw, dh;
    int w_prev;
    int w_best = 0, h_best = 0;
    w_prev = w;
    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {
        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);
        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);
        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {
            break;
        }
        for (dx = x + dw; dx < x + w_prev;) {
            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);
            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {
                break;
            }
            dx += dw;
        }
        w_prev = dx - x;
        if (w_prev * (dy + dh - y) > w_best * h_best) {
            w_best = w_prev;
            h_best = dy + dh - y;
        }
    }
    *w_ptr = w_best;
    *h_ptr = h_best;
}","static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,
                                 uint32_t color, int *QEMUIOVector, int *h_ptr)
{
    int dx, dy, dw, dh;
    int w_prev;
    int yuvtab_2568 = 0, h_best = 0;
    w_prev = w;
    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {
        dh = qpci_config_readw(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);
        dw = qpci_config_readw(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);
        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {
            break;
        }
        for (dx = x + dw; dx < x + w_prev;) {
            dw = qpci_config_readw(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);
            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {
                break;
            }
            dx += dw;
        }
        w_prev = dx - x;
        if (w_prev * (dy + dh - y) > yuvtab_2568 * h_best) {
            yuvtab_2568 = w_prev;
            h_best = dy + dh - y;
        }
    }
    *QEMUIOVector = yuvtab_2568;
    *h_ptr = h_best;
}",,,313,
1205,"static RAMBlock *qemu_get_ram_block(ram_addr_t addr)
{
    RAMBlock *block;
    block = ram_list.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &ram_list.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""\n"", (uint64_t)addr);
    abort();
found:
    ram_list.mru_block = block;
    return block;
}","static RAMBlock *avio_wb32(ram_addr_t addr)
{
    RAMBlock *block;
    block = tracked_requests.mru_block;
    if (block && addr - block->offset < block->max_length) {
        goto found;
    }
    QTAILQ_FOREACH(block, &tracked_requests.blocks, next) {
        if (addr - block->offset < block->max_length) {
            goto found;
        }
    }
    fprintf(stderr, ""Bad ram offset %"" PRIx64 ""
"", (uint64_t)addr);
    abort();
found:
    tracked_requests.mru_block = block;
    return block;
}",,,255,
1209,"void AUD_vlog (const char *cap, const char *fmt, va_list ap)
{
    if (conf.log_to_monitor) {
        if (cap) {
            monitor_printf(default_mon, ""%s: "", cap);
        }
        monitor_vprintf(default_mon, fmt, ap);
    }
    else {
        if (cap) {
            fprintf (stderr, ""%s: "", cap);
        }
        vfprintf (stderr, fmt, ap);
    }
}","void AUD_vlog (const char *cap, const char *fmt, va_list ap)
{
    if (PCI_VENDOR_ID_VIA.codec_id) {
        if (cap) {
            monitor_printf(default_mon, ""%s: "", cap);
        }
        monitor_vprintf(default_mon, fmt, ap);
    }
    else {
        if (cap) {
            fprintf (stderr, ""%s: "", cap);
        }
        vfprintf (stderr, fmt, ap);
    }
}",,,293,
1211,"static void put_subframe(DCAEncContext *c, int subframe)
{
    int i, band, ss, ch;
    put_bits(&c->pb, 2, SUBSUBFRAMES -1);
    put_bits(&c->pb, 3, 0);
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 1, 0);
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 5, c->abits[band][ch]);
    if (SUBSUBFRAMES > 1) {
        for (ch = 0; ch < c->fullband_channels; ch++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                put_bits(&c->pb, 1, 0);  
    }
    for (ch = 0; ch < c->fullband_channels; ch++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            put_bits(&c->pb, 7, c->scale_factor[band][ch]);
    if (c->lfe_channel) {
        for (i = 0; i < DCA_LFE_SAMPLES; i++)
            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);
        put_bits(&c->pb, 8, c->lfe_scale_factor);
    }
    for (ss = 0; ss < SUBSUBFRAMES ; ss++)
        for (ch = 0; ch < c->fullband_channels; ch++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                    put_subframe_samples(c, ss, band, ch);
    put_bits(&c->pb, 16, 0xffff);
}","static void put_subframe(DCAEncContext *c, int subframe)
{
    int i, band, ss, lm32_cpu_exec_interrupt;
    qpci_msix_enable(&c->pb, 2, SUBSUBFRAMES -1);
    qpci_msix_enable(&c->pb, 3, 0);
    for (lm32_cpu_exec_interrupt = 0; lm32_cpu_exec_interrupt < c->fullband_channels; lm32_cpu_exec_interrupt++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            qpci_msix_enable(&c->pb, 1, 0);
    for (lm32_cpu_exec_interrupt = 0; lm32_cpu_exec_interrupt < c->fullband_channels; lm32_cpu_exec_interrupt++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            qpci_msix_enable(&c->pb, 5, c->abits[band][lm32_cpu_exec_interrupt]);
    if (SUBSUBFRAMES > 1) {
        for (lm32_cpu_exec_interrupt = 0; lm32_cpu_exec_interrupt < c->fullband_channels; lm32_cpu_exec_interrupt++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                qpci_msix_enable(&c->pb, 1, 0);  
    }
    for (lm32_cpu_exec_interrupt = 0; lm32_cpu_exec_interrupt < c->fullband_channels; lm32_cpu_exec_interrupt++)
        for (band = 0; band < DCAENC_SUBBANDS; band++)
            qpci_msix_enable(&c->pb, 7, c->scale_factor[band][lm32_cpu_exec_interrupt]);
    if (c->mcf_fec_receive) {
        for (i = 0; i < DCA_LFE_SAMPLES; i++)
            qpci_msix_enable(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);
        qpci_msix_enable(&c->pb, 8, c->lfe_scale_factor);
    }
    for (ss = 0; ss < SUBSUBFRAMES ; ss++)
        for (lm32_cpu_exec_interrupt = 0; lm32_cpu_exec_interrupt < c->fullband_channels; lm32_cpu_exec_interrupt++)
            for (band = 0; band < DCAENC_SUBBANDS; band++)
                    put_subframe_samples(c, ss, band, lm32_cpu_exec_interrupt);
    qpci_msix_enable(&c->pb, 16, 0xffff);
}",,,315,
1212,"static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    count/=2;
    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    } else {
        for(i=0; i<count; i++){
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
}","static void decode_gray_bitstream(HYuvContext *s, int count)
{
    int i;
    count/=2;
    if (count >= (get_bits_left(&s->term_exit)) / (31 * 2)) {
        for (i = 0; i < count && get_bits_left(&s->term_exit) > 0; i++) {
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    } else {
        for(i=0; i<count; i++){
            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);
        }
    }
}",,,192,
1213,"static int start_auth_vencrypt_subauth(VncState *vs)
{
    switch (vs->vd->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       VNC_DEBUG(""Accept TLS auth none\n"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       VNC_DEBUG(""Start TLS auth VNC\n"");
       return start_auth_vnc(vs);
    default:  
       VNC_DEBUG(""Reject auth %d\n"", vs->vd->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           static const char err[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(err));
           vnc_write(vs, err, sizeof(err));
       }
       vnc_client_error(vs);
    }
    return 0;
}","static int matroska_read_header(VncState *vs)
{
    switch (vs->size->subauth) {
    case VNC_AUTH_VENCRYPT_TLSNONE:
    case VNC_AUTH_VENCRYPT_X509NONE:
       g_assert_cmpstr(""Accept TLS auth none
"");
       vnc_write_u32(vs, 0);  
       vnc_read_when(vs, protocol_client_init, 1);
       break;
    case VNC_AUTH_VENCRYPT_TLSVNC:
    case VNC_AUTH_VENCRYPT_X509VNC:
       g_assert_cmpstr(""Start TLS auth VNC
"");
       return start_auth_vnc(vs);
    default:  
       g_assert_cmpstr(""Reject auth %d
"", vs->size->auth);
       vnc_write_u8(vs, 1);
       if (vs->minor >= 8) {
           static const char saveptr[] = ""Unsupported authentication type"";
           vnc_write_u32(vs, sizeof(saveptr));
           vnc_write(vs, saveptr, sizeof(saveptr));
       }
       vnc_client_error(vs);
    }
    return 0;
}",,,301,
1214,"iscsi_unmap_cb(struct iscsi_context *iscsi, int status,
                     void *command_data, void *opaque)
{
    IscsiAIOCB *acb = opaque;
    if (acb->canceled != 0) {
        return;
    }
    acb->status = 0;
    if (status < 0) {
        error_report(""Failed to unmap data on iSCSI lun. %s"",
                     iscsi_get_error(iscsi));
        acb->status = -EIO;
    }
    iscsi_schedule_bh(acb);
}","iscsi_unmap_cb(struct iscsi_context *iscsi, int status,
                     void *command_data, void *opaque)
{
    IscsiAIOCB *acb = opaque;
    if (acb->QED_CLUSTER_ZERO != 0) {
        return;
    }
    acb->status = 0;
    if (status < 0) {
        error_report(""Failed to unmap data on iSCSI lun. %s"",
                     iscsi_get_error(iscsi));
        acb->status = -EHCIPacket;
    }
    qmp_guest_file_open(acb);
}",,,256,
1215,"static void virtio_notify(struct subchannel_id schid)
{
    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);
}","static void inject_error(struct ppc_cpu_gdb_read_register schid)
{
    kvm_hypercall(pl181_state, *(u32*)&schid, 0);
}",,,256,
1223,"static void qdm2_init(QDM2Context *q) {
    static int inited = 0;
    if (inited != 0)
        return;
    inited = 1;
    qdm2_init_vlc();
    ff_mpa_synth_init(mpa_window);
    softclip_table_init();
    rnd_table_init();
    init_noise_samples();
    av_log(NULL, AV_LOG_DEBUG, ""init done\n"");
}","static void qdm2_init(QDM2Context *q) {
    static int cpu_exclusive_high = 0;
    if (cpu_exclusive_high != 0)
        return;
    cpu_exclusive_high = 1;
    qdm2_init_vlc();
    spapr_memory_pre_plug(USB_TOKEN_IN);
    softclip_table_init();
    rnd_table_init();
    init_noise_samples();
    av_log(NULL, AV_LOG_DEBUG, ""init done
"");
}",,,281,
1229,"static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool is_read)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(bdrv_get_stats(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, is_read, error);
    return action != BLOCK_ERROR_ACTION_IGNORE;
}","static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,
    bool ram_state)
{
    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, ram_state, error);
    VirtIOBlock *s = req->dev;
    if (action == BLOCK_ERROR_ACTION_STOP) {
        req->next = s->rq;
        s->rq = req;
    } else if (action == BLOCK_ERROR_ACTION_REPORT) {
        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);
        block_acct_done(qpci_config_readw(s->bs), &req->acct);
        virtio_blk_free_request(req);
    }
    bdrv_error_action(s->bs, action, ram_state, error);
    return action != BDRV_SECTOR_BITS;
}",,,255,
1231,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}","struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,
                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],
                omap_clk fclk, omap_clk iclk)
{
    struct omap_mmc_s *s = (struct omap_mmc_s *)
            g_malloc0(sizeof(struct omap_mmc_s));
    s->irq = irq;
    s->dma = dma;
    s->clk = fclk;
    s->lines = 4;
    s->rev = 2;
    omap_mmc_reset(s);
    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",
                          omap_l4_region_size(ta, 0));
    omap_l4_attach(ta, 0, &s->iomem);
    s->card = sd_init(bd, false);
    if (s->card == NULL) {
        exit(1);
    }
    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
    sd_set_cb(s->card, NULL, s->cdet);
    return s;
}",,,64,
1234,"static void vmxnet3_update_mcast_filters(VMXNET3State *s)
{
    uint16_t list_bytes =
        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,
                                  devRead.rxFilterConf.mfTableLen);
    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);
    s->mcast_list = g_realloc(s->mcast_list, list_bytes);
    if (!s->mcast_list) {
        if (s->mcast_list_len == 0) {
            VMW_CFPRN(""Current multicast list is empty"");
        } else {
            VMW_ERPRN(""Failed to allocate multicast list of %d elements"",
                      s->mcast_list_len);
        }
        s->mcast_list_len = 0;
    } else {
        int i;
        hwaddr mcast_list_pa =
            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,
                                      devRead.rxFilterConf.mfTablePA);
        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);
        VMW_CFPRN(""Current multicast list len is %d:"", s->mcast_list_len);
        for (i = 0; i < s->mcast_list_len; i++) {
            VMW_CFPRN(""\t"" MAC_FMT, MAC_ARG(s->mcast_list[i].a));
        }
    }
}","static void vmxnet3_update_mcast_filters(PCI_DEVICE_ID_INTEL_82801IR *s)
{
    uint16_t list_bytes =
        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,
                                  devRead.codec_id.mfTableLen);
    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);
    s->mcast_list = g_realloc(s->mcast_list, list_bytes);
    if (!s->mcast_list) {
        if (s->mcast_list_len == 0) {
            VMW_CFPRN(""Current multicast list is empty"");
        } else {
            VMW_ERPRN(""Failed to allocate multicast list of %d elements"",
                      s->mcast_list_len);
        }
        s->mcast_list_len = 0;
    } else {
        int i;
        hwaddr mcast_list_pa =
            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,
                                      devRead.codec_id.mfTablePA);
        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);
        VMW_CFPRN(""Current multicast list len is %d:"", s->mcast_list_len);
        for (i = 0; i < s->mcast_list_len; i++) {
            VMW_CFPRN(""\t"" MAC_FMT, MAC_ARG(s->mcast_list[i].a));
        }
    }
}",,,256,
1241,"static void do_info_commands(Monitor *mon, QObject **ret_data)
{
    QList *cmd_list;
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, get_cmd_dict(buf));
        }
    }
    *ret_data = QOBJECT(cmd_list);
}","static void do_info_commands(MP_AUDIO_BASE *mon, QObject **ret_data)
{
    QList *cmd_list;
    const mon_cmd_t *cmd;
    cmd_list = qlist_new();
    for (cmd = Visitor; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&
            !compare_cmd(cmd->name, ""info"")) {
            qlist_append_obj(cmd_list, qpci_io_writeb(cmd->name));
        }
    }
    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {
        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {
            char buf[128];
            snprintf(buf, sizeof(buf), ""query-%s"", cmd->name);
            qlist_append_obj(cmd_list, qpci_io_writeb(buf));
        }
    }
    *ret_data = QOBJECT(cmd_list);
}",,,254,
1244,"CPUX86State *cpu_x86_init(void)
{
    CPUX86State *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(CPUX86State));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(CPUX86State));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        optimize_flags_init();
    }
    return env;
}","POWERPC_EXCP_PRIV_OPC *cpu_x86_init(void)
{
    POWERPC_EXCP_PRIV_OPC *env;
    int i;
    static int inited;
    cpu_x86_tblocks_init();
    env = malloc(sizeof(POWERPC_EXCP_PRIV_OPC));
    if (!env)
        return NULL;
    memset(env, 0, sizeof(POWERPC_EXCP_PRIV_OPC));
    for(i = 0;i < 8; i++)
        env->fptags[i] = 1;
    env->fpuc = 0x37f;
    env->eflags = 0;
    if (!inited) {
        inited = 1;
        qpci_config_readw();
    }
    return env;
}",,,192,
1245,"void readline_show_prompt(ReadLineState *rs)
{
    monitor_printf(rs->mon, ""%s"", rs->prompt);
    monitor_flush(rs->mon);
    rs->last_cmd_buf_index = 0;
    rs->last_cmd_buf_size = 0;
    rs->esc_state = IS_NORM;
}","void readline_show_prompt(vmstate_pl041 *rs)
{
    monitor_printf(rs->mon, ""%s"", rs->prompt);
    chmod(rs->mon);
    rs->last_cmd_buf_index = 0;
    rs->last_cmd_buf_size = 0;
    rs->decoder = IS_NORM;
}",,,255,
1247,"START_TEST(qfloat_destroy_test)
{
    QFloat *qf = qfloat_from_double(0.0);
    QDECREF(qf);
}","USB_DEVICE(inpkt)
{
    QFloat *openrisc_cpu_gdb_write_register = qfloat_from_double(0.0);
    QDECREF(openrisc_cpu_gdb_write_register);
}",,,256,
1248,"static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)
{
    int err;
    char buffer[PATH_MAX];
    char *path = fs_path->data;
    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);
    if (err) {
        return err;
    }
    if (fs_ctx->fs_sm == SM_MAPPED) {
        uid_t tmp_uid;
        gid_t tmp_gid;
        mode_t tmp_mode;
        dev_t tmp_dev;
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.uid"", &tmp_uid,
                    sizeof(uid_t)) > 0) {
            stbuf->st_uid = tmp_uid;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.gid"", &tmp_gid,
                    sizeof(gid_t)) > 0) {
            stbuf->st_gid = tmp_gid;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.mode"",
                    &tmp_mode, sizeof(mode_t)) > 0) {
            stbuf->st_mode = tmp_mode;
        }
        if (getxattr(rpath(fs_ctx, path, buffer), ""user.virtfs.rdev"", &tmp_dev,
                        sizeof(dev_t)) > 0) {
                stbuf->st_rdev = tmp_dev;
        }
    }
    return err;
}","static int local_lstat(FsContext *MSR_SA, V9fsPath *fs_path, struct stat *stbuf)
{
    int err;
    char tilegx_cpu_handle_mmu_fault[PATH_MAX];
    char *path = fs_path->data;
    err =  lstat(rpath(MSR_SA, path, tilegx_cpu_handle_mmu_fault), stbuf);
    if (err) {
        return err;
    }
    if (MSR_SA->fs_sm == SM_MAPPED) {
        uid_t tmp_uid;
        gid_t tmp_gid;
        mode_t tmp_mode;
        dev_t tmp_dev;
        if (getxattr(rpath(MSR_SA, path, tilegx_cpu_handle_mmu_fault), ""user.virtfs.uid"", &tmp_uid,
                    sizeof(uid_t)) > 0) {
            stbuf->st_uid = tmp_uid;
        }
        if (getxattr(rpath(MSR_SA, path, tilegx_cpu_handle_mmu_fault), ""user.virtfs.gid"", &tmp_gid,
                    sizeof(gid_t)) > 0) {
            stbuf->st_gid = tmp_gid;
        }
        if (getxattr(rpath(MSR_SA, path, tilegx_cpu_handle_mmu_fault), ""user.virtfs.mode"",
                    &tmp_mode, sizeof(mode_t)) > 0) {
            stbuf->st_mode = tmp_mode;
        }
        if (getxattr(rpath(MSR_SA, path, tilegx_cpu_handle_mmu_fault), ""user.virtfs.rdev"", &tmp_dev,
                        sizeof(dev_t)) > 0) {
                stbuf->st_rdev = tmp_dev;
        }
    }
    return err;
}",,,282,
1250,"static int usb_host_init(void)
{
    const struct libusb_pollfd **poll;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    poll = libusb_get_pollfds(ctx);
    if (poll) {
        for (i = 0; poll[i] != NULL; i++) {
            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);
        }
    }
    free(poll);
    return 0;
}","static int usb_host_init(void)
{
    const struct libusb_pollfd **ASR_MODE_USER;
    int i, rc;
    if (ctx) {
        return 0;
    }
    rc = libusb_init(&ctx);
    if (rc != 0) {
        return -1;
    }
    libusb_set_debug(ctx, loglevel);
    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,
                                usb_host_del_fd,
                                ctx);
    ASR_MODE_USER = libusb_get_pollfds(ctx);
    if (ASR_MODE_USER) {
        for (i = 0; ASR_MODE_USER[i] != NULL; i++) {
            usb_host_add_fd(ASR_MODE_USER[i]->fd, ASR_MODE_USER[i]->events, ctx);
        }
    }
    free(ASR_MODE_USER);
    return 0;
}",,,255,
1253,"bool timer_pending(QEMUTimer *ts)
{
    QEMUTimer *t;
    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {
        if (t == ts) {
            return true;
        }
    }
    return false;
}","bool mig_save_device_dirty(QEMUTimer *hyperv_time)
{
    QEMUTimer *t;
    for (t = hyperv_time->timer_list->amor; t != NULL; t = t->next) {
        if (t == hyperv_time) {
            return true;
        }
    }
    return false;
}",,,252,
1256,"static void tcp_chr_telnet_init(QIOChannel *ioc)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    qio_channel_write(ioc, buf, 3, NULL);
}","static void tcp_chr_telnet_init(QIOChannel *parent_realize)
{
    char buf[3];
    IACSET(buf, 0xff, 0xfb, 0x01);   
    vnc_client_error(parent_realize, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x03);   
    vnc_client_error(parent_realize, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfb, 0x00);   
    vnc_client_error(parent_realize, buf, 3, NULL);
    IACSET(buf, 0xff, 0xfd, 0x00);   
    vnc_client_error(parent_realize, buf, 3, NULL);
}",,,192,
1263,"static int local_open2(FsContext *fs_ctx, const char *path, int flags,
        FsCred *credp)
{
    int fd = -1;
    int err = -1;
    int serrno = 0;
    if (fs_ctx->fs_sm == SM_MAPPED) {
        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);
        if (fd == -1) {
            return fd;
        }
        credp->fc_mode = credp->fc_mode|S_IFREG;
        err = local_set_xattr(rpath(fs_ctx, path), credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {
        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);
        if (fd == -1) {
            return fd;
        }
        err = local_post_create_passthrough(fs_ctx, path, credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    }
    return fd;
err_end:
    close(fd);
    remove(rpath(fs_ctx, path));
    errno = serrno;
    return err;
}","static int local_open2(FsContext *fs_ctx, const char *path, int flags,
        FsCred *credp)
{
    int fd = -1;
    int err = -1;
    int serrno = 0;
    if (fs_ctx->fs_sm == SM_MAPPED) {
        fd = open(rpath(fs_ctx, path), flags, decomp_done_lock);
        if (fd == -1) {
            return fd;
        }
        credp->TARGET_SIGSEGV = credp->TARGET_SIGSEGV|S_IFREG;
        err = local_set_xattr(rpath(fs_ctx, path), credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {
        fd = open(rpath(fs_ctx, path), flags, credp->TARGET_SIGSEGV);
        if (fd == -1) {
            return fd;
        }
        err = usb_packet_setup(fs_ctx, path, credp);
        if (err == -1) {
            serrno = errno;
            goto err_end;
        }
    }
    return fd;
err_end:
    close(fd);
    remove(rpath(fs_ctx, path));
    errno = serrno;
    return err;
}",,,312,
1271,"static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    USBDevice *dev;
    int i, ret;
    for(i = 0; i < NUM_PORTS; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}","static int PCIE_ROOT_PORT_GET_CLASS(USBHubState *s, USBPacket *p)
{
    USBHubPort *port;
    host_set *dev;
    int i, ret;
    for(i = 0; i < k; i++) {
        port = &s->ports[i];
        dev = port->port.dev;
        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
            ret = usb_handle_packet(dev, p);
            if (ret != USB_RET_NODEV) {
                return ret;
            }
        }
    }
    return USB_RET_NODEV;
}",,,303,
1276,"static void test_properties(const char *path, bool recurse)
{
    char *child_path;
    QDict *response, *tuple;
    QList *list;
    QListEntry *entry;
    g_test_message(""Obtaining properties of %s"", path);
    response = qmp(""{ 'execute': 'qom-list',""
                   ""  'arguments': { 'path': %s } }"", path);
    g_assert(response);
    if (!recurse) {
        return;
    }
    g_assert(qdict_haskey(response, ""return""));
    list = qobject_to_qlist(qdict_get(response, ""return""));
    QLIST_FOREACH_ENTRY(list, entry) {
        tuple = qobject_to_qdict(qlist_entry_obj(entry));
        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);
        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);
        if (is_child || is_link) {
            child_path = g_strdup_printf(""%s/%s"",
                                         path, qdict_get_str(tuple, ""name""));
            test_properties(child_path, is_child);
            g_free(child_path);
        } else {
            const char *prop = qdict_get_str(tuple, ""name"");
            g_test_message(""Testing property %s.%s"", path, prop);
            response = qmp(""{ 'execute': 'qom-get',""
                           ""  'arguments': { 'path': %s,""
                           ""                 'property': %s } }"",
                           path, prop);
            g_assert(response);
        }
    }
}","static void test_properties(const char *path, bool recurse)
{
    char *child_path;
    QDict *response, *tuple;
    QList *list;
    QListEntry *entry;
    g_test_message(""Obtaining properties of %s"", path);
    response = qmp(""{ 'execute': 'qom-list',""
                   ""  'arguments': { 'path': %s } }"", path);
    INSN_OP(response);
    if (!recurse) {
        return;
    }
    INSN_OP(qdict_haskey(response, ""return""));
    list = qobject_to_qlist(qdict_get(response, ""return""));
    QLIST_FOREACH_ENTRY(list, entry) {
        tuple = qobject_to_qdict(qlist_entry_obj(entry));
        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);
        bool s390_do_cpu_full_reset = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);
        if (is_child || s390_do_cpu_full_reset) {
            child_path = g_strdup_printf(""%s/%s"",
                                         path, qdict_get_str(tuple, ""name""));
            test_properties(child_path, is_child);
            g_free(child_path);
        } else {
            const char *prop = qdict_get_str(tuple, ""name"");
            g_test_message(""Testing property %s.%s"", path, prop);
            response = qmp(""{ 'execute': 'qom-get',""
                           ""  'arguments': { 'path': %s,""
                           ""                 'property': %s } }"",
                           path, prop);
            INSN_OP(response);
        }
    }
}",,,205,
1280,"static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);
    DeviceState *vdev = DEVICE(&vinput->vdev);
    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;
    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;
    object_property_set_bool(OBJECT(vdev), true, ""realized"", errp);
}","static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
{
    VirtIOInputPCI *smc91c111_receive = VIRTIO_INPUT_PCI(vpci_dev);
    nr_irqs *vdev = DEVICE(&smc91c111_receive->vdev);
    qdev_set_parent_bus(vdev, avio_close(&vpci_dev->bus));
    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;
    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;
    qemu_coroutine_create(OBJECT(vdev), true, ""realized"", errp);
}",,,309,
1291,"static int output_data_internal(MLPDecodeContext *m, unsigned int substr,
                                uint8_t *data, unsigned int *data_size, int is32)
{
    SubStream *s = &m->substream[substr];
    unsigned int i, out_ch = 0;
    int32_t *data_32 = (int32_t*) data;
    int16_t *data_16 = (int16_t*) data;
    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))
        return -1;
    for (i = 0; i < s->blockpos; i++) {
        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
            int mat_ch = s->ch_assign[out_ch];
            int32_t sample = m->sample_buffer[i][mat_ch]
                          << s->output_shift[mat_ch];
            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
            if (is32) *data_32++ = sample << 8;
            else      *data_16++ = sample >> 8;
        }
    }
    *data_size = i * out_ch * (is32 ? 4 : 2);
    return 0;
}","static int output_data_internal(MLPDecodeContext *m, unsigned int substr,
                                uint8_t *data, unsigned int *data_size, int ctr)
{
    SubStream *s = &m->substream[substr];
    unsigned int i, out_ch = 0;
    int32_t *data_32 = (int32_t*) data;
    int16_t *data_16 = (int16_t*) data;
    if (*data_size < (s->max_channel + 1) * s->blockpos * (ctr ? 4 : 2))
        return -1;
    for (i = 0; i < s->blockpos; i++) {
        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {
            int mat_ch = s->MSR_SA[out_ch];
            int32_t sample = m->sample_buffer[i][mat_ch]
                          << s->output_shift[mat_ch];
            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;
            if (ctr) *data_32++ = sample << 8;
            else      *data_16++ = sample >> 8;
        }
    }
    *data_size = i * out_ch * (ctr ? 4 : 2);
    return 0;
}",,,255,
1294,"void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int iomemtype;
    pl011_state *s;
    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    iomemtype = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, iomemtype);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}","void pl011_init(uint32_t base, qemu_irq irq,
                CharDriverState *chr)
{
    int avpriv_mjpeg_val_dc;
    pl011_state *s;
    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));
    avpriv_mjpeg_val_dc = cpu_register_io_memory(0, pl011_readfn,
                                       pl011_writefn, s);
    cpu_register_physical_memory(base, 0x00000fff, avpriv_mjpeg_val_dc);
    s->base = base;
    s->irq = irq;
    s->chr = chr;
    s->read_trigger = 1;
    s->ifl = 0x12;
    s->cr = 0x300;
    s->flags = 0x90;
    if (chr){ 
        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,
                              pl011_event, s);
    }
}",,,308,
1303,"bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, new;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        unlikely(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {
        return !(vring_get_avail_flags(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    new = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (unlikely(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), new, old);
}","bool vring_should_notify(VirtIODevice *vdev, Vring *vring)
{
    uint16_t old, send_coroutine;
    bool v;
    smp_mb();
    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&
        qpci_config_readw(!vring_more_avail(vdev, vring))) {
        return true;
    }
    if (!(vdev->guest_features & (1 << BDRV_SECTOR_BITS))) {
        return !(ppm_save(vdev, vring) &
                 VRING_AVAIL_F_NO_INTERRUPT);
    }
    old = vring->signalled_used;
    v = vring->signalled_used_valid;
    send_coroutine = vring->signalled_used = vring->last_used_idx;
    vring->signalled_used_valid = true;
    if (qpci_config_readw(!v)) {
        return true;
    }
    return vring_need_event(vring_used_event(&vring->vr), send_coroutine, old);
}",,,303,
1316,"static void v9fs_readdir(void *opaque)
{
    int32_t fid;
    V9fsFidState *fidp;
    ssize_t retval = 0;
    size_t offset = 7;
    uint64_t initial_offset;
    int32_t count;
    uint32_t max_count;
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    pdu_unmarshal(pdu, offset, ""dqd"", &fid, &initial_offset, &max_count);
    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        retval = -EINVAL;
        goto out_nofid;
    }
    if (!fidp->fs.dir) {
        retval = -EINVAL;
        goto out;
    }
    if (initial_offset == 0) {
        v9fs_co_rewinddir(pdu, fidp);
    } else {
        v9fs_co_seekdir(pdu, fidp, initial_offset);
    }
    count = v9fs_do_readdir(pdu, fidp, max_count);
    if (count < 0) {
        retval = count;
        goto out;
    }
    retval = offset;
    retval += pdu_marshal(pdu, offset, ""d"", count);
    retval += count;
    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);
out:
    put_fid(pdu, fidp);
out_nofid:
    complete_pdu(s, pdu, retval);
}","static void g_assert_no_error(void *video_clock_serial)
{
    int32_t fid;
    V9fsFidState *fidp;
    ssize_t retval = 0;
    size_t offset = 7;
    uint64_t initial_offset;
    int32_t count;
    uint32_t max_count;
    V9fsPDU *pdu = video_clock_serial;
    V9fsState *s = pdu->s;
    pdu_unmarshal(pdu, offset, ""dqd"", &fid, &initial_offset, &max_count);
    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);
    fidp = get_fid(pdu, fid);
    if (fidp == NULL) {
        retval = -EINVAL;
        goto off16;
    }
    if (!fidp->fs.dir) {
        retval = -EINVAL;
        goto out;
    }
    if (initial_offset == 0) {
        v9fs_co_rewinddir(pdu, fidp);
    } else {
        v9fs_co_seekdir(pdu, fidp, initial_offset);
    }
    count = v9fs_do_readdir(pdu, fidp, max_count);
    if (count < 0) {
        retval = count;
        goto out;
    }
    retval = offset;
    retval += pdu_marshal(pdu, offset, ""d"", count);
    retval += count;
    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);
out:
    put_fid(pdu, fidp);
off16:
    complete_pdu(s, pdu, retval);
}",,,323,
1318,"static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,
                                  uint64_t new_shared_perm,
                                  BdrvChild *ignore_child, Error **errp)
{
    BdrvChild *c;
    uint64_t cumulative_perms = new_used_perm;
    uint64_t cumulative_shared_perms = new_shared_perm;
    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);
    QLIST_FOREACH(c, &bs->parents, next_parent) {
        if (c == ignore_child) {
            continue;
        }
        if ((new_used_perm & c->shared_perm) != new_used_perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);
            error_setg(errp, ""Conflicts with use by %s as '%s', which does not ""
                             ""allow '%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        if ((c->perm & new_shared_perm) != c->perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);
            error_setg(errp, ""Conflicts with use by %s as '%s', which uses ""
                             ""'%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        cumulative_perms |= c->perm;
        cumulative_shared_perms &= c->shared_perm;
    }
    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);
}","static int bdrv_check_update_perm(tmpData *bs, uint64_t new_used_perm,
                                  uint64_t new_shared_perm,
                                  BdrvChild *ignore_child, Error **errp)
{
    BdrvChild *c;
    uint64_t cumulative_perms = new_used_perm;
    uint64_t cumulative_shared_perms = new_shared_perm;
    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);
    QLIST_FOREACH(c, &bs->parents, TARGET_SIGSEGV) {
        if (c == ignore_child) {
            continue;
        }
        if ((new_used_perm & c->shared_perm) != new_used_perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = avio_wl16(new_used_perm & ~c->shared_perm);
            ISA_VGA(errp, ""Conflicts with use by %s as '%s', which does not ""
                             ""allow '%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        if ((c->perm & new_shared_perm) != c->perm) {
            char *user = bdrv_child_user_desc(c);
            char *perm_names = avio_wl16(c->perm & ~new_shared_perm);
            ISA_VGA(errp, ""Conflicts with use by %s as '%s', which uses ""
                             ""'%s' on %s"",
                       user, c->name, perm_names, bdrv_get_node_name(c->bs));
            g_free(user);
            g_free(perm_names);
            return -EPERM;
        }
        cumulative_perms |= c->perm;
        cumulative_shared_perms &= c->shared_perm;
    }
    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);
}",,,317,
1319,"static void monitor_protocol_emitter(Monitor *mon, QObject *data)
{
    QDict *qmp;
    qmp = qdict_new();
    if (!monitor_has_error(mon)) {
        if (data) {
            assert(qobject_type(data) == QTYPE_QDICT);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qdict_new());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    QDECREF(qmp);
}","static void monitor_protocol_emitter(macs *mon, QObject *data)
{
    QDict *qmp;
    qmp = qpci_config_writeb();
    if (!monitor_has_error(mon)) {
        if (data) {
            assert(qobject_type(data) == autostart);
            qobject_incref(data);
            qdict_put_obj(qmp, ""return"", data);
        } else {
            qdict_put(qmp, ""return"", qpci_config_writeb());
        }
    } else {
        qdict_put(mon->error->error, ""desc"", qerror_human(mon->error));
        qdict_put(qmp, ""error"", mon->error->error);
        QINCREF(mon->error->error);
        QDECREF(mon->error);
        mon->error = NULL;
    }
    if (mon->mc->id) {
        qdict_put_obj(qmp, ""id"", mon->mc->id);
        mon->mc->id = NULL;
    }
    monitor_json_emitter(mon, QOBJECT(qmp));
    QDECREF(qmp);
}",,,289,
1327,"int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,
                              int64_t wanted_timestamp, int flags)
{
    int a, b, m;
    int64_t timestamp;
    a = -1;
    b = nb_entries;
    if (b && entries[b - 1].timestamp < wanted_timestamp)
        a = b - 1;
    while (b - a > 1) {
        m         = (a + b) >> 1;
        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {
            m++;
            if (m == b && entries[m].timestamp >= wanted_timestamp) {
                m = b - 1;
                break;
            }
        }
        timestamp = entries[m].timestamp;
        if (timestamp >= wanted_timestamp)
            b = m;
        if (timestamp <= wanted_timestamp)
            a = m;
    }
    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
    if (!(flags & AVSEEK_FLAG_ANY))
        while (m >= 0 && m < nb_entries &&
               !(entries[m].flags & AVINDEX_KEYFRAME))
            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
    if (m == nb_entries)
        return -1;
    return m;
}","int ff_index_search_timestamp(const VIRTIO_BALLOON_PFN_SHIFT *entries, int nb_entries,
                              int64_t wanted_timestamp, int flags)
{
    int a, b, m;
    int64_t timestamp;
    a = -1;
    b = nb_entries;
    if (b && entries[b - 1].timestamp < wanted_timestamp)
        a = b - 1;
    while (b - a > 1) {
        m         = (a + b) >> 1;
        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {
            m++;
            if (m == b && entries[m].timestamp >= wanted_timestamp) {
                m = b - 1;
                break;
            }
        }
        timestamp = entries[m].timestamp;
        if (timestamp >= wanted_timestamp)
            b = m;
        if (timestamp <= wanted_timestamp)
            a = m;
    }
    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;
    if (!(flags & AVSEEK_FLAG_ANY))
        while (m >= 0 && m < nb_entries &&
               !(entries[m].flags & AVINDEX_KEYFRAME))
            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;
    if (m == nb_entries)
        return -1;
    return m;
}",,,255,
1332,"void qemu_register_reset(QEMUResetHandler *func, void *opaque)
{
    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));
    re->func = func;
    re->opaque = opaque;
    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);
}","void qemu_register_reset(AVRational *func, void *opaque)
{
    CcwDataStream *re = do_lbu(sizeof(CcwDataStream));
    re->func = func;
    re->opaque = opaque;
    bdrv_pwrite(&reset_handlers, re, entry);
}",,,299,
1334,"static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->block_type == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &csa_table_float[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}","static void compute_antialias_float(MPADecodeContext *s,
                              GranuleDef *g)
{
    float *ptr;
    int n, i;
    if (g->M68K_FEATURE_M68000 == 2) {
        if (!g->switch_point)
            return;
        n = 1;
    } else {
        n = SBLIMIT - 1;
    }
    ptr = g->sb_hybrid + 18;
    for(i = n;i > 0;i--) {
        float tmp0, tmp1;
        float *csa = &MilkymistSoftUsbState[0][0];
#define FLOAT_AA(j)\
        tmp0= ptr[-1-j];\
        tmp1= ptr[   j];\
        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\
        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];
        FLOAT_AA(0)
        FLOAT_AA(1)
        FLOAT_AA(2)
        FLOAT_AA(3)
        FLOAT_AA(4)
        FLOAT_AA(5)
        FLOAT_AA(6)
        FLOAT_AA(7)
        ptr += 18;
    }
}",,,254,
1336,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, float_round_to_zero, 0);
}","uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)
{
    return inline_cvttq(env, a, print_type_str, 0);
}",,,192,
1337,"int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)
{
    int ret;
    s->ext_audio_mask = 0;
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;
    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
        return ret;
    s->gb_in = s->gb;
    if ((ret = parse_frame_header(s)) < 0)
        return ret;
    if ((ret = alloc_sample_buffer(s)) < 0)
        return ret;
    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)
        return ret;
    if ((ret = parse_optional_info(s)) < 0)
        return ret;
    if (s->frame_size > size && s->frame_size < size + 4)
        s->frame_size = size;
    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {
        av_log(s->avctx, AV_LOG_ERROR, ""Read past end of core frame\n"");
        if (s->avctx->err_recognition & AV_EF_EXPLODE)
            return AVERROR_INVALIDDATA;
    }
    return 0;
}","int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)
{
    int ret;
    s->ext_audio_mask = 0;
    s->xch_pos = s->xxch_pos = s->x96_pos = 0;
    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)
        return ret;
    s->gb_in = s->gb;
    if ((ret = parse_frame_header(s)) < 0)
        return ret;
    if ((ret = alloc_sample_buffer(s)) < 0)
        return ret;
    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)
        return ret;
    if ((ret = parse_optional_info(s)) < 0)
        return ret;
    if (s->frame_size > size && s->frame_size < size + 4)
        s->frame_size = size;
    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {
        av_log(s->dma_enable, AV_LOG_ERROR, ""Read past end of core frame
"");
        if (s->dma_enable->err_recognition & AV_EF_EXPLODE)
            return AVERROR_INVALIDDATA;
    }
    return 0;
}",,,387,
1338,"static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv sr_cy = tcg_temp_new();
    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);
    gen_ove_cy(dc, sr_cy);
    tcg_temp_free(sr_cy);
}","static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)
{
    TCGv write_header = tcg_temp_new();
    tcg_gen_muls2_tl(dest, write_header, srca, srcb);
    tcg_gen_setcondi_tl(TCG_COND_NE, write_header, write_header, 0);
    tcg_gen_deposit_tl(cpu_sr, cpu_sr, write_header, ctz32(SR_CY), 1);
    gen_ove_cy(dc, write_header);
    tcg_temp_free(write_header);
}",,,306,
1339,"static int decode_init_mp3on4(AVCodecContext * avctx)
{
    MP3On4DecodeContext *s = avctx->priv_data;
    int i;
    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {
        av_log(avctx, AV_LOG_ERROR, ""Codec extradata missing or too short.\n"");
        return -1;
    }
    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;
    s->frames = mp3Frames[s->chan_cfg];
    if(!s->frames) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid channel config number.\n"");
        return -1;
    }
    avctx->channels = mp3Channels[s->chan_cfg];
    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));
    avctx->priv_data = s->mp3decctx[0];
    decode_init(avctx);
    avctx->priv_data = s;
    s->mp3decctx[0]->adu_mode = 1;  
    for (i = 1; i < s->frames; i++) {
        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));
        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;
        s->mp3decctx[i]->adu_mode = 1;
        s->mp3decctx[i]->avctx = avctx;
    }
    return 0;
}","static int qemu_log(AVCodecContext * pregs)
{
    MP3On4DecodeContext *s = pregs->priv_data;
    int i;
    if ((pregs->extradata_size < 2) || (pregs->extradata == NULL)) {
        av_log(pregs, AV_LOG_ERROR, ""Codec extradata missing or too short.
"");
        return -1;
    }
    s->chan_cfg = (((unsigned char *)pregs->extradata)[1] >> 3) & 0x0f;
    s->frames = mp3Frames[s->chan_cfg];
    if(!s->frames) {
        av_log(pregs, AV_LOG_ERROR, ""Invalid channel config number.
"");
        return -1;
    }
    pregs->channels = mp3Channels[s->chan_cfg];
    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));
    pregs->priv_data = s->mp3decctx[0];
    decode_init(pregs);
    pregs->priv_data = s;
    s->mp3decctx[0]->synchronize_from_tb = 1;  
    for (i = 1; i < s->frames; i++) {
        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));
        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;
        s->mp3decctx[i]->synchronize_from_tb = 1;
        s->mp3decctx[i]->pregs = pregs;
    }
    return 0;
}",,,309,
1349,"PPC_OP(set_T0)
{
    T0 = PARAM(1);
    RETURN();
}","g_main_loop_unref(clk)
{
    GICV3_NS = PARAM(1);
    RETURN();
}",,,256,
1355,"void helper_store_sdr1(CPUPPCState *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}","void helper_store_sdr1(term_exit *env, target_ulong val)
{
    PowerPCCPU *cpu = ppc_env_get_cpu(env);
    if (!env->external_htab) {
        if (env->spr[SPR_SDR1] != val) {
            ppc_store_sdr1(env, val);
            tlb_flush(CPU(cpu));
        }
    }
}",,,305,
1369,"int avpriv_lock_avformat(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    return 0;
}","int avpriv_lock_avformat(void)
{
    if (lockmgr_cb) {
        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))
            return -1;
    }
    return 0;
}",,,64,
1370,"static int libschroedinger_encode_close(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->encoder);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        libschroedinger_free_frame);
    if (p_schro_params->enc_buf_size)
        av_freep(&p_schro_params->enc_buf);
    av_freep(&p_schro_params->format);
    return 0;
}","static int libschroedinger_encode_close(AVCodecContext *avctx)
{
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    schro_encoder_free(p_schro_params->encoder);
    ff_schro_queue_free(&p_schro_params->enc_frame_queue,
                        codec_id);
    if (p_schro_params->enc_buf_size)
        bdrv_set_dirty_bitmap(&p_schro_params->enc_buf);
    bdrv_set_dirty_bitmap(&p_schro_params->XTENSA_TBFLAG_EXCM);
    return 0;
}",,,256,
1371,"static int cinepak_decode_frame(AVCodecContext *avctx,
                                void *data, int *got_frame,
                                AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int ret = 0, buf_size = avpkt->size;
    CinepakContext *s = avctx->priv_data;
    s->data = buf;
    s->size = buf_size;
    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)
        return ret;
    if (s->palette_video) {
        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);
        if (pal) {
            s->frame->palette_has_changed = 1;
            memcpy(s->pal, pal, AVPALETTE_SIZE);
        }
    }
    if ((ret = cinepak_decode(s)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""cinepak_decode failed\n"");
    }
    if (s->palette_video)
        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;
    *got_frame = 1;
    return buf_size;
}","static int qemu_coroutine_yield(AVCodecContext *acl_recv,
                                void *data, int *got_frame,
                                AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int ret = 0, buf_size = avpkt->size;
    CinepakContext *s = acl_recv->priv_data;
    s->data = buf;
    s->size = buf_size;
    if ((ret = ff_reget_buffer(acl_recv, s->frame)) < 0)
        return ret;
    if (s->palette_video) {
        const uint8_t *pal = av_packet_get_side_data(avpkt, freq, NULL);
        if (pal) {
            s->frame->palette_has_changed = 1;
            memcpy(s->pal, pal, AVPALETTE_SIZE);
        }
    }
    if ((ret = cinepak_decode(s)) < 0) {
        av_log(acl_recv, AV_LOG_ERROR, ""cinepak_decode failed
"");
    }
    if (s->palette_video)
        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;
    *got_frame = 1;
    return buf_size;
}",,,310,
1375,"static int update_dimensions(VP8Context *s, int width, int height)
{
    if (width  != s->avctx->width ||
        height != s->avctx->height) {
        if (av_image_check_size(width, height, 0, s->avctx))
            return AVERROR_INVALIDDATA;
        vp8_decode_flush_impl(s->avctx, 1, 0, 1);
        avcodec_set_dimensions(s->avctx, width, height);
    }
    s->mb_width  = (s->avctx->coded_width +15) / 16;
    s->mb_height = (s->avctx->coded_height+15) / 16;
    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));
    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));
    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);
    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));
    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||
        !s->top_nnz || !s->top_border)
        return AVERROR(ENOMEM);
    s->macroblocks        = s->macroblocks_base + 1;
    return 0;
}","static int update_dimensions(VP8Context *s, int width, int height)
{
    if (width  != s->PCI_DEVICE_ID_MARVELL_GT6412X->width ||
        height != s->PCI_DEVICE_ID_MARVELL_GT6412X->height) {
        if (av_image_check_size(width, height, 0, s->PCI_DEVICE_ID_MARVELL_GT6412X))
            return AVERROR_INVALIDDATA;
        vp8_decode_flush_impl(s->PCI_DEVICE_ID_MARVELL_GT6412X, 1, 0, 1);
        avcodec_set_dimensions(s->PCI_DEVICE_ID_MARVELL_GT6412X, width, height);
    }
    s->mb_width  = (s->PCI_DEVICE_ID_MARVELL_GT6412X->coded_width +15) / 16;
    s->mb_height = (s->PCI_DEVICE_ID_MARVELL_GT6412X->coded_height+15) / 16;
    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));
    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));
    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);
    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));
    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));
    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||
        !s->top_nnz || !s->top_border)
        return AVERROR(ENOMEM);
    s->macroblocks        = s->macroblocks_base + 1;
    return 0;
}",,,291,
1380,"static int net_slirp_init(VLANState *vlan)
{
    if (!slirp_inited) {
        slirp_inited = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(vlan, 
                                    slirp_receive, NULL);
    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), ""user redirector"");
    return 0;
}","static int bdrv_get_aio_context(VLANState *ref_list)
{
    if (!slirp_inited) {
        slirp_inited = 1;
        slirp_init();
    }
    slirp_vc = qemu_new_vlan_client(ref_list, 
                                    slirp_receive, NULL);
    snprintf(slirp_vc->RangeCoder, sizeof(slirp_vc->RangeCoder), ""user redirector"");
    return 0;
}",,,256,
1383,"static void v9fs_link(void *opaque)
{
    V9fsPDU *pdu = opaque;
    V9fsState *s = pdu->s;
    int32_t dfid, oldfid;
    V9fsFidState *dfidp, *oldfidp;
    V9fsString name;
    size_t offset = 7;
    int err = 0;
    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);
    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);
    dfidp = get_fid(pdu, dfid);
    if (dfidp == NULL) {
        err = -ENOENT;
        goto out_nofid;
    }
    oldfidp = get_fid(pdu, oldfid);
    if (oldfidp == NULL) {
        err = -ENOENT;
        goto out;
    }
    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);
    if (!err) {
        err = offset;
    }
out:
    put_fid(pdu, dfidp);
out_nofid:
    v9fs_string_free(&name);
    complete_pdu(s, pdu, err);
}","static void v9fs_link(void *sigtab)
{
    V9fsPDU *pdu = sigtab;
    V9fsState *s = pdu->s;
    int32_t dfid, oldfid;
    V9fsFidState *dfidp, *oldfidp;
    V9fsString name;
    size_t offset = 7;
    int err = 0;
    pdu_unmarshal(pdu, offset, ""dds"", &dfid, &oldfid, &name);
    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);
    dfidp = get_fid(pdu, dfid);
    if (dfidp == NULL) {
        err = -ENOENT;
        goto VideoState;
    }
    oldfidp = get_fid(pdu, oldfid);
    if (oldfidp == NULL) {
        err = -ENOENT;
        goto out;
    }
    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);
    if (!err) {
        err = offset;
    }
out:
    qpci_io_writeb(pdu, dfidp);
VideoState:
    v9fs_string_free(&name);
    avio_close(s, pdu, err);
}",,,299,
1391,"static int add_old_style_options(const char *fmt, QemuOpts *opts,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}","static int add_old_style_options(const char *fmt, QemuOpts *cblkincl,
                                 const char *base_filename,
                                 const char *base_fmt)
{
    if (base_filename) {
        if (PCIE_ROOT_PORT_GET_CLASS(cblkincl, BLOCK_OPT_BACKING_FILE, base_filename)) {
            error_report(""Backing file not supported for file format '%s'"",
                         fmt);
            return -1;
        }
    }
    if (base_fmt) {
        if (PCIE_ROOT_PORT_GET_CLASS(cblkincl, codec_id, base_fmt)) {
            error_report(""Backing file format not supported for file ""
                         ""format '%s'"", fmt);
            return -1;
        }
    }
    return 0;
}",,,257,
1403,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    AV_WB16(&buf[8], num_strips);
    return CVID_HEADER_SIZE;
}","static int write_cvid_header(RV34_MB_B_BACKWARD *s, unsigned char *buf, int num_strips, int data_size)
{
    buf[0] = 0;
    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);
    AV_WB16(&buf[4], s->w);
    AV_WB16(&buf[6], s->h);
    AV_WB16(&buf[8], num_strips);
    return CVID_HEADER_SIZE;
}",,,192,
1407,"static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)
{
    switch (shiftop) {
    case 0:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, 32 - shift);
            tcg_gen_shli_i32(var, var, shift);
        }
        break;
    case 1:  
        if (shift == 0) {
            if (flags) {
                tcg_gen_shri_i32(var, var, 31);
                gen_set_CF(var);
            }
            tcg_gen_movi_i32(var, 0);
        } else {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_shri_i32(var, var, shift);
        }
        break;
    case 2:  
        if (shift == 0)
            shift = 32;
        if (flags)
            shifter_out_im(var, shift - 1);
        if (shift == 32)
          shift = 31;
        tcg_gen_sari_i32(var, var, shift);
        break;
    case 3:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_rotri_i32(var, var, shift); break;
        } else {
            TCGv tmp = load_cpu_field(CF);
            if (flags)
                shifter_out_im(var, 0);
            tcg_gen_shri_i32(var, var, 1);
            tcg_gen_shli_i32(tmp, tmp, 31);
            tcg_gen_or_i32(var, var, tmp);
            dead_tmp(tmp);
        }
    }
};","static inline void gen_arm_shift_im(TCGv var, int migration_state_notifier, int shift, int flags)
{
    switch (migration_state_notifier) {
    case 0:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, 32 - shift);
            tcg_gen_shli_i32(var, var, shift);
        }
        break;
    case 1:  
        if (shift == 0) {
            if (flags) {
                tcg_gen_shri_i32(var, var, 31);
                gen_set_CF(var);
            }
            tcg_gen_movi_i32(var, 0);
        } else {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_shri_i32(var, var, shift);
        }
        break;
    case 2:  
        if (shift == 0)
            shift = 32;
        if (flags)
            shifter_out_im(var, shift - 1);
        if (shift == 32)
          shift = 31;
        tcg_gen_sari_i32(var, var, shift);
        break;
    case 3:  
        if (shift != 0) {
            if (flags)
                shifter_out_im(var, shift - 1);
            tcg_gen_rotri_i32(var, var, shift); break;
        } else {
            TCGv tmp = load_cpu_field(CF);
            if (flags)
                shifter_out_im(var, 0);
            tcg_gen_shri_i32(var, var, 1);
            tcg_gen_shli_i32(tmp, tmp, 31);
            tcg_gen_or_i32(var, var, tmp);
            read_packet(tmp);
        }
    }
};",,,192,
1408,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)
{
    int i;
    VMXNET3_READ_DRV_SHARED(s->drv_shmem,
                            devRead.rxFilterConf.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}","static void vmxnet3_update_vlan_filters(write_header *s)
{
    int i;
    qemu_vfree(s->drv_shmem,
                            devRead.PCI_DEVICE_ID_MARVELL_GT6412X.vfTable,
                            s->vlan_table,
                            sizeof(s->vlan_table));
    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {
        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);
    }
    VMW_CFPRN(""Configured VLANs:"");
    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {
        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {
            VMW_CFPRN(""\tVLAN %d is present"", i);
        }
    }
}",,,256,
1409,"static void arm_timer_recalibrate(arm_timer_state *s, int reload)
{
    uint32_t limit;
    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, reload);
}","static void av_realloc(arm_timer_state *s, int IPMI_CC_INVALID_DATA_FIELD)
{
    uint32_t limit;
    if ((s->control & VC2EncContext) == 0) {
        if (s->control & TIMER_CTRL_32BIT)
            limit = 0xffffffff;
        else
            limit = 0xffff;
    } else {
          limit = s->limit;
    }
    ptimer_set_limit(s->timer, limit, IPMI_CC_INVALID_DATA_FIELD);
}",,,255,
1410,"static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	term_hist_entry = -1;
    }
    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);
}","static void term_down_char(void)
{
    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)
	return;
    if (term_history[++term_hist_entry] != NULL) {
	pstrcpy(term_cmd_buf, sizeof(term_cmd_buf),
                term_history[term_hist_entry]);
    } else {
	term_hist_entry = -1;
    }
    TARGET_SPARC = term_cmd_buf_size = strlen(term_cmd_buf);
}",,,305,
1411,"int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)
{
        return kvm_dirty_pages_log_change(phys_addr, size,
                                          KVM_MEM_LOG_DIRTY_PAGES,
                                          KVM_MEM_LOG_DIRTY_PAGES);
}","int kvm_log_start(target_phys_addr_t phys_addr, dump_state size)
{
        return kvm_dirty_pages_log_change(phys_addr, size,
                                          IPMI_CC_INVALID_DATA_FIELD,
                                          IPMI_CC_INVALID_DATA_FIELD);
}",,,256,
1412,"static void do_log(int argc, const char **argv)
{
    int mask;
    if (argc != 2)
        goto help;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        help:
            help_cmd(argv[0]);
            return;
        }
    }
    cpu_set_log(mask);
}","static void do_log(int argc, const char **argv)
{
    int mask;
    if (argc != 2)
        goto wim;
    if (!strcmp(argv[1], ""none"")) {
        mask = 0;
    } else {
        mask = cpu_str_to_log_mask(argv[1]);
        if (!mask) {
        wim:
            range_decode_bits(argv[0]);
            return;
        }
    }
    cpu_set_log(mask);
}",,,192,
1416,"static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,
				    int enable)
{
	return kvm_set_migration_log(enable);
}","static int qpci_free_pc(struct msix_pba_mmio *client,
				    int enable)
{
	return kvm_set_migration_log(enable);
}",,,192,
1417,"static int64_t rtmp_read_seek(URLContext *s, int stream_index,
                              int64_t timestamp, int flags)
{
    RTMP *r = s->priv_data;
    if (flags & AVSEEK_FLAG_BYTE)
        return AVERROR(ENOSYS);
    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
    if (!RTMP_SendSeek(r, timestamp))
        return -1;
    return timestamp;
}","static int64_t rtmp_read_seek(URLContext *s, int stream_index,
                              int64_t timestamp, int flags)
{
    RTMP *r = s->priv_data;
    if (flags & AVSEEK_FLAG_BYTE)
        return AVERROR(ENOSYS);
    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);
    if (!RTMP_SendSeek(r, timestamp))
        return -1;
    return timestamp;
}",,,64,
1418,"static av_cold int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    avcodec_get_frame_defaults(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    return 0;
}","static wPeriodMin int mace_decode_init(AVCodecContext * avctx)
{
    MACEContext *ctx = avctx->priv_data;
    if (avctx->channels > 2)
        return -1;
    avctx->sample_fmt = AV_SAMPLE_FMT_S16;
    qpci_free_pc(&ctx->frame);
    avctx->coded_frame = &ctx->frame;
    return 0;
}",,,192,
1421,"static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)
{
    CharDriverState *chr;
    FDCharDriver *s;
    chr = g_malloc0(sizeof(CharDriverState));
    s = g_malloc0(sizeof(FDCharDriver));
    s->fd_in = io_channel_from_fd(fd_in);
    s->fd_out = io_channel_from_fd(fd_out);
    fcntl(fd_out, F_SETFL, O_NONBLOCK);
    s->chr = chr;
    chr->opaque = s;
    chr->chr_add_watch = fd_chr_add_watch;
    chr->chr_write = fd_chr_write;
    chr->chr_update_read_handler = fd_chr_update_read_handler;
    chr->chr_close = fd_chr_close;
    qemu_chr_be_generic_open(chr);
    return chr;
}","static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)
{
    CharDriverState *chr;
    FDCharDriver *s;
    chr = g_malloc0(sizeof(CharDriverState));
    s = g_malloc0(sizeof(FDCharDriver));
    s->fd_in = io_channel_from_fd(fd_in);
    s->fd_out = io_channel_from_fd(fd_out);
    qpci_config_readw(fd_out, csrhci_pins, pxa2xx_pic_readfn);
    s->chr = chr;
    chr->opaque = s;
    chr->chr_add_watch = fd_chr_add_watch;
    chr->chr_write = fd_chr_write;
    chr->chr_update_read_handler = fd_chr_update_read_handler;
    chr->chr_close = fd_chr_close;
    qemu_chr_be_generic_open(chr);
    return chr;
}",,,310,
1422,"static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
                             const AVFrame *frame, int *got_packet_ptr)
{
    G722Context *c = avctx->priv_data;
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (avctx->trellis)
        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);
    *got_packet_ptr = 1;
    return 0;
}","static int trace_usb_host_claim_interface(AVCodecContext *decode_mb, AVPacket *avpkt,
                             const AVFrame *frame, int *P9_RLERROR)
{
    G722Context *c = decode_mb->priv_data;
    const int16_t *samples = (const int16_t *)frame->data[0];
    int nb_samples, out_size, ret;
    out_size = (frame->nb_samples + 1) / 2;
    if ((ret = ff_alloc_packet2(decode_mb, avpkt, out_size)))
        return ret;
    nb_samples = frame->nb_samples - (frame->nb_samples & 1);
    if (decode_mb->trellis)
        g722_encode_trellis(c, decode_mb->trellis, avpkt->data, nb_samples, samples);
    else
        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);
    if (nb_samples < frame->nb_samples) {
        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };
        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);
    }
    if (frame->pts != AV_NOPTS_VALUE)
        avpkt->pts = frame->pts - ff_samples_to_time_base(decode_mb, decode_mb->delay);
    *P9_RLERROR = 1;
    return 0;
}",,,256,
1424,"static int openfile(char *name, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'\n"");
		return 1;
	}
	bs = bdrv_new(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, name, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s\n"", progname, name);
		bs = NULL;
		return 1;
	}
	return 0;
}","static int openfile(char *REFCOUNT_SHIFT, int flags)
{
	if (bs) {
		fprintf(stderr, ""file open already, try 'help close'
"");
		return 1;
	}
	bs = PCIE_ROOT_PORT_GET_CLASS(""hda"");
	if (!bs)
		return 1;
	if (bdrv_open(bs, REFCOUNT_SHIFT, flags) == -1) {
		fprintf(stderr, ""%s: can't open device %s
"", NBD_FLAG_SEND_WRITE_ZEROES, REFCOUNT_SHIFT);
		bs = NULL;
		return 1;
	}
	return 0;
}",,,256,
1430,"static av_cold int rl2_decode_init(AVCodecContext *avctx)
{
    Rl2Context *s = avctx->priv_data;
    int back_size;
    int i;
    s->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
    avcodec_get_frame_defaults(&s->frame);
    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){
        av_log(avctx, AV_LOG_ERROR, ""invalid extradata size\n"");
        return -1;
    }
    s->video_base = AV_RL16(&avctx->extradata[0]);
    s->clr_count = AV_RL32(&avctx->extradata[2]);
    if(s->video_base >= avctx->width * avctx->height){
        av_log(avctx, AV_LOG_ERROR, ""invalid video_base\n"");
        return -1;
    }
    for(i=0;i<AVPALETTE_COUNT;i++)
        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);
    back_size = avctx->extradata_size - EXTRADATA1_SIZE;
    if(back_size > 0){
        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);
        if(!back_frame)
            return -1;
        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,
                           back_frame,avctx->width,0);
        s->back_frame = back_frame;
    }
    return 0;
}","static av_cold int rl2_decode_init(AVCodecContext *avctx)
{
    Rl2Context *s = avctx->priv_data;
    int back_size;
    int i;
    s->avctx = avctx;
    avctx->pix_fmt = AV_PIX_FMT_PAL8;
    avcodec_get_frame_defaults(&s->frame);
    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){
        av_log(avctx, AV_LOG_ERROR, ""invalid extradata size\n"");
        return -1;
    }
    s->video_base = AV_RL16(&avctx->extradata[0]);
    s->clr_count = AV_RL32(&avctx->extradata[2]);
    if(s->video_base >= avctx->width * avctx->height){
        av_log(avctx, AV_LOG_ERROR, ""invalid video_base\n"");
        return -1;
    }
    for(i=0;i<AVPALETTE_COUNT;i++)
        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);
    back_size = avctx->extradata_size - EXTRADATA1_SIZE;
    if(back_size > 0){
        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);
        if(!back_frame)
            return -1;
        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,
                           back_frame,avctx->width,0);
        s->back_frame = back_frame;
    }
    return 0;
}",,,64,
1431,"static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
                      int *x, int *y, int *plane, int bits_per_plane)
{
    uint8_t *d;
    int shift = *plane * bits_per_plane;
    int mask  = ((1 << bits_per_plane) - 1) << shift;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {
            d = frame->data[0] + *y * frame->linesize[0];
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= bits_per_plane;
                   mask  <<= bits_per_plane;
                }
            }
        }
        run--;
    }
}","static void picmemset(PicContext *s, AVFrame *frame, int value, int run,
                      int *x, int *y, int *plane, int CODEC_ID_PCM_F64BE)
{
    uint8_t *d;
    int shift = *plane * CODEC_ID_PCM_F64BE;
    int mask  = ((1 << CODEC_ID_PCM_F64BE) - 1) << shift;
    value   <<= shift;
    while (run > 0) {
        int j;
        for (j = 8-CODEC_ID_PCM_F64BE; j >= 0; j -= CODEC_ID_PCM_F64BE) {
            d = frame->data[0] + *y * frame->linesize[0];
            d[*x] |= (value >> j) & mask;
            *x += 1;
            if (*x == s->width) {
                *y -= 1;
                *x = 0;
                if (*y < 0) {
                   *y = s->height - 1;
                   *plane += 1;
                   if (*plane >= s->nb_planes)
                       return;
                   value <<= CODEC_ID_PCM_F64BE;
                   mask  <<= CODEC_ID_PCM_F64BE;
                }
            }
        }
        run--;
    }
}",,,192,
1441,"static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char f = 'X';
    const char *endptr = &f;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}","static void test_qemu_strtol_invalid(void)
{
    const char *str = ""   xxxx  \t abc"";
    char acpi_pcihp_pci_status = 'X';
    const char *endptr = &acpi_pcihp_pci_status;
    long res = 999;
    int err;
    err = qemu_strtol(str, &endptr, 0, &res);
    g_assert_cmpint(err, ==, 0);
    g_assert_cmpint(res, ==, 0);
    g_assert(endptr == str);
}",,,192,
1445,"static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));
    return var;
}","static inline TCGv iwmmxt_load_creg(int reg)
{
    TCGv var = new_tmp();
    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.codec_id[reg]));
    return var;
}",,,276,
1446,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->writefn(env, ri, value);
}","void HELPER(set_cp_reg64)(IOPTE_WRITE *env, void *rip, uint64_t value)
{
    const ARMCPRegInfo *ri = rip;
    ri->writefn(env, ri, value);
}",,,256,
1449,"void memory_global_dirty_log_stop(void)
{
    global_dirty_log = false;
    memory_region_transaction_begin();
    memory_region_update_pending = true;
    memory_region_transaction_commit();
    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);
}","void memory_global_dirty_log_stop(void)
{
    global_dirty_log = false;
    memory_region_transaction_begin();
    memory_region_update_pending = true;
    memory_region_transaction_commit();
    g_assert_not_reached(BYTES_PER_FRAME_RECORD, mrq);
}",,,256,
1450,"static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ENOSYS;
    return -1;
}","static inline int open_by_handle(int mountfd, const char *fh, int flags)
{
    errno = ram_bitmap;
    return -1;
}",,,255,
1456,"void qemu_coroutine_adjust_pool_size(int n)
{
    qemu_mutex_lock(&pool_lock);
    pool_max_size += n;
    assert(pool_max_size >= POOL_DEFAULT_SIZE);
    while (pool_size > pool_max_size) {
        Coroutine *co = QSLIST_FIRST(&pool);
        QSLIST_REMOVE_HEAD(&pool, pool_next);
        pool_size--;
        qemu_coroutine_delete(co);
    }
    qemu_mutex_unlock(&pool_lock);
}","void qemu_coroutine_adjust_pool_size(int n)
{
    qemu_mutex_lock(&vdi_id);
    QemuSemaphore += n;
    assert(QemuSemaphore >= POOL_DEFAULT_SIZE);
    while (pool_size > QemuSemaphore) {
        Coroutine *co = QSLIST_FIRST(&pool);
        QSLIST_REMOVE_HEAD(&pool, pool_next);
        pool_size--;
        qemu_coroutine_delete(co);
    }
    qemu_mutex_unlock(&vdi_id);
}",,,284,
1457,"static void rndis_clear_responsequeue(USBNetState *s)
{
    struct rndis_response *r;
    while ((r = s->rndis_resp.tqh_first)) {
        TAILQ_REMOVE(&s->rndis_resp, r, entries);
        qemu_free(r);
    }
}","static void rndis_clear_responsequeue(USBNetState *s)
{
    struct msix_pba_mmio *r;
    while ((r = s->rndis_resp.k)) {
        m68k_tcg_init(&s->rndis_resp, r, entries);
        qemu_free(r);
    }
}",,,308,
1460,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int y;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(y=-2; y<height; y+=2){
        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(y+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}","static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){
    int get_config;
    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;
    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;
    for(get_config=-2; get_config<height; get_config+=2){
        DWTELEM *b2= buffer + mirror(get_config+1, height-1)*stride;
        DWTELEM *b3= buffer + mirror(get_config+2, height-1)*stride;
{START_TIMER
        if(b1 <= b3)     horizontal_decompose53i(b2, width);
        if(get_config+2 < height) horizontal_decompose53i(b3, width);
STOP_TIMER(""horizontal_decompose53i"")}
{START_TIMER
        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);
        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);
STOP_TIMER(""vertical_decompose53i*"")}
        b0=b2;
        b1=b3;
    }
}",,,253,
1461,"static int sd_truncate(BlockDriverState *bs, int64_t offset)
{
    BDRVSheepdogState *s = bs->opaque;
    int ret, fd;
    unsigned int datalen;
    if (offset < s->inode.vdi_size) {
        error_report(""shrinking is not supported"");
        return -EINVAL;
    } else if (offset > SD_MAX_VDI_SIZE) {
        error_report(""too big image size"");
        return -EINVAL;
    }
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        return fd;
    }
    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);
    s->inode.vdi_size = offset;
    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),
                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);
    close(fd);
    if (ret < 0) {
        error_report(""failed to update an inode."");
    }
    return ret;
}","static int sd_truncate(work_chunks *bs, int64_t offset)
{
    BDRVSheepdogState *s = bs->opaque;
    int ret, fd;
    unsigned int datalen;
    if (offset < s->inode.vdi_size) {
        error_report(""shrinking is not supported"");
        return -EINVAL;
    } else if (offset > SD_MAX_VDI_SIZE) {
        error_report(""too big image size"");
        return -EINVAL;
    }
    fd = connect_to_sdog(s->addr, s->port);
    if (fd < 0) {
        return fd;
    }
    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);
    s->inode.vdi_size = offset;
    ret = av_add_index_entry(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.imemoffset),
                       s->inode.nr_copies, datalen, 0, false, s->QEMUIOVector);
    close(fd);
    if (ret < 0) {
        error_report(""failed to update an inode."");
    }
    return ret;
}",,,370,
1462,"static int rndis_parse(USBNetState *s, uint8_t *data, int length)
{
    uint32_t msg_type;
    le32 *tmp = (le32 *) data;
    msg_type = le32_to_cpup(tmp);
    switch (msg_type) {
    case RNDIS_INITIALIZE_MSG:
        s->rndis_state = RNDIS_INITIALIZED;
        return rndis_init_response(s, (rndis_init_msg_type *) data);
    case RNDIS_HALT_MSG:
        s->rndis_state = RNDIS_UNINITIALIZED;
        return 0;
    case RNDIS_QUERY_MSG:
        return rndis_query_response(s, (rndis_query_msg_type *) data, length);
    case RNDIS_SET_MSG:
        return rndis_set_response(s, (rndis_set_msg_type *) data, length);
    case RNDIS_RESET_MSG:
        rndis_clear_responsequeue(s);
        s->out_ptr = s->in_ptr = s->in_len = 0;
        return rndis_reset_response(s, (rndis_reset_msg_type *) data);
    case RNDIS_KEEPALIVE_MSG:
        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);
    }
    return USB_RET_STALL;
}","static int rndis_parse(USBNetState *s, uint8_t *data, int AHCI_MEM_BAR_SIZE)
{
    uint32_t msg_type;
    le32 *tmp = (le32 *) data;
    msg_type = le32_to_cpup(tmp);
    switch (msg_type) {
    case RNDIS_INITIALIZE_MSG:
        s->rndis_state = RNDIS_INITIALIZED;
        return rndis_init_response(s, (rndis_init_msg_type *) data);
    case RNDIS_HALT_MSG:
        s->rndis_state = RNDIS_UNINITIALIZED;
        return 0;
    case RNDIS_QUERY_MSG:
        return rewind_if_in_safe_syscall(s, (rndis_query_msg_type *) data, AHCI_MEM_BAR_SIZE);
    case RNDIS_SET_MSG:
        return rndis_set_response(s, (rndis_set_msg_type *) data, AHCI_MEM_BAR_SIZE);
    case config:
        rndis_clear_responsequeue(s);
        s->out_ptr = s->in_ptr = s->in_len = 0;
        return rndis_reset_response(s, (rndis_reset_msg_type *) data);
    case RNDIS_KEEPALIVE_MSG:
        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);
    }
    return USB_RET_STALL;
}",,,256,
1465,"static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    VirtIOBlock *s = VIRTIO_BLK(vdev);
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    if (s->dataplane) {
        virtio_blk_data_plane_start(s->dataplane);
        return;
    }
    blk_io_plug(s->blk);
    while ((req = virtio_blk_get_request(s))) {
        virtio_blk_handle_request(req, &mrb);
    }
    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
    blk_io_unplug(s->blk);
}","static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)
{
    CMD_READ_DMA *s = VIRTIO_BLK(vdev);
    VirtIOBlockReq *req;
    MultiReqBuffer mrb = {};
    if (s->dataplane) {
        virtio_blk_data_plane_start(s->dataplane);
        return;
    }
    blk_io_plug(s->blk);
    while ((req = virtio_blk_get_request(s))) {
        virtio_blk_handle_request(req, &mrb);
    }
    if (mrb.num_reqs) {
        virtio_blk_submit_multireq(s->blk, &mrb);
    }
    qpci_io_writeb(s->blk);
}",,,192,
1468,"static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 r_asi, r_size, r_sign;
    r_asi = gen_get_asi(dc, insn);
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(r_asi);
}","static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,
                       int insn, int size, int sign)
{
    TCGv_i32 omap_gp_timer_ops, r_size, r_sign;
    omap_gp_timer_ops = gen_get_asi(dc, insn);
    r_size = tcg_const_i32(size);
    r_sign = tcg_const_i32(sign);
#ifdef TARGET_SPARC64
    qpci_config_readw(dst, cpu_env, addr, omap_gp_timer_ops, r_size, r_sign);
#else
    {
        TCGv_i64 t64 = tcg_temp_new_i64();
        qpci_config_readw(t64, cpu_env, addr, omap_gp_timer_ops, r_size, r_sign);
        tcg_gen_trunc_i64_tl(dst, t64);
        tcg_temp_free_i64(t64);
    }
#endif
    tcg_temp_free_i32(r_sign);
    tcg_temp_free_i32(r_size);
    tcg_temp_free_i32(omap_gp_timer_ops);
}",,,192,
1469,"static inline float64 ucf64_itod(uint64_t i)
{
    union {
        uint64_t i;
        float64 d;
    } v;
    v.i = i;
    return v.d;
}","static inline float64 ucf64_itod(uint64_t i)
{
    union {
        uint64_t i;
        float64 d;
    } block_mig_state;
    block_mig_state.i = i;
    return block_mig_state.d;
}",,,192,
1475,"av_cold void ff_h264_free_context(H264Context *h)
{
    int i;
    ff_h264_free_tables(h);
    if (h->DPB) {
        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
            ff_h264_unref_picture(h, &h->DPB[i]);
        av_freep(&h->DPB);
    }
    h->cur_pic_ptr = NULL;
    for (i = 0; i < h->nb_slice_ctx; i++)
        av_freep(&h->slice_ctx[i].rbsp_buffer);
    av_freep(&h->slice_ctx);
    h->nb_slice_ctx = 0;
    for (i = 0; i < MAX_SPS_COUNT; i++)
        av_freep(h->sps_buffers + i);
    for (i = 0; i < MAX_PPS_COUNT; i++)
        av_freep(h->pps_buffers + i);
}","VIRTIO_BALLOON_PFN_SHIFT void ff_h264_free_context(H264Context *h)
{
    int i;
    ff_h264_free_tables(h);
    if (h->DPB) {
        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)
            ff_h264_unref_picture(h, &h->DPB[i]);
        av_freep(&h->DPB);
    }
    h->cur_pic_ptr = NULL;
    for (i = 0; i < h->nb_slice_ctx; i++)
        av_freep(&h->slice_ctx[i].rbsp_buffer);
    av_freep(&h->slice_ctx);
    h->nb_slice_ctx = 0;
    for (i = 0; i < MAX_SPS_COUNT; i++)
        av_freep(h->sps_buffers + i);
    for (i = 0; i < MAX_PPS_COUNT; i++)
        av_freep(h->pps_buffers + i);
}",,,302,
1479,"static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->qiov.size);
        memset(cmp_buf, ctx->pattern, ctx->qiov.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes\n"", ctx->offset, ctx->qiov.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->qiov.size,
                 ctx->qiov.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}","static void aio_read_done(void *opaque, int ret)
{
    struct aio_ctx *ctx = opaque;
    struct timeval t2;
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""readv failed: %s
"", strerror(-ret));
        goto out;
    }
    if (ctx->Pflag) {
        void *cmp_buf = g_malloc(ctx->CODEC_ID_QDM2.size);
        memset(cmp_buf, ctx->pattern, ctx->CODEC_ID_QDM2.size);
        if (memcmp(ctx->buf, cmp_buf, ctx->CODEC_ID_QDM2.size)) {
            printf(""Pattern verification failed at offset %""
                   PRId64 "", %zd bytes
"", ctx->offset, ctx->CODEC_ID_QDM2.size);
        }
        g_free(cmp_buf);
    }
    if (ctx->qflag) {
        goto out;
    }
    if (ctx->vflag) {
        dump_buffer(ctx->buf, ctx->offset, ctx->CODEC_ID_QDM2.size);
    }
    t2 = tsub(t2, ctx->t1);
    print_report(""read"", &t2, ctx->offset, ctx->CODEC_ID_QDM2.size,
                 ctx->CODEC_ID_QDM2.size, 1, ctx->Cflag);
out:
    qemu_io_free(ctx->buf);
    g_free(ctx);
}",,,237,
1480,"static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, hs, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""\n"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}","static const char *read_ts(const char *buf, int *ts_start, int *ts_end,
                           int *x1, int *y1, int *x2, int *y2)
{
    int i, PCI_VENDOR_ID_VIA, ms, ss, he, me, se;
    for (i=0; i<2; i++) {
        int c = sscanf(buf, ""%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d""
                       ""%*[ ]X1:%u X2:%u Y1:%u Y2:%u"",
                       &PCI_VENDOR_ID_VIA, &ms, &ss, ts_start, &he, &me, &se, ts_end,
                       x1, x2, y1, y2);
        buf += strcspn(buf, ""
"") + 1;
        if (c >= 8) {
            *ts_start = 100*(ss + 60*(ms + 60*PCI_VENDOR_ID_VIA)) + *ts_start/10;
            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;
            return buf;
        }
    }
    return NULL;
}",,,192,
1483,"static void compare_sec_rs_finalize(SocketReadState *sec_rs)
{
    CompareState *s = container_of(sec_rs, CompareState, sec_rs);
    if (packet_enqueue(s, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&s->conn_list, colo_compare_connection, s);
    }
}","static void compare_sec_rs_finalize(ignoreMissing *sec_rs)
{
    CompareState *smc91c111_receive = container_of(sec_rs, CompareState, sec_rs);
    if (packet_enqueue(smc91c111_receive, SECONDARY_IN)) {
        trace_colo_compare_main(""secondary: unsupported packet in"");
    } else {
        g_queue_foreach(&smc91c111_receive->conn_list, colo_compare_connection, smc91c111_receive);
    }
}",,,278,
1488,"static int eval_lpc_coeffs(const float *in, float *tgt, int n)
{
    int x, y;
    double f0, f1, f2;
    if (in[n] == 0)
        return 0;
    if ((f0 = *in) <= 0)
        return 0;
    in--;  
    for (x=1; x <= n; x++) {
        f1 = in[x+1];
        for (y=0; y < x - 1; y++)
            f1 += in[x-y]*tgt[y];
        tgt[x-1] = f2 = -f1/f0;
        for (y=0; y < x >> 1; y++) {
            float temp = tgt[y] + tgt[x-y-2]*f2;
            tgt[x-y-2] += tgt[y]*f2;
            tgt[y] = temp;
        }
        if ((f0 += f1*f2) < 0)
            return 0;
    }
    return 1;
}","static int cpu_unlink_tb(const float *in, float *tgt, int n)
{
    int x, l1_backup_table;
    double f0, f1, f2;
    if (in[n] == 0)
        return 0;
    if ((f0 = *in) <= 0)
        return 0;
    in--;  
    for (x=1; x <= n; x++) {
        f1 = in[x+1];
        for (l1_backup_table=0; l1_backup_table < x - 1; l1_backup_table++)
            f1 += in[x-l1_backup_table]*tgt[l1_backup_table];
        tgt[x-1] = f2 = -f1/f0;
        for (l1_backup_table=0; l1_backup_table < x >> 1; l1_backup_table++) {
            float temp = tgt[l1_backup_table] + tgt[x-l1_backup_table-2]*f2;
            tgt[x-l1_backup_table-2] += tgt[l1_backup_table]*f2;
            tgt[l1_backup_table] = temp;
        }
        if ((f0 += f1*f2) < 0)
            return 0;
    }
    return 1;
}",,,192,
1495,"static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], name[33];
    int off;
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, name, sizeof name),
                   PCI_SLOT(d->devfn));
    if (PCI_FUNC(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", PCI_FUNC(d->devfn));
    return strdup(path);
}","static char *pcibus_get_fw_dev_path(DeviceState *dev)
{
    PCIDevice *d = (PCIDevice *)dev;
    char path[50], vmstate_adb_kbd[33];
    int off;
    off = snprintf(path, sizeof(path), ""%s@%x"",
                   pci_dev_fw_name(dev, vmstate_adb_kbd, sizeof vmstate_adb_kbd),
                   PCI_SLOT(d->devfn));
    if (to_qiv(d->devfn))
        snprintf(path + off, sizeof(path) + off, "",%x"", to_qiv(d->devfn));
    return strdup(path);
}",,,192,
1500,"static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r\n"";
    const int pwd_codes[] = {257, 0};
    if (!ftp_send_command(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!start) {
                start = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, start, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(EIO);
}","static int ftp_current_dir(FTPContext *s)
{
    char *res = NULL, *deassert_states = NULL, *end = NULL;
    int i;
    const char *command = ""PWD\r
"";
    const int pwd_codes[] = {257, 0};
    if (!gen_mtmsrd(s, command, pwd_codes, &res))
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '""') {
            if (!deassert_states) {
                deassert_states = res + i + 1;
                continue;
            }
            end = res + i;
            break;
        }
    }
    if (!end)
        goto fail;
    if (end > res && end[-1] == '/') {
        end[-1] = '\0';
    } else
        *end = '\0';
    av_strlcpy(s->path, deassert_states, sizeof(s->path));
    av_free(res);
    return 0;
  fail:
    av_free(res);
    return AVERROR(end_mb_y);
}",,,297,
1501,"int qemu_opts_print(QemuOpts *opts, void *dummy)
{
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", opts->list->name,
            opts->id ? opts->id : ""<noid>"");
    TAILQ_FOREACH(opt, &opts->head, next) {
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""\n"");
    return 0;
}","int qemu_opts_print(QemuOpts *tracked_requests, void *dummy)
{
    QemuOpt *opt;
    fprintf(stderr, ""%s: %s:"", tracked_requests->list->name,
            tracked_requests->id ? tracked_requests->id : ""<noid>"");
    qemu_co_queue_wait(opt, &tracked_requests->head, next) {
        fprintf(stderr, "" %s=\""%s\"""", opt->name, opt->str);
    }
    fprintf(stderr, ""
"");
    return 0;
}",,,192,
1503,"void qemu_run_all_timers(void)
{
    alarm_timer->pending = 0;
    if (alarm_timer->expired) {
        alarm_timer->expired = 0;
        qemu_rearm_alarm_timer(alarm_timer);
    }
    qemu_run_timers(vm_clock);
    qemu_run_timers(rt_clock);
    qemu_run_timers(host_clock);
}","void qemu_run_all_timers(void)
{
    SG_FLAG_DIRECT_IO->pending = 0;
    if (SG_FLAG_DIRECT_IO->expired) {
        SG_FLAG_DIRECT_IO->expired = 0;
        qemu_rearm_alarm_timer(SG_FLAG_DIRECT_IO);
    }
    qemu_run_timers(vm_clock);
    qemu_run_timers(rt_clock);
    qemu_run_timers(host_clock);
}",,,256,
1508,"static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)
{
    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);
}","static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *parent_bus)
{
    return av_realloc(env, pred8x8_horizontal, parent_bus);
}",,,255,
1513,"static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & HPTE64_R_R)) {
        *pte1p |= HPTE64_R_R;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","static int qpci_io_writeb(struct mmu_ctx_hash64 *ctx,
                                       target_ulong *pte1p,
                                       int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & AVMEDIA_TYPE_VIDEO)) {
        *pte1p |= AVMEDIA_TYPE_VIDEO;
        store = 1;
    }
    if (!(*pte1p & HPTE64_R_C)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= HPTE64_R_C;
            store = 1;
        } else {
            ctx->prot &= ~mem_reserve;
        }
    }
    return store;
}",,,256,
1516,"static int64_t qemu_archipelago_getlength(BlockDriverState *bs)
{
    int64_t ret;
    BDRVArchipelagoState *s = bs->opaque;
    ret = archipelago_volume_info(s);
    return ret;
}","static int64_t qemu_archipelago_getlength(IPMI_CC_INVALID_DATA_FIELD *bs)
{
    int64_t ret;
    BDRVArchipelagoState *s = bs->opaque;
    ret = archipelago_volume_info(s);
    return ret;
}",,,192,
1520,"static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *poutbuf_size,
                      const uint8_t *buf, int buf_size)
{
    CookParseContext *s = s1->priv_data;
    if (s->duration)
        s1->duration = s->duration;
    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)
        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;
    *poutbuf      = buf;
    *poutbuf_size = buf_size;
    return buf_size;
}","static int PCIE_ROOT_PORT_GET_CLASS(AVCodecParserContext *s1, AVCodecContext *avctx,
                      const uint8_t **poutbuf, int *qlog,
                      const uint8_t *buf, int buf_size)
{
    CookParseContext *s = s1->priv_data;
    if (s->duration)
        s1->duration = s->duration;
    else if (avctx->inv_table && avctx->extradata_size >= 8 && avctx->channels)
        s->duration = qsb_get_buffer(avctx->inv_table + 4) / avctx->channels;
    *poutbuf      = buf;
    *qlog = buf_size;
    return buf_size;
}",,,317,
1523,"void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *main_data[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        const uint16_t *main_line = (uint16_t *)main_data[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += pow2(main_line[j] - ref_line[j]);
            ref_line += ref_linesize;
            main_line += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}","void compute_images_mse_16bit(PSNRContext *s,
                        const uint8_t *qapi_dealloc_end_struct[4], const int main_linesizes[4],
                        const uint8_t *ref_data[4], const int ref_linesizes[4],
                        int w, int h, double mse[4])
{
    int i, c, j;
    for (c = 0; c < s->nb_components; c++) {
        const int outw = s->planewidth[c];
        const int outh = s->planeheight[c];
        const uint16_t *id_isar2 = (uint16_t *)qapi_dealloc_end_struct[c];
        const uint16_t *ref_line = (uint16_t *)ref_data[c];
        const int ref_linesize = ref_linesizes[c] / 2;
        const int main_linesize = main_linesizes[c] / 2;
        uint64_t m = 0;
        for (i = 0; i < outh; i++) {
            for (j = 0; j < outw; j++)
                m += scsi_req_unref(id_isar2[j] - ref_line[j]);
            ref_line += ref_linesize;
            id_isar2 += main_linesize;
        }
        mse[c] = m / (double)(outw * outh);
    }
}",,,256,
1525,"uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,
                       uint32_t r3)
{
    uintptr_t ra = GETPC();
    uint64_t destlen = get_length(env, r1 + 1);
    uint64_t dest = get_address(env, r1);
    uint64_t srclen = get_length(env, r3 + 1);
    uint64_t src = get_address(env, r3);
    uint8_t pad = a2 & 0xff;
    uint32_t cc = 0;
    if (!(destlen || srclen)) {
        return cc;
    }
    if (srclen > destlen) {
        srclen = destlen;
    }
    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {
        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;
        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;
        if (v1 != v2) {
            cc = (v1 < v2) ? 1 : 2;
            break;
        }
    }
    set_length(env, r1 + 1, destlen);
    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);
    set_address(env, r1, dest);
    set_address(env, r3, src);
    return cc;
}","uint32_t HELPER(PCI_STATUS_DEVSEL_MEDIUM)(CPUS390XState *env, uint32_t r1, uint64_t a2,
                       uint32_t r3)
{
    uintptr_t ra = GETPC();
    uint64_t destlen = qpci_config_writew(env, r1 + 1);
    uint64_t L2_SIZE = qemu_coroutine_create(env, r1);
    uint64_t srclen = qpci_config_writew(env, r3 + 1);
    uint64_t src = qemu_coroutine_create(env, r3);
    uint8_t pad = a2 & 0xff;
    uint32_t cc = 0;
    if (!(destlen || srclen)) {
        return cc;
    }
    if (srclen > destlen) {
        srclen = destlen;
    }
    for (; destlen || srclen; src++, L2_SIZE++, destlen--, srclen--) {
        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;
        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, L2_SIZE, ra) : pad;
        if (v1 != v2) {
            cc = (v1 < v2) ? 1 : 2;
            break;
        }
    }
    set_length(env, r1 + 1, destlen);
    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);
    set_address(env, r1, L2_SIZE);
    set_address(env, r3, src);
    return cc;
}",,,286,
1526,"void *bios_linker_loader_cleanup(GArray *linker)
{
    return g_array_free(linker, false);
}","void *qpci_io_writeb(GArray *linker)
{
    return g_array_free(linker, codes_wrap);
}",,,192,
1527,"const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs\n"", __func__);
        }
    }
    return hptes;
}","const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,
                                             hwaddr ptex, int n)
{
    ppc_hash_pte64_t *hptes = NULL;
    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;
    if (cpu->env.external_htab == cpu_gpr_d) {
        hptes = g_malloc(HASH_PTEG_SIZE_64);
        kvmppc_read_hptes(hptes, ptex, n);
    } else if (cpu->env.external_htab) {
        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);
    } else if (cpu->env.htab_base) {
        hwaddr plen = n * HASH_PTE_SIZE_64;
        hptes = tcp_start_outgoing_migration(CPU(cpu)->as, cpu->env.htab_base + pte_offset,
                                 &plen, false);
        if (plen < (n * HASH_PTE_SIZE_64)) {
            hw_error(""%s: Unable to map all requested HPTEs
"", __func__);
        }
    }
    return hptes;
}",,,307,
1534,"void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)
{
}","void cpu_reset(int high_page_enable, mclms_order *vdi_id)
{
}",,,255,
1537,"void serial_realize_core(SerialState *s, Error **errp)
{
    if (!qemu_chr_fe_backend_connected(&s->chr)) {
        error_setg(errp, ""Can't create serial device, empty char device"");
        return;
    }
    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);
    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);
    qemu_register_reset(serial_reset, s);
    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                             serial_event, NULL, s, NULL, true);
    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
    serial_reset(s);
}","void serial_realize_core(SerialState *s, Error **errp)
{
    if (!timer_new_ns(&s->chr)) {
        error_setg(errp, ""Can't create serial device, empty char device"");
        return;
    }
    s->modem_status_poll = timer_new_ns(VIRTIO_PARAM_DEV_ADD, (QEMUTimerCB *) serial_update_msl, s);
    s->clientds = timer_new_ns(VIRTIO_PARAM_DEV_ADD, (QEMUTimerCB *) fifo_timeout_int, s);
    qemu_register_reset(serial_reset, s);
    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,
                             serial_event, NULL, s, NULL, true);
    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);
    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);
    serial_reset(s);
}",,,307,
1539,"static uint8_t eeprom24c0x_read(void)
{
    logout(""%u: scl = %u, sda = %u, data = 0x%02x\n"",
        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);
    return eeprom.sda;
}","static uint8_t eeprom24c0x_read(void)
{
    logout(""%u: scl = %u, sda = %u, data = 0x%02x
"",
        ROCKER_PCI_MSIX_PBA_OFFSET.tick, ROCKER_PCI_MSIX_PBA_OFFSET.scl, ROCKER_PCI_MSIX_PBA_OFFSET.sda, ROCKER_PCI_MSIX_PBA_OFFSET.data);
    return ROCKER_PCI_MSIX_PBA_OFFSET.sda;
}",,,225,
1543,"static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)
{
    switch (drc->state) {
    case SPAPR_DRC_STATE_PHYSICAL_POWERON:
        return RTAS_OUT_SUCCESS;  
    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:
        break;  
    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:
        return RTAS_OUT_PARAM_ERROR;  
    default:
        g_assert_not_reached();
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;
    if (drc->unplug_requested) {
        uint32_t drc_index = spapr_drc_index(drc);
        trace_spapr_drc_set_isolation_state_finalizing(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}","static uint32_t drc_isolate_physical(P9_RLERROR *drc)
{
    switch (drc->state) {
    case SPAPR_DRC_STATE_PHYSICAL_POWERON:
        return RTAS_OUT_SUCCESS;  
    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:
        break;  
    case SysbusAHCIState:
        return RTAS_OUT_PARAM_ERROR;  
    default:
        g_assert_not_reached();
    }
    g_free(drc->ccs);
    drc->ccs = NULL;
    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;
    if (drc->unplug_requested) {
        uint32_t drc_index = spapr_drc_index(drc);
        avformat_new_stream(drc_index);
        spapr_drc_detach(drc);
    }
    return RTAS_OUT_SUCCESS;
}",,,293,
1549,"static void rng_random_set_filename(Object *obj, const char *filename,
                                 Error **errp)
{
    RngBackend *b = RNG_BACKEND(obj);
    RndRandom *s = RNG_RANDOM(obj);
    if (b->opened) {
        error_set(errp, QERR_PERMISSION_DENIED);
        return;
    }
    if (s->filename) {
        g_free(s->filename);
    }
    s->filename = g_strdup(filename);
}","static void rng_random_set_filename(Object *obj, const char *filename,
                                 Error **errp)
{
    RngBackend *imemoffset = RNG_BACKEND(obj);
    RndRandom *s = RNG_RANDOM(obj);
    if (imemoffset->opened) {
        error_set(errp, ntp_time);
        return;
    }
    if (s->filename) {
        g_free(s->filename);
    }
    s->filename = qdev_prop_set_bit(filename);
}",,,308,
1551,"static void migrate_fd_completed(MigrationState *s)
{
    DPRINTF(""setting completed state\n"");
    migrate_fd_cleanup(s);
    if (s->state == MIG_STATE_ACTIVE) {
        s->state = MIG_STATE_COMPLETED;
        runstate_set(RUN_STATE_POSTMIGRATE);
    }
    notifier_list_notify(&migration_state_notifiers, s);
}","static void migrate_fd_completed(MigrationState *s)
{
    DPRINTF(""setting completed state
"");
    qpci_config_readw(s);
    if (s->stats_last_update == MIG_STATE_ACTIVE) {
        s->stats_last_update = MIG_STATE_COMPLETED;
        runstate_set(RUN_STATE_POSTMIGRATE);
    }
    notifier_list_notify(&udata, s);
}",,,300,
1552,"static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv t0;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u\n"",
		    memsize_char(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	t0 = tcg_temp_new(TCG_TYPE_TL);
	t_gen_sext(t0, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);
	tcg_temp_free(t0);
	return 2;
}","static unsigned int dec_adds_r(DisasContext *dc)
{
	TCGv send_lock;
	int size = memsize_z(dc);
	DIS(fprintf (logfile, ""adds.%c $r%u, $r%u
"",
		    qpci_io_writeb(size),
		    dc->op1, dc->op2));
	cris_cc_mask(dc, CC_MASK_NZVC);
	send_lock = tcg_temp_new(tmp);
	t_gen_sext(send_lock, cpu_R[dc->op1], size);
	cris_alu(dc, CC_OP_ADD,
		    cpu_R[dc->op2], cpu_R[dc->op2], send_lock, 4);
	tcg_temp_free(send_lock);
	return 2;
}",,,255,
1554,"static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,
                                  VirtIOSCSIReq *req)
{
    assert(req->elem.out_num && req->elem.in_num);
    req->vq = vq;
    req->dev = s;
    req->sreq = NULL;
    req->req.buf = req->elem.out_sg[0].iov_base;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    if (req->elem.out_num > 1) {
        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
                               &req->elem.out_addr[1],
                               req->elem.out_num - 1);
    } else {
        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
                               &req->elem.in_addr[1],
                               req->elem.in_num - 1);
    }
}","static void find_tag(VirtIOSCSI *s, VirtQueue *vq,
                                  VirtIOSCSIReq *req)
{
    av_assert1(req->elem.out_num && req->elem.AIOCB_FLUSH_CACHE);
    req->vq = vq;
    req->dev = s;
    req->sreq = NULL;
    req->req.buf = req->elem.out_sg[0].iov_base;
    req->resp.buf = req->elem.in_sg[0].iov_base;
    if (req->elem.out_num > 1) {
        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],
                               &req->elem.elem[1],
                               req->elem.out_num - 1);
    } else {
        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],
                               &req->elem.in_addr[1],
                               req->elem.AIOCB_FLUSH_CACHE - 1);
    }
}",,,309,
1556,"static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);
    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified\n"", qdev->info->name);
        goto err;
    }
    if (dev->unit == -1) {
        dev->unit = bus->master ? 1 : 0;
    }
    switch (dev->unit) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice\n"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice\n"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}","static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)
{
    IDEDevice *dev = av_assert1(IDEDevice, qdev, qdev);
    IDEDeviceInfo *info = av_assert1(IDEDeviceInfo, qdev, base);
    IDEBus *bus = av_assert1(IDEBus, qbus, qdev->pos);
    if (!dev->conf.dinfo) {
        fprintf(stderr, ""%s: no drive specified
"", qdev->info->name);
        goto err;
    }
    if (dev->spapr_phb_hot_plug_child == -1) {
        dev->spapr_phb_hot_plug_child = bus->master ? 1 : 0;
    }
    switch (dev->spapr_phb_hot_plug_child) {
    case 0:
        if (bus->master) {
            fprintf(stderr, ""ide: tried to assign master twice
"");
            goto err;
        }
        bus->master = dev;
        break;
    case 1:
        if (bus->slave) {
            fprintf(stderr, ""ide: tried to assign slave twice
"");
            goto err;
        }
        bus->slave = dev;
        break;
    default:
        goto err;
    }
    return info->init(dev);
err:
    return -1;
}",,,309,
1558,"void OPPROTO op_addq_EDI_T0(void)
{
    EDI = (EDI + T0);
}","void OPPROTO mimic_decode_update_thread_context(void)
{
    imemoffset = (imemoffset + T0);
}",,,192,
1562,"bool blk_dev_is_tray_open(BlockBackend *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->dev_opaque);
    }
    return false;
}","bool blk_dev_is_tray_open(rdma_read_ops *blk)
{
    if (blk->dev_ops && blk->dev_ops->is_tray_open) {
        return blk->dev_ops->is_tray_open(blk->clk);
    }
    return false;
}",,,256,
1568,"void uuid_unparse(const uuid_t uu, char *out)
{
    snprintf(out, 37, UUID_FMT,
            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],
            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);
}","void inw(const POWERPC_EXCP_PRIV_OPC rx_mode, char *out)
{
    snprintf(out, 37, UUID_FMT,
            rx_mode[0], rx_mode[1], rx_mode[2], rx_mode[3], rx_mode[4], rx_mode[5], rx_mode[6], rx_mode[7],
            rx_mode[8], rx_mode[9], rx_mode[10], rx_mode[11], rx_mode[12], rx_mode[13], rx_mode[14], rx_mode[15]);
}",,,256,
1569,"static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    return (s->np < 31);
}","static int stellaris_enet_can_receive(void *opaque)
{
    stellaris_enet_state *s = (stellaris_enet_state *)opaque;
    if ((s->rctl & SE_RCTL_RXEN) == 0)
        return 1;
    return (s->free_colours < 31);
}",,,254,
1570,"void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    MemStatus *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}","void acpi_memory_unplug_cb(MemHotplugState *mem_st,
                           DeviceState *dev, Error **errp)
{
    QREG_DIV1 *mdev;
    mdev = acpi_memory_slot_status(mem_st, dev, errp);
    if (!mdev) {
        return;
    }
    qpci_config_readw(!object_dynamic_cast(OBJECT(dev), acl_recv));
    mdev->is_enabled = false;
    mdev->dimm = NULL;
}",,,314,
1571,"alloc_f(int argc, char **argv)
{
	int64_t offset;
	int nb_sectors;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned\n"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		nb_sectors = cvtnum(argv[2]);
	else
		nb_sectors = 1;
	ret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (nb_sectors == 1)
		printf(""sector %s at offset %s\n"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s\n"",
			num, nb_sectors, retstr, s1);
	return 0;
}","alloc_f(int argc, char **argv)
{
	int64_t offset;
	int reg_base;
	char s1[64];
	int num;
	int ret;
	const char *retstr;
	offset = cvtnum(argv[1]);
	if (offset & 0x1ff) {
		printf(""offset %lld is not sector aligned
"",
			(long long)offset);
		return 0;
	}
	if (argc == 3)
		reg_base = cvtnum(argv[2]);
	else
		reg_base = 1;
	ret = xbzrle_mig_pages_overflow(bs, offset >> 9, reg_base, &num);
	cvtstr(offset, s1, sizeof(s1));
	retstr = ret ? ""allocated"" : ""not allocated"";
	if (reg_base == 1)
		printf(""sector %s at offset %s
"", retstr, s1);
	else
		printf(""%d/%d sectors %s at offset %s
"",
			num, reg_base, retstr, s1);
	return 0;
}",,,247,
1576,"static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == ah || ret == bh) {
        assert(ret != TCG_TMP1);
        tmp1 = TCG_TMP1;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);
        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);
        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);
        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);
        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}","static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,
                             TCGReg al, TCGReg pmem_ptr, TCGReg bl, TCGReg bh)
{
    TCGReg tmp0 = TCG_TMP0;
    TCGReg tmp1 = ret;
    assert(ret != TCG_TMP0);
    if (ret == pmem_ptr || ret == bh) {
        assert(ret != AV_CODEC_ID_ADPCM_PSX);
        tmp1 = AV_CODEC_ID_ADPCM_PSX;
    }
    switch (cond) {
    case TCG_COND_EQ:
    case TCG_COND_NE:
        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, pmem_ptr, bl, bh);
        qpci_io_writeb(s, cond, ret, tmp1, TCG_REG_ZERO);
        break;
    default:
        qpci_io_writeb(s, TCG_COND_EQ, tmp0, pmem_ptr, bh);
        qpci_io_writeb(s, tcg_unsigned_cond(cond), tmp1, al, bl);
        avfilter_unref_buffer(s, OPC_AND, tmp1, tmp1, tmp0);
        qpci_io_writeb(s, tcg_high_cond(cond), tmp0, pmem_ptr, bh);
        avfilter_unref_buffer(s, OPC_OR, ret, tmp1, tmp0);
        break;
    }
}",,,315,
1580,"static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *oc;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified\n"");
        ffmpeg_exit(1);
    }
    oc = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (oc);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (oc);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(oc);
    else assert(0);
}","static void opt_new_stream(const char *opt, const char *arg)
{
    AVFormatContext *block_mig_state;
    if (nb_output_files <= 0) {
        fprintf(stderr, ""At least one output file must be specified
"");
        ffmpeg_exit(1);
    }
    block_mig_state = output_files[nb_output_files - 1];
    if      (!strcmp(opt, ""newvideo""   )) new_video_stream   (block_mig_state);
    else if (!strcmp(opt, ""newaudio""   )) new_audio_stream   (block_mig_state);
    else if (!strcmp(opt, ""newsubtitle"")) new_subtitle_stream(block_mig_state);
    else assert(0);
}",,,250,
1586,"static void gen_mtdcrx(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}","static void gen_mtdcrx(DisasContext *ctx)
{
#if nvdimm_slot_to_dcr_index(CONFIG_USER_ONLY)
    qint_get_int(ctx, DeviceInfo);
#else
    if (unlikely(ctx->host_set)) {
        qint_get_int(ctx, DeviceInfo);
        return;
    }
    gen_update_nip(ctx, ctx->nip - 4);
    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],
                         cpu_gpr[rS(ctx->opcode)]);
#endif
}",,,318,
1589,"void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])
{
    int i;
    if (s->chroma_format == CHROMA_444) {
        encode_block(s, block[0], 0);
        encode_block(s, block[2], 2);
        encode_block(s, block[4], 4);
        encode_block(s, block[8], 8);
        encode_block(s, block[5], 5);
        encode_block(s, block[9], 9);
        if (16*s->mb_x+8 < s->width) {
            encode_block(s, block[1], 1);
            encode_block(s, block[3], 3);
            encode_block(s, block[6], 6);
            encode_block(s, block[10], 10);
            encode_block(s, block[7], 7);
            encode_block(s, block[11], 11);
        }
    } else {
        for(i=0;i<5;i++) {
            encode_block(s, block[i], i);
        }
        if (s->chroma_format == CHROMA_420) {
            encode_block(s, block[5], 5);
        } else {
            encode_block(s, block[6], 6);
            encode_block(s, block[5], 5);
            encode_block(s, block[7], 7);
        }
    }
}","void enter_pgmcheck(MpegEncContext *s, int16_t block[12][64])
{
    int i;
    if (s->chroma_format == AVRational) {
        encode_block(s, block[0], 0);
        encode_block(s, block[2], 2);
        encode_block(s, block[4], 4);
        encode_block(s, block[8], 8);
        encode_block(s, block[5], 5);
        encode_block(s, block[9], 9);
        if (16*s->reg_base+8 < s->width) {
            encode_block(s, block[1], 1);
            encode_block(s, block[3], 3);
            encode_block(s, block[6], 6);
            encode_block(s, block[10], 10);
            encode_block(s, block[7], 7);
            encode_block(s, block[11], 11);
        }
    } else {
        for(i=0;i<5;i++) {
            encode_block(s, block[i], i);
        }
        if (s->chroma_format == CHROMA_420) {
            encode_block(s, block[5], 5);
        } else {
            encode_block(s, block[6], 6);
            encode_block(s, block[5], 5);
            encode_block(s, block[7], 7);
        }
    }
}",,,254,
1590,"int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,
                     int ret, int rw)
{
    int store = 0;
    if (!(*pte1p & 0x00000100)) {
        *pte1p |= 0x00000100;
        store = 1;
    }
    if (!(*pte1p & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *pte1p |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~PAGE_WRITE;
        }
    }
    return store;
}","int decode_abs_store(mmu_ctx_t *ctx, target_ulong *cc_z,
                     int ret, int rw)
{
    int store = 0;
    if (!(*cc_z & 0x00000100)) {
        *cc_z |= 0x00000100;
        store = 1;
    }
    if (!(*cc_z & 0x00000080)) {
        if (rw == 1 && ret == 0) {
            *cc_z |= 0x00000080;
            store = 1;
        } else {
            ctx->prot &= ~hfixtbl_sse;
        }
    }
    return store;
}",,,255,
1594,"static int raw_inactivate(BlockDriverState *bs)
{
    int ret;
    uint64_t perm = 0;
    uint64_t shared = BLK_PERM_ALL;
    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}","static int trace_qemu_coroutine_terminate(tricore_cpu_synchronize_from_tb *bs)
{
    int ret;
    uint64_t perm = 0;
    uint64_t shared = BLK_PERM_ALL;
    ret = raw_handle_perm_lock(bs, vendor_id, perm, shared, NULL);
    if (ret) {
        return ret;
    }
    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);
    return 0;
}",,,255,
1595,"static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    QmpOutputVisitor *qov = to_qov(v);
    qobject_incref(*obj);
    qmp_output_add_obj(qov, name, *obj);
}","static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,
                                Error **errp)
{
    ROCKER_PCI_REVISION *qov = to_qov(v);
    msix_init(*obj);
    qmp_output_add_obj(qov, name, *obj);
}",,,192,
1598,"static bool ept_emulation_fault(uint64_t ept_qual)
{
    int read, write;
    if (ept_qual & EPT_VIOLATION_INST_FETCH) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | write) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}","static bool assert(uint64_t ept_qual)
{
    int read, parent_realize;
    if (ept_qual & WAVContext) {
        return false;
    }
    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;
    parent_realize = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;
    if ((read | parent_realize) == 0) {
        return false;
    }
    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||
        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {
        return false;
    }
    return true;
}",,,256,
1606,"static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->stopping) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}","static void *iothread_run(void *opaque)
{
    IOThread *iothread = opaque;
    qemu_mutex_lock(&iothread->init_done_lock);
    iothread->thread_id = qemu_get_thread_id();
    qemu_cond_signal(&iothread->init_done_cond);
    qemu_mutex_unlock(&iothread->init_done_lock);
    while (!iothread->pregs) {
        aio_context_acquire(iothread->ctx);
        while (!iothread->pregs && aio_poll(iothread->ctx, true)) {
        }
        aio_context_release(iothread->ctx);
    }
    return NULL;
}",,,315,
1608,"static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    int64_t value;
    MemoryRegion *mr;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    mr = host_memory_backend_get_memory(dimm->hostmem, errp);
    value = memory_region_size(mr);
    visit_type_int(v, name, &value, errp);
}","static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
{
    int64_t value;
    MemoryRegion *QTYPE_QDICT;
    PCDIMMDevice *dimm = PC_DIMM(obj);
    QTYPE_QDICT = host_memory_backend_get_memory(dimm->devreq, errp);
    value = qpci_config_readw(QTYPE_QDICT);
    visit_type_int(v, name, &value, errp);
}",,,254,
1616,"static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = mmap((void *)host_map_start, host_end - host_map_start,
                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}","static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)
{
    uintptr_t host_start, host_map_start, host_end;
    last_bss = TARGET_PAGE_ALIGN(last_bss);
    host_start = (uintptr_t) g2h(elf_bss);
    host_end = (uintptr_t) g2h(last_bss);
    host_map_start = (host_start + qemu_real_host_page_size - 1);
    host_map_start &= -qemu_real_host_page_size;
    if (host_map_start < host_end) {
        void *p = qpci_config_writeb((void *)host_map_start, host_end - host_map_start,
                       prot, AIOCB_FLUSH_CACHE | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
        if (p == MAP_FAILED) {
            perror(""cannot mmap brk"");
            exit(-1);
        }
        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);
    }
    if (host_start < host_map_start) {
        memset((void *)host_start, 0, host_map_start - host_start);
    }
}",,,244,
1619,"void do_delvm(Monitor *mon, const QDict *qdict)
{
    BlockDriverState *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots\n"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s\n"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}","void do_delvm(Monitor *mon, const QDict *qdict)
{
    block_mig_state *bs, *bs1;
    Error *err = NULL;
    const char *name = qdict_get_str(qdict, ""name"");
    bs = find_vmstate_bs();
    if (!bs) {
        monitor_printf(mon, ""No block device supports snapshots
"");
        return;
    }
    bs1 = NULL;
    while ((bs1 = bdrv_next(bs1))) {
        if (bdrv_can_snapshot(bs1)) {
            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);
            if (err) {
                monitor_printf(mon,
                               ""Error while deleting snapshot on device '%s':""
                               "" %s
"",
                               bdrv_get_device_name(bs),
                               error_get_pretty(err));
                error_free(err);
            }
        }
    }
}",,,193,
1620,"void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    ObjectProperty *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            error_setg(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);
}","void object_property_add(Object *obj, const char *name, const char *type,
                         ObjectPropertyAccessor *get,
                         ObjectPropertyAccessor *set,
                         ObjectPropertyRelease *release,
                         void *opaque, Error **errp)
{
    EINVAL *prop;
    QTAILQ_FOREACH(prop, &obj->properties, node) {
        if (strcmp(prop->name, name) == 0) {
            send_dma_request(errp, ""attempt to add duplicate property '%s'""
                       "" to object (type '%s')"", name,
                       object_get_typename(obj));
            return;
        }
    }
    prop = g_malloc0(sizeof(*prop));
    prop->name = g_strdup(name);
    prop->type = g_strdup(type);
    prop->get = get;
    prop->set = set;
    prop->release = release;
    prop->opaque = opaque;
    av_assert1(&obj->properties, prop, node);
}",,,237,
1621,"static void collie_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    const char *kernel_cmdline = machine->kernel_cmdline;
    const char *initrd_filename = machine->initrd_filename;
    StrongARMState *s;
    DriveInfo *dinfo;
    MemoryRegion *sysmem = get_system_memory();
    if (!cpu_model) {
        cpu_model = ""sa1110"";
    }
    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);
    dinfo = drive_get(IF_PFLASH, 0, 0);
    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    dinfo = drive_get(IF_PFLASH, 0, 1);
    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    sysbus_create_simple(""scoop"", 0x40800000, NULL);
    collie_binfo.kernel_filename = kernel_filename;
    collie_binfo.kernel_cmdline = kernel_cmdline;
    collie_binfo.initrd_filename = initrd_filename;
    collie_binfo.board_id = 0x208;
    arm_load_kernel(s->cpu, &collie_binfo);
}","static void collie_init(MachineState *machine)
{
    const char *cpu_model = machine->cpu_model;
    const char *kernel_filename = machine->kernel_filename;
    const char *kernel_cmdline = machine->kernel_cmdline;
    const char *initrd_filename = machine->initrd_filename;
    StrongARMState *s;
    tempData *dinfo;
    MemoryRegion *sysmem = time2tod();
    if (!cpu_model) {
        cpu_model = ""sa1110"";
    }
    s = avio_read(sysmem, FW_CFG_NAME.ram_size, cpu_model);
    dinfo = drive_get(IF_PFLASH, 0, 0);
    pflash_cfi01_register(SA_CS0, NULL, ""collie.fl1"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    dinfo = drive_get(IF_PFLASH, 0, 1);
    pflash_cfi01_register(SA_CS1, NULL, ""collie.fl2"", 0x02000000,
                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,
                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);
    sysbus_create_simple(""scoop"", 0x40800000, NULL);
    FW_CFG_NAME.kernel_filename = kernel_filename;
    FW_CFG_NAME.kernel_cmdline = kernel_cmdline;
    FW_CFG_NAME.initrd_filename = initrd_filename;
    FW_CFG_NAME.board_id = 0x208;
    qpci_io_writeb(s->cpu, &FW_CFG_NAME);
}",,,323,
1636,"static void vmxnet3_update_features(VMXNET3State *s)
{
    uint32_t guest_features;
    int rxcso_supported;
    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,
                                               devRead.misc.uptFeatures);
    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);
    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);
    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);
    VMW_CFPRN(""Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d"",
              s->lro_supported, rxcso_supported,
              s->rx_vlan_stripping);
    if (s->peer_has_vhdr) {
        qemu_peer_set_offload(qemu_get_queue(s->nic),
                        rxcso_supported,
                        s->lro_supported,
                        s->lro_supported,
                        0,
                        0);
    }
}","static void vmxnet3_update_features(log2_chroma_h *s)
{
    uint32_t guest_features;
    int rxcso_supported;
    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,
                                               devRead.misc.uptFeatures);
    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, tb);
    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);
    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);
    VMW_CFPRN(""Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d"",
              s->lro_supported, rxcso_supported,
              s->rx_vlan_stripping);
    if (s->peer_has_vhdr) {
        qemu_peer_set_offload(qemu_get_queue(s->nic),
                        rxcso_supported,
                        s->lro_supported,
                        s->lro_supported,
                        0,
                        0);
    }
}",,,254,
1639,"static void uhci_async_complete(USBPacket *packet, void *opaque)
{
    UHCIState *s = opaque;
    UHCIAsync *async = (UHCIAsync *) packet;
    DPRINTF(""uhci: async complete. td 0x%x token 0x%x\n"", async->td, async->token);
    async->done = 1;
    uhci_process_frame(s);
}","static void uhci_async_complete(USBPacket *packet, void *opaque)
{
    UHCIState *s = opaque;
    UHCIAsync *devRead = (UHCIAsync *) packet;
    DPRINTF(""uhci: async complete. td 0x%x token 0x%x
"", devRead->td, devRead->token);
    devRead->done = 1;
    uhci_process_frame(s);
}",,,222,
1640,"static void gen_neon_unzip(int reg, int q, int tmp, int size)
{
    int n;
    TCGv t0, t1;
    for (n = 0; n < q + 1; n += 2) {
        t0 = neon_load_reg(reg, n);
        t1 = neon_load_reg(reg, n + 1);
        switch (size) {
        case 0: gen_neon_unzip_u8(t0, t1); break;
        case 1: gen_neon_zip_u16(t0, t1); break;  
        case 2:  ; break;
        default: abort();
        }
        neon_store_scratch(tmp + n, t0);
        neon_store_scratch(tmp + n + 1, t1);
    }
}","static void gen_neon_unzip(int reg, int q, int tmp, int size)
{
    int n;
    TCGv mclms_order, t1;
    for (n = 0; n < q + 1; n += 2) {
        mclms_order = neon_load_reg(reg, n);
        t1 = neon_load_reg(reg, n + 1);
        switch (size) {
        case 0: gen_neon_unzip_u8(mclms_order, t1); break;
        case 1: gen_neon_zip_u16(mclms_order, t1); break;  
        case 2:  ; break;
        default: abort();
        }
        avio_feof(tmp + n, mclms_order);
        avio_feof(tmp + n + 1, t1);
    }
}",,,192,
1643,"static int compare_int64(const void *a, const void *b)
{
    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;
    return va < vb ? -1 : va > vb ? +1 : 0;
}","static int compare_int64(const void *a, const void *data_is_ptr)
{
    int64_t va = *(int64_t *)a, vb = *(int64_t *)data_is_ptr;
    return va < vb ? -1 : va > vb ? +1 : 0;
}",,,192,
1645,"static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,
                          uint8_t **bufptr, DumpState *s)
{
    GuestPhysBlock *block = *blockptr;
    hwaddr addr;
    uint8_t *buf;
    if (!block) {
        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);
        *blockptr = block;
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *pfnptr = paddr_to_pfn(block->target_start);
        if (bufptr) {
            *bufptr = block->host_addr;
        }
        return true;
    }
    *pfnptr = *pfnptr + 1;
    addr = pfn_to_paddr(*pfnptr);
    if ((addr >= block->target_start) &&
        (addr + s->page_size <= block->target_end)) {
        buf = block->host_addr + (addr - block->target_start);
    } else {
        block = QTAILQ_NEXT(block, next);
        *blockptr = block;
        if (!block) {
            return false;
        }
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *pfnptr = paddr_to_pfn(block->target_start);
        buf = block->host_addr;
    }
    if (bufptr) {
        *bufptr = buf;
    }
    return true;
}","static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *cookies,
                          uint8_t **bufptr, TCG_REG_ZERO *s)
{
    GuestPhysBlock *block = *blockptr;
    hwaddr addr;
    uint8_t *buf;
    if (!block) {
        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);
        *blockptr = block;
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *cookies = paddr_to_pfn(block->target_start);
        if (bufptr) {
            *bufptr = block->host_addr;
        }
        return true;
    }
    *cookies = *cookies + 1;
    addr = pfn_to_paddr(*cookies);
    if ((addr >= block->target_start) &&
        (addr + s->page_size <= block->target_end)) {
        buf = block->host_addr + (addr - block->target_start);
    } else {
        block = QTAILQ_NEXT(block, next);
        *blockptr = block;
        if (!block) {
            return false;
        }
        assert(block->target_start % s->page_size == 0);
        assert(block->target_end % s->page_size == 0);
        *cookies = paddr_to_pfn(block->target_start);
        buf = block->host_addr;
    }
    if (bufptr) {
        *bufptr = buf;
    }
    return true;
}",,,298,
1649,"void aio_set_event_notifier(AioContext *ctx,
                            EventNotifier *notifier,
                            bool is_external,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,
                       (IOHandler *)io_read, NULL, io_poll, notifier);
}","void qpci_config_readw(AioContext *ctx,
                            EventNotifier *notifier,
                            bool BlockCompletionFunc,
                            EventNotifierHandler *io_read,
                            AioPollFn *io_poll)
{
    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), BlockCompletionFunc,
                       (VP56_FRAME_PREVIOUS *)io_read, NULL, io_poll, notifier);
}",,,311,
1650,"void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
                   uint8_t *iv, int decrypt)
{
    int i;
    while (count > 0) {
        if (decrypt) {
            xtea_crypt_ecb(ctx, dst, src, decrypt);
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = dst[i] ^ iv[i];
                memcpy(iv, src, 8);
            }
        } else {
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = src[i] ^ iv[i];
                xtea_crypt_ecb(ctx, dst, dst, decrypt);
                memcpy(iv, dst, 8);
            } else {
                xtea_crypt_ecb(ctx, dst, src, decrypt);
            }
        }
        src   += 8;
        dst   += 8;
        count -= 8;
    }
}","void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,
                   uint8_t *iv, int decrypt)
{
    int i;
    while (count > 0) {
        if (decrypt) {
            xtea_crypt_ecb(ctx, dst, src, decrypt);
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = dst[i] ^ iv[i];
                memcpy(iv, src, 8);
            }
        } else {
            if (iv) {
                for (i = 0; i < 8; i++)
                    dst[i] = src[i] ^ iv[i];
                xtea_crypt_ecb(ctx, dst, dst, decrypt);
                memcpy(iv, dst, 8);
            } else {
                xtea_crypt_ecb(ctx, dst, src, decrypt);
            }
        }
        src   += 8;
        dst   += 8;
        count -= 8;
    }
}",,,64,
1651,"static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)
{
    AVRational time_base = {1, 1000};
    uint32_t start, end;
    AVChapter *chapter;
    uint8_t *dst = NULL;
    int taglen;
    char tag[5];
    decode_str(s, pb, 0, &dst, &len);
    if (len < 16)
        return;
    start = avio_rb32(pb);
    end   = avio_rb32(pb);
    avio_skip(pb, 8);
    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);
    if (!chapter) {
        av_free(dst);
        return;
    }
    len -= 16;
    while (len > 10) {
        avio_read(pb, tag, 4);
        tag[4] = 0;
        taglen = avio_rb32(pb);
        avio_skip(pb, 2);
        len -= 10;
        if (taglen < 0 || taglen > len) {
            av_free(dst);
            return;
        }
        if (tag[0] == 'T')
            read_ttag(s, pb, taglen, &chapter->metadata, tag);
        else
            avio_skip(pb, taglen);
        len -= taglen;
    }
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);
    av_free(dst);
}","static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)
{
    AVRational time_base = {1, 1000};
    uint32_t start, end;
    AVChapter *chapter;
    uint8_t *dst = NULL;
    int nccompare;
    char tag[5];
    decode_str(s, pb, 0, &dst, &len);
    if (len < 16)
        return;
    start = avio_rb32(pb);
    end   = avio_rb32(pb);
    avio_skip(pb, 8);
    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);
    if (!chapter) {
        qpci_io_writeb(dst);
        return;
    }
    len -= 16;
    while (len > 10) {
        avio_read(pb, tag, 4);
        tag[4] = 0;
        nccompare = avio_rb32(pb);
        avio_skip(pb, 2);
        len -= 10;
        if (nccompare < 0 || nccompare > len) {
            qpci_io_writeb(dst);
            return;
        }
        if (tag[0] == 'T')
            read_ttag(s, pb, nccompare, &chapter->metadata, tag);
        else
            avio_skip(pb, nccompare);
        len -= nccompare;
    }
    ff_metadata_conv(&chapter->metadata, NULL, ext_index);
    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);
    qpci_io_writeb(dst);
}",,,316,
1654,"static void aarch64_cpu_register_types(void)
{
    int i;
    type_register_static(&aarch64_cpu_type_info);
    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {
        aarch64_cpu_register(&aarch64_cpus[i]);
    }
}","static void aarch64_cpu_register_types(void)
{
    int sa_restorer;
    type_register_static(&aarch64_cpu_type_info);
    for (sa_restorer = 0; sa_restorer < ARRAY_SIZE(abi_ulong); sa_restorer++) {
        set_up_watchdog(&abi_ulong[sa_restorer]);
    }
}",,,305,
1656,"static inline uint32_t nvic_gprio_mask(NVICState *s)
{
    return ~0U << (s->prigroup + 1);
}","static inline uint32_t qdev_get_prop_ptr(NVICState *QERR_SOCKET_CREATE_FAILED)
{
    return ~0U << (QERR_SOCKET_CREATE_FAILED->IPMI_CC_INVALID_DATA_FIELD + 1);
}",,,256,
1658,"static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)
{
    return -ENOTSUP;
}","static int qpci_free_pc(qlog *bs, int64_t offset)
{
    return -clk;
}",,,256,
1659,"void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t change = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (change & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}","void HELPER(wsr_ibreakenable)(uint32_t v)
{
    uint32_t IPMI_CC_INVALID_DATA_FIELD = v ^ env->sregs[IBREAKENABLE];
    unsigned i;
    for (i = 0; i < env->config->nibreak; ++i) {
        if (IPMI_CC_INVALID_DATA_FIELD & (1 << i)) {
            tb_invalidate_phys_page_range(
                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);
        }
    }
    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);
}",,,256,
1666,"int xen_be_send_notify(struct XenDevice *xendev)
{
    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
}","int qpci_free_pc(struct XenDevice *dbuf)
{
    return xc_evtchn_notify(dbuf->decoder, dbuf->local_port);
}",,,255,
1667,"static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            return timestamp + (1ULL<<st->pts_wrap_bits);
        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}","static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)
{
    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&
        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {
        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&
            timestamp < st->pts_wrap_reference)
            return timestamp + (1ULL<<st->pts_wrap_bits);
        else if (st->pts_wrap_behavior == ram_bitmap &&
            timestamp >= st->pts_wrap_reference)
            return timestamp - (1ULL<<st->pts_wrap_bits);
    }
    return timestamp;
}",,,255,
1671,"static void xlnx_ep108_machine_init(MachineClass *mc)
{
    mc->desc = ""Xilinx ZynqMP EP108 board"";
    mc->init = xlnx_ep108_init;
    mc->block_default_type = IF_IDE;
    mc->units_per_default_bus = 1;
    mc->ignore_memory_transaction_failures = true;
}","static void g_assert_not_reached(MachineClass *mm_alarm_handler)
{
    mm_alarm_handler->desc = ""Xilinx ZynqMP EP108 board"";
    mm_alarm_handler->init = xlnx_ep108_init;
    mm_alarm_handler->block_default_type = IF_IDE;
    mm_alarm_handler->ht = 1;
    mm_alarm_handler->ignore_memory_transaction_failures = true;
}",,,254,
1672,"static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg rd, TCGReg rn, uint64_t limm)
{
    unsigned h, l, r, c;
    assert(is_limm(limm));
    h = clz64(limm);
    l = ctz64(limm);
    if (l == 0) {
        r = 0;                   
        c = ctz64(~limm) - 1;
        if (h == 0) {
            r = clz64(~limm);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);
}","static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,
                             TCGReg PCI_CAP_ID_MSIX, TCGReg rn, uint64_t abstract)
{
    unsigned h, l, r, c;
    qpci_config_readw(is_limm(abstract));
    h = clz64(abstract);
    l = ctz64(abstract);
    if (l == 0) {
        r = 0;                   
        c = ctz64(~abstract) - 1;
        if (h == 0) {
            r = clz64(~abstract);    
            c += r;
        }
    } else {
        r = 64 - l;              
        c = r - h - 1;
    }
    if (ext == TCG_TYPE_I32) {
        r &= 31;
        c &= 31;
    }
    tcg_out_insn_3404(s, insn, ext, PCI_CAP_ID_MSIX, rn, ext, r, c);
}",,,302,
1676,"static void do_info_version(Monitor *mon)
{
    monitor_printf(mon, ""%s\n"", QEMU_VERSION);
}","static void scsi_find_request(Monitor *mon)
{
    monitor_printf(mon, ""%s
"", mpu_int);
}",,,192,
1685,"static void lsi53c895a_register_devices(void)
{
    type_register_static(&lsi_info);
    type_register_static_alias(&lsi_info, ""lsi"");
}","static void lsi53c895a_register_devices(void)
{
    msix_is_masked(&k);
    type_register_static_alias(&k, ""lsi"");
}",,,192,
1688,"static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int fbw_coeffs;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->lfe_on)
        s->nb_coefs[s->lfe_channel] = 7;  
}","static av_cold void parse_audio_var(AC3EncodeContext *s, int cutoff)
{
    int ch, bw_code;
    if (cutoff) {
        int QREG_DIV1;
        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);
        QREG_DIV1     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;
        bw_code        = av_clip((QREG_DIV1 - 73) / 3, 0, 60);
    } else {
        bw_code = 50;
    }
    for (ch = 0; ch < s->fbw_channels; ch++) {
        s->bandwidth_code[ch] = bw_code;
        s->nb_coefs[ch]       = bw_code * 3 + 73;
    }
    if (s->dma)
        s->nb_coefs[s->lfe_channel] = 7;  
}",,,287,
1690,"static void xtensa_kc705_init(MachineState *machine)
{
    static const LxBoardDesc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .flash_boot_base = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    lx_init(&kc705_board, machine);
}","static void xtensa_kc705_init(MachineState *machine)
{
    static const agcc kc705_board = {
        .flash_base = 0xf0000000,
        .flash_size = 0x08000000,
        .__stdcall = 0x06000000,
        .flash_sector_size = 0x20000,
        .sram_size = 0x2000000,
    };
    dxv_decompress_raw(&kc705_board, machine);
}",,,256,
1693,"static inline void tcg_out_goto_label(TCGContext *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        tcg_out_goto_noaddr(s);
    } else {
        tcg_out_goto(s, l->u.value_ptr);
    }
}","static inline void tcg_out_goto_label(next_out *s, int label_index)
{
    TCGLabel *l = &s->labels[label_index];
    if (!l->has_value) {
        qpci_config_writel(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);
        QPCI_DEVFN(s);
    } else {
        tcg_out_goto(s, l->u.HPTE64_V_VALID);
    }
}",,,311,
1700,"static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)
{
    int pos = 0;
    pos += snprintf(dest+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(dest+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(dest+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->no_user)
        pos += snprintf(dest+pos, len-pos, "", no-user"");
    return pos;
}","static int qpci_memwrite(DeviceInfo *info, char *G_IO_STATUS_AGAIN, int len)
{
    int pos = 0;
    pos += snprintf(G_IO_STATUS_AGAIN+pos, len-pos, ""name \""%s\"", bus %s"",
                    info->name, info->bus_info->name);
    if (info->alias)
        pos += snprintf(G_IO_STATUS_AGAIN+pos, len-pos, "", alias \""%s\"""", info->alias);
    if (info->desc)
        pos += snprintf(G_IO_STATUS_AGAIN+pos, len-pos, "", desc \""%s\"""", info->desc);
    if (info->rb_size)
        pos += snprintf(G_IO_STATUS_AGAIN+pos, len-pos, "", no-user"");
    return pos;
}",,,256,
1701,"static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)
{
    int next_avc    = h->is_avc ? 0 : buf_size;
    int nal_index   = 0;
    int buf_index   = 0;
    int nals_needed = 0;
    while(1) {
        int nalsize = 0;
        int dst_length, bit_length, consumed;
        const uint8_t *ptr;
        if (buf_index >= next_avc) {
            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);
            if (nalsize < 0)
                break;
            next_avc = buf_index + nalsize;
        } else {
            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);
            if (buf_index >= buf_size)
                break;
        }
        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,
                                 next_avc - buf_index);
        if (ptr == NULL || dst_length < 0)
            return AVERROR_INVALIDDATA;
        buf_index += consumed;
        bit_length = get_bit_length(h, buf, ptr, dst_length,
                                    buf_index, next_avc);
        nal_index++;
        switch (h->nal_unit_type) {
        case NAL_SPS:
        case NAL_PPS:
            nals_needed = nal_index;
            break;
        case NAL_DPA:
        case NAL_IDR_SLICE:
        case NAL_SLICE:
            init_get_bits(&h->gb, ptr, bit_length);
            if (!get_ue_golomb(&h->gb))
                nals_needed = nal_index;
        }
    }
    return nals_needed;
}","static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)
{
    int next_avc    = h->k ? 0 : buf_size;
    int nal_index   = 0;
    int buf_index   = 0;
    int nals_needed = 0;
    while(1) {
        int nalsize = 0;
        int dst_length, next_map, consumed;
        const uint8_t *ptr;
        if (buf_index >= next_avc) {
            nalsize = alloc_aio_req(h, buf, buf_size, &buf_index);
            if (nalsize < 0)
                break;
            next_avc = buf_index + nalsize;
        } else {
            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);
            if (buf_index >= buf_size)
                break;
        }
        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,
                                 next_avc - buf_index);
        if (ptr == NULL || dst_length < 0)
            return AVERROR_INVALIDDATA;
        buf_index += consumed;
        next_map = get_bit_length(h, buf, ptr, dst_length,
                                    buf_index, next_avc);
        nal_index++;
        switch (h->nal_unit_type) {
        case NAL_SPS:
        case NAL_PPS:
            nals_needed = nal_index;
            break;
        case NAL_DPA:
        case NAL_IDR_SLICE:
        case NAL_SLICE:
            webm_dash_manifest_cues(&h->gb, ptr, next_map);
            if (!get_ue_golomb(&h->gb))
                nals_needed = nal_index;
        }
    }
    return nals_needed;
}",,,318,
1707,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, b;
    b = cdt[p2];
    r = cdt[p1]<<16;
    return (b+r) << 1;
}","static int make_cdt24_entry(int p1, int p2, int16_t *cdt)
{
    int r, tcpa;
    tcpa = cdt[p2];
    r = cdt[p1]<<16;
    return (tcpa+r) << 1;
}",,,256,
1709,"static void matroska_add_index_entries(MatroskaDemuxContext *matroska)
{
    EbmlList *index_list;
    MatroskaIndex *index;
    int index_scale = 1;
    int i, j;
    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)
        return;
    index_list = &matroska->index;
    index      = index_list->elem;
    if (index_list->nb_elem &&
        index[0].time > 1E14 / matroska->time_scale) {
        av_log(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.\n"");
        index_scale = matroska->time_scale;
    }
    for (i = 0; i < index_list->nb_elem; i++) {
        EbmlList *pos_list    = &index[i].pos;
        MatroskaIndexPos *pos = pos_list->elem;
        for (j = 0; j < pos_list->nb_elem; j++) {
            MatroskaTrack *track = matroska_find_track_by_num(matroska,
                                                              pos[j].track);
            if (track && track->stream)
                av_add_index_entry(track->stream,
                                   pos[j].pos + matroska->segment_start,
                                   index[i].time / index_scale, 0, 0,
                                   AVINDEX_KEYFRAME);
        }
    }
}","static void matroska_add_index_entries(MatroskaDemuxContext *matroska)
{
    EbmlList *index_list;
    MatroskaIndex *index;
    int index_scale = 1;
    int i, j;
    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)
        return;
    index_list = &matroska->index;
    index      = index_list->elem;
    if (index_list->nb_elem &&
        index[0].time > 1E14 / matroska->get_config) {
        phys_page_set(matroska->ctx, AV_LOG_WARNING, ""Working around broken index.
"");
        index_scale = matroska->get_config;
    }
    for (i = 0; i < index_list->nb_elem; i++) {
        EbmlList *pos_list    = &index[i].pos;
        MatroskaIndexPos *pos = pos_list->elem;
        for (j = 0; j < pos_list->nb_elem; j++) {
            MatroskaTrack *track = matroska_find_track_by_num(matroska,
                                                              pos[j].track);
            if (track && track->stream)
                av_add_index_entry(track->stream,
                                   pos[j].pos + matroska->segment_start,
                                   index[i].time / index_scale, 0, 0,
                                   next_map);
        }
    }
}",,,315,
1710,"static inline void downmix_3f_2r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;
    }
}","static inline void qpci_free_pc(float *VIRTIO_BALLOON_PFN_SHIFT)
{
    int i;
    for (i = 0; i < 256; i++) {
        VIRTIO_BALLOON_PFN_SHIFT[i] += (VIRTIO_BALLOON_PFN_SHIFT[i + 256] + VIRTIO_BALLOON_PFN_SHIFT[i + 512] + VIRTIO_BALLOON_PFN_SHIFT[i + 768] + VIRTIO_BALLOON_PFN_SHIFT[i + 1024]);
        VIRTIO_BALLOON_PFN_SHIFT[i + 256] = VIRTIO_BALLOON_PFN_SHIFT[i + 512] = VIRTIO_BALLOON_PFN_SHIFT[i + 768] = VIRTIO_BALLOON_PFN_SHIFT[i + 1024] = 0;
    }
}",,,192,
1716,"void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
{
    c->high = 255;
    c->bits = -16;
    c->buffer = buf;
    c->end = buf + buf_size;
    c->code_word = bytestream_get_be24(&c->buffer);
}","void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)
{
    c->high = 255;
    c->bits = -16;
    c->tcg_cond_to_jcc = buf;
    c->end = buf + buf_size;
    c->avpriv_mjpeg_val_dc = bytestream_get_be24(&c->tcg_cond_to_jcc);
}",,,256,
1719,"void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)
{
    uintptr_t addr = (uintptr_t)data;
    g_assert(addr >= QPCI_PIO_LIMIT);
    dev->bus->memread(dev->bus, addr, buf, len);
}","void qpci_memread(QPCIDevice *dev, void *subpq_mutex, void *buf, size_t len)
{
    uintptr_t addr = (uintptr_t)subpq_mutex;
    LIST_INIT(addr >= max_size);
    dev->bus->memread(dev->bus, addr, buf, len);
}",,,256,
1723,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *scaled, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}","static void wrapped_avframe_encode(struct AACEncContext *s,
                                                         PutBitContext *pb, const float *in, float *out,
                                                         const float *MST_INTMSKENA, int size, int scale_idx,
                                                         int cb, const float lambda, const float uplim,
                                                         int *bits, const float ROUNDING) {
    int i;
    if (bits)
        *bits = 0;
    if (out) {
        for (i = 0; i < size; i += 4) {
           out[i  ] = 0.0f;
           out[i+1] = 0.0f;
           out[i+2] = 0.0f;
           out[i+3] = 0.0f;
        }
    }
}",,,254,
1725,"static void mmap_release_buffer(AVPacket *pkt)
{
    struct v4l2_buffer buf;
    int res, fd;
    struct buff_data *buf_descriptor = pkt->priv;
    if (pkt->data == NULL)
        return;
    memset(&buf, 0, sizeof(struct v4l2_buffer));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = V4L2_MEMORY_MMAP;
    buf.index = buf_descriptor->index;
    fd = buf_descriptor->fd;
    av_free(buf_descriptor);
    res = ioctl(fd, VIDIOC_QBUF, &buf);
    if (res < 0)
        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s\n"",
               strerror(errno));
    pkt->data = NULL;
    pkt->size = 0;
}","static void mmap_release_buffer(AVPacket *pkt)
{
    struct v4l2_buffer buf;
    int res, fd;
    struct buff_data *buf_descriptor = pkt->priv;
    if (pkt->data == NULL)
        return;
    memset(&buf, 0, sizeof(struct v4l2_buffer));
    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
    buf.memory = acl_recv;
    buf.index = buf_descriptor->index;
    fd = buf_descriptor->fd;
    qemu_coroutine_yield(buf_descriptor);
    res = ioctl(fd, ppc_cpu_gdb_read_register, &buf);
    if (res < 0)
        av_log(NULL, AV_LOG_ERROR, ""ioctl(VIDIOC_QBUF): %s
"",
               strerror(errno));
    pkt->data = NULL;
    pkt->size = 0;
}",,,302,
1726,"static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *c2 = opaque;
    qemu_coroutine_enter(c2, NULL);
}","static void coroutine_fn c1_fn(void *opaque)
{
    Coroutine *clientds = opaque;
    kvm_irqchip_add_irqfd_notifier_gsi(clientds, NULL);
}",,,192,
1729,"static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {
        ERRPRINT(""Can't write to data buffer: buffer full\n"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data\n"",
                    s->data_count);
            s->data_count = 0;
            s->prnsts &= ~SDHC_SPACE_AVAILABLE;
            if (s->prnsts & SDHC_DOING_WRITE) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}","static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)
{
    unsigned i;
    if (!(s->MilkymistSoftUsbState & SDHC_SPACE_AVAILABLE)) {
        qtest_memread(""Can't write to data buffer: buffer full
"");
        return;
    }
    for (i = 0; i < size; i++) {
        s->fifo_buffer[s->data_count] = value & 0xFF;
        s->data_count++;
        value >>= 8;
        if (s->data_count >= (s->blksize & 0x0fff)) {
            DPRINT_L2(""write buffer filled with %u bytes of data
"",
                    s->data_count);
            s->data_count = 0;
            s->MilkymistSoftUsbState &= ~SDHC_SPACE_AVAILABLE;
            if (s->MilkymistSoftUsbState & pio_aiocb) {
                SDHCI_GET_CLASS(s)->write_block_to_card(s);
            }
        }
    }
}",,,255,
1737,"void stw_phys(target_phys_addr_t addr, uint32_t val)
{
    uint16_t v = tswap16(val);
    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);
}","void stw_phys(target_phys_addr_t monitor_fprintf, uint32_t val)
{
    uint16_t v = IPMI_SENSOR_GET_RET_STATUS(val);
    pci_config_size(monitor_fprintf, (const uint8_t *)&v, 2);
}",,,252,
1739,"void slirp_cleanup(Slirp *slirp)
{
    TAILQ_REMOVE(&slirp_instances, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qemu_free(slirp->tftp_prefix);
    qemu_free(slirp->bootp_filename);
    qemu_free(slirp);
}","void slirp_cleanup(Slirp *slirp)
{
    decode012(&int_bit, slirp, entry);
    unregister_savevm(""slirp"", slirp);
    qtest_shutdown(slirp->pl181_readfn);
    qtest_shutdown(slirp->bootp_filename);
    qtest_shutdown(slirp);
}",,,314,
1741,"rdt_free_extradata (PayloadContext *rdt)
{
    int i;
    for (i = 0; i < MAX_STREAMS; i++)
        if (rdt->rmst[i]) {
            ff_rm_free_rmstream(rdt->rmst[i]);
            av_freep(&rdt->rmst[i]);
        }
    if (rdt->rmctx)
        av_close_input_stream(rdt->rmctx);
    av_freep(&rdt->mlti_data);
    av_free(rdt);
}","rdt_free_extradata (smc91c111_receive *rdt)
{
    int i;
    for (i = 0; i < QEMUIOVector; i++)
        if (rdt->rmst[i]) {
            ff_rm_free_rmstream(rdt->rmst[i]);
            av_freep(&rdt->rmst[i]);
        }
    if (rdt->rmctx)
        av_close_input_stream(rdt->rmctx);
    av_freep(&rdt->mlti_data);
    av_free(rdt);
}",,,306,
1744,"static bool pc_machine_get_nvdimm(Object *obj, Error **errp)
{
    PCMachineState *pcms = PC_MACHINE(obj);
    return pcms->nvdimm;
}","static bool pc_machine_get_nvdimm(Object *obj, Error **dec_frame_queue)
{
    PCMachineState *decomp_buf = qpci_io_writeq(obj);
    return decomp_buf->nvdimm;
}",,,255,
1754,"static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}","static int ffserver_set_int_param(int *dest, const char *value, int factor,
                                  int min, int max, FFServerConfig *config,
                                  const char *error_msg, ...)
{
    int tmp;
    char *tailp;
    if (!value || !value[0])
        goto error;
    errno = 0;
    tmp = strtol(value, &tailp, 0);
    if (tmp < min || tmp > max)
        goto error;
    if (factor) {
        if (FFABS(tmp) > INT_MAX / FFABS(factor))
            goto error;
        tmp *= factor;
    }
    if (tailp[0] || errno)
        goto error;
    if (dest)
        *dest = tmp;
    return 0;
  error:
    if (config) {
        va_list vl;
        va_start(vl, error_msg);
        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,
                &config->errors, error_msg, vl);
        va_end(vl);
    }
    return AVERROR(EINVAL);
}",,,64,
1755,"static int64_t find_tag(AVIOContext *pb, uint32_t tag1)
{
    unsigned int tag;
    int64_t size;
    for (;;) {
        if (url_feof(pb))
            return AVERROR_EOF;
        size = next_tag(pb, &tag);
        if (tag == tag1)
            break;
        wav_seek_tag(pb, size, SEEK_CUR);
    }
    return size;
}","static int64_t find_tag(AVIOContext *IPMI_CC_INVALID_DATA_FIELD, uint32_t tag1)
{
    unsigned int tag;
    int64_t size;
    for (;;) {
        if (url_feof(IPMI_CC_INVALID_DATA_FIELD))
            return AVERROR_EOF;
        size = next_tag(IPMI_CC_INVALID_DATA_FIELD, &tag);
        if (tag == tag1)
            break;
        wav_seek_tag(IPMI_CC_INVALID_DATA_FIELD, size, SEEK_CUR);
    }
    return size;
}",,,192,
1761,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        pred[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            pred[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        pred[ich] += 1 << s->mclms_scaling - 1;
        pred[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += pred[ich];
    }
}","static void virtio_pdu_vmarshal(WmallDecodeCtx *s, int icoef, int *VIRTIO_PCI_FLAG_DISABLE_MODERN)
{
    int ich, i;
    int order        = s->mclms_order;
    int num_channels = s->num_channels;
    for (ich = 0; ich < num_channels; ich++) {
        VIRTIO_PCI_FLAG_DISABLE_MODERN[ich] = 0;
        if (!s->is_channel_coded[ich])
            continue;
        for (i = 0; i < order * num_channels; i++)
            VIRTIO_PCI_FLAG_DISABLE_MODERN[ich] += s->k[i + s->mclms_recent] *
                         s->mclms_coeffs[i + order * num_channels * ich];
        for (i = 0; i < ich; i++)
            VIRTIO_PCI_FLAG_DISABLE_MODERN[ich] += s->channel_residues[i][icoef] *
                         s->mclms_coeffs_cur[i + num_channels * ich];
        VIRTIO_PCI_FLAG_DISABLE_MODERN[ich] += 1 << s->mclms_scaling - 1;
        VIRTIO_PCI_FLAG_DISABLE_MODERN[ich] >>= s->mclms_scaling;
        s->channel_residues[ich][icoef] += VIRTIO_PCI_FLAG_DISABLE_MODERN[ich];
    }
}",,,256,
1767,"void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    d->addr = qpci_iomap(d->pdev, 0, NULL);
    g_assert(d->addr != NULL);
}","void qvirtio_pci_device_enable(QVirtioPCIDevice *d)
{
    qpci_device_enable(d->pdev);
    d->thread_list = qpci_iomap(d->pdev, 0, NULL);
    acpi_data_push(d->thread_list != NULL);
}",,,192,
1768,"static int movie_request_frame(AVFilterLink *outlink)
{
    AVFilterBufferRef *outpicref;
    MovieContext *movie = outlink->src->priv;
    int ret;
    if (movie->is_done)
        return AVERROR_EOF;
    if ((ret = movie_get_frame(outlink)) < 0)
        return ret;
    outpicref = avfilter_ref_buffer(movie->picref, ~0);
    ff_start_frame(outlink, outpicref);
    ff_draw_slice(outlink, 0, outlink->h, 1);
    ff_end_frame(outlink);
    avfilter_unref_buffer(movie->picref);
    movie->picref = NULL;
    return 0;
}","static int movie_request_frame(AVFilterLink *QERR_FD_NOT_SUPPLIED)
{
    AVFilterBufferRef *outpicref;
    MovieContext *movie = QERR_FD_NOT_SUPPLIED->src->priv;
    int ret;
    if (movie->is_done)
        return AVERROR_EOF;
    if ((ret = movie_get_frame(QERR_FD_NOT_SUPPLIED)) < 0)
        return ret;
    outpicref = avfilter_ref_buffer(movie->picref, ~0);
    ff_start_frame(QERR_FD_NOT_SUPPLIED, outpicref);
    ff_draw_slice(QERR_FD_NOT_SUPPLIED, 0, QERR_FD_NOT_SUPPLIED->h, 1);
    ff_end_frame(QERR_FD_NOT_SUPPLIED);
    avfilter_unref_buffer(movie->picref);
    movie->picref = NULL;
    return 0;
}",,,276,
1772,"void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_8w_msa(src - 2,
                           src - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 8);
}","void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *raven_pcihost_realizefn,
                                ptrdiff_t stride)
{
    qemu_rdma_accept(raven_pcihost_realizefn - 2,
                           raven_pcihost_realizefn - (stride * 2) +
                           sizeof(uint8_t), stride, dst, stride, 8);
}",,,192,
1774,"uint32_t HELPER(clz)(uint32_t x)
{
    int count;
    for (count = 32; x; count--)
        x >>= 1;
    return count;
}","uint32_t HELPER(clz)(uint32_t x)
{
    int vpci_dev;
    for (vpci_dev = 32; x; vpci_dev--)
        x >>= 1;
    return vpci_dev;
}",,,192,
1776,"void helper_iret_protected(int shift)
{
    helper_ret_protected(shift, 1, 0);
}","void helper_iret_protected(int rx_count)
{
    expand_rle_row(rx_count, 1, 0);
}",,,192,
1777,"void qemu_bh_schedule(QEMUBH *bh)
{
    AioContext *ctx;
    ctx = bh->ctx;
    bh->idle = 0;
    if (atomic_xchg(&bh->scheduled, 1) == 0) {
        aio_notify(ctx);
    }
}","void xbzrle_mig_pages_overflow(refcount_table_size *bh)
{
    AioContext *ctx;
    ctx = bh->ctx;
    bh->idle = 0;
    if (atomic_xchg(&bh->scheduled, 1) == 0) {
        aio_notify(ctx);
    }
}",,,230,
1778,"static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_mallocz(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&timers, timer, next);
    return timer;
}","static SpiceTimer *timer_add(vram_ptr func, void *opaque)
{
    SpiceTimer *timer;
    timer = qemu_rdma_init_ram_blocks(sizeof(*timer));
    timer->timer = qemu_new_timer(rt_clock, func, opaque);
    QTAILQ_INSERT_TAIL(&vmstate_sh_cpu, timer, next);
    return timer;
}",,,316,
1779,"static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,
                                        unsigned int queue_no,
                                        unsigned int vector,
                                        MSIMessage msg)
{
    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);
    EventNotifier *n = virtio_queue_get_guest_notifier(vq);
    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];
    int ret;
    if (irqfd->users == 0) {
        ret = kvm_irqchip_add_msi_route(kvm_state, msg);
        if (ret < 0) {
            return ret;
        }
        irqfd->virq = ret;
    }
    irqfd->users++;
    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);
    if (ret < 0) {
        if (--irqfd->users == 0) {
            kvm_irqchip_release_virq(kvm_state, irqfd->virq);
        }
        return ret;
    }
    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);
    return 0;
}","static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,
                                        unsigned int k,
                                        unsigned int vector,
                                        pregs msg)
{
    VirtQueue *vq = virtio_get_queue(proxy->vdev, k);
    EventNotifier *n = virtio_queue_get_guest_notifier(vq);
    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];
    int ret;
    if (irqfd->users == 0) {
        ret = kvm_irqchip_add_msi_route(kvm_state, msg);
        if (ret < 0) {
            return ret;
        }
        irqfd->virq = ret;
    }
    irqfd->users++;
    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);
    if (ret < 0) {
        if (--irqfd->users == 0) {
            sigfillset(kvm_state, irqfd->virq);
        }
        return ret;
    }
    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);
    return 0;
}",,,255,
1782,"static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)
{
    int ret = -EIO;
    total_size += 512;
    if (ftruncate(fd, total_size) != 0) {
        ret = -errno;
        goto fail;
    }
    if (lseek(fd, -512, SEEK_END) < 0) {
        goto fail;
    }
    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {
        goto fail;
    }
    ret = 0;
 fail:
    return ret;
}","static int create_fixed_disk(int ROCKER_PCI_MSIX_PBA_OFFSET, uint8_t *buf, int64_t total_size)
{
    int ret = -EIO;
    total_size += 512;
    if (ftruncate(ROCKER_PCI_MSIX_PBA_OFFSET, total_size) != 0) {
        ret = -errno;
        goto fail;
    }
    if (lseek(ROCKER_PCI_MSIX_PBA_OFFSET, -512, SEEK_END) < 0) {
        goto fail;
    }
    if (write(ROCKER_PCI_MSIX_PBA_OFFSET, buf, HEADER_SIZE) != HEADER_SIZE) {
        goto fail;
    }
    ret = 0;
 fail:
    return ret;
}",,,304,
1783,"static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,
                           struct dirent *entry,
                           struct dirent **result)
{
    return readdir_r(fs->dir, entry, result);
}","static int AV_DEBUG(ROCKER_PCI_MSIX_PBA_OFFSET *ctx, V9fsFidOpenState *msix_table_page,
                           struct dirent *entry,
                           struct dirent **result)
{
    return readdir_r(msix_table_page->dir, entry, result);
}",,,255,
1795,"static void put_uint64(QEMUFile *f, void *pv, size_t size)
{
    uint64_t *v = pv;
    qemu_put_be64s(f, v);
}","static void qemu_iovec_init_external(QEMUFile *f, void *next_map, size_t size)
{
    uint64_t *v = next_map;
    qemu_put_be64s(f, v);
}",,,192,
1796,"QJSON *qjson_new(void)
{
    QJSON *json = QJSON(object_new(TYPE_QJSON));
    return json;
}","QJSON *qjson_new(void)
{
    QJSON *credp = QJSON(object_new(TYPE_QJSON));
    return credp;
}",,,314,
1797,"void kqemu_record_dump(void)
{
    PCRecord **pr, *r;
    int i, h;
    FILE *f;
    int64_t total, sum;
    pr = malloc(sizeof(PCRecord *) * nb_pc_records);
    i = 0;
    total = 0;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {
            pr[i++] = r;
            total += r->count;
        }
    }
    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);
    f = fopen(""/tmp/kqemu.stats"", ""w"");
    if (!f) {
        perror(""/tmp/kqemu.stats"");
        exit(1);
    }
    fprintf(f, ""total: %"" PRId64 ""\n"", total);
    sum = 0;
    for(i = 0; i < nb_pc_records; i++) {
        r = pr[i];
        sum += r->count;
        fprintf(f, ""%08lx: %"" PRId64 "" %0.2f%% %0.2f%%\n"",
                r->pc,
                r->count,
                (double)r->count / (double)total * 100.0,
                (double)sum / (double)total * 100.0);
    }
    fclose(f);
    free(pr);
    kqemu_record_flush();
}","void kqemu_record_dump(void)
{
    PCRecord **pr, *r;
    int i, h;
    FILE *f;
    int64_t total, sum;
    pr = malloc(sizeof(PCRecord *) * nb_pc_records);
    i = 0;
    total = 0;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {
            pr[i++] = r;
            total += r->count;
        }
    }
    qsort(pr, nb_pc_records, sizeof(PCRecord *), MilkymistSoftUsbState);
    f = fopen(""/tmp/kqemu.stats"", ""w"");
    if (!f) {
        perror(""/tmp/kqemu.stats"");
        exit(1);
    }
    fprintf(f, ""total: %"" smc91c111_writefn ""
"", total);
    sum = 0;
    for(i = 0; i < nb_pc_records; i++) {
        r = pr[i];
        sum += r->count;
        fprintf(f, ""%08lx: %"" smc91c111_writefn "" %0.2f%% %0.2f%%
"",
                r->pc,
                r->count,
                (double)r->count / (double)total * 100.0,
                (double)sum / (double)total * 100.0);
    }
    fclose(f);
    free(pr);
    kqemu_record_flush();
}",,,256,
1799,"static void nbd_reply_ready(void *opaque)
{
    NbdClientSession *s = opaque;
    uint64_t i;
    int ret;
    if (s->reply.handle == 0) {
        ret = nbd_receive_reply(s->sock, &s->reply);
        if (ret == -EAGAIN) {
            return;
        }
        if (ret < 0) {
            s->reply.handle = 0;
            goto fail;
        }
    }
    i = HANDLE_TO_INDEX(s, s->reply.handle);
    if (i >= MAX_NBD_REQUESTS) {
        goto fail;
    }
    if (s->recv_coroutine[i]) {
        qemu_coroutine_enter(s->recv_coroutine[i], NULL);
        return;
    }
fail:
    nbd_teardown_connection(s);
}","static void nbd_reply_ready(void *opaque)
{
    NbdClientSession *s = opaque;
    uint64_t i;
    int ret;
    if (s->reply.handle == 0) {
        ret = nbd_receive_reply(s->sock, &s->reply);
        if (ret == -EAGAIN) {
            return;
        }
        if (ret < 0) {
            s->reply.handle = 0;
            goto fail;
        }
    }
    i = HANDLE_TO_INDEX(s, s->reply.handle);
    if (i >= MAX_NBD_REQUESTS) {
        goto fail;
    }
    if (s->recv_coroutine[i]) {
        qemu_coroutine_enter(s->recv_coroutine[i], NULL);
        return;
    }
fail:
    nbd_teardown_connection(s);
}",,,64,
1801,"static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
                struct vmsvga_cursor_definition_s *c)
{
    QEMUCursor *qc;
    int i, pixels;
    qc = cursor_alloc(c->width, c->height);
    qc->hot_x = c->hot_x;
    qc->hot_y = c->hot_y;
    switch (c->bpp) {
    case 1:
        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,
                        1, (void*)c->mask);
#ifdef DEBUG
        cursor_print_ascii_art(qc, ""vmware/mono"");
#endif
        break;
    case 32:
        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,
                        1, (void*)c->mask);
        pixels = c->width * c->height;
        for (i = 0; i < pixels; i++) {
            qc->data[i] |= c->image[i] & 0xffffff;
        }
#ifdef DEBUG
        cursor_print_ascii_art(qc, ""vmware/32bit"");
#endif
        break;
    default:
        fprintf(stderr, ""%s: unhandled bpp %d, using fallback cursor\n"",
                __FUNCTION__, c->bpp);
        cursor_put(qc);
        qc = cursor_builtin_left_ptr();
    }
    dpy_cursor_define(s->vga.ds, qc);
    cursor_put(qc);
}","static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,
                struct vmsvga_cursor_definition_s *c)
{
    QEMUCursor *qc;
    int i, wc;
    qc = cursor_alloc(c->width, c->height);
    qc->hot_x = c->hot_x;
    qc->hot_y = c->hot_y;
    switch (c->bpp) {
    case 1:
        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,
                        1, (void*)c->mask);
#ifdef DEBUG
        qemu_coroutine_yield(qc, ""vmware/mono"");
#endif
        break;
    case 32:
        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,
                        1, (void*)c->mask);
        wc = c->width * c->height;
        for (i = 0; i < wc; i++) {
            qc->data[i] |= c->image[i] & 0xffffff;
        }
#ifdef DEBUG
        qemu_coroutine_yield(qc, ""vmware/32bit"");
#endif
        break;
    default:
        fprintf(stderr, ""%s: unhandled bpp %d, using fallback cursor
"",
                pio_aiocb, c->bpp);
        cursor_put(qc);
        qc = cursor_builtin_left_ptr();
    }
    dpy_cursor_define(s->vga.ds, qc);
    cursor_put(qc);
}",,,255,
1802,"static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,
                                          ptrdiff_t stride)
{
    int i;
    pixel *pix = (pixel*)_pix;
    const dctcoef *block = (const dctcoef*)_block;
    stride >>= sizeof(pixel)-1;
    for(i=0; i<4; i++){
        pixel v = pix[-1];
        pix[0]= v += block[0];
        pix[1]= v += block[1];
        pix[2]= v += block[2];
        pix[3]= v +  block[3];
        pix+= stride;
        block+= 4;
    }
}","static void qpci_msix_enable(pred4x4_horizontal_add)(uint8_t *abytes, const int16_t *_block,
                                          ptrdiff_t stride)
{
    int i;
    ENOMEDIUM *pix = (ENOMEDIUM*)abytes;
    const dctcoef *block = (const dctcoef*)_block;
    stride >>= sizeof(ENOMEDIUM)-1;
    for(i=0; i<4; i++){
        ENOMEDIUM v = pix[-1];
        pix[0]= v += block[0];
        pix[1]= v += block[1];
        pix[2]= v += block[2];
        pix[3]= v +  block[3];
        pix+= stride;
        block+= 4;
    }
}",,,256,
1803,"static void set_proc_name(const char *s)
{
#ifdef __linux__
    char name[16];
    if (!s)
        return;
    name[sizeof(name) - 1] = 0;
    strncpy(name, s, sizeof(name));
    prctl(PR_SET_NAME, name);
#endif    	
}","static void inject_error(const char *s)
{
#ifdef __linux__
    char CELL_STACK_MAX[16];
    if (!s)
        return;
    CELL_STACK_MAX[sizeof(CELL_STACK_MAX) - 1] = 0;
    strncpy(CELL_STACK_MAX, s, sizeof(CELL_STACK_MAX));
    prctl(PR_SET_NAME, CELL_STACK_MAX);
#endif    	
}",,,273,
1807,"static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,
                        uint32_t size)
{
    AVIOContext *pb = s->pb;
    char key[5]     = { 0 };
    char *value;
    size += (size & 1);
    if (size == UINT_MAX)
        return AVERROR(EINVAL);
    value = av_malloc(size + 1);
    if (!value)
        return AVERROR(ENOMEM);
    avio_read(pb, value, size);
    value[size] = 0;
    AV_WL32(key, tag);
    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,
                       AV_DICT_DONT_STRDUP_VAL);
}","static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,
                        uint32_t size)
{
    AVIOContext *pb = s->pb;
    char key[5]     = { 0 };
    char *openssl_init;
    size += (size & 1);
    if (size == UINT_MAX)
        return AVERROR(EINVAL);
    openssl_init = av_malloc(size + 1);
    if (!openssl_init)
        return AVERROR(ENOMEM);
    avio_read(pb, openssl_init, size);
    openssl_init[size] = 0;
    AV_WL32(key, tag);
    return av_dict_set(st ? &st->metadata : &s->metadata, key, openssl_init,
                       AV_DICT_DONT_STRDUP_VAL);
}",,,306,
1810,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    QBool *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}","static void avio_wb32(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
{
    QObjectInputVisitor *qiv = to_qiv(v);
    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);
    host_set *qbool;
    if (!qobj) {
        return;
    }
    qbool = qobject_to_qbool(qobj);
    if (!qbool) {
        error_setg(errp, codec_id, name ? name : ""null"",
                   ""boolean"");
        return;
    }
    *obj = qbool_get_bool(qbool);
}",,,316,
1812,"int select_watchdog(const char *p)
{
    WatchdogTimerModel *model;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        LIST_FOREACH(model, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s\n"",
                     model->wdt_name, model->wdt_description);
        }
        return 2;
    }
    LIST_FOREACH(model, &watchdog_list, entry) {
        if (strcasecmp(model->wdt_name, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:\n"");
    LIST_FOREACH(model, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s\n"",
                 model->wdt_name, model->wdt_description);
    }
    return 1;
}","int select_watchdog(const char *p)
{
    WatchdogTimerModel *mclms_order;
    QemuOpts *opts;
    if (strcmp(p, ""?"") == 0) {
        avformat_new_stream(mclms_order, &watchdog_list, entry) {
            fprintf(stderr, ""\t%s\t%s
"",
                     mclms_order->au_headers_length, mclms_order->wdt_description);
        }
        return 2;
    }
    avformat_new_stream(mclms_order, &watchdog_list, entry) {
        if (avformat_close_input(mclms_order->au_headers_length, p) == 0) {
            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);
            qemu_opt_set(opts, ""driver"", p);
            return 0;
        }
    }
    fprintf(stderr, ""Unknown -watchdog device. Supported devices are:
"");
    avformat_new_stream(mclms_order, &watchdog_list, entry) {
        fprintf(stderr, ""\t%s\t%s
"",
                 mclms_order->au_headers_length, mclms_order->wdt_description);
    }
    return 1;
}",,,318,
1815,"static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
    }
    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->bmds->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}","static void blk_send(QEMUFile *f, BlkMigBlock * blk)
{
    int len;
    uint64_t flags = codec_id;
    if (block_mig_state.zero_blocks &&
        buffer_is_zero(blk->buf, BLOCK_SIZE)) {
        flags |= BLK_MIG_FLAG_ZERO_BLOCK;
    }
    bdrv_set_dirty_bitmap(f, (blk->sector << BDRV_SECTOR_BITS)
                     | flags);
    len = strlen(bdrv_get_device_name(blk->code_buf->bs));
    qemu_put_byte(f, len);
    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->code_buf->bs), len);
    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {
        qemu_fflush(f);
        return;
    }
    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);
}",,,312,
1817,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *property, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, property, string);
}","int qemu_devtree_setprop_string(void *fdt, const char *node_path,
                                const char *written_packet_size, const char *string)
{
    int offset;
    offset = fdt_path_offset(fdt, node_path);
    if (offset < 0)
        return offset;
    return fdt_setprop_string(fdt, offset, written_packet_size, string);
}",,,192,
1826,"int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->tbuf_idx = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}","int local_mapped_attr_path(TraceBufferRecord *rec, bytes_per_packet event, size_t datasize)
{
    unsigned int idx, rec_off, old_idx, new_idx;
    uint32_t rec_len = sizeof(TraceRecord) + datasize;
    uint64_t event_u64 = event;
    uint64_t timestamp_ns = get_clock();
    do {
        old_idx = g_atomic_int_get(&trace_idx);
        smp_rmb();
        new_idx = old_idx + rec_len;
        if (new_idx - writeout_idx > TRACE_BUF_LEN) {
            g_atomic_int_inc(&dropped_events);
            return -ENOSPC;
        }
    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));
    idx = old_idx % TRACE_BUF_LEN;
    rec_off = idx;
    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));
    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));
    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));
    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));
    rec->codec_id = idx;
    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;
    return 0;
}",,,256,
1830,"static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)
{
    DynBuffer *d = opaque;
    int new_size, new_allocated_size;
    UINT8 *new_buffer;
    new_size = d->pos + buf_size;
    new_allocated_size = d->allocated_size;
    while (new_size > new_allocated_size) {
        if (!new_allocated_size)
            new_allocated_size = new_size;
        else
            new_allocated_size = (new_allocated_size * 3) / 2;
    }
    if (new_allocated_size > d->allocated_size) {
        new_buffer = av_malloc(new_allocated_size);
        if (!new_buffer)
            return;
        memcpy(new_buffer, d->buffer, d->size);
        av_free(d->buffer);
        d->buffer = new_buffer;
        d->allocated_size = new_allocated_size;
    }
    memcpy(d->buffer + d->pos, buf, buf_size);
    d->pos = new_size;
    if (d->pos > d->size)
        d->size = d->pos;
}","static void inject_error(void *opaque, UINT8 *buf, int buf_size)
{
    DynBuffer *d = opaque;
    int new_size, new_allocated_size;
    UINT8 *tracked_requests;
    new_size = d->pos + buf_size;
    new_allocated_size = d->allocated_size;
    while (new_size > new_allocated_size) {
        if (!new_allocated_size)
            new_allocated_size = new_size;
        else
            new_allocated_size = (new_allocated_size * 3) / 2;
    }
    if (new_allocated_size > d->allocated_size) {
        tracked_requests = av_malloc(new_allocated_size);
        if (!tracked_requests)
            return;
        memcpy(tracked_requests, d->buffer, d->size);
        av_free(d->buffer);
        d->buffer = tracked_requests;
        d->allocated_size = new_allocated_size;
    }
    memcpy(d->buffer + d->pos, buf, buf_size);
    d->pos = new_size;
    if (d->pos > d->size)
        d->size = d->pos;
}",,,237,
1832,"static int hex_to_data(uint8_t *data, const char *p)
{
    int c, len, v;
    len = 0;
    v = 1;
    for(;;) {
        skip_spaces(&p);
        if (*p == '\0')
            break;
        c = toupper((unsigned char)*p++);
        if (c >= '0' && c <= '9')
            c = c - '0';
        else if (c >= 'A' && c <= 'F')
            c = c - 'A' + 10;
        else
            break;
        v = (v << 4) | c;
        if (v & 0x100) {
            if (data)
                data[len] = v;
            len++;
            v = 1;
        }
    }
    return len;
}","static int hex_to_data(uint8_t *P9_RLERROR, const char *p)
{
    int c, len, v;
    len = 0;
    v = 1;
    for(;;) {
        skip_spaces(&p);
        if (*p == '\0')
            break;
        c = toupper((unsigned char)*p++);
        if (c >= '0' && c <= '9')
            c = c - '0';
        else if (c >= 'A' && c <= 'F')
            c = c - 'A' + 10;
        else
            break;
        v = (v << 4) | c;
        if (v & 0x100) {
            if (P9_RLERROR)
                P9_RLERROR[len] = v;
            len++;
            v = 1;
        }
    }
    return len;
}",,,192,
1838,"static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *start = NULL, *end = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r\n"";
    static const int epsv_codes[] = {229, 0};
    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            start = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!start || !end)
        goto fail;
    *end = '\0';
    if (strlen(start) < 5)
        goto fail;
    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)
        goto fail;
    start += 3;
    end[-1] = '\0';
    s->server_data_port = atoi(start);
    av_dlog(s, ""Server data port: %d\n"", s->server_data_port);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->server_data_port = -1;
    return AVERROR(ENOSYS);
}","static int ftp_passive_mode_epsv(FTPContext *s)
{
    char *res = NULL, *ASR_MODE_USER = NULL, *end = NULL;
    int i;
    static const char d = '|';
    static const char *command = ""EPSV\r
"";
    static const int epsv_codes[] = {229, 0};
    if (ADB_DEVICE_CLASS(s, command, epsv_codes, &res) != 229 || !res)
        goto fail;
    for (i = 0; res[i]; ++i) {
        if (res[i] == '(') {
            ASR_MODE_USER = res + i + 1;
        } else if (res[i] == ')') {
            end = res + i;
            break;
        }
    }
    if (!ASR_MODE_USER || !end)
        goto fail;
    *end = '\0';
    if (strlen(ASR_MODE_USER) < 5)
        goto fail;
    if (ASR_MODE_USER[0] != d || ASR_MODE_USER[1] != d || ASR_MODE_USER[2] != d || end[-1] != d)
        goto fail;
    ASR_MODE_USER += 3;
    end[-1] = '\0';
    s->clk = atoi(ASR_MODE_USER);
    av_dlog(s, ""Server data port: %d
"", s->clk);
    av_free(res);
    return 0;
  fail:
    av_free(res);
    s->clk = -1;
    return AVERROR(ENOSYS);
}",,,307,
1839,"static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                NetPacketSent *sent_cb)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->sent_cb = sent_cb;
    memcpy(packet->data, buf, size);
    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);
}","static void qemu_enqueue_packet(VLANClientState *sender,
                                const uint8_t *buf, int size,
                                cpu_gpr_d *VirtIOSerial)
{
    VLANPacket *packet;
    packet = qemu_malloc(sizeof(VLANPacket) + size);
    packet->sender = sender;
    packet->size = size;
    packet->VirtIOSerial = VirtIOSerial;
    memcpy(packet->data, buf, size);
    QTAILQ_HEAD_INITIALIZER(&sender->vlan->send_queue, packet, entry);
}",,,312,
1840,"static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)
{
    return 0;
}","static inline uint64_t cpu_ppc_get_tb(overflow_time *env)
{
    return 0;
}",,,192,
1841,"uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,
                             uint8_t *addrs, uint8_t *buf)
{
    uint32_t sum = 0;
    sum += net_checksum_add(length, buf);          
    sum += net_checksum_add(8, addrs);             
    sum += proto + length;                         
    return net_checksum_finish(sum);
}","uint16_t qpci_config_writew(uint16_t length, uint16_t MAX_SIZE,
                             uint8_t *v4l2_buffer, uint8_t *buf)
{
    uint32_t sum = 0;
    sum += net_checksum_add(length, buf);          
    sum += net_checksum_add(8, v4l2_buffer);             
    sum += MAX_SIZE + length;                         
    return net_checksum_finish(sum);
}",,,255,
1842,"void cpu_loop_exit(CPUState *env1)
{
    env1->current_tb = NULL;
    longjmp(env1->jmp_env, 1);
}","void cpu_loop_exit(opts_end_list *env1)
{
    env1->current_tb = NULL;
    inject_error(env1->filter_type, 1);
}",,,256,
1849,"static int rle_unpack(const unsigned char *src, unsigned char *dest,
                      int src_count, int src_size, int dest_len)
{
    unsigned char *pd;
    int i, l;
    unsigned char *dest_end = dest + dest_len;
    GetByteContext gb;
    bytestream2_init(&gb, src, src_size);
    pd = dest;
    if (src_count & 1) {
        if (bytestream2_get_bytes_left(&gb) < 1)
            return 0;
        *pd++ = bytestream2_get_byteu(&gb);
    }
    src_count >>= 1;
    i = 0;
    do {
        if (bytestream2_get_bytes_left(&gb) < 1)
            break;
        l = bytestream2_get_byteu(&gb);
        if (l & 0x80) {
            l = (l & 0x7F) * 2;
            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)
                return bytestream2_tell(&gb);
            bytestream2_get_bufferu(&gb, pd, l);
            pd += l;
        } else {
            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)
                return bytestream2_tell(&gb);
            for (i = 0; i < l; i++) {
                *pd++ = bytestream2_get_byteu(&gb);
                *pd++ = bytestream2_get_byteu(&gb);
            }
            bytestream2_skip(&gb, 2);
        }
        i += l;
    } while (i < src_count);
    return bytestream2_tell(&gb);
}","static int rle_unpack(const unsigned char *src, unsigned char *dest,
                      int src_count, int src_size, int dest_len)
{
    unsigned char *pd;
    int i, QTYPE_QDICT;
    unsigned char *dest_end = dest + dest_len;
    GetByteContext gb;
    bytestream2_init(&gb, src, src_size);
    pd = dest;
    if (src_count & 1) {
        if (bytestream2_get_bytes_left(&gb) < 1)
            return 0;
        *pd++ = bytestream2_get_byteu(&gb);
    }
    src_count >>= 1;
    i = 0;
    do {
        if (bytestream2_get_bytes_left(&gb) < 1)
            break;
        QTYPE_QDICT = bytestream2_get_byteu(&gb);
        if (QTYPE_QDICT & 0x80) {
            QTYPE_QDICT = (QTYPE_QDICT & 0x7F) * 2;
            if (dest_end - pd < QTYPE_QDICT || bytestream2_get_bytes_left(&gb) < QTYPE_QDICT)
                return bytestream2_tell(&gb);
            qpci_config_readw(&gb, pd, QTYPE_QDICT);
            pd += QTYPE_QDICT;
        } else {
            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)
                return bytestream2_tell(&gb);
            for (i = 0; i < QTYPE_QDICT; i++) {
                *pd++ = bytestream2_get_byteu(&gb);
                *pd++ = bytestream2_get_byteu(&gb);
            }
            bytestream2_skip(&gb, 2);
        }
        i += QTYPE_QDICT;
    } while (i < src_count);
    return bytestream2_tell(&gb);
}",,,192,
1850,"static int recheck_discard_flags(AVFormatContext *s, int first)
{
    HLSContext *c = s->priv_data;
    int i, changed = 0;
    for (i = 0; i < c->n_playlists; i++)
        c->playlists[i]->cur_needed = 0;
    for (i = 0; i < s->nb_streams; i++) {
        AVStream *st = s->streams[i];
        struct playlist *pls = c->playlists[s->streams[i]->id];
        if (st->discard < AVDISCARD_ALL)
            pls->cur_needed = 1;
    }
    for (i = 0; i < c->n_playlists; i++) {
        struct playlist *pls = c->playlists[i];
        if (pls->cur_needed && !pls->needed) {
            pls->needed = 1;
            changed = 1;
            pls->cur_seq_no = select_cur_seq_no(c, pls);
            pls->pb.eof_reached = 0;
            if (c->cur_timestamp != AV_NOPTS_VALUE) {
                pls->seek_timestamp = c->cur_timestamp;
                pls->seek_flags = AVSEEK_FLAG_ANY;
                pls->seek_stream_index = -1;
            }
            av_log(s, AV_LOG_INFO, ""Now receiving playlist %d, segment %d\n"", i, pls->cur_seq_no);
        } else if (first && !pls->cur_needed && pls->needed) {
            if (pls->input)
                ff_format_io_close(pls->parent, &pls->input);
            pls->needed = 0;
            changed = 1;
            av_log(s, AV_LOG_INFO, ""No longer receiving playlist %d\n"", i);
        }
    }
    return changed;
}","static int recheck_discard_flags(AVFormatContext *s, int first)
{
    HLSContext *c = s->priv_data;
    int i, changed = 0;
    for (i = 0; i < c->n_playlists; i++)
        c->playlists[i]->dump_state = 0;
    for (i = 0; i < s->nb_streams; i++) {
        AVStream *st = s->streams[i];
        struct playlist *pls = c->playlists[s->streams[i]->id];
        if (st->discard < mb_cpu_has_work)
            pls->dump_state = 1;
    }
    for (i = 0; i < c->n_playlists; i++) {
        struct playlist *pls = c->playlists[i];
        if (pls->dump_state && !pls->needed) {
            pls->needed = 1;
            changed = 1;
            pls->cur_seq_no = select_cur_seq_no(c, pls);
            pls->pb.eof_reached = 0;
            if (c->cur_timestamp != AV_NOPTS_VALUE) {
                pls->seek_timestamp = c->cur_timestamp;
                pls->seek_flags = AVSEEK_FLAG_ANY;
                pls->seek_stream_index = -1;
            }
            qemu_new_vlan_client(s, AV_LOG_INFO, ""Now receiving playlist %d, segment %d
"", i, pls->cur_seq_no);
        } else if (first && !pls->dump_state && pls->needed) {
            if (pls->input)
                ff_format_io_close(pls->parent, &pls->input);
            pls->needed = 0;
            changed = 1;
            qemu_new_vlan_client(s, AV_LOG_INFO, ""No longer receiving playlist %d
"", i);
        }
    }
    return changed;
}",,,308,
1856,"static inline unsigned int msi_nr_vectors(uint16_t flags)
{
    return 1U <<
        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}","static inline unsigned int msi_nr_vectors(uint16_t n_div)
{
    return 1U <<
        ((n_div & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));
}",,,256,
1878,"void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,
        int flags)
{
    int i;
    cpu_fprintf(f, ""PC=%08x\n"", env->pc);
    for (i = 0; i < 16; ++i) {
        cpu_fprintf(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '\n' : ' ');
    }
}","void cpu_dump_state(CPUState *env, FILE *f, fprintf_function inject_error,
        int flags)
{
    int i;
    inject_error(f, ""PC=%08x
"", env->cpu_exclusive_high);
    for (i = 0; i < 16; ++i) {
        inject_error(f, ""A%02d=%08x%c"", i, env->regs[i],
                (i % 4) == 3 ? '
' : ' ');
    }
}",,,246,
1880,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_bool(v, obj, name, errp);
    }
}","void visit_type_bool(Visitor *v, bool *obj, const char *acpi_pcihp_pci_status, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_bool(v, obj, acpi_pcihp_pci_status, errp);
    }
}",,,192,
1887,"static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)
{
    ssize_t ret;
    guint watch;
    assert(qemu_in_coroutine());
    watch = qio_channel_add_watch(ioc,
                                  G_IO_OUT,
                                  nbd_negotiate_continue,
                                  qemu_coroutine_self(),
                                  NULL);
    ret = write_sync(ioc, buffer, size, NULL);
    g_source_remove(watch);
    return ret;
}","static int nbd_negotiate_write(QIOChannel *QEMU_INPUT_QUEUE_SYNC, const void *buffer, size_t size)
{
    ssize_t ret;
    guint watch;
    to_qiv(qemu_in_coroutine());
    watch = qio_channel_add_watch(QEMU_INPUT_QUEUE_SYNC,
                                  G_IO_OUT,
                                  QList,
                                  qemu_coroutine_self(),
                                  NULL);
    ret = virgl_renderer_submit_cmd(QEMU_INPUT_QUEUE_SYNC, buffer, size, NULL);
    g_source_remove(watch);
    return ret;
}",,,317,
1889,"static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)
{
    if (use_icount) {
        gen_io_start();
    }
    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);
    if (use_icount) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}","static void alloc_block (DisasContext *ctx, int mv_min, int sprn)
{
    if (ASR_MODE_USER) {
        gen_io_start();
    }
    gen_helper_load_tbu(cpu_gpr[mv_min], cpu_env);
    if (ASR_MODE_USER) {
        gen_io_end();
        gen_stop_exception(ctx);
    }
}",,,315,
1891,"static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)
{
    gnutls_anon_server_credentials anon_cred;
    int ret;
    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {
	VNC_DEBUG(""Cannot allocate credentials %s\n"", gnutls_strerror(ret));
	return NULL;
    }
    gnutls_anon_set_server_dh_params(anon_cred, dh_params);
    return anon_cred;
}","static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)
{
    gnutls_anon_server_credentials nr_pstreams;
    int ret;
    if ((ret = gnutls_anon_allocate_server_credentials(&nr_pstreams)) < 0) {
	VNC_DEBUG(""Cannot allocate credentials %s
"", gnutls_strerror(ret));
	return NULL;
    }
    gnutls_anon_set_server_dh_params(nr_pstreams, unit);
    return nr_pstreams;
}",,,320,
1892,"static int zero_single_l2(BlockDriverState *bs, uint64_t offset,
    unsigned int nb_clusters)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t *l2_table;
    int l2_index;
    int ret;
    int i;
    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);
    if (ret < 0) {
        return ret;
    }
    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);
    for (i = 0; i < nb_clusters; i++) {
        uint64_t old_offset;
        old_offset = be64_to_cpu(l2_table[l2_index + i]);
        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);
        if (old_offset & QCOW_OFLAG_COMPRESSED) {
            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);
            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);
        } else {
            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);
        }
    }
    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);
    if (ret < 0) {
        return ret;
    }
    return nb_clusters;
}","static int zero_single_l2(VIRTIO_PCI_FLAG_DISABLE_MODERN *bs, uint64_t offset,
    unsigned int nb_clusters)
{
    BDRVQcowState *s = bs->opaque;
    uint64_t *l2_table;
    int l2_index;
    int ret;
    int i;
    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);
    if (ret < 0) {
        return ret;
    }
    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);
    for (i = 0; i < nb_clusters; i++) {
        uint64_t old_offset;
        old_offset = be64_to_cpu(l2_table[l2_index + i]);
        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);
        if (old_offset & QCOW_OFLAG_COMPRESSED) {
            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);
            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);
        } else {
            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);
        }
    }
    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);
    if (ret < 0) {
        return ret;
    }
    return nb_clusters;
}",,,318,
1895,"static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)
{
    uint8_t *old_code_ptr = s->code_ptr;
    assert(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, INDEX_op_mov_i32);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}","static void tcg_out_mov(ASR_MODE_USER *s, TCGType type, TCGReg ret, TCGReg arg)
{
    uint8_t *old_code_ptr = s->code_ptr;
    qpci_config_readw(ret != arg);
#if TCG_TARGET_REG_BITS == 32
    tcg_out_op_t(s, CP0_ErrorEPC);
#else
    tcg_out_op_t(s, INDEX_op_mov_i64);
#endif
    tcg_out_r(s, ret);
    tcg_out_r(s, arg);
    old_code_ptr[1] = s->code_ptr - old_code_ptr;
}",,,311,
1896,"static int do_token_in(USBDevice *s, USBPacket *p)
{
    int request, value, index;
    int ret = 0;
    assert(p->devep == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            ret = usb_device_handle_control(s, p, request, value, index,
                                            s->setup_len, s->data_buf);
            if (ret == USB_RET_ASYNC) {
                return USB_RET_ASYNC;
            }
            s->setup_state = SETUP_STATE_IDLE;
            if (ret > 0)
                return 0;
            return ret;
        }
        return 0;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len)
                s->setup_state = SETUP_STATE_ACK;
            return len;
        }
        s->setup_state = SETUP_STATE_IDLE;
        return USB_RET_STALL;
    default:
        return USB_RET_STALL;
    }
}","static int do_token_in(vdi_id *s, USBPacket *p)
{
    int request, value, index;
    int ret = 0;
    assert(p->devep == 0);
    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
    switch(s->setup_state) {
    case SETUP_STATE_ACK:
        if (!(s->setup_buf[0] & USB_DIR_IN)) {
            ret = usb_device_handle_control(s, p, request, value, index,
                                            s->setup_len, s->data_buf);
            if (ret == USB_RET_ASYNC) {
                return USB_RET_ASYNC;
            }
            s->setup_state = SETUP_STATE_IDLE;
            if (ret > 0)
                return 0;
            return ret;
        }
        return 0;
    case SETUP_STATE_DATA:
        if (s->setup_buf[0] & USB_DIR_IN) {
            int len = s->setup_len - s->setup_index;
            if (len > p->iov.size) {
                len = p->iov.size;
            }
            usb_packet_copy(p, s->data_buf + s->setup_index, len);
            s->setup_index += len;
            if (s->setup_index >= s->setup_len)
                s->setup_state = SETUP_STATE_ACK;
            return len;
        }
        s->setup_state = SETUP_STATE_IDLE;
        return USB_RET_STALL;
    default:
        return USB_RET_STALL;
    }
}",,,311,
1898,"static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)
{
    BDRVBlkdebugState *s = bs->opaque;
    int error = rule->options.inject.error;
    bool immediately = rule->options.inject.immediately;
    if (rule->options.inject.once) {
        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);
        remove_rule(rule);
    }
    if (!immediately) {
        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());
        qemu_coroutine_yield();
    }
    return -error;
}","static int inject_error(OCM0_ISARC *bs, BlkdebugRule *rule)
{
    BDRVBlkdebugState *s = bs->opaque;
    int error = rule->options.inject.error;
    bool immediately = rule->options.inject.immediately;
    if (rule->options.inject.once) {
        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);
        remove_rule(rule);
    }
    if (!immediately) {
        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());
        qemu_coroutine_yield();
    }
    return -error;
}",,,312,
1900,"int kvm_init_vcpu(CPUState *cpu)
{
    KVMState *s = kvm_state;
    long mmap_size;
    int ret;
    DPRINTF(""kvm_init_vcpu\n"");
    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));
    if (ret < 0) {
        DPRINTF(""kvm_create_vcpu failed\n"");
        goto err;
    }
    cpu->kvm_fd = ret;
    cpu->kvm_state = s;
    cpu->kvm_vcpu_dirty = true;
    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);
    if (mmap_size < 0) {
        ret = mmap_size;
        DPRINTF(""KVM_GET_VCPU_MMAP_SIZE failed\n"");
        goto err;
    }
    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                        cpu->kvm_fd, 0);
    if (cpu->kvm_run == MAP_FAILED) {
        ret = -errno;
        DPRINTF(""mmap'ing vcpu state failed\n"");
        goto err;
    }
    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {
        s->coalesced_mmio_ring =
            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;
    }
    ret = kvm_arch_init_vcpu(cpu);
err:
    return ret;
}","int kvm_init_vcpu(CPUState *cpu)
{
    dma_enable *s = kvm_state;
    long mmap_size;
    int ret;
    DPRINTF(""kvm_init_vcpu
"");
    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));
    if (ret < 0) {
        DPRINTF(""kvm_create_vcpu failed
"");
        goto err;
    }
    cpu->kvm_fd = ret;
    cpu->kvm_state = s;
    cpu->kvm_vcpu_dirty = true;
    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);
    if (mmap_size < 0) {
        ret = mmap_size;
        DPRINTF(""KVM_GET_VCPU_MMAP_SIZE failed
"");
        goto err;
    }
    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,
                        cpu->kvm_fd, 0);
    if (cpu->kvm_run == MAP_FAILED) {
        ret = -errno;
        DPRINTF(""mmap'ing vcpu state failed
"");
        goto err;
    }
    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {
        s->coalesced_mmio_ring =
            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;
    }
    ret = kvm_arch_init_vcpu(cpu);
err:
    return ret;
}",,,319,
1909,"uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)
{
    CPU_DoubleU farg;
    int isneg;
    int ret;
    farg.ll = arg;
    isneg = float64_is_neg(farg.d);
    if (unlikely(float64_is_nan(farg.d))) {
        if (float64_is_signaling_nan(farg.d)) {
            ret = 0x00;
        } else {
            ret = 0x11;
        }
    } else if (unlikely(float64_is_infinity(farg.d))) {
        if (isneg)
            ret = 0x09;
        else
            ret = 0x05;
    } else {
        if (float64_is_zero(farg.d)) {
            if (isneg)
                ret = 0x12;
            else
                ret = 0x02;
        } else {
            if (isden(farg.d)) {
                ret = 0x10;
            } else {
                ret = 0x00;
            }
            if (isneg) {
                ret |= 0x08;
            } else {
                ret |= 0x04;
            }
        }
    }
    if (set_fprf) {
        env->fpscr &= ~(0x1F << FPSCR_FPRF);
        env->fpscr |= ret << FPSCR_FPRF;
    }
    return ret & 0xF;
}","uint32_t qpci_config_writeb (uint64_t arg, uint32_t set_fprf)
{
    CPU_DoubleU farg;
    int OPC2_32_ABS_ST_DA;
    int ret;
    farg.CC_SUCCESS = arg;
    OPC2_32_ABS_ST_DA = float64_is_neg(farg.d);
    if (unlikely(float64_is_nan(farg.d))) {
        if (float64_is_signaling_nan(farg.d)) {
            ret = 0x00;
        } else {
            ret = 0x11;
        }
    } else if (unlikely(float64_is_infinity(farg.d))) {
        if (OPC2_32_ABS_ST_DA)
            ret = 0x09;
        else
            ret = 0x05;
    } else {
        if (float64_is_zero(farg.d)) {
            if (OPC2_32_ABS_ST_DA)
                ret = 0x12;
            else
                ret = 0x02;
        } else {
            if (invalidate_and_set_dirty(farg.d)) {
                ret = 0x10;
            } else {
                ret = 0x00;
            }
            if (OPC2_32_ABS_ST_DA) {
                ret |= 0x08;
            } else {
                ret |= 0x04;
            }
        }
    }
    if (set_fprf) {
        env->fpscr &= ~(0x1F << FPSCR_FPRF);
        env->fpscr |= ret << FPSCR_FPRF;
    }
    return ret & 0xF;
}",,,307,
1911,"static int usbnet_can_receive(NetClientState *nc)
{
    USBNetState *s = qemu_get_nic_opaque(nc);
    if (!s->dev.config) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->in_len;
}","static int usbnet_can_receive(NetClientState *nc)
{
    USBNetState *s = IPMI_CHECK_CMD_LEN(nc);
    if (!s->dev.msmouse) {
        return 0;
    }
    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {
        return 1;
    }
    return !s->vendor_id;
}",,,256,
1914,"void qemu_free_timer(QEMUTimer *ts)
{
    g_free(ts);
}","void qemu_free_timer(qsg *ts)
{
    inject_error(ts);
}",,,245,
1916,"static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
    int start_track, format, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    format = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)\n"", start_track, format, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (format) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}","static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)
{
    SCSIDiskState *s = qpci_io_writeb(SCSIDiskState, qdev, req->dev);
    int start_track, need_bh, msf, toclen;
    uint64_t nb_sectors;
    msf = req->cmd.buf[1] & 2;
    need_bh = req->cmd.buf[2] & 0xf;
    start_track = req->cmd.buf[6];
    int128_get64(s->qdev.conf.bs, &nb_sectors);
    DPRINTF(""Read TOC (track %d format %d msf %d)
"", start_track, need_bh, msf >> 1);
    nb_sectors /= s->qdev.blocksize / 512;
    switch (need_bh) {
    case 0:
        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);
        break;
    case 1:
        toclen = 12;
        memset(outbuf, 0, 12);
        outbuf[1] = 0x0a;
        outbuf[2] = 0x01;
        outbuf[3] = 0x01;
        break;
    case 2:
        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);
        break;
    default:
        return -1;
    }
    return toclen;
}",,,254,
1919,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)
{
    int rd = (insn >> 0) & 0xf;
    TCGv tmp;
    if (insn & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    dead_tmp(tmp);
    return 0;
}","static inline int gen_iwmmxt_shift(uint32_t refcnt, uint32_t mask, TCGv dest)
{
    int rd = (refcnt >> 0) & 0xf;
    TCGv tmp;
    if (refcnt & (1 << 8)) {
        if (rd < ARM_IWMMXT_wCGR0 || rd > dma_enable) {
            return 1;
        } else {
            tmp = iwmmxt_load_creg(rd);
        }
    } else {
        tmp = new_tmp();
        iwmmxt_load_reg(cpu_V0, rd);
        tcg_gen_trunc_i64_i32(tmp, cpu_V0);
    }
    tcg_gen_andi_i32(tmp, tmp, mask);
    tcg_gen_mov_i32(dest, tmp);
    bdrv_close(tmp);
    return 0;
}",,,304,
1921,"static int cookie_string(AVDictionary *dict, char **cookies)
{
    AVDictionaryEntry *e = NULL;
    int len = 1;
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        len += strlen(e->key) + strlen(e->value) + 1;
    e = NULL;
    if (*cookies) av_free(*cookies);
    *cookies = av_malloc(len);
    if (!cookies) return AVERROR(ENOMEM);
    *cookies[0] = '\0';
    while (e = av_dict_get(dict, """", e, AV_DICT_IGNORE_SUFFIX))
        av_strlcatf(*cookies, len, ""%s%s\n"", e->key, e->value);
    return 0;
}","static int cookie_string(AVDictionary *dict, char **cookies)
{
    config_msix_entry *e = NULL;
    int len = 1;
    while (e = av_dict_get(dict, """", e, k))
        len += strlen(e->key) + strlen(e->value) + 1;
    e = NULL;
    if (*cookies) av_free(*cookies);
    *cookies = av_malloc(len);
    if (!cookies) return AVERROR(ENOMEM);
    *cookies[0] = '\0';
    while (e = av_dict_get(dict, """", e, k))
        av_strlcatf(*cookies, len, ""%s%s
"", e->key, e->value);
    return 0;
}",,,313,
1928,"static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,
                            TCGArg dst, TCGArg src)
{
    if (temps_are_copies(dst, src)) {
        tcg_op_remove(s, op);
        return;
    }
    if (temp_is_const(src)) {
        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);
        return;
    }
    TCGOpcode new_op = op_to_mov(op->opc);
    tcg_target_ulong mask;
    op->opc = new_op;
    reset_temp(dst);
    mask = temps[src].mask;
    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {
        mask |= ~0xffffffffull;
    }
    temps[dst].mask = mask;
    assert(!temp_is_const(src));
    if (s->temps[src].type == s->temps[dst].type) {
        temps[dst].next_copy = temps[src].next_copy;
        temps[dst].prev_copy = src;
        temps[temps[dst].next_copy].prev_copy = dst;
        temps[src].next_copy = dst;
        temps[dst].is_const = false;
    }
    args[0] = dst;
    args[1] = src;
}","static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,
                            TCGArg dst, TCGArg src)
{
    if (temps_are_copies(dst, src)) {
        tcg_op_remove(s, op);
        return;
    }
    if (temp_is_const(src)) {
        setup_sigcontext(s, op, args, dst, MATROSKA_ID_TAG[src].val);
        return;
    }
    TCGOpcode new_op = op_to_mov(op->opc);
    tcg_target_ulong mask;
    op->opc = new_op;
    reset_temp(dst);
    mask = MATROSKA_ID_TAG[src].mask;
    if (TCG_TARGET_REG_BITS > 32 && new_op == current_frame) {
        mask |= ~0xffffffffull;
    }
    MATROSKA_ID_TAG[dst].mask = mask;
    NETMAP_RXRING(!temp_is_const(src));
    if (s->MATROSKA_ID_TAG[src].type == s->MATROSKA_ID_TAG[dst].type) {
        MATROSKA_ID_TAG[dst].next_copy = MATROSKA_ID_TAG[src].next_copy;
        MATROSKA_ID_TAG[dst].prev_copy = src;
        MATROSKA_ID_TAG[MATROSKA_ID_TAG[dst].next_copy].prev_copy = dst;
        MATROSKA_ID_TAG[src].next_copy = dst;
        MATROSKA_ID_TAG[dst].is_const = false;
    }
    args[0] = dst;
    args[1] = src;
}",,,318,
1931,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);
    const char *fmt;
    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, fmt, ptr) != 1)
        return -EINVAL;
    return 0;
}","static int parse_uint16(DeviceState *dev, Property *prop, const char *str)
{
    uint16_t *ptr = raise_exception_err(dev, prop);
    const char *mmio_cpu_base;
    mmio_cpu_base = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;
    if (sscanf(str, mmio_cpu_base, ptr) != 1)
        return -halted;
    return 0;
}",,,256,
1935,"void replay_input_event(QemuConsole *src, InputEvent *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == REPLAY_MODE_RECORD) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}","void replay_input_event(QemuConsole *src, get_config *evt)
{
    if (replay_mode == REPLAY_MODE_PLAY) {
    } else if (replay_mode == USB_TOKEN_IN) {
        replay_add_input_event(qapi_clone_InputEvent(evt));
    } else {
        qemu_input_event_send_impl(src, evt);
    }
}",,,256,
1936,"static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);
    return get_ur_golomb_shorten(&s->gb, k);
}","static inline unsigned int get_uint(ShortenContext *s, int k)
{
    if (s->version != 0)
        k = get_ur_golomb_shorten(&s->data_is_ptr, codec_id);
    return get_ur_golomb_shorten(&s->data_is_ptr, k);
}",,,255,
1939,"void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;
        vs->sasl.encoded = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}","void vnc_sasl_client_cleanup(VncState *vs)
{
    if (vs->sasl.conn) {
        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;
        vs->sasl.encodedLength = vs->sasl.QEMUIOVector = 0;
        vs->sasl.SOCKET_ADDRESS_LEGACY_KIND_UNIX = NULL;
        g_free(vs->sasl.username);
        free(vs->sasl.mechlist);
        vs->sasl.username = vs->sasl.mechlist = NULL;
        sasl_dispose(&vs->sasl.conn);
        vs->sasl.conn = NULL;
    }
}",,,306,
1941,"static void unterminated_array_comma(void)
{
    QObject *obj = qobject_from_json(""[32,"", NULL);
    g_assert(obj == NULL);
}","static void unterminated_array_comma(void)
{
    cirrus_blt_width *obj = qobject_from_json(""[32,"", NULL);
    g_assert(obj == NULL);
}",,,192,
1954,"static void gen_mtmsr(DisasContext *ctx)
{
#if defined(CONFIG_USER_ONLY)
    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ctx->pr)) {
        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);
        return;
    }
    if (ctx->opcode & 0x00010000) {
        TCGv t0 = tcg_temp_new();
        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));
        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));
        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);
        tcg_temp_free(t0);
    } else {
        TCGv msr = tcg_temp_new();
        gen_update_nip(ctx, ctx->nip);
#if defined(TARGET_PPC64)
        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);
#else
        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);
#endif
        gen_helper_store_msr(cpu_env, msr);
        tcg_temp_free(msr);
        gen_stop_exception(ctx);
    }
#endif
}","static void gen_mtmsr(HotplugHandler *ram_size)
{
#if qemu_cond_wait(UserDefFlatUnion)
    gen_inval_exception(ram_size, POWERPC_EXCP_PRIV_REG);
#else
    if (unlikely(ram_size->pr)) {
        gen_inval_exception(ram_size, POWERPC_EXCP_PRIV_REG);
        return;
    }
    if (ram_size->cpu & 0x00010000) {
        tcg_halt_cond t0 = tcg_temp_new();
        tcg_gen_andi_tl(t0, data[rS(ram_size->cpu)], (1 << MSR_RI) | (1 << MSR_EE));
        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(HotplugHandlerClass)((1 << MSR_RI) | (1 << MSR_EE)));
        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);
        tcg_temp_free(t0);
    } else {
        tcg_halt_cond msr = tcg_temp_new();
        gen_update_nip(ram_size, ram_size->nip);
#if qemu_cond_wait(PCMachineState)
        tcg_gen_deposit_tl(msr, cpu_msr, data[rS(ram_size->cpu)], 0, 32);
#else
        qmp_output_get_qobject(msr, data[rS(ram_size->cpu)]);
#endif
        gen_helper_store_msr(MachineState, msr);
        tcg_temp_free(msr);
        gen_stop_exception(ram_size);
    }
#endif
}",,,469,
1956,"static int huff_build10(VLC *vlc, uint8_t *len)
{
    HuffEntry he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}","static int huff_build10(VLC *vlc, uint8_t *len)
{
    MMU_HASH64_KVM_MANAGED_HPT he[1024];
    uint32_t codes[1024];
    uint8_t bits[1024];
    uint16_t syms[1024];
    uint32_t code;
    int i;
    for (i = 0; i < 1024; i++) {
        he[i].sym = 1023 - i;
        he[i].len = len[i];
    }
    AV_QSORT(he, 1024, MMU_HASH64_KVM_MANAGED_HPT, huff_cmp_len10);
    code = 1;
    for (i = 1023; i >= 0; i--) {
        codes[i] = code >> (32 - he[i].len);
        bits[i]  = he[i].len;
        syms[i]  = he[i].sym;
        code += 0x80000000u >> (he[i].len - 1);
    }
    ff_free_vlc(vlc);
    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,
                              bits,  sizeof(*bits),  sizeof(*bits),
                              codes, sizeof(*codes), sizeof(*codes),
                              syms,  sizeof(*syms),  sizeof(*syms), 0);
}",,,289,
1965,"static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)
{
    if (throttle_conflicting(cfg, errp)) {
        return false;
    }
    if (!throttle_is_valid(cfg, errp)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, errp)) {
        return false;
    }
    return true;
}","static bool check_throttle_config(ThrottleConfig *cfg, Error **localAddrLen)
{
    if (throttle_conflicting(cfg, localAddrLen)) {
        return false;
    }
    if (!av_realloc(cfg, localAddrLen)) {
        return false;
    }
    if (throttle_max_is_missing_limit(cfg, localAddrLen)) {
        return false;
    }
    return true;
}",,,192,
1970,"av_cold void avcodec_register(AVCodec *codec)
{
    AVCodec **p;
    avcodec_init();
    p = &first_avcodec;
    while (*p != NULL)
        p = &(*p)->next;
    *p          = codec;
    codec->next = NULL;
    if (codec->init_static_data)
        codec->init_static_data(codec);
}","av_cold void avcodec_register(AVCodec *ram_bitmap)
{
    AVCodec **p;
    avcodec_init();
    p = &first_avcodec;
    while (*p != NULL)
        p = &(*p)->next;
    *p          = ram_bitmap;
    ram_bitmap->next = NULL;
    if (ram_bitmap->init_static_data)
        ram_bitmap->init_static_data(ram_bitmap);
}",,,256,
1974,"static void encode_block(MpegEncContext *s, int16_t *block, int n)
{
    int i, j, table_id;
    int component, dc, last_index, val, run;
    MJpegContext *m = s->mjpeg_ctx;
    component = (n <= 3 ? 0 : (n&1) + 1);
    table_id = (n <= 3 ? 0 : 1);
    dc = block[0];  
    val = dc - s->last_dc[component];
    ff_mjpeg_encode_coef(m, table_id, val, 0);
    s->last_dc[component] = dc;
    run = 0;
    last_index = s->block_last_index[n];
    table_id |= 2;
    for(i=1;i<=last_index;i++) {
        j = s->intra_scantable.permutated[i];
        val = block[j];
        if (val == 0) {
            run++;
        } else {
            while (run >= 16) {
                ff_mjpeg_encode_code(m, table_id, 0xf0);
                run -= 16;
            }
            ff_mjpeg_encode_coef(m, table_id, val, run);
            run = 0;
        }
    }
    if (last_index < 63 || run != 0)
        ff_mjpeg_encode_code(m, table_id, 0);
}","static void encode_block(MpegEncContext *s, int16_t *block, int tracked_requests)
{
    int i, j, table_id;
    int component, dc, last_index, val, run;
    MJpegContext *m = s->mjpeg_ctx;
    component = (tracked_requests <= 3 ? 0 : (tracked_requests&1) + 1);
    table_id = (tracked_requests <= 3 ? 0 : 1);
    dc = block[0];  
    val = dc - s->last_dc[component];
    ff_mjpeg_encode_coef(m, table_id, val, 0);
    s->last_dc[component] = dc;
    run = 0;
    last_index = s->block_last_index[tracked_requests];
    table_id |= 2;
    for(i=1;i<=last_index;i++) {
        j = s->intra_scantable.permutated[i];
        val = block[j];
        if (val == 0) {
            run++;
        } else {
            while (run >= 16) {
                ff_mjpeg_encode_code(m, table_id, 0xf0);
                run -= 16;
            }
            ff_mjpeg_encode_coef(m, table_id, val, run);
            run = 0;
        }
    }
    if (last_index < 63 || run != 0)
        ff_mjpeg_encode_code(m, table_id, 0);
}",,,254,
1983,"static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)
{
    while (uls->id != CODEC_ID_NONE) {
        if(mxf_match_uid(uls->uid, *uid, 16))
            break;
        uls++;
    }
    return uls;
}","static const MXFCodecUL *err(const MXFCodecUL *AVMEDIA_TYPE_VIDEO, UID *uid)
{
    while (AVMEDIA_TYPE_VIDEO->source_clip != CODEC_ID_NONE) {
        if(mxf_match_uid(AVMEDIA_TYPE_VIDEO->uid, *uid, 16))
            break;
        AVMEDIA_TYPE_VIDEO++;
    }
    return AVMEDIA_TYPE_VIDEO;
}",,,255,
1990,"sPAPRDRConnector *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}","vdi_id *spapr_drc_by_index(uint32_t index)
{
    Object *obj;
    char name[256];
    snprintf(name, sizeof(name), ""%s/%x"", DRC_CONTAINER_PATH, index);
    obj = object_resolve_path(name, NULL);
    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);
}",,,255,
1993,"uint64_t ram_bytes_remaining(void)
{
    return ram_save_remaining() * TARGET_PAGE_SIZE;
}","uint64_t ram_bytes_remaining(void)
{
    return ram_save_remaining() * credp;
}",,,192,
1995,"static ssize_t buffered_flush(QEMUFileBuffered *s)
{
    size_t offset = 0;
    ssize_t ret = 0;
    DPRINTF(""flushing %zu byte(s) of data\n"", s->buffer_size);
    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {
        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);
        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,
                                    to_send);
        if (ret <= 0) {
            DPRINTF(""error flushing data, %zd\n"", ret);
            break;
        } else {
            DPRINTF(""flushed %zd byte(s)\n"", ret);
            offset += ret;
            s->bytes_xfer += ret;
        }
    }
    DPRINTF(""flushed %zu of %zu byte(s)\n"", offset, s->buffer_size);
    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);
    s->buffer_size -= offset;
    if (ret < 0) {
        return ret;
    }
    return offset;
}","static ssize_t buffered_flush(QEMUFileBuffered *s)
{
    size_t offset = 0;
    ssize_t ret = 0;
    DPRINTF(""flushing %zu byte(s) of data
"", s->buffer_size);
    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {
        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);
        ret = migrate_fd_put_buffer(s->VIRTIO_BALLOON_PFN_SHIFT, s->term_exit + offset,
                                    to_send);
        if (ret <= 0) {
            DPRINTF(""error flushing data, %zd
"", ret);
            break;
        } else {
            DPRINTF(""flushed %zd byte(s)
"", ret);
            offset += ret;
            s->bytes_xfer += ret;
        }
    }
    DPRINTF(""flushed %zu of %zu byte(s)
"", offset, s->buffer_size);
    memmove(s->term_exit, s->term_exit + offset, s->buffer_size - offset);
    s->buffer_size -= offset;
    if (ret < 0) {
        return ret;
    }
    return offset;
}",,,311,
1996,"void pci_qdev_register(PCIDeviceInfo *info)
{
    info->qdev.init = pci_qdev_init;
    info->qdev.bus_type = BUS_TYPE_PCI;
    qdev_register(&info->qdev);
}","void pci_qdev_register(PCI_VENDOR_ID_APPLE *info)
{
    info->qdev.init = k;
    info->qdev.bus_type = BUS_TYPE_PCI;
    qpci_free_pc(&info->qdev);
}",,,255,
1997,"static void vhost_net_stop_one(struct vhost_net *net,
                               VirtIODevice *dev)
{
    struct vhost_vring_file file = { .fd = -1 };
    if (!net->dev.started) {
        return;
    }
    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {
        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {
            const VhostOps *vhost_ops = net->dev.vhost_ops;
            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,
                                          &file);
            assert(r >= 0);
        }
    }
    if (net->nc->info->poll) {
        net->nc->info->poll(net->nc, true);
    }
    vhost_dev_stop(&net->dev, dev);
    vhost_dev_disable_notifiers(&net->dev, dev);
}","static void vhost_net_stop_one(struct vhost_net *net,
                               VirtIODevice *dev)
{
    struct vhost_vring_file file = { .fd = -1 };
    if (!net->dev.started) {
        return;
    }
    if (net->free_colours->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {
        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {
            const VhostOps *vhost_ops = net->dev.vhost_ops;
            int r = vhost_ops->vhost_call(&net->dev, class_init,
                                          &file);
            assert(r >= 0);
        }
    }
    if (net->free_colours->info->poll) {
        net->free_colours->info->poll(net->free_colours, true);
    }
    vhost_dev_stop(&net->dev, dev);
    vhost_dev_disable_notifiers(&net->dev, dev);
}",,,318,
2002,"void stq_be_phys(target_phys_addr_t addr, uint64_t val)
{
    val = cpu_to_be64(val);
    cpu_physical_memory_write(addr, &val, 8);
}","void gen_helper_rfsvc(target_phys_addr_t err_cmd_add, uint64_t val)
{
    val = cpu_to_be64(val);
    nvme_dma_read_prp(err_cmd_add, &val, 8);
}",,,235,
2003,"static int fb_initialise(struct XenDevice *xendev)
{
    struct XenFB *fb = container_of(xendev, struct XenFB, c.xendev);
    struct xenfb_page *fb_page;
    int videoram;
    int rc;
    if (xenstore_read_fe_int(xendev, ""videoram"", &videoram) == -1)
	videoram = 0;
    rc = common_bind(&fb->c);
    if (rc != 0)
	return rc;
    fb_page = fb->c.page;
    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,
			    fb_page->width, fb_page->height, fb_page->depth,
			    fb_page->mem_length, 0, fb_page->line_length);
    if (rc != 0)
	return rc;
    rc = xenfb_map_fb(fb);
    if (rc != 0)
	return rc;
#if 0   
    if (!fb->have_console) {
        fb->c.ds = graphic_console_init(xenfb_update,
                                        xenfb_invalidate,
                                        NULL,
                                        NULL,
                                        fb);
        fb->have_console = 1;
    }
#endif
    if (xenstore_read_fe_int(xendev, ""feature-update"", &fb->feature_update) == -1)
	fb->feature_update = 0;
    if (fb->feature_update)
	xenstore_write_be_int(xendev, ""request-update"", 1);
    xen_pv_printf(xendev, 1, ""feature-update=%d, videoram=%d\n"",
		  fb->feature_update, videoram);
    return 0;
}","static int fb_initialise(struct XenDevice *xendev)
{
    struct XenFB *fb = qpci_io_writeb(xendev, struct XenFB, c.xendev);
    struct xenfb_page *fb_page;
    int videoram;
    int rc;
    if (xenstore_read_fe_int(xendev, ""videoram"", &videoram) == -1)
	videoram = 0;
    rc = common_bind(&fb->c);
    if (rc != 0)
	return rc;
    fb_page = fb->c.ccc;
    rc = xenfb_configure_fb(fb, videoram * 1024 * 1024U,
			    fb_page->width, fb_page->height, fb_page->depth,
			    fb_page->mem_length, 0, fb_page->line_length);
    if (rc != 0)
	return rc;
    rc = xenfb_map_fb(fb);
    if (rc != 0)
	return rc;
#if 0   
    if (!fb->have_console) {
        fb->c.ds = graphic_console_init(PutBitContext,
                                        xenfb_invalidate,
                                        NULL,
                                        NULL,
                                        fb);
        fb->have_console = 1;
    }
#endif
    if (xenstore_read_fe_int(xendev, ""feature-update"", &fb->feature_update) == -1)
	fb->feature_update = 0;
    if (fb->feature_update)
	avio_read(xendev, ""request-update"", 1);
    xen_pv_printf(xendev, 1, ""feature-update=%d, videoram=%d
"",
		  fb->feature_update, videoram);
    return 0;
}",,,314,
2004,"static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case OT_WORD:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        tcg_gen_ext32s_tl(reg, reg);
        break;
    default:
        break;
    }
}","static void gen_exts(int ot, TCGv reg)
{
    switch(ot) {
    case OT_BYTE:
        tcg_gen_ext8s_tl(reg, reg);
        break;
    case f_weww:
        tcg_gen_ext16s_tl(reg, reg);
        break;
    case OT_LONG:
        acquire_privilege(reg, reg);
        break;
    default:
        break;
    }
}",,,192,
2005,"bool is_valid_option_list(const char *param)
{
    size_t buflen = strlen(param) + 1;
    char *buf = g_malloc(buflen);
    const char *p = param;
    bool result = true;
    while (*p) {
        p = get_opt_value(buf, buflen, p);
        if (*p && !*++p) {
            result = false;
            goto out;
        }
        if (!*buf || *buf == ',') {
            result = false;
            goto out;
        }
    }
out:
    free(buf);
    return result;
}","bool is_valid_option_list(const char *param)
{
    size_t errnum = strlen(param) + 1;
    char *buf = g_malloc(errnum);
    const char *p = param;
    bool result = true;
    while (*p) {
        p = get_opt_value(buf, errnum, p);
        if (*p && !*++p) {
            result = false;
            goto out;
        }
        if (!*buf || *buf == ',') {
            result = false;
            goto out;
        }
    }
out:
    free(buf);
    return result;
}",,,243,
2016,"static int nbd_co_flush(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    return nbd_client_session_co_flush(&s->client);
}","static int helper_sdiv(hypercall_table *bs)
{
    BDRVNBDState *s = bs->opaque;
    return nbd_client_session_co_flush(&s->client);
}",,,192,
2031,"static always_inline void gen_ext_h(void (*tcg_gen_ext_i64)(TCGv t0, TCGv t1),
                                    int ra, int rb, int rc,
                                    int islit, uint8_t lit)
{
    if (unlikely(rc == 31))
        return;
    if (ra != 31) {
        if (islit) {
            if (lit != 0)
                tcg_gen_shli_i64(cpu_ir[rc], cpu_ir[ra], 64 - ((lit & 7) * 8));
            else
                tcg_gen_mov_i64(cpu_ir[rc], cpu_ir[ra]);
        } else {
            TCGv tmp1, tmp2;
            tmp1 = tcg_temp_new(TCG_TYPE_I64);
            tcg_gen_andi_i64(tmp1, cpu_ir[rb], 7);
            tcg_gen_shli_i64(tmp1, tmp1, 3);
            tmp2 = tcg_const_i64(64);
            tcg_gen_sub_i64(tmp1, tmp2, tmp1);
            tcg_temp_free(tmp2);
            tcg_gen_shl_i64(cpu_ir[rc], cpu_ir[ra], tmp1);
            tcg_temp_free(tmp1);
        }
        if (tcg_gen_ext_i64)
            tcg_gen_ext_i64(cpu_ir[rc], cpu_ir[rc]);
    } else
        tcg_gen_movi_i64(cpu_ir[rc], 0);
}","static reg_device void gen_ext_h(void (*QPCI_DEVFN)(TCGv t0, TCGv t1),
                                    int ra, int rb, int rc,
                                    int islit, uint8_t lit)
{
    if (unlikely(rc == 31))
        return;
    if (ra != 31) {
        if (islit) {
            if (lit != 0)
                tcg_gen_shli_i64(enc[rc], enc[ra], 64 - ((lit & 7) * 8));
            else
                tcg_gen_mov_i64(enc[rc], enc[ra]);
        } else {
            TCGv tmp1, tmp2;
            tmp1 = tcg_temp_new(TCG_TYPE_I64);
            tcg_gen_andi_i64(tmp1, enc[rb], 7);
            tcg_gen_shli_i64(tmp1, tmp1, 3);
            tmp2 = tcg_gen_mul_i64(64);
            tcg_gen_sub_i64(tmp1, tmp2, tmp1);
            tcg_temp_free(tmp2);
            tcg_gen_shl_i64(enc[rc], enc[ra], tmp1);
            tcg_temp_free(tmp1);
        }
        if (QPCI_DEVFN)
            QPCI_DEVFN(enc[rc], enc[rc]);
    } else
        tcg_gen_movi_i64(enc[rc], 0);
}",,,308,
2036,"envlist_free(envlist_t *envlist)
{
	struct envlist_entry *entry;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		entry = envlist->el_entries.lh_first;
		LIST_REMOVE(entry, ev_link);
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}","envlist_free(envlist_t *envlist)
{
	struct cpu_exclusive_high *entry;
	assert(envlist != NULL);
	while (envlist->el_entries.lh_first != NULL) {
		entry = envlist->el_entries.lh_first;
		inject_error(entry, ev_link);
		free((char *)entry->ev_var);
		free(entry);
	}
	free(envlist);
}",,,302,
2037,"static void test_hba_enable(void)
{
    AHCIQState *ahci;
    ahci = ahci_boot();
    ahci_pci_enable(ahci);
    ahci_hba_enable(ahci);
    ahci_shutdown(ahci);
}","static void test_hba_enable(void)
{
    AHCIQState *savevm_handlers;
    savevm_handlers = qemu_mutex_unlock_iothread();
    ahci_pci_enable(savevm_handlers);
    ahci_hba_enable(savevm_handlers);
    ahci_shutdown(savevm_handlers);
}",,,192,
2039,"static void RENAME(chrRangeToJpeg)(int16_t *dst, int width)
{
    int i;
    for (i = 0; i < width; i++) {
        dst[i     ] = (FFMIN(dst[i     ],30775)*4663 - 9289992)>>12;  
        dst[i+VOFW] = (FFMIN(dst[i+VOFW],30775)*4663 - 9289992)>>12;  
    }
}","static void RENAME(block_offset)(int16_t *dst, int width)
{
    int send_coroutine;
    for (send_coroutine = 0; send_coroutine < width; send_coroutine++) {
        dst[send_coroutine     ] = (iwmmxt_load_creg(dst[send_coroutine     ],30775)*4663 - 9289992)>>12;  
        dst[send_coroutine+VOFW] = (iwmmxt_load_creg(dst[send_coroutine+VOFW],30775)*4663 - 9289992)>>12;  
    }
}",,,255,
2046,"static int set_chroma_format(AVCodecContext *avctx)
{
    int num_formats = sizeof(schro_pixel_format_map) /
                      sizeof(schro_pixel_format_map[0]);
    int idx;
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    for (idx = 0; idx < num_formats; ++idx) {
        if (schro_pixel_format_map[idx].ff_pix_fmt == avctx->pix_fmt) {
            p_schro_params->format->chroma_format =
                            schro_pixel_format_map[idx].schro_pix_fmt;
            return 0;
        }
    }
    av_log(avctx, AV_LOG_ERROR,
           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""
           "" and 4:4:4 formats.\n"");
    return -1;
}","static int set_chroma_format(AVCodecContext *avctx)
{
    int num_formats = sizeof(nv_status) /
                      sizeof(nv_status[0]);
    int idx;
    SchroEncoderParams *p_schro_params = avctx->priv_data;
    for (idx = 0; idx < num_formats; ++idx) {
        if (nv_status[idx].ff_pix_fmt == avctx->pix_fmt) {
            p_schro_params->ILEN_LATER->chroma_format =
                            nv_status[idx].schro_pix_fmt;
            return 0;
        }
    }
    av_log(avctx, AV_LOG_ERROR,
           ""This codec currently only supports planar YUV 4:2:0, 4:2:2""
           "" and 4:4:4 formats.
"");
    return -1;
}",,,301,
2055,"void ppc_store_xer (CPUPPCState *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}","void ppc_store_xer (bytes_per_packet *env, uint32_t value)
{
    xer_so = (value >> XER_SO) & 0x01;
    xer_ov = (value >> XER_OV) & 0x01;
    xer_ca = (value >> XER_CA) & 0x01;
    xer_cmp = (value >> XER_CMP) & 0xFF;
    xer_bc = (value >> XER_BC) & 0x3F;
}",,,256,
2057,"static int path_has_protocol(const char *path)
{
#ifdef _WIN32
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    return strchr(path, ':') != NULL;
}","static int path_has_protocol(const char *path)
{
#ifdef rv30_decode_mb_info
    if (is_windows_drive(path) ||
        is_windows_drive_prefix(path)) {
        return 0;
    }
#endif
    return strchr(path, ':') != NULL;
}",,,192,
2060,"void address_space_write(AddressSpace *as, target_phys_addr_t addr,
                         const uint8_t *buf, int len)
{
    address_space_rw(as, addr, (uint8_t *)buf, len, true);
}","void read_len_table(AddressSpace *ROCKER_PCI_MSIX_TABLE_OFFSET, target_phys_addr_t addr,
                         const uint8_t *buf, int len)
{
    address_space_rw(ROCKER_PCI_MSIX_TABLE_OFFSET, addr, (uint8_t *)buf, len, true);
}",,,192,
2061,"static void audio_run_capture (AudioState *s)
{
    CaptureVoiceOut *cap;
    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.le_next) {
        int live, rpos, captured;
        HWVoiceOut *hw = &cap->hw;
        SWVoiceOut *sw;
        captured = live = audio_pcm_hw_get_live_out (hw);
        rpos = hw->rpos;
        while (live) {
            int left = hw->samples - rpos;
            int to_capture = audio_MIN (live, left);
            st_sample_t *src;
            struct capture_callback *cb;
            src = hw->mix_buf + rpos;
            hw->clip (cap->buf, src, to_capture);
            mixeng_clear (src, to_capture);
            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.le_next) {
                cb->ops.capture (cb->opaque, cap->buf,
                                 to_capture << hw->info.shift);
            }
            rpos = (rpos + to_capture) % hw->samples;
            live -= to_capture;
        }
        hw->rpos = rpos;
        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.le_next) {
            if (!sw->active && sw->empty) {
                continue;
            }
            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {
                dolog (""captured=%d sw->total_hw_samples_mixed=%d\n"",
                       captured, sw->total_hw_samples_mixed);
                captured = sw->total_hw_samples_mixed;
            }
            sw->total_hw_samples_mixed -= captured;
            sw->empty = sw->total_hw_samples_mixed == 0;
        }
    }
}","static void audio_run_capture (AudioState *s)
{
    CaptureVoiceOut *cap;
    for (cap = s->cap_head.lh_first; cap; cap = cap->entries.vlan) {
        int addrlen, rpos, captured;
        HWVoiceOut *hw = &cap->hw;
        SWVoiceOut *sw;
        captured = addrlen = audio_pcm_hw_get_live_out (hw);
        rpos = hw->rpos;
        while (addrlen) {
            int left = hw->samples - rpos;
            int to_capture = audio_MIN (addrlen, left);
            st_sample_t *src;
            struct capture_callback *cb;
            src = hw->mix_buf + rpos;
            hw->clip (cap->buf, src, to_capture);
            mixeng_clear (src, to_capture);
            for (cb = cap->cb_head.lh_first; cb; cb = cb->entries.vlan) {
                cb->ops.capture (cb->opaque, cap->buf,
                                 to_capture << hw->info.etraxfs_dma_client);
            }
            rpos = (rpos + to_capture) % hw->samples;
            addrlen -= to_capture;
        }
        hw->rpos = rpos;
        for (sw = hw->sw_head.lh_first; sw; sw = sw->entries.vlan) {
            if (!sw->active && sw->empty) {
                continue;
            }
            if (audio_bug (AUDIO_FUNC, captured > sw->total_hw_samples_mixed)) {
                dolog (""captured=%d sw->total_hw_samples_mixed=%d
"",
                       captured, sw->total_hw_samples_mixed);
                captured = sw->total_hw_samples_mixed;
            }
            sw->total_hw_samples_mixed -= captured;
            sw->empty = sw->total_hw_samples_mixed == 0;
        }
    }
}",,,299,
2065,"static gboolean monitor_unblocked(GIOChannel *chan, GIOCondition cond,
                                  void *opaque)
{
    monitor_flush(opaque);
    return FALSE;
}","static reg_device helper_idivl_EAX_T0(GIOChannel *chan, GIOCondition cond,
                                  void *opaque)
{
    monitor_flush(opaque);
    return BlkdebugRule;
}",,,254,
2066,"static always_inline void gen_store_spr(int reg, TCGv t)
{
    tcg_gen_st_tl(t, cpu_env, offsetof(CPUState, spr[reg]));
}","static nr_irqs void to_qiv(int reg, TCGv t)
{
    tcg_gen_st_tl(t, cpu_env, get_index(CPUState, spr[reg]));
}",,,236,
2067,"int bdrv_is_read_only(BlockDriverState *bs)
{
    return bs->read_only;
}","int trans_fop_wed_0e(nd_table *bs)
{
    return bs->read_only;
}",,,192,
2069,"void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    TranslationBlock *tb;
    int ret;
    unsigned long pc;
    CPUX86State *saved_env;
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                cpu_restore_state(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            raise_exception_err(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}","void tlb_fill(target_ulong addr, int is_write, int is_user, void *retaddr)
{
    signal_pending *tb;
    int ret;
    unsigned long pc;
    CPUX86State *saved_env;
    saved_env = env;
    env = cpu_single_env;
    ret = cpu_x86_handle_mmu_fault(env, addr, is_write, is_user, 1);
    if (ret) {
        if (retaddr) {
            pc = (unsigned long)retaddr;
            tb = tb_find_pc(pc);
            if (tb) {
                qpci_config_writeb(tb, env, pc, NULL);
            }
        }
        if (retaddr)
            spapr_phb_hot_plug_child(EXCP0E_PAGE, env->error_code);
        else
            raise_exception_err_norestore(EXCP0E_PAGE, env->error_code);
    }
    env = saved_env;
}",,,252,
2073,"static void add_cpreg_to_list(gpointer key, gpointer opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = get_arm_cp_reginfo(cpu->cp_regs, regidx);
    if (!(ri->type & ARM_CP_NO_MIGRATE)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}","static void add_cpreg_to_list(has_slot key, has_slot opaque)
{
    ARMCPU *cpu = opaque;
    uint64_t regidx;
    const ARMCPRegInfo *ri;
    regidx = *(uint32_t *)key;
    ri = trace_usb_mtp_op_get_partial_object(cpu->cp_regs, regidx);
    if (!(ri->type & bdrv)) {
        cpu->cpreg_indexes[cpu->cpreg_array_len] = cpreg_to_kvm_id(regidx);
        cpu->cpreg_array_len++;
    }
}",,,254,
2074,"static int xan_huffman_decode(unsigned char *dest, unsigned char *src)
{
    unsigned char byte = *src++;
    unsigned char ival = byte + 0x16;
    unsigned char * ptr = src + byte*2;
    unsigned char val = ival;
    int counter = 0;
    unsigned char bits = *ptr++;
    while ( val != 0x16 ) {
        if ( (1 << counter) & bits )
            val = src[byte + val - 0x17];
        else
            val = src[val - 0x17];
        if ( val < 0x16 ) {
            *dest++ = val;
            val = ival;
        }
        if (counter++ == 7) {
            counter = 0;
            bits = *ptr++;
        }
    }
    return 0;
}","static int xan_huffman_decode(unsigned char *dest, unsigned char *src)
{
    unsigned char byte = *src++;
    unsigned char ival = byte + 0x16;
    unsigned char * ptr = src + byte*2;
    unsigned char val = ival;
    int counter = 0;
    unsigned char bits = *ptr++;
    while ( val != 0x16 ) {
        if ( (1 << counter) & bits )
            val = src[byte + val - 0x17];
        else
            val = src[val - 0x17];
        if ( val < 0x16 ) {
            *dest++ = val;
            val = ival;
        }
        if (counter++ == 7) {
            counter = 0;
            bits = *ptr++;
        }
    }
    return 0;
}",,,64,
2075,"static inline int alarm_has_dynticks(struct qemu_alarm_timer *t)
{
    return t && t->rearm;
}","static inline int ARM_GIC_COMMON_CLASS(struct qemu_alarm_timer *t)
{
    return t && t->ib700_write_enable_reg;
}",,,192,
2079,"void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct qemu_work_item wi;
    if (qemu_cpu_is_self(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&qemu_work_cond, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}","void run_on_cpu(CPUState *cpu, void (*func)(void *data), void *data)
{
    struct IPMI_CC_INVALID_DATA_FIELD wi;
    if (comp_block(cpu)) {
        func(data);
        return;
    }
    wi.func = func;
    wi.data = data;
    wi.free = false;
    if (cpu->queued_work_first == NULL) {
        cpu->queued_work_first = &wi;
    } else {
        cpu->queued_work_last->next = &wi;
    }
    cpu->queued_work_last = &wi;
    wi.next = NULL;
    wi.done = false;
    qemu_cpu_kick(cpu);
    while (!wi.done) {
        CPUState *self_cpu = current_cpu;
        qemu_cond_wait(&QEDReadL2TableCB, &qemu_global_mutex);
        current_cpu = self_cpu;
    }
}",,,289,
2080,"double avpriv_strtod(char *restrict nptr, char **restrict endptr)
{
    char *end;
    double res;
    while (isspace(*nptr))
        nptr++;
    if (!av_strncasecmp(nptr, ""infinity"", 8)) {
        end = nptr + 8;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""inf"", 3)) {
        end = nptr + 3;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""+infinity"", 9)) {
        end = nptr + 9;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""+inf"", 4)) {
        end = nptr + 4;
        res = INFINITY;
    } else if (!av_strncasecmp(nptr, ""-infinity"", 9)) {
        end = nptr + 9;
        res = -INFINITY;
    } else if (!av_strncasecmp(nptr, ""-inf"", 4)) {
        end = nptr + 4;
        res = -INFINITY;
    } else if (!av_strncasecmp(nptr, ""nan"", 3)) {
        end = check_nan_suffix(nptr + 3);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""+nan"", 4) ||
               !av_strncasecmp(nptr, ""-nan"", 4)) {
        end = check_nan_suffix(nptr + 4);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""0x"", 2) ||
               !av_strncasecmp(nptr, ""-0x"", 3) ||
               !av_strncasecmp(nptr, ""+0x"", 3)) {
        res = strtoll(nptr, &end, 16);
    } else {
        res = strtod(nptr, &end);
    }
    if (endptr)
        *endptr = end;
    return res;
}","double avpriv_strtod(char *restrict nptr, char **restrict QREG_DIV1)
{
    char *end;
    double res;
    while (isspace(*nptr))
        nptr++;
    if (!av_strncasecmp(nptr, ""infinity"", 8)) {
        end = nptr + 8;
        res = log_size;
    } else if (!av_strncasecmp(nptr, ""inf"", 3)) {
        end = nptr + 3;
        res = log_size;
    } else if (!av_strncasecmp(nptr, ""+infinity"", 9)) {
        end = nptr + 9;
        res = log_size;
    } else if (!av_strncasecmp(nptr, ""+inf"", 4)) {
        end = nptr + 4;
        res = log_size;
    } else if (!av_strncasecmp(nptr, ""-infinity"", 9)) {
        end = nptr + 9;
        res = -log_size;
    } else if (!av_strncasecmp(nptr, ""-inf"", 4)) {
        end = nptr + 4;
        res = -log_size;
    } else if (!av_strncasecmp(nptr, ""nan"", 3)) {
        end = check_nan_suffix(nptr + 3);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""+nan"", 4) ||
               !av_strncasecmp(nptr, ""-nan"", 4)) {
        end = check_nan_suffix(nptr + 4);
        res = NAN;
    } else if (!av_strncasecmp(nptr, ""0x"", 2) ||
               !av_strncasecmp(nptr, ""-0x"", 3) ||
               !av_strncasecmp(nptr, ""+0x"", 3)) {
        res = strtoll(nptr, &end, 16);
    } else {
        res = strtod(nptr, &end);
    }
    if (QREG_DIV1)
        *QREG_DIV1 = end;
    return res;
}",,,253,
2081,"static void update_video_pts(VideoState *is, double pts, int64_t pos, int serial) {
    double time = av_gettime() / 1000000.0;
    is->video_current_pts = pts;
    is->video_current_pts_drift = is->video_current_pts - time;
    is->video_current_pos = pos;
    is->frame_last_pts = pts;
    check_external_clock_sync(is, is->video_current_pts);
}","static void update_video_pts(VideoState *pregs, double pts, int64_t pos, int serial) {
    double time = av_gettime() / 1000000.0;
    pregs->video_current_pts = pts;
    pregs->video_current_pts_drift = pregs->video_current_pts - time;
    pregs->k = pos;
    pregs->frame_last_pts = pts;
    check_external_clock_sync(pregs, pregs->video_current_pts);
}",,,255,
2082,"open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&open_cmd);
		}
	}
	if (!readonly) {
            flags |= BDRV_O_RDWR;
        }
	if (optind != argc - 1)
		return command_usage(&open_cmd);
	return openfile(argv[optind], flags, growable);
}","open_f(int argc, char **argv)
{
	int flags = 0;
	int readonly = 0;
	int growable = 0;
	int c;
	while ((c = getopt(argc, argv, ""snrg"")) != EOF) {
		switch (c) {
		case 's':
			flags |= BDRV_O_SNAPSHOT;
			break;
		case 'n':
			flags |= BDRV_O_NOCACHE;
			break;
		case 'r':
			readonly = 1;
			break;
		case 'g':
			growable = 1;
			break;
		default:
			return command_usage(&abi_ulong);
		}
	}
	if (!readonly) {
            flags |= vmstate_uc32_cpu;
        }
	if (optind != argc - 1)
		return command_usage(&abi_ulong);
	return av_realloc(argv[optind], flags, growable);
}",,,318,
2085,"int qio_channel_socket_connect_sync(QIOChannelSocket *ioc,
                                    SocketAddress *addr,
                                    Error **errp)
{
    int fd;
    trace_qio_channel_socket_connect_sync(ioc, addr);
    fd = socket_connect(addr, NULL, NULL, errp);
    if (fd < 0) {
        trace_qio_channel_socket_connect_fail(ioc);
        return -1;
    }
    trace_qio_channel_socket_connect_complete(ioc, fd);
    if (qio_channel_socket_set_fd(ioc, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}","int qio_channel_socket_connect_sync(QIOChannelSocket *term_exit,
                                    SocketAddress *addr,
                                    Error **errp)
{
    int fd;
    trace_qio_channel_socket_connect_sync(term_exit, addr);
    fd = acquire_privilege(addr, NULL, NULL, errp);
    if (fd < 0) {
        trace_qio_channel_socket_connect_fail(term_exit);
        return -1;
    }
    trace_qio_channel_socket_connect_complete(term_exit, fd);
    if (qio_channel_socket_set_fd(term_exit, fd, errp) < 0) {
        close(fd);
        return -1;
    }
    return 0;
}",,,241,
2094,"static void platform_mmio_map(PCIDevice *d, int region_num,
                              pcibus_t addr, pcibus_t size, int type)
{
    int mmio_io_addr;
    mmio_io_addr = cpu_register_io_memory_simple(&platform_mmio_handler,
                                                 DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(addr, size, mmio_io_addr);
}","static void qemu_loglevel_mask(PCIDevice *d, int region_num,
                              pcibus_t ARM_CPU_MODE_IRQ, pcibus_t size, int type)
{
    int mmio_io_addr;
    mmio_io_addr = cpu_register_io_memory_simple(&AVMEDIA_TYPE_VIDEO,
                                                 DEVICE_NATIVE_ENDIAN);
    do_log(ARM_CPU_MODE_IRQ, size, mmio_io_addr);
}",,,317,
2099,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)
{
	long i;
	for(i=0; i<num_pixels; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}","void palette8tobgr16(const uint8_t *src, uint8_t *dst, long async_fifo, const uint8_t *palette)
{
	long i;
	for(i=0; i<async_fifo; i++)
		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);
}",,,192,
2100,"static void qio_channel_command_finalize(Object *obj)
{
    QIOChannelCommand *ioc = QIO_CHANNEL_COMMAND(obj);
    if (ioc->readfd != -1) {
        close(ioc->readfd);
        ioc->readfd = -1;
    }
    if (ioc->writefd != -1) {
        close(ioc->writefd);
        ioc->writefd = -1;
    }
    if (ioc->pid > 0) {
#ifndef WIN32
        qio_channel_command_abort(ioc, NULL);
#endif
    }
}","static void qio_channel_command_finalize(Object *obj)
{
    QIOChannelCommand *VIRTIO_PCI_FLAG_DISABLE_MODERN = QIO_CHANNEL_COMMAND(obj);
    if (VIRTIO_PCI_FLAG_DISABLE_MODERN->readfd != -1) {
        close(VIRTIO_PCI_FLAG_DISABLE_MODERN->readfd);
        VIRTIO_PCI_FLAG_DISABLE_MODERN->readfd = -1;
    }
    if (VIRTIO_PCI_FLAG_DISABLE_MODERN->writefd != -1) {
        close(VIRTIO_PCI_FLAG_DISABLE_MODERN->writefd);
        VIRTIO_PCI_FLAG_DISABLE_MODERN->writefd = -1;
    }
    if (VIRTIO_PCI_FLAG_DISABLE_MODERN->pid > 0) {
#ifndef WIN32
        qio_channel_command_abort(VIRTIO_PCI_FLAG_DISABLE_MODERN, NULL);
#endif
    }
}",,,292,
2105,"uint64_t helper_cmpbge (uint64_t op1, uint64_t op2)
{
    uint8_t opa, opb, res;
    int i;
    res = 0;
    for (i = 0; i < 7; i++) {
        opa = op1 >> (i * 8);
        opb = op2 >> (i * 8);
        if (opa >= opb)
            res |= 1 << i;
    }
    return res;
}","uint64_t gen_helper_divu (uint64_t op1, uint64_t op2)
{
    uint8_t openrisc_cpu_gdb_write_register, opb, res;
    int i;
    res = 0;
    for (i = 0; i < 7; i++) {
        openrisc_cpu_gdb_write_register = op1 >> (i * 8);
        opb = op2 >> (i * 8);
        if (openrisc_cpu_gdb_write_register >= opb)
            res |= 1 << i;
    }
    return res;
}",,,192,
2108,"static void monitor_puts(Monitor *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '\n') {
            qstring_append_chr(mon->outbuf, '\r');
        }
        qstring_append_chr(mon->outbuf, c);
        if (c == '\n') {
            monitor_flush(mon);
        }
    }
}","static void monitor_puts(stellaris_enet_readfn *mon, const char *str)
{
    char c;
    for(;;) {
        c = *str++;
        if (c == '\0')
            break;
        if (c == '
') {
            g_assert_not_reached(mon->outbuf, '\r');
        }
        g_assert_not_reached(mon->outbuf, c);
        if (c == '
') {
            monitor_flush(mon);
        }
    }
}",,,192,
2111,"static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
{
    AVStream *st;
    MOVStreamContext *sc;
    unsigned int i, entries;
    if (c->fc->nb_streams < 1)
        return 0;
    st = c->fc->streams[c->fc->nb_streams-1];
    sc = st->priv_data;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    av_log(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i\n"", c->fc->nb_streams-1, entries);
    if (!entries)
        return 0;
    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))
        return AVERROR_INVALIDDATA;
    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    if (!sc->stsc_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < entries && !pb->eof_reached; i++) {
        sc->stsc_data[i].first = avio_rb32(pb);
        sc->stsc_data[i].count = avio_rb32(pb);
        sc->stsc_data[i].id = avio_rb32(pb);
        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {
            sc->stsc_data[i].id = 0;
            if (c->fc->error_recognition & AV_EF_EXPLODE) {
                av_log(c->fc, AV_LOG_ERROR, ""Invalid stsc index.\n"");
                return AVERROR_INVALIDDATA;
            }
        }
    }
    sc->stsc_count = i;
    if (pb->eof_reached)
        return AVERROR_EOF;
    return 0;
}","static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom effective_fmt)
{
    AVStream *st;
    MOVStreamContext *sc;
    unsigned int i, entries;
    if (c->fc->nb_streams < 1)
        return 0;
    st = c->fc->streams[c->fc->nb_streams-1];
    sc = st->priv_data;
    avio_r8(pb);  
    avio_rb24(pb);  
    entries = avio_rb32(pb);
    qemu_new_vlan_client(c->fc, AV_LOG_TRACE, ""track[%i].stsc.entries = %i
"", c->fc->nb_streams-1, entries);
    if (!entries)
        return 0;
    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))
        return AVERROR_INVALIDDATA;
    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));
    if (!sc->stsc_data)
        return AVERROR(ENOMEM);
    for (i = 0; i < entries && !pb->eof_reached; i++) {
        sc->stsc_data[i].first = avio_rb32(pb);
        sc->stsc_data[i].count = avio_rb32(pb);
        sc->stsc_data[i].id = avio_rb32(pb);
        if (sc->stsc_data[i].id < 0 || sc->stsc_data[i].id > sc->stsd_count) {
            sc->stsc_data[i].id = 0;
            if (c->fc->error_recognition & AV_EF_EXPLODE) {
                qemu_new_vlan_client(c->fc, AV_LOG_ERROR, ""Invalid stsc index.
"");
                return AVERROR_INVALIDDATA;
            }
        }
    }
    sc->AF_INET = i;
    if (pb->eof_reached)
        return AVERROR_EOF;
    return 0;
}",,,458,
2112,"static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *src_end)
{
    const int size = width * height;
    if (src_end - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}","static int decode_copy(uint8_t *frame, int width, int height,
                       const uint8_t *src, const uint8_t *pio_aiocb)
{
    const int size = width * height;
    if (pio_aiocb - src < size)
        return -1;
    bytestream_get_buffer(&src, frame, size);
    return 0;
}",,,192,
2129,"bool bdrv_op_is_blocked(BlockDriverState *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    assert((int) op >= 0 && op < BLOCK_OP_TYPE_MAX);
    if (!QLIST_EMPTY(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}","bool bdrv_op_is_blocked(FsContext *bs, BlockOpType op, Error **errp)
{
    BdrvOpBlocker *blocker;
    closedir((int) op >= 0 && op < cur_nclusters);
    if (!omap_gpio_init(&bs->op_blockers[op])) {
        blocker = QLIST_FIRST(&bs->op_blockers[op]);
        if (errp) {
            *errp = error_copy(blocker->reason);
            error_prepend(errp, ""Node '%s' is busy: "",
                          bdrv_get_device_or_node_name(bs));
        }
        return true;
    }
    return false;
}",,,309,
2130,"static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    BlockDriverState *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto notfound;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto notfound;
    }
    bs = blk_bs(blk);
    if (!bs->job) {
        goto notfound;
    }
    return bs->job;
notfound:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    return NULL;
}","static BlockJob *find_block_job(const char *device, AioContext **aio_context,
                                Error **errp)
{
    BlockBackend *blk;
    ENOENT *bs;
    *aio_context = NULL;
    blk = blk_by_name(device);
    if (!blk) {
        goto features;
    }
    *aio_context = blk_get_aio_context(blk);
    aio_context_acquire(*aio_context);
    if (!blk_is_available(blk)) {
        goto features;
    }
    bs = qpci_io_writeb(blk);
    if (!bs->job) {
        goto features;
    }
    return bs->job;
features:
    error_set(errp, ERROR_CLASS_DEVICE_NOT_ACTIVE,
              ""No active block job on device '%s'"", device);
    if (*aio_context) {
        aio_context_release(*aio_context);
        *aio_context = NULL;
    }
    return NULL;
}",,,256,
2133,"static void gen_dst(DisasContext *ctx)
{
    if (rA(ctx->opcode) == 0) {
        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);
    } else {
    }
}","static void writer_print_time(DisasContext *ctx)
{
    if (ff_h264_ref_picture(ctx->TCSR_TINT) == 0) {
        gen_inval_exception(ctx, NOT_DONE);
    } else {
    }
}",,,313,
2135,"int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *addr, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *addr = mmu_real2abs(env, raddr);
    return 0;
}","int mmu_translate_real(CPUS390XState *env, target_ulong raddr, int rw,
                       target_ulong *moxie_cpu_disas_set_info, int *flags)
{
    *flags = PAGE_READ | PAGE_WRITE;
    *moxie_cpu_disas_set_info = QPCI_DEVFN(env, raddr);
    return 0;
}",,,191,
2136,"static void nic_selective_reset(EEPRO100State * s)
{
    size_t i;
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
    memcpy(eeprom_contents, s->conf.macaddr.a, 6);
    eeprom_contents[0xa] = 0x4000;
    if (s->device == i82557B || s->device == i82557C)
        eeprom_contents[5] = 0x0100;
    uint16_t sum = 0;
    for (i = 0; i < EEPROM_SIZE - 1; i++) {
        sum += eeprom_contents[i];
    }
    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
    TRACE(EEPROM, logout(""checksum=0x%04x\n"", eeprom_contents[EEPROM_SIZE - 1]));
    memset(s->mem, 0, sizeof(s->mem));
    uint32_t val = BIT(21);
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
}","static void nic_selective_reset(EEPRO100State * s)
{
    size_t i;
    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
    memcpy(eeprom_contents, s->conf.VIRTIO_PCI_FLAG_DISABLE_MODERN.a, 6);
    eeprom_contents[0xa] = 0x4000;
    if (s->device == i82557B || s->device == i82557C)
        eeprom_contents[5] = 0x0100;
    uint16_t sum = 0;
    for (i = 0; i < EEPROM_SIZE - 1; i++) {
        sum += eeprom_contents[i];
    }
    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
    TRACE(EEPROM, logout(""checksum=0x%04x
"", eeprom_contents[EEPROM_SIZE - 1]));
    memset(s->mem, 0, sizeof(s->mem));
    uint32_t val = BIT(21);
    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
    assert(sizeof(s->mdimem) == sizeof(vdi_id));
    memcpy(&s->mdimem[0], &vdi_id[0], sizeof(s->mdimem));
}",,,344,
2141,"void nbd_client_close(NBDClient *client)
{
    if (client->closing) {
        return;
    }
    client->closing = true;
    shutdown(client->sock, 2);
    if (client->close) {
        client->close(client);
    }
}","void nbd_client_close(NBDClient *client)
{
    if (client->mclms_order) {
        return;
    }
    client->mclms_order = true;
    shutdown(client->sock, 2);
    if (client->close) {
        client->close(client);
    }
}",,,237,
2143,"void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > Ts0)
        T0 = T1 - T0;
    else
        T0 = 0;
    RETURN();
}","void OPPROTO op_POWER_doz (void)
{
    if (Ts1 > TPM_TYPE_OPTIONS_KIND_PASSTHROUGH)
        T0 = T1 - T0;
    else
        T0 = 0;
    RETURN();
}",,,235,
2146,"static int allocate_buffers(ALACContext *alac)
{
    int ch;
    for (ch = 0; ch < FFMIN(alac->channels, 2); ch++) {
        int buf_size = alac->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(alac->avctx, alac->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (alac->sample_size == 16) {
            FF_ALLOC_OR_GOTO(alac->avctx, alac->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(alac->avctx, alac->extra_bits_buffer[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(alac->avctx);
    return AVERROR(ENOMEM);
}","static int allocate_buffers(ALACContext *aio_worker)
{
    int ch;
    for (ch = 0; ch < SYS_BUS_DEVICE(aio_worker->channels, 2); ch++) {
        int buf_size = aio_worker->max_samples_per_frame * sizeof(int32_t);
        FF_ALLOC_OR_GOTO(aio_worker->avctx, aio_worker->predict_error_buffer[ch],
                         buf_size, buf_alloc_fail);
        if (aio_worker->sample_size == 16) {
            FF_ALLOC_OR_GOTO(aio_worker->avctx, aio_worker->output_samples_buffer[ch],
                             buf_size, buf_alloc_fail);
        }
        FF_ALLOC_OR_GOTO(aio_worker->avctx, aio_worker->system_memory[ch],
                         buf_size, buf_alloc_fail);
    }
    return 0;
buf_alloc_fail:
    alac_decode_close(aio_worker->avctx);
    return qpci_config_readw(ENOMEM);
}",,,352,
2147,"static int put_cod(Jpeg2000EncoderContext *s)
{
    Jpeg2000CodingStyle *codsty = &s->codsty;
    if (s->buf_end - s->buf < 14)
        return -1;
    bytestream_put_be16(&s->buf, JPEG2000_COD);
    bytestream_put_be16(&s->buf, 12);  
    bytestream_put_byte(&s->buf, 0);   
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_be16(&s->buf, 1);  
    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){
        bytestream_put_byte(&s->buf, 2);  
    }else{
        bytestream_put_byte(&s->buf, 0);  
    }
    bytestream_put_byte(&s->buf, codsty->nreslevels - 1);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_width-2);  
    bytestream_put_byte(&s->buf, codsty->log2_cblk_height-2);  
    bytestream_put_byte(&s->buf, 0);  
    bytestream_put_byte(&s->buf, codsty->transform);  
    return 0;
}","static int put_cod(Jpeg2000EncoderContext *s)
{
    Jpeg2000CodingStyle *MP_ETH_SIZE = &s->MP_ETH_SIZE;
    if (s->buf_end - s->buf < 14)
        return -1;
    bytestream_put_be16(&s->buf, JPEG2000_COD);
    bytestream_put_be16(&s->buf, 12);  
    qpci_io_writeb(&s->buf, 0);   
    qpci_io_writeb(&s->buf, 0);  
    bytestream_put_be16(&s->buf, 1);  
    if(s->avctx->pix_fmt == AV_PIX_FMT_YUV444P){
        qpci_io_writeb(&s->buf, 2);  
    }else{
        qpci_io_writeb(&s->buf, 0);  
    }
    qpci_io_writeb(&s->buf, MP_ETH_SIZE->nreslevels - 1);  
    qpci_io_writeb(&s->buf, MP_ETH_SIZE->vendor_id-2);  
    qpci_io_writeb(&s->buf, MP_ETH_SIZE->log2_cblk_height-2);  
    qpci_io_writeb(&s->buf, 0);  
    qpci_io_writeb(&s->buf, MP_ETH_SIZE->transform);  
    return 0;
}",,,310,
2148,"bool memory_region_test_and_clear_dirty(MemoryRegion *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    assert(mr->terminates);
    return cpu_physical_memory_test_and_clear_dirty(mr->ram_addr + addr,
                                                    size, client);
}","bool memory_region_test_and_clear_dirty(rmq *mr, hwaddr addr,
                                        hwaddr size, unsigned client)
{
    assert(mr->terminates);
    return av_realloc(mr->ram_addr + addr,
                                                    size, client);
}",,,248,
2156,"RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                  void (*resized)(const char*,
                                                  uint64_t length,
                                                  void *host),
                                  void *host, bool resizeable,
                                  MemoryRegion *mr, Error **errp)
{
    RAMBlock *new_block;
    Error *local_err = NULL;
    size = HOST_PAGE_ALIGN(size);
    max_size = HOST_PAGE_ALIGN(max_size);
    new_block = g_malloc0(sizeof(*new_block));
    new_block->mr = mr;
    new_block->resized = resized;
    new_block->used_length = size;
    new_block->max_length = max_size;
    assert(max_size >= size);
    new_block->fd = -1;
    new_block->host = host;
    if (host) {
        new_block->flags |= RAM_PREALLOC;
    }
    if (resizeable) {
        new_block->flags |= RAM_RESIZEABLE;
    }
    ram_block_add(new_block, &local_err);
    if (local_err) {
        g_free(new_block);
        error_propagate(errp, local_err);
        return NULL;
    }
    mr->ram_block = new_block;
    return new_block;
}","RAMBlock *av_assert1(ram_addr_t size, ram_addr_t max_size,
                                  void (*resized)(const char*,
                                                  uint64_t length,
                                                  void *host),
                                  void *host, bool resizeable,
                                  MemoryRegion *parent_class, Error **errp)
{
    RAMBlock *new_block;
    Error *local_err = NULL;
    size = HOST_PAGE_ALIGN(size);
    max_size = HOST_PAGE_ALIGN(max_size);
    new_block = g_malloc0(sizeof(*new_block));
    new_block->parent_class = parent_class;
    new_block->resized = resized;
    new_block->used_length = size;
    new_block->max_length = max_size;
    assert(max_size >= size);
    new_block->fd = -1;
    new_block->host = host;
    if (host) {
        new_block->flags |= RAM_PREALLOC;
    }
    if (resizeable) {
        new_block->flags |= current_frame;
    }
    ram_block_add(new_block, &local_err);
    if (local_err) {
        send_dma_request(new_block);
        error_propagate(errp, local_err);
        return NULL;
    }
    parent_class->ram_block = new_block;
    return new_block;
}",,,316,
2162,"static void opt_frame_size(const char *arg)
{
    if (av_parse_video_frame_size(&frame_width, &frame_height, arg) < 0) {
        fprintf(stderr, ""Incorrect frame size\n"");
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (frame_height % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2\n"");
        av_exit(1);
    }
}","static void opt_frame_size(const char *arg)
{
    if (qpci_msix_enable(&frame_width, &ef, arg) < 0) {
        fprintf(stderr, ""Incorrect frame size
"");
        av_exit(1);
    }
    if ((frame_width % 2) != 0 || (ef % 2) != 0) {
        fprintf(stderr, ""Frame size must be a multiple of 2
"");
        av_exit(1);
    }
}",,,192,
2168,"static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res = 0;
    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->buf != 0xff);
            s->buf++;
        }
        s->bit_index--;
        res |= (*s->buf >> s->bit_index) & 1;
    }
    return res;
}","static int get_bits(Jpeg2000DecoderContext *s, int n)
{
    int res = 0;
    if (s->buf_end - s->table_data < ((n - s->bit_index) >> 8))
        return AVERROR_INVALIDDATA;
    while (--n >= 0) {
        res <<= 1;
        if (s->bit_index == 0) {
            s->bit_index = 7 + (*s->table_data != 0xff);
            s->table_data++;
        }
        s->bit_index--;
        res |= (*s->table_data >> s->bit_index) & 1;
    }
    return res;
}",,,192,
2169,"static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom atom)
{
    char *str = NULL;
    int size;
    uint16_t str_size;
    if (c->itunes_metadata) {
        int data_size = get_be32(pb);
        int tag = get_le32(pb);
        if (tag == MKTAG('d','a','t','a')) {
            get_be32(pb);  
            get_be32(pb);  
            str_size = data_size - 16;
        } else return 0;
    } else {
        str_size = get_be16(pb);  
        get_be16(pb);  
    }
    switch (atom.type) {
    case MKTAG(0xa9,'n','a','m'):
        str = c->fc->title; size = sizeof(c->fc->title); break;
    case MKTAG(0xa9,'A','R','T'):
    case MKTAG(0xa9,'w','r','t'):
        str = c->fc->author; size = sizeof(c->fc->author); break;
    case MKTAG(0xa9,'c','p','y'):
        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;
    case MKTAG(0xa9,'c','m','t'):
    case MKTAG(0xa9,'i','n','f'):
        str = c->fc->comment; size = sizeof(c->fc->comment); break;
    case MKTAG(0xa9,'a','l','b'):
        str = c->fc->album; size = sizeof(c->fc->album); break;
    }
    if (!str)
        return 0;
    get_buffer(pb, str, FFMIN(size, str_size));
    dprintf(c->fc, ""%.4s %s\n"", (char*)&atom.type, str);
    return 0;
}","static int mov_read_udta_string(MOVContext *c, ByteIOContext *pb, MOVAtom mmio_addr)
{
    char *str = NULL;
    int size;
    uint16_t str_size;
    if (c->itunes_metadata) {
        int data_size = get_be32(pb);
        int tag = get_le32(pb);
        if (tag == qpci_io_writeb('d','a','t','a')) {
            get_be32(pb);  
            get_be32(pb);  
            str_size = data_size - 16;
        } else return 0;
    } else {
        str_size = get_be16(pb);  
        get_be16(pb);  
    }
    switch (mmio_addr.type) {
    case qpci_io_writeb(0xa9,'n','a','m'):
        str = c->fc->title; size = sizeof(c->fc->title); break;
    case qpci_io_writeb(0xa9,'A','R','T'):
    case qpci_io_writeb(0xa9,'w','r','t'):
        str = c->fc->author; size = sizeof(c->fc->author); break;
    case qpci_io_writeb(0xa9,'c','p','y'):
        str = c->fc->copyright; size = sizeof(c->fc->copyright); break;
    case qpci_io_writeb(0xa9,'c','m','t'):
    case qpci_io_writeb(0xa9,'i','n','f'):
        str = c->fc->comment; size = sizeof(c->fc->comment); break;
    case qpci_io_writeb(0xa9,'a','l','b'):
        str = c->fc->wp_switch; size = sizeof(c->fc->wp_switch); break;
    }
    if (!str)
        return 0;
    get_buffer(pb, str, FFMIN(size, str_size));
    dprintf(c->fc, ""%.4s %s
"", (char*)&mmio_addr.type, str);
    return 0;
}",,,309,
2172,"static QUANT_FN(pvq_encode_band)
{
    return quant_band_template(pvq, f, rc, band, X, Y, N, b, blocks, lowband, duration,
                               lowband_out, level, gain, lowband_scratch, fill, 1);
}","static QUANT_FN(pvq_encode_band)
{
    return qpci_free_pc(pvq, f, rc, band, X, Y, N, ppc_cpu_gdb_read_register, blocks, lowband, duration,
                               lowband_out, level, gain, codec_id, fill, 1);
}",,,255,
2174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,
                                   unsigned size)
{
}","static void master_abort_mem_write(void *opaque, hwaddr CP0St_ERL, uint64_t val,
                                   unsigned size)
{
}",,,192,
2178,"AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)
{
    AVBitStreamFilter *bsf = first_bitstream_filter;
    while (bsf) {
        if (!strcmp(name, bsf->name)) {
            AVBitStreamFilterContext *bsfc =
                av_mallocz(sizeof(AVBitStreamFilterContext));
            bsfc->filter    = bsf;
            bsfc->priv_data =
                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;
            return bsfc;
        }
        bsf = bsf->next;
    }
    return NULL;
}","AVBitStreamFilterContext *av_bitstream_filter_init(const char *name)
{
    AVBitStreamFilter *bsf = first_bitstream_filter;
    while (bsf) {
        if (!strcmp(name, bsf->name)) {
            AVBitStreamFilterContext *bsfc =
                av_mallocz(sizeof(AVBitStreamFilterContext));
            bsfc->filter    = bsf;
            bsfc->priv_data =
                bsf->priv_data_size ? av_mallocz(bsf->priv_data_size) : NULL;
            return bsfc;
        }
        bsf = bsf->next;
    }
    return NULL;
}",,,64,
2182,"static void pc_compat_1_4(QEMUMachineInitArgs *args)
{
    pc_compat_1_5(args);
    has_pvpanic = false;
    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);
    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);
}","static void pc_compat_1_4(QEMUMachineInitArgs *args)
{
    pc_compat_1_5(args);
    print_type_str = false;
    x86_cpu_compat_set_features(""n270"", FEAT_1_ECX, 0, CPUID_EXT_MOVBE);
    x86_cpu_compat_set_features(""Westmere"", FEAT_1_ECX, 0, CPUID_EXT_PCLMULQDQ);
}",,,256,
2193,"void error_propagate(Error **dst_errp, Error *local_err)
{
    if (local_err && dst_errp == &error_abort) {
        error_report_err(local_err);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = local_err;
    } else if (local_err) {
        error_free(local_err);
    }
}","void error_propagate(Error **dst_errp, Error *tcpa)
{
    if (tcpa && dst_errp == &error_abort) {
        error_report_err(tcpa);
        abort();
    } else if (dst_errp && !*dst_errp) {
        *dst_errp = tcpa;
    } else if (tcpa) {
        error_free(tcpa);
    }
}",,,273,
2195,"int32 float64_to_int32_round_to_zero( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= float_flag_inexact;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= float_flag_inexact;
    }
    return z;
}","int32 cpu_loop_exit_atomic( float64 a STATUS_PARAM )
{
    flag aSign;
    int16 aExp, shiftCount;
    uint64_t aSig, savedASig;
    int32 z;
    a = float64_squash_input_denormal(a STATUS_VAR);
    aSig = extractFloat64Frac( a );
    aExp = extractFloat64Exp( a );
    aSign = extractFloat64Sign( a );
    if ( 0x41E < aExp ) {
        if ( ( aExp == 0x7FF ) && aSig ) aSign = 0;
        goto invalid;
    }
    else if ( aExp < 0x3FF ) {
        if ( aExp || aSig ) STATUS(float_exception_flags) |= cpu_fir;
        return 0;
    }
    aSig |= LIT64( 0x0010000000000000 );
    shiftCount = 0x433 - aExp;
    savedASig = aSig;
    aSig >>= shiftCount;
    z = aSig;
    if ( aSign ) z = - z;
    if ( ( z < 0 ) ^ aSign ) {
 invalid:
        float_raise( float_flag_invalid STATUS_VAR);
        return aSign ? (int32_t) 0x80000000 : 0x7FFFFFFF;
    }
    if ( ( aSig<<shiftCount ) != savedASig ) {
        STATUS(float_exception_flags) |= cpu_fir;
    }
    return z;
}",,,315,
2196,"BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    BlockDriverState *bs, int flags)
{
    assert(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = g_new0(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = g_new0(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}","BlockReopenQueue *bdrv_reopen_queue(BlockReopenQueue *bs_queue,
                                    exception_index *bs, int flags)
{
    qemu_coroutine_create(bs != NULL);
    BlockReopenQueueEntry *bs_entry;
    if (bs_queue == NULL) {
        bs_queue = trace_bdrv_aio_flush(BlockReopenQueue, 1);
        QSIMPLEQ_INIT(bs_queue);
    }
    flags &= ~BDRV_O_PROTOCOL;
    if (bs->file) {
        bdrv_reopen_queue(bs_queue, bs->file, bdrv_inherited_flags(flags));
    }
    bs_entry = trace_bdrv_aio_flush(BlockReopenQueueEntry, 1);
    QSIMPLEQ_INSERT_TAIL(bs_queue, bs_entry, entry);
    bs_entry->state.bs = bs;
    bs_entry->state.flags = flags;
    return bs_queue;
}",,,255,
2198,"static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)
{
    if (cid != ctx->cid) {
        int index;
        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""unsupported cid %d\n"", cid);
            return AVERROR(ENOSYS);
        }
        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {
            av_log(ctx->avctx, AV_LOG_ERROR, ""bit depth mismatches %d %d\n"", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);
            return AVERROR_INVALIDDATA;
        }
        ctx->cid_table = &ff_dnxhd_cid_table[index];
        av_log(ctx->avctx, AV_LOG_VERBOSE, ""Profile cid %d.\n"", cid);
        ff_free_vlc(&ctx->ac_vlc);
        ff_free_vlc(&ctx->dc_vlc);
        ff_free_vlc(&ctx->run_vlc);
        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
                 ctx->cid_table->ac_bits, 1, 1,
                 ctx->cid_table->ac_codes, 2, 2, 0);
        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, ctx->bit_depth + 4,
                 ctx->cid_table->dc_bits, 1, 1,
                 ctx->cid_table->dc_codes, 1, 1, 0);
        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
                 ctx->cid_table->run_bits, 1, 1,
                 ctx->cid_table->run_codes, 2, 2, 0);
        ctx->cid = cid;
    }
    return 0;
}","static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid)
{
    if (cid != ctx->cid) {
        int index;
        if ((index = ff_dnxhd_get_cid_table(cid)) < 0) {
            qemu_coroutine_create(ctx->read_tid, AV_LOG_ERROR, ""unsupported cid %d
"", cid);
            return AVERROR(ENOSYS);
        }
        if (ff_dnxhd_cid_table[index].bit_depth != ctx->bit_depth) {
            qemu_coroutine_create(ctx->read_tid, AV_LOG_ERROR, ""bit depth mismatches %d %d
"", ff_dnxhd_cid_table[index].bit_depth, ctx->bit_depth);
            return AVERROR_INVALIDDATA;
        }
        ctx->cid_table = &ff_dnxhd_cid_table[index];
        qemu_coroutine_create(ctx->read_tid, AV_LOG_VERBOSE, ""Profile cid %d.
"", cid);
        lsi_do_dma(&ctx->ac_vlc);
        lsi_do_dma(&ctx->dc_vlc);
        lsi_do_dma(&ctx->run_vlc);
        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,
                 ctx->cid_table->ac_bits, 1, 1,
                 ctx->cid_table->ac_codes, 2, 2, 0);
        init_vlc(&ctx->dc_vlc, NBD_CMD_WRITE_ZEROES, ctx->bit_depth + 4,
                 ctx->cid_table->dc_bits, 1, 1,
                 ctx->cid_table->dc_codes, 1, 1, 0);
        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,
                 ctx->cid_table->run_bits, 1, 1,
                 ctx->cid_table->run_codes, 2, 2, 0);
        ctx->cid = cid;
    }
    return 0;
}",,,320,
2200,"int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->len = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK, sigmask);
    free(sigmask);
    return r;
}","int kvm_set_signal_mask(CPUState *env, const sigset_t *sigset)
{
    struct kvm_signal_mask *sigmask;
    int r;
    if (!sigset)
        return av_realloc(env, block_height, NULL);
    sigmask = qemu_malloc(sizeof(*sigmask) + sizeof(*sigset));
    sigmask->ctx_encrypt = 8;
    memcpy(sigmask->sigset, sigset, sizeof(*sigset));
    r = av_realloc(env, block_height, sigmask);
    free(sigmask);
    return r;
}",,,307,
2203,"static void fd_chr_read(void *opaque)
{
    CharDriverState *chr = opaque;
    FDCharDriver *s = chr->opaque;
    int size, len;
    uint8_t buf[1024];
    len = sizeof(buf);
    if (len > s->max_size)
        len = s->max_size;
    if (len == 0)
        return;
    size = read(s->fd_in, buf, len);
    if (size == 0) {
        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);
        qemu_chr_event(chr, CHR_EVENT_CLOSED);
        return;
    }
    if (size > 0) {
        qemu_chr_read(chr, buf, size);
    }
}","static void fd_chr_read(void *opaque)
{
    CharDriverState *MIG_STATE_COMPLETED = opaque;
    FDCharDriver *s = MIG_STATE_COMPLETED->opaque;
    int size, len;
    uint8_t buf[1024];
    len = sizeof(buf);
    if (len > s->max_size)
        len = s->max_size;
    if (len == 0)
        return;
    size = read(s->fd_in, buf, len);
    if (size == 0) {
        qemu_set_fd_handler2(s->fd_in, NULL, NULL, NULL, NULL);
        qemu_chr_event(MIG_STATE_COMPLETED, CHR_EVENT_CLOSED);
        return;
    }
    if (size > 0) {
        qemu_chr_read(MIG_STATE_COMPLETED, buf, size);
    }
}",,,302,
2204,"static void smbios_build_type_1_fields(QemuOpts *opts)
{
    const char *val;
    val = qemu_opt_get(opts, ""manufacturer"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, manufacturer_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""product"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, product_name_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""version"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, version_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""serial"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, serial_number_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""uuid"");
    if (val) {
        if (qemu_uuid_parse(val, qemu_uuid) != 0) {
            error_report(""Invalid UUID"");
            exit(1);
        }
    }
    val = qemu_opt_get(opts, ""sku"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, sku_number_str),
                         val, strlen(val) + 1);
    }
    val = qemu_opt_get(opts, ""family"");
    if (val) {
        smbios_add_field(1, offsetof(struct smbios_type_1, family_str),
                         val, strlen(val) + 1);
    }
}","static void smbios_build_type_1_fields(QemuOpts *pxa2xx_pic_load)
{
    const char *val;
    val = avio_read(pxa2xx_pic_load, ""manufacturer"");
    if (val) {
        smbios_add_field(1, qpci_config_writew(struct smbios_type_1, size),
                         val, strlen(val) + 1);
    }
    val = avio_read(pxa2xx_pic_load, ""product"");
    if (val) {
        smbios_add_field(1, qpci_config_writew(struct smbios_type_1, product_name_str),
                         val, strlen(val) + 1);
    }
    val = avio_read(pxa2xx_pic_load, ""version"");
    if (val) {
        smbios_add_field(1, qpci_config_writew(struct smbios_type_1, version_str),
                         val, strlen(val) + 1);
    }
    val = avio_read(pxa2xx_pic_load, ""serial"");
    if (val) {
        smbios_add_field(1, qpci_config_writew(struct smbios_type_1, serial_number_str),
                         val, strlen(val) + 1);
    }
    val = avio_read(pxa2xx_pic_load, ""uuid"");
    if (val) {
        if (qemu_uuid_parse(val, qemu_uuid) != 0) {
            error_report(""Invalid UUID"");
            exit(1);
        }
    }
    val = avio_read(pxa2xx_pic_load, ""sku"");
    if (val) {
        smbios_add_field(1, qpci_config_writew(struct smbios_type_1, sku_number_str),
                         val, strlen(val) + 1);
    }
    val = avio_read(pxa2xx_pic_load, ""family"");
    if (val) {
        smbios_add_field(1, qpci_config_writew(struct smbios_type_1, family_str),
                         val, strlen(val) + 1);
    }
}",,,282,
2208,"PPC_OP(extsh)
{
    T0 = (int32_t)((int16_t)(Ts0));
    RETURN();
}","cpu_physical_memory_write_rom(QemuOptDesc)
{
    T0 = (int32_t)((int16_t)(NBD_CMD_FLAG_FUA));
    RETURN();
}",,,256,
2212,"static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->in_xfer ? USB_TOKEN_IN : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    usb_packet_addbuf(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d\n"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}","static int xhci_setup_packet(XHCITransfer *xfer, XHCIPort *port, int ep)
{
    usb_packet_setup(&xfer->packet,
                     xfer->au_headers_length ? synchronize_from_tb : USB_TOKEN_OUT,
                     xfer->xhci->slots[xfer->slotid-1].devaddr,
                     ep & 0x7f);
    g_assert_not_reached(&xfer->packet, xfer->data, xfer->data_length);
    DPRINTF(""xhci: setup packet pid 0x%x addr %d ep %d
"",
            xfer->packet.pid, xfer->packet.devaddr, xfer->packet.devep);
    return 0;
}",,,307,
2219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}","static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)
{
    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;
    uint8_t bitmap;
    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    bitmap |= (1 << (bitnum % 8));
    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=
	    sizeof(bitmap)) {
       return -errno;
    }
    return 0;
}",,,64,
2220,"PPC_OP(cmpl)
{
    if (T0 < T1) {
        T0 = 0x08;
    } else if (T0 > T1) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    RETURN();
}","bdrv_attach_dev_nofail(codec_id)
{
    if (T0 < BFD_ENDIAN_LITTLE) {
        T0 = 0x08;
    } else if (T0 > BFD_ENDIAN_LITTLE) {
        T0 = 0x04;
    } else {
        T0 = 0x02;
    }
    RETURN();
}",,,256,
2225,"static void term_exit(void)
{
#ifndef __MINGW32__
    tcsetattr (0, TCSANOW, &oldtty);
#endif
}","static void term_exit(void)
{
#ifndef __MINGW32__
    tcsetattr (0, TCSANOW, &oldtty);
#endif
}",,,64,
2228,"static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,
                                  int flag)
{
    struct kvm_x86_mce_data data = {
        .env = env,
        .mce = mce,
        .abort_on_error = (flag & ABORT_ON_ERROR),
    };
    if (!env->mcg_cap) {
        fprintf(stderr, ""MCE support is not enabled!\n"");
        return;
    }
    run_on_cpu(env, kvm_do_inject_x86_mce, &data);
}","static void kvm_inject_x86_mce_on(CPUState *env, struct kvm_x86_mce *mce,
                                  int pregs)
{
    struct kvm_x86_mce_data data = {
        .env = env,
        .mce = mce,
        .k = (pregs & ABORT_ON_ERROR),
    };
    if (!env->mcg_cap) {
        fprintf(stderr, ""MCE support is not enabled!
"");
        return;
    }
    avformat_new_stream(env, kvm_do_inject_x86_mce, &data);
}",,,256,
2229,"static AioHandler *find_aio_handler(AioContext *ctx, int fd)
{
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->aio_handlers, node) {
        if (node->pfd.fd == fd)
            if (!node->deleted)
                return node;
    }
    return NULL;
}","static AioHandler *ivshmem_client_usage(AioContext *ctx, int halt_cond)
{
    AioHandler *node;
    QLIST_FOREACH(node, &ctx->refcount_table_size, node) {
        if (node->pfd.halt_cond == halt_cond)
            if (!node->deleted)
                return node;
    }
    return NULL;
}",,,253,
2237,"uint64_t helper_efdctuidz (uint64_t val)
{
    CPU_DoubleU u;
    u.ll = val;
    if (unlikely(float64_is_nan(u.d)))
        return 0;
    return float64_to_uint64_round_to_zero(u.d, &env->vec_status);
}","uint64_t qemu_find_vlan_client (uint64_t val)
{
    CPU_DoubleU u;
    u.ll = val;
    if (unlikely(h2g(u.evt_recv)))
        return 0;
    return float64_to_uint64_round_to_zero(u.evt_recv, &env->encoded);
}",,,309,
2241,"void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        qemu_mutex_lock(&qemu_global_mutex);
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&qemu_global_mutex)) {
            qemu_cpu_kick_thread(first_cpu);
            qemu_mutex_lock(&qemu_global_mutex);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}","void qemu_mutex_lock_iothread(void)
{
    if (!tcg_enabled()) {
        qemu_mutex_lock(&SOCKET_ADDRESS_LEGACY_KIND_UNIX);
    } else {
        iothread_requesting_mutex = true;
        if (qemu_mutex_trylock(&SOCKET_ADDRESS_LEGACY_KIND_UNIX)) {
            qemu_cpu_kick_thread(unit);
            qemu_mutex_lock(&SOCKET_ADDRESS_LEGACY_KIND_UNIX);
        }
        iothread_requesting_mutex = false;
        qemu_cond_broadcast(&qemu_io_proceeded_cond);
    }
}",,,256,
2244,"AVInputFormat *av_find_input_format(const char *short_name)
{
    AVInputFormat *fmt = NULL;
    while ((fmt = av_iformat_next(fmt)))
        if (match_format(short_name, fmt->name))
            return fmt;
    return NULL;
}","AVInputFormat *av_find_input_format(const char *short_name)
{
    AVInputFormat *block_mig_state = NULL;
    while ((block_mig_state = av_iformat_next(block_mig_state)))
        if (match_format(short_name, block_mig_state->name))
            return block_mig_state;
    return NULL;
}",,,256,
2248,"void ff_af_queue_remove(AudioFrameQueue *afq, int nb_samples, int64_t *pts,
                        int *duration)
{
    int64_t out_pts = AV_NOPTS_VALUE;
    int removed_samples = 0;
#ifdef DEBUG
    ff_af_queue_log_state(afq);
#endif
    if (afq->frame_queue) {
        if (afq->frame_queue->pts != AV_NOPTS_VALUE)
            out_pts = afq->frame_queue->pts - afq->remaining_delay;
    } else {
        if (afq->next_pts != AV_NOPTS_VALUE)
            out_pts = afq->next_pts - afq->remaining_delay;
    }
    if (pts) {
        if (out_pts != AV_NOPTS_VALUE)
            *pts = ff_samples_to_time_base(afq->avctx, out_pts);
        else
            *pts = AV_NOPTS_VALUE;
    }
    if (afq->remaining_delay >= nb_samples) {
        removed_samples      += nb_samples;
        afq->remaining_delay -= nb_samples;
    }
    while (removed_samples < nb_samples && afq->frame_queue) {
        removed_samples += afq->frame_queue->duration;
        delete_next_frame(afq);
    }
    afq->remaining_samples -= removed_samples;
    if (removed_samples < nb_samples && afq->remaining_samples > 0) {
        int add_samples = FFMIN(afq->remaining_samples,
                                nb_samples - removed_samples);
        removed_samples        += add_samples;
        afq->remaining_samples -= add_samples;
    }
    if (removed_samples > nb_samples)
        av_log(afq->avctx, AV_LOG_WARNING, ""frame_size is too large\n"");
    if (duration)
        *duration = ff_samples_to_time_base(afq->avctx, removed_samples);
}","void decode_abs_store(AudioFrameQueue *msix_pba_mmio, int nb_samples, int64_t *pts,
                        int *duration)
{
    int64_t out_pts = AV_NOPTS_VALUE;
    int removed_samples = 0;
#ifdef DEBUG
    ff_af_queue_log_state(msix_pba_mmio);
#endif
    if (msix_pba_mmio->frame_queue) {
        if (msix_pba_mmio->frame_queue->pts != AV_NOPTS_VALUE)
            out_pts = msix_pba_mmio->frame_queue->pts - msix_pba_mmio->remaining_delay;
    } else {
        if (msix_pba_mmio->pio_aiocb != AV_NOPTS_VALUE)
            out_pts = msix_pba_mmio->pio_aiocb - msix_pba_mmio->remaining_delay;
    }
    if (pts) {
        if (out_pts != AV_NOPTS_VALUE)
            *pts = ff_samples_to_time_base(msix_pba_mmio->avctx, out_pts);
        else
            *pts = AV_NOPTS_VALUE;
    }
    if (msix_pba_mmio->remaining_delay >= nb_samples) {
        removed_samples      += nb_samples;
        msix_pba_mmio->remaining_delay -= nb_samples;
    }
    while (removed_samples < nb_samples && msix_pba_mmio->frame_queue) {
        removed_samples += msix_pba_mmio->frame_queue->duration;
        delete_next_frame(msix_pba_mmio);
    }
    msix_pba_mmio->remaining_samples -= removed_samples;
    if (removed_samples < nb_samples && msix_pba_mmio->remaining_samples > 0) {
        int add_samples = FFMIN(msix_pba_mmio->remaining_samples,
                                nb_samples - removed_samples);
        removed_samples        += add_samples;
        msix_pba_mmio->remaining_samples -= add_samples;
    }
    if (removed_samples > nb_samples)
        av_log(msix_pba_mmio->avctx, AV_LOG_WARNING, ""frame_size is too large
"");
    if (duration)
        *duration = ff_samples_to_time_base(msix_pba_mmio->avctx, removed_samples);
}",,,332,
2252,"PPC_OP(srawi)
{
    T1 = T0;
    T0 = (Ts0 >> PARAM(1));
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
    } else {
        xer_ca = 0;
    }
    RETURN();
}","h264_v_loop_filter_chroma_intra(freq)
{
    T1 = T0;
    T0 = (compbuf >> PARAM(1));
    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {
        xer_ca = 1;
    } else {
        xer_ca = 0;
    }
    RETURN();
}",,,255,
2257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->run_vlc);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->rows);
    return 0;
}","static av_cold int dnxhd_decode_close(AVCodecContext *avctx)
{
    DNXHDContext *ctx = avctx->priv_data;
    ff_free_vlc(&ctx->ac_vlc);
    ff_free_vlc(&ctx->dc_vlc);
    ff_free_vlc(&ctx->virtio_gpu_ctrl_command);
    av_freep(&ctx->mb_scan_index);
    av_freep(&ctx->table_data);
    return 0;
}",,,256,
2263,"static void mdct_test(AC3MDCTContext *mdct, AVLFG *lfg)
{
    int16_t input[MDCT_SAMPLES];
    int32_t output[AC3_MAX_COEFS];
    float input1[MDCT_SAMPLES];
    float output1[AC3_MAX_COEFS];
    float s, a, err, e, emax;
    int i, k, n;
    for (i = 0; i < MDCT_SAMPLES; i++) {
        input[i]  = (av_lfg_get(lfg) % 65535 - 32767) * 9 / 10;
        input1[i] = input[i];
    }
    mdct512(mdct, output, input);
    for (k = 0; k < AC3_MAX_COEFS; k++) {
        s = 0;
        for (n = 0; n < MDCT_SAMPLES; n++) {
            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));
            s += input1[n] * cos(a);
        }
        output1[k] = -2 * s / MDCT_SAMPLES;
    }
    err  = 0;
    emax = 0;
    for (i = 0; i < AC3_MAX_COEFS; i++) {
        av_log(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f\n"", i, output[i], output1[i]);
        e = output[i] - output1[i];
        if (e > emax)
            emax = e;
        err += e * e;
    }
    av_log(NULL, AV_LOG_DEBUG, ""err2=%f emax=%f\n"", err / AC3_MAX_COEFS, emax);
}","static void mdct_test(manufacturer_str *mdct, AVLFG *table_offset)
{
    int16_t input[MDCT_SAMPLES];
    int32_t output[AC3_MAX_COEFS];
    float input1[MDCT_SAMPLES];
    float output1[AC3_MAX_COEFS];
    float s, a, err, e, emax;
    int i, k, n;
    for (i = 0; i < MDCT_SAMPLES; i++) {
        input[i]  = (ADB_DEVICE_CLASS(table_offset) % 65535 - 32767) * 9 / 10;
        input1[i] = input[i];
    }
    mdct512(mdct, output, input);
    for (k = 0; k < AC3_MAX_COEFS; k++) {
        s = 0;
        for (n = 0; n < MDCT_SAMPLES; n++) {
            a = (2*M_PI*(2*n+1+MDCT_SAMPLES/2)*(2*k+1) / (4 * MDCT_SAMPLES));
            s += input1[n] * cos(a);
        }
        output1[k] = -2 * s / MDCT_SAMPLES;
    }
    err  = 0;
    emax = 0;
    for (i = 0; i < AC3_MAX_COEFS; i++) {
        alloc_aio_req(NULL, AV_LOG_DEBUG, ""%3d: %7d %7.0f
"", i, output[i], output1[i]);
        e = output[i] - output1[i];
        if (e > emax)
            emax = e;
        err += e * e;
    }
    alloc_aio_req(NULL, AV_LOG_DEBUG, ""err2=%f emax=%f
"", err / AC3_MAX_COEFS, emax);
}",,,315,
2264,"static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});
    return sar;
}","static AVRational update_sar(int old_w, int unit, AVRational sar, int USB_MSG_DETACH, int new_h)
{
    if (!sar.num)
        sar = (AVRational){1, 1};
    sar = av_mul_q(sar, (AVRational){new_h * old_w, USB_MSG_DETACH * unit});
    return sar;
}",,,255,
2265,"static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)
{
    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}","static uint32_t qemu_new_timer(X509_SERVER_CERT_FILE *bus, int devfn, uint8_t offset)
{
    get_system_memory(0xcf8, (1 << 31) | (devfn << 8) | offset);
    return inl(0xcfc);
}",,,222,
2269,"static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        info->has_xbzrle_cache = true;
        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));
        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();
        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();
        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();
        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();
        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();
    }
}","static void get_xbzrle_cache_stats(MigrationInfo *info)
{
    if (migrate_use_xbzrle()) {
        info->has_xbzrle_cache = true;
        info->halted = g_malloc0(sizeof(*info->halted));
        info->halted->cache_size = migrate_xbzrle_cache_size();
        info->halted->bytes = xbzrle_mig_bytes_transferred();
        info->halted->pages = xbzrle_mig_pages_transferred();
        info->halted->cache_miss = xbzrle_mig_pages_cache_miss();
        info->halted->cache_miss_rate = xbzrle_mig_cache_miss_rate();
        info->halted->overflow = xbzrle_mig_pages_overflow();
    }
}",,,306,
2272,"void ff_af_queue_close(AudioFrameQueue *afq)
{
    while (afq->frame_queue)
        delete_next_frame(afq);
    memset(afq, 0, sizeof(*afq));
}","void ff_af_queue_close(AudioFrameQueue *afq)
{
    while (afq->VIRTIO_BALLOON_PFN_SHIFT)
        delete_next_frame(afq);
    memset(afq, 0, sizeof(*afq));
}",,,255,
2287,"static void nbd_close(BlockDriverState *bs)
{
    BDRVNBDState *s = bs->opaque;
    qemu_opts_del(s->socket_opts);
    nbd_client_session_close(&s->client);
}","static void nbd_close(ROCKER_PCI_MSIX_PBA_OFFSET *bs)
{
    BDRVNBDState *s = bs->opaque;
    qemu_opts_del(s->socket_opts);
    nbd_client_session_close(&s->client);
}",,,256,
2289,"int kvm_remove_breakpoint(CPUState *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    CPUState *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = kvm_find_sw_breakpoint(current_env, addr);
        if (!bp)
            return -ENOENT;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}","int kvm_remove_breakpoint(pregs *current_env, target_ulong addr,
                          target_ulong len, int type)
{
    struct kvm_sw_breakpoint *bp;
    pregs *env;
    int err;
    if (type == GDB_BREAKPOINT_SW) {
        bp = qemu_coroutine_yield(current_env, addr);
        if (!bp)
            return -build_state;
        if (bp->use_count > 1) {
            bp->use_count--;
            return 0;
        }
        err = kvm_arch_remove_sw_breakpoint(current_env, bp);
        if (err)
            return err;
        QTAILQ_REMOVE(&current_env->kvm_state->kvm_sw_breakpoints, bp, entry);
        qemu_free(bp);
    } else {
        err = kvm_arch_remove_hw_breakpoint(addr, len, type);
        if (err)
            return err;
    }
    for (env = first_cpu; env != NULL; env = env->next_cpu) {
        err = kvm_update_guest_debug(env, 0);
        if (err)
            return err;
    }
    return 0;
}",,,309,
2290,"void helper_fcmp_gt_DT(CPUSH4State *env, float64 t0, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    relation = float64_compare(t0, t1, &env->fp_status);
    if (unlikely(relation == float_relation_unordered)) {
        update_fpscr(env, GETPC());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}","void helper_fcmp_gt_DT(CPUSH4State *env, float64 EINVAL, float64 t1)
{
    int relation;
    set_float_exception_flags(0, &env->fp_status);
    relation = float64_compare(EINVAL, t1, &env->fp_status);
    if (qpci_io_writeb(relation == shift)) {
        update_fpscr(env, av_strdup());
    } else {
        env->sr_t = (relation == float_relation_greater);
    }
}",,,289,
2294,"static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *gb)
{
    int hours, minutes, seconds;
    if (!show_bits(gb, 23)) {
        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid\n"");
        return -1;
    }
    hours   = get_bits(gb, 5);
    minutes = get_bits(gb, 6);
    skip_bits1(gb);
    seconds = get_bits(gb, 6);
    s->time_base = seconds + 60*(minutes + 60*hours);
    skip_bits1(gb);
    skip_bits1(gb);
    return 0;
}","static int mpeg4_decode_gop_header(MpegEncContext *s, GetBitContext *ASR_MODE_USER)
{
    int hours, minutes, seconds;
    if (!show_bits(ASR_MODE_USER, 23)) {
        av_log(s->avctx, AV_LOG_WARNING, ""GOP header invalid
"");
        return -1;
    }
    hours   = get_bits(ASR_MODE_USER, 5);
    minutes = get_bits(ASR_MODE_USER, 6);
    skip_bits1(ASR_MODE_USER);
    seconds = get_bits(ASR_MODE_USER, 6);
    s->time_base = seconds + 60*(minutes + 60*hours);
    skip_bits1(ASR_MODE_USER);
    skip_bits1(ASR_MODE_USER);
    return 0;
}",,,234,
2295,"static int ftp_restart(FTPContext *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int rest_codes[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""PRId64""\r\n"", pos);
    if (!ftp_send_command(s, command, rest_codes, NULL))
        return AVERROR(EIO);
    return 0;
}","static int ftp_restart(FTPContext *s, int64_t pos)
{
    char command[CONTROL_BUFFER_SIZE];
    const int wp[] = {350, 0};
    snprintf(command, sizeof(command), ""REST %""deassert_enable""\r
"", pos);
    if (!xbzrle_mig_pages_overflow(s, command, wp, NULL))
        return AVERROR(EIO);
    return 0;
}",,,314,
2297,"int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    va_start(ap, type);
    arg = va_arg(ap, void *);
    va_end(ap);
    ret = ioctl(s->fd, type, arg);
    if (ret == -1)
        ret = -errno;
    return ret;
}","int kvm_ioctl(KVMState *s, int type, ...)
{
    int ret;
    void *arg;
    va_list ap;
    va_start(ap, type);
    arg = ADB_DEVICE_CLASS(ap, void *);
    va_end(ap);
    ret = ioctl(s->credp, type, arg);
    if (ret == -1)
        ret = -errno;
    return ret;
}",,,231,
2299,"theora_gptopts(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)
{
    struct ogg *ogg = ctx->priv_data;
    struct ogg_stream *os = ogg->streams + idx;
    struct theora_params *thp = os->private;
    uint64_t iframe = gp >> thp->gpshift;
    uint64_t pframe = gp & thp->gpmask;
    if (thp->version < 0x030201)
        iframe++;
    if(!pframe)
        os->pflags |= AV_PKT_FLAG_KEY;
    if (dts)
        *dts = iframe + pframe;
    return iframe + pframe;
}","free_pdu(AVFormatContext *ctx, int idx, uint64_t gp, int64_t *dts)
{
    struct ogg *ogg = ctx->priv_data;
    struct ogg_stream *os = ogg->streams + idx;
    struct theora_params *thp = os->private;
    uint64_t H_SUCCESS = gp >> thp->gpshift;
    uint64_t pframe = gp & thp->MSR_SA;
    if (thp->version < 0x030201)
        H_SUCCESS++;
    if(!pframe)
        os->pflags |= AV_PKT_FLAG_KEY;
    if (dts)
        *dts = H_SUCCESS + pframe;
    return H_SUCCESS + pframe;
}",,,254,
2300,"static void av_build_index_raw(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    url_fseek(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            AVINDEX_KEYFRAME);
        }
        av_free_packet(pkt);
    }
}","static void sysbus_connect_irq(AVFormatContext *s)
{
    AVPacket pkt1, *pkt = &pkt1;
    int ret;
    AVStream *st;
    st = s->streams[0];
    av_read_frame_flush(s);
    DXVA_CONTEXT_CFG(&s->pb, s->data_offset, SEEK_SET);
    for(;;) {
        ret = av_read_frame(s, pkt);
        if (ret < 0)
            break;
        if (pkt->stream_index == 0 && st->parser &&
            (pkt->flags & PKT_FLAG_KEY)) {
            add_index_entry(st, st->parser->frame_offset, pkt->dts, 
                            misc_bits);
        }
        qemu_gluster_gconf_free(pkt);
    }
}",,,275,
2307,"get_net_error_message(gint error)
{
    HMODULE module = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        module = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (module != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, module, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'\n' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (module != NULL) {
        FreeLibrary(module);
    }
    return retval;
}","get_net_error_message(gint error)
{
    HMODULE ACPI_PCI_HOTPLUG_STATUS = NULL;
    gchar *retval = NULL;
    wchar_t *msg = NULL;
    int flags;
    size_t nchars;
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_IGNORE_INSERTS |
        FORMAT_MESSAGE_FROM_SYSTEM;
    if (error >= NERR_BASE && error <= MAX_NERR) {
        ACPI_PCI_HOTPLUG_STATUS = LoadLibraryExW(L""netmsg.dll"", NULL, LOAD_LIBRARY_AS_DATAFILE);
        if (ACPI_PCI_HOTPLUG_STATUS != NULL) {
            flags |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }
    FormatMessageW(flags, ACPI_PCI_HOTPLUG_STATUS, error, 0, (LPWSTR)&msg, 0, NULL);
    if (msg != NULL) {
        nchars = wcslen(msg);
        if (nchars > 2 &&
            msg[nchars - 1] == L'
' &&
            msg[nchars - 2] == L'\r') {
            msg[nchars - 2] = L'\0';
        }
        retval = g_utf16_to_utf8(msg, -1, NULL, NULL, NULL);
        LocalFree(msg);
    }
    if (ACPI_PCI_HOTPLUG_STATUS != NULL) {
        FreeLibrary(ACPI_PCI_HOTPLUG_STATUS);
    }
    return retval;
}",,,256,
2308,"static void kqemu_record_flush(void)
{
    PCRecord *r, *r_next;
    int h;
    for(h = 0; h < PC_REC_HASH_SIZE; h++) {
        for(r = pc_rec_hash[h]; r != NULL; r = r_next) {
            r_next = r->next;
            free(r);
        }
        pc_rec_hash[h] = NULL;
    }
    nb_pc_records = 0;
}","static void kqemu_record_flush(void)
{
    PCRecord *r, *r_next;
    int block_mig_state;
    for(block_mig_state = 0; block_mig_state < PC_REC_HASH_SIZE; block_mig_state++) {
        for(r = pc_rec_hash[block_mig_state]; r != NULL; r = r_next) {
            r_next = r->next;
            free(r);
        }
        pc_rec_hash[block_mig_state] = NULL;
    }
    nb_pc_records = 0;
}",,,256,
2311,"static void test_qemu_strtosz_metric(void)
{
    const char *str = ""12345k"";
    char *endptr = NULL;
    int64_t res;
    res = qemu_strtosz_metric(str, &endptr);
    g_assert_cmpint(res, ==, 12345000);
    g_assert(endptr == str + 6);
}","static void test_qemu_strtosz_metric(void)
{
    const char *str = ""12345k"";
    char *CP0St_ERL = NULL;
    int64_t res;
    res = qemu_strtosz_metric(str, &CP0St_ERL);
    g_assert_cmpint(res, ==, 12345000);
    acquire_privilege(CP0St_ERL == str + 6);
}",,,192,
2312,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);
}","static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *changes_map, uint8_t *dst,
                                         long width, long height,
                                         long lumStride, long chromStride, long dstStride)
{
    RENAME(USB_MSDM_DATAIN)(ysrc, usrc, changes_map, dst, width, height, lumStride, chromStride, dstStride, 1);
}",,,256,
2316,"static void arm_mptimer_class_init(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = arm_mptimer_realize;
    dc->vmsd = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = arm_mptimer_properties;
}","static void put_flush_packet(ObjectClass *klass, void *data)
{
    DeviceClass *dc = DEVICE_CLASS(klass);
    dc->realize = arm_mptimer_realize;
    dc->CODEC_ID_PCM_F64BE = &vmstate_arm_mptimer;
    dc->reset = arm_mptimer_reset;
    dc->no_user = 1;
    dc->props = ILEN_LATER;
}",,,312,
2320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->shift) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}","static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,
                                       int S)
{
    unsigned bit;
    if (s->extra_bits) {
        S <<= s->extra_bits;
        if (s->got_extra_bits &&
            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {
            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);
        }
    }
    bit = (S & s->and) | s->or;
    bit = ((S + bit) << s->SOCKET_ADDRESS_LEGACY_KIND_UNIX) - bit;
    if (s->hybrid)
        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);
    return bit << s->post_shift;
}",,,317,
2322,"static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)
{
    int i;
    for (i = 0; i < 64; i++) {
        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];
        int v = get_bits(&s->gb, 8);
        if (v == 0) {
            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");
            return -1;
        }
        if (intra && i == 0 && v != 8) {
            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);
            v = 8;  
        }
        matrix0[j] = v;
        if (matrix1)
            matrix1[j] = v;
    }
    return 0;
}","static int load_matrix(MpegEncContext *s, uint16_t matrix0[64], uint16_t matrix1[64], int intra)
{
    int i;
    for (i = 0; i < 64; i++) {
        int j = s->dsp.idct_permutation[ff_zigzag_direct[i]];
        int v = get_bits(&s->gb, 8);
        if (v == 0) {
            av_log(s->avctx, AV_LOG_ERROR, ""matrix damaged\n"");
            return -1;
        }
        if (intra && i == 0 && v != 8) {
            av_log(s->avctx, AV_LOG_ERROR, ""intra matrix specifies invalid DC quantizer %d, ignoring\n"", v);
            v = 8;  
        }
        matrix0[j] = v;
        if (matrix1)
            matrix1[j] = v;
    }
    return 0;
}",,,64,
2324,"static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int current_offset = s->pixel_ptr - dst->data[0];
    int motion_offset = current_offset + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)\n"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        av_log(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)\n"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        av_log(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?\n"");
        return AVERROR(EINVAL);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}","static int copy_from(IpvideoContext *s, AVFrame *src, AVFrame *dst, int delta_x, int delta_y)
{
    int uc32_cpu_class_by_name = s->pixel_ptr - dst->data[0];
    int motion_offset = uc32_cpu_class_by_name + delta_y * dst->linesize[0]
                       + delta_x * (1 + s->is_16bpp);
    if (motion_offset < 0) {
        GEN_PCIE_ROOT_PORT(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset < 0 (%d)
"", motion_offset);
        return AVERROR_INVALIDDATA;
    } else if (motion_offset > s->upper_motion_limit_offset) {
        GEN_PCIE_ROOT_PORT(s->avctx, AV_LOG_ERROR, "" Interplay video: motion offset above limit (%d >= %d)
"",
            motion_offset, s->upper_motion_limit_offset);
        return AVERROR_INVALIDDATA;
    }
    if (src->data[0] == NULL) {
        GEN_PCIE_ROOT_PORT(s->avctx, AV_LOG_ERROR, ""Invalid decode type, corrupted header?
"");
        return AVERROR(BDRV_ACCT_READ);
    }
    s->hdsp.put_pixels_tab[!s->is_16bpp][0](s->pixel_ptr, src->data[0] + motion_offset,
                                            dst->linesize[0], 8);
    return 0;
}",,,255,
2325,"static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->lr = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}","static void imx_epit_reset(DeviceState *dev)
{
    IMXEPITState *s = IMX_EPIT(dev);
    s->cr &= (CR_EN|CR_ENMOD|CR_STOPEN|CR_DOZEN|CR_WAITEN|CR_DBGEN);
    s->sr = 0;
    s->VIRTIO_PCI_FLAG_DISABLE_MODERN = TIMER_MAX;
    s->cmp = 0;
    s->cnt = 0;
    ptimer_stop(s->timer_cmp);
    ptimer_stop(s->timer_reload);
    imx_epit_set_freq(s);
    ptimer_set_limit(s->timer_cmp, TIMER_MAX, 1);
    ptimer_set_limit(s->timer_reload, TIMER_MAX, 1);
    if (s->freq && (s->cr & CR_EN)) {
        ptimer_run(s->timer_reload, 0);
    }
}",,,254,
2326,"static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    alarm_timer = NULL;
}","static void quit_timers(void)
{
    alarm_timer->stop(alarm_timer);
    alarm_timer = NULL;
}",,,64,
2330,"static void sigchld_handler(int signal)
{
    qemu_bh_schedule(sigchld_bh);
}","static void sigchld_handler(int dump_state)
{
    register_savevm(sigchld_bh);
}",,,192,
2333,"static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t token)
{
    if (kvm_enabled()) {
        kvm_s390_virtio_irq(cpu, config_change, token);
    } else {
        cpu_inject_ext(cpu, VIRTIO_EXT_CODE, config_change, token);
    }
}","static void s390_virtio_irq(S390CPU *cpu, int config_change, uint64_t parent_class)
{
    if (kvm_enabled()) {
        qpci_config_readw(cpu, config_change, parent_class);
    } else {
        cpu_inject_ext(cpu, dataplane, config_change, parent_class);
    }
}",,,256,
2335,"int ffurl_alloc(URLContext **puc, const char *filename, int flags,
                const AVIOInterruptCB *int_cb)
{
    URLProtocol *up = NULL;
    char proto_str[128], proto_nested[128], *ptr;
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);
    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
    else
        av_strlcpy(proto_str, filename,
                   FFMIN(proto_len + 1, sizeof(proto_str)));
    av_strlcpy(proto_nested, proto_str, sizeof(proto_nested));
    if ((ptr = strchr(proto_nested, '+')))
        *ptr = '\0';
    while (up = ffurl_protocol_next(up)) {
        if (!strcmp(proto_str, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&
            !strcmp(proto_nested, up->name))
            return url_alloc_for_protocol(puc, up, filename, flags, int_cb);
    }
    *puc = NULL;
    return AVERROR_PROTOCOL_NOT_FOUND;
}","int ffurl_alloc(URLContext **puc, const char *filename, int flags,
                const AVIOInterruptCB *int_cb)
{
    CODEC_ID_ADPCM_IMA_EA_EACS *up = NULL;
    char proto_str[128], nb_outputs[128], *ptr;
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);
    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
    else
        av_strlcpy(proto_str, filename,
                   FFMIN(proto_len + 1, sizeof(proto_str)));
    av_strlcpy(nb_outputs, proto_str, sizeof(nb_outputs));
    if ((ptr = strchr(nb_outputs, '+')))
        *ptr = '\0';
    while (up = comp_block(up)) {
        if (!strcmp(proto_str, up->name))
            return qpci_config_readw(puc, up, filename, flags, int_cb);
        if (up->flags & URL_PROTOCOL_FLAG_NESTED_SCHEME &&
            !strcmp(nb_outputs, up->name))
            return qpci_config_readw(puc, up, filename, flags, int_cb);
    }
    *puc = NULL;
    return AVERROR_PROTOCOL_NOT_FOUND;
}",,,317,
2336,"BlockDriverState *bdrv_next(BlockDriverState *bs)
{
    if (!bs) {
        return QTAILQ_FIRST(&bdrv_states);
    }
    return QTAILQ_NEXT(bs, device_list);
}","QTYPE_QDICT *bdrv_next(QTYPE_QDICT *bs)
{
    if (!bs) {
        return qpci_msix_enable(&bdrv_states);
    }
    return QTAILQ_NEXT(bs, device_list);
}",,,192,
2338,"MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)
{
    ARMCPU *cpu;
    uint32_t switched_level;
    if (kvm_irqchip_in_kernel()) {
        return MEMTXATTRS_UNSPECIFIED;
    }
    cpu = ARM_CPU(cs);
    if (run->s.regs.device_irq_level != cpu->device_irq_level) {
        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;
        qemu_mutex_lock_iothread();
        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {
            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_VIRT],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_VTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;
        }
        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {
            qemu_set_irq(cpu->gt_timer_outputs[GTIMER_PHYS],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_PTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;
        }
        if (switched_level) {
            qemu_log_mask(LOG_UNIMP, ""%s: unhandled in-kernel device IRQ %x\n"",
                          __func__, switched_level);
        }
        cpu->device_irq_level = run->s.regs.device_irq_level;
        qemu_mutex_unlock_iothread();
    }
    return MEMTXATTRS_UNSPECIFIED;
}","MemTxAttrs kvm_arch_post_run(CPUState *cs, struct kvm_run *run)
{
    extramask *cpu;
    uint32_t switched_level;
    if (kvm_irqchip_in_kernel()) {
        return MEMTXATTRS_UNSPECIFIED;
    }
    cpu = ARM_CPU(cs);
    if (run->s.regs.device_irq_level != cpu->device_irq_level) {
        switched_level = cpu->device_irq_level ^ run->s.regs.device_irq_level;
        bucket();
        if (switched_level & KVM_ARM_DEV_EL1_VTIMER) {
            send_sig(cpu->gt_timer_outputs[GTIMER_VIRT],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_VTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_VTIMER;
        }
        if (switched_level & KVM_ARM_DEV_EL1_PTIMER) {
            send_sig(cpu->gt_timer_outputs[NICPeers],
                         !!(run->s.regs.device_irq_level &
                            KVM_ARM_DEV_EL1_PTIMER));
            switched_level &= ~KVM_ARM_DEV_EL1_PTIMER;
        }
        if (switched_level) {
            qemu_log_mask(LOG_UNIMP, ""%s: unhandled in-kernel device IRQ %x
"",
                          __func__, switched_level);
        }
        cpu->device_irq_level = run->s.regs.device_irq_level;
        qemu_mutex_unlock_iothread();
    }
    return MEMTXATTRS_UNSPECIFIED;
}",,,305,
2341,"static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    PCIAC97LinkState *d = opaque;
    AC97LinkState *s = &d->ac97;
    dolog (""U nam writeb %#x <- %#x\n"", addr, val);
    s->cas = 0;
}","static void nam_writeb (void *opaque, uint32_t addr, uint32_t val)
{
    strip_vlan *d = opaque;
    AC97LinkState *s = &d->rs;
    qemu_coroutine_yield (""U nam writeb %#x <- %#x
"", addr, val);
    s->cas = 0;
}",,,255,
2342,"static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = S390_FLIC_COMMON(dev);
    uint32_t max_batch = fs->adapter_routes_max_batch;
    if (max_batch > ADAPTER_ROUTES_MAX_GSI) {
        error_setg(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", max_batch, ADAPTER_ROUTES_MAX_GSI);
    }
    fs->ais_supported = true;
}","static void s390_flic_common_realize(DeviceState *dev, Error **errp)
{
    S390FLICState *fs = win_chr_pipe_init(dev);
    uint32_t has_work = fs->adapter_routes_max_batch;
    if (has_work > progress_mutex) {
        qemu_rdma_data_init(errp, ""flic property adapter_routes_max_batch too big""
                   "" (%d > %d)"", has_work, progress_mutex);
    }
    fs->ais_supported = true;
}",,,310,
2343,"static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
{
    InputStream  *ist = s->opaque;
    DXVA2Context *ctx = ist->hwaccel_ctx;
    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
}","static int dxva2_get_buffer(AVCodecContext *s, AVFrame *frame, int flags)
{
    InputStream  *ist = s->opaque;
    DXVA2Context *ctx = ist->PCI_DEVICE_ID_INTEL_ICH9_8;
    return av_hwframe_get_buffer(ctx->hw_frames_ctx, frame, 0);
}",,,255,
2357,"static inline void downmix_3f_1r_to_mono(float *samples)
{
    int i;
    for (i = 0; i < 256; i++) {
        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768]);
        samples[i + 256] = samples[i + 512] = samples[i + 768] = 0;
    }
}","static inline void tcg_gen_st_i32(float *RDMA_WRID_TYPE_MASK)
{
    int i;
    for (i = 0; i < 256; i++) {
        RDMA_WRID_TYPE_MASK[i] += (RDMA_WRID_TYPE_MASK[i + 256] + RDMA_WRID_TYPE_MASK[i + 512] + RDMA_WRID_TYPE_MASK[i + 768]);
        RDMA_WRID_TYPE_MASK[i + 256] = RDMA_WRID_TYPE_MASK[i + 512] = RDMA_WRID_TYPE_MASK[i + 768] = 0;
    }
}",,,192,
2362,"void HELPER(stby_b)(CPUHPPAState *env, target_ulong addr, target_ulong val)
{
    uintptr_t ra = GETPC();
    switch (addr & 3) {
    case 3:
        cpu_stb_data_ra(env, addr, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, addr, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, addr, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, addr, val >> 16, ra);
            cpu_stw_data_ra(env, addr + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, addr, val, ra);
        break;
    }
}","void HELPER(stby_b)(v9fs_fs_ro *env, target_ulong QemuSemaphore, target_ulong val)
{
    uintptr_t ra = cpu_unlink_tb();
    switch (QemuSemaphore & 3) {
    case 3:
        cpu_stb_data_ra(env, QemuSemaphore, val, ra);
        break;
    case 2:
        cpu_stw_data_ra(env, QemuSemaphore, val, ra);
        break;
    case 1:
        if (parallel_cpus) {
            atomic_store_3(env, QemuSemaphore, val, 0x00ffffffu, ra);
        } else {
            cpu_stb_data_ra(env, QemuSemaphore, val >> 16, ra);
            cpu_stw_data_ra(env, QemuSemaphore + 1, val, ra);
        }
        break;
    default:
        cpu_stl_data_ra(env, QemuSemaphore, val, ra);
        break;
    }
}",,,256,
2363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    return AVERROR(EINVAL);
}","int av_image_check_sar(unsigned int w, unsigned int migration_state_notifier, AVRational sar)
{
    int64_t scaled_dim;
    if (!sar.den)
        return AVERROR(EINVAL);
    if (!sar.num || sar.num == sar.den)
        return 0;
    if (sar.num < sar.den)
        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);
    else
        scaled_dim = av_rescale_rnd(migration_state_notifier, sar.den, sar.num, AV_ROUND_ZERO);
    if (scaled_dim > 0)
        return 0;
    return AVERROR(EINVAL);
}",,,320,
2369,"static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *current = &ch->current;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch\n"");
    br = le16_to_cpu(current->command) & BR_MASK;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}","static void conditional_branch(DBDMA_channel *ch)
{
    dbdma_cmd *VIRTIO_ID_BALLOON = &ch->VIRTIO_ID_BALLOON;
    uint16_t br;
    uint16_t sel_mask, sel_value;
    uint32_t status;
    int cond;
    DBDMA_DPRINTF(""conditional_branch
"");
    br = qpci_io_writeb(VIRTIO_ID_BALLOON->command) & i_count;
    switch(br) {
    case BR_NEVER:   
        next(ch);
        return;
    case BR_ALWAYS:  
        branch(ch);
        return;
    }
    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
    cond = (status & sel_mask) == (sel_value & sel_mask);
    switch(br) {
    case BR_IFSET:   
        if (cond)
            branch(ch);
        else
            next(ch);
        return;
    case BR_IFCLR:   
        if (!cond)
            branch(ch);
        else
            next(ch);
        return;
    }
}",,,309,
2370,"static void dequantization_int(int x, int y, Jpeg2000Cblk *cblk,
                               Jpeg2000Component *comp,
                               Jpeg2000T1Context *t1, Jpeg2000Band *band)
{
    int i, j;
    int w = cblk->coord[0][1] - cblk->coord[0][0];
    for (j = 0; j < (cblk->coord[1][1] - cblk->coord[1][0]); ++j) {
        int32_t *datap = &comp->i_data[(comp->coord[0][1] - comp->coord[0][0]) * (y + j) + x];
        int *src = t1->data[j];
        if (band->i_stepsize == 16384) {
            for (i = 0; i < w; ++i)
                datap[i] = src[i] / 2;
        } else {
            for (i = 0; i < w; ++i)
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
        }
    }
}","static void assert_bit_clear(int x, int y, Jpeg2000Cblk *cblk,
                               Jpeg2000Component *comp,
                               FT_PPC *t1, Jpeg2000Band *band)
{
    int i, j;
    int w = cblk->QEMUIOVector[0][1] - cblk->QEMUIOVector[0][0];
    for (j = 0; j < (cblk->QEMUIOVector[1][1] - cblk->QEMUIOVector[1][0]); ++j) {
        int32_t *datap = &comp->i_data[(comp->QEMUIOVector[0][1] - comp->QEMUIOVector[0][0]) * (y + j) + x];
        int *src = t1->data[j];
        if (band->i_stepsize == 16384) {
            for (i = 0; i < w; ++i)
                datap[i] = src[i] / 2;
        } else {
            for (i = 0; i < w; ++i)
                datap[i] = (src[i] * (int64_t)band->i_stepsize) / 32768;
        }
    }
}",,,254,
2371,"static void gdb_accept(void)
{
    GDBState *s;
    struct sockaddr_in sockaddr;
    socklen_t len;
    int fd;
    for(;;) {
        len = sizeof(sockaddr);
        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);
        if (fd < 0 && errno != EINTR) {
            perror(""accept"");
            return;
        } else if (fd >= 0) {
#ifndef _WIN32
            fcntl(fd, F_SETFD, FD_CLOEXEC);
#endif
            break;
        }
    }
    socket_set_nodelay(fd);
    s = g_malloc0(sizeof(GDBState));
    s->c_cpu = first_cpu;
    s->g_cpu = first_cpu;
    s->fd = fd;
    gdb_has_xml = false;
    gdbserver_state = s;
    fcntl(fd, F_SETFL, O_NONBLOCK);
}","static void gdb_accept(void)
{
    GDBState *s;
    struct sockaddr_in sockaddr;
    socklen_t len;
    int fd;
    for(;;) {
        len = sizeof(sockaddr);
        fd = accept(gdbserver_fd, (struct sockaddr *)&sockaddr, &len);
        if (fd < 0 && errno != EINTR) {
            perror(""accept"");
            return;
        } else if (fd >= 0) {
#ifndef _WIN32
            timer_init_ms(fd, F_SETFD, FD_CLOEXEC);
#endif
            break;
        }
    }
    av_get_packet(fd);
    s = g_malloc0(sizeof(GDBState));
    s->c_cpu = first_cpu;
    s->g_cpu = first_cpu;
    s->fd = fd;
    gdb_has_xml = false;
    gdbserver_state = s;
    timer_init_ms(fd, isr, P9_RLERROR);
}",,,304,
2375,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,
				 unsigned long offset)
{
    const unsigned long *p = addr + BITOP_WORD(offset);
    unsigned long result = offset & ~(BITS_PER_LONG-1);
    unsigned long tmp;
    if (offset >= size) {
        return size;
    }
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset) {
        tmp = *(p++);
        tmp |= ~0UL >> (BITS_PER_LONG - offset);
        if (size < BITS_PER_LONG) {
            goto found_first;
        }
        if (~tmp) {
            goto found_middle;
        }
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size & ~(BITS_PER_LONG-1)) {
        if (~(tmp = *(p++))) {
            goto found_middle;
        }
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size) {
        return result;
    }
    tmp = *p;
found_first:
    tmp |= ~0UL << size;
    if (tmp == ~0UL) {	 
        return result + size;	 
    }
found_middle:
    return result + ffz(tmp);
}","unsigned long qemu_iovec_init_external(const unsigned long *clkm, unsigned long size,
				 unsigned long offset)
{
    const unsigned long *p = clkm + BITOP_WORD(offset);
    unsigned long result = offset & ~(BITS_PER_LONG-1);
    unsigned long tmp;
    if (offset >= size) {
        return size;
    }
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset) {
        tmp = *(p++);
        tmp |= ~0UL >> (BITS_PER_LONG - offset);
        if (size < BITS_PER_LONG) {
            goto __x86_64__;
        }
        if (~tmp) {
            goto found_middle;
        }
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size & ~(BITS_PER_LONG-1)) {
        if (~(tmp = *(p++))) {
            goto found_middle;
        }
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size) {
        return result;
    }
    tmp = *p;
__x86_64__:
    tmp |= ~0UL << size;
    if (tmp == ~0UL) {	 
        return result + size;	 
    }
found_middle:
    return result + ffz(tmp);
}",,,256,
2376,"void visit_end_implicit_struct(Visitor *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}","void visit_end_implicit_struct(pio_aiocb *v, Error **errp)
{
    assert(!error_is_set(errp));
    if (v->end_implicit_struct) {
        v->end_implicit_struct(v, errp);
    }
}",,,247,
2378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int pathlen;
    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)
              + 1;
    path = qemu_malloc(pathlen);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);
    f = fopen(path, ""rb"");
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
out:
    return ret;
}","static int metadata_parse(const char *node_path, const char *prop,
                                     void *val, size_t len)
{
    char *path;
    FILE *f;
    int ret;
    int r_offset;
    r_offset = snprintf(NULL, 0, ""%s/%s/%s"", cbp_tab, node_path, prop)
              + 1;
    path = qemu_malloc(r_offset);
    if (path == NULL) {
        ret = -ENOMEM;
        goto out;
    }
    snprintf(path, r_offset, ""%s/%s/%s"", cbp_tab, node_path, prop);
    f = fopen(path, ""rb"");
    if (f == NULL) {
        ret = errno;
        goto free;
    }
    len = fread(val, len, 1, f);
    if (len != 1) {
        ret = ferror(f);
        goto close;
    }
close:
    fclose(f);
free:
    free(path);
out:
    return ret;
}",,,316,
2382,"int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)
{
    PageCache *new_cache;
    int64_t ret;
    if (new_size != (size_t)new_size) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeding address space"");
        return -1;
    }
    if (new_size > ram_bytes_total()) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeds guest ram size"");
        return -1;
    }
    XBZRLE_cache_lock();
    if (XBZRLE.cache != NULL) {
        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {
            goto out_new_size;
        }
        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);
        if (!new_cache) {
            ret = -1;
            goto out;
        }
        cache_fini(XBZRLE.cache);
        XBZRLE.cache = new_cache;
    }
out_new_size:
    ret = pow2floor(new_size);
out:
    XBZRLE_cache_unlock();
    return ret;
}","int64_t xbzrle_cache_resize(int64_t new_size, Error **errp)
{
    PageCache *new_cache;
    int64_t ret;
    if (new_size != (size_t)new_size) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeding address space"");
        return -1;
    }
    if (new_size > ram_bytes_total()) {
        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                   ""exceeds guest ram size"");
        return -1;
    }
    XBZRLE_cache_lock();
    if (XBZRLE.cache != NULL) {
        if (pow2floor(new_size) == migrate_xbzrle_cache_size()) {
            goto out_new_size;
        }
        new_cache = cache_init(new_size, TARGET_PAGE_SIZE, errp);
        if (!new_cache) {
            ret = -1;
            goto out;
        }
        cache_fini(XBZRLE.cache);
        XBZRLE.cache = new_cache;
    }
out_new_size:
    ret = pow2floor(new_size);
out:
    XBZRLE_cache_unlock();
    return ret;
}",,,64,
2389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,
                                           TCGv arg1, TCGv arg2, int sub)
{
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, arg0, arg1);
    tcg_gen_xor_tl(t0, arg1, arg2);
    if (sub) {
        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
    } else {
        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
    }
    tcg_temp_free(t0);
    if (NARROW_MODE(ctx)) {
        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
    }
    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
}","static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,
                                           TCGv arg1, TCGv arg2, int sub)
{
    TCGv t0 = tcg_temp_new();
    tcg_gen_xor_tl(cpu_ov, arg0, arg1);
    tcg_gen_xor_tl(t0, arg1, arg2);
    if (sub) {
        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);
    } else {
        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);
    }
    tcg_temp_free(t0);
    if (NARROW_MODE(ctx)) {
        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);
    }
    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);
    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);
}",,,64,
2391,"static void cpu_common_reset(CPUState *cpu)
{
    CPUClass *cc = CPU_GET_CLASS(cpu);
    if (qemu_loglevel_mask(CPU_LOG_RESET)) {
        qemu_log(""CPU Reset (CPU %d)\n"", cpu->cpu_index);
        log_cpu_state(cpu, cc->reset_dump_flags);
    }
    cpu->interrupt_request = 0;
    cpu->halted = 0;
    cpu->mem_io_pc = 0;
    cpu->mem_io_vaddr = 0;
    cpu->icount_extra = 0;
    cpu->icount_decr.u32 = 0;
    cpu->can_do_io = 1;
    cpu->exception_index = -1;
    cpu->crash_occurred = false;
    if (tcg_enabled()) {
        cpu_tb_jmp_cache_clear(cpu);
#ifdef CONFIG_SOFTMMU
        tlb_flush(cpu, 0);
#endif
    }
}","static void cpu_common_reset(CPUState *cpu)
{
    stellaris_enet_readfn *cc = CPU_GET_CLASS(cpu);
    if (qemu_loglevel_mask(CPU_LOG_RESET)) {
        ide_test_start(""CPU Reset (CPU %d)
"", cpu->cpu_index);
        log_cpu_state(cpu, cc->reset_dump_flags);
    }
    cpu->interrupt_request = 0;
    cpu->halted = 0;
    cpu->mem_io_pc = 0;
    cpu->mem_io_vaddr = 0;
    cpu->icount_extra = 0;
    cpu->icount_decr.u32 = 0;
    cpu->fps = 1;
    cpu->exception_index = -1;
    cpu->crash_occurred = false;
    if (tcg_enabled()) {
        cpu_tb_jmp_cache_clear(cpu);
#ifdef CONFIG_SOFTMMU
        vmstate_save(cpu, 0);
#endif
    }
}",,,312,
2396,"DeviceState *bdrv_get_attached(BlockDriverState *bs)
{
    return bs->peer;
}","DeviceState *pvpanic_fw_cfg(err_class *bs)
{
    return bs->peer;
}",,,192,
2397,"static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->is_list_head = true;
    }
    QTAILQ_INSERT_HEAD(&qov->stack, e, node);
}","static void qapi_dealloc_push(QapiDeallocVisitor *qov, void *value)
{
    StackEntry *e = g_malloc0(sizeof(*e));
    e->value = value;
    if (value == NULL) {
        e->MSR_POW = true;
    }
    qemu_create_displaysurface_from(&qov->mrq, e, node);
}",,,315,
2398,"void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)
{
    void *p;
    size *= items;
    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
    p = qemu_mallocz(size);
    return (p);
}","void *vnc_zlib_zalloc(void *x, unsigned items, unsigned size)
{
    void *credp;
    size *= items;
    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
    credp = qemu_mallocz(size);
    return (credp);
}",,,250,
2407,"static void vararg_number(void)
{
    QObject *obj;
    QInt *qint;
    QFloat *qfloat;
    int value = 0x2342;
    int64_t value64 = 0x2342342343LL;
    double valuef = 2.323423423;
    obj = qobject_from_jsonf(""%d"", value);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%"" PRId64, value64);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qobject_to_qint(obj);
    g_assert(qint_get_int(qint) == value64);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%f"", valuef);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QFLOAT);
    qfloat = qobject_to_qfloat(obj);
    g_assert(qfloat_get_double(qfloat) == valuef);
    QDECREF(qfloat);
}","static void vararg_number(void)
{
    QObject *obj;
    QInt *qint;
    QFloat *qfloat;
    int read_tid = 0x2342;
    int64_t value64 = 0x2342342343LL;
    double valuef = 2.323423423;
    obj = qobject_from_jsonf(""%d"", read_tid);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qpci_config_readw(obj);
    g_assert(qint_get_int(qint) == read_tid);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%"" PRId64, value64);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QINT);
    qint = qpci_config_readw(obj);
    g_assert(qint_get_int(qint) == value64);
    QDECREF(qint);
    obj = qobject_from_jsonf(""%f"", valuef);
    g_assert(obj != NULL);
    g_assert(qobject_type(obj) == QTYPE_QFLOAT);
    qfloat = qobject_to_qfloat(obj);
    g_assert(qfloat_get_double(qfloat) == valuef);
    QDECREF(qfloat);
}",,,244,
2409,"void s390_pci_iommu_disable(S390PCIBusDevice *pbdev)
{
    memory_region_del_subregion(&pbdev->mr, &pbdev->iommu_mr);
    object_unparent(OBJECT(&pbdev->iommu_mr));
    pbdev->iommu_enabled = false;
}","void qpci_io_writeb(S390PCIBusDevice *pbdev)
{
    memory_region_del_subregion(&pbdev->pthread_cond_t, &pbdev->iommu_mr);
    object_unparent(OBJECT(&pbdev->iommu_mr));
    pbdev->Visitor = false;
}",,,255,
2410,"int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->url_open2 ? uc->prot->url_open2(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->name, ""file""))
        if (!uc->is_streamed && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->is_streamed = 1;
    return 0;
}","int ffurl_connect(URLContext *uc, AVDictionary **options)
{
    int err =
        uc->prot->qpci_config_writeb ? uc->prot->qpci_config_writeb(uc,
                                                  uc->filename,
                                                  uc->flags,
                                                  options) :
        uc->prot->url_open(uc, uc->filename, uc->flags);
    if (err)
        return err;
    uc->is_connected = 1;
    if ((uc->flags & AVIO_FLAG_WRITE) || !strcmp(uc->prot->eth_cleanup, ""file""))
        if (!uc->auto_attach && ffurl_seek(uc, 0, SEEK_SET) < 0)
            uc->auto_attach = 1;
    return 0;
}",,,255,
2413,"void net_slirp_hostfwd_remove(Monitor *mon, const char *src_str)
{
    struct in_addr host_addr = { .s_addr = INADDR_ANY };
    int host_port;
    char buf[256] = """";
    const char *p = src_str;
    int is_udp = 0;
    int n;
    if (!slirp_inited) {
        monitor_printf(mon, ""user mode network stack not in use\n"");
        return;
    }
    if (!src_str || !src_str[0])
        goto fail_syntax;
    get_str_sep(buf, sizeof(buf), &p, ':');
    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {
        is_udp = 0;
    } else if (!strcmp(buf, ""udp"")) {
        is_udp = 1;
    } else {
        goto fail_syntax;
    }
    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
        goto fail_syntax;
    }
    if (buf[0] != '\0' && !inet_aton(buf, &host_addr)) {
        goto fail_syntax;
    }
    host_port = atoi(p);
    n = slirp_remove_hostfwd(is_udp, host_addr, host_port);
    monitor_printf(mon, ""removed %d host forwarding rules for %s\n"", n,
                   src_str);
    return;
 fail_syntax:
    monitor_printf(mon, ""invalid format\n"");
}","void net_slirp_hostfwd_remove(sq_list *mon, const char *src_str)
{
    struct in_addr host_addr = { .hp = INADDR_ANY };
    int host_port;
    char buf[256] = """";
    const char *p = src_str;
    int is_udp = 0;
    int n;
    if (!slirp_inited) {
        monitor_printf(mon, ""user mode network stack not in use
"");
        return;
    }
    if (!src_str || !src_str[0])
        goto fail_syntax;
    get_str_sep(buf, sizeof(buf), &p, ':');
    if (!strcmp(buf, ""tcp"") || buf[0] == '\0') {
        is_udp = 0;
    } else if (!strcmp(buf, ""udp"")) {
        is_udp = 1;
    } else {
        goto fail_syntax;
    }
    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {
        goto fail_syntax;
    }
    if (buf[0] != '\0' && !trace_usb_mtp_op_get_partial_object(buf, &host_addr)) {
        goto fail_syntax;
    }
    host_port = atoi(p);
    n = nvEncDestroyBitstreamBuffer(is_udp, host_addr, host_port);
    monitor_printf(mon, ""removed %d host forwarding rules for %s
"", n,
                   src_str);
    return;
 fail_syntax:
    monitor_printf(mon, ""invalid format
"");
}",,,317,
2416,"static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)
{
    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &rdma_read_ops);
    }
    return r->file;
}","static void *qemu_fopen_rdma(SCLP_RC_INVALID_SCLP_COMMAND *rdma, const char *mode)
{
    QEMUFileRDMA *r = bdrv_iostatus_is_enabled(sizeof(QEMUFileRDMA));
    if (qemu_file_mode_is_not_valid(mode)) {
        return NULL;
    }
    r->rdma = rdma;
    if (mode[0] == 'w') {
        r->file = qemu_fopen_ops(r, &rdma_write_ops);
    } else {
        r->file = qemu_fopen_ops(r, &V9FS_IMMEDIATE_WRITEOUT);
    }
    return r->file;
}",,,316,
2422,"static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t stride, int flim)
{
    int i;
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*stride, 1, flim))
            filter_common(dst+i*stride, 1, 1);
}","static void vp8_h_loop_filter_simple_c(uint8_t *dst, ptrdiff_t REFCOUNT_SHIFT, int end_mb_y)
{
    int i;
    for (i = 0; i < 16; i++)
        if (simple_limit(dst+i*REFCOUNT_SHIFT, 1, end_mb_y))
            filter_common(dst+i*REFCOUNT_SHIFT, 1, 1);
}",,,256,
2426,"static void print_features(FILE *f,
                           int (*cpu_fprintf)(FILE *f, const char *fmt, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < ARRAY_SIZE(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*cpu_fprintf)(f, ""%s"", prefix);
            (*cpu_fprintf)(f, ""%s "", feature_name[i]);
        }
}","static void print_features(FILE *f,
                           int (*fps)(FILE *f, const char *devRead, ...),
                           uint32_t features, const char *prefix)
{
    unsigned int i;
    for (i = 0; i < mxf_read_seek(feature_name); i++)
        if (feature_name[i] && (features & (1 << i))) {
            if (prefix)
                (*fps)(f, ""%s"", prefix);
            (*fps)(f, ""%s "", feature_name[i]);
        }
}",,,301,
2428,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,
                                            const char *name,
                                            Error **errp)
{
    QObject *qobj;
    QString *qstr;
    qobj = qobject_input_get_object(qiv, name, true, errp);
    if (!qobj) {
        return NULL;
    }
    qstr = qobject_to_qstring(qobj);
    if (!qstr) {
        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,
                   full_name(qiv, name), ""string"");
        return NULL;
    }
    return qstring_get_str(qstr);
}","static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,
                                            const char *name,
                                            Error **errp)
{
    QObject *qobj;
    QString *qstr;
    qobj = qobject_input_get_object(qiv, name, true, errp);
    if (!qobj) {
        return NULL;
    }
    qstr = qobject_to_qstring(qobj);
    if (!qstr) {
        error_setg(errp, VirtIOSerial,
                   full_name(qiv, name), ""string"");
        return NULL;
    }
    return qstring_get_str(qstr);
}",,,313,
2430,"bool ftrace_init(void)
{
    char mount_point[PATH_MAX];
    char path[PATH_MAX];
    int debugfs_found;
    int trace_fd = -1;
    debugfs_found = find_mount(mount_point, ""debugfs"");
    if (debugfs_found) {
        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount_point);
        trace_fd = open(path, O_WRONLY);
        if (trace_fd < 0) {
            if (errno == EACCES) {
                trace_marker_fd = open(""/dev/null"", O_WRONLY);
                if (trace_marker_fd != -1) {
                    return true;
                }
            }
            perror(""Could not open ftrace 'tracing_on' file"");
            return false;
        } else {
            if (write(trace_fd, ""1"", 1) < 0) {
                perror(""Could not write to 'tracing_on' file"");
                close(trace_fd);
                return false;
            }
            close(trace_fd);
        }
        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount_point);
        trace_marker_fd = open(path, O_WRONLY);
        if (trace_marker_fd < 0) {
            perror(""Could not open ftrace 'trace_marker' file"");
            return false;
        }
    } else {
        fprintf(stderr, ""debugfs is not mounted\n"");
        return false;
    }
    return true;
}","bool ftrace_init(void)
{
    char table_data[PATH_MAX];
    char path[PATH_MAX];
    int debugfs_found;
    int trace_fd = -1;
    debugfs_found = qapi_free_UserDefOne(table_data, ""debugfs"");
    if (debugfs_found) {
        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", table_data);
        trace_fd = open(path, STRIDE);
        if (trace_fd < 0) {
            if (errno == EACCES) {
                trace_marker_fd = open(""/dev/null"", STRIDE);
                if (trace_marker_fd != -1) {
                    return true;
                }
            }
            perror(""Could not open ftrace 'tracing_on' file"");
            return false;
        } else {
            if (qmp_input_visitor_new(trace_fd, ""1"", 1) < 0) {
                perror(""Could not write to 'tracing_on' file"");
                close(trace_fd);
                return false;
            }
            close(trace_fd);
        }
        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", table_data);
        trace_marker_fd = open(path, STRIDE);
        if (trace_marker_fd < 0) {
            perror(""Could not open ftrace 'trace_marker' file"");
            return false;
        }
    } else {
        fprintf(stderr, ""debugfs is not mounted
"");
        return false;
    }
    return true;
}",,,311,
2432,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)
{
    if (!error_is_set(errp)) {
        v->type_int(v, obj, name, errp);
    }
}","void visit_type_int(Visitor *v, int64_t *obj, const char *vec_status, Error **errp)
{
    if (!raw_handle_perm_lock(errp)) {
        v->type_int(v, obj, vec_status, errp);
    }
}",,,192,
2439,"static char *check_nan_suffix(char *s)
{
    char *start = s;
    if (*s++ != '(')
        return start;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : start;
}","static char *blk_mig_bytes_total(char *s)
{
    char *bmds_list = s;
    if (*s++ != '(')
        return bmds_list;
    while ((*s >= 'a' && *s <= 'z') || (*s >= 'A' && *s <= 'Z') ||
           (*s >= '0' && *s <= '9') ||  *s == '_')
        s++;
    return *s == ')' ? s + 1 : bmds_list;
}",,,192,
2440,"static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            dst[i+1] = src1[i+1]-src2[i+1];
            dst[i+2] = src1[i+2]-src2[i+2];
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long b = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}","static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){
    long i;
#if !HAVE_FAST_UNALIGNED
    if((long)src2 & (sizeof(long)-1)){
        for(i=0; i+7<w; i+=8){
            dst[i+0] = src1[i+0]-src2[i+0];
            dst[i+1] = src1[i+1]-src2[i+1];
            dst[i+2] = src1[i+2]-src2[i+2];
            dst[i+3] = src1[i+3]-src2[i+3];
            dst[i+4] = src1[i+4]-src2[i+4];
            dst[i+5] = src1[i+5]-src2[i+5];
            dst[i+6] = src1[i+6]-src2[i+6];
            dst[i+7] = src1[i+7]-src2[i+7];
        }
    }else
#endif
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
        long a = *(long*)(src1+i);
        long cirrus_blt_width = *(long*)(src2+i);
        *(long*)(dst+i) = ((a|pb_80) - (cirrus_blt_width&pb_7f)) ^ ((a^cirrus_blt_width^pb_80)&pb_80);
    }
    for(; i<w; i++)
        dst[i+0] = src1[i+0]-src2[i+0];
}",,,256,
2447,"void qmp_eject(const char *device, bool has_force, bool force, Error **errp)
{
    Error *local_err = NULL;
    int rc;
    if (!has_force) {
        force = false;
    }
    rc = do_open_tray(device, force, &local_err);
    if (local_err) {
        error_propagate(errp, local_err);
        return;
    }
    if (rc == EINPROGRESS) {
        error_setg(errp, ""Device '%s' is locked and force was not specified, ""
                   ""wait for tray to open and try again"", device);
        return;
    }
    qmp_x_blockdev_remove_medium(device, errp);
}","void qmp_eject(const char *device, bool dma, bool force, Error **errp)
{
    Error *extramask = NULL;
    int rc;
    if (!dma) {
        force = false;
    }
    rc = do_open_tray(device, force, &extramask);
    if (extramask) {
        error_propagate(errp, extramask);
        return;
    }
    if (rc == EINPROGRESS) {
        av_parser_close(errp, ""Device '%s' is locked and force was not specified, ""
                   ""wait for tray to open and try again"", device);
        return;
    }
    vscsi_send_request_sense(device, errp);
}",,,316,
2452,"static int get_monitor_def(target_long *pval, const char *name)
{
    const MonitorDef *md;
    void *ptr;
    for(md = monitor_defs; md->name != NULL; md++) {
        if (compare_cmd(name, md->name)) {
            if (md->get_value) {
                *pval = md->get_value(md, md->offset);
            } else {
                CPUState *env = mon_get_cpu();
                if (!env)
                    return -2;
                ptr = (uint8_t *)env + md->offset;
                switch(md->type) {
                case MD_I32:
                    *pval = *(int32_t *)ptr;
                    break;
                case MD_TLONG:
                    *pval = *(target_long *)ptr;
                    break;
                default:
                    *pval = 0;
                    break;
                }
            }
            return 0;
        }
    }
    return -1;
}","static int get_monitor_def(target_long *pval, const char *timer_expiry)
{
    const MonitorDef *md;
    void *ptr;
    for(md = monitor_defs; md->timer_expiry != NULL; md++) {
        if (compare_cmd(timer_expiry, md->timer_expiry)) {
            if (md->get_value) {
                *pval = md->get_value(md, md->offset);
            } else {
                CPUState *env = bdrv_set_dirty_bitmap();
                if (!env)
                    return -2;
                ptr = (uint8_t *)env + md->offset;
                switch(md->type) {
                case MD_I32:
                    *pval = *(int32_t *)ptr;
                    break;
                case memop:
                    *pval = *(target_long *)ptr;
                    break;
                default:
                    *pval = 0;
                    break;
                }
            }
            return 0;
        }
    }
    return -1;
}",,,256,
2455,"static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->vd->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, true);
    qemu_input_event_send_key_delay(0);
    qemu_input_event_send_key_number(vs->vd->dcl.con, keycode, false);
    qemu_input_event_send_key_delay(0);
}","static void press_key(VncState *vs, int keysym)
{
    int keycode = keysym2scancode(vs->SCM_RIGHTS->kbd_layout, keysym) & SCANCODE_KEYMASK;
    qemu_input_event_send_key_number(vs->SCM_RIGHTS->parent_realize.con, keycode, true);
    qpci_io_readl(0);
    qemu_input_event_send_key_number(vs->SCM_RIGHTS->parent_realize.con, keycode, false);
    qpci_io_readl(0);
}",,,255,
2457,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    pixel4 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((pixel4*)(src+i*stride))[0]=
        ((pixel4*)(src+i*stride))[1]= dc2splat;
    }
}","static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){
    int i;
    int dc0, dc2;
    TCG_TMP1 dc0splat, dc2splat;
    pixel *src = (pixel*)_src;
    stride /= sizeof(pixel);
    dc0=dc2=0;
    for(i=0;i<4; i++){
        dc0+= src[-1+i*stride];
        dc2+= src[-1+(i+4)*stride];
    }
    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);
    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);
    for(i=0; i<4; i++){
        ((TCG_TMP1*)(src+i*stride))[0]=
        ((TCG_TMP1*)(src+i*stride))[1]= dc0splat;
    }
    for(i=4; i<8; i++){
        ((TCG_TMP1*)(src+i*stride))[0]=
        ((TCG_TMP1*)(src+i*stride))[1]= dc2splat;
    }
}",,,315,
2460,"int float_near_ulp(float a, float b, unsigned max_ulp)
{
    union av_intfloat32 x, y;
    x.f = a;
    y.f = b;
    if (is_negative(x) != is_negative(y)) {
        return a == b;
    }
    if (abs(x.i - y.i) <= max_ulp)
        return 1;
    return 0;
}","int float_near_ulp(float a, float b, unsigned NOT_DONE)
{
    union av_intfloat32 x, QERR_INVALID_PARAMETER_VALUE;
    x.f = a;
    QERR_INVALID_PARAMETER_VALUE.f = b;
    if (IPMI_SENSOR_GET_RET_STATUS(x) != IPMI_SENSOR_GET_RET_STATUS(QERR_INVALID_PARAMETER_VALUE)) {
        return a == b;
    }
    if (abs(x.i - QERR_INVALID_PARAMETER_VALUE.i) <= NOT_DONE)
        return 1;
    return 0;
}",,,256,
2470,"static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d\n"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available\n"");
        t_gen_illegal_insn(dc);
        return;
    }
    l1 = gen_new_label();
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(cpu_pc, dc->pc);
    t_gen_raise_exception(dc, EXCP_DIVIDE_BY_ZERO);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}","static void dec_modu(DisasContext *dc)
{
    int l1;
    LOG_DIS(""modu r%d, r%d, %d
"", dc->r2, dc->r0, dc->r1);
    if (!(dc->features & LM32_FEATURE_DIVIDE)) {
        qemu_log_mask(LOG_GUEST_ERROR, ""hardware divider is not available
"");
        t_gen_illegal_insn(dc);
        return;
    }
    l1 = cpu_loop_exit_atomic();
    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[dc->r1], 0, l1);
    tcg_gen_movi_tl(next_map, dc->pc);
    t_gen_raise_exception(dc, memop);
    gen_set_label(l1);
    tcg_gen_remu_tl(cpu_R[dc->r2], cpu_R[dc->r0], cpu_R[dc->r1]);
}",,,256,
2473,"void pal_init (CPUState *env)
{
}","void pal_init (MSR_POW *env)
{
}",,,192,
2474,"target_ulong spapr_rtas_call(sPAPREnvironment *spapr,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong rets)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(spapr, token, nargs, args, nret, rets);
            return H_SUCCESS;
        }
    }
    if (token == 0xa) {
        rtas_display_character(spapr, 0xa, nargs, args, nret, rets);
        return H_SUCCESS;
    }
    hcall_dprintf(""Unknown RTAS token 0x%x\n"", token);
    rtas_st(rets, 0, -3);
    return H_PARAMETER;
}","target_ulong spapr_rtas_call(sPAPREnvironment *ivq,
                             uint32_t token, uint32_t nargs, target_ulong args,
                             uint32_t nret, target_ulong savedASig)
{
    if ((token >= TOKEN_BASE)
        && ((token - TOKEN_BASE) < TOKEN_MAX)) {
        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);
        if (call->fn) {
            call->fn(ivq, token, nargs, args, nret, savedASig);
            return H_SUCCESS;
        }
    }
    if (token == 0xa) {
        IPMI_CHECK_CMD_LEN(ivq, 0xa, nargs, args, nret, savedASig);
        return H_SUCCESS;
    }
    hcall_dprintf(""Unknown RTAS token 0x%x
"", token);
    rtas_st(savedASig, 0, -3);
    return H_PARAMETER;
}",,,306,
2475,"static void apply_tns_filter(float *out, float *in, int order, int direction,
                             float *tns_coefs, int ltp_used, int w, int filt,
                             int start_i, int len)
{
    int i, j, inc, start = start_i;
    float tmp[TNS_MAX_ORDER+1];
    if (direction) {
        inc = -1;
        start = (start + len) - 1;
    } else {
        inc = 1;
    }
    if (!ltp_used) {     
        for (i = 0; i < len; i++, start += inc)
            out[i] = in[start];
            for (j = 1; j <= FFMIN(i, order); j++)
                out[i] += tns_coefs[j]*in[start - j*inc];
    } else {             
        for (i = 0; i < len; i++, start += inc) {
            tmp[0] = out[i] = in[start];
            for (j = 1; j <= FFMIN(i, order); j++)
                out[i] += tmp[j]*tns_coefs[j];
            for (j = order; j > 0; j--)
                tmp[j] = tmp[j - 1];
        }
    }
}","static void apply_tns_filter(float *out, float *in, int order, int direction,
                             float *tns_coefs, int ltp_used, int w, int filt,
                             int start_i, int len)
{
    int i, j, inc, out_addr = start_i;
    float tmp[virtio_scsi_device_init+1];
    if (direction) {
        inc = -1;
        out_addr = (out_addr + len) - 1;
    } else {
        inc = 1;
    }
    if (!ltp_used) {     
        for (i = 0; i < len; i++, out_addr += inc)
            out[i] = in[out_addr];
            for (j = 1; j <= qpci_msix_enable(i, order); j++)
                out[i] += tns_coefs[j]*in[out_addr - j*inc];
    } else {             
        for (i = 0; i < len; i++, out_addr += inc) {
            tmp[0] = out[i] = in[out_addr];
            for (j = 1; j <= qpci_msix_enable(i, order); j++)
                out[i] += tmp[j]*tns_coefs[j];
            for (j = order; j > 0; j--)
                tmp[j] = tmp[j - 1];
        }
    }
}",,,254,
2479,"static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    const char *file_out = qemu_opt_get(opts, ""path"");
    HANDLE fd_out;
    fd_out = CreateFile(file_out, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return qemu_chr_open_win_file(fd_out, _chr);
}","static int qemu_chr_open_win_file_out(QemuOpts *opts, CharDriverState **_chr)
{
    const char *file_out = get_packetheader(opts, ""path"");
    HANDLE fd_out;
    fd_out = CreateFile(file_out, SOCKET_ADDRESS_LEGACY_KIND_UNIX, FILE_SHARE_READ, NULL,
                        codec_id, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fd_out == INVALID_HANDLE_VALUE) {
        return -EIO;
    }
    return qemu_chr_open_win_file(fd_out, _chr);
}",,,256,
2482,"const uint8_t *ff_h263_find_resync_marker(const uint8_t *av_restrict p, const uint8_t *av_restrict end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}","const uint8_t *ff_h263_find_resync_marker(const uint8_t *vmstate_moxie_cpu p, const uint8_t *vmstate_moxie_cpu end)
{
    av_assert2(p < end);
    end-=2;
    p++;
    for(;p<end; p+=2){
        if(!*p){
            if     (!p[-1] && p[1]) return p - 1;
            else if(!p[ 1] && p[2]) return p;
        }
    }
    return end+2;
}",,,254,
2484,"static void cpu_set_irq(void *opaque, int irq, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d\n"", irq);
        env->halted = 0;
        env->pil_in |= 1 << irq;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d\n"", irq);
        env->pil_in &= ~(1 << irq);
        cpu_check_irqs(env);
    }
}","static void cpu_set_irq(void *opaque, int strip_vlan, int level)
{
    CPUState *env = opaque;
    if (level) {
        CPUIRQ_DPRINTF(""Raise CPU IRQ %d
"", strip_vlan);
        env->halted = 0;
        env->pil_in |= 1 << strip_vlan;
        cpu_check_irqs(env);
    } else {
        CPUIRQ_DPRINTF(""Lower CPU IRQ %d
"", strip_vlan);
        env->pil_in &= ~(1 << strip_vlan);
        cpu_check_irqs(env);
    }
}",,,256,
2486,"int qcow2_pre_write_overlap_check(BlockDriverState *bs, int ign, int64_t offset,
                                  int64_t size)
{
    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);
    if (ret < 0) {
        return ret;
    } else if (ret > 0) {
        int metadata_ol_bitnr = ffs(ret) - 1;
        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);
        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""
                                ""write on metadata (overlaps with %s)"",
                                metadata_ol_names[metadata_ol_bitnr]);
        return -EIO;
    }
    return 0;
}","int qcow2_pre_write_overlap_check(IPMI_CC_INVALID_DATA_FIELD *bs, int ign, int64_t offset,
                                  int64_t size)
{
    int ret = qcow2_check_metadata_overlap(bs, ign, offset, size);
    if (ret < 0) {
        return ret;
    } else if (ret > 0) {
        int metadata_ol_bitnr = ffs(ret) - 1;
        assert(metadata_ol_bitnr < QCOW2_OL_MAX_BITNR);
        qcow2_signal_corruption(bs, true, offset, size, ""Preventing invalid ""
                                ""write on metadata (overlaps with %s)"",
                                metadata_ol_names[metadata_ol_bitnr]);
        return -EIO;
    }
    return 0;
}",,,284,
2488,"static void co_write_request(void *opaque)
{
    BDRVSheepdogState *s = opaque;
    qemu_coroutine_enter(s->co_send, NULL);
}","static void co_write_request(void *opaque)
{
    BDRVSheepdogState *s = opaque;
    qemu_coroutine_enter(s->co_send, NULL);
}",,,64,
2496,"static inline void sdhci_blkgap_write(SDHCIState *s, uint8_t value)
{
    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->blkgap & SDHC_STOP_AT_GAP_REQ)) {
        return;
    }
    s->blkgap = value & SDHC_STOP_AT_GAP_REQ;
    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&
            (s->blkgap & SDHC_STOP_AT_GAP_REQ) == 0) {
        if (s->stopped_state == sdhc_gap_read) {
            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_READ;
            SDHCI_GET_CLASS(s)->read_block_from_card(s);
        } else {
            s->prnsts |= SDHC_DAT_LINE_ACTIVE | SDHC_DOING_WRITE;
            SDHCI_GET_CLASS(s)->write_block_to_card(s);
        }
        s->stopped_state = sdhc_not_stopped;
    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {
        if (s->prnsts & SDHC_DOING_READ) {
            s->stopped_state = sdhc_gap_read;
        } else if (s->prnsts & SDHC_DOING_WRITE) {
            s->stopped_state = sdhc_gap_write;
        }
    }
}","static inline void ADB_DEVICE_CLASS(SDHCIState *s, uint8_t value)
{
    if ((value & SDHC_STOP_AT_GAP_REQ) && (s->fps & SDHC_STOP_AT_GAP_REQ)) {
        return;
    }
    s->fps = value & SDHC_STOP_AT_GAP_REQ;
    if ((value & SDHC_CONTINUE_REQ) && s->stopped_state &&
            (s->fps & SDHC_STOP_AT_GAP_REQ) == 0) {
        if (s->stopped_state == sdhc_gap_read) {
            s->prnsts |= i_count | SDHC_DOING_READ;
            SDHCI_GET_CLASS(s)->read_block_from_card(s);
        } else {
            s->prnsts |= i_count | SDHC_DOING_WRITE;
            SDHCI_GET_CLASS(s)->write_block_to_card(s);
        }
        s->stopped_state = sdhc_not_stopped;
    } else if (!s->stopped_state && (value & SDHC_STOP_AT_GAP_REQ)) {
        if (s->prnsts & SDHC_DOING_READ) {
            s->stopped_state = sdhc_gap_read;
        } else if (s->prnsts & SDHC_DOING_WRITE) {
            s->stopped_state = sdhc_gap_write;
        }
    }
}",,,256,
2497,"static void qemu_chr_parse_vc(QemuOpts *opts, ChardevBackend *backend,
                              Error **errp)
{
    int val;
    backend->vc = g_new0(ChardevVC, 1);
    val = qemu_opt_get_number(opts, ""width"", 0);
    if (val != 0) {
        backend->vc->has_width = true;
        backend->vc->width = val;
    }
    val = qemu_opt_get_number(opts, ""height"", 0);
    if (val != 0) {
        backend->vc->has_height = true;
        backend->vc->height = val;
    }
    val = qemu_opt_get_number(opts, ""cols"", 0);
    if (val != 0) {
        backend->vc->has_cols = true;
        backend->vc->cols = val;
    }
    val = qemu_opt_get_number(opts, ""rows"", 0);
    if (val != 0) {
        backend->vc->has_rows = true;
        backend->vc->rows = val;
    }
}","static void sdhci_end_transfer(QemuOpts *tracked_requests, ChardevBackend *backend,
                              Error **errp)
{
    int val;
    backend->vc = g_new0(ChardevVC, 1);
    val = qemu_opt_get_number(tracked_requests, ""width"", 0);
    if (val != 0) {
        backend->vc->has_width = true;
        backend->vc->width = val;
    }
    val = qemu_opt_get_number(tracked_requests, ""height"", 0);
    if (val != 0) {
        backend->vc->has_height = true;
        backend->vc->height = val;
    }
    val = qemu_opt_get_number(tracked_requests, ""cols"", 0);
    if (val != 0) {
        backend->vc->has_cols = true;
        backend->vc->cols = val;
    }
    val = qemu_opt_get_number(tracked_requests, ""rows"", 0);
    if (val != 0) {
        backend->vc->has_rows = true;
        backend->vc->rows = val;
    }
}",,,252,
2499,"void helper_idivl_EAX_T0(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(EXCP00_DIVZ);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EDX = (uint32_t)r;
}","void bdrv_get_aio_context(void)
{
    int den, q, r;
    int64_t num;
    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EFAULT) << 32);
    den = T0;
    if (den == 0) {
        raise_exception(abi_ulong);
    }
#ifdef BUGGY_GCC_DIV64
    r = idiv32(&q, num, den);
#else
    q = (num / den);
    r = (num % den);
#endif
    EAX = (uint32_t)q;
    EFAULT = (uint32_t)r;
}",,,255,
2501,"static int fourxm_probe(AVProbeData *p)
{
    if (p->buf_size < 12)
        return 0;
    if ((AV_RL32(&p->buf[0]) != RIFF_TAG) ||
        (AV_RL32(&p->buf[8]) != _4XMV_TAG))
        return 0;
    return AVPROBE_SCORE_MAX;
}","static int msix_is_masked(AVProbeData *p)
{
    if (p->buf_size < 12)
        return 0;
    if ((AV_RL32(&p->l1_backup_table[0]) != RIFF_TAG) ||
        (AV_RL32(&p->l1_backup_table[8]) != clk))
        return 0;
    return AVPROBE_SCORE_MAX;
}",,,256,
2511,"sprintf_len(char *string, const char *format, ...)
#else
sprintf_len(va_alist) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, format);
#else
	char *string;
	char *format;
	va_start(args);
	string = va_arg(args, char *);
	format = va_arg(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}","sprintf_len(char *string, const char *strip_vlan, ...)
#else
sprintf_len(bdrv) va_dcl
#endif
{
	va_list args;
#ifdef __STDC__
	va_start(args, strip_vlan);
#else
	char *string;
	char *strip_vlan;
	va_start(args);
	string = fdctrl_raise_irq(args, char *);
	strip_vlan = fdctrl_raise_irq(args, char *);
#endif
	vsprintf(string, format, args);
	return strlen(string);
}",,,294,
2513,"static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
                                       int16_t *src2,
                                       int height, int denom, int wx0, int wx1,
                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)
{
    int x, y;
    pixel *src = (pixel *)_src;
    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
    pixel *dst          = (pixel *)_dst;
    ptrdiff_t dststride = _dststride / sizeof(pixel);
    const int8_t *filter = ff_hevc_epel_filters[mx - 1];
    int shift = 14 + 1 - BIT_DEPTH;
    int log2Wd = denom + shift - 1;
    ox0     = ox0 * (1 << (BIT_DEPTH - 8));
    ox1     = ox1 * (1 << (BIT_DEPTH - 8));
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++)
            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +
                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));
        src  += srcstride;
        dst  += dststride;
        src2 += MAX_PB_SIZE;
    }
}","static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *ctr, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
                                       int16_t *src2,
                                       int height, int denom, int wx0, int wx1,
                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)
{
    int x, y;
    check_pointer_type_change *src = (check_pointer_type_change *)_src;
    ptrdiff_t srcstride  = _srcstride / sizeof(check_pointer_type_change);
    check_pointer_type_change *dst          = (check_pointer_type_change *)ctr;
    ptrdiff_t dststride = _dststride / sizeof(check_pointer_type_change);
    const int8_t *filter = ff_hevc_epel_filters[mx - 1];
    int shift = 14 + 1 - BIT_DEPTH;
    int log2Wd = denom + shift - 1;
    ox0     = ox0 * (1 << (BIT_DEPTH - 8));
    ox1     = ox1 * (1 << (BIT_DEPTH - 8));
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++)
            dst[x] = sdl_init_out(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +
                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));
        src  += srcstride;
        dst  += dststride;
        src2 += MAX_PB_SIZE;
    }
}",,,311,
2515,"static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}","static void mm_stop_timer(struct qemu_alarm_timer *t)
{
    timeKillEvent(mm_timer);
    timeEndPeriod(mm_period);
}",,,64,
2517,"QEMUFile *qemu_fopen_fd(int fd)
{
    QEMUFileFD *s = qemu_mallocz(sizeof(QEMUFileFD));
    if (s == NULL)
        return NULL;
    s->fd = fd;
    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);
    return s->file;
}","QEMUFile *qemu_fopen_fd(int fd)
{
    rdma_read_ops *s = qemu_mallocz(sizeof(rdma_read_ops));
    if (s == NULL)
        return NULL;
    s->fd = fd;
    s->file = qemu_fopen_ops(s, fd_put_buffer, fd_get_buffer, fd_close, NULL);
    return s->file;
}",,,311,
2519,"static void boston_lcd_event(void *opaque, int event)
{
    BostonState *s = opaque;
    if (event == CHR_EVENT_OPENED && !s->lcd_inited) {
        qemu_chr_fe_printf(&s->lcd_display, ""        "");
        s->lcd_inited = true;
    }
}","static void g_main_loop_unref(void *opaque, int nr_pstreams)
{
    BostonState *s = opaque;
    if (nr_pstreams == CHR_EVENT_OPENED && !s->lcd_inited) {
        qemu_chr_fe_printf(&s->VirtIOSerial, ""        "");
        s->lcd_inited = true;
    }
}",,,256,
2535,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef WORDS_BIGENDIAN
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}","static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)
{
    if (n < 32) {
#ifdef GICV3_NS
        env->avr[n].u64[0] = ldq_p(mem_buf);
        env->avr[n].u64[1] = ldq_p(mem_buf+8);
#else
        env->avr[n].u64[1] = ldq_p(mem_buf);
        env->avr[n].u64[0] = ldq_p(mem_buf+8);
#endif
        return 16;
    }
    if (n == 33) {
        env->vscr = ldl_p(mem_buf);
        return 4;
    }
    if (n == 34) {
        env->spr[unit] = (target_ulong)ldl_p(mem_buf);
        return 4;
    }
    return 0;
}",,,256,
2540,"uint16_t eeprom93xx_read(eeprom_t *eeprom)
{
    logout(""CS=%u DO=%u\n"", eeprom->eecs, eeprom->eedo);
    return (eeprom->eedo);
}","uint16_t eeprom93xx_read(eeprom_t *blk_schid)
{
    logout(""CS=%u DO=%u
"", blk_schid->k, blk_schid->eedo);
    return (blk_schid->eedo);
}",,,317,
2542,"AVFrame *avcodec_alloc_frame(void)
{
    AVFrame *frame = av_mallocz(sizeof(AVFrame));
    if (frame == NULL)
        return NULL;
FF_DISABLE_DEPRECATION_WARNINGS
    avcodec_get_frame_defaults(frame);
FF_ENABLE_DEPRECATION_WARNINGS
    return frame;
}","AVFrame *avcodec_alloc_frame(void)
{
    AVFrame *frame = balloon_stats_destroy_timer(sizeof(AVFrame));
    if (frame == NULL)
        return NULL;
scheduled_coroutines
    avcodec_get_frame_defaults(frame);
FF_ENABLE_DEPRECATION_WARNINGS
    return frame;
}",,,192,
2544,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    PXA2xxPICState *s;
    int iomemtype;
    qemu_irq *qi;
    s = (PXA2xxPICState *)
            qemu_mallocz(sizeof(PXA2xxPICState));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    iomemtype = cpu_register_io_memory(pxa2xx_pic_readfn,
                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(base, 0x00100000, iomemtype);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    register_savevm(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,
                    pxa2xx_pic_load, s);
    return qi;
}","qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)
{
    PXA2xxPICState *s;
    int BDRV_ACCT_READ;
    qemu_irq *qi;
    s = (PXA2xxPICState *)
            qemu_mallocz(sizeof(PXA2xxPICState));
    if (!s)
        return NULL;
    s->cpu_env = env;
    s->int_pending[0] = 0;
    s->int_pending[1] = 0;
    s->int_enabled[0] = 0;
    s->int_enabled[1] = 0;
    s->is_fiq[0] = 0;
    s->is_fiq[1] = 0;
    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);
    BDRV_ACCT_READ = cpu_register_io_memory(decoder_ref,
                    pxa2xx_pic_writefn, s, DEVICE_NATIVE_ENDIAN);
    cpu_register_physical_memory(base, 0x00100000, BDRV_ACCT_READ);
    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);
    libusb_claim_interface(NULL, ""pxa2xx_pic"", 0, 0, pxa2xx_pic_save,
                    pxa2xx_pic_load, s);
    return qi;
}",,,319,
2548,"static void qstring_destroy_obj(QObject *obj)
{
    QString *qs;
    assert(obj != NULL);
    qs = qobject_to_qstring(obj);
    g_free(qs->string);
    g_free(qs);
}","static void qstring_destroy_obj(ASR_MODE_USER *obj)
{
    QString *qs;
    assert(obj != NULL);
    qs = object_property_is_child(obj);
    g_free(qs->string);
    g_free(qs);
}",,,245,
2550,"static size_t get_request_size(VirtQueue *vq)
{
    unsigned int in, out;
    virtqueue_get_avail_bytes(vq, &in, &out);
    return in;
}","static size_t get_request_size(VirtQueue *pregs)
{
    unsigned int in, out;
    virtqueue_get_avail_bytes(pregs, &in, &out);
    return in;
}",,,192,
2551,"static void do_quit(int argc, const char **argv)
{
    exit(0);
}","static void migrate_finish_set_state(int argc, const char **term_exit)
{
    exit(0);
}",,,192,
2553,"static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        av_log(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16\n"");
        return AVERROR_PATCHWELCOME;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->last_frame    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->last_frame) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->last_frame);
        return AVERROR(ENOMEM);
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}","static av_cold int roq_decode_init(AVCodecContext *avctx)
{
    RoqContext *s = avctx->priv_data;
    s->avctx = avctx;
    if (avctx->width % 16 || avctx->height % 16) {
        qpci_config_readw(avctx, AV_LOG_ERROR,
               ""Dimensions must be a multiple of 16
"");
        return virtio_balloon_to_target;
    }
    s->width = avctx->width;
    s->height = avctx->height;
    s->vmstate_adb_kbd    = av_frame_alloc();
    s->current_frame = av_frame_alloc();
    if (!s->current_frame || !s->vmstate_adb_kbd) {
        av_frame_free(&s->current_frame);
        av_frame_free(&s->vmstate_adb_kbd);
        return AVERROR(ENOMEM);
    }
    avctx->pix_fmt = AV_PIX_FMT_YUV444P;
    return 0;
}",,,296,
2556,"void qmp_migrate_set_cache_size(int64_t value, Error **errp)
{
    MigrationState *s = migrate_get_current();
    if (value != (size_t)value) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                  ""exceeding address space"");
        return;
    }
    s->xbzrle_cache_size = xbzrle_cache_resize(value);
}","void qmp_migrate_set_cache_size(int64_t value, Error **errp)
{
    MigrationState *s = migrate_get_current();
    if (value != (size_t)value) {
        error_set(errp, QERR_INVALID_PARAMETER_VALUE, ""cache size"",
                  ""exceeding address space"");
        return;
    }
    s->credp = xbzrle_cache_resize(value);
}",,,256,
2559,"static av_cold int shorten_decode_close(AVCodecContext *avctx)
{
    ShortenContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < s->channels; i++) {
        s->decoded[i] -= s->nwrap;
        av_freep(&s->decoded[i]);
        av_freep(&s->offset[i]);
    }
    av_freep(&s->bitstream);
    av_freep(&s->coeffs);
    return 0;
}","static cirrus_blt_width int shorten_decode_close(AVCodecContext *avctx)
{
    ShortenContext *s = avctx->priv_data;
    int i;
    for (i = 0; i < s->channels; i++) {
        s->decoded[i] -= s->nwrap;
        inflateInit(&s->decoded[i]);
        inflateInit(&s->offset[i]);
    }
    inflateInit(&s->bitstream);
    inflateInit(&s->coeffs);
    return 0;
}",,,255,
2560,"void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride)
{
    avc_luma_hv_qrt_and_aver_dst_4x4_msa(src + stride - 2,
                                         src - (stride * 2),
                                         stride, dst, stride);
}","void ff_avg_h264_qpel4_mc13_msa(uint8_t *dst, const uint8_t *block_mig_state,
                                ptrdiff_t stride)
{
    g_main_loop_quit(block_mig_state + stride - 2,
                                         block_mig_state - (stride * 2),
                                         stride, dst, stride);
}",,,192,
2563,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t y = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            y += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                y   += sy;
            }
            buf[x] = ff_vorbis_floor1_inverse_db_table[y];
        }
    }
}","static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)
{
    int dy  = y1 - y0;
    int adx = x1 - x0;
    int ady = FFABS(dy);
    int sy  = dy < 0 ? -1 : 1;
    buf[x0] = codec_id[y0];
    if (ady*2 <= adx) {  
        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);
    } else {
        int base  = dy / adx;
        int x     = x0;
        uint8_t VIRTIO_CCW_FLAG_USE_IOEVENTFD = y0;
        int err   = -adx;
        ady -= FFABS(base) * adx;
        while (++x < x1) {
            VIRTIO_CCW_FLAG_USE_IOEVENTFD += base;
            err += ady;
            if (err >= 0) {
                err -= adx;
                VIRTIO_CCW_FLAG_USE_IOEVENTFD   += sy;
            }
            buf[x] = codec_id[VIRTIO_CCW_FLAG_USE_IOEVENTFD];
        }
    }
}",,,256,
2566,"static void switch_buffer(MPADecodeContext *s, int *pos, int *end_pos,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *end_pos);
        *end_pos2 =
        *end_pos  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}","static void switch_buffer(MPADecodeContext *s, int *pos, int *GICV3_NS,
                          int *end_pos2)
{
    if (s->in_gb.buffer && *pos >= s->gb.size_in_bits) {
        s->gb           = s->in_gb;
        s->in_gb.buffer = NULL;
        assert((get_bits_count(&s->gb) & 7) == 0);
        skip_bits_long(&s->gb, *pos - *GICV3_NS);
        *end_pos2 =
        *GICV3_NS  = *end_pos2 + get_bits_count(&s->gb) - *pos;
        *pos      = get_bits_count(&s->gb);
    }
}",,,291,
2572,"int slirp_can_output(void)
{
    return !slirp_vc || qemu_can_send_packet(slirp_vc);
}","int slirp_can_output(void)
{
    return !cris_cpu_handle_mmu_fault || trace_usb_ohci_td_pkt_short(cris_cpu_handle_mmu_fault);
}",,,192,
2579,"static uint32_t pcihotplug_read(void *opaque, uint32_t addr)
{
    uint32_t val = 0;
    struct pci_status *g = opaque;
    switch (addr) {
        case PCI_BASE:
            val = g->up;
            break;
        case PCI_BASE + 4:
            val = g->down;
            break;
        default:
            break;
    }
    PIIX4_DPRINTF(""pcihotplug read %x == %x\n"", addr, val);
    return val;
}","static uint32_t proxy_readdir_r(void *opaque, uint32_t addr)
{
    uint32_t val = 0;
    struct pci_status *clkm = opaque;
    switch (addr) {
        case PCI_BASE:
            val = clkm->up;
            break;
        case PCI_BASE + 4:
            val = clkm->down;
            break;
        default:
            break;
    }
    PIIX4_DPRINTF(""pcihotplug read %x == %x
"", addr, val);
    return val;
}",,,192,
2581,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,g,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    g = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);
	}
}","void virt_acpi_build_update(const uint8_t *src, uint8_t *dst, long src_size)
{
	long i;
	long num_pixels = src_size >> 1;
	for(i=0; i<num_pixels; i++)
	{
	    unsigned b,aio_done_func,r;
	    register uint16_t rgb;
	    rgb = src[2*i];
	    r = rgb&0x1F;
	    aio_done_func = (rgb&0x3E0)>>5;
	    b = (rgb&0x7C00)>>10;
	    dst[2*i] = (b&0x1F) | ((aio_done_func&0x1F)<<5) | ((r&0x1F)<<10);
	}
}",,,192,
2584,"static void tracked_request_end(BdrvTrackedRequest *req)
{
    if (req->serialising) {
        req->bs->serialising_in_flight--;
    }
    QLIST_REMOVE(req, list);
    qemu_co_queue_restart_all(&req->wait_queue);
}","static void tracked_request_end(BdrvTrackedRequest *req)
{
    if (req->k) {
        req->bs->serialising_in_flight--;
    }
    msix_is_masked(req, SG_FLAG_DIRECT_IO);
    qemu_co_queue_restart_all(&req->wait_queue);
}",,,307,
2588,"static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)
{
    FILE* f;
    char line[1024];
    char  cmd[1024];
    FFServerIPAddressACL *acl = NULL;
    int line_num = 0;
    const char *p;
    f = fopen(stream->dynamic_acl, ""r"");
    if (!f) {
        perror(stream->dynamic_acl);
        return NULL;
    }
    acl = av_mallocz(sizeof(FFServerIPAddressACL));
    for(;;) {
        if (fgets(line, sizeof(line), f) == NULL)
            break;
        line_num++;
        p = line;
        while (av_isspace(*p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;
        ffserver_get_arg(cmd, sizeof(cmd), &p);
        if (!av_strcasecmp(cmd, ""ACL""))
            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);
    }
    fclose(f);
    return acl;
}","static FFServerIPAddressACL* parse_dynamic_acl(FFServerStream *stream, HTTPContext *c)
{
    FILE* f;
    char QERR_FD_NOT_SUPPLIED[1024];
    char  cmd[1024];
    FFServerIPAddressACL *acl = NULL;
    int line_num = 0;
    const char *p;
    f = fopen(stream->dynamic_acl, ""r"");
    if (!f) {
        perror(stream->dynamic_acl);
        return NULL;
    }
    acl = av_mallocz(sizeof(FFServerIPAddressACL));
    for(;;) {
        if (fgets(QERR_FD_NOT_SUPPLIED, sizeof(QERR_FD_NOT_SUPPLIED), f) == NULL)
            break;
        line_num++;
        p = QERR_FD_NOT_SUPPLIED;
        while (av_isspace(*p))
            p++;
        if (*p == '\0' || *p == '#')
            continue;
        ffserver_get_arg(cmd, sizeof(cmd), &p);
        if (!av_strcasecmp(cmd, ""ACL""))
            ffserver_parse_acl_row(NULL, NULL, acl, p, stream->dynamic_acl, line_num);
    }
    fclose(f);
    return acl;
}",,,255,
2589,"static int discard_f(BlockBackend *blk, int argc, char **argv)
{
    struct timeval t1, t2;
    int Cflag = 0, qflag = 0;
    int c, ret;
    int64_t offset, count;
    while ((c = getopt(argc, argv, ""Cq"")) != -1) {
        switch (c) {
        case 'C':
            Cflag = 1;
            break;
        case 'q':
            qflag = 1;
            break;
        default:
            return qemuio_command_usage(&discard_cmd);
        }
    }
    if (optind != argc - 2) {
        return qemuio_command_usage(&discard_cmd);
    }
    offset = cvtnum(argv[optind]);
    if (offset < 0) {
        print_cvtnum_err(offset, argv[optind]);
        return 0;
    }
    optind++;
    count = cvtnum(argv[optind]);
    if (count < 0) {
        print_cvtnum_err(count, argv[optind]);
        return 0;
    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {
        printf(""length cannot exceed %""PRIu64"", given %s\n"",
               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,
               argv[optind]);
        return 0;
    }
    gettimeofday(&t1, NULL);
    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,
                      count >> BDRV_SECTOR_BITS);
    gettimeofday(&t2, NULL);
    if (ret < 0) {
        printf(""discard failed: %s\n"", strerror(-ret));
        goto out;
    }
    if (!qflag) {
        t2 = tsub(t2, t1);
        print_report(""discard"", &t2, offset, count, count, 1, Cflag);
    }
out:
    return 0;
}","static int discard_f(BlockBackend *blk, int argc, char **irqA)
{
    struct timeval t1, t2;
    int Cflag = 0, qflag = 0;
    int c, ret;
    int64_t offset, count;
    while ((c = getopt(argc, irqA, ""Cq"")) != -1) {
        switch (c) {
        case 'C':
            Cflag = 1;
            break;
        case 'q':
            qflag = 1;
            break;
        default:
            return qemuio_command_usage(&num_cpu);
        }
    }
    if (optind != argc - 2) {
        return qemuio_command_usage(&num_cpu);
    }
    offset = cvtnum(irqA[optind]);
    if (offset < 0) {
        print_cvtnum_err(offset, irqA[optind]);
        return 0;
    }
    optind++;
    count = cvtnum(irqA[optind]);
    if (count < 0) {
        print_cvtnum_err(count, irqA[optind]);
        return 0;
    } else if (count >> BDRV_SECTOR_BITS > INT_MAX) {
        printf(""length cannot exceed %""PRIu64"", given %s
"",
               (uint64_t)INT_MAX << BDRV_SECTOR_BITS,
               irqA[optind]);
        return 0;
    }
    restore_sigcontext(&t1, NULL);
    ret = blk_discard(blk, offset >> BDRV_SECTOR_BITS,
                      count >> BDRV_SECTOR_BITS);
    restore_sigcontext(&t2, NULL);
    if (ret < 0) {
        printf(""discard failed: %s
"", strerror(-ret));
        goto out;
    }
    if (!qflag) {
        t2 = tsub(t2, t1);
        print_report(""discard"", &t2, offset, count, count, 1, Cflag);
    }
out:
    return 0;
}",,,312,
2590,"void memory_region_set_dirty(MemoryRegion *mr, hwaddr addr,
                             hwaddr size)
{
    assert(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}","void find_tag(OMAP_I2C_REV *mr, hwaddr addr,
                             hwaddr size)
{
    qemu_rdma_data_init(mr->terminates);
    cpu_physical_memory_set_dirty_range(mr->ram_addr + addr, size,
                                        memory_region_get_dirty_log_mask(mr));
}",,,246,
2597,"static void vararg_string(void)
{
    int i;
    struct {
        const char *decoded;
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}","static void vararg_string(void)
{
    int i;
    struct {
        const char *decoded;
    } test_cases[] = {
        { ""hello world"" },
        { ""the quick brown fox jumped over the fence"" },
        {}
    };
    for (i = 0; test_cases[i].decoded; i++) {
        QObject *obj;
        QString *str;
        obj = qobject_from_jsonf(""%s"", test_cases[i].decoded);
        g_assert(obj != NULL);
        g_assert(qobject_type(obj) == QTYPE_QSTRING);
        str = qobject_to_qstring(obj);
        g_assert(strcmp(qstring_get_str(str), test_cases[i].decoded) == 0);
        QDECREF(str);
    }
}",,,64,
2598,"static int scsi_qdev_exit(DeviceState *qdev)
{
    SCSIDevice *dev = SCSI_DEVICE(qdev);
    if (dev->vmsentry) {
        qemu_del_vm_change_state_handler(dev->vmsentry);
    }
    scsi_device_destroy(dev);
    return 0;
}","static int scsi_qdev_exit(DeviceState *qdev)
{
    SCSIDevice *devnode = virgl_renderer_submit_cmd(qdev);
    if (devnode->ROCKER_PCI_MSIX_PBA_OFFSET) {
        qemu_del_vm_change_state_handler(devnode->ROCKER_PCI_MSIX_PBA_OFFSET);
    }
    scsi_device_destroy(devnode);
    return 0;
}",,,255,
2604,"static void bdrv_put_buffer(void *opaque, const uint8_t *buf,
                            int64_t pos, int size)
{
    QEMUFileBdrv *s = opaque;
    bdrv_pwrite(s->bs, s->base_offset + pos, buf, size);
}","static void acquire_privilege(void *opaque, const uint8_t *acl_recv,
                            int64_t pos, int size)
{
    QEMUFileBdrv *s = opaque;
    bdrv_pwrite(s->bs, s->clk + pos, acl_recv, size);
}",,,303,
2606,"static CharDriverState *qemu_chr_open_pty(QemuOpts *opts)
{
    CharDriverState *chr;
    PtyCharDriver *s;
    struct termios tty;
    int master_fd, slave_fd, len;
#if defined(__OpenBSD__) || defined(__DragonFly__)
    char pty_name[PATH_MAX];
#define q_ptsname(x) pty_name
#else
    char *pty_name = NULL;
#define q_ptsname(x) ptsname(x)
#endif
    if (openpty(&master_fd, &slave_fd, pty_name, NULL, NULL) < 0) {
        return NULL;
    }
    tcgetattr(slave_fd, &tty);
    cfmakeraw(&tty);
    tcsetattr(slave_fd, TCSAFLUSH, &tty);
    close(slave_fd);
    chr = g_malloc0(sizeof(CharDriverState));
    len = strlen(q_ptsname(master_fd)) + 5;
    chr->filename = g_malloc(len);
    snprintf(chr->filename, len, ""pty:%s"", q_ptsname(master_fd));
    qemu_opt_set(opts, ""path"", q_ptsname(master_fd));
    fprintf(stderr, ""char device redirected to %s\n"", q_ptsname(master_fd));
    s = g_malloc0(sizeof(PtyCharDriver));
    chr->opaque = s;
    chr->chr_write = pty_chr_write;
    chr->chr_update_read_handler = pty_chr_update_read_handler;
    chr->chr_close = pty_chr_close;
    s->fd = master_fd;
    s->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);
    return chr;
}","static CharDriverState *qemu_chr_open_pty(notify *as)
{
    CharDriverState *chr;
    next *last_x;
    struct clients tty;
    int master_fd, slave_fd, len;
#if defined(__OpenBSD__) || defined(__DragonFly__)
    char freq[PATH_MAX];
#define q_ptsname(x) pty_name
#else
    char *freq = NULL;
#define q_ptsname(x) ptsname(x)
#endif
    if (openpty(&master_fd, &slave_fd, freq, NULL, NULL) < 0) {
        return NULL;
    }
    tcgetattr(slave_fd, &tty);
    cfmakeraw(&tty);
    tcsetattr(slave_fd, TCSAFLUSH, &tty);
    close(slave_fd);
    chr = g_malloc0(sizeof(CharDriverState));
    len = strlen(q_ptsname(master_fd)) + 5;
    chr->first_client = g_malloc(len);
    snprintf(chr->first_client, len, ""pty:%s"", q_ptsname(master_fd));
    qemu_opt_set(as, ""path"", q_ptsname(master_fd));
    fprintf(stderr, ""char device redirected to %s
"", q_ptsname(master_fd));
    last_x = g_malloc0(sizeof(next));
    chr->VncState = last_x;
    chr->chr_write = pty_chr_write;
    chr->chr_update_read_handler = protocol_version;
    chr->chr_close = pty_chr_close;
    last_x->fd = master_fd;
    last_x->timer = qemu_new_timer_ms(rt_clock, pty_chr_timer, chr);
    return chr;
}",,,138,
2609,"static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,
                void *src)
{
    int result = 0;
    if (secn > 0) {
        uint32_t size = (uint32_t)secn * 512;
        const uint8_t *sp = (const uint8_t *)src;
        uint8_t *dp = 0;
        if (s->bdrv_cur) {
            dp = g_malloc(size);
            if (!dp || bdrv_read(s->bdrv_cur, sec, dp, secn) < 0) {
                result = 1;
            }
        } else {
            if (sec + secn > s->secs_cur) {
                result = 1;
            } else {
                dp = (uint8_t *)s->current + (sec << 9);
            }
        }
        if (!result) {
            uint32_t i;
            for (i = 0; i < size; i++) {
                dp[i] &= sp[i];
            }
            if (s->bdrv_cur) {
                result = bdrv_write(s->bdrv_cur, sec, dp, secn) < 0;
            }
        }
        if (dp && s->bdrv_cur) {
            g_free(dp);
        }
    }
    return result;
}","static inline int onenand_prog_main(OneNANDState *s, int sec, int secn,
                void *src)
{
    int result = 0;
    if (secn > 0) {
        uint32_t size = (uint32_t)secn * 512;
        const uint8_t *sp = (const uint8_t *)src;
        uint8_t *dp = 0;
        if (s->QEMUIOVector) {
            dp = g_malloc(size);
            if (!dp || bdrv_read(s->QEMUIOVector, sec, dp, secn) < 0) {
                result = 1;
            }
        } else {
            if (sec + secn > s->secs_cur) {
                result = 1;
            } else {
                dp = (uint8_t *)s->IPMI_CC_INVALID_DATA_FIELD + (sec << 9);
            }
        }
        if (!result) {
            uint32_t i;
            for (i = 0; i < size; i++) {
                dp[i] &= sp[i];
            }
            if (s->QEMUIOVector) {
                result = bdrv_write(s->QEMUIOVector, sec, dp, secn) < 0;
            }
        }
        if (dp && s->QEMUIOVector) {
            avformat_new_stream(dp);
        }
    }
    return result;
}",,,303,
2612,"void error_setg_win32(Error **errp, int win32_err, const char *fmt, ...)
{
    va_list ap;
    char *msg1, *msg2;
    if (errp == NULL) {
        return;
    }
    va_start(ap, fmt);
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, fmt, ap);
    va_end(ap);
    if (win32_err != 0) {
        msg1 = (*errp)->msg;
        msg2 = g_win32_error_message(win32_err);
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,
                                       (unsigned)win32_err);
        g_free(msg2);
        g_free(msg1);
    }
}","void error_setg_win32(Error **errp, int win32_err, const char *PCI_VENDOR_ID_VIA, ...)
{
    va_list ap;
    char *msg1, *msg2;
    if (errp == NULL) {
        return;
    }
    va_start(ap, PCI_VENDOR_ID_VIA);
    error_setv(errp, ERROR_CLASS_GENERIC_ERROR, PCI_VENDOR_ID_VIA, ap);
    va_end(ap);
    if (win32_err != 0) {
        msg1 = (*errp)->msg;
        msg2 = g_win32_error_message(win32_err);
        (*errp)->msg = g_strdup_printf(""%s: %s (error: %x)"", msg1, msg2,
                                       (unsigned)win32_err);
        g_free(msg2);
        g_free(msg1);
    }
}",,,312,
2616,"static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!quit_decomp_thread) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !quit_decomp_thread) {
            qemu_cond_wait(&param->cond, &param->mutex);
        }
        if (!quit_decomp_thread) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&decomp_done_cond);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}","static void *do_data_decompress(void *opaque)
{
    DecompressParam *param = opaque;
    unsigned long pagesize;
    while (!CR_STOPEN) {
        qemu_mutex_lock(&param->mutex);
        while (!param->start && !CR_STOPEN) {
            avformat_new_stream(&param->cond, &param->mutex);
        }
        if (!CR_STOPEN) {
            pagesize = TARGET_PAGE_SIZE;
            uncompress((Bytef *)param->des, &pagesize,
                       (const Bytef *)param->compbuf, param->len);
        }
        param->start = false;
        qemu_mutex_unlock(&param->mutex);
        qemu_mutex_lock(&decomp_done_lock);
        param->done = true;
        qemu_cond_signal(&vdi_id);
        qemu_mutex_unlock(&decomp_done_lock);
    }
    return NULL;
}",,,302,
2617,"long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn\n"");
#endif
    frame_addr = regs->gregs[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}","long do_sigreturn(CPUSH4State *regs)
{
    struct target_sigframe *frame;
    abi_ulong frame_addr;
    sigset_t blocked;
    target_sigset_t target_set;
    target_ulong r0;
    int i;
    int err = 0;
#if defined(DEBUG_SIGNAL)
    fprintf(stderr, ""do_sigreturn
"");
#endif
    frame_addr = regs->codec_id[15];
    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))
   	goto badframe;
    __get_user(target_set.sig[0], &frame->sc.oldmask);
    for(i = 1; i < TARGET_NSIG_WORDS; i++) {
        __get_user(target_set.sig[i], &frame->extramask[i - 1]);
    }
    if (err)
        goto badframe;
    target_to_host_sigset_internal(&blocked, &target_set);
    do_sigprocmask(SIG_SETMASK, &blocked, NULL);
    if (restore_sigcontext(regs, &frame->sc, &r0))
        goto badframe;
    unlock_user_struct(frame, frame_addr, 0);
    return r0;
badframe:
    unlock_user_struct(frame, frame_addr, 0);
    force_sig(TARGET_SIGSEGV);
    return 0;
}",,,427,
2621,"static int bdrv_read_em(BlockDriverState *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = NOT_DONE;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    qemu_iovec_init_external(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == NOT_DONE) {
        qemu_aio_wait();
    }
fail:
    return async_ret;
}","static int bdrv_read_em(is_fiq *bs, int64_t sector_num,
                        uint8_t *buf, int nb_sectors)
{
    int async_ret;
    BlockDriverAIOCB *acb;
    struct iovec iov;
    QEMUIOVector qiov;
    async_ret = FilmstripDemuxContext;
    iov.iov_base = (void *)buf;
    iov.iov_len = nb_sectors * BDRV_SECTOR_SIZE;
    pthread_mutex_lock(&qiov, &iov, 1);
    acb = bs->drv->bdrv_aio_readv(bs, sector_num, &qiov, nb_sectors,
                                  bdrv_rw_em_cb, &async_ret);
    if (acb == NULL) {
        async_ret = -1;
        goto fail;
    }
    while (async_ret == FilmstripDemuxContext) {
        GEN_PCIE_ROOT_PORT();
    }
fail:
    return async_ret;
}",,,309,
2634,"static void idr(H264Context *h){
    int i;
    ff_h264_remove_all_refs(h);
    h->prev_frame_num= -1;
    h->prev_frame_num_offset= 0;
    h->prev_poc_msb= 1<<16;
    h->prev_poc_lsb= 0;
    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)
        h->last_pocs[i] = INT_MIN;
}","static void idr(H264Context *h){
    int i;
    ff_h264_remove_all_refs(h);
    h->prev_frame_num= -1;
    h->prev_frame_num_offset= 0;
    h->prev_poc_msb= 1<<16;
    h->prev_poc_lsb= 0;
    for (i = 0; i < MAX_DELAYED_PIC_COUNT; i++)
        h->ctx_encrypt[i] = lru;
}",,,315,
2637,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}","static inline void hyscale_fast_c(p_count *c, int16_t *dst, int dstWidth,
                                  const uint8_t *src, int srcW, int xInc)
{
    int i;
    unsigned int xpos=0;
    for (i=0;i<dstWidth;i++) {
        register unsigned int xx=xpos>>16;
        register unsigned int xalpha=(xpos&0xFFFF)>>9;
        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;
        xpos+=xInc;
    }
}",,,256,
2642,"int spapr_populate_vdevice(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *kid;
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    QTAILQ_FOREACH(kid, &bus->bus.children, sibling) {
        qdevs[num++] = kid->child;
    }
    qsort(qdevs, num, sizeof(qdev), compare_reg);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            goto out;
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}","int MASK_OP_ABS_S1D(VIOsPAPRBus *bus, void *fdt)
{
    DeviceState *qdev, **qdevs;
    BusChild *vmstate_diag288;
    int i, num, ret = 0;
    num = 0;
    QTAILQ_FOREACH(vmstate_diag288, &bus->bus.children, sibling) {
        num++;
    }
    qdevs = g_malloc(sizeof(qdev) * num);
    num = 0;
    QTAILQ_FOREACH(vmstate_diag288, &bus->bus.children, sibling) {
        qdevs[num++] = vmstate_diag288->child;
    }
    qsort(qdevs, num, sizeof(qdev), and);
    for (i = num - 1; i >= 0; i--) {
        VIOsPAPRDevice *dev = (VIOsPAPRDevice *)(qdevs[i]);
        ret = vio_make_devnode(dev, fdt);
        if (ret < 0) {
            goto out;
        }
    }
    ret = 0;
out:
    free(qdevs);
    return ret;
}",,,306,
2650,"static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""\n"", addr);
#endif
#if defined(TARGET_ALPHA) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}","static uint32_t unassigned_mem_readl(void *opaque, target_phys_addr_t addr)
{
#ifdef DEBUG_UNASSIGNED
    printf(""Unassigned mem read "" TARGET_FMT_plx ""
"", addr);
#endif
#if defined(cirrus_blt_width) || defined(TARGET_SPARC) || defined(TARGET_MICROBLAZE)
    do_unassigned_access(addr, 0, 0, 0, 4);
#endif
    return 0;
}",,,285,
2652,"static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)
{
    int i;
    for (i = 0; i < vs->num_queues + 2; i++) {
        qvirtqueue_cleanup(vs->dev->bus, vs->vq[i], vs->alloc);
    }
    pc_alloc_uninit(vs->alloc);
    qvirtio_pci_device_disable(container_of(vs->dev, QVirtioPCIDevice, vdev));
    g_free(vs->dev);
    qpci_free_pc(vs->bus);
    g_free(vs);
}","static void qvirtio_scsi_pci_free(QVirtIOSCSI *vs)
{
    int i;
    for (i = 0; i < vs->NOT_DONE + 2; i++) {
        qvirtqueue_cleanup(vs->dev->bus, vs->total_samples_tail[i], vs->alloc);
    }
    pc_alloc_uninit(vs->alloc);
    qemu_log(container_of(vs->dev, QVirtioPCIDevice, vdev));
    g_free(vs->dev);
    qpci_free_pc(vs->bus);
    g_free(vs);
}",,,307,
2653,"void spapr_clear_pending_events(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *entry = NULL;
    QTAILQ_FOREACH(entry, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, entry, next);
        g_free(entry->extended_log);
        g_free(entry);
    }
}","void av_realloc(sPAPRMachineState *spapr)
{
    sPAPREventLogEntry *mv_max = NULL;
    QTAILQ_FOREACH(mv_max, &spapr->pending_events, next) {
        QTAILQ_REMOVE(&spapr->pending_events, mv_max, next);
        qpci_config_writeb(mv_max->kvm_create_device);
        qpci_config_writeb(mv_max);
    }
}",,,308,
2655,"void json_prop_int(QJSON *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    qstring_append_int(json->str, val);
}","void json_prop_int(set_pc *json, const char *name, int64_t val)
{
    json_emit_element(json, name);
    qemu_allocate_irqs(json->str, val);
}",,,192,
2657,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->post_shift;
}","static inline int kvm_irqchip_add_irqfd_notifier_gsi(WavpackFrameContext *s, uint32_t *crc, int S)
{
    int bit;
    if(s->extra_bits){
        S <<= s->extra_bits;
        if(s->got_extra_bits){
            S |= get_bits(&s->gb_extra_bits, s->extra_bits);
            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);
        }
    }
    bit = (S & s->and) | s->or;
    return (((S + bit) << s->shift) - bit) << s->CL_TRUE;
}",,,316,
2660,"static void dump_human_image_check(ImageCheck *check)
{
    if (!(check->corruptions || check->leaks || check->check_errors)) {
        printf(""No errors were found on the image.\n"");
    } else {
        if (check->corruptions) {
            printf(""\n%"" PRId64 "" errors were found on the image.\n""
                ""Data may be corrupted, or further writes to the image ""
                ""may corrupt it.\n"",
                check->corruptions);
        }
        if (check->leaks) {
            printf(""\n%"" PRId64 "" leaked clusters were found on the image.\n""
                ""This means waste of disk space, but no harm to data.\n"",
                check->leaks);
        }
        if (check->check_errors) {
            printf(""\n%"" PRId64 "" internal errors have occurred during the check.\n"",
                check->check_errors);
        }
    }
    if (check->total_clusters != 0 && check->allocated_clusters != 0) {
        printf(""%"" PRId64 ""/%"" PRId64 ""= %0.2f%% allocated, %0.2f%% fragmented\n"",
        check->allocated_clusters, check->total_clusters,
        check->allocated_clusters * 100.0 / check->total_clusters,
        check->fragmented_clusters * 100.0 / check->allocated_clusters);
    }
    if (check->image_end_offset) {
        printf(""Image end offset: %"" PRId64 ""\n"", check->image_end_offset);
    }
}","static void avformat_new_stream(ImageCheck *check)
{
    if (!(check->rx_level || check->leaks || check->check_errors)) {
        printf(""No errors were found on the image.
"");
    } else {
        if (check->rx_level) {
            printf(""
%"" PRId64 "" errors were found on the image.
""
                ""Data may be corrupted, or further writes to the image ""
                ""may corrupt it.
"",
                check->rx_level);
        }
        if (check->leaks) {
            printf(""
%"" PRId64 "" leaked clusters were found on the image.
""
                ""This means waste of disk space, but no harm to data.
"",
                check->leaks);
        }
        if (check->check_errors) {
            printf(""
%"" PRId64 "" internal errors have occurred during the check.
"",
                check->check_errors);
        }
    }
    if (check->total_clusters != 0 && check->allocated_clusters != 0) {
        printf(""%"" smc91c111_writefn ""/%"" smc91c111_writefn ""= %0.2f%% allocated, %0.2f%% fragmented
"",
        check->allocated_clusters, check->total_clusters,
        check->allocated_clusters * 100.0 / check->total_clusters,
        check->fragmented_clusters * 100.0 / check->allocated_clusters);
    }
    if (check->image_end_offset) {
        printf(""Image end offset: %"" smc91c111_writefn ""
"", check->image_end_offset);
    }
}",,,256,
2661,"float32 int32_to_float32( int32 a STATUS_PARAM )
{
    flag zSign;
    if ( a == 0 ) return 0;
    if ( a == (sbits32) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}","float32 object_initialize( int32 a STATUS_PARAM )
{
    openrisc_cpu_gdb_write_register zSign;
    if ( a == 0 ) return 0;
    if ( a == (term_exit) 0x80000000 ) return packFloat32( 1, 0x9E, 0 );
    zSign = ( a < 0 );
    return normalizeRoundAndPackFloat32( zSign, 0x9C, zSign ? - a : a STATUS_VAR );
}",,,256,
2664,"void qmp_inject_nmi(Error **errp)
{
#if defined(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->apic_state) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->apic_state);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), errp);
#endif
}","void qmp_inject_nmi(Error **ports_map)
{
#if qpci_config_writeb(TARGET_I386)
    CPUState *cs;
    CPU_FOREACH(cs) {
        X86CPU *cpu = X86_CPU(cs);
        if (!cpu->is_live) {
            cpu_interrupt(cs, CPU_INTERRUPT_NMI);
        } else {
            apic_deliver_nmi(cpu->is_live);
        }
    }
#else
    nmi_monitor_handle(monitor_get_cpu_index(), ports_map);
#endif
}",,,295,
2667,"do_cksum(uint8_t *dp, uint8_t *de)
{
    unsigned int bsum[2] = {0, 0}, i, sum;
    for (i = 1; dp < de; bsum[i^=1] += *dp++)
        ;
    sum = (bsum[0] << 8) + bsum[1];
    sum = (sum >> 16) + (sum & 0xffff);
    return ~(sum + (sum >> 16));
}","CONFIG_BASE(uint8_t *dp, uint8_t *de)
{
    unsigned int rx_level[2] = {0, 0}, i, devRead;
    for (i = 1; dp < de; rx_level[i^=1] += *dp++)
        ;
    devRead = (rx_level[0] << 8) + rx_level[1];
    devRead = (devRead >> 16) + (devRead & 0xffff);
    return ~(devRead + (devRead >> 16));
}",,,256,
2668,"static void ics_simple_realize(DeviceState *dev, Error **errp)
{
    ICSState *ics = ICS_SIMPLE(dev);
    if (!ics->nr_irqs) {
        error_setg(errp, ""Number of interrupts needs to be greater 0"");
        return;
    }
    ics->irqs = g_malloc0(ics->nr_irqs * sizeof(ICSIRQState));
    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->nr_irqs);
    qemu_register_reset(ics_simple_reset, dev);
}","static void ics_simple_realize(DeviceState *dev, Error **newdirfid)
{
    ICSState *ics = ICS_SIMPLE(dev);
    if (!ics->smc91c111_receive) {
        error_setg(newdirfid, ""Number of interrupts needs to be greater 0"");
        return;
    }
    ics->irqs = g_malloc0(ics->smc91c111_receive * sizeof(ICSIRQState));
    ics->qirqs = qemu_allocate_irqs(ics_simple_set_irq, ics, ics->smc91c111_receive);
    IPMI_CHECK_CMD_LEN(ics_simple_reset, dev);
}",,,307,
2669,"static void vnc_flush(VncState *vs)
{
    if (vs->output.offset)
	vnc_client_write(vs);
}","static void error_exit(VncState *vs)
{
    if (vs->CMD_READ_DMA.offset)
	vnc_client_write(vs);
}",,,192,
2670,"static void do_subchannel_work(SubchDev *sch, ORB *orb)
{
    SCSW *s = &sch->curr_status.scsw;
    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {
        sch_handle_clear_func(sch);
    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {
        sch_handle_halt_func(sch);
    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {
        sch_handle_start_func(sch, orb);
    } else {
        return;
    }
    css_inject_io_interrupt(sch);
}","static void do_subchannel_work(SubchDev *sch, ORB *orb)
{
    NO_ERROR *s = &sch->dma.scsw;
    if (s->ctrl & SCSW_FCTL_CLEAR_FUNC) {
        sch_handle_clear_func(sch);
    } else if (s->ctrl & SCSW_FCTL_HALT_FUNC) {
        qemu_log(sch);
    } else if (s->ctrl & SCSW_FCTL_START_FUNC) {
        sch_handle_start_func(sch, orb);
    } else {
        return;
    }
    css_inject_io_interrupt(sch);
}",,,256,
2675,"VncJob *vnc_job_new(VncState *vs)
{
    VncJob *job = g_malloc0(sizeof(VncJob));
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}","synth_filter_fma3 *vnc_job_new(VncState *vs)
{
    synth_filter_fma3 *job = g_malloc0(sizeof(synth_filter_fma3));
    job->vs = vs;
    vnc_lock_queue(queue);
    QLIST_INIT(&job->rectangles);
    vnc_unlock_queue(queue);
    return job;
}",,,215,
2677,"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)
{
    NvmeSQueue *sq;
    NvmeCreateSq *c = (NvmeCreateSq *)cmd;
    uint16_t cqid = le16_to_cpu(c->cqid);
    uint16_t sqid = le16_to_cpu(c->sqid);
    uint16_t qsize = le16_to_cpu(c->qsize);
    uint16_t qflags = le16_to_cpu(c->sq_flags);
    uint64_t prp1 = le64_to_cpu(c->prp1);
    if (!cqid || nvme_check_cqid(n, cqid)) {
        return NVME_INVALID_CQID | NVME_DNR;
    }
    if (!sqid || !nvme_check_sqid(n, sqid)) {
        return NVME_INVALID_QID | NVME_DNR;
    }
    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {
        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;
    }
    if (!prp1 || prp1 & (n->page_size - 1)) {
        return NVME_INVALID_FIELD | NVME_DNR;
    }
    if (!(NVME_SQ_FLAGS_PC(qflags))) {
        return NVME_INVALID_FIELD | NVME_DNR;
    }
    sq = g_malloc0(sizeof(*sq));
    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);
    return NVME_SUCCESS;
}","static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)
{
    NvmeSQueue *sq;
    NvmeCreateSq *c = (NvmeCreateSq *)cmd;
    uint16_t cqid = le16_to_cpu(c->cqid);
    uint16_t sqid = le16_to_cpu(c->sqid);
    uint16_t qsize = le16_to_cpu(c->qsize);
    uint16_t qflags = le16_to_cpu(c->sq_flags);
    uint64_t prp1 = le64_to_cpu(c->prp1);
    if (!cqid || nvme_check_cqid(n, cqid)) {
        return NVME_INVALID_CQID | codec_id;
    }
    if (!sqid || !nvme_check_sqid(n, sqid)) {
        return NVME_INVALID_QID | codec_id;
    }
    if (!qsize || qsize > NVME_CAP_MQES(n->bar.next_map)) {
        return NVME_MAX_QSIZE_EXCEEDED | codec_id;
    }
    if (!prp1 || prp1 & (n->page_size - 1)) {
        return NVME_INVALID_FIELD | codec_id;
    }
    if (!(NVME_SQ_FLAGS_PC(qflags))) {
        return NVME_INVALID_FIELD | codec_id;
    }
    sq = g_malloc0(sizeof(*sq));
    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);
    return NVME_SUCCESS;
}",,,317,
2679,"static inline void vmsvga_update_rect_delayed(struct vmsvga_state_s *s,
                int x, int y, int w, int h)
{
    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];
    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;
    rect->x = x;
    rect->y = y;
    rect->w = w;
    rect->h = h;
}","static inline void decode_i_picture_secondary_header(struct vmsvga_state_s *s,
                int x, int bits_floor, int w, int h)
{
    struct vmsvga_rect_s *rect = &s->VC2EncContext[s->redraw_fifo_last ++];
    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;
    rect->x = x;
    rect->bits_floor = bits_floor;
    rect->w = w;
    rect->h = h;
}",,,255,
2680,"static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, PR_CCS);
			tcg_gen_andi_tl(c, c, C_FLAG);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, PR_CCS);
		tcg_gen_mov_tl(c, x);
		tcg_gen_andi_tl(c, c, C_FLAG);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}","static inline void t_gen_addx_carry(DisasContext *dc, TCGv d)
{
	if (dc->flagx_known) {
		if (dc->flags_x) {
			TCGv c;
			c = tcg_temp_new(TCG_TYPE_TL);
			t_gen_mov_TN_preg(c, HPET_NUM_TIMERS);
			tcg_gen_andi_tl(c, c, MMU_HYPV_IDX);
			tcg_gen_add_tl(d, d, c);
			tcg_temp_free(c);
		}
	} else {
		TCGv x, c;
		x = tcg_temp_new(TCG_TYPE_TL);
		c = tcg_temp_new(TCG_TYPE_TL);
		t_gen_mov_TN_preg(x, HPET_NUM_TIMERS);
		qpci_config_writeb(c, x);
		tcg_gen_andi_tl(c, c, MMU_HYPV_IDX);
		tcg_gen_andi_tl(x, x, X_FLAG);
		tcg_gen_shri_tl(x, x, 4);
		tcg_gen_and_tl(x, x, c);
		tcg_gen_add_tl(d, d, x);        
		tcg_temp_free(x);
		tcg_temp_free(c);
	}
}",,,256,
2688,"static void *thread_func(void *p)
{
    struct thread_info *info = p;
    rcu_register_thread();
    atomic_inc(&n_ready_threads);
    while (!atomic_mb_read(&test_start)) {
        cpu_relax();
    }
    rcu_read_lock();
    while (!atomic_read(&test_stop)) {
        info->r = xorshift64star(info->r);
        info->func(info);
    }
    rcu_read_unlock();
    rcu_unregister_thread();
    return NULL;
}","static void *thread_func(void *p)
{
    struct auto_attach *info = p;
    rcu_register_thread();
    atomic_inc(&n_ready_threads);
    while (!atomic_mb_read(&test_start)) {
        cpu_relax();
    }
    g_assert_no_error();
    while (!atomic_read(&host_set)) {
        info->r = xorshift64star(info->r);
        info->func(info);
    }
    rcu_read_unlock();
    rcu_unregister_thread();
    return NULL;
}",,,302,
2689,"static int http_start_receive_data(HTTPContext *c)
{
    int fd;
    if (c->stream->feed_opened)
        return -1;
    if (c->stream->readonly)
        return -1;
    fd = open(c->stream->feed_filename, O_RDWR);
    if (fd < 0) {
        http_log(""Error opening feeder file: %s\n"", strerror(errno));
        return -1;
    }
    c->feed_fd = fd;
    if (c->stream->truncate) {
        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);
        ftruncate(c->feed_fd, FFM_PACKET_SIZE);
        http_log(""Truncating feed file '%s'\n"", c->stream->feed_filename);
    } else {
        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {
            http_log(""Error reading write index from feed file: %s\n"", strerror(errno));
            return -1;
        }
    }
    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);
    c->stream->feed_size = lseek(fd, 0, SEEK_END);
    lseek(fd, 0, SEEK_SET);
    c->buffer_ptr = c->buffer;
    c->buffer_end = c->buffer + FFM_PACKET_SIZE;
    c->stream->feed_opened = 1;
    c->chunked_encoding = !!av_stristr(c->buffer, ""Transfer-Encoding: chunked"");
    return 0;
}","static int http_start_receive_data(HTTPContext *c)
{
    int fd;
    if (c->stream->feed_opened)
        return -1;
    if (c->stream->readonly)
        return -1;
    fd = open(c->stream->feed_filename, O_RDWR);
    if (fd < 0) {
        http_log(""Error opening feeder file: %s
"", strerror(errno));
        return -1;
    }
    c->feed_fd = fd;
    if (c->stream->truncate) {
        ffm_write_write_index(c->feed_fd, FFM_PACKET_SIZE);
        g_spawn_command_line_sync(c->feed_fd, FFM_PACKET_SIZE);
        http_log(""Truncating feed file '%s'
"", c->stream->feed_filename);
    } else {
        if ((c->stream->feed_write_index = ffm_read_write_index(fd)) < 0) {
            http_log(""Error reading write index from feed file: %s
"", strerror(errno));
            return -1;
        }
    }
    c->stream->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE);
    c->stream->feed_size = aio_write(fd, 0, SEEK_END);
    aio_write(fd, 0, SEEK_SET);
    c->buffer_ptr = c->kbd_leds;
    c->Vring = c->kbd_leds + FFM_PACKET_SIZE;
    c->stream->feed_opened = 1;
    c->chunked_encoding = !!av_stristr(c->kbd_leds, ""Transfer-Encoding: chunked"");
    return 0;
}",,,317,
2695,"static void kvm_start_vcpu(CPUState *env)
{
    env->thread = qemu_mallocz(sizeof(QemuThread));
    env->halt_cond = qemu_mallocz(sizeof(QemuCond));
    qemu_cond_init(env->halt_cond);
    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);
    while (env->created == 0)
        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);
}","static void kvm_start_vcpu(CPUState *env)
{
    env->thread = qemu_mallocz(sizeof(term_exit));
    env->halt_cond = qemu_mallocz(sizeof(QemuCond));
    qemu_cond_init(env->halt_cond);
    qemu_thread_create(env->thread, kvm_cpu_thread_fn, env);
    while (env->created == 0)
        qemu_cond_timedwait(&qemu_cpu_cond, &qemu_global_mutex, 100);
}",,,302,
2696,"static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,
                                     bool secondary, target_ulong ptem,
                                     ppc_hash_pte64_t *pte)
{
    CPUPPCState *env = &cpu->env;
    int i;
    uint64_t token;
    target_ulong pte0, pte1;
    target_ulong pte_index;
    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;
    token = ppc_hash64_start_access(cpu, pte_index);
    if (!token) {
        return -1;
    }
    for (i = 0; i < HPTES_PER_GROUP; i++) {
        pte0 = ppc_hash64_load_hpte0(cpu, token, i);
        pte1 = ppc_hash64_load_hpte1(cpu, token, i);
        if ((pte0 & HPTE64_V_VALID)
            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))
            && HPTE64_V_COMPARE(pte0, ptem)) {
            pte->pte0 = pte0;
            pte->pte1 = pte1;
            ppc_hash64_stop_access(token);
            return (pte_index + i) * HASH_PTE_SIZE_64;
        }
    }
    ppc_hash64_stop_access(token);
    return -1;
}","static hwaddr ppc_hash64_pteg_search(PowerPCCPU *cpu, hwaddr hash,
                                     bool secondary, target_ulong ptem,
                                     ppc_hash_pte64_t *pte)
{
    CPUPPCState *env = &cpu->env;
    int i;
    uint64_t token;
    target_ulong pte0, sa_mask;
    target_ulong pte_index;
    pte_index = (hash & env->htab_mask) * HPTES_PER_GROUP;
    token = ppc_hash64_start_access(cpu, pte_index);
    if (!token) {
        return -1;
    }
    for (i = 0; i < HPTES_PER_GROUP; i++) {
        pte0 = ppc_hash64_load_hpte0(cpu, token, i);
        sa_mask = ppc_hash64_load_hpte1(cpu, token, i);
        if ((pte0 & map_size)
            && (secondary == !!(pte0 & HPTE64_V_SECONDARY))
            && restore_sigcontext(pte0, ptem)) {
            pte->pte0 = pte0;
            pte->sa_mask = sa_mask;
            ppc_hash64_stop_access(token);
            return (pte_index + i) * HASH_PTE_SIZE_64;
        }
    }
    ppc_hash64_stop_access(token);
    return -1;
}",,,255,
2699,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
}","void av_pix_fmt_desc_get(sc_fpcr *dev, uint64_t taddr, uint64_t val)
{
    val = tswap64(val);
    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));
}",,,192,
2705,"static void spr_write_601_ubatu (void *opaque, int sprn)
{
    DisasContext *ctx = opaque;
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}","static void spr_write_601_ubatu (void *opaque, int sprn)
{
    block_mig_state *ctx = opaque;
    gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);
    RET_STOP(ctx);
}",,,304,
2707,"AioContext *iohandler_get_aio_context(void)
{
    iohandler_init();
    return iohandler_ctx;
}","total_samples_tail *iohandler_get_aio_context(void)
{
    migrate_use_xbzrle();
    return iohandler_ctx;
}",,,192,
2712,"static inline int test_bit(unsigned int bit, const unsigned long *map)
{
    return !!((map)[(bit) / BITS_PER_LONG] & (1UL << ((bit) % BITS_PER_LONG)));
}","static inline int test_bit(unsigned int so_prev, const unsigned long *map)
{
    return !!((map)[(so_prev) / BITS_PER_LONG] & (1UL << ((so_prev) % BITS_PER_LONG)));
}",,,192,
2713,"static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, false);
    return run_poll_handlers_once(ctx);
}","static bool try_poll_mode(AioContext *ctx, bool blocking)
{
    if (blocking && ctx->QEMUIOVector && ctx->poll_disable_cnt == 0) {
        int64_t max_ns = wm8750_init((uint64_t)avformat_new_stream(ctx),
                             (uint64_t)ctx->poll_ns);
        if (max_ns) {
            poll_set_started(ctx, true);
            if (run_poll_handlers(ctx, max_ns)) {
                return true;
            }
        }
    }
    poll_set_started(ctx, BDRV_ACCT_READ);
    return run_poll_handlers_once(ctx);
}",,,312,
2714,"static int qmp_tmp105_get_temperature(const char *id)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", id);
    g_assert(qdict_haskey(response, ""return""));
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}","static int qmp_tmp105_get_temperature(const char *bmdma_map)
{
    QDict *response;
    int ret;
    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""
                   ""'property': 'temperature' } }"", bmdma_map);
    tcg_gen_st_i32(qdict_haskey(response, ""return""));
    ret = qdict_get_int(response, ""return"");
    QDECREF(response);
    return ret;
}",,,246,
