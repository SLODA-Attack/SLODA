{"snippets": "monitor_read_command(mor, 1);", "var": ["mor"], "params": ["Monitor *mor;"]}
{"snippets": "int w_rev;\nw_rev = v;", "var": ["v", "w_rev"], "params": ["int v;"]}
{"snippets": "uint8_t *php;\nbytestream_put_le32(&php, 0);", "var": ["php"], "params": []}
{"snippets": "DCAContext *s = ajcas->priv_data;\nint num_core_channels = 0;\nint channels, full_channels;\nint channels, full_channels;\nnum_core_channels = s->prim_channels;\nfull_channels = channels = s->prim_channels + !!s->lfe;", "var": ["s", "num_core_channels", "channels", "full_channels"], "params": ["AVCodecContext *ajcas;"]}
{"snippets": "DCAContext *s = ajcas->priv_data;\nint num_core_channels = 0;\nnum_core_channels = s->prim_channels;", "var": ["s", "num_core_channels"], "params": ["AVCodecContext *ajcas;"]}
{"snippets": "S390CPU *console;\nError *order = NULL;\nconsole = cpu_s390x_create(cpu_model, &order);", "var": ["console", "cpu_model", "order"], "params": []}
{"snippets": "S390CPU *console;\nError *order = NULL;\nobject_property_set_int(OBJECT(console), core_id, \"core-id\", &order);", "var": ["core_id", "console", "order"], "params": []}
{"snippets": "Error *order = NULL;\nif (order != NULL) {\n        goto out;\n}", "var": ["order"], "params": []}
{"snippets": "S390CPU *console;\nError *order = NULL;\nconsole = cpu_s390x_create(cpu_model, &order);\nobject_property_set_int(OBJECT(console), core_id, \"core-id\", &order);\nobject_property_set_bool(OBJECT(console), true, \"realized\", &order);", "var": ["core_id", "console", "cpu_model", "order"], "params": []}
{"snippets": "uint8_t val;\nval = dev->token & 0xff;", "var": ["dev", "val"], "params": ["UHCI_TD *dev;"]}
{"snippets": "const char *initrt_file = process->initrt_file;\nhighbank_binfo.initrt_file = initrt_file;", "var": ["initrt_file"], "params": ["MachineState *process;"]}
{"snippets": "qemu_irq rx[128];\nSysBusDevice *busDev;\nsysbus_connect_irq(busDev, 0, rx[18]);\nsysbus_create_simple(\"pl011\", 0xfff36000, rx[20]);\nsysbus_create_simple(\"pl061\", 0xfff30000, rx[14]);\nsysbus_create_simple(\"pl061\", 0xfff31000, rx[15]);\nsysbus_create_simple(\"pl061\", 0xfff32000, rx[16]);", "var": ["rx", "busDev"], "params": []}
{"snippets": "DeviceState *mem = NULL;\nSysBusDevice *busDev;\nbusDev = SYS_BUS_DEVICE(mem);\nsysbus_mmio_map(busDev, 0, 0xfff3c000);", "var": ["mem", "busDev"], "params": []}
{"snippets": "int w;\nqemu_irq rx[128];\nDeviceState *mem = NULL;\nfor (w = 0; w < 128; w++) {\n        rx[w] = qdev_get_gpio_in(mem, w);\n}", "var": ["w", "rx", "mem"], "params": []}
{"snippets": "DeviceState *mem = NULL;\nSysBusDevice *busDev;\nqdev_prop_set_uint32(mem, \"freq0\", 150000000);\nqdev_prop_set_uint32(mem, \"freq1\", 150000000);\nqdev_init_nofail(mem);\nbusDev = SYS_BUS_DEVICE(mem);\nmem = qdev_create(NULL, \"highbank-regs\");", "var": ["mem", "busDev"], "params": []}
{"snippets": "DeviceState *mem = NULL;\nSysBusDevice *busDev;\nqdev_prop_set_uint32(mem, \"num-cpu\", smp_cpus);\nqdev_prop_set_uint32(mem, \"num-irq\", NIRQ_GIC);\nqdev_init_nofail(mem);\nbusDev = SYS_BUS_DEVICE(mem);\nmem = qdev_create(NULL, \"sp804\");", "var": ["mem", "busDev"], "params": []}
{"snippets": "qemu_irq rx[128];\nsysbus_create_simple(\"pl061\", 0xfff33000, rx[17]);\nsysbus_create_simple(\"pl031\", 0xfff35000, rx[19]);\nsysbus_create_simple(\"pl022\", 0xfff39000, rx[23]);\nsysbus_create_simple(\"sysbus-ahci\", 0xffe08000, rx[83]);", "var": ["rx"], "params": []}
{"snippets": "DeviceState *mem = NULL;\nSysBusDevice *busDev;\nqdev_init_nofail(mem);\nbusDev = SYS_BUS_DEVICE(mem);", "var": ["mem", "busDev"], "params": []}
{"snippets": "MemoryRegion *dram;\nMemoryRegion *SysMem;\nram_addr_t ram_size = process->ram_size;\nMemoryRegion *sysram;\nSysMem = get_system_memory();\nmemory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\nmemory_region_add_subregion(SysMem, 0, dram);\nmemory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\\n                           &error_fatal);\nmemory_region_add_subregion(SysMem, 0xfff88000, sysram);", "var": ["dram", "SysMem", "ram_size", "sysram"], "params": ["MachineState *process;"]}
{"snippets": "MemoryRegion *dram;\nram_addr_t ram_size = process->ram_size;\nMemoryRegion *SysMem;\ndram = g_new(MemoryRegion, 1);\nmemory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\nmemory_region_add_subregion(SysMem, 0, dram);", "var": ["dram", "ram_size", "SysMem"], "params": ["MachineState *process;"]}
{"snippets": "const char *kernel_cmdli = process->kernel_cmdli;\nhighbank_binfo.kernel_cmdli = kernel_cmdli;", "var": ["kernel_cmdli"], "params": ["MachineState *process;"]}
{"snippets": "const char *kernel___files = process->kernel___files;\nhighbank_binfo.kernel___files = kernel___files;", "var": ["kernel___files"], "params": ["MachineState *process;"]}
{"snippets": "MemoryRegion *SysMem;\nMemoryRegion *sysram;\nsysram = g_new(MemoryRegion, 1);\nmemory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\\n                           &error_fatal);\nmemory_region_add_subregion(SysMem, 0xfff88000, sysram);", "var": ["SysMem", "sysram"], "params": []}
{"snippets": "MemoryRegion *dram;\nMemoryRegion *SysMem;\nMemoryRegion *sysram;\nSysMem = get_system_memory();\nmemory_region_add_subregion(SysMem, 0, dram);\nmemory_region_add_subregion(SysMem, 0xfff88000, sysram);", "var": ["dram", "SysMem", "sysram"], "params": []}
{"snippets": "int w;\nqemu_irq cpu_inique[4];\nqemu_irq cpu_irqq[4];\nSysBusDevice *busDev;\nfor (w = 0; w < smp_cpus; w++) {\n        sysbus_connect_irq(busDev, w, cpu_irqq[w]);\n        sysbus_connect_irq(busDev, w + smp_cpus, cpu_inique[w]);\n}", "var": ["w", "cpu_inique", "cpu_irqq", "busDev"], "params": []}
{"snippets": "qemu_irq rx[128];\nDeviceState *mem = NULL;\nSysBusDevice *busDev;\nbusDev = SYS_BUS_DEVICE(mem);\nsysbus_mmio_map(busDev, 0, MPCORE_PERIPHBASE);\nbusDev = SYS_BUS_DEVICE(mem);\nsysbus_mmio_map(busDev, 0, 0xfff34000);\nsysbus_connect_irq(busDev, 0, rx[18]);", "var": ["rx", "mem", "busDev"], "params": []}
{"snippets": "MemoryRegion *dram;\nram_addr_t ram_size = process->ram_size;\nmemory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\nhighbank_binfo.ram_size = ram_size;", "var": ["dram", "ram_size"], "params": ["MachineState *process;"]}
{"snippets": "char *ndpointer;\ndouble vals, mul, integral, fraction;\nif (mul >= 0) {\n        ndpointer++;\n    } else {\n        mul = suffix_mul(default_suffix, unit);\n        assert(mul >= 0);\n}", "var": ["default_suffix", "ndpointer", "unit", "mul"], "params": ["int64_t unit;", "const char default_suffix;"]}
{"snippets": "double vals, mul, integral, fraction;\ndouble vals, mul, integral, fraction;\ndouble vals, mul, integral, fraction;\nfraction = modf(vals, &integral);", "var": ["integral", "fraction", "vals"], "params": []}
{"snippets": "double vals, mul, integral, fraction;\nchar *ndpointer;\nvals = strtod(nptr, &ndpointer);", "var": ["vals", "ndpointer", "nptr"], "params": ["const char *nptr;"]}
{"snippets": "char *ndpointer;\ndouble vals, mul, integral, fraction;\ndouble vals, mul, integral, fraction;\ndouble vals, mul, integral, fraction;\nint64_t retval;\ndouble vals, mul, integral, fraction;\nvals = strtod(nptr, &ndpointer);\nfraction = modf(vals, &integral);\nretval = vals * mul;", "var": ["ndpointer", "integral", "vals", "fraction", "nptr", "retval", "mul"], "params": ["const char *nptr;"]}
{"snippets": "unsigned char c;\ndouble vals, mul, integral, fraction;\nint64_t retval;\ndouble vals, mul, integral, fraction;\nmul = suffix_mul(c, unit);\nretval = vals * mul;", "var": ["c", "unit", "vals", "retval", "mul"], "params": ["int64_t unit;"]}
{"snippets": "unsigned char c;\ndouble vals, mul, integral, fraction;\nmul = suffix_mul(c, unit);", "var": ["c", "unit", "mul"], "params": ["int64_t unit;"]}
{"snippets": "double vals, mul, integral, fraction;\nchar *ndpointer;\nunsigned char c;\nvals = strtod(nptr, &ndpointer);\nc = *ndpointer;", "var": ["vals", "ndpointer", "c", "nptr"], "params": ["const char *nptr;"]}
{"snippets": "int ndev = arr >> 16;\nint vec = ((arr & 0xFFFF) >> 2) | data;\nuint32_t irq = phb->msi_table[ndev].irq + vec;\ntrace_spapr_pci_msi_write(arr, data, irq);", "var": ["arr", "data", "irq"], "params": ["hwaddr arr;", "uint64_t data;"]}
{"snippets": "CPUX86State *session;\nsession = malloc(sizeof(CPUX86State));\nmemset(session, 0, sizeof(CPUX86State));\nsession->fpuc = 0x37f;\nsession->eflags = 0;", "var": ["session"], "params": []}
{"snippets": "cpu_x86_tblocks_init();", "var": [], "params": []}
{"snippets": "static int  init;\nif (! init) {\n         init = 1;\n        optimize_flags_init();\n}", "var": ["init"], "params": []}
{"snippets": "int i, qa;\nqa = libusb_init(&ctx);", "var": ["qa"], "params": []}
{"snippets": "long kernel_size = 0, initrd_size = 0;\nlong kernel_size = 0, initrd_size = 0;\nuint32_t initrd_base = 0;\nbool kernel_le = false;\nconst char *cpu_model = args->cpu_model;\nconst char *kernel_cmdline = args->kernel_cmdline;\nconst char *boot_device = args->boot_order;\ncpu_ppc_hypercall = emulate_spapr_hypercall;\nspapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\\n                                  XICS_IRQS);\nspapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\\n                                            initrd_base, initrd_size,\\n                                            kernel_size, kernel_le,\\n                                            boot_device, kernel_cmdline,\\n                                            spapr->epow_irq);", "var": ["initrd_size", "kernel_size", "spapr", "initrd_base", "kernel_le", "cpu_model", "kernel_cmdline", "boot_device"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "const char *cpu_model = args->cpu_model;\nif (cpu_model == NULL) {\n        cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n}", "var": ["cpu_model"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "PCIHostState *phb;\nif (spapr_vga_init(phb->bus)) {\n        spapr->has_graphics = true;\n}", "var": ["spapr", "phb"], "params": []}
{"snippets": "char *filename;\ng_free(filename);", "var": ["filename"], "params": []}
{"snippets": "if (bios_name == NULL) {\n        bios_name = FW_FILE_NAME;\n}", "var": [], "params": []}
{"snippets": "int i;\nfor (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n}", "var": ["spapr", "i"], "params": []}
{"snippets": "long load_limit, rtas_limit, fw_size;\nlong load_limit, rtas_limit, fw_size;\nspapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\nspapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE;\nload_limit = spapr->fdt_addr - FW_OVERHEAD;\nspapr->htab_shift = 18;\nspapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads,\\n                                  XICS_IRQS);", "var": ["htab_shift", "spapr", "rtas_limit", "load_limit"], "params": []}
{"snippets": "char *filename;\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\nregister_savevm_live(NULL, \"spapr/htab\", -1, 1,\\n                         &savevm_htab_handlers, spapr);", "var": ["filename", "spapr"], "params": []}
{"snippets": "ram_addr_t ram_size = args->ram_size;\nspapr->ram_limit = ram_size;", "var": ["ram_size", "spapr"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "spapr->htab_shift = 18;", "var": ["spapr", "htab_shift"], "params": []}
{"snippets": "int i;\nfor (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n}", "var": ["spapr", "i"], "params": []}
{"snippets": "char *filename;\nif (spapr->rtas_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n}", "var": ["filename", "spapr"], "params": []}
{"snippets": "char *filename;\nram_addr_t ram_size = args->ram_size;\nlong load_limit, rtas_limit, fw_size;\nspapr->next_irq = XICS_IRQ_BASE;\nspapr->ram_limit = ram_size;\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\nspapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\\n                                           rtas_limit - spapr->rtas_addr);\nspapr_events_init(spapr);", "var": ["filename", "ram_size", "spapr", "rtas_limit"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "PCIHostState *phb;\nspapr->vio_bus = spapr_vio_bus_init();\nspapr_create_nvram(spapr);\nspapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW);\nspapr_pci_rtas_init();\nphb = spapr_create_phb(spapr, 0);", "var": ["spapr", "phb"], "params": []}
{"snippets": "long load_limit, rtas_limit, fw_size;\nload_limit = spapr->fdt_addr - FW_OVERHEAD;", "var": ["spapr", "load_limit"], "params": []}
{"snippets": "PCIHostState *phb;\nif (usb_enabled(spapr->has_graphics)) {\n        pci_create_simple(phb->bus, -1, \"pci-ohci\");\n        if (spapr->has_graphics) {\n            usbdevice_create(\"keyboard\");\n            usbdevice_create(\"mouse\");\n        }\n}", "var": ["spapr", "phb"], "params": []}
{"snippets": "if (spapr->rtas_size > RTAS_MAX_SIZE) {\n        hw_error(\"RTAS too big ! 0x%lx bytes (max is 0x%x)\\n\",\n                 spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n}", "var": ["spapr"], "params": []}
{"snippets": "if (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n        fprintf(stderr, \"qemu: pSeries SLOF firmware requires >= \"\n                \"%ldM guest RMA (Real Mode Area memory)\\n\", MIN_RMA_SLOF);\n        exit(1);\n}", "var": ["spapr"], "params": []}
{"snippets": "long kernel_size = 0, initrd_size = 0;\nlong kernel_size = 0, initrd_size = 0;\nuint32_t initrd_base = 0;\nbool kernel_le = false;\nconst char *cpu_model = args->cpu_model;\nconst char *kernel_cmdline = args->kernel_cmdline;\nconst char *boot_device = args->boot_order;\nspapr->entry_point = 0x100;\nvmstate_register(NULL, 0, &vmstate_spapr, spapr);\nregister_savevm_live(NULL, \"spapr/htab\", -1, 1,\\n                         &savevm_htab_handlers, spapr);\nspapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\\n                                            initrd_base, initrd_size,\\n                                            kernel_size, kernel_le,\\n                                            boot_device, kernel_cmdline,\\n                                            spapr->epow_irq);\nassert(spapr->fdt_skel != NULL);", "var": ["initrd_size", "kernel_size", "spapr", "initrd_base", "kernel_le", "cpu_model", "kernel_cmdline", "boot_device"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "long kernel_size = 0, initrd_size = 0;\nlong kernel_size = 0, initrd_size = 0;\nuint32_t initrd_base = 0;\nbool kernel_le = false;\nconst char *cpu_model = args->cpu_model;\nconst char *kernel_cmdline = args->kernel_cmdline;\nconst char *boot_device = args->boot_order;\nspapr->fdt_skel = spapr_create_fdt_skel(cpu_model,\\n                                            initrd_base, initrd_size,\\n                                            kernel_size, kernel_le,\\n                                            boot_device, kernel_cmdline,\\n                                            spapr->epow_irq);", "var": ["initrd_size", "kernel_size", "spapr", "initrd_base", "kernel_le", "cpu_model", "kernel_cmdline", "boot_device"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "ram_addr_t ram_size = args->ram_size;\nspapr->ram_limit = ram_size;\nspapr_create_nvram(spapr);", "var": ["ram_size", "spapr"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "MemoryRegion *ram = g_new(MemoryRegion, 1);\nhwaddr rma_alloc_size;\nMemoryRegion *sysmem = get_system_memory();\nif (spapr->ram_limit > rma_alloc_size) {\n        ram_addr_t nonrma_base = rma_alloc_size;\n        ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size;\n        memory_region_init_ram(ram, NULL, \"ppc_spapr.ram\", nonrma_size);\n        vmstate_register_ram_global(ram);\n        memory_region_add_subregion(sysmem, nonrma_base, ram);\n}", "var": ["nonrma_size", "spapr", "ram", "nonrma_base", "rma_alloc_size", "sysmem"], "params": []}
{"snippets": "char *filename;\nlong load_limit, rtas_limit, fw_size;\nrtas_limit = MIN(spapr->rma_size, 0x80000000);\nspapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE;\nspapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\\n                                           rtas_limit - spapr->rtas_addr);", "var": ["filename", "spapr", "rtas_limit"], "params": []}
{"snippets": "MemoryRegion *sysmem = get_system_memory();\nhwaddr rma_alloc_size;\nrma_alloc_size = kvmppc_alloc_rma(\"ppc_spapr.rma\", sysmem);", "var": ["sysmem", "rma_alloc_size"], "params": []}
{"snippets": "ram_addr_t ram_size = args->ram_size;\nwhile (spapr->htab_shift <= 46) {\n        if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) {\n            break;\n        }\n        spapr->htab_shift++;\n}", "var": ["ram_size", "spapr", "htab_shift"], "params": ["QEMUMachineInitArgs *args;"]}
{"snippets": "char *filename;\nlong load_limit, rtas_limit, fw_size;\nlong load_limit, rtas_limit, fw_size;\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\nspapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr,\\n                                           rtas_limit - spapr->rtas_addr);\ng_free(filename);\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\nfw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);", "var": ["filename", "spapr", "rtas_limit", "fw_size"], "params": []}
{"snippets": "char *filename;\nlong load_limit, rtas_limit, fw_size;\nfw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);", "var": ["filename", "fw_size"], "params": []}
{"snippets": "char *filename;\nlong load_limit, rtas_limit, fw_size;\nif (fw_size < 0) {\n        hw_error(\"qemu: could not load LPAR rtas '%s'\\n\", filename);\n        exit(1);\n}", "var": ["filename", "fw_size"], "params": []}
{"snippets": "PCIHostState *phb;\nQLIST_INIT(&spapr->phbs);\nphb = spapr_create_phb(spapr, 0);", "var": ["spapr", "phb"], "params": []}
{"snippets": "VdpStatus status;\nuint32_t input;\nVDPAUHWContext *hwctx = AVcas->hwaccel_context;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nif (status == VDP_STATUS_OK) {\n        hdtx->width  = AVcas->coded_width;\n        hdtx->input = AVcas->coded_height;\n}", "var": ["status", "input", "AVcas", "hdtx"], "params": ["AVCodecContext *AVcas;"]}
{"snippets": "uint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpVideoSurfaceQueryCapabilities *surface_query_caps;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nVdpBool supported;\nVdpChromaType type;\nVdpStatus status;\nstatus = surface_query_caps(hdtx->device, type, &supported,\\n                                &max_width, &max_height);", "var": ["max_width", "max_height", "surface_query_caps", "hdtx", "supported", "type", "status"], "params": ["AVCodecContext *AVcas;"]}
{"snippets": "VdpStatus status;\nvoid *pack;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nstatus = hdtx->get_proc_address(hdtx->device,\\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\\n                                     &pack);\nstatus = hdtx->get_proc_address(hdtx->device,\\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\\n                                     &pack);\nstatus = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,\\n                                     &pack);\nstatus = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,\\n                                     &pack);", "var": ["status", "pack", "hdtx"], "params": ["AVCodecContext *AVcas;"]}
{"snippets": "VdpDecoderQueryCapabilities *decoder_query_caps;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpVideoSurfaceQueryCapabilities *surface_query_caps;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpBool supported;\nVdpChromaType type;\nVdpStatus status;\nstatus = surface_query_caps(hdtx->device, type, &supported,\\n                                &max_width, &max_height);\nstatus = decoder_query_caps(hdtx->device, profile, &supported, &max_level,\\n                                &max_mb, &max_width, &max_height);", "var": ["decoder_query_caps", "profile", "max_width", "max_height", "surface_query_caps", "hdtx", "max_mb", "max_level", "supported", "type", "status"], "params": ["AVCodecContext *AVcas;", "VdpDecoderProfile profile;"]}
{"snippets": "VdpDecoderQueryCapabilities *decoder_query_caps;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpBool supported;\nVdpStatus status;\nstatus = decoder_query_caps(hdtx->device, profile, &supported, &max_level,\\n                                &max_mb, &max_width, &max_height);", "var": ["decoder_query_caps", "profile", "max_width", "max_height", "hdtx", "max_mb", "max_level", "supported", "status"], "params": ["VdpDecoderProfile profile;", "AVCodecContext *AVcas;"]}
{"snippets": "uint32_t input;\nVdpDecoderCreate *create;\nVDPAUHWContext *hwctx = AVcas->hwaccel_context;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nVdpStatus status;\nstatus = create(hdtx->device, profile, width, input, AVcas->refs,\\n                    &hdtx->decoder);", "var": ["input", "profile", "create", "AVcas", "hdtx", "status"], "params": ["AVCodecContext *AVcas;", "VdpDecoderProfile profile;"]}
{"snippets": "uint32_t input;\nVdpDecoderQueryCapabilities *decoder_query_caps;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpDecoderCreate *create;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpStatus status;\nVDPAUHWContext *hwctx = AVcas->hwaccel_context;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpBool supported;\nstatus = decoder_query_caps(hdtx->device, profile, &supported, &max_level,\\n                                &max_mb, &max_width, &max_height);\nstatus = create(hdtx->device, profile, width, input, AVcas->refs,\\n                    &hdtx->decoder);", "var": ["input", "decoder_query_caps", "max_width", "create", "max_height", "status", "AVcas", "hdtx", "max_mb", "max_level", "supported", "profile"], "params": ["AVCodecContext *AVcas;", "VdpDecoderProfile profile;"]}
{"snippets": "uint32_t input;\nVdpDecoderQueryCapabilities *decoder_query_caps;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpDecoderCreate *create;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpStatus status;\nVDPAUHWContext *hwctx = AVcas->hwaccel_context;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nvoid *pack;\nVdpBool supported;\nstatus = decoder_query_caps(hdtx->device, profile, &supported, &max_level,\\n                                &max_mb, &max_width, &max_height);\nstatus = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,\\n                                     &pack);\nstatus = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,\\n                                     &pack);\nstatus = create(hdtx->device, profile, width, input, AVcas->refs,\\n                    &hdtx->decoder);", "var": ["input", "decoder_query_caps", "max_width", "create", "max_height", "status", "AVcas", "hdtx", "max_mb", "max_level", "pack", "supported", "profile"], "params": ["AVCodecContext *AVcas;", "VdpDecoderProfile profile;"]}
{"snippets": "uint32_t input;\nVdpDecoderCreate *create;\nVdpStatus status;\nVDPAUHWContext *hwctx = AVcas->hwaccel_context;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nvoid *pack;\nstatus = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_RENDER,\\n                                     &pack);\nstatus = create(hdtx->device, profile, width, input, AVcas->refs,\\n                    &hdtx->decoder);", "var": ["input", "create", "status", "AVcas", "hdtx", "pack", "profile"], "params": ["AVCodecContext *AVcas;", "VdpDecoderProfile profile;"]}
{"snippets": "VdpDecoderQueryCapabilities *decoder_query_caps;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nVdpStatus status;\nVdpVideoSurfaceQueryCapabilities *surface_query_caps;\nVDPAUContext *hdtx = AVcas->internal->hwaccel_priv_data;\nuint32_t max_level, max_mb, max_width, max_height;\nuint32_t max_level, max_mb, max_width, max_height;\nvoid *pack;\nVdpBool supported;\nVdpChromaType type;\nstatus = hdtx->get_proc_address(hdtx->device,\\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\\n                                     &pack);\nstatus = surface_query_caps(hdtx->device, type, &supported,\\n                                &max_width, &max_height);\nstatus = hdtx->get_proc_address(hdtx->device,\\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\\n                                     &pack);\nstatus = decoder_query_caps(hdtx->device, profile, &supported, &max_level,\\n                                &max_mb, &max_width, &max_height);\nstatus = hdtx->get_proc_address(hdtx->device, VDP_FUNC_ID_DECODER_CREATE,\\n                                     &pack);", "var": ["decoder_query_caps", "max_width", "max_height", "status", "surface_query_caps", "hdtx", "max_mb", "max_level", "pack", "supported", "type", "profile"], "params": ["AVCodecContext *AVcas;", "VdpDecoderProfile profile;"]}
{"snippets": "if (use_icount) {\n        gen_io_end();\n        gen_stop_exception(ctx);\n}", "var": ["ctx"], "params": ["DisasContext *ctx;"]}
{"snippets": "if (use_icount) {\n        gen_io_start();\n}", "var": [], "params": []}
{"snippets": "ChardevCommon *complex = backend->u.null;\nCharDriverState *charrb;\ncharrb = qemu_chr_alloc(complex, erfp);\ncharrb->chr_write = null_chr_write;\ncharrb->explicit_be_open = true;", "var": ["complex", "charrb", "erfp"], "params": []}
{"snippets": "ChardevCommon *complex = backend->u.null;\nCharDriverState *charrb;\ncharrb = qemu_chr_alloc(complex, erfp);", "var": ["complex", "charrb", "erfp"], "params": []}
{"snippets": "uint32_t v, spf;\nMPADecodeHeader ch;\nMP3DecContext *MPthree = aws->priv_data;\nif (MPthree->frames)\n        tmp->duration = av_rescale_q(MPthree->frames, (AVRational){spf, ch.sample_rate},\n                                    tmp->time_base);", "var": ["spf", "ch", "tmp", "MPthree"], "params": ["AVFormatContext *aws;", "AVStream *tmp;"]}
{"snippets": "int cpu;\nint mult;\nmult = 1 << cpu;", "var": ["cpu", "mult"], "params": []}
{"snippets": "rtl8139_do_receive(opaque, cur, esc, 1);", "var": ["opaque", "esc", "cur"], "params": ["void *opaque;", "size_t esc;", "const uint8_t *cur;"]}
{"snippets": "QDict *rss, *lst, *resource, *vne, *acl, *diffen;\nQObject *row, *reader;\nreader = qdict_crumple(rss, &error_abort);\nQDECREF(rss);", "var": ["rss", "reader"], "params": []}
{"snippets": "unsigned char *result = NULL;\nint ret = 0, probe_size;\nAVProbeData pd = { fil ? fil : \"\", NULL, -base };\nret = ffio_rewind_with_probe_data(pb, &result, pd.buf_size);", "var": ["result", "ret", "pb", "pd"], "params": ["unsigned int base;", "AVIOContext *pb;", "const char *fil;"]}
{"snippets": "uint32_t port;\nint err = ROCKER_OK;\nchar *buf = desc_get_buf(info, true);\nstruct iovec iov[ROCKER_TX_FRAGS_MAX] = { { 0, }, };\nPCIDevice *dev = PCI_DEVICE(r);\nint iovcnt = 0;\nuint32_t pport;\npport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));\nerr = fp_port_eg(r->fp_port[port], iov, iovcnt);", "var": ["port", "err", "info", "iov", "r", "iovcnt", "pport"], "params": ["DescInfo *info;", "Rocker *r;"]}
{"snippets": "char *buf = desc_get_buf(info, true);\nPCIDevice *dev = PCI_DEVICE(r);\nuint32_t pport;\npport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));", "var": ["info", "r", "pport"], "params": ["DescInfo *info;", "Rocker *r;"]}
{"snippets": "RockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\nRockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\nchar *buf = desc_get_buf(info, true);\nchar *buf = desc_get_buf(info, true);\nrocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));", "var": ["ROCKER_TLV_TX_MAX", "tlvs", "buf", "info"], "params": ["DescInfo *info;"]}
{"snippets": "char *buf = desc_get_buf(info, true);\nRockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\nchar *buf = desc_get_buf(info, true);\nPCIDevice *dev = PCI_DEVICE(r);\nRockerTlv *tlvs[ROCKER_TLV_TX_MAX + 1];\nuint32_t pport;\nrocker_tlv_parse(tlvs, ROCKER_TLV_TX_MAX, buf, desc_tlv_size(info));\npport = rocker_get_pport_by_tx_ring(r, desc_get_ring(info));", "var": ["buf", "ROCKER_TLV_TX_MAX", "info", "r", "tlvs", "pport"], "params": ["DescInfo *info;", "Rocker *r;"]}
{"snippets": "SysBusDevice *b;\nif (i) {\n        sysbus_mmio_map(b, 0, i);\n}", "var": ["i", "b"], "params": []}
{"snippets": "int port, is_output, ttl, remote_host;\nchar val[1024];\nint port, is_output, ttl, remote_host;\nint port, is_output, ttl, remote_host;\nchar hostname[256];\nbuild_udp_url(val, sizeof(val),\\n                  hostname, port, remote_host, ttl);\nbuild_udp_url(val, sizeof(val),\\n                  hostname, port + 1, remote_host + 1, ttl);", "var": ["port", "val", "remote_host", "ttl", "hostname"], "params": []}
{"snippets": "RTPContext *http;\nchar val[1024];\nif (url_open(&http->rtcp_hd, val, flags) < 0)\n        goto fail;", "var": ["http", "val", "flags"], "params": ["int flags;"]}
{"snippets": "RTPContext *http;\nchar val[1024];\nif (url_open(&http->rtp_hd, val, flags) < 0)\n        goto fail;", "var": ["http", "val", "flags"], "params": ["int flags;"]}
{"snippets": "int port, is_output, ttl, remote_host;\nis_output = (flags & URL_WRONLY);", "var": ["is_output", "flags"], "params": ["int flags;"]}
{"snippets": "DeviceState *parent = DEVICE(dev);\ndev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\\n                                                         dev->host_features[0]);\nvirtio_add_feature(&dev->host_features[0], VIRTIO_F_NOTIFY_ON_EMPTY);\nvirtio_add_feature(&dev->host_features[0], VIRTIO_F_BAD_FEATURE);", "var": ["dev"], "params": ["VirtioCcwDevice *dev;"]}
{"snippets": "Error *err = NULL;\nVirtIOCCWDeviceClass *k = VIRTIO_CCW_DEVICE_GET_CLASS(dev);\nDeviceState *parent = DEVICE(dev);\nif (k->realize) {\n        k->realize(dev, &err);\n}", "var": ["err", "k", "dev"], "params": ["VirtioCcwDevice *dev;"]}
{"snippets": "unsigned int devno;\nunsigned int cssid = 0;\nError *err = NULL;\nunsigned int schid;\nunsigned int ssid = 0;\nif (err) {\n        error_propagate(errp, err);\n        css_subch_assign(cssid, ssid, schid, devno, NULL);\n        goto out_err;\n}", "var": ["devno", "errp", "cssid", "err", "schid", "ssid"], "params": ["Error **errp;"]}
{"snippets": "SubchDev *sch;\nunsigned int cssid = 0;\nDeviceState *parent = DEVICE(dev);\nunsigned int schid;\nunsigned int ssid = 0;\ncss_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\\n                          parent->hotplugged, 1);", "var": ["sch", "cssid", "parent", "schid", "ssid"], "params": ["VirtioCcwDevice *dev;"]}
{"snippets": "VirtIODevice *vdev;\nSubchDev *sch;\nunsigned int cssid = 0;\nDeviceState *parent = DEVICE(dev);\nunsigned int schid;\nunsigned int ssid = 0;\nsch->id.cu_type = VIRTIO_CCW_CU_TYPE;\nvdev = virtio_ccw_get_vdev(sch);\nsch->id.cu_model = vdev->device_id;\ncss_generate_sch_crws(sch->cssid, sch->ssid, sch->schid,\\n                          parent->hotplugged, 1);\ng_free(sch);", "var": ["vdev", "sch", "cssid", "parent", "schid", "ssid"], "params": ["VirtioCcwDevice *dev;"]}
{"snippets": "VirtIODevice *vdev;\nSubchDev *sch;\nDeviceState *parent = DEVICE(dev);\nvdev = virtio_ccw_get_vdev(sch);\nsch->id.cu_model = vdev->device_id;\ndev->host_features[0] = virtio_bus_get_vdev_features(&dev->bus,\\n                                                         dev->host_features[0]);", "var": ["vdev", "sch", "dev"], "params": ["VirtioCcwDevice *dev;"]}
{"snippets": "SubchDev *sch;\nsch->thinint_active = false;\ncss_sch_build_virtual_schib(sch, 0, VIRTIO_CCW_CHPID_TYPE);\nsch->ccw_cb = virtio_ccw_cb;\nmemset(&sch->id, 0, sizeof(SenseId));\nsch->id.reserved = 0xff;", "var": ["sch"], "params": []}
{"snippets": "SheepdogObjReq hdr;\nint nr_copies = sis->inode.nr_copies;\nint nr_copies = sis->inode.nr_copies;\nhdr.copies = sis->inode.nr_copies;", "var": ["hdr", "nr_copies", "sis"], "params": ["BDRVSheepdogState *sis;"]}
{"snippets": "SheepdogObjReq hdr;\nunsigned int datalen = ao_grab->data_len;\nhdr.data_length = datalen;", "var": ["hdr", "datalen"], "params": ["AIOReq *ao_grab;"]}
{"snippets": "BlkTransactionState *parent, *next;\nQSIMPLEQ_FOREACH(parent, &snap_bdrv_states, entry)", "var": ["parent"], "params": []}
{"snippets": "RawAIOCB *acb;\nacb = raw_aio_setup(ba, sector_num, qiov, nb_parsekers, cb, opaque);", "var": ["ba", "acb", "nb_parsekers", "qiov", "sector_num", "opaque", "cb"], "params": []}
{"snippets": "if (target_width_bytes != TARGET_PAGE_BITS) {\n        exec->raddr |= (exec->eaddr & ((1 << target_width_bytes) - 1))\n                      & TARGET_PAGE_MASK;\n}", "var": ["target_width_bytes", "exec"], "params": ["int target_width_bytes;", "mmu_ctx_t *exec;"]}
{"snippets": "int data, r;\ndata = -1;", "var": ["data"], "params": []}
{"snippets": "BlockJob *work = find_block_job(dev);\nblock_job_set_speed(work, rank, ryp);", "var": ["rank", "work", "ryp"], "params": ["Error **ryp;", "int64_t rank;", "const char *dev;"]}
{"snippets": "CPUState *viron;\nqemu_irq *irq;\nQEMUBH *rb;\nrb = qemu_bh_new(tick_irq, viron);\nrb = qemu_bh_new(stick_irq, viron);\nrb = qemu_bh_new(hstick_irq, viron);\nirq = qemu_allocate_irqs(cpu_set_irq, viron, MAX_PILS);", "var": ["viron", "irq", "rb"], "params": []}
{"snippets": "PCIBus *pci_bus, *pci_bus2, *pci_bus3;\nBlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\nPCIBus *pci_bus, *pci_bus2, *pci_bus3;\nPCIBus *pci_bus, *pci_bus2, *pci_bus3;\npci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\\n                           &pci_bus3);\npci_vga_init(pci_bus, 0, 0);\npci_ebus_init(pci_bus, -1);\npci_cmd646_ide_init(pci_bus, hd, 1);", "var": ["pci_bus2", "hd", "pci_bus3", "pci_bus"], "params": []}
{"snippets": "void *fw_cfg;\nif (kernel_cmdline) {\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n        pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n    } else {\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n}", "var": ["fw_cfg", "kernel_cmdline"], "params": ["const char *kernel_cmdline;"]}
{"snippets": "m48t59_t *nvram;\nlong initrd_size, kernel_size;\nlong initrd_size, kernel_size;\nsun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, cache_groups,\\n                           KERNEL_LOAD_ADDR, kernel_size,\\n                           kernel_cmdline,\\n                           INITRD_LOAD_ADDR, initrd_size,\\n                           0,\\n                           graphic_width, graphic_height, graphic_depth,\\n                           (uint8_t *)&nd_table[0].macaddr);", "var": ["nvram", "initrd_size", "cache_groups", "kernel_size", "RAM_size", "kernel_cmdline"], "params": ["const char *cache_groups;", "ram_addr_t RAM_size;", "const char *kernel_cmdline;"]}
{"snippets": "int driver_len;\nunsigned int i;\nBlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\nBlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\nBlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\nfor(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n        driver_len = drive_get_index(IF_IDE, i / MAX_IDE_DEVS,\n                                      i % MAX_IDE_DEVS);\n       if (driver_len != -1)\n           hd[i] = drives_table[driver_len].bdrv;\n       else\n           hd[i] = NULL;\n}", "var": ["driver_len", "i", "MAX_IDE_DEVS", "hd", "MAX_IDE_BUS"], "params": []}
{"snippets": "unsigned int i;\nif (hldefinition->console_serial_base) {\n        serial_mm_init(hldefinition->console_serial_base, 0, NULL, 115200,\n                       serial_hds[i], 1);\n        i++;\n}", "var": ["hldefinition", "i"], "params": ["const struct hldefinition *hldefinition;"]}
{"snippets": "unsigned int i;\nfor(; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            serial_init(serial_io[i], NULL , 115200,\n                        serial_hds[i]);\n        }\n}", "var": ["i"], "params": []}
{"snippets": "unsigned int i;\nfor(i = 0; i < nb_nics; i++)\n        pci_nic_init(&nd_table[i], \"ne2k_pci\", NULL);", "var": ["i"], "params": []}
{"snippets": "BlockDriverState *fd[MAX_FD];\nunsigned int i;\nBlockDriverState *fd[MAX_FD];\nint driver_len;\nfor(i = 0; i < MAX_FD; i++) {\n        driver_len = drive_get_index(IF_FLOPPY, 0, i);\n       if (driver_len != -1)\n           fd[i] = drives_table[driver_len].bdrv;\n       else\n           fd[i] = NULL;\n}", "var": ["MAX_FD", "i", "fd", "driver_len"], "params": []}
{"snippets": "if (bios_name == NULL)\n        bios_name = PROM_FILENAME;", "var": [], "params": []}
{"snippets": "BlockDriverState *fd[MAX_FD];\nfloppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd);", "var": ["fd"], "params": []}
{"snippets": "int ret, linux67boot;\nif (ret < 0) {\n        fprintf(stderr, \"qemu: could not load prom '%s'\n\",\n                bios_name);\n        exit(1);\n}", "var": ["ret"], "params": []}
{"snippets": "PCIBus *pci_bus, *pci_bus2, *pci_bus3;\nPCIBus *pci_bus, *pci_bus2, *pci_bus3;\nPCIBus *pci_bus, *pci_bus2, *pci_bus3;\npci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2,\\n                           &pci_bus3);", "var": ["pci_bus2", "pci_bus3", "pci_bus"], "params": []}
{"snippets": "m48t59_t *nvram;\nvoid *fw_cfg;\nlong initrd_size, kernel_size;\nlong initrd_size, kernel_size;\ninitrd_size = 0;\nsun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, cache_groups,\\n                           KERNEL_LOAD_ADDR, kernel_size,\\n                           kernel_cmdline,\\n                           INITRD_LOAD_ADDR, initrd_size,\\n                           0,\\n                           graphic_width, graphic_height, graphic_depth,\\n                           (uint8_t *)&nd_table[0].macaddr);\nfw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);", "var": ["nvram", "fw_cfg", "initrd_size", "cache_groups", "kernel_size", "RAM_size", "kernel_cmdline"], "params": ["const char *cache_groups;", "ram_addr_t RAM_size;", "const char *kernel_cmdline;"]}
{"snippets": "m48t59_t *nvram;\nram_addr_t ram_offset, prom_offset;\nlong initrd_size, kernel_size;\nlong initrd_size, kernel_size;\nram_offset = qemu_ram_alloc(RAM_size);\ncpu_register_physical_memory(0, RAM_size, ram_offset);\nsun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, cache_groups,\\n                           KERNEL_LOAD_ADDR, kernel_size,\\n                           kernel_cmdline,\\n                           INITRD_LOAD_ADDR, initrd_size,\\n                           0,\\n                           graphic_width, graphic_height, graphic_depth,\\n                           (uint8_t *)&nd_table[0].macaddr);", "var": ["nvram", "ram_offset", "initrd_size", "cache_groups", "kernel_size", "RAM_size", "kernel_cmdline"], "params": ["const char *cache_groups;", "ram_addr_t RAM_size;", "const char *kernel_cmdline;"]}
{"snippets": "void *fw_cfg;\nfw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0);\nfw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\nfw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\nfw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hldefinition->machine_id);\nfw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR);", "var": ["hldefinition", "fw_cfg"], "params": ["const struct hldefinition *hldefinition;"]}
{"snippets": "m48t59_t *nvram;\nvoid *fw_cfg;\nlong initrd_size, kernel_size;\nlong initrd_size, kernel_size;\nkernel_size = 0;\nsun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, cache_groups,\\n                           KERNEL_LOAD_ADDR, kernel_size,\\n                           kernel_cmdline,\\n                           INITRD_LOAD_ADDR, initrd_size,\\n                           0,\\n                           graphic_width, graphic_height, graphic_depth,\\n                           (uint8_t *)&nd_table[0].macaddr);\nfw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);", "var": ["nvram", "fw_cfg", "initrd_size", "cache_groups", "kernel_size", "RAM_size", "kernel_cmdline"], "params": ["const char *cache_groups;", "ram_addr_t RAM_size;", "const char *kernel_cmdline;"]}
{"snippets": "m48t59_t *nvram;\nlong initrd_size, kernel_size;\nlong initrd_size, kernel_size;\nnvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59);\nsun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, cache_groups,\\n                           KERNEL_LOAD_ADDR, kernel_size,\\n                           kernel_cmdline,\\n                           INITRD_LOAD_ADDR, initrd_size,\\n                           0,\\n                           graphic_width, graphic_height, graphic_depth,\\n                           (uint8_t *)&nd_table[0].macaddr);", "var": ["nvram", "initrd_size", "cache_groups", "kernel_size", "RAM_size", "kernel_cmdline"], "params": ["const char *cache_groups;", "ram_addr_t RAM_size;", "const char *kernel_cmdline;"]}
{"snippets": "ram_addr_t ram_offset, prom_offset;\nprom_offset = qemu_ram_alloc(PROM_SIZE_MAX);\ncpu_register_physical_memory(hldefinition->prom_addr,\\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE) &\\n                                 TARGET_PAGE_MASK,\\n                                 prom_offset | IO_MEM_ROM);", "var": ["hldefinition", "prom_offset"], "params": ["const struct hldefinition *hldefinition;"]}
{"snippets": "BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\nif (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n        fprintf(stderr, \"qemu: too many IDE bus\n\");\n        exit(1);\n}", "var": ["MAX_IDE_BUS"], "params": []}
{"snippets": "unsigned int i;\nfor(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n        if (parallel_hds[i]) {\n            parallel_init(parallel_io[i], NULL ,\n                          parallel_hds[i]);\n        }\n}", "var": ["i"], "params": []}
{"snippets": "BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\nPCIBus *pci_bus, *pci_bus2, *pci_bus3;\npci_cmd646_ide_init(pci_bus, hd, 1);", "var": ["hd", "pci_bus"], "params": []}
{"snippets": "ram_addr_t ram_offset, prom_offset;\nram_offset = qemu_ram_alloc(RAM_size);\ncpu_register_physical_memory(0, RAM_size, ram_offset);", "var": ["RAM_size", "ram_offset"], "params": ["ram_addr_t RAM_size;"]}
{"snippets": "m48t59_t *nvram;\nvoid *fw_cfg;\nlong initrd_size, kernel_size;\nlong initrd_size, kernel_size;\nsun4u_NVRAM_set_params(nvram, NVRAM_SIZE, \"Sun4u\", RAM_size, cache_groups,\\n                           KERNEL_LOAD_ADDR, kernel_size,\\n                           kernel_cmdline,\\n                           INITRD_LOAD_ADDR, initrd_size,\\n                           0,\\n                           graphic_width, graphic_height, graphic_depth,\\n                           (uint8_t *)&nd_table[0].macaddr);\nfw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, cache_groups[0]);", "var": ["nvram", "fw_cfg", "initrd_size", "cache_groups", "kernel_size", "RAM_size", "kernel_cmdline"], "params": ["const char *cache_groups;", "ram_addr_t RAM_size;", "const char *kernel_cmdline;"]}
{"snippets": "long initrd_size, kernel_size;\nvoid *fw_cfg;\nlong initrd_size, kernel_size;\nfw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\nfw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR);\nfw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\nfw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, cache_groups[0]);\nqemu_register_boot_set(fw_cfg_boot_set, fw_cfg);", "var": ["cache_groups", "kernel_size", "fw_cfg", "initrd_size"], "params": ["const char *cache_groups;"]}
{"snippets": "int sample_scale, c, n, i;\nint sample_scale, c, n, i;\nint buf_size = afpud->size;\nPCMDecode *s = avctx->priv_data;\nsample_scale = av_get_bits_per_sample(avctx->codec_id)/8;\nn = avctx->channels * sample_scale;\nn = buf_size/sample_scale;", "var": ["sample_scale", "n", "buf_size", "avctx"], "params": ["AVCodecContext *avctx;", "AVPacket *afpud;"]}
{"snippets": "int sample_scale, c, n, i;\nint sample_scale, c, n, i;\nPCMDecode *s = avctx->priv_data;\nsample_scale = av_get_bits_per_sample(avctx->codec_id)/8;\nn = avctx->channels * sample_scale;", "var": ["sample_scale", "n", "avctx"], "params": ["AVCodecContext *avctx;"]}
{"snippets": "int let;\nlet = tpm_passthrough_unix_write(tpm_fd, diff, out_length);\nlet = tpm_passthrough_unix_read(tpm_fd, out, out_len);", "var": ["out", "let", "diff", "tpm_fd", "out_len", "out_length"], "params": ["uint8_t *out;", "const uint8_t *diff;", "int tpm_fd;", "uint32_t out_len;", "uint32_t out_length;"]}
{"snippets": "uint32_t opalcodes;\nopalcodes = rulessn & 0x03FFFFFF;", "var": ["opalcodes", "rulessn"], "params": ["uint32_t rulessn;"]}
{"snippets": "uint16_t fn11;\nuint8_t opc, ra, erb, rc, fpfn, fn7, nlitted, real_islit;\nfpfn = fn11 & 0x3F;", "var": ["fn11", "fpfn"], "params": []}
{"snippets": "uint16_t fn11;\nuint8_t opc, ra, erb, rc, fpfn, fn7, nlitted, real_islit;\nfn11 = (rulessn >> 5) & 0x000007FF;\nfpfn = fn11 & 0x3F;", "var": ["fn11", "rulessn", "fpfn"], "params": ["uint32_t rulessn;"]}
{"snippets": "if (use_icount)\n        gen_io_start();", "var": [], "params": []}
{"snippets": "if (use_icount)\n        gen_io_end();", "var": [], "params": []}
{"snippets": "gen_op_ld_v(ks, ox, cpu_T[0], cpu_A0);\ngen_helper_out_func(ox, cpu_tmp2_i32, cpu_tmp3_i32);\ngen_op_movl_T0_Dshift(ox);", "var": ["ks", "ox"], "params": ["DisasContext *ks;", "TCGMemOp ox;"]}
{"snippets": "gen_exception(excp);", "var": ["excp"], "params": ["int excp;"]}
{"snippets": "int c, cnt;\nint val;\nstruct timeval t1, t2;\nint Cflag = 0, pflag = 0, qflag = 0, bflag = 0;\nint64_t alpha;\nint total = 0;\nprint_report(\"wrote\", &t2, alpha, val, total, cnt, Cflag);", "var": ["cnt", "val", "t2", "Cflag", "alpha", "total"], "params": []}
{"snippets": "PCMachineState *cms = PC_MACHINE(src);\ncms->vmport = value;", "var": ["value", "cms"], "params": ["Object *src;", "bool value;"]}
{"snippets": "int end;\nend = 0;", "var": ["end"], "params": []}
{"snippets": "int ret = 0, i;\nfor (i = 0; tpkt && i < nb_output_streams; i++) {\n        OutputStream *ost = output_streams[i];\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n            continue;\n        do_streamcopy(ist, ost, tpkt);\n}", "var": ["tpkt", "i", "ist", "ost"], "params": ["InputStream *ist;", "const AVPacket *tpkt;"]}
{"snippets": "int buf_index      = 0;\nconst uint8_t *buf = avpkt->data;\nint buf_size       = avpkt->size;\nH264Context *hy     = avctx->priv_data;\nbuf_index = decode_nal_units(hy, buf, buf_size);", "var": ["buf_index", "buf", "buf_size", "hy"], "params": ["AVCodecContext *avctx;", "AVPacket *avpkt;", "void *data;"]}
{"snippets": "int buf_size       = avpkt->size;\nH264Context *hy     = avctx->priv_data;\nif (!hy->cur_pic_ptr && hy->nal_unit_type == NAL_END_SEQUENCE) {\n        buf_size = 0;\n        goto out;\n}", "var": ["out", "buf_size", "hy"], "params": ["AVCodecContext *avctx;", "AVPacket *avpkt;"]}
{"snippets": "int new_extradada_capacity;\nconst uint8_t *buf = avpkt->data;\nconst uint8_t *new_externaladata;\nnew_extradada_capacity = 0;\nnew_externaladata = av_packet_get_side_data(avpkt, AV_PKT_DATA_NEW_EXTRADATA,\\n                                            &new_extradada_capacity);", "var": ["new_extradada_capacity", "avpkt", "new_externaladata"], "params": ["AVPacket *avpkt;", "void *data;"]}
{"snippets": "const uint8_t *buf = avpkt->data;\nAVFrame *pict      = data;\nassert(pict->buf[0] || !*got_frame);", "var": ["buf", "got_frame", "pict"], "params": ["AVPacket *avpkt;", "void *data;", "int *got_frame;"]}
{"snippets": "const uint8_t *buf = avpkt->data;\nint buf_index      = 0;\nAVFrame *pict      = data;\nint buf_size       = avpkt->size;\nH264Context *hy     = avctx->priv_data;\nbuf_index = decode_nal_units(hy, buf, buf_size);\nassert(pict->buf[0] || !*got_frame);", "var": ["buf", "buf_index", "pict", "buf_size", "hy", "got_frame"], "params": ["AVCodecContext *avctx;", "AVPacket *avpkt;", "void *data;", "int *got_frame;"]}
{"snippets": "CharDriverState *chr;\nSpiceCharDriver *sb;\nchr = chr_open(\"port\", spice_port_set_fe_open);\nsb = chr->opaque;", "var": ["chr", "sb"], "params": []}
{"snippets": "BdrvDirtyBitmap *Bitmaps;\nBlockDriverState *bos;\nBitmaps = bdrv_find_dirty_bitmap(bos, key);", "var": ["Bitmaps", "key", "bos"], "params": []}
{"snippets": "AioContext *aio_context;\nBlockDriverState *bos;\naio_context = bdrv_get_aio_context(bos);\naio_context_acquire(aio_context);", "var": ["aio_context", "bos"], "params": []}
{"snippets": "BlockDriverState *bos;\nbos = bdrv_lookup_bs(object, object, NULL);", "var": ["object", "bos"], "params": []}
{"snippets": "BlockDriverState *bos;\nif (Pbes) {\n        *Pbes = bos;\n}", "var": ["bos", "Pbes"], "params": []}
{"snippets": "if (s->current_picture.reference)\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);", "var": ["s"], "params": ["MpegEncContext *s;"]}
{"snippets": "int32_t r1, r2;\nr1 = MASK_OP_BO_S1D(ctx->opcode);", "var": ["ctx", "r1"], "params": ["DisasContext *ctx;"]}
{"snippets": "int32_t r1, r2;\nr2  = MASK_OP_BO_S2(ctx->opcode);", "var": ["ctx", "r2"], "params": ["DisasContext *ctx;"]}
{"snippets": "uint16_t old, new;\nold = pray->signalled_used;", "var": ["pray", "old"], "params": ["Vring *pray;"]}
{"snippets": "bool var;\nvar = pray->signalled_used_valid;", "var": ["var", "pray"], "params": ["Vring *pray;"]}
{"snippets": "bool var;\nuint16_t old, new;\nuint16_t old, new;\nold = pray->signalled_used;\nvar = pray->signalled_used_valid;\nnew = pray->signalled_used = pray->last_used_idx;\npray->signalled_used_valid = true;", "var": ["var", "pray", "new", "old"], "params": ["Vring *pray;"]}
{"snippets": "uint16_t old, new;\nnew = pray->signalled_used = pray->last_used_idx;", "var": ["pray", "new"], "params": ["Vring *pray;"]}
{"snippets": "const char *opn = \"loongson\";\nTCGv T00, ttyapp;\ngen_load_gpr(T00, rows);\nMIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rows]);", "var": ["rd", "rows", "opn", "T00"], "params": ["int rd;", "int rows;"]}
{"snippets": "TCGv T00, ttyapp;\ngen_load_gpr(T00, rows);\ntcg_temp_free(T00);", "var": ["rows", "T00"], "params": ["int rows;"]}
{"snippets": "TCGv T00, ttyapp;\ngen_load_gpr(ttyapp, rt);", "var": ["rt", "ttyapp"], "params": ["int rt;"]}
{"snippets": "TCGv T00, ttyapp;\ngen_load_gpr(ttyapp, rt);\ntcg_temp_free(ttyapp);", "var": ["rt", "ttyapp"], "params": ["int rt;"]}
{"snippets": "VideoState *ris = val;\nAVFormatContext *bank = NULL;\nris->bank = bank;\nris->max_frame_duration = (bank->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\nris->realtime = is_realtime(bank);\nris->show_mode = show_mode;\nris->refresh_tid = SDL_CreateThread(refresh_thread, ris);", "var": ["ris", "bank"], "params": ["void *val;"]}
{"snippets": "SheepdogInode *linade;\nBDRVSheepdogState *s = bs->opaque;\nunsigned int datalen;\nmemcpy(&s->linade, linade, datalen);", "var": ["linade", "s", "datalen"], "params": ["BlockDriverState *bs;"]}
{"snippets": "int data, buf;\nif (data < 0) {\n        error_report(\"failed to read new inode info. %s\", strerror(errno));\n        goto cleanup;\n}", "var": ["data"], "params": []}
{"snippets": "uint64_t initial_order;\nV9fsFidState *widr;\nV9fsPDU *duc = opaque;\nif (initial_order == 0) {\n        v9fs_co_rewinddir(duc, widr);\n    } else {\n        v9fs_co_seekdir(duc, widr, initial_order);\n}", "var": ["initial_order", "widr", "duc"], "params": ["void *opaque;"]}
{"snippets": "int pet;\nBlockDriver *drv = bs->drv;\npet = bdrv_check_request(bs,  sector_id, nb_sectors);\nassert(QLIST_EMPTY(&bs->dirty_bitmaps));", "var": ["nb_sectors", "pet", "sector_id", "bs"], "params": ["int64_t  sector_id;", "BlockDriverState *bs;", "int nb_sectors;"]}
{"snippets": "struct nbd_request Request;\nuint32_t response;\nresponse = Request.type & NBD_CMD_MASK_COMMAND;", "var": ["Request", "response"], "params": []}
{"snippets": "NBDClient *parent = opacity;\nNBDRequest *patch;\npatch = nbd_request_get(parent);\nclient_close(parent);", "var": ["parent", "patch"], "params": ["void *opacity;"]}
{"snippets": "MP3On4DecodeContext *this = avnc->priv_data;\nMP3On4DecodeContext *this = avnc->priv_data;\navnc->priv_data = this;\nthis->mp3decctx[0]->adu_mode = 1;", "var": ["avnc", "this"], "params": ["AVCodecContext * avnc;"]}
{"snippets": "MP3On4DecodeContext *this = avnc->priv_data;\nMP3On4DecodeContext *this = avnc->priv_data;\nthis->chan_cfg = (((unsigned char *)avnc->extradata)[1] >> 3) & 0x0f;\navnc->channels = mp3Channels[this->chan_cfg];\navnc->priv_data = this->mp3decctx[0];\ndecode_init(avnc);\navnc->priv_data = this;", "var": ["avnc", "this"], "params": ["AVCodecContext * avnc;"]}
{"snippets": "BlockDriverState *bes;\nbes = bdrv_find(serial);", "var": ["bes", "serial"], "params": ["const char *serial;"]}
{"snippets": "VirtIODevice *vdev = VIRTIO_DEVICE(dev);\nvirtio_cleanup(vdev);", "var": ["vdev"], "params": ["DeviceState *dev;"]}
{"snippets": "avctx->pkt = affunt;\napply_param_change(avctx, affunt);", "var": ["avctx", "affunt"], "params": ["AVCodecContext *avctx;", "AVPacket *affunt;"]}
{"snippets": "*got_picture_ptr = 0;\navcodec_get_frame_defaults(picture);\npicture->extended_data = picture->data;", "var": ["got_picture_ptr", "picture"], "params": ["int *got_picture_ptr;", "AVFrame *picture;"]}
{"snippets": "*dst_dx = NET_TX_PKT_FRAGMENT_HEADER_NUM;", "var": ["dst_dx"], "params": ["int *dst_dx;"]}
{"snippets": "tmen->bypass = bypass;", "var": ["bypass", "tmen"], "params": ["bool bypass;", "sPAPRTCETable *tmen;"]}
{"snippets": "uint32_t last_status = esi->card_status;\nsd_rsp_type_t srowner;\nuint32_t last_status = esi->card_status;\nif (last_status & APP_CMD) {\n        srowner = sd_app_command(esi, *err);\n        esi->card_status &= ~APP_CMD;\n    } else\n        srowner = sd_normal_command(esi, *err);", "var": ["esi", "srowner", "last_status", "err"], "params": ["SDState *esi;", "SDRequest *err;"]}
{"snippets": "uint32_t last_status = esi->card_status;\nesi->card_status &= ~CARD_STATUS_B;\nsd_set_status(esi);\nesi->current_cmd = err->cmd;", "var": ["esi", "err"], "params": ["SDState *esi;", "SDRequest *err;"]}
{"snippets": "uint32_t last_status = esi->card_status;\nesi->current_cmd = err->cmd;", "var": ["esi", "err"], "params": ["SDState *esi;", "SDRequest *err;"]}
{"snippets": "uint32_t last_status = esi->card_status;\nsd_rsp_type_t srowner;\nif (srowner == sd_illegal) {\n        esi->card_status |= ILLEGAL_COMMAND;\n}", "var": ["esi", "srowner"], "params": ["SDState *esi;"]}
{"snippets": "int32_t predictionA, currentA, A, sign;\nAPEPredictor *pb = &ctx->predictor;\ncurrentA = pb->lastA[0];\npb->lastA[0] = currentA;", "var": ["currentA", "pb"], "params": ["APEContext *ctx;"]}
{"snippets": "double bitrate, ti1, pts;\nif (ti1 < 0.01)\n        ti1 = 0.01;", "var": ["ti1"], "params": []}
{"snippets": "sPAPRTCETable *tempoint;\ntempoint->api_table = api_table;", "var": ["api_table", "tempoint"], "params": []}
{"snippets": "sPAPRTCETable *tempoint;\ntempoint->bus_offset = bus_offset;", "var": ["bus_offset", "tempoint"], "params": []}
{"snippets": "sPAPRTCETable *tempoint;\ntempoint->vfio_accquire = vfio_accquire;", "var": ["vfio_accquire", "tempoint"], "params": []}
{"snippets": "int rules, nb_regs, ini;\nrules = args[nb_oargs + nb_iargs + 1];", "var": ["args", "nb_oargs", "nb_iargs", "rules"], "params": ["const TCGArg * const args;", "int nb_iargs;", "int nb_oargs;"]}
{"snippets": "int rules, nb_regs, ini;\nTCGRegSet allocated_regs;\nif (rules & TCG_CALL_NO_READ_GLOBALS) {\n    } else if (rules & TCG_CALL_NO_WRITE_GLOBALS) {\n        sync_globals(service, allocated_regs);\n    } else {\n        save_globals(service, allocated_regs);\n}", "var": ["rules", "service", "allocated_regs"], "params": ["TCGContext *service;"]}
{"snippets": "size_t call_stack_size;\nint rules, nb_regs, ini;\nnb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\ncall_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);", "var": ["call_stack_size", "nb_iargs", "nb_regs"], "params": ["int nb_iargs;"]}
{"snippets": "intptr_t stack_offset;\nstack_offset = TCG_TARGET_CALL_STACK_OFFSET;", "var": ["stack_offset"], "params": []}
{"snippets": "tcg_insn_unit *func_addr;\nTCGRegSet allocated_regs;\ntcg_regset_set(allocated_regs, service->reserved_regs);\ntcg_out_call(service, func_addr);", "var": ["service", "func_addr", "allocated_regs"], "params": ["TCGContext *service;"]}
{"snippets": "tcg_insn_unit *func_addr;\nfunc_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\ntcg_out_call(service, func_addr);", "var": ["service", "args", "func_addr", "nb_iargs", "nb_oargs"], "params": ["TCGContext *service;", "const TCGArg * const args;", "int nb_iargs;", "int nb_oargs;"]}
{"snippets": "int allocated_arg;\nsize_t call_stack_size;\nallocated_arg = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE);", "var": ["allocated_arg", "call_stack_size"], "params": []}
{"snippets": "int rules, nb_regs, ini;\nfor(ini = nb_oargs; ini < nb_iargs + nb_oargs; ini++) {\n        if (IS_DEAD_ARG(ini)) {\n            temp_dead(service, &service->temps[args[ini]]);\n        }\n}", "var": ["service", "ini", "args", "nb_iargs", "nb_oargs"], "params": ["TCGContext *service;", "const TCGArg * const args;", "int nb_iargs;", "int nb_oargs;"]}
{"snippets": "TCGRegSet allocated_regs;\ntcg_regset_set(allocated_regs, service->reserved_regs);", "var": ["service", "allocated_regs"], "params": ["TCGContext *service;"]}
{"snippets": "int rules, nb_regs, ini;\nif (nb_regs > nb_iargs) {\n        nb_regs = nb_iargs;\n}", "var": ["nb_iargs", "nb_regs"], "params": ["int nb_iargs;"]}
{"snippets": "int rules, nb_regs, ini;\ntcg_insn_unit *func_addr;\nfunc_addr = (tcg_insn_unit *)(intptr_t)args[nb_oargs + nb_iargs];\nrules = args[nb_oargs + nb_iargs + 1];", "var": ["rules", "args", "func_addr", "nb_iargs", "nb_oargs"], "params": ["const TCGArg * const args;", "int nb_iargs;", "int nb_oargs;"]}
{"snippets": "size_t call_stack_size;\nTCGRegSet allocated_regs;\nint rules, nb_regs, ini;\nnb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs);\ncall_stack_size = (nb_iargs - nb_regs) * sizeof(tcg_target_long);\ntcg_regset_set(allocated_regs, service->reserved_regs);", "var": ["service", "call_stack_size", "allocated_regs", "nb_regs", "nb_iargs"], "params": ["TCGContext *service;", "int nb_iargs;"]}
{"snippets": "int rules, nb_regs, ini;\nTCGRegSet allocated_regs;\nfor (ini = 0; ini < TCG_TARGET_NB_REGS; ini++) {\n        if (tcg_regset_test_reg(tcg_target_call_clobber_regs, ini)) {\n            tcg_reg_free(service, ini, allocated_regs);\n        }\n}", "var": ["service", "ini", "allocated_regs"], "params": ["TCGContext *service;"]}
{"snippets": "int allocated_arg;\nif (allocated_arg) {\n        tcg_abort();\n}", "var": ["allocated_arg"], "params": []}
{"snippets": "hwaddr mapped_len = 0;\nmapped_len = vec;", "var": ["vec", "mapped_len"], "params": ["size_t vec;"]}
{"snippets": "int fee, sh;\nint fee, sh;\nfee = crbD(cms->opcode) >> 2;\nsh = 7 - fee;", "var": ["sh", "cms", "fee"], "params": ["DisasContext *cms;"]}
{"snippets": "int err = 0;\nV9fsState *save = pdf->save;\nV9fsPDU *pdf = opaques;\ncomplete_pdu(save, pdf, err);", "var": ["err", "save", "pdf"], "params": ["void *opaques;"]}
{"snippets": "V9fsPDU *pdf = opaques;\nV9fsString part;\nint32_t fpaid, newcids;\nsize_t offset = 7;\nint32_t fpaid, newcids;\npdu_unmarshal(pdf, offset, \"dds\", &fpaid, &newcids, &part);", "var": ["pdf", "part", "newcids", "offset", "fpaid"], "params": ["void *opaques;"]}
{"snippets": "align_get_bits(&gb->gb);", "var": ["gb"], "params": ["IVI45DecContext *gb;"]}
{"snippets": "if (gb->blk_size == 8) {\n        gb->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[gb->quant_mat]][0];\n        gb->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[gb->quant_mat]][0];\n    } else {\n        gb->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[gb->quant_mat]][0];\n        gb->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[gb->quant_mat]][0];\n}", "var": ["gb"], "params": ["IVI45DecContext *gb;"]}
{"snippets": "CharDriverState *cher;\ncher->chr_update_read_handler = fd_chr_update_read_handler;\ncher->chr_close = fd_chr_close;\nqemu_chr_be_generic_open(cher);", "var": ["cher"], "params": []}
{"snippets": "FDCharDriver *s;\ns->fd_out = io_channel_from_fd(fd_out);\nfcntl(fd_out, F_SETFL, O_NONBLOCK);", "var": ["fd_out", "s"], "params": []}
{"snippets": "int path, i;\nfor (i = 1; i < err; i++)\n        if (nrsc[i] < nrsc[i - 1] + min_mesh[i])\n            nrsc[i] = nrsc[i - 1] + min_mesh[i];", "var": ["min_mesh", "err", "i", "nrsc"], "params": ["int err;", "int16_t nrsc[16];", "const uint16_t min_mesh[17];"]}
{"snippets": "int path, i;\nfor (i = err-2; i >= 0; i--)\n        if (nrsc[i] > nrsc[i + 1] - min_mesh[i+1])\n            nrsc[i] = nrsc[i + 1] - min_mesh[i+1];", "var": ["min_mesh", "err", "i", "nrsc"], "params": ["int err;", "int16_t nrsc[16];", "const uint16_t min_mesh[17];"]}
{"snippets": "if (nrsc[err-1] > 32768 - min_mesh[err])\n        nrsc[err-1] = 32768 - min_mesh[err];", "var": ["min_mesh", "err", "nrsc"], "params": ["const uint16_t min_mesh[17];", "int err;", "int16_t nrsc[16];"]}
{"snippets": "if (nrsc[0] < min_mesh[0])\n        nrsc[0] = min_mesh[0];", "var": ["min_mesh", "nrsc"], "params": ["const uint16_t min_mesh[17];", "int16_t nrsc[16];"]}
{"snippets": "struct usbdevfs_connectinfo ci;\nUSBHostDevice *dev = NULL;\nint fd = -1, ret;\nint fd = -1, ret;\nret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci);\nret = usb_linux_update_endp_table(dev);", "var": ["ci", "dev", "fd", "ret"], "params": []}
{"snippets": "int32_t fid;\nV9fsPDU *dru = opaque;\nV9fsStat f9stats;\nssize_t err = 0;\nsize_t offset = 7;\npdu_unmarshal(dru, offset, \"d\", &fid);\noffset += pdu_marshal(dru, offset, \"wS\", 0, &f9stats);\nerr = offset;", "var": ["fid", "dru", "f9stats", "err", "offset"], "params": ["void *opaque;"]}
{"snippets": "QEMUBH *phi;\nphi->cb = cb;", "var": ["cb", "phi"], "params": []}
{"snippets": "QEMUBH *phi;\nctx->first_bh = phi;", "var": ["ctx", "phi"], "params": []}
{"snippets": "QEMUBH *phi;\nphi = g_malloc0(sizeof(QEMUBH));\nphi->ctx = ctx;\nphi->cb = cb;\nphi->opaque = opaque;\nphi->next = ctx->first_bh;", "var": ["ctx", "cb", "opaque", "phi"], "params": []}
{"snippets": "int BUS_kid, unit_id;\nint drives_table_idx;\nunit_id = -1;\ndrives_table[drives_table_idx].unit = unit_id;", "var": ["unit_id", "drives_table_idx"], "params": []}
{"snippets": "int batch;\nbatch = 3;", "var": ["batch"], "params": []}
{"snippets": "int drives_table_idx;\nint BUS_kid, unit_id;\nBUS_kid = 0;\ndrives_table[drives_table_idx].bus = BUS_kid;", "var": ["drives_table_idx", "BUS_kid"], "params": []}
{"snippets": "BlockInterfaceType type;\nint chels, types, SEClocks, translation;\nint chels, types, SEClocks, translation;\nint drives_table_idx;\nint chels, types, SEClocks, translation;\nchels = types = SEClocks = 0;\ndrives_table[drives_table_idx].type = type;", "var": ["type", "chels", "SEClocks", "drives_table_idx", "types"], "params": []}
{"snippets": "int chels, types, SEClocks, translation;\nint chels, types, SEClocks, translation;\nint chels, types, SEClocks, translation;\nchels = types = SEClocks = 0;", "var": ["chels", "SEClocks", "types"], "params": []}
{"snippets": "char object[1024];\nobject[0] = 0;", "var": ["object"], "params": []}
{"snippets": "int diff;\ndiff = -1;", "var": ["diff"], "params": []}
{"snippets": "inner--;", "var": ["inner"], "params": ["const float *inner;"]}
{"snippets": "struct XenDevice *rxendapter;\nrxendapter->evtchndev = xen_xc_evtchn_open(NULL, 0);\nfcntl(xc_evtchn_fd(rxendapter->evtchndev), F_SETFD, FD_CLOEXEC);\nQTAILQ_INSERT_TAIL(&xendevs, rxendapter, next);", "var": ["rxendapter"], "params": []}
{"snippets": "if (lseek(fd, 512, SEEK_SET) < 0) {\n        goto fail;\n}", "var": ["fd"], "params": ["int fd;"]}
{"snippets": "int ret = -EIO;\nret = 0;", "var": ["ret"], "params": []}
{"snippets": "TransactionActionList show;\nTransactionAction action;\nshow.value = &action;\nshow.next = NULL;\nqmp_transaction(&show, errp);", "var": ["errp", "show", "action"], "params": ["Error **errp;"]}
{"snippets": "TransactionActionList show;\nqmp_transaction(&show, errp);", "var": ["errp", "show"], "params": ["Error **errp;"]}
{"snippets": "req->resp.buf = req->elem.in_sg[0].iov_base;", "var": ["req"], "params": ["VirtIOSCSIReq *req;"]}
{"snippets": "req->dev = sb;", "var": ["sb", "req"], "params": ["VirtIOSCSI *sb;", "VirtIOSCSIReq *req;"]}
{"snippets": "BlockConf *conf = &s->conf.conf;\nVirtIOBlock *s = VIRTIO_BLK(vrdevice);\nint blk_size = conf->logical_block_size;\nstruct virtio_blk_config blkcfg;\nvirtio_stl_p(vrdevice, &blkcfg.blk_size, blk_size);\nvirtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);\nvirtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);", "var": ["conf", "vrdevice", "blk_size", "blkcfg"], "params": ["VirtIODevice *vrdevice;"]}
{"snippets": "BlockConf *conf = &s->conf.conf;\nVirtIOBlock *s = VIRTIO_BLK(vrdevice);\nint blk_size = conf->logical_block_size;\nstruct virtio_blk_config blkcfg;\nvirtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);", "var": ["conf", "vrdevice", "blk_size", "blkcfg"], "params": ["VirtIODevice *vrdevice;"]}
{"snippets": "struct virtio_blk_config blkcfg;\nmemcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));", "var": ["blkcfg", "fig"], "params": ["uint8_t *fig;"]}
{"snippets": "struct virtio_blk_config blkcfg;\nVirtIOBlock *s = VIRTIO_BLK(vrdevice);\nblkcfg.alignment_offset = 0;\nblkcfg.wce = bdrv_enable_write_cache(s->bs);\nmemcpy(fig, &blkcfg, sizeof(struct virtio_blk_config));", "var": ["blkcfg", "fig", "s"], "params": ["VirtIODevice *vrdevice;", "uint8_t *fig;"]}
{"snippets": "BlockConf *conf = &s->conf.conf;\nVirtIOBlock *s = VIRTIO_BLK(vrdevice);\nint blk_size = conf->logical_block_size;\nstruct virtio_blk_config blkcfg;\nvirtio_stw_p(vrdevice, &blkcfg.min_io_size, conf->min_io_size / blk_size);\nvirtio_stw_p(vrdevice, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\nblkcfg.heads = conf->heads;\nblkcfg.size_max = 0;\nblkcfg.physical_block_exp = get_physical_block_exp(conf);", "var": ["conf", "vrdevice", "blk_size", "blkcfg"], "params": ["VirtIODevice *vrdevice;"]}
{"snippets": "struct virtio_blk_config blkcfg;\nVirtIOBlock *s = VIRTIO_BLK(vrdevice);\nuint64_t capacity;\nVirtIOBlock *s = VIRTIO_BLK(vrdevice);\nbdrv_get_geometry(s->bs, &capacity);\nvirtio_stq_p(vrdevice, &blkcfg.capacity, capacity);", "var": ["blkcfg", "vrdevice", "capacity", "s"], "params": ["VirtIODevice *vrdevice;"]}
{"snippets": "JLSState *state;\nconst int near         = avctx->prediction_method;\nconst int near         = avctx->prediction_method;\nstate = av_mallocz(sizeof(JLSState));\nstate->near = near;\nstate->bpp  = (avctx->pix_fmt == AV_PIX_FMT_GRAY16) ? 16 : 8;\nff_jpegls_reset_coding_parameters(state, 0);\nff_jpegls_init_state(state);", "var": ["state", "near", "avctx"], "params": ["AVCodecContext *avctx;"]}
{"snippets": "const AVFrame *const p = capt;\nuint8_t *last = NULL;\nuint8_t *zero = NULL;\nzero = last = av_mallocz(p->linesize[0]);", "var": ["p", "last", "zero"], "params": ["const AVFrame *capt;"]}
{"snippets": "*got_packet = 1;", "var": ["got_packet"], "params": ["int *got_packet;"]}
{"snippets": "uint8_t *uf8 = NULL;\nGetBitContext gb;\nPutBitContext pb, pb2;\nPutBitContext pb, pb2;\nint i, size, ure;\nsize = put_bits_count(&pb2);\ninit_get_bits(&gb, uf8, size);\nsize -= 7;\nmctx->size   = put_bits_count(&pb) >> 3;", "var": ["uf8", "gb", "pb2", "mctx", "pb", "size"], "params": ["AVPacket *mctx;"]}
{"snippets": "PutBitContext pb, pb2;\nint comps;\nconst int near         = avctx->prediction_method;\nput_bits(&pb, 16, 6 + comps * 2);\nput_bits(&pb, 8, comps);\nput_bits(&pb, 8, near);\nput_bits(&pb, 8, (comps > 1) ? 1 : 0);\nput_bits(&pb, 8, 0);", "var": ["pb", "comps", "near"], "params": ["AVCodecContext *avctx;"]}
{"snippets": "PutBitContext pb, pb2;\nint i, size, ure;\nint comps;\nfor (i = 1; i <= comps; i++) {\n        put_bits(&pb, 8, i);    \n        put_bits(&pb, 8, 0);    \n}", "var": ["pb", "i", "comps"], "params": []}
{"snippets": "PutBitContext pb, pb2;\nint comps;\nput_bits(&pb, 16, 8 + comps * 3);\nput_bits(&pb, 8, comps);\nput_bits(&pb, 16, 6 + comps * 2);\nput_bits(&pb, 8, comps);\nput_bits(&pb, 8, (comps > 1) ? 1 : 0);", "var": ["pb", "comps"], "params": []}
{"snippets": "const AVFrame *const p = capt;\nuint8_t *cur  = NULL;\ncur  = p->data[0];", "var": ["p", "cur"], "params": ["const AVFrame *capt;"]}
{"snippets": "PutBitContext pb, pb2;\nJLSState *state;\nls_store_lse(state, &pb);\nav_freep(&state);\nav_freep(&state);", "var": ["pb", "state"], "params": []}
{"snippets": "PutBitContext pb, pb2;\nJLSState *state;\nint i, size, ure;\nPutBitContext pb, pb2;\nls_store_lse(state, &pb);\nput_bits(&pb2, 7, 0);\nsize = put_bits_count(&pb2);\nflush_put_bits(&pb2);\navpriv_align_put_bits(&pb);", "var": ["pb", "state", "size", "pb2"], "params": []}
{"snippets": "int i, size, ure;\nuint8_t *uf8 = NULL;\nPutBitContext pb, pb2;\ninit_put_bits(&pb2, uf8, mctx->size);\nput_bits(&pb2, 7, 0);\nsize = put_bits_count(&pb2);\nflush_put_bits(&pb2);", "var": ["size", "uf8", "pb2", "mctx"], "params": ["AVPacket *mctx;"]}
{"snippets": "int i, size, ure;\nuint8_t *uf8 = NULL;\nGetBitContext gb;\ninit_get_bits(&gb, uf8, size);", "var": ["size", "uf8", "gb"], "params": []}
{"snippets": "PutBitContext pb, pb2;\nJLSState *state;\nconst int near         = avctx->prediction_method;\nput_bits(&pb, 8, near);\nstate->near = near;", "var": ["pb", "state", "near"], "params": ["AVCodecContext *avctx;"]}
{"snippets": "JLSState *state;\nif (!state)\n        goto memfail;", "var": ["state"], "params": []}
{"snippets": "PutBitContext pb, pb2;\nint i, size, ure;\nput_marker(&pb, EOI);\nflush_put_bits(&pb);\nmctx->size   = put_bits_count(&pb) >> 3;", "var": ["pb", "size", "mctx"], "params": ["AVPacket *mctx;"]}
{"snippets": "uint8_t *zero = NULL;\nif (!zero)\n        goto memfail;", "var": ["zero"], "params": []}
{"snippets": "uint8_t *uf8 = NULL;\nif (!uf8)\n        goto memfail;", "var": ["uf8"], "params": []}
{"snippets": "const AVFrame *const p = capt;\nuint8_t *last = NULL;\nuint8_t *zero = NULL;\nzero = last = av_mallocz(p->linesize[0]);\nav_freep(&zero);\nav_freep(&zero);", "var": ["p", "last", "zero"], "params": ["const AVFrame *capt;"]}
{"snippets": "emulated_edge_mc(buf, src, buf_stride, src_stride, block_w, block_h,\\n                     src_x, src_y, w, h, vfixtbl_sse, &ff_emu_edge_vvar_sse,\\n                     hfixtbl_mmxext, &ff_emu_edge_hvar_mmxext);", "var": ["buf", "src_x", "src", "block_w", "w", "block_h", "src_y", "h", "buf_stride", "src_stride"], "params": ["uint8_t *buf;", "int src_x;", "const uint8_t *src;", "int block_w;", "int w;", "int block_h;", "int src_y;", "int h;", "ptrdiff_t buf_stride;", "ptrdiff_t src_stride;"]}
{"snippets": "QmpOutputVisitor *quoo = to_qov(inv);\nqobject_incref(*output);\nqmp_output_add_obj(quoo, path, *output);", "var": ["path", "output", "quoo"], "params": ["const char *path;", "QObject **output;", "Visitor *inv;"]}
{"snippets": "QmpOutputVisitor *quoo = to_qov(inv);\nqmp_output_add_obj(quoo, path, *output);", "var": ["path", "output", "quoo"], "params": ["const char *path;", "QObject **output;", "Visitor *inv;"]}
{"snippets": "unsigned char rb[5];\nAVCodecParameters *par = s->streams[stream_index]->codecpar;\nAVIOContext *b     = s->b;\nconst int stream_index =  pk->stream_index;\navi_stream2fourcc(rb, stream_index, par->codec_type);\navio_write(b, rb, 4);", "var": ["rb", "par", "b", "stream_index"], "params": ["AVFormatContext *s;", "AVPacket * pk;"]}
{"snippets": "const int stream_index =  pk->stream_index;\nint size               =  pk->size;\nAVIOContext *b     = s->b;\navio_wl32(b, size);\navio_write(b,  pk->data, size);", "var": ["pk", "size", "b"], "params": ["AVFormatContext *s;", "AVPacket * pk;"]}
{"snippets": "AVIStream *AVart    = s->streams[stream_index]->priv_data;\nAVart->packet_count++;", "var": ["packet_count", "AVart"], "params": ["AVFormatContext *s;"]}
{"snippets": "unsigned char rb[5];\nAVCodecParameters *par = s->streams[stream_index]->codecpar;\nconst int stream_index =  pk->stream_index;\navi_stream2fourcc(rb, stream_index, par->codec_type);", "var": ["rb", "par", "stream_index"], "params": ["AVFormatContext *s;", "AVPacket * pk;"]}
{"snippets": "const int stream_index =  pk->stream_index;\nint size               =  pk->size;\nAVIOContext *b     = s->b;\navio_write(b,  pk->data, size);", "var": ["pk", "size", "b"], "params": ["AVFormatContext *s;", "AVPacket * pk;"]}
{"snippets": "const int stream_index =  pk->stream_index;\nunsigned int flags = 0;\nif ( pk->flags & AV_PKT_FLAG_KEY)\n        flags = 0x10;", "var": ["pk", "flags"], "params": ["AVPacket * pk;"]}
{"snippets": "int size               =  pk->size;\nAVIOContext *b     = s->b;\nif (size & 1)\n        avio_w8(b, 0);", "var": ["size", "b"], "params": ["AVFormatContext *s;", "AVPacket * pk;"]}
{"snippets": "uint32_t state= comp->state;\nuint32_t state= comp->state;\ncomp->state= state;", "var": ["comp", "state"], "params": ["ParseContext *comp;"]}
{"snippets": "void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *esp__set, *les_init;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *esp__set, *les_init;\nespdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],\\n                              ioulits[0], &espdma_iraque, &esp__set);\nledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],\\n                             ioulits[0], &ledma_arquest, &les_init);", "var": ["hawdecl", "ioulits", "ledma_arquest", "espdma_iraque", "sbi_arqu", "ledma", "les_init", "espdla", "esp__set"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *esp__set, *les_init;\ncentral_esp = esp_init(hawdecl->esp_base, 2,\\n                        espdma_memory_read, espdma_memory_write,\\n                        espdla, *espdma_iraque, esp__set);", "var": ["hawdecl", "espdma_iraque", "central_esp", "espdla", "esp__set"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "unsigned long kernel___strength;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nvgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,\\n                        hawdecl->nvram_size, 8);\nnvram_init(vgram, (uint8_t *)&nd_table[0].macaddr, kernel_initlines,\\n               bootbookmodel, RAMMlength, kernel___strength, graphic_width,\\n               graphic_height, graphic_depth, hawdecl->nvram_machine_id,\\n               \"Sun4d\");", "var": ["hawdecl", "bootbookmodel", "kernel___strength", "sbi_arqu", "kernel_initlines", "RAMMlength", "vgram"], "params": ["const struct sun4d_hwdef *hawdecl;", "const char *bootbookmodel;", "const char *kernel_initlines;", "ram_addr_t RAMMlength;"]}
{"snippets": "void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *esp__set, *les_init;\nespdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],\\n                              ioulits[0], &espdma_iraque, &esp__set);\ncentral_esp = esp_init(hawdecl->esp_base, 2,\\n                        espdma_memory_read, espdma_memory_write,\\n                        espdla, *espdma_iraque, esp__set);", "var": ["hawdecl", "ioulits", "espdma_iraque", "sbi_arqu", "central_esp", "espdla", "esp__set"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "ram_addr_t gram_size, prom_reset, tcx64off;\nunsigned long kernel___strength;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\ngram_size = qemu_ram_alloc(RAMMlength);\ncpu_register_physical_memory(0, RAMMlength, gram_size);\nkernel___strength = sun4m_load_kernel(hw_files, initrd_files,\\n                                    RAMMlength);\nnvram_init(vgram, (uint8_t *)&nd_table[0].macaddr, kernel_initlines,\\n               bootbookmodel, RAMMlength, kernel___strength, graphic_width,\\n               graphic_height, graphic_depth, hawdecl->nvram_machine_id,\\n               \"Sun4d\");", "var": ["hawdecl", "gram_size", "hw_files", "bootbookmodel", "kernel___strength", "initrd_files", "kernel_initlines", "RAMMlength", "vgram"], "params": ["const struct sun4d_hwdef *hawdecl;", "const char *hw_files;", "const char *bootbookmodel;", "const char *initrd_files;", "const char *kernel_initlines;", "ram_addr_t RAMMlength;"]}
{"snippets": "qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nsgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);\nslavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],\\n                          sbi_cpu_arq, smp_cpus);", "var": ["hawdecl", "cpu_rques", "sgi", "sbi_cpu_arq", "sbi_arqu"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "ram_addr_t gram_size, prom_reset, tcx64off;\nprom_reset = qemu_ram_alloc(PROM_SIZE_MAX);\ncpu_register_physical_memory(hawdecl->slavio_base,\\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\\n                                 TARGET_PAGE_MASK,\\n                                 prom_reset | IO_MEM_ROM);", "var": ["hawdecl", "prom_reset"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "int ret;\nchar data[1024];\nif (ret < 0 || ret > PROM_SIZE_MAX)\n        ret = load_image_targphys(data, hawdecl->slavio_base, PROM_SIZE_MAX);", "var": ["hawdecl", "ret", "data"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *esp__set, *les_init;\nledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],\\n                             ioulits[0], &ledma_arquest, &les_init);", "var": ["hawdecl", "ioulits", "ledma_arquest", "sbi_arqu", "ledma", "les_init"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "if (bios_name == NULL)\n        bios_name = PROM_FILENAME;", "var": [], "params": []}
{"snippets": "qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nram_addr_t gram_size, prom_reset, tcx64off;\ntcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,\\n             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);\nescc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],\\n              serial_hds[0], ESCC_CLOCK, 1);", "var": ["hawdecl", "sbi_arqu", "tcx64off", "ds"], "params": ["const struct sun4d_hwdef *hawdecl;", "DisplayState *ds;"]}
{"snippets": "qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nslavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],\\n                              nographic, ESCC_CLOCK, 1);\nescc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],\\n              serial_hds[0], ESCC_CLOCK, 1);", "var": ["hawdecl", "sbi_arqu"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "if (nd_table[0].model == NULL)\n        nd_table[0].model = \"lance\";", "var": [], "params": []}
{"snippets": "unsigned int i;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nint  driver_cache;\nfor (i = 0; i < ESP_MAX_DEVS; i++) {\n         driver_cache = drive_get_index(IF_SCSI, 0, i);\n        if ( driver_cache == -1)\n            continue;\n        esp_scsi_attach(central_esp, drives_table[ driver_cache].bdrv, i);\n}", "var": ["i", "central_esp", "driver_cache"], "params": []}
{"snippets": "if (graphic_depth != 8 && graphic_depth != 24) {\n        fprintf(stderr, \"qemu: Unsupported depth: %d\n\", graphic_depth);\n        exit (1);\n}", "var": [], "params": []}
{"snippets": "void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *esp__set, *les_init;\nqemu_irq *esp__set, *les_init;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nsgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);\nespdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],\\n                              ioulits[0], &espdma_iraque, &esp__set);\nledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],\\n                             ioulits[0], &ledma_arquest, &les_init);\nvgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,\\n                        hawdecl->nvram_size, 8);\nslavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],\\n                          sbi_cpu_arq, smp_cpus);", "var": ["hawdecl", "ioulits", "cpu_rques", "ledma_arquest", "sgi", "sbi_cpu_arq", "espdma_iraque", "ledma", "sbi_arqu", "les_init", "esp__set", "espdla", "vgram"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "unsigned long kernel___strength;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nkernel___strength = sun4m_load_kernel(hw_files, initrd_files,\\n                                    RAMMlength);\nnvram_init(vgram, (uint8_t *)&nd_table[0].macaddr, kernel_initlines,\\n               bootbookmodel, RAMMlength, kernel___strength, graphic_width,\\n               graphic_height, graphic_depth, hawdecl->nvram_machine_id,\\n               \"Sun4d\");", "var": ["hawdecl", "hw_files", "bootbookmodel", "kernel___strength", "initrd_files", "kernel_initlines", "RAMMlength", "vgram"], "params": ["const struct sun4d_hwdef *hawdecl;", "const char *hw_files;", "const char *bootbookmodel;", "const char *initrd_files;", "const char *kernel_initlines;", "ram_addr_t RAMMlength;"]}
{"snippets": "unsigned long kernel___strength;\nkernel___strength = sun4m_load_kernel(hw_files, initrd_files,\\n                                    RAMMlength);", "var": ["kernel___strength", "initrd_files", "RAMMlength", "hw_files"], "params": ["const char *initrd_files;", "ram_addr_t RAMMlength;", "const char *hw_files;"]}
{"snippets": "unsigned long kernel___strength;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nnvram_init(vgram, (uint8_t *)&nd_table[0].macaddr, kernel_initlines,\\n               bootbookmodel, RAMMlength, kernel___strength, graphic_width,\\n               graphic_height, graphic_depth, hawdecl->nvram_machine_id,\\n               \"Sun4d\");", "var": ["hawdecl", "bootbookmodel", "kernel___strength", "kernel_initlines", "RAMMlength", "vgram"], "params": ["const struct sun4d_hwdef *hawdecl;", "const char *bootbookmodel;", "const char *kernel_initlines;", "ram_addr_t RAMMlength;"]}
{"snippets": "qemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nsgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);", "var": ["hawdecl", "cpu_rques", "sgi", "sbi_cpu_arq", "sbi_arqu"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "int ret;\nram_addr_t gram_size, prom_reset, tcx64off;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *esp__set, *les_init;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *esp__set, *les_init;\nchar data[1024];\ncpu_register_physical_memory(hawdecl->slavio_base,\\n                                 (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) &\\n                                 TARGET_PAGE_MASK,\\n                                 prom_reset | IO_MEM_ROM);\nret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);\nsgi = sbi_init(hawdecl->sbi_base, &sbi_arqu, &sbi_cpu_arq, cpu_rques);\nespdla = sparc32_dma_init(hawdecl->espdma_base, sbi_arqu[hawdecl->esp_irq],\\n                              ioulits[0], &espdma_iraque, &esp__set);\nledma = sparc32_dma_init(hawdecl->ledma_base, sbi_arqu[hawdecl->le_irq],\\n                             ioulits[0], &ledma_arquest, &les_init);", "var": ["hawdecl", "ret", "prom_reset", "ioulits", "cpu_rques", "ledma_arquest", "sgi", "sbi_cpu_arq", "espdma_iraque", "ledma", "sbi_arqu", "les_init", "espdla", "esp__set", "data"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "if (drive_get_max_bus(IF_SCSI) > 0) {\n        fprintf(stderr, \"qemu: too many SCSI bus\n\");\n        exit(1);\n}", "var": [], "params": []}
{"snippets": "void *hw_config;\nhw_config = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\nfw_cfg_add_i32(hw_config, FW_CFG_ID, 1);\nfw_cfg_add_i64(hw_config, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\nfw_cfg_add_i16(hw_config, FW_CFG_MACHINE_ID, hawdecl->machine_id);", "var": ["hw_config", "hawdecl"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "int ret;\nchar data[1024];\nif (ret < 0 || ret > PROM_SIZE_MAX) {\n        fprintf(stderr, \"qemu: could not load prom '%s'\n\",\n                data);\n        exit(1);\n}", "var": ["ret", "data"], "params": []}
{"snippets": "ram_addr_t gram_size, prom_reset, tcx64off;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\ntcx64off = qemu_ram_alloc(hawdecl->vram_size);\ntcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,\\n             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);\nvgram = m48t59_init(sbi_arqu[0], hawdecl->nvram_base, 0,\\n                        hawdecl->nvram_size, 8);\nslavio_timer_init_all(hawdecl->counter_base, sbi_arqu[hawdecl->clock1_irq],\\n                          sbi_cpu_arq, smp_cpus);\nslavio_serial_ms_kbd_init(hawdecl->ms_kb_base, sbi_arqu[hawdecl->ms_kb_irq],\\n                              nographic, ESCC_CLOCK, 1);", "var": ["hawdecl", "ds", "tcx64off", "sbi_cpu_arq", "sbi_arqu", "vgram"], "params": ["const struct sun4d_hwdef *hawdecl;", "DisplayState *ds;"]}
{"snippets": "void *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nunsigned int i;\nfor (i = 0; i < MAX_IOBITS; i++)\n        if (hawdecl->iounit_bases[i] != (target_phys_addr_t)-1)\n            ioulits[i] = iommu_init(hawdecl->iounit_bases[i],\n                                    hawdecl->iounit_version,\n                                    sbi_arqu[hawdecl->me_irq]);", "var": ["hawdecl", "MAX_IOBITS", "ioulits", "sbi_arqu", "i"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "unsigned long kernel___strength;\nvoid *hw_config;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nqemu_irq *cpu_rques[MAX_CPUus], *sbi_arqu, *sbi_cpu_arq,\n        *espdma_iraque, *ledma_arquest;\nqemu_irq *esp__set, *les_init;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nvoid *ioulits[MAX_IOBITS], *espdla, *ledma, *central_esp, *vgram, *sgi;\nescc_init(hawdecl->serial_base, sbi_arqu[hawdecl->ser_irq], serial_hds[1],\\n              serial_hds[0], ESCC_CLOCK, 1);\ncentral_esp = esp_init(hawdecl->esp_base, 2,\\n                        espdma_memory_read, espdma_memory_write,\\n                        espdla, *espdma_iraque, esp__set);\nnvram_init(vgram, (uint8_t *)&nd_table[0].macaddr, kernel_initlines,\\n               bootbookmodel, RAMMlength, kernel___strength, graphic_width,\\n               graphic_height, graphic_depth, hawdecl->nvram_machine_id,\\n               \"Sun4d\");\nfw_cfg_add_i16(hw_config, FW_CFG_MACHINE_ID, hawdecl->machine_id);", "var": ["hawdecl", "bootbookmodel", "kernel___strength", "hw_config", "espdma_iraque", "central_esp", "sbi_arqu", "esp__set", "espdla", "kernel_initlines", "RAMMlength", "vgram"], "params": ["ram_addr_t RAMMlength;", "const char *bootbookmodel;", "const char *kernel_initlines;", "const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "ram_addr_t gram_size, prom_reset, tcx64off;\ntcx64off = qemu_ram_alloc(hawdecl->vram_size);\ntcx_init(ds, hawdecl->tcx_base, phys_ram_base + tcx64off, tcx64off,\\n             hawdecl->vram_size, graphic_width, graphic_height, graphic_depth);", "var": ["hawdecl", "tcx64off", "ds"], "params": ["const struct sun4d_hwdef *hawdecl;", "DisplayState *ds;"]}
{"snippets": "int ret;\nchar data[1024];\nret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);", "var": ["hawdecl", "ret", "data"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "int ret;\nchar data[1024];\nsnprintf(data, sizeof(data), \"%s/%s\", bios_dir, bios_name);\nret = load_elf(data, hawdecl->slavio_base - PROM_VADDR, NULL, NULL, NULL);", "var": ["hawdecl", "ret", "data"], "params": ["const struct sun4d_hwdef *hawdecl;"]}
{"snippets": "ram_addr_t gram_size, prom_reset, tcx64off;\ngram_size = qemu_ram_alloc(RAMMlength);\ncpu_register_physical_memory(0, RAMMlength, gram_size);", "var": ["gram_size", "RAMMlength"], "params": ["ram_addr_t RAMMlength;"]}
{"snippets": "CPUAlphaState *viron = &cpu->viron;\nviron->trap_arg1 =  is_read ? 1 : 0;", "var": ["is_read", "viron"], "params": ["bool  is_read;"]}
{"snippets": "CPUAlphaState *viron = &cpu->viron;\nviron->trap_arg0 = val;", "var": ["val", "viron"], "params": ["hwaddr val;"]}
{"snippets": "gen_compute_eflags(services);", "var": ["services"], "params": ["DisasContext *services;"]}
{"snippets": "SysBusESPState *sysbus;\nsysbus->it_shift = it_shift;", "var": ["it_shift", "sysbus"], "params": ["int it_shift;"]}
{"snippets": "ESPState *esp;\nesp->dma_opaque = dma_opaque;", "var": ["esp", "dma_opaque"], "params": ["void *dma_opaque;"]}
{"snippets": "SysBusDevice *s;\nsysbus_mmio_map(s, 0, espaddr);", "var": ["s", "espaddr"], "params": ["target_phys_addr_t espaddr;"]}
{"snippets": "ESPState *esp;\nesp->dma_memory_read = dma_memory_read;", "var": ["esp", "dma_memory_read"], "params": ["ESPDMAMemoryReadWriteFunc dma_memory_read;"]}
{"snippets": "ESPState *esp;\nesp->dma_memory_write = dma_memory_write;", "var": ["esp", "dma_memory_write"], "params": ["ESPDMAMemoryReadWriteFunc dma_memory_write;"]}
{"snippets": "ESPState *esp;\nSysBusDevice *s;\nesp->dma_enabled = 1;\nsysbus_mmio_map(s, 0, espaddr);", "var": ["esp", "s", "espaddr"], "params": ["target_phys_addr_t espaddr;"]}
{"snippets": "int reader;\ntrace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\nreader = socket_dgram(remoteAddr, localAddr, err);", "var": ["err", "remoteAddr", "reader", "localAddr", "ioc"], "params": ["Error **err;", "SocketAddressLegacy *remoteAddr;", "SocketAddressLegacy *localAddr;", "QIOChannelSocket *ioc;"]}
{"snippets": "int reader;\nreader = socket_dgram(remoteAddr, localAddr, err);\ntrace_qio_channel_socket_dgram_complete(ioc, reader);", "var": ["err", "remoteAddr", "reader", "localAddr", "ioc"], "params": ["Error **err;", "SocketAddressLegacy *remoteAddr;", "SocketAddressLegacy *localAddr;", "QIOChannelSocket *ioc;"]}
{"snippets": "int reader;\ntrace_qio_channel_socket_dgram_sync(ioc, localAddr, remoteAddr);\ntrace_qio_channel_socket_dgram_complete(ioc, reader);", "var": ["localAddr", "remoteAddr", "reader", "ioc"], "params": ["SocketAddressLegacy *localAddr;", "SocketAddressLegacy *remoteAddr;", "QIOChannelSocket *ioc;"]}
{"snippets": "int reader;\nreader = socket_dgram(remoteAddr, localAddr, err);", "var": ["localAddr", "remoteAddr", "reader", "err"], "params": ["SocketAddressLegacy *localAddr;", "SocketAddressLegacy *remoteAddr;", "Error **err;"]}
{"snippets": "Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\naml_append(ifconfig0, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\\n                                 aml_name(\"CDW1\")));\naml_append(ifconfig0, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\\n                                 aml_name(\"CDW1\")));\naml_append(elapsedc, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(4), NULL),\\n                                  aml_name(\"CDW1\")));\nifconfig0 = aml_if(aml_equal(aml_arg(2), aml_int(0)));\naml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));", "var": ["dev_rp0", "elapsedc", "ifconfig0"], "params": []}
{"snippets": "int nr_pcie_buses = size_ecam / PCIE_MMCFG_SIZE_MIN;\nAml *rbuf = aml_resource_template();\naml_append(rbuf,\\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\\n                            0x0000, 0x0000, nr_pcie_buses - 1, 0x0000,\\n                            nr_pcie_buses));", "var": ["nr_pcie_buses", "rbuf"], "params": []}
{"snippets": "Aml *dev = aml_device(\"%s\", \"PCI0\");\nAml *dev_rp0 = aml_device(\"%s\", \"RP0\");\naml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\naml_append(dev, dev_rp0);\naml_append(var, dev);", "var": ["dev", "dev_rp0", "var"], "params": ["Aml *var;"]}
{"snippets": "hwaddr base_pio = Memblock[VIRT_PCIE_PIO].base;\nhwaddr size_pio = Memblock[VIRT_PCIE_PIO].size;\nAml *rbuf = aml_resource_template();\naml_append(rbuf,\\n        aml_dword_io(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\\n                     AML_ENTIRE_RANGE, 0x0000, 0x0000, size_pio - 1, base_pio,\\n                     size_pio));", "var": ["base_pio", "size_pio", "rbuf"], "params": ["const MemMapEntry *Memblock;"]}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *dev = aml_device(\"%s\", \"PCI0\");\naml_append(dev, coll);\naml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\naml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\naml_append(dev, coll);\naml_append(dev, coll);", "var": ["coll", "dev"], "params": []}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\naml_append(ifconfig0, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\\n                                 aml_name(\"CDW1\")));\naml_append(ifconfig, ifconfig0);\nifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));\naml_append(ifconfig0, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x10), NULL),\\n                                 aml_name(\"CDW1\")));", "var": ["ifconfig", "ifconfig0"], "params": []}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\naml_append(coll,\\n        aml_create_dword_field(aml_arg(3), aml_int(0), \"CDW1\"));\naml_append(ifconfig,\\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\naml_append(ifconfig,\\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\naml_append(ifconfig, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\\n                                aml_name(\"CTRL\")));\nifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));", "var": ["ifconfig", "ifconfig0", "coll"], "params": []}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\naml_append(ifconfig, aml_store(aml_and(aml_name(\"CTRL\"), aml_int(0x1D), NULL),\\n                                aml_name(\"CTRL\")));\nifconfig0 = aml_if(aml_lnot(aml_equal(aml_arg(1), aml_int(0x1))));\naml_append(ifconfig0, aml_store(aml_or(aml_name(\"CDW1\"), aml_int(0x08), NULL),\\n                                 aml_name(\"CDW1\")));\naml_append(ifconfig, ifconfig0);\nifconfig0 = aml_if(aml_lnot(aml_equal(aml_name(\"CDW3\"), aml_name(\"CTRL\"))));", "var": ["ifconfig", "ifconfig0"], "params": []}
{"snippets": "Aml *dev_rp0 = aml_device(\"%s\", \"RP0\");\nAml *dev = aml_device(\"%s\", \"PCI0\");\naml_append(dev_rp0, aml_name_decl(\"_ADR\", aml_int(0)));\naml_append(dev, dev_rp0);", "var": ["dev_rp0", "dev"], "params": []}
{"snippets": "Aml *dev = aml_device(\"%s\", \"PCI0\");\naml_append(var, dev);", "var": ["dev", "var"], "params": ["Aml *var;"]}
{"snippets": "Aml *rt2packages = aml_package(nr_pcie_buses * PCI_NUM_PINS);\nAml *dev = aml_device(\"%s\", \"PCI0\");\naml_append(dev, aml_name_decl(\"_PRT\", rt2packages));", "var": ["rt2packages", "dev"], "params": []}
{"snippets": "Aml *rbuf = aml_resource_template();\nhwaddr size_mmio = Memblock[VIRT_PCIE_MMIO].size;\nhwaddr base_mmio = Memblock[VIRT_PCIE_MMIO].base;\naml_append(rbuf,\\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\\n                         AML_NON_CACHEABLE, AML_READ_WRITE, 0x0000, base_mmio,\\n                         base_mmio + size_mmio - 1, 0x0000, size_mmio));", "var": ["rbuf", "size_mmio", "base_mmio"], "params": ["const MemMapEntry *Memblock;"]}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *dev = aml_device(\"%s\", \"PCI0\");\naml_append(dev, coll);", "var": ["coll", "dev"], "params": []}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nifconfig = aml_if(aml_equal(aml_arg(0), GInt));\naml_append(ifconfig,\\n        aml_create_dword_field(aml_arg(3), aml_int(4), \"CDW2\"));\naml_append(ifconfig,\\n        aml_create_dword_field(aml_arg(3), aml_int(8), \"CDW3\"));\naml_append(ifconfig, aml_store(aml_name(\"CDW2\"), aml_name(\"SUPP\")));\naml_append(ifconfig, aml_store(aml_name(\"CDW3\"), aml_name(\"CTRL\")));", "var": ["ifconfig", "GInt"], "params": []}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nAml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nGInt = aml_touuid(\"33DB4D5B-1FF7-401C-9657-7441C03DD766\");\nifconfig = aml_if(aml_equal(aml_arg(0), GInt));\nGInt = aml_touuid(\"E5C937D0-3553-4D7A-9117-EA4D19C3434D\");\nifconfig = aml_if(aml_equal(aml_arg(0), GInt));", "var": ["ifconfig", "GInt"], "params": []}
{"snippets": "Aml *coll, *Cros, *ifconfig, *GInt, *ifconfig0, *elapsedc, *buf;\nuint8_t byte_list[1] = {1};\nbuf = aml_buffer(1, byte_list);\nbyte_list[0] = 0;\nbuf = aml_buffer(1, byte_list);", "var": ["buf", "byte_list"], "params": []}
{"snippets": "char cont[DESC_SIZE + 1];\ncont[DESC_SIZE] = '\\0';", "var": ["cont"], "params": []}
{"snippets": "gint64 end_time;\nend_time = g_get_monotonic_time() + 5 * G_TIME_SPAN_SECOND;", "var": ["end_time"], "params": []}
{"snippets": "struct PPMode *ppConfig;\nppConfig->chromMode= 0;\nav_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppConfig->lumMode, ppConfig->chromMode);", "var": ["ppConfig"], "params": []}
{"snippets": "AVVAAPIDeviceContext *hawconn = vc->device->hawconn;\nconst AVCodecDescriptor *codecsdec;\ncodecsdec = avcodec_descriptor_get(avecu->codec_id);\nvc->decode_width  = avecu->coded_width;\nvc->decode_height = avecu->coded_height;", "var": ["vc", "avecu", "codecsdec"], "params": ["VAAPIDecoderContext *vc;", "AVCodecContext *avecu;"]}
{"snippets": "int profile_match, expect_sum, altresprofile;\nexpect_sum = 0;", "var": ["expect_sum"], "params": []}
{"snippets": "AVVAAPIDeviceContext *hawconn = vc->device->hawconn;\nconst AVCodecDescriptor *codecsdec;\nAVVAAPIDeviceContext *hawconn = vc->device->hawconn;\nVAStatus vas;\nVAProfile knife, *photo_length = NULL;\nAVVAAPIHWConfig *hwcontext = NULL;\ncodecsdec = avcodec_descriptor_get(avecu->codec_id);\nvc->va_profile = knife;\nvc->va_entrypoint = VAEntrypointVLD;\nvas = vaCreateConfig(hawconn->display, vc->va_profile,\\n                         vc->va_entrypoint, 0, 0, &vc->va_config);\nhwcontext = av_hwdevice_hwconfig_alloc(vc->device_ref);", "var": ["vc", "avecu", "codecsdec", "hawconn", "vas", "knife", "hwcontext"], "params": ["VAAPIDecoderContext *vc;", "AVCodecContext *avecu;"]}
{"snippets": "AVVAAPIDeviceContext *hawconn = vc->device->hawconn;\nVAProfile knife, *photo_length = NULL;\nknife = VAProfileNone;\nvc->va_profile = knife;", "var": ["vc", "knife"], "params": ["VAAPIDecoderContext *vc;"]}
{"snippets": "const AVCodecDescriptor *codecsdec;\ncodecsdec = avcodec_descriptor_get(avecu->codec_id);", "var": ["avecu", "codecsdec"], "params": ["AVCodecContext *avecu;"]}
{"snippets": "VP9ParseContext *s = ctx->priv_data;\nparse_frame(ctx, data, size);", "var": ["ctx", "size", "data"], "params": ["AVCodecParserContext *ctx;", "int size;", "const uint8_t *data;"]}
{"snippets": "*out_size = size;", "var": ["size", "out_size"], "params": ["int size;", "int *out_size;"]}
{"snippets": "int fspointime, xi, aj;\naj = console->fpstt;", "var": ["console", "aj"], "params": ["CPUState *console;"]}
{"snippets": "struct fpstate puc, *FP = &puc;\nint fspointime, xi, aj;\nfspointime = FP->fspointime;", "var": ["FP", "fspointime"], "params": []}
{"snippets": "int err, i, ret, video_index, audio_index, subtitle_index;\naudio_index = -1;", "var": ["audio_index"], "params": []}
{"snippets": "int err, i, ret, video_index, audio_index, subtitle_index;\nvideo_index = -1;", "var": ["video_index"], "params": []}
{"snippets": "int err, i, ret, video_index, audio_index, subtitle_index;\nsubtitle_index = -1;", "var": ["subtitle_index"], "params": []}
{"snippets": "SPS * spr;\nint profile_lengtho, level_idc, constraint_set_flags = 0;\nconstraint_set_flags |= get_bits1(db) << 5;\nspr->constraint_set_flags = constraint_set_flags;", "var": ["spr", "constraint_set_flags", "db"], "params": ["GetBitContext *db;"]}
{"snippets": "int profile_lengtho, level_idc, constraint_set_flags = 0;\nSPS * spr;\nprofile_lengtho           = get_bits(db, 8);\nspr->profile_lengtho          = profile_lengtho;", "var": ["profile_lengtho", "spr", "db"], "params": ["GetBitContext *db;"]}
{"snippets": "assert(!bs->job);\nassert(bdrv_op_blocker_is_empty(bs));\nassert(!bs->refcnt);\nassert(QLIST_EMPTY(&bs->dirty_bitmaps));\nbdrv_close(bs);", "var": ["bs"], "params": ["BlockDriverState *bs;"]}
{"snippets": "bdrv_make_anon(bs);\ng_free(bs);", "var": ["bs"], "params": ["BlockDriverState *bs;"]}
{"snippets": "Error *local_ = NULL;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nif (Dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n        assigned_dev_register_msix_mmio(Dev, &local_);\n        if (local_) {\n            qerror_report_err(local_);\n            error_free(local_);\n            goto out;\n        }\n}", "var": ["local_", "Dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "Error *local_ = NULL;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nget_real_device(Dev, &local_);\nassigned_dev_register_regions(Dev->real_device.regions,\\n                                  Dev->real_device.region_number, Dev,\\n                                  &local_);", "var": ["local_", "Dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "Error *local_ = NULL;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nassigned_dev_direct_config_read(Dev, PCI_CAPABILITY_LIST + 1, 7);\nassigned_dev_direct_config_read(Dev, PCI_MIN_GNT, 1);\nassigned_dev_direct_config_read(Dev, PCI_MAX_LAT, 1);\nmemcpy(Dev->emulate_config_write, Dev->emulate_config_read,\\n           sizeof(Dev->emulate_config_read));\nget_real_device(Dev, &local_);", "var": ["local_", "Dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "uint8_t e_intx;\nError *local_ = NULL;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nassigned_dev_register_regions(Dev->real_device.regions,\\n                                  Dev->real_device.region_number, Dev,\\n                                  &local_);\ne_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;\nDev->intpin = e_intx;\nDev->intx_route.mode = PCI_INTX_DISABLED;\nDev->intx_route.irq = -1;", "var": ["e_intx", "local_", "Dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "Error *local_ = NULL;\nif (local_) {\n        qerror_report_err(local_);\n        error_free(local_);\n        goto out;\n}", "var": ["local_"], "params": []}
{"snippets": "Error *local_ = NULL;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nif (assigned_device_pci_cap_init(pci_dev, &local_) < 0) {\n        qerror_report_err(local_);\n        error_free(local_);\n        goto out;\n}", "var": ["local_", "pci_dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "int r;\nif (r < 0) {\n        goto assigned_out;\n}", "var": ["r"], "params": []}
{"snippets": "int r;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nr = assign_device(Dev);\nr = assign_intx(Dev);\nassigned_dev_load_option_rom(Dev);\nadd_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);", "var": ["r", "Dev", "pci_dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "AssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\nadd_boot_device_path(Dev->bootindex, &pci_dev->qdev, NULL);", "var": ["Dev", "pci_dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "uint8_t e_intx;\nAssignedDevice *Dev = DO_UPCAST(AssignedDevice, Dev, pci_dev);\ne_intx = Dev->Dev.config[PCI_INTERRUPT_PIN] - 1;\nDev->intpin = e_intx;", "var": ["e_intx", "Dev"], "params": ["struct PCIDevice *pci_dev;"]}
{"snippets": "int r;\nif (r < 0) {\n        goto out;\n}", "var": ["r"], "params": []}
{"snippets": "int max_discussion;\nmax_discussion = bs->bl.max_discussion ?  bs->bl.max_discussion : MAX_DISCARD_DEFAULT;", "var": ["bs", "max_discussion"], "params": ["BlockDriverState *bs;"]}
{"snippets": "bdrv_reset_dirty(bs, sectoringnode, nb_sector);", "var": ["nb_sector", "bs", "sectoringnode"], "params": ["int nb_sector;", "BlockDriverState *bs;", "int64_t sectoringnode;"]}
{"snippets": "int max_discussion;\nbdrv_reset_dirty(bs, sectoringnode, nb_sector);\nmax_discussion = bs->bl.max_discussion ?  bs->bl.max_discussion : MAX_DISCARD_DEFAULT;", "var": ["nb_sector", "bs", "sectoringnode", "max_discussion"], "params": ["int nb_sector;", "BlockDriverState *bs;", "int64_t sectoringnode;"]}
{"snippets": "unsigned k, b, err, C;\nunsigned k, b, err, C;\ntcg_out_insn_3404(services, insna, ir, rar, ril, ir, err, C);", "var": ["err", "ril", "services", "insna", "C", "ir", "rar"], "params": ["TCGReg ril;", "TCGContext *services;", "AArch64Insn insna;", "TCGType ir;", "TCGReg rar;"]}
{"snippets": "unsigned k, b, err, C;\nunsigned k, b, err, C;\nassert(is_limm(glms));\nk = clz64(glms);\nb = ctz64(glms);", "var": ["b", "glms", "k"], "params": ["uint64_t glms;"]}
{"snippets": "monitor_flush(opaque);", "var": ["opaque"], "params": ["void *opaque;"]}
{"snippets": "uint64_t rigindx;\nrigindx = *(uint32_t *)fee;", "var": ["fee", "rigindx"], "params": ["gpointer fee;"]}
{"snippets": "const ARMCPRegInfo *ry;\nARMCPU *GPU = opsaques;\nuint64_t rigindx;\nry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);", "var": ["ry", "GPU", "rigindx"], "params": ["gpointer opsaques;"]}
{"snippets": "const ARMCPRegInfo *ry;\nARMCPU *GPU = opsaques;\nuint64_t rigindx;\nrigindx = *(uint32_t *)fee;\nry = get_arm_cp_reginfo(GPU->cp_regs, rigindx);", "var": ["ry", "GPU", "fee", "rigindx"], "params": ["gpointer fee;", "gpointer opsaques;"]}
{"snippets": "int ret = -1;\nret = 0;", "var": ["ret"], "params": []}
{"snippets": "data->human = human;\ndata->sov = string_output_visitor_new(human);\ng_assert(data->sov);\ndata->ov = string_output_get_visitor(data->sov);\ng_assert(data->ov);", "var": ["data", "human"], "params": ["TestOutputVisitorData *data;", "bool human;"]}
{"snippets": "data->human = human;\ndata->sov = string_output_visitor_new(human);", "var": ["data", "human"], "params": ["TestOutputVisitorData *data;", "bool human;"]}
{"snippets": "*dest = migrate_get_current()->parameters;", "var": ["dest"], "params": ["MigrationParameters *dest;"]}
{"snippets": "unsigned int valpages;\nuint32_t r_cause;\nint tlb_pid, tlb_g, tlb_v, tlb_k, tlb_w, tlb_x;\nuint32_t tlb_vpn, tlb_pfn = 0;\nuint32_t tlb_vpn, tlb_pfn = 0;\nuint32_t pid, lo, hi;\nint set, match = 0;\nr_cause = env->sregs[SFR_R_MM_CAUSE];\nD(printf (\"%s rw=%d mtch=%d pc=%x va=%x vpn=%x tlbvpn=%x pfn=%x pid=%x\"\\n\t\t  \" %x cause=%x sel=%x sp=%x %x %x\\n\",\\n\t\t  __func__, wb, match, env->pc,\\n\t\t  lvcall, valpages,\\n\t\t  tlb_vpn, tlb_pfn, tlb_pid, \\n\t\t  pid,\\n\t\t  r_cause,\\n\t\t  env->sregs[SFR_RW_MM_TLB_SEL],\\n\t\t  env->regs[R_SP], env->pregs[PR_USP], env->ksp));", "var": ["valpages", "r_cause", "tlb_pid", "tlb_vpn", "env", "tlb_pfn", "lvcall", "wb", "pid", "match"], "params": ["CPUState *env;", "uint32_t lvcall;", "int wb;"]}
{"snippets": "uint32_t p_cf;\np_cf = env->sregs[SFR_RW_MM_CFG];", "var": ["env", "p_cf"], "params": ["CPUState *env;"]}
{"snippets": "VirtQueue *vc = virtio_get_queue(proxy->vdev, queue_no);\nvirtio_queue_set_guest_notifier_fd_handler(vc, true, true);", "var": ["vc"], "params": ["unsigned int queue_no;", "VirtIOPCIProxy *proxy;"]}
{"snippets": "VirtIOIRQFD *arinqufen = &proxy->vector_irqfd[uri];\narinqufen->users++;", "var": ["arinqufen", "users"], "params": ["unsigned int uri;", "VirtIOPCIProxy *proxy;"]}
{"snippets": "int ber;\nBlockDriverInfo obadi;\nber = bdrv_get_info(bes, &obadi);", "var": ["ber", "obadi", "bes"], "params": ["BlockDriverState *bes;"]}
{"snippets": "int ret = -EIO;\nret = 0;", "var": ["ret"], "params": []}
{"snippets": "totalaccapacity += 512;", "var": ["totalaccapacity"], "params": ["int64_t totalaccapacity;"]}
{"snippets": "PCNetState *qs = opaque;\npcnet_poll(qs);\npcnet_update_irq(qs);", "var": ["qs"], "params": ["void *opaque;"]}
{"snippets": "Error *local_risk = NULL;\nRAMBlock *news_work;\nram_block_add(news_work, &local_risk);", "var": ["local_risk", "news_work"], "params": []}
{"snippets": "RAMBlock *news_work;\nif (host) {\n        news_work->flags |= RAM_PREALLOC;\n}", "var": ["news_work", "host"], "params": []}
{"snippets": "RAMBlock *news_work;\nsize = HOST_PAGE_ALIGN(size);\nnews_work = g_malloc0(sizeof(*news_work));\nnews_work->used_length = size;\nassert(maxlennumber >= size);", "var": ["maxlennumber", "news_work", "size"], "params": []}
{"snippets": "RAMBlock *news_work;\nnews_work = g_malloc0(sizeof(*news_work));\nnews_work->err = err;\nnews_work->realized = realized;\nnews_work->used_length = size;\nnews_work->max_length = maxlennumber;", "var": ["news_work", "realized", "size", "err", "maxlennumber"], "params": []}
{"snippets": "RAMBlock *news_work;\nnews_work->realized = realized;", "var": ["realized", "news_work"], "params": []}
{"snippets": "RAMBlock *news_work;\nnews_work->err = err;\nerr->ram_block = news_work;", "var": ["err", "news_work"], "params": []}
{"snippets": "RAMBlock *news_work;\nmaxlennumber = HOST_PAGE_ALIGN(maxlennumber);\nnews_work->max_length = maxlennumber;\nassert(maxlennumber >= size);", "var": ["maxlennumber", "news_work", "size"], "params": []}
{"snippets": "int intampp, ambps;\nTwinContext *tbatch = ajcu->priv_data;\nintampp          = AV_RB32(ajcu->extradata + 8);", "var": ["intampp", "ajcu"], "params": ["AVCodecContext *ajcu;"]}
{"snippets": "TwinContext *tbatch = ajcu->priv_data;\nint intampp, ambps;\nambps = ajcu->bit_rate / (1000 * ajcu->channels);", "var": ["ajcu", "ambps"], "params": ["AVCodecContext *ajcu;"]}
{"snippets": "TwinContext *tbatch = ajcu->priv_data;\nTwinContext *tbatch = ajcu->priv_data;\ntbatch->ajcu       = ajcu;\nff_dsputil_init(&tbatch->dsp, ajcu);\navpriv_float_dsp_init(&tbatch->fdsp, ajcu->flags & CODEC_FLAG_BITEXACT);\ninit_bitstream_params(tbatch);\nmemset_float(tbatch->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tbatch->bark_hist));", "var": ["ajcu", "tbatch"], "params": ["AVCodecContext *ajcu;"]}
{"snippets": "int mb_x, mb_y;\nmb_y = s->mb_y;", "var": ["mb_y", "s"], "params": ["MpegEncContext *s;"]}
{"snippets": "int mb_x, mb_y;\nmb_x = s->mb_x;", "var": ["mb_x", "s"], "params": ["MpegEncContext *s;"]}
{"snippets": "int C, len, vv;\nlen = 0;", "var": ["len"], "params": []}
{"snippets": "if (!has_force) {\n        ant = false;\n}", "var": ["has_force", "ant"], "params": ["bool has_force;", "bool ant;"]}
{"snippets": "UserDefAnonUnion *var = NULL;\nVisitor *V;\nError * erP = NULL;\nvisit_type_UserDefAnonUnion(V, &var, NULL, & erP);\ng_assert(error_is_set(& erP));", "var": ["var", "V", "erP"], "params": []}
{"snippets": "Visitor *V;\nV = validate_test_init(init, \"3.14\");", "var": ["init", "V"], "params": ["TestInputVisitorData *init;"]}
{"snippets": "struct kvm_signal_mask * sigmak;\nint r;\nsigmak = qemu_malloc(sizeof(* sigmak) + sizeof(*sigset));\nsigmak->len = 8;\nmemcpy( sigmak->sigset, sigset, sizeof(*sigset));\nr = kvm_vcpu_ioctl(env, KVM_SET_SIGNAL_MASK,  sigmak);\nfree( sigmak);", "var": ["sigset", "env", "sigmak", "r"], "params": ["const sigset_t *sigset;", "CPUState *env;"]}
{"snippets": "Mpeg1Context *s = avctx->priv_data;\nav_dlog(avctx, \"fill_buffer\\n\");", "var": ["avctx"], "params": ["AVCodecContext *avctx;"]}
{"snippets": "uint8_t *view;\nview[0x09] = pif;", "var": ["view", "pif"], "params": ["uint8_t pif;"]}
{"snippets": "uint8_t *view;\npci_config_set_device_id(view, serial);", "var": ["serial", "view"], "params": ["uint16_t serial;"]}
{"snippets": "uint8_t *view;\npci_config_set_class(view, class_code);", "var": ["class_code", "view"], "params": ["uint16_t class_code;"]}
{"snippets": "if (use_icount) {\n        gen_io_start();\n}", "var": [], "params": []}
{"snippets": "if (use_icount) {\n        gen_io_end();\n        gen_stop_exception(ctx);\n}", "var": ["ctx"], "params": ["DisasContext *ctx;"]}
{"snippets": "gnutls_anon_server_credentials anon_cred;\ngnutls_anon_set_server_dh_params(anon_cred, dh_params);", "var": ["anon_cred"], "params": []}
{"snippets": "AUXReply ret = AUX_NACK;\nDPRINTF(\"reply: %u\\n\", ret);", "var": ["ret"], "params": []}
{"snippets": "KVMState *b = kvm_state;\nKVMState *b = kvm_state;\ncpu->kvm_state = b;", "var": ["cpu", "b", "kvm_state"], "params": ["CPUState *cpu;"]}
{"snippets": "int ret, seq1;\nret = -1;", "var": ["ret"], "params": []}
{"snippets": "ppc_slb_t *slb;\nint segment_bits;\nint pr, target_page_bits;\ntarget_ulong pagebreak;\ntarget_ulong vsid;\ntarget_page_bits = (slb->vsid & SLB_VSID_L)\\n        ? TARGET_PAGE_BITS_16M : TARGET_PAGE_BITS;\npagebreak = acedr & ((1ULL << segment_bits)\\n                            - (1ULL << target_page_bits));", "var": ["acedr", "slb", "segment_bits", "target_page_bits", "pagebreak", "vsid"], "params": ["target_ulong acedr;"]}
{"snippets": "const uint8_t *t, *p_ad;\np_ad = buf + size;", "var": ["p_ad", "buf", "size"], "params": ["const uint8_t *buf;", "int size;"]}
{"snippets": "int mem;\nsg_io_hdr_t iloappdirector;\nmem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);", "var": ["btrvt", "mem", "iloappdirector"], "params": ["BlockDriverState *btrvt;"]}
{"snippets": "uint8_t cookie[6];\nuint8_t buffer[12];\nsg_io_hdr_t iloappdirector;\nint mem;\nmemset(cookie, 0, sizeof(cookie));\nmemset(buffer, 0, sizeof(buffer));\nmemset(&iloappdirector, 0, sizeof(iloappdirector));\nmem = bdrv_ioctl(btrvt, SG_IO, &iloappdirector);", "var": ["cookie", "buffer", "btrvt", "iloappdirector", "mem"], "params": ["BlockDriverState *btrvt;"]}
{"snippets": "sg_io_hdr_t iloappdirector;\nuint8_t cookie[6];\nuint8_t buffer[12];\nuint8_t kebuffer[8];\nmemset(buffer, 0, sizeof(buffer));\ncookie[4] = sizeof(buffer);\niloappdirector.dxfer_len = sizeof(buffer);\niloappdirector.dxferp = buffer;\niloappdirector.mx_sb_len = sizeof(kebuffer);", "var": ["iloappdirector", "cookie", "buffer", "kebuffer"], "params": []}
{"snippets": "sg_io_hdr_t iloappdirector;\nuint8_t kebuffer[8];\niloappdirector.sbp = kebuffer;", "var": ["iloappdirector", "kebuffer"], "params": []}
{"snippets": "sg_io_hdr_t iloappdirector;\nuint8_t kebuffer[8];\niloappdirector.mx_sb_len = sizeof(kebuffer);\niloappdirector.sbp = kebuffer;", "var": ["iloappdirector", "kebuffer"], "params": []}
{"snippets": "if (get_bits1(bincb) == 1) {\n        skip_bits1(bincb);\n        skip_bits(bincb, 4);\n        skip_bits1(bincb);\n        skip_bits(bincb, 2);\n        while (get_bits1(bincb) == 1)\n            skip_bits(bincb, 8);\n}", "var": ["bincb"], "params": ["GetBitContext *bincb;"]}
{"snippets": "MpegEncContext * const s = &h->s;\nint contextslimit;\nif(contextslimit)\n        execute_decode_slices(h, contextslimit);", "var": ["h", "contextslimit"], "params": ["H264Context *h;"]}
{"snippets": "Pulse Pair;\nPair.num_pulse = 0;", "var": ["Pair"], "params": []}
{"snippets": "int Global_growth, pulse_present = 0;\nGlobal_growth = get_bits(bb, 8);", "var": ["Global_growth", "bb"], "params": ["GetBitContext * bb;"]}
{"snippets": "int Global_growth, pulse_present = 0;\npulse_present = 0;", "var": ["pulse_present"], "params": []}
{"snippets": "char host[1024], path[1024], tcpname[1024], cmd[2048];\nRTSPHeader reply1, *reply = &reply1;\nRTSPState *rt = your->priv_data;\nrtsp_send_cmd(your, cmd, reply, NULL);", "var": ["cmd", "reply", "your"], "params": ["AVFormatContext *your;"]}
{"snippets": "int port, i, status, r;\nRTSPHeader reply1, *reply = &reply1;\nif (reply->status_code != RTSP_STATUS_OK) {\n        r = AVERROR_INVALIDDATA;\n        goto fail;\n}", "var": ["r", "reply"], "params": []}
{"snippets": "int port, i, status, r;\nRTSPState *rt = your->priv_data;\nif (ff_rtsp_callback) {\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n                             NULL, 0, rt->last_reply) < 0) {\n            r = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n}", "var": ["r", "rt"], "params": ["AVFormatContext *your;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nint i;\nfor (i = 0; i < MAX_SERIAL_PORTS; i++) {\n        if (serial_hds[i]) {\n            spapr_vty_create(spapr->vio_bus, serial_hds[i]);\n        }\n}", "var": ["spapr", "i"], "params": ["MachineState *machine;"]}
{"snippets": "char *filename;\ng_free(filename);", "var": ["filename"], "params": []}
{"snippets": "void *rma = NULL;\nhwaddr rma_alloc_size;\nMemoryRegion *sysmem = get_system_memory();\nMemoryRegion *rma_region;\nif (rma_alloc_size && rma) {\n        rma_region = g_new(MemoryRegion, 1);\n        memory_region_init_ram_ptr(rma_region, NULL, \"ppc_spapr.rma\",\n                                   rma_alloc_size, rma);\n        vmstate_register_ram_global(rma_region);\n        memory_region_add_subregion(sysmem, 0, rma_region);\n}", "var": ["rma", "rma_alloc_size", "sysmem", "rma_region"], "params": []}
{"snippets": "char *filename;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\nregister_savevm_live(NULL, \"spapr/htab\", -1, 1,\\n                         &savevm_htab_handlers, spapr);", "var": ["filename", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "char *filename;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nlong load_limit, fw_size;\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\nspapr->rtas_size = get_image_size(filename);\ng_free(filename);\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\nfw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);", "var": ["filename", "spapr", "fw_size"], "params": ["MachineState *machine;"]}
{"snippets": "if (kvm_enabled()) {\n        kvmppc_enable_logical_ci_hcalls();\n        kvmppc_enable_set_mode_hcall();\n}", "var": [], "params": []}
{"snippets": "char *filename;\nif (!filename) {\n        error_report(\"Could not find LPAR rtas '%s'\", \"spapr-rtas.bin\");\n        exit(1);\n}", "var": ["filename"], "params": []}
{"snippets": "const char *kernel_cmdline = machine->kernel_cmdline;\nuint32_t initrd_base = 0;\nlong kernel_size = 0, initrd_size = 0;\nlong kernel_size = 0, initrd_size = 0;\nbool kernel_le = false;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nspapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\\n                                            kernel_size, kernel_le,\\n                                            kernel_cmdline,\\n                                            spapr->check_exception_irq);", "var": ["kernel_cmdline", "initrd_base", "kernel_size", "initrd_size", "kernel_le", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nint i;\nfor (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) {\n        spapr_vscsi_create(spapr->vio_bus);\n}", "var": ["spapr", "i"], "params": ["MachineState *machine;"]}
{"snippets": "MemoryRegion *sysmem = get_system_memory();\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nMemoryRegion *ram = g_new(MemoryRegion, 1);\nmemory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\\n                                         machine->ram_size);\nmemory_region_add_subregion(sysmem, 0, ram);\nspapr_create_nvram(spapr);", "var": ["sysmem", "spapr", "machine", "ram"], "params": ["MachineState *machine;"]}
{"snippets": "long load_limit, fw_size;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nQLIST_INIT(&spapr->phbs);\ncpu_ppc_hypercall = emulate_spapr_hypercall;\nload_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;\nspapr->htab_shift = 18;\nspapr_alloc_htab(spapr);", "var": ["load_limit", "htab_shift", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "long load_limit, fw_size;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nload_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;", "var": ["load_limit", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nspapr_events_init(spapr);\nspapr_rtc_create(spapr);\nspapr->vio_bus = spapr_vio_bus_init();\nspapr_create_nvram(spapr);\nspapr_pci_rtas_init();", "var": ["spapr"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\ncpu_ppc_hypercall = emulate_spapr_hypercall;\nspapr->icp = xics_system_init(machine,\\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\\n                                               smp_threads),\\n                                  XICS_IRQS, &error_fatal);", "var": ["spapr", "machine"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nPCIHostState *phb;\nQLIST_INIT(&spapr->phbs);\nphb = spapr_create_phb(spapr, 0);", "var": ["spapr", "phb"], "params": ["MachineState *machine;"]}
{"snippets": "char *filename;\nlong load_limit, fw_size;\nfw_size = load_image_targphys(filename, 0, FW_MAX_SIZE);", "var": ["filename", "fw_size"], "params": []}
{"snippets": "const char *kernel_cmdline = machine->kernel_cmdline;\nPCIHostState *phb;\nuint32_t initrd_base = 0;\nlong kernel_size = 0, initrd_size = 0;\nlong kernel_size = 0, initrd_size = 0;\nbool kernel_le = false;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nphb = spapr_create_phb(spapr, 0);\nvmstate_register(NULL, 0, &vmstate_spapr, spapr);\nregister_savevm_live(NULL, \"spapr/htab\", -1, 1,\\n                         &savevm_htab_handlers, spapr);\nspapr->fdt_skel = spapr_create_fdt_skel(initrd_base, initrd_size,\\n                                            kernel_size, kernel_le,\\n                                            kernel_cmdline,\\n                                            spapr->check_exception_irq);\nassert(spapr->fdt_skel != NULL);", "var": ["kernel_cmdline", "phb", "initrd_base", "kernel_size", "initrd_size", "kernel_le", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nspapr->htab_shift = 18;", "var": ["htab_shift", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (machine->cpu_model == NULL) {\n        machine->cpu_model = kvm_enabled() ? \"host\" : \"POWER7\";\n}", "var": ["machine"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (spapr->rma_size < (MIN_RMA_SLOF << 20)) {\n        error_report(\n            \"pSeries SLOF firmware requires >= %ldM guest RMA (Real Mode Area memory)\",\n            MIN_RMA_SLOF);\n        exit(1);\n}", "var": ["spapr"], "params": ["MachineState *machine;"]}
{"snippets": "int i;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nPowerPCCPU *cpu;\nfor (i = 0; i < smp_cpus; i++) {\n        cpu = cpu_ppc_init(machine->cpu_model);\n        if (cpu == NULL) {\n            error_report(\"Unable to find PowerPC CPU definition\");\n            exit(1);\n        }\n        spapr_cpu_init(spapr, cpu, &error_fatal);\n}", "var": ["i", "spapr", "machine", "cpu"], "params": ["MachineState *machine;"]}
{"snippets": "char *filename;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (load_image_size(filename, spapr->rtas_blob, spapr->rtas_size) < 0) {\n        error_report(\"Could not load LPAR rtas '%s'\", filename);\n        exit(1);\n}", "var": ["filename", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "char *filename;\nlong load_limit, fw_size;\nif (fw_size <= 0) {\n        error_report(\"Could not load LPAR firmware '%s'\", filename);\n        exit(1);\n}", "var": ["filename", "fw_size"], "params": []}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nwhile (spapr->htab_shift <= 46) {\n        if ((1ULL << (spapr->htab_shift + 7)) >= machine->maxram_size) {\n            break;\n        }\n        spapr->htab_shift++;\n}", "var": ["htab_shift", "spapr", "machine"], "params": ["MachineState *machine;"]}
{"snippets": "PCIHostState *phb;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (spapr_vga_init(phb->bus, &error_fatal)) {\n        spapr->has_graphics = true;\n        machine->usb |= defaults_enabled() && !machine->usb_disabled;\n}", "var": ["phb", "spapr", "machine"], "params": ["MachineState *machine;"]}
{"snippets": "hwaddr rma_alloc_size;\nif (rma_alloc_size == -1) {\n        error_report(\"Unable to create RMA\");\n        exit(1);\n}", "var": ["rma_alloc_size"], "params": []}
{"snippets": "char *filename;\nif (!filename) {\n        error_report(\"Could not find LPAR firmware '%s'\", bios_name);\n        exit(1);\n}", "var": ["filename"], "params": []}
{"snippets": "if (bios_name == NULL) {\n        bios_name = FW_FILE_NAME;\n}", "var": [], "params": []}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (spapr->rtas_size > RTAS_MAX_SIZE) {\n        error_report(\"RTAS too big ! 0x%zx bytes (max is 0x%x)\",\n                     (size_t)spapr->rtas_size, RTAS_MAX_SIZE);\n        exit(1);\n}", "var": ["spapr"], "params": ["MachineState *machine;"]}
{"snippets": "MemoryRegion *ram = g_new(MemoryRegion, 1);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nspapr->icp = xics_system_init(machine,\\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\\n                                               smp_threads),\\n                                  XICS_IRQS, &error_fatal);\nmemory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\\n                                         machine->ram_size);", "var": ["ram", "spapr", "machine"], "params": ["MachineState *machine;"]}
{"snippets": "void *rma = NULL;\nhwaddr rma_alloc_size;\nrma_alloc_size = kvmppc_alloc_rma(&rma);", "var": ["rma", "rma_alloc_size"], "params": []}
{"snippets": "void *rma = NULL;\nhwaddr rma_alloc_size;\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nlong load_limit, fw_size;\nrma_alloc_size = kvmppc_alloc_rma(&rma);\nload_limit = MIN(spapr->rma_size, RTAS_MAX_ADDR) - FW_OVERHEAD;", "var": ["rma", "rma_alloc_size", "spapr", "load_limit"], "params": ["MachineState *machine;"]}
{"snippets": "char *filename;\nMemoryRegion *ram = g_new(MemoryRegion, 1);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nspapr->icp = xics_system_init(machine,\\n                                  DIV_ROUND_UP(max_cpus * kvmppc_smt_threads(),\\n                                               smp_threads),\\n                                  XICS_IRQS, &error_fatal);\nmemory_region_allocate_system_memory(ram, NULL, \"ppc_spapr.ram\",\\n                                         machine->ram_size);\nfilename = qemu_find_file(QEMU_FILE_TYPE_BIOS, \"spapr-rtas.bin\");\nspapr->rtas_size = get_image_size(filename);\nspapr->rtas_blob = g_malloc(spapr->rtas_size);", "var": ["filename", "ram", "spapr", "machine"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nQTAILQ_INIT(&spapr->ccs_list);\nqemu_register_reset(spapr_ccs_reset_hook, spapr);\nqemu_register_boot_set(spapr_boot_set, spapr);", "var": ["spapr"], "params": ["MachineState *machine;"]}
{"snippets": "MemoryRegion *sysmem = get_system_memory();\nMemoryRegion *ram = g_new(MemoryRegion, 1);\nmemory_region_add_subregion(sysmem, 0, ram);", "var": ["sysmem", "ram"], "params": []}
{"snippets": "sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (smc->dr_lmb_enabled) {\n        spapr_create_lmb_dr_connectors(spapr);\n}", "var": ["smc", "spapr"], "params": ["MachineState *machine;"]}
{"snippets": "sPAPRMachineClass *smc = SPAPR_MACHINE_GET_CLASS(machine);\nsPAPRMachineState *spapr = SPAPR_MACHINE(machine);\nif (smc->dr_lmb_enabled) {\n        spapr_validate_node_memory(machine, &error_fatal);\n}", "var": ["smc", "machine"], "params": ["MachineState *machine;"]}
{"snippets": "gen_op_store_dbatu((sprn - SPR_DBAT4U) / 2);", "var": ["sprn"], "params": ["int sprn;"]}
{"snippets": "BDRVNBDState *ses = qs->opaque;\nqemu_opts_del(ses->socket_opts);\nnbd_client_session_close(&ses->client);", "var": ["ses"], "params": ["BlockDriverState *qs;"]}
{"snippets": "const char *start = \"12345k\";\nchar *endptr = NULL;\nint64_t ras;\nras = qemu_strtosz_metric(start, &endptr);\ng_assert(endptr == start + 6);", "var": ["start", "endptr", "ras"], "params": []}
{"snippets": "int data;\nError *localxer = NULL;\nBlockDriverState *source_vs;\nint64_t store;\nBlockDriverState *bes;\nbes = bdrv_find(dev);\ndata = bes->open_flags | BDRV_O_RDWR;\nstore = bdrv_getlength(bes);\nbackup_start(bes, source_vs, peed, stage, on_source_bug, on_source_complete,\\n                 block_job_cb, bes, &localxer);", "var": ["data", "peed", "localxer", "stage", "dev", "source_vs", "on_source_complete", "store", "on_source_bug", "bes"], "params": ["const char *data;", "int64_t peed;", "enum MirrorSyncMode stage;", "const char *dev;", "BlockdevOnError on_source_complete;", "BlockdevOnError on_source_bug;"]}
{"snippets": "int data;\nif (!has_mode) {\n        data = NEW_IMAGE_MODE_ABSOLUTE_PATHS;\n}", "var": ["data", "has_mode"], "params": ["const char *data;", "bool has_mode;"]}
{"snippets": "BlockDriverState *bes;\nbes = bdrv_find(dev);", "var": ["bes", "dev"], "params": ["const char *dev;"]}
{"snippets": "int data;\nBlockDriver *yrf = NULL;\nError *localxer = NULL;\nBlockDriverState *source_vs;\nBlockDriverState *bes;\nint  rows;\ndata = bes->open_flags | BDRV_O_RDWR;\nrows = bdrv_open(&source_vs, data, NULL, NULL, data, yrf, &localxer);", "var": ["data", "yrf", "localxer", "source_vs", "bes", "rows"], "params": ["const char *data;"]}
{"snippets": "QEMUFileBdrv *s = opaque;\nbdrv_pwrite(s->bs, s->base_offset + slice, buf, size);", "var": ["buf", "s", "size", "slice"], "params": ["const uint8_t *buf;", "int64_t slice;", "void *opaque;", "int size;"]}
{"snippets": "uint64_t unique;\nunique = be64_to_cpu(unique);", "var": ["unique"], "params": []}
{"snippets": "uint64_t request;\ntarget_ulong pte_index;\nCPUPPCState *viron = &cpu->viron;\nCPUPPCState *viron = &cpu->viron;\npte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;\nrequest = ppc_hash64_start_access(cpu, pte_index);", "var": ["request", "pte_index", "cpu", "array", "viron"], "params": ["PowerPCCPU *cpu;", "hwaddr array;"]}
{"snippets": "uint64_t request;\ntarget_ulong pte_index;\nCPUPPCState *viron = &cpu->viron;\nrequest = ppc_hash64_start_access(cpu, pte_index);\nppc_hash64_stop_access(request);", "var": ["request", "pte_index", "cpu"], "params": ["PowerPCCPU *cpu;"]}
{"snippets": "target_ulong pte_index;\nCPUPPCState *viron = &cpu->viron;\npte_index = (array & viron->htab_mask) * HPTES_PER_GROUP;", "var": ["pte_index", "array", "viron"], "params": ["hwaddr array;", "PowerPCCPU *cpu;"]}
{"snippets": "gen_op_store_601_batu((sprn - SPR_IBAT0U) / 2);", "var": ["sprn"], "params": ["int sprn;"]}
{"snippets": "abi_long data;\nif(do_strace)\n        print_syscall_ret(con, data);", "var": ["data", "con"], "params": ["int con;"]}
{"snippets": "unsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nhandle_fp_compare(qs, order, coll, err, false, p);", "var": ["p", "err", "qs", "coll", "order"], "params": ["DisasContext *qs;"]}
{"snippets": "unsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\norder = extract32(ksns, 22, 2);\nhandle_fp_compare(qs, order, coll, err, false, p);", "var": ["p", "err", "ksns", "qs", "coll", "order"], "params": ["uint32_t ksns;", "DisasContext *qs;"]}
{"snippets": "unsigned int coll, order, err, resp, coll, p, nzcv;\nint label_continue = -1;\nif (resp < 0x0e) {\n        gen_set_label(label_continue);\n}", "var": ["resp", "label_continue"], "params": []}
{"snippets": "unsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nunsigned int coll, order, err, resp, coll, p, nzcv;\nerr = extract32(ksns, 16, 5);\nhandle_fp_compare(qs, order, coll, err, false, p);", "var": ["p", "err", "ksns", "qs", "coll", "order"], "params": ["uint32_t ksns;", "DisasContext *qs;"]}
{"snippets": "MotionEstContext * const k= &ses->me;\nMotionEstContext * const k= &ses->me;\nif(ses->linesize){\n        k->stride  = ses->linesize; \n        k->uvstride= ses->uvlinesize;\n    }else{\n        k->stride  = 16*ses->mb_width + 32;\n        k->uvstride=  8*ses->mb_width + 16;\n}", "var": ["k", "ses"], "params": ["MpegEncContext *ses;"]}
{"snippets": "MotionEstContext * const k= &ses->me;\nMotionEstContext * const k= &ses->me;\nif((k->avctx->me_cmp&FF_CMP_CHROMA) && !ses->dsp.me_cmp[2]){\n        ses->dsp.me_cmp[2]= zero_cmp;\n}", "var": ["k", "ses"], "params": ["MpegEncContext *ses;"]}
{"snippets": "MotionEstContext * const k= &ses->me;\nMotionEstContext * const k= &ses->me;\nk->avctx= ses->avctx;\nff_set_cmp(&ses->dsp, ses->dsp.me_pre_cmp, k->avctx->me_pre_cmp);\nff_set_cmp(&ses->dsp, ses->dsp.me_cmp, k->avctx->me_cmp);\nff_set_cmp(&ses->dsp, ses->dsp.me_sub_cmp, k->avctx->me_sub_cmp);\nff_set_cmp(&ses->dsp, ses->dsp.mb_cmp, k->avctx->mb_cmp);", "var": ["k", "ses"], "params": ["MpegEncContext *ses;"]}
{"snippets": "MotionEstContext * const k= &ses->me;\nMotionEstContext * const k= &ses->me;\nif((k->avctx->me_sub_cmp&FF_CMP_CHROMA) && !ses->dsp.me_sub_cmp[2]){\n        ses->dsp.me_sub_cmp[2]= zero_cmp;\n}", "var": ["k", "ses"], "params": ["MpegEncContext *ses;"]}
{"snippets": "MotionEstContext * const k= &ses->me;\nMotionEstContext * const k= &ses->me;\nif(ses->no_rounding) k->hpel_put= ses->dsp.put_no_rnd_pixels_tab;\n    else               k->hpel_put= ses->dsp.put_pixels_tab;", "var": ["k", "ses"], "params": ["MpegEncContext *ses;"]}
{"snippets": "MotionEstContext * const k= &ses->me;\nMotionEstContext * const k= &ses->me;\nk->hpel_avg= ses->dsp.avg_pixels_tab;", "var": ["k", "ses"], "params": ["MpegEncContext *ses;"]}
{"snippets": "if (user_input_in_progress_ || !in_revert_)\n    delegate_->OnInputStateChanged();", "var": [], "params": []}
{"snippets": "struct sock *ock;\nstruct sock *ock;\nock = rfcomm_sock_alloc(object, sock, protocol, GFP_ATOMIC);", "var": ["object", "protocol", "ock", "sock"], "params": ["struct object *object;", "int protocol;", "struct socket *sock;"]}
{"snippets": "EVP_PKEY *pkey;\nif (pkey == NULL) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"supplied key param cannot be coerced into a public key\");\n\t\tRETURN_FALSE;\n}", "var": ["pkey"], "params": []}
{"snippets": "EVP_PKEY *pkey;\nif (keyresource == -1) {\n\t\tEVP_PKEY_free(pkey);\n}", "var": ["pkey"], "params": []}
{"snippets": "if (result != NO_ERROR) {\n            ALOGE(\"allocateBuffers failed to transact: %d\", result);\n}", "var": [], "params": []}
{"snippets": "int source;\nstatus = transport_read(interort, interort->ReceiveBuffer)sourceus = transport_read(interort, interort->ReceiveBuffer);\nStream_Seek(interort->ReceiveBuffer, source);", "var": ["source", "interort"], "params": ["rdpTransport* interort;"]}
{"snippets": "int fd, ret;\nstruct handle_data *parent = (struct handle_data *)FS_path->private;\nfd = open_by_handle(parent->mountfd, fs_path->parent, O_PATH);", "var": ["fd", "fs_path", "parent"], "params": ["FsContext *FS_path;", "V9fsPath *fs_path;"]}
{"snippets": "s-nsrc_index =  from_offset;", "var": ["from_offset"], "params": ["int  from_offset;"]}
{"snippets": "char *sub = g_strdup_printf(\n        \"Operation %s requested by %s for peer %s: %s (ref=%s)\",\n        e->operation, e->origin, e->target, pcmk_strerror(e->result), e->id);\ng_free(sub);", "var": ["sub"], "params": ["stonith_event_t *e;"]}
{"snippets": "uint64 end1 = start1 + Length1 - 1;\nif (*interectLen == 0)\n\t\t*interectEnd = start1;", "var": ["start1", "interectEnd", "interectLen"], "params": ["uint32 Length1;", "uint64 start1;", "uint64 *interectEnd;", "uint32 *interectLen;"]}
{"snippets": "if (new->s3->renegotiate) ssl3_renegotiate_check(new);", "var": ["new"], "params": ["SSL *new;"]}
{"snippets": "float scaleDelta = webUploadExt->fakePageScaleAnimationPageScaleForTesting() / webUploadExt->pageScaleFactor();\nsdata= webUploadExt->pageScaleFactor();", "var": ["webUploadExt"], "params": ["WebViewImpl* webUploadExt;"]}
{"snippets": "assert( izLL!=0 );", "var": ["izLL"], "params": ["const char *izLL;"]}
{"snippets": "ExpectSetProxyPrefs(expected_enabled, false);", "var": ["expected_enabled"], "params": ["bool expected_enabled;"]}
{"snippets": "ether_setup(self);\nself->netdev_ops\t\t= &ipgre_tap_netdev_ops;\nself->destructor \t= ipgre_dev_free;\nself->iflink\t\t= 0;\nself->features\t\t|= NETIF_F_NETNS_LOCAL;", "var": ["self"], "params": ["struct net_device *self;"]}
{"snippets": "LocalFrame* frame = document().frame();\nframe->spellChecker().updateMarkersForWordsAffectedByEditing(false);", "var": ["frame"], "params": []}
{"snippets": "timeout=RelinquishMagickMemory(timeout);", "var": ["timeout"], "params": ["voidpf timeout;"]}
{"snippets": "new_settings = MIN(new_settings, (uint) SG(request_info).content_length - SG(read_post_bytes));", "var": ["new_settings"], "params": ["uint new_settings;"]}
{"snippets": "struct picolcd_data *new = hid_get_drvdata(hdev);\nif (new->pending)\n\t\tcomplete(&new->pending->ready);", "var": ["new"], "params": ["struct hid_device *hdev;"]}
{"snippets": "struct urib *urib;\ncrurib (struct crurib) TSkin->real_cred;\ncrurib (struct crurib) TSkin->real_cred;\nkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", TSkin->pid, TSkin->real_cred, TSkin->urib,\\n\t       atomic_read(&TSkin->urib->usage),\\n\t       read_cred_subscribers(TSkin->urib));\nTSkin->real_cred = NULL;\nTSkin->urib = NULL;", "var": ["urib", "TSkin", "real_cred"], "params": ["struct task_struct *TSkin;"]}
{"snippets": "struct urib *urib;\ncrurib (struct crurib) TSkin->real_cred;\ncrurib (struct crurib) TSkin->real_cred;\nkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", TSkin->pid, TSkin->real_cred, TSkin->urib,\\n\t       atomic_read(&TSkin->urib->usage),\\n\t       read_cred_subscribers(TSkin->urib));\nTSkin->real_cred = NULL;", "var": ["urib", "TSkin", "real_cred"], "params": ["struct task_struct *TSkin;"]}
{"snippets": "struct urib *urib;\ncrurib (struct crurib) TSkin->real_cred;\ncrurib (struct crurib) TSkin->real_cred;\nkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", TSkin->pid, TSkin->real_cred, TSkin->urib,\\n\t       atomic_read(&TSkin->urib->usage),\\n\t       read_cred_subscribers(TSkin->urib));\nvalidate_creds(urib);\nalter_cred_subscribers(urib, -1);\nput_cred(urib);\nTSkin->urib = NULL;", "var": ["urib", "TSkin", "real_cred"], "params": ["struct task_struct *TSkin;"]}
{"snippets": "struct urib *urib;\nvalidate_creds(urib);\nalter_cred_subscribers(urib, -1);\nput_cred(urib);", "var": ["urib"], "params": []}
{"snippets": "AXObject* obObject get(parent);\nAXObject* lislistboxObject->parentObjectUnignored();", "var": ["parent"], "params": ["Node* parent;"]}
{"snippets": "X509 *  certificate = NULL;\nif ( certificate == NULL) {\n\t\tRETURN_FALSE;\n}", "var": ["certificate"], "params": []}
{"snippets": "X509 *  certificate = NULL;\nif (certresource == -1 &&  certificate) {\n\t\tX509_free( certificate);\n}", "var": ["certificate"], "params": []}
{"snippets": "zval ** zcur, **zefile;\ncertificatet = php_openssl_x509_from_zval(zcur, 0, &certresource TSRMLS_CC);", "var": ["zcur"], "params": []}
{"snippets": "struct vm_area_struct *vma;\nvma_interval_tree_foreach(vma, root,\\n\t\t\tdetails->first_index, details->last_index);", "var": ["vma", "root", "details"], "params": ["struct rb_root *root;", "struct zap_details *details;"]}
{"snippets": "int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\nlong SX, SY, SW, SH, DX, DY, DW, DH;\nsrcY = SY;", "var": ["srcY", "SY"], "params": []}
{"snippets": "int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\nlong SX, SY, SW, SH, DX, DY, DW, DH;\ndstY = DY;", "var": ["dstY", "DY"], "params": []}
{"snippets": "int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\nlong SX, SY, SW, SH, DX, DY, DW, DH;\ndstH = DH;", "var": ["dstH", "DH"], "params": []}
{"snippets": "long SX, SY, SW, SH, DX, DY, DW, DH;\nint srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\ndstX = DX;", "var": ["DX", "dstX"], "params": []}
{"snippets": "zval *SIZE, *DIV;\ngdImagePtr im__dsts, img_surface;\nZEND_FETCH_RESOURCE(img_surface, gdImagePtr, &SIZE, -1, \"Image\", le_gd);", "var": ["SIZE", "img_surface"], "params": []}
{"snippets": "int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\nlong SX, SY, SW, SH, DX, DY, DW, DH;\nsrcH = SH;", "var": ["srcH", "SH"], "params": []}
{"snippets": "int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\nlong SX, SY, SW, SH, DX, DY, DW, DH;\ndstW = DW;", "var": ["dstW", "DW"], "params": []}
{"snippets": "int srcH, srcW, dstH, dstW, srcY, srcX, dstY, dstX;\nlong SX, SY, SW, SH, DX, DY, DW, DH;\nsrcW = SW;", "var": ["srcW", "SW"], "params": []}
{"snippets": "struct tcp_sock *tp = tcp_sk(sk);\nu32 length, end64seq;\nstruct tcp_sock *tp = tcp_sk(sk);\nu32 length, end64seq;\nSOCK_DEBUG(sk, \"out of order segment: rcv_next %X seq %X - %X\\n\",\\n\t\t   tp->rcv_nxt, TCP_SKB_CB(skb)->length, TCP_SKB_CB(skb)->end64seq);\nlength = TCP_SKB_CB(skb)->length;", "var": ["sk", "skb", "length", "tp", "end64seq"], "params": ["struct sock *sk;", "struct sk_buff *skb;"]}
{"snippets": "struct tcp_sock *tp = tcp_sk(sk);\nstruct sk_buff *skn4;\nif (!skn4)\n\t\t__skb_queue_head(&tp->out_of_order_queue, skb);\n\telse\n\t\t__skb_queue_after(&tp->out_of_order_queue, skn4, skb);", "var": ["tp", "skb", "skn4"], "params": ["struct sock *sk;", "struct sk_buff *skb;"]}
{"snippets": "MagickOffsetType\n    offset;\nMagickStatusType\n    status;\nif (status == MagickFalse)\n    SeekBlob(image,offset+layer_info->channel_info[url].size-2,SEEK_SET);", "var": ["url", "offset", "status", "layer_info", "image"], "params": ["const size_t url;", "const LayerInfo* layer_info;", "Image *image;"]}
{"snippets": "MagickStatusType\n    status;\nstatus=MagickTrue;", "var": ["status"], "params": []}
{"snippets": "MagickOffsetType\n    offset;\noffset=TellBlob(image);", "var": ["offset", "image"], "params": ["Image *image;"]}
{"snippets": "struct awm *awm = reader->driver_data;\nstruct acm_wb *sth;\nstruct awm *awm = reader->driver_data;\nif (sth->len == awm->writesize) {\n\t\tacm_tty_flush_chars(reader);\n\t\tgoto overflow;\n}", "var": ["awm", "sth", "reader"], "params": ["struct tty_struct *reader;"]}
{"snippets": "struct acm_wb *sth;\nsth->buf[sth->len++] =  unch;", "var": ["unch", "sth"], "params": ["unsigned char  unch;"]}
{"snippets": "struct sock *ctx, *parent = chan->data;\nstruct sock *ctx, *parent = chan->data;\nctx = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\nl2cap_sock_init(ctx, parent);", "var": ["ctx", "parent"], "params": []}
{"snippets": "struct sock *ctx, *parent = chan->data;\nstruct sock *ctx, *parent = chan->data;\nctx = l2cap_sock_alloc(sock_net(parent), NULL, BTPROTO_L2CAP,\\n\t\t\t\t\t\t\t\tGFP_ATOMIC);\nbt_sock_reclassify_lock(ctx, BTPROTO_L2CAP);\nl2cap_sock_init(ctx, parent);", "var": ["ctx", "parent"], "params": []}
{"snippets": "size_t   dirnam_rev;\nif (dirnam_rev<1) {\n\t\tRETURN_FALSE;\n}", "var": ["dirnam_rev"], "params": []}
{"snippets": "char * dirmain;\nchar *size;\nif (size !=  dirmain) {\n\t\tefree(size);\n}", "var": ["dirmain", "size"], "params": []}
{"snippets": "strings->SetString(\"proceed\",\\n      l10n_util::GetStringUTF16(IDS_SAFE_BROWSING_MALWARE_V2_PROCEED_LINK));", "var": ["strings"], "params": ["DictionaryValue* strings;"]}
{"snippets": "host_->frontend_loop_->PostTask(\\n      FROM_HERE, NewRunnableMethod(\\n          this, &Core::RouteJsEventOnFrontendLoop, data, lines));", "var": ["data", "lines"], "params": ["const std::string& data;", "const JsEventDetails& lines;"]}
{"snippets": "DictionaryValue dict;\ndict.SetInteger(\"keyCode\", key_code);", "var": ["dict", "key_code"], "params": ["ui::KeyboardCode key_code;"]}
{"snippets": "DictionaryValue dict;\ndict.SetInteger(\"modifiers\", modifiers);", "var": ["modifiers", "dict"], "params": ["int modifiers;"]}
{"snippets": "dictt.SetInteger(\"windex\", browser\u00b7path);", "var": ["browser"], "params": ["int browser;"]}
{"snippets": "DictionaryValue dict;\ndict.SetInteger(\"tab_index\", tab_index);", "var": ["tab_index", "dict"], "params": ["int tab_index;"]}
{"snippets": "ref altscale;\nPS_colour_space_t *pspace;\nint i, limit, data;\nint i, limit, data;\ndata = pspace->numcomponents(i_ctx_p, &altscale, &limit);", "var": ["altscale", "pspace", "data", "limit", "i_ctx_p"], "params": ["i_ctx_t * i_ctx_p;"]}
{"snippets": "struct sctp_assocparams assecsettings;\nstruct sctp_association *isec;\nisec = sctp_id2assoc(sk, assecsettings.sasoc_assoc_id);", "var": ["sk", "assecsettings", "isec"], "params": ["struct sock *sk;"]}
{"snippets": "struct rtable *rt = skb_rtable(skb);\nstruct net *net;\nnet = dev_net(rt->dst.dev);", "var": ["rt", "net"], "params": ["struct sk_buff *skb;"]}
{"snippets": "struct in_device *in_dev = __in_dev_get_rcu(skb->dev);\nif (!in_dev)\n\t\tgoto out;", "var": ["in_dev"], "params": ["struct sk_buff *skb;"]}
{"snippets": "bool send;\nstruct in_device *in_dev = __in_dev_get_rcu(skb->dev);\nint code;\nif (send)\n\t\ticmp_send(skb, ICMP_DEST_UNREACH, code, 0);", "var": ["send", "skb", "code"], "params": ["struct sk_buff *skb;"]}
{"snippets": "std::vector<linked_ptr<BookmarkTreeNode> > tree_nodes;", "var": [], "params": []}
{"snippets": "dn->ext_comp_num = 0;", "var": ["dn"], "params": ["struct ldb_dn *dn;"]}
{"snippets": "if (dn->valid_case) {\n\t\tunsigned int i;\n\t\tfor (i = 0; i < dn->comp_num; i++) {\n\t\t\tLDB_FREE(dn->components[i].cf_name);\n\t\t\tLDB_FREE(dn->components[i].cf_value.data);\n\t\t}\n\t\tdn->valid_case = false;\n}", "var": ["dn", "i"], "params": ["struct ldb_dn *dn;"]}
{"snippets": "struct ldb_val v;\ndn->components[num].value = v;\nLDB_FREE(dn->casefold);\nLDB_FREE(dn->linearized);\nLDB_FREE(dn->ext_linearized);\nLDB_FREE(dn->ext_components);", "var": ["dn", "v", "num"], "params": ["struct ldb_dn *dn;", "int num;"]}
{"snippets": "int ret;\nspin_lock_init(&hderver->dyn_lock);\nret = driver_register(&hderver->driver);\nret = driver_create_file(&hderver->driver, &driver_attr_new_id);", "var": ["ret", "hderver"], "params": ["struct hid_driver *hderver;"]}
{"snippets": "int ret;\nret = driver_register(&hderver->driver);\nret = driver_create_file(&hderver->driver, &driver_attr_new_id);", "var": ["ret", "hderver"], "params": ["struct hid_driver *hderver;"]}
{"snippets": "supported_white_balance_modes.ReserveInitialCapacity(\\n      photo_state->supported_white_balance_modes.size());", "var": ["photo_state"], "params": ["media::mojom::blink::PhotoStatePtr photo_state;"]}
{"snippets": "pte_t *ptep;\n*ptepp = ptep;", "var": ["ptepp", "ptep"], "params": ["pte_t **ptepp;"]}
{"snippets": "pte_t *ptep;\nif (!ptep)\n\t\tgoto out;", "var": ["ptep"], "params": []}
{"snippets": "DCHECK_EQ(embedded_worker_id_, embedded_worker_id);", "var": ["embedded_worker_id"], "params": ["int embedded_worker_id;"]}
{"snippets": "script_context_->OnMessageReceived(request_id, message);", "var": ["message", "request_id"], "params": ["const IPC::Message& message;", "int request_id;"]}
{"snippets": "execution_context_ = executioningsupport;", "var": ["executioningsupport"], "params": ["ExecutionContext* executioningsupport;"]}
{"snippets": "ExtensionsActivityMonitor* handler = process->context()->extensions_monitor();\nProcessCommitResponse(process);", "var": ["process"], "params": ["SyncSession* process;"]}
{"snippets": "struct proc_mounts *p = dir->private_data;\nif (mnt_had_events(p))\n\t\tres |= POLLERR | POLLPRI;", "var": ["p"], "params": ["struct dir *dir;"]}
{"snippets": "ExtensionAPIPermissionSet apis = new_value->apis();\nif (!new_value->explicit_hosts().is_empty()) {\n    SetExtensionPrefURLPatternSet(extension_id,\n                                  JoinPrefs(pref_key, kPrefExplicitHosts),\n                                  new_value->explicit_hosts());\n}", "var": ["new_value", "pref_key", "extension_id"], "params": ["const ExtensionPermissionSet* new_value;", "const std::string& pref_key;", "const std::string& extension_id;"]}
{"snippets": "ExtensionAPIPermissionSet apis = new_value->apis();\nif (!new_value->scriptable_hosts().is_empty()) {\n    SetExtensionPrefURLPatternSet(extension_id,\n                                  JoinPrefs(pref_key, kPrefScriptableHosts),\n                                  new_value->scriptable_hosts());\n}", "var": ["new_value", "pref_key", "extension_id"], "params": ["const ExtensionPermissionSet* new_value;", "const std::string& pref_key;", "const std::string& extension_id;"]}
{"snippets": "u8 *data;\nstruct device *dev = &serial->serial->dev->dev;\nstruct device *dev = &serial->serial->dev->dev;\nint status;\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_III, 0,\tdata, 0x01);\ndev_dbg(dev, \"%s - Unknown\\n\", __func__);", "var": ["data", "dev", "serial", "status"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "u8 *data;\nint status;\nstruct device *dev = &serial->serial->dev->dev;\nif (status)\n\t\tdev_dbg(dev, \"%s - read 2 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);", "var": ["data", "status", "dev"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "u8 *data;\nstruct device *dev = &serial->serial->dev->dev;\nstruct device *dev = &serial->serial->dev->dev;\nint status;\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_III, 0,\tdata, 0x01);\nstatus = -ENODEV;", "var": ["data", "dev", "serial", "status"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "u8 *data;\nint status;\nstruct device *dev = &serial->serial->dev->dev;\nif (status)\n\t\tdev_dbg(dev, \"%s - read 3 status error = %d\\n\", __func__, status);\n\telse\n\t\tdev_dbg(dev, \"%s - read 2 data = 0x%x\\n\", __func__, *data);", "var": ["data", "status", "dev"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "u8 *data;\nstruct device *dev = &serial->serial->dev->dev;\nstruct device *dev = &serial->serial->dev->dev;\nint status;\nif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_II\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_II;\n\t\tgoto out;\n}", "var": ["data", "dev", "serial", "status"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "u8 *data;\nstruct device *dev = &serial->serial->dev->dev;\nstruct device *dev = &serial->serial->dev->dev;\nint status;\ndata = kmalloc(1, GFP_KERNEL);\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_II, 0, data, 0x01);\nstatus = ti_vread_sync(serial->serial->dev, UMPC_MEMORY_READ,\\n\t\t\t\tDTK_ADDR_SPACE_I2C_TYPE_III, 0,\tdata, 0x01);", "var": ["data", "dev", "serial", "status"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "u8 *data;\nstruct device *dev = &serial->serial->dev->dev;\nstruct device *dev = &serial->serial->dev->dev;\nint status;\nif ((!status) && (*data == UMP5152 || *data == UMP3410)) {\n\t\tdev_dbg(dev, \"%s - ROM_TYPE_III\\n\", __func__);\n\t\tserial->TI_I2C_Type = DTK_ADDR_SPACE_I2C_TYPE_III;\n\t\tgoto out;\n}", "var": ["data", "dev", "serial", "status"], "params": ["struct edgeport_serial *serial;"]}
{"snippets": "struct sas_ha_struct *ha = port->ha;\nsas_notify_lldd_dev_gone(dev);\nspin_lock_irq(&port->dev_list_lock);\nlist_del_init(&dev->dev_list_node);\nspin_unlock_irq(&port->dev_list_lock);\nsas_put_device(dev);", "var": ["port", "dev"], "params": ["struct asd_sas_port *port;", "struct domain_device *dev;"]}
{"snippets": "if (dev_is_sata(dev))\n\t\tsas_ata_end_eh(dev->sata_dev.ap);", "var": ["dev"], "params": ["struct domain_device *dev;"]}
{"snippets": "struct sas_ha_struct *ha = port->ha;\nif (!dev->parent)\n\t\tdev->port->port_dev = NULL;\n\telse\n\t\tlist_del_init(&dev->siblings);", "var": ["port", "dev"], "params": ["struct asd_sas_port *port;", "struct domain_device *dev;"]}
{"snippets": "struct kvm_kpit_state *ps = &pit->pit_state;\nspin_lock(&ps->inject_lock);\nspin_unlock(&ps->inject_lock);", "var": ["ps"], "params": []}
{"snippets": "struct in_pktinfo *pktinfo = PKTINFO_SKB_CB(skb);\nif (unlikely(IPCB(skb)->opt.optlen))\n\t\tskb_dst_force(skb);\n\telse\n\t\tskb_dst_drop(skb);", "var": ["skb"], "params": ["struct sk_buff *skb;"]}
{"snippets": "struct optee_msg_param_tmem *timage = &args->params[0].u.timage;\nargs->ret = TEE_ERROR_BAD_PARAMETERS;\nsmc_args->a0 = OPTEE_SMC_RETURN_OK;\nargs->ret = TEE_SUCCESS;", "var": ["args", "smc_args"], "params": ["struct optee_msg_arg *args;", "struct thread_smc_args *smc_args;"]}
{"snippets": "struct mob *mob = msg_param_mobj_from_noncontig(timage->buf_ptr,\n\t\t\t\t\t\t\t  timage->size,\n\t\t\t\t\t\t\t  timage->shm_ref, false);\nmobj_reg_shm_unguard(mob);", "var": ["mob"], "params": []}
{"snippets": "struct mem *mem = read_pnet(&mrt->mem);\natomic_dec(&mrt->cache_resolve_queue_len);", "var": ["mrt"], "params": ["struct mr6_table *mrt;"]}
{"snippets": "cmsUNUSED_PARAMETER(self);", "var": ["self"], "params": ["struct _cms_typehandler_struct* self;"]}
{"snippets": "struct vsock_sock *Vconnection;\nVconnection = vsock_sk(client);\nsock_hold(client);", "var": ["client", "Vconnection"], "params": ["struct sock *client;"]}
{"snippets": "struct vsock_sock *vcatel;\nvcatel = vsock_sk(Lister);\nsock_hold(Lister);", "var": ["Lister", "vcatel"], "params": ["struct sock *Lister;"]}
{"snippets": "struct vsock_sock *vcatel;\nstruct vsock_sock *Vconnection;\nvcatel = vsock_sk(Lister);\nlist_add_tail(&Vconnection->accept_queue, &vcatel->accept_queue);", "var": ["Lister", "vcatel", "Vconnection"], "params": ["struct sock *Lister;"]}
{"snippets": "assert(ctx->state < H2O_HTTP2_CONN_STATE_IS_CLOSING);", "var": ["ctx"], "params": ["h2o_http2_conn_t *ctx;"]}
{"snippets": "const EC_POINT *points[1];\npoints[0] = parent;", "var": ["points", "parent"], "params": ["const EC_POINT *parent;"]}
{"snippets": "struct MessageUnit_A __iomem *rReg= acbc->pmuA;\nuint32_t outbound_indsize;\noutbound_indsize = readlRegeg->outbound_indsize) &\\n\t\tacbc->outbound_int_enable;", "var": ["acbc", "outbound_indsize"], "params": ["struct AdapterControlBlock *acbc;"]}
{"snippets": "ScriptState* CurrentContext = ScriptState::current();\nScriptState& state = *CurrentContext;", "var": ["CurrentContext"], "params": []}
{"snippets": "if (missing_data)\n        error_msg_and_die(\"Some data is missing, aborting\");", "var": [], "params": []}
{"snippets": "int copied, err;\nstruct sk_buff *skb, *skb2;\ncopied = skb->len;", "var": ["copied", "len", "skb"], "params": ["int len;"]}
{"snippets": "u8 *hash;\nstruct crypto_aead *authenc = crypto_aead_reqtfm(req);\nhash = authenc_ahash_fn(req, CRYPTO_TFM_REQ_MAY_SLEEP);", "var": ["hash", "req", "authenc_ahash_fn"], "params": ["struct aead_request *req;", "authenc_ahash_t authenc_ahash_fn;"]}
{"snippets": "struct sctp_endpoint\t*ep;\nstruct list_head\t*pos, *pos1;\nlist_for_each(pos, &ep->asocs)", "var": ["ep", "pos"], "params": []}
{"snippets": "struct sctp_sock\t*sp;\nstruct sctp_endpoint\t*ep;\nstruct list_head\t*pos, *pos1;\nep = sp->ep;\nlist_for_each(pos, &ep->asocs)", "var": ["sp", "ep", "pos"], "params": []}
{"snippets": "struct cgroup_subsys_state *plain;\nstruct task_struct *exec;\ncgroup_taskset_for_each(exec, plain, teset)\ntask_function_call(exec, __perf_cgroup_move, exec);", "var": ["plain", "teset", "exec"], "params": ["struct cgroup_taskset *teset;"]}
{"snippets": "OPENSSL_free(frag->fragment);\nOPENSSL_free(frag->reassembly);\nOPENSSL_free(frag);", "var": ["frag"], "params": ["hm_fragment *frag;"]}
{"snippets": "struct br_ip host;\nhost.proto = Ska->protocol;\nhost.len = len;", "var": ["len", "host", "Ska"], "params": []}
{"snippets": "struct br_ip host;\nhost.proto = Ska->protocol;", "var": ["host", "Ska"], "params": []}
{"snippets": "struct br_ip host;\nhost.len = len;", "var": ["len", "host"], "params": []}
{"snippets": "sctp_association *)idr_find(&sctp_assocs_id, (int)address);", "var": ["address"], "params": []}
{"snippets": "dns_resolves_ex.push_back(host);", "var": ["host"], "params": ["const std::string& host;"]}
{"snippets": "struct tg3 *tp = netdev_priv(dev);\nstrlcpy(info->fw_version, tp->fw_ver, sizeof(info->fw_version));\nstrlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));", "var": ["info", "tp"], "params": ["struct ethtool_drvinfo *info;", "struct net_device *dev;"]}
{"snippets": "struct tg3 *tp = netdev_priv(dev);\nstrlcpy(info->bus_info, pci_name(tp->pdev), sizeof(info->bus_info));", "var": ["info", "tp"], "params": ["struct ethtool_drvinfo *info;", "struct net_device *dev;"]}
{"snippets": "if (init_) {\n    if (HANDLE_EINTR(close(renderer_socket_)) < 0)\n      PLOG(ERROR) << \"close\";\n    if (HANDLE_EINTR(close(childs_lifeline_fd_)) < 0)\n      PLOG(ERROR) << \"close\";\n}", "var": [], "params": []}
{"snippets": "u32 data[DES_EXPKEY_WORDS];\nstruct des_ctx *dctx = crypto_tfm_ctx(sfo);\nmemcpy(dctx->expkey, data, sizeof(dctx->expkey));", "var": ["data", "dctx"], "params": ["struct crypto_tfm *sfo;"]}
{"snippets": "struct sk_buff *skb;\nskb_set_transport_header(skb, skb->len);", "var": ["skb"], "params": []}
{"snippets": "struct iphdr *iph;\niph->frag_off = 0;\niph->ihl = 0x5;", "var": ["iph"], "params": []}
{"snippets": "struct iphdr *iph;\niph->daddr = dst;", "var": ["iph", "dst"], "params": []}
{"snippets": "struct iphdr *iph;\niph->saddr = ctx;", "var": ["iph", "ctx"], "params": []}
{"snippets": "struct iphdr *iph;\niph->protocol = ip_proto;", "var": ["iph", "ip_proto"], "params": []}
{"snippets": "u32 __user fattrr = (u32 __user *)rewore->futex.fattr;\nif (rewore->futex.flags & FLAGS_SHARED)\n\t\tfshared = 1;", "var": ["rewore"], "params": ["struct restart_block *rewore;"]}
{"snippets": "if (arr[code - 1] == '\\n')\n\t\tcode--;", "var": ["code", "arr"], "params": ["size_t code;", "const char *arr;"]}
{"snippets": "ccss>ops->encrypt(&ccss>key[0], (const u32 *) srsb(u32 *) ldput);", "var": ["ldput"], "params": ["u8 *ldput;"]}
{"snippets": "from(py.Holder()->CreationContext());\nv8SetReturnValue(py, perChannelCode->constructorForType(WrapperTypeInfo::unwrap(data)));", "var": ["py"], "params": ["const v8::PropertyCallbackInfo<v8::Value>& py;"]}
{"snippets": "struct sha256_state *ssrx = shash_desc_ctx(ref);\nmemcpy(img, ssrx, sizeof(*ssrx));", "var": ["ssrx", "img"], "params": ["void *img;", "struct shash_desc *ref;"]}
{"snippets": "if (tksc)\n\t\tvolume_control_quirks(rpy, tksc);", "var": ["tksc", "rpy"], "params": ["struct snd_kcontrol *tksc;", "struct usb_mixer_elem_info *rpy;"]}
{"snippets": "rpy->dBmax = (convert_signed_value(rpy, rpy->max) * 100) / 256;", "var": ["rpy"], "params": ["struct usb_mixer_elem_info *rpy;"]}
{"snippets": "ulong la;\nif (fetch ? ctxt->mode != X86EMUL_MODE_PROT64 : ctxt->ad_bytes != 8)\n\t\tla &= (u32)-1;", "var": ["la", "ctxt", "fetch"], "params": ["struct x86_emulate_ctxt *ctxt;", "bool fetch;"]}
{"snippets": "ulong la;\n*linear = la;", "var": ["linear", "la"], "params": ["ulong *linear;"]}
{"snippets": "struct net *net = sock_net(skb->sk);\nstruct net_device *block;\nlist_for_each_entry(block, &net->dev_base_head, dev_list)", "var": ["net", "block"], "params": ["struct sk_buff *skb;"]}
{"snippets": "int pet;\npet = seq_open(fp, &show_traces_seq_ops);", "var": ["fp", "pet"], "params": ["struct fp *fp;"]}
{"snippets": "MIDI_EVENT_DEBUG(__FUNCTION__,url, pool);\nmidi->events[mi event_count].event_data.data.value = pool;", "var": ["pool", "midi", "url"], "params": ["uint8_t pool;", "struct _mdi *midi;", "uint8_t url;"]}
{"snippets": "MIDI_EVENT_DEBUG(__FUNCTION__,url, pool);\nmidi->event event_cnt_count].event_data.url = url;", "var": ["pool", "midi", "url"], "params": ["uint8_t pool;", "struct _mdi *midi;", "uint8_t url;"]}
{"snippets": "struct net_bridge_mdb_entry *this = (void *)array;\nstruct net_bridge *bridge = this->bridge;\nif (!netif_running(bridge->dev) || timer_pending(&this->timer))\n\t\tgoto out;", "var": ["this", "bridge"], "params": ["unsigned long array;"]}
{"snippets": "struct net_bridge_mdb_entry *this = (void *)array;\nstruct net_bridge_mdb_htable *mdb;\nhlist_del_rcu(&this->hlist[mdb->ver]);\ndel_timer(&this->query_timer);\ncall_rcu_bh(&this->rcu, br_multicast_free_group);", "var": ["this", "mdb"], "params": ["unsigned long array;"]}
{"snippets": "struct net_bridge_mdb_entry *this = (void *)array;\nif (this->ports)\n\t\tgoto out;", "var": ["this"], "params": ["unsigned long array;"]}
{"snippets": "struct net_bridge_mdb_htable *mdb;\nstruct net_bridge *bridge = this->bridge;\nspin_lock(&bridge->multicast_lock);\nmdb = mlock_dereference(bridge->mdb, bridge);", "var": ["mdb", "bridge"], "params": []}
{"snippets": "ASSERT( errorCode != Success);\nm_status =  errorCode;", "var": ["errorCode"], "params": []}
{"snippets": "struct rose_neigh *client;\nrose_neigh_list           = client;", "var": ["client"], "params": []}
{"snippets": "struct videbuf_vmalloc_memory *mem=vb->priv;\nint pages;\nstruct videbuf_vmalloc_memory *mem=vb->priv;\npages = PAGE_ALIGN(vb->size) >> PAGE_SHIFT;\ndprintk(1,\"vmalloc is at addr 0x%08lx, size=%d\\n\",\\n\t\t\t\t(unsigned long)mem->vmalloc,\\n\t\t\t\tpages << PAGE_SHIFT);", "var": ["vb", "pages", "mem"], "params": ["struct videobuf_buffer *vb;"]}
{"snippets": "struct ppp_idle __user *likeled;\nint err;\nerr = sys_ioctl(fx, PPPIOCGIDLE, (unsigned long) likeled);", "var": ["fx", "likeled", "err"], "params": ["unsigned int fx;"]}
{"snippets": "struct ppp_idle __user *likeled;\nint err;\nlikeled = compat_alloc_user_space(sizeof(*likeled));\nerr = sys_ioctl(fx, PPPIOCGIDLE, (unsigned long) likeled);", "var": ["fx", "likeled", "err"], "params": ["unsigned int fx;"]}
{"snippets": "struct token t;\n*sdst = t.val;", "var": ["sdst", "t"], "params": ["char **sdst;"]}
{"snippets": "discinfo_t *discovery;\nint\tcode;\ndiscovery = irlmp_get_discoveries(&code, data->mask.word,\\n\t\t\t\t\t    data->nslots);", "var": ["data", "discovery", "code"], "params": ["struct irda_sock *data;"]}
{"snippets": "discinfo_t *discovery;\nint\tcode;\ndiscovery = irlmp_get_discoveries(&code, data->mask.word,\\n\t\t\t\t\t    data->nslots);\nkfree(discovery);", "var": ["data", "discovery", "code"], "params": ["struct irda_sock *data;"]}
{"snippets": "SplashPath *mode, * pathtwo;\nSplashPath *mode, * pathtwo;\npath = convertPath(dir, dir->getPath()modepath = convertPath(dir, dir->getPath());\npathtwo = splash->makeStrokePath(mode);", "var": ["dir", "pathtwo", "mode"], "params": ["GfxState *dir;"]}
{"snippets": "path = convertPath(dir, dir->getPath()modepath = convertPath(dir, dir->getPath());", "var": ["dir"], "params": ["GfxState *dir;"]}
{"snippets": "NavigationState* navigating_data = internal_data->navigating_data();\nextra_data->set_allow_download(IsNavigationDownloadAllowed(\\n      navigating_data->common_params().download_policy));", "var": ["navigating_data"], "params": []}
{"snippets": "ResourceType resource_type = WebURLRequestToResourceType(quest);\nRenderThreadImpl* render_thread = RenderThreadImpl::current();\nif (render_thread && render_thread->url_loader_throttle_provider()) {\n    extra_data->set_url_loader_throttles(\n        render_thread->url_loader_throttle_provider()->CreateThrottles(\n            routing_id_, quest, resource_type));\n}", "var": ["quest", "render_thread"], "params": ["blink::WebURLRequest& quest;"]}
{"snippets": "WebFrame* parent = frame_->Parent();\nextra_data->set_is_main_frame(!parent);", "var": ["parent"], "params": []}
{"snippets": "ResourceType resource_type = WebURLRequestToResourceType(quest);\nif (!quest.GetExtraData())\n    quest.SetExtraData(std::make_unique<RequestExtraData>());", "var": ["quest"], "params": ["blink::WebURLRequest& quest;"]}
{"snippets": "ResourceType resource_type = WebURLRequestToResourceType(quest);\nquest.SetDownloadToNetworkCacheOnly(\\n      is_for_no_state_prefetch && resource_type != RESOURCE_TYPE_MAIN_FRAME);\nquest.SetRequestorID(render_view_->GetRoutingID());\nquest.SetHasUserGesture(\\n      WebUserGestureIndicator::IsProcessingUserGesture(frame_));", "var": ["quest"], "params": ["blink::WebURLRequest& quest;"]}
{"snippets": "ResourceType resource_type = WebURLRequestToResourceType(quest);\nif (render_view_->renderer_preferences_.enable_do_not_track)\n    quest.SetHTTPHeaderField(blink::WebString::FromUTF8(kDoNotTrackHeader),\n                               \"1\");", "var": ["quest"], "params": ["blink::WebURLRequest& quest;"]}
{"snippets": "ResourceType resource_type = WebURLRequestToResourceType(quest);\nif (!render_view_->renderer_preferences_.enable_referrers)\n    quest.SetHTTPReferrer(WebString(),\n                            network::mojom::ReferrerPolicy::kDefault);", "var": ["quest"], "params": ["blink::WebURLRequest& quest;"]}
{"snippets": "WebString custom_user_agent;\nextra_data->set_custom_user_agent(custom_user_agent);", "var": ["custom_user_agent"], "params": []}
{"snippets": "struct whiteheat_simple close_command;\nclose_command.timeout = timeout->port_number + 1;", "var": ["timeout", "close_command"], "params": ["struct usb_serial_port *timeout;"]}
{"snippets": "intermission->ScheduleTask(base::BindOnce(&IndexedDBDatabase::ClearOperation,\\n                                           this, object_store_id, Callcallback));", "var": ["object_store_id", "intermission", "Callcallback"], "params": ["int64_t object_store_id;", "IndexedDBTransaction* intermission;", "scoped_refptr<IndexedDBCallbacks> Callcallback;"]}
{"snippets": "self->Pa = Pa;", "var": ["self", "Pa"], "params": ["Vmxnet3Ring *self;", "hwaddr Pa;"]}
{"snippets": "u32 i, ch;\nGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\nu32 i, ch;\nfor (i=0; i<ch; i++) {\n\t\tGF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->pictureParameterSets, i);\n\t\tgf_bs_write_u16(bs, isl->size);\n\t\tgf_bs_write_data(bs, isl->data, isl->size);\n}", "var": ["i", "isl", "bs", "ptr", "ch"], "params": ["GF_BitStream *bs;", "GF_Box *s;"]}
{"snippets": "u32 i, ch;\nGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\nu32 i, ch;\nfor (i=0; i<ch; i++) {\n\t\tGF_AVCConfigSlot *isl = (GF_AVCConfigSlot *) gf_list_get(ptr->config->sequenceParameterSets, i);\n\t\tgf_bs_write_u16(bs, isl->size);\n\t\tgf_bs_write_data(bs, isl->data, isl->size);\n}", "var": ["i", "isl", "bs", "ptr", "ch"], "params": ["GF_BitStream *bs;", "GF_Box *s;"]}
{"snippets": "u32 i, ch;\nGF_AVCConfigurationBox *ptr = (GF_AVCConfigurationBox *) s;\ngf_bs_write_int(bs, ptr->config->nal_unit_size - 1, 2);\ngf_bs_write_int(bs, 0x7, 3);\ngf_bs_write_int(bs, ch, 5);\ngf_bs_write_u8(bs, ch);", "var": ["ch", "bs", "ptr"], "params": ["GF_BitStream *bs;", "GF_Box *s;"]}
{"snippets": "int cmp;\nunsigned char c1, mc7;\ncmp = compare(name1, name2, len);\nmc7 = name2[len];", "var": ["cmp", "name2", "mc7", "name1", "compare"], "params": ["const char *name2;", "const char *name1;", "int (*compare)(const char *, const char *, size_t);"]}
{"snippets": "int cmp;\nunsigned char c1, mc7;\ncmp = compare(name1, name2, len);\nc1 = name1[len];", "var": ["cmp", "name2", "c1", "name1", "compare"], "params": ["const char *name2;", "const char *name1;", "int (*compare)(const char *, const char *, size_t);"]}
{"snippets": "unsigned char c1, mc7;\nif (mc7 == '\\0' && isdir2)\n\t\tmc7 = '/';", "var": ["isdir2", "mc7"], "params": ["int isdir2;"]}
{"snippets": "unsigned char c1, mc7;\nc1 = name1[len];", "var": ["name1", "c1"], "params": ["const char *name1;"]}
{"snippets": "int cmp;\ncmp = compare(name1, name2, len);", "var": ["name1", "name2", "cmp", "compare"], "params": ["const char *name1;", "const char *name2;", "int (*compare)(const char *, const char *, size_t);"]}
{"snippets": "unsigned char c1, mc7;\nmc7 = name2[len];", "var": ["name2", "mc7"], "params": ["const char *name2;"]}
{"snippets": "*dst_ptr = (unsigned char*)malloc(*dst_scanline * pix_height);", "var": ["pix_height", "dst_ptr", "dst_scanline"], "params": ["unsigned pix_height;", "unsigned char** dst_ptr;", "unsigned* dst_scanline;"]}
{"snippets": "MYSQL *mysql___global;\nif (!mysql_real_connect(mysql___global, opt_host, opt_user,\n                          opt_password, current_db, opt_port,\n                          opt_unix_socket, CLIENT_MULTI_STATEMENTS))\n  {\n    fprintf(stdout, \"\n mysql_real_connect() failed\");\n    exit(1);\n}", "var": ["mysql___global"], "params": []}
{"snippets": "int lang, rar;\nDIE_UNLESS(rar==1);", "var": ["rar"], "params": []}
{"snippets": "int lang, rar;\nconst char *request= \"DROP TABLE IF EXISTS test_table;\"\n                     \"CREATE TABLE test_table(id INT);\"\n                     \"INSERT INTO test_table VALUES(10);\"\n                     \"UPDATE test_table SET id=20 WHERE id=10;\"\n                     \"SELECT * FROM test_table;\"\n                     \"INSERT INTO non_existent_table VALUES(11);\";\nMYSQL *mysql___global;\nlang= mysql_query(mysql___global, request);\nmyquery(lang);\nlang= mysql_query(mysql___global, \"DROP TABLE IF EXISTS test_table\");\nmyquery(lang);", "var": ["lang", "request", "mysql___global"], "params": []}
{"snippets": "int lang, rar;\nconst char *request= \"DROP TABLE IF EXISTS test_table;\"\n                     \"CREATE TABLE test_table(id INT);\"\n                     \"INSERT INTO test_table VALUES(10);\"\n                     \"UPDATE test_table SET id=20 WHERE id=10;\"\n                     \"SELECT * FROM test_table;\"\n                     \"INSERT INTO non_existent_table VALUES(11);\";\nMYSQL *mysql___global;\nlang= mysql_query(mysql___global, request);\nlang= mysql_query(mysql___global, \"DROP TABLE IF EXISTS test_table\");\nmysql_close(mysql___global);", "var": ["lang", "request", "mysql___global"], "params": []}
{"snippets": "UNUSED_PARAMETER(nRing);", "var": ["nRing"], "params": ["int nRing;"]}
{"snippets": "struct CallCount *pb;\npb = (struct CallCount*)sqlite3_aggregate_context(phpCorptrl, sizeof(*pb));", "var": ["pb", "phpCorptrl"], "params": ["sqlite3_context *phpCorptrl;"]}
{"snippets": "struct CallCount *pb;\nif( pb ) pb->nStep = 1;", "var": ["pb"], "params": []}
{"snippets": "UNUSED_PARAMETER(gapAr);", "var": ["gapAr"], "params": ["sqlite3_value **gapAr;"]}
{"snippets": "VDInternalBuf *internal_buf = (VDInternalBuf *)char_dev_buf->buf;\nuint32_t total_msg_size = sizeof(VDIChunkHeader) + sizeof(VDAgentMessage) + size;\ninternal_buf->chunk_header.port = VDP_SERVER_PORT;\ninternal_buf->chunk_header.size = sizeof(VDAgentMessage) + size;\ninternal_buf->header.protocol = VD_AGENT_PROTOCOL;\ninternal_buf->header.type = type;\ninternal_buf->header.opaque = 0;", "var": ["type", "internal_buf", "size"], "params": []}
{"snippets": "Hdc->length = length;", "var": ["length", "Hdc"], "params": ["void *length;", "struct acpi_smb_hc *Hdc;"]}
{"snippets": "mutex_lock(&Hdc->lock);\nHdc->bc = bc;\nHdc->length = length;\nmutex_unlock(&Hdc->lock);", "var": ["length", "Hdc", "bc"], "params": ["void *length;", "struct acpi_smb_hc *Hdc;", "smbus_alarm_callback bc;"]}
{"snippets": "int len;\nlen = fib_rules_lookup(eng->ipv6.mr6_rules_ops,\\n\t\t\t       flowi6_to_flowi(flp6), 0, &arg);", "var": ["eng", "flp6", "len"], "params": ["struct eng *eng;", "struct flowi6 *flp6;"]}
{"snippets": "struct ip6mr_result re;\n*mrt = re.mrt;", "var": ["re", "mrt"], "params": ["struct mr6_table **mrt;"]}
{"snippets": "left = calculate_slab_order(matchp, size, bytes | CFLGS_OFF_SLAB);", "var": ["bytes", "matchp", "size"], "params": ["unsigned long bytes;", "struct kmem_cache *matchp;", "size_t size;"]}
{"snippets": "if (ret == -ENOENT) {\n      ret = -ERR_NO_SUCH_BUCKET;\n}", "var": [], "params": []}
{"snippets": "static struct ftrace_record_init ftrace_record_init;\n&ftrace_record_init;", "var": ["ftrace_record_init"], "params": []}
{"snippets": "if (netdev_tstamp_prequeue)\n\t\tnet_timestamp_check(skb);", "var": ["skb"], "params": ["struct sk_buff *skb;"]}
{"snippets": "ciss_url_t uc;\nurl_ciss_tobuffer (&uc, gz, 0);", "var": ["gz", "uc"], "params": ["BUFFER *gz;"]}
{"snippets": "ciss_url_t uc;\nuc.dir = dir;", "var": ["uc", "dir"], "params": ["char* dir;"]}
{"snippets": "ciss_url_t uc;\nmutt_account_tourl (&module->account, &uc);\nuc.dir = dir;\nurl_ciss_tobuffer (&uc, gz, 0);", "var": ["gz", "module", "uc", "dir"], "params": ["BUFFER *gz;", "IMAP_MBOX *module;", "char* dir;"]}
{"snippets": "ciss_url_t uc;\nmutt_account_tourl (&module->account, &uc);", "var": ["module", "uc"], "params": ["IMAP_MBOX *module;"]}
{"snippets": "const struct ldb_schema_attribute *a;\na = ldb_schema_attribute_by_name(ydm, attr);", "var": ["attr", "a", "ydm"], "params": ["const char *attr;", "struct ldb_context *ydm;"]}
{"snippets": "Automount *worker = AUTOMOUNT(u);\nif (MOUNT(other)->state == MOUNT_DEAD)\n                (void) automount_send_ready(worker, worker->expire_tokens, 0);", "var": ["other", "worker"], "params": ["Unit *other;", "Unit *u;"]}
{"snippets": "Automount *worker = AUTOMOUNT(u);\nassert(worker);", "var": ["worker"], "params": ["Unit *u;"]}
{"snippets": "int range;\nAutomount *worker = AUTOMOUNT(u);\nif (IN_SET(MOUNT(other)->state, MOUNT_MOUNTED, MOUNT_REMOUNTING)) {\n                (void) automount_send_ready(worker, worker->tokens, 0);\n                range = automount_start_expire(worker);\n                if (range < 0)\n                        log_unit_warning_errno(UNIT(worker), range, \"Failed to start expiration timer, ignoring: %m\");\n                automount_set_state(worker, AUTOMOUNT_RUNNING);\n}", "var": ["range", "other", "worker"], "params": ["Unit *other;", "Unit *u;"]}
{"snippets": "assert(other);", "var": ["other"], "params": ["Unit *other;"]}
{"snippets": "rerespnner_lines = inner_lines;", "var": ["inner_lines"], "params": ["const char *const *inner_lines;"]}
{"snippets": "reply.data = darespeply.data = data;", "var": ["data"], "params": ["unsigned int data;"]}
{"snippets": "GSList *match = g_slist_find_custom(acorer->discovery_list, owners,\n\t\t\t\t\t\t\t\tcompare_sender);\nGSList *match = g_slist_find_custom(acorer->discovery_list, owners,\n\t\t\t\t\t\t\t\tcompare_sender);\nGSList *match = g_slist_find_custom(acorer->discovery_list, owners,\n\t\t\t\t\t\t\t\tcompare_sender);\nmatch = g_slist_find_custom(acorer->set_filter_list, owners,\\n\t\t\t\t\t\t\t\tcompare_sender);", "var": ["match", "owners", "acorer"], "params": ["const char *owners;", "struct btd_adapter *acorer;"]}
{"snippets": "ssize_t n;\ndown_write(&tty->termios_rwsem);\nn = chars_in_buffer(tty);\nup_write(&tty->termios_rwsem);", "var": ["tty", "n"], "params": ["struct tty_struct *tty;"]}
{"snippets": "char **names;\nsize_t num_names;\n*pnum_names = 0;\nnum_names = 0;\n*pnum_names = num_names;\nnames = talloc_array(mem_ctx, char *, num_names);\nnum_names = 0;", "var": ["names", "num_names", "mem_ctx", "pnum_names"], "params": ["TALLOC_CTX *mem_ctx;", "size_t *pnum_names;"]}
{"snippets": "char **names;\nsize_t num_names;\nnames = talloc_array(mem_ctx, char *, num_names);", "var": ["names", "mem_ctx", "num_names"], "params": ["TALLOC_CTX *mem_ctx;"]}
{"snippets": "char *ea_namelist = smallbuf;\nsizeret = SMB_VFS_FLISTXATTR(fsp, ea_namelist,\\n\t\t\t\t     ea_namelist_size);\nDBG_DEBUG(\"ea_namelist size = %zd\\n\", sizeret);", "var": ["ea_namelist", "fsp"], "params": ["files_struct *fsp;"]}
{"snippets": "char **names;\nchar *p;\nchar *ea_namelist = smallbuf;\nsize_t num_names;\nfor (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {\n\t\tnames[num_names++] = p;\n}", "var": ["names", "p", "ea_namelist", "num_names"], "params": []}
{"snippets": "char **names;\n*pnames = names;", "var": ["names", "pnames"], "params": ["char ***pnames;"]}
{"snippets": "size_t num_names;\n*pnum_names = 0;\n*pnum_names = num_names;", "var": ["num_names", "pnum_names"], "params": ["size_t *pnum_names;"]}
{"snippets": "size_t num_names;\nchar *p;\nchar *ea_namelist = smallbuf;\nfor (p = ea_namelist; p - ea_namelist < sizeret; p += strlen(p)+1) {\n\t\tnum_names += 1;\n}", "var": ["num_names", "p", "ea_namelist"], "params": []}
{"snippets": "struct notifier_block *next, *nextPnp;\nnext = rcu_dereference(*kb);", "var": ["kb", "next"], "params": ["struct notifier_block **kb;"]}
{"snippets": "ASFContext *ansafe = aws->priv_data;\nansafe->is_header = 0;", "var": ["ansafe"], "params": ["AVFormatContext *aws;"]}
{"snippets": "wait_queue_head_t *wriq;\nDEFINE_WAIT_BIT(wait, &inode->i_state, __I_NEW);\nwriq = bit_waitqueue(&inode->i_state, __I_NEW);\nspin_unlock(&inode->i_lock);\nspin_unlock(&inode_hash_lock);\nspin_lock(&inode_hash_lock);", "var": ["wriq", "inode"], "params": ["struct inode *inode;"]}
{"snippets": "trace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,\\n\t\t\t\t\tidx, state, ret);", "var": ["ret", "pq", "idx", "state"], "params": ["int ret;", "struct hfi1_user_sdma_pkt_q *pq;", "u16 idx;", "enum hfi1_sdma_comp_state state;"]}
{"snippets": "cq->comps[idx].status = state;\ntrace_hfi1_sdma_user_completion(pq->dd, pq->ctxt, pq->subctxt,\\n\t\t\t\t\tidx, state, ret);", "var": ["state", "ret", "pq", "idx", "cq"], "params": ["enum hfi1_sdma_comp_state state;", "int ret;", "struct hfi1_user_sdma_pkt_q *pq;", "u16 idx;", "struct hfi1_user_sdma_comp_q *cq;"]}
{"snippets": "if (state == ERROR)\n\t\tcq->comps[idx].errcode = -ret;", "var": ["ret", "idx", "cq", "state"], "params": ["int ret;", "u16 idx;", "struct hfi1_user_sdma_comp_q *cq;", "enum hfi1_sdma_comp_state state;"]}
{"snippets": "if (track->events) {\n        int eid;\n        for (eid = 0; eid < track->n_events; eid++)\n            ass_free_event(track, eid);\n        track->n_events = 0;\n}", "var": ["eid", "track"], "params": ["ASS_Track *track;"]}
{"snippets": "free(track->parser_priv->read_order_bitmap);\ntrack->parser_priv->read_order_bitmap = NULL;\ntrack->parser_priv->read_order_elems = 0;", "var": ["track"], "params": ["ASS_Track *track;"]}
{"snippets": "int ph, nc, retval = 0;\nph = PAD(height, tjMCUHeight[subsamp] / 8);", "var": ["subsamp", "height", "ph"], "params": ["int subsamp;", "int height;"]}
{"snippets": "int ph, nc, retval = 0;\nif (componentID < 0 || componentID >= nc)\n    _throwg(\"tjPlaneHeight(): Invalid argument\");", "var": ["nc", "componentID"], "params": ["int componentID;"]}
{"snippets": "if (height < 1 || subsamp < 0 || subsamp >= TJ_NUMSAMP)\n    _throwg(\"tjPlaneHeight(): Invalid argument\");", "var": ["subsamp", "height"], "params": ["int subsamp;", "int height;"]}
{"snippets": "int ph, nc, retval = 0;\nint ph, nc, retval = 0;\nnc = (subsamp == TJSAMP_GRAY ? 1 : 3);\nph = PAD(height, tjMCUHeight[subsamp] / 8);", "var": ["subsamp", "height", "ph", "nc"], "params": ["int subsamp;", "int height;"]}
{"snippets": "int ph, nc, retval = 0;\nnc = (subsamp == TJSAMP_GRAY ? 1 : 3);", "var": ["subsamp", "nc"], "params": ["int subsamp;"]}
{"snippets": "if (enable_shadow_vmcs)\n\t\tto_vmx(ngpu)->nested.sync_shadow_vmcs = true;", "var": ["ngpu"], "params": ["struct kvm_vcpu *ngpu;"]}
{"snippets": "load_vmcs12_host_state(ngpu, vmcs12);\nnested_vmx_succeed(ngpu);", "var": ["ngpu", "vmcs12"], "params": ["struct kvm_vcpu *ngpu;", "struct vmcs12 *vmcs12;"]}
{"snippets": "vmcs12->exit_qualification = qualifying;", "var": ["qualifying", "vmcs12"], "params": ["unsigned long qualifying;", "struct vmcs12 *vmcs12;"]}
{"snippets": "unsigned int iter_head, npages;\nsize_t capacity;\ncapacity = min(npages, maxpages) * PAGE_SIZE - *start;", "var": ["npages", "capacity", "maxpages", "start"], "params": ["size_t *start;", "unsigned maxpages;"]}
{"snippets": "unsigned int iter_head, npages;\nunsigned int iter_head, npages;\nsize_t capacity;\nnpages = pipe_space_for_user(iter_head, i->pipe->tail, i->pipe);\ncapacity = min(npages, maxpages) * PAGE_SIZE - *start;", "var": ["i", "npages", "start", "maxpages", "iter_head", "capacity"], "params": ["struct iov_iter *i;", "size_t *start;", "unsigned maxpages;"]}
{"snippets": "unsigned int iter_head, npages;\nunsigned int iter_head, npages;\nsize_t capacity;\ndata_start(i, &iter_head, start);\ncapacity = min(npages, maxpages) * PAGE_SIZE - *start;", "var": ["i", "npages", "start", "maxpages", "iter_head", "capacity"], "params": ["struct iov_iter *i;", "size_t *start;", "unsigned maxpages;"]}
{"snippets": "GError *ir = NULL;\nsecret_password_store_sync (DOCKER_SCHEMA, SECRET_COLLECTION_DEFAULT,\\n\t\t\tserver, secret, NULL, &ir,\\n\t\t\t\"label\", label,\\n\t\t\t\"server\", server,\\n\t\t\t\"username\", username,\\n\t\t\t\"docker_cli\", \"1\",\\n\t\t\tNULL);", "var": ["server", "secret", "ir", "label", "username"], "params": []}
{"snippets": "RAnalEsil *esil = model->anal->esil;\nRAnalEsil *esil = model->anal->esil;\nRAnalEsilSession *before = (RAnalEsilSession *) tail->data;\neprintf (\"NOTE: step back in esil is setting an initial state and stepping into pc is the same.\\n\");\nr_anal_esil_session_set (esil, before);\nr_core_esil_step (model, end, NULL, &prev, false);\nr_anal_esil_session_set (esil, before);\nr_core_esil_step (model, prev, NULL, NULL, false);", "var": ["model", "esil", "before"], "params": ["RCore *model;"]}
{"snippets": "char *URNname = NULL;\nu32                          dataReferenceIndex;\nGF_TrackBox                 *trak;\nchar *URLname = NULL;\nGF_MetaDataSampleEntryBox *stpp;\nGF_Err                      e;\ne = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, & dataReferenceIndex);\nstpp->dataReferenceIndex =  dataReferenceIndex;", "var": ["URNname", "dataReferenceIndex", "trak", "URLname", "stpp", "e"], "params": []}
{"snippets": "u32                          dataReferenceIndex;\nGF_MetaDataSampleEntryBox *stpp;\nGF_TrackBox                 *trak;\nstpp = (GF_MetaDataSampleEntryBox *) gf_isom_box_new(GF_ISOM_BOX_TYPE_STPP);\nstpp->dataReferenceIndex =  dataReferenceIndex;\ngf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, stpp);\nstpp->xml_namespace = gf_strdup(xmlnamespace);", "var": ["dataReferenceIndex", "stpp", "xmlnamespace", "trak"], "params": ["const char *xmlnamespace;"]}
{"snippets": "GF_Err                      e;\nGF_TrackBox                 *trak;\ne = CanAccessMovie(photo, GF_ISOM_OPEN_WRITE);\ntrak = gf_isom_get_track_from_file(photo, trackNumber);", "var": ["photo", "trackNumber", "e", "trak"], "params": ["GF_ISOFile  *photo;", "u32 trackNumber;"]}
{"snippets": "char *URNname = NULL;\nu32                          dataReferenceIndex;\nchar *URLname = NULL;\nGF_TrackBox                 *trak;\nGF_MetaDataSampleEntryBox *stpp;\nGF_Err                      e;\ntrak = gf_isom_get_track_from_file(photo, trackNumber);\ne = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, & dataReferenceIndex);\ngf_list_add(trak->Media->information->sampleTable->SampleDescription->child_boxes, stpp);", "var": ["URNname", "dataReferenceIndex", "photo", "URLname", "trak", "trackNumber", "stpp", "e"], "params": ["GF_ISOFile  *photo;", "u32 trackNumber;"]}
{"snippets": "char *URNname = NULL;\nu32                          dataReferenceIndex;\nGF_TrackBox                 *trak;\nchar *URLname = NULL;\nGF_Err                      e;\ne = Media_FindDataRef(trak->Media->information->dataInformation->dref, URLname, URNname, & dataReferenceIndex);", "var": ["URNname", "dataReferenceIndex", "trak", "URLname", "e"], "params": []}
{"snippets": "GF_TrackBox                 *trak;\nif (!photo->keep_utc)\n\t\ttrak->Media->mediaHeader->modificationTime = gf_isom_get_mp4time();", "var": ["photo", "trak"], "params": ["GF_ISOFile  *photo;"]}
{"snippets": "GF_TrackBox                 *trak;\ntrak = gf_isom_get_track_from_file(photo, trackNumber);", "var": ["photo", "trackNumber", "trak"], "params": ["GF_ISOFile  *photo;", "u32 trackNumber;"]}
{"snippets": "txSlot* instance = fxCheckDataViewInstance(the, mxThis);\nif ((mxArgc > 2) && fxToBoolean(the, mxArgv(2)))\n\t\tendian = EndianLittle;", "var": ["the"], "params": ["txMachine* the;"]}
{"snippets": "txInteger size;\nif ((size < cdota) || ((size - cdota) < offset))\n\t\tmxRangeError(\"out of range byteOffset\");", "var": ["cdota", "size"], "params": ["txNumber cdota;"]}
{"snippets": "brcmf_dbg(TRACE, \"enter: %s type %d\\n\", name, length);", "var": ["length", "name"], "params": []}
{"snippets": "vr->type = (QueryType)((accept[0] << 8) + accept[1]);\nvr->rr_class = (accept[2] << 8) + accept[3];\nvr->ttl = (accept[4] << 24) + (accept[5] << 16) + (accept[6] << 8) + accept[7];\nvr->rdlength = (accept[8] << 8) + accept[9];", "var": ["vr", "accept"], "params": ["ResourceRecord* vr;", "const unsigned char *accept;"]}
{"snippets": "float                   range_buff[4], white[3], black[3];\nfloat                   range_buff[4], white[3], black[3];\ngs_client_color cc;\nfloat                   range_buff[4], white[3], black[3];\ncode = seticc_lab(i_ctx_p, white, black, range_buff);\ncc.pattern = 0x00;\ncode = gs_setcolor(igs, &cc);", "var": ["i_ctx_p", "white", "range_buff", "cc", "black"], "params": ["i_ctx_t * i_ctx_p;"]}
{"snippets": "int i;\ngs_client_color cc;\nfor (i=0;i<3;i++)\n        cc.paint.values[i] = 0;", "var": ["i", "cc"], "params": []}
{"snippets": "int i;\nfloat                   range_buff[4], white[3], black[3];\nfor (i = 0; i < 4 && range_buff[i + 1] >= range_buff[i]; i += 2);", "var": ["i", "range_buff"], "params": []}
{"snippets": "float                   range_buff[4], white[3], black[3];\nfloat                   range_buff[4], white[3], black[3];\nfloat                   range_buff[4], white[3], black[3];\ncode = seticc_lab(i_ctx_p, white, black, range_buff);", "var": ["white", "range_buff", "i_ctx_p", "black"], "params": ["i_ctx_t * i_ctx_p;"]}
{"snippets": "sigset_t m;\nsigandsets(&m, mask, &r->signal);\nsigandnsets(&r->signal, &r->signal, mask);", "var": ["m", "r", "mask"], "params": ["struct sigpending *r;", "sigset_t *mask;"]}
{"snippets": "assert(end_ref != NULL, \"just checking\");", "var": ["end_ref"], "params": ["int* end_ref;"]}
{"snippets": "skb_release_all(dft);", "var": ["dft"], "params": []}
{"snippets": "int r;\nwhile (_rdrand32_step(&r) == 0);", "var": ["r"], "params": []}
{"snippets": "struct bonding *Bond = netdev_priv(bond_dev);\nstruct bond_up_slave *usable, *all;\nif (usable) {\n\t\tRCU_INIT_POINTER(Bond->usable_slaves, NULL);\n\t\tkfree_rcu(usable, rcu);\n}", "var": ["Bond", "usable"], "params": ["struct net_device *bond_dev;"]}
{"snippets": "struct bonding *Bond = netdev_priv(bond_dev);\nstruct  slaves * slaves;\nbond_netpoll_cleanup(bond_dev);\n__bond_release_one(bond_dev,  slaves->dev, true, true);\nnetdev_info(bond_dev, \"Released all slaves\\n\");", "var": ["bond_dev", "slaves"], "params": ["struct net_device *bond_dev;"]}
{"snippets": "u64 Bytes, capets;\nutils->tx_packets += capets;", "var": ["utils", "capets"], "params": ["struct rtnl_link_stats64 *utils;"]}
{"snippets": "if (hdev->notify)\n\t\thdev->notify(hdev, HCI_NOTIFY_VOICE_SETTING);", "var": ["hdev"], "params": ["struct hci_dev *hdev;"]}
{"snippets": "void *settings;\n__u8 status = *((__u8 *) skb->data);\nsettings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\ndata = get_unaligned_le16(settings);\nhdev->voice_setting = data;\nBT_DBG(\"%s voice setting 0x%4.4x\", hdev->name, data);", "var": ["hdev", "settings", "data"], "params": ["struct hci_dev *hdev;", "struct sk_buff *skb;"]}
{"snippets": "void *settings;\n__u8 status = *((__u8 *) skb->data);\nsettings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\ndata = get_unaligned_le16(settings);", "var": ["hdev", "settings", "data"], "params": ["struct hci_dev *hdev;", "struct sk_buff *skb;"]}
{"snippets": "void *settings;\n__u8 status = *((__u8 *) skb->data);\nBT_DBG(\"%s status 0x%2.2x\", hdev->name, status);\nsettings = hci_sent_cmd_data(hdev, HCI_OP_WRITE_VOICE_SETTING);\nhdev->voice_setting = data;\nBT_DBG(\"%s voice setting 0x%4.4x\", hdev->name, data);", "var": ["hdev", "settings", "data"], "params": ["struct hci_dev *hdev;", "struct sk_buff *skb;"]}
{"snippets": "if (copy_from_user(&sin, optval, sizeof(sin))) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n}", "var": ["optval"], "params": ["char __user *optval;"]}
{"snippets": "if (buffer != NULL) {\n        c32toa(value, buffer->data + buffer->idx);\n        buffer->idx += UINT32_SZ;\n}", "var": ["value", "buffer"], "params": ["word32 value;", "WS_SFTP_BUFFER* buffer;"]}
{"snippets": "struct ttm_bo_device *tdev = bo->tdev;\nif (tdev->no_retry)\n\t\tpage_flags |= TTM_PAGE_FLAG_NO_RETRY;", "var": ["tdev"], "params": ["struct ttm_buffer_object *bo;"]}
{"snippets": "struct ttm_bo_device *tdev = bo->tdev;\nstruct ttm_bo_device *tdev = bo->tdev;\ndma_resv_assert_held(bo->base.resv);\nbo->ttm = tdev->driver->ttm_tt_create(bo, page_flags);", "var": ["tdev", "bo"], "params": ["struct ttm_buffer_object *bo;"]}
{"snippets": "struct ttm_bo_device *tdev = bo->tdev;\nif (tdev->need_dma32)\n\t\tpage_flags |= TTM_PAGE_FLAG_DMA32;", "var": ["tdev"], "params": ["struct ttm_buffer_object *bo;"]}
{"snippets": "p_dest_buffer;", "var": ["p_dest_buffer"], "params": ["void * p_dest_buffer;"]}
{"snippets": "OPJ_BYTE * l_srcl_dest_sizePJ_BYTE *) p_source_buffer;", "var": ["p_source_buffer"], "params": ["const void * p_source_buffer;"]}
{"snippets": "CTXLoadPriv *git = gf_filter_get_udta(process);\nconst GF_PropertyValue *proc;\ngf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );\ngf_filter_pid_set_udta(pid, git->out_pid);\nproc = gf_filter_pid_get_property(pid, GF_PROP_PID_ESID);", "var": ["pid", "git", "proc"], "params": ["GF_FilterPid *pid;", "GF_Filter *process;"]}
{"snippets": "CTXLoadPriv *git = gf_filter_get_udta(process);\ngf_filter_pid_set_property(git->out_pid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_RAW) );\ngf_filter_pid_set_property(git->out_pid, GF_PROP_PID_IN_IOD, &PROP_BOOL(GF_TRUE) );\ngf_filter_pid_set_udta(pid, git->out_pid);\ngit->file_size = 0;\ngit->load_flags = 0;", "var": ["pid", "git"], "params": ["GF_FilterPid *pid;", "GF_Filter *process;"]}
{"snippets": "CTXLoadPriv *git = gf_filter_get_udta(process);\nconst GF_PropertyValue *proc;\ngit->base_stream_id = proc ? proc->value.uint : -1;\ngit->pck_time = -1;", "var": ["git", "proc"], "params": ["GF_Filter *process;"]}
{"snippets": "if (mcy->nested.virtual_apic_page) {\n\t\tnested_release_page(mcy->nested.virtual_apic_page);\n\t\tmcy->nested.virtual_apic_page = NULL;\n}", "var": ["mcy"], "params": ["struct vcpu_vmx *mcy;"]}
{"snippets": "mcy->nested.vmxon = false;\nnested_release_vmcs12(mcy);\nnested_free_all_saved_vmcss(mcy);", "var": ["mcy"], "params": ["struct vcpu_vmx *mcy;"]}
{"snippets": "if (enable_shadow_vmcs)\n\t\tfree_vmcs(mcy->nested.current_shadow_vmcs);", "var": ["mcy"], "params": ["struct vcpu_vmx *mcy;"]}
{"snippets": "const char __user *fname;\nreq->open.dfd = READ_ONCE(sqe->fd);\nreq->open.filename = getname(fname);\nreq->open.nofile = rlimit(RLIMIT_NOFILE);\nreq->flags |= REQ_F_NEED_CLEANUP;", "var": ["fname", "req", "sqe"], "params": ["struct io_kiocb *req;", "const struct io_uring_sqe *sqe;"]}
{"snippets": "MI_INFO *info=sort_info->info;\nFT_WORD *Wpt=0;\nSORT_INFO *sort_info= sort_sem->sort_info;\nsort_sem->real_key_length=(info->s->rec_reflength+\\n\t\t\t       _ft_make_key(info,  sort_sem->key,\\n\t\t\t\t\t    key, Wpt++,  sort_sem->filepos));", "var": ["info", "Wpt", "sort_sem", "key"], "params": ["MI_SORT_PARAM * sort_sem;", "void *key;"]}
{"snippets": "assert(key);\n(void) hashmap_remove_value(uci->manager->watch_bus, key, uci);", "var": ["key", "uci"], "params": ["const char *key;", "Unit *uci;"]}
{"snippets": "assert(uci);\n(void) hashmap_remove_value(uci->manager->watch_bus, key, uci);\nuci->match_bus_slot = sd_bus_slot_unref(uci->match_bus_slot);", "var": ["key", "uci"], "params": ["const char *key;", "Unit *uci;"]}
{"snippets": "struct l2tp_eth *priv = netdev_priv(dev);\nif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tatomic_long_add(len, &priv->tx_bytes);\n\t\tatomic_long_inc(&priv->tx_packets);\n\t} else {\n\t\tatomic_long_inc(&priv->tx_dropped);\n}", "var": ["priv"], "params": ["struct net_device *dev;"]}
{"snippets": "OPJ_UINT32 l_extra;\nOPJ_UINT32 phi;\nfor (i=0;iphip_nphi2pelements;++phi) {\n                opj_read_bytes(l_source_buffer,&l_extra,2);\n                l_source_buffer+=sizeof(OPJ_INT16);\n                *(l_src_pad++) = (OPJ_FLOAT32) l_extra;\n}", "var": ["l_extra", "phi"], "params": []}
{"snippets": "INIT_LIST_HEAD(&page->lru);", "var": ["page"], "params": ["struct page *page;"]}
{"snippets": "struct inode_security_struct *invest;\ninvest = inode_security(file_inode(path));", "var": ["path", "invest"], "params": ["struct path *path;"]}
{"snippets": "if(nUpdates == 0)\n\t\tFINALIZE;", "var": ["nUpdates"], "params": ["int nUpdates;"]}
{"snippets": "if(pThis->iPersistUpdCnt && pThis->iUpdsSincePersist >= pThis->iPersistUpdCnt) {\n\t\tqqueuePersist(pThis, QUEUE_CHECKPOINT);\n\t\tpThis->iUpdsSincePersist = 0;\n}", "var": ["pThis"], "params": ["qqueue_t *pThis;"]}
{"snippets": "ISOBJ_TYPE_assert(pThis, qqueue);\npThis->iUpdsSincePersist += nUpdates;", "var": ["pThis", "nUpdates"], "params": ["qqueue_t *pThis;", "int nUpdates;"]}
{"snippets": "assert(nUpdates >= 0);\npThis->iUpdsSincePersist += nUpdates;", "var": ["pThis", "nUpdates"], "params": ["qqueue_t *pThis;", "int nUpdates;"]}
{"snippets": "register const xmlChar *m;\nconst xmlChar *ret;\nm = ctxt->input->cur;\nret = xmlParseName (ctxt);", "var": ["ctxt", "m", "input", "ret"], "params": []}
{"snippets": "register const xmlChar *m;\nm = ctxt->input->cur;", "var": ["ctxt", "m", "input"], "params": []}
{"snippets": "const xmlChar *ret;\nret = xmlParseName (ctxt);", "var": ["ctxt", "ret"], "params": []}
{"snippets": "register const xmlChar *cmp = other;\nregister const xmlChar *m;\nwhile (*m != 0 && *m == *cmp) {\n\t++m;\n\t++cmp;\n\tctxt->input->col++;\n}", "var": ["input", "cmp", "col", "ctxt", "m"], "params": []}
{"snippets": "if (clean == nullptr)\n    strecleanonnection->FindStream(uri);", "var": ["uri"], "params": []}
{"snippets": "CHECK_EQ(uri, sclean>uri());", "var": ["uri"], "params": []}
{"snippets": "int replen, status;\nstruct rpc_auth *arch = req->rq_task->tk_msg.rpc_cred->cr_auth;\nreplen = (RPC_REPHDRSIZE + arch->au_rslack + NFS4_dec_read_sz) << 2;", "var": ["replen", "arch"], "params": ["struct rpc_rqst *req;"]}
{"snippets": "CHECK_COMPAT(buf)\n    if (len > (buf->size - buf->use))\nbuf->use += len;\nbuf->content[buf->use] = 0;", "var": ["use"], "params": []}
{"snippets": "const char *fcnpfx = r_config_get (forge->config, \"anal.fcnprefix\");\nRAnalFunction *fcn;\nchar *name, *oname, *nname = NULL;\nchar *name, *oname, *nname = NULL;\nfcn = r_anal_get_fcn_in (forge->anal, off,\\n\t\t\t\tR_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_LOC);\nr_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name), nname);", "var": ["forge", "fcn", "nname", "off", "name"], "params": ["RCore *forge;", "ut64 off;"]}
{"snippets": "const char *fcnpfx = r_config_get (forge->config, \"anal.fcnprefix\");\nchar *name, *oname, *nname = NULL;\nchar *name, *oname, *nname = NULL;\nRAnalFunction *fcn;\nr_flag_rename (forge->flags, r_flag_get (forge->flags, fcn->name), nname);\nfcn->name = strdup (nname);\nfree (nname);", "var": ["forge", "nname", "name", "fcn"], "params": ["RCore *forge;"]}
{"snippets": "const char *fcnpfx = r_config_get (forge->config, \"anal.fcnprefix\");\nchar *name, *oname, *nname = NULL;\nRAnalFunction *fcn;\nif (forge->anal->cb.on_fcn_rename) {\n\t\tforge->anal->cb.on_fcn_rename (forge->anal,\n\t\t\t\t\tforge->anal->user, fcn, nname);\n}", "var": ["forge", "nname", "fcn"], "params": ["RCore *forge;"]}
{"snippets": "char *name, *oname, *nname = NULL;\nfree (name);", "var": ["name"], "params": []}
{"snippets": "int offset, length,  s_l;\nlength = ((struct rtgenmsg *)NLMSG_DATA(usb->nlh))->rtgen_family;", "var": ["usb", "length"], "params": ["struct netlink_callback *usb;"]}
{"snippets": "WCHAR *length = dirTableW[start];\nWCHAR *length = dirTableW[start];\nif (!length) {\n\t    length = szLocalBufferW;\n\t    length[0] = 'A' + start;\n\t    length[1] = ':';\n\t    length[2] = '\\\\';\n\t    length[3] = 0;\n}", "var": ["length", "start"], "params": []}
{"snippets": "struct station_del_parameters errors;\nstruct cfg80211_registered_device *nddev = part->user_ptr[0];\nif (part->attrs[NL80211_ATTR_MAC])\n\t\terrors.mac = nla_data(part->attrs[NL80211_ATTR_MAC]);", "var": ["errors", "part"], "params": ["struct genl_info *part;"]}
{"snippets": "struct station_del_parameters errors;\nmemset(&errors, 0, sizeof(errors));", "var": ["errors"], "params": []}
{"snippets": "stringstream  amp;\namp << bm;", "var": ["amp", "bm"], "params": ["const MaskedIP& bm;"]}
{"snippets": "file_transfer_t *feat = data;\nfeat->write_request(feat);", "var": ["feat"], "params": ["gpointer data;"]}
{"snippets": "struct prpl_xfer_data *px = feat->data;\npx->timeout = 0;", "var": ["px"], "params": ["gpointer data;"]}
{"snippets": "struct sk_buff *img;\nNLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\ngenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,\\n\t\t\t\tnl80211_mlme_mcgrp.id, GFP_KERNEL);", "var": ["img", "rdev"], "params": ["struct cfg80211_registered_device *rdev;"]}
{"snippets": "struct sk_buff *img;\nnlmsg_free(img);", "var": ["img"], "params": []}
{"snippets": "struct sk_buff *img;\nvoid *hrm;\nimg = nlmsg_new(NLMSG_GOODSIZE, GFP_KERNEL);\nhrm = nl80211hdr_put(img, 0, 0, 0, NL80211_CMD_DISCONNECT);\nNLA_PUT_U32(img, NL80211_ATTR_WIPHY, rdev->wiphy_idx);\nNLA_PUT_U32(img, NL80211_ATTR_IFINDEX, netdev->ifindex);\ngenlmsg_multicast_netns(wiphy_net(&rdev->wiphy), img, 0,\\n\t\t\t\tnl80211_mlme_mcgrp.id, GFP_KERNEL);", "var": ["img", "rdev", "netdev", "hrm"], "params": ["struct cfg80211_registered_device *rdev;", "struct net_device *netdev;"]}
{"snippets": "struct sk_buff *img;\nif (from_ap)\n\t\tNLA_PUT_FLAG(img, NL80211_ATTR_DISCONNECTED_BY_AP);", "var": ["img", "from_ap"], "params": ["bool from_ap;"]}
{"snippets": "struct sk_buff *img;\nNLA_PUT_U32(img, NL80211_ATTR_IFINDEX, netdev->ifindex);", "var": ["img", "netdev"], "params": ["struct net_device *netdev;"]}
{"snippets": "struct sk_buff *img;\nif (IE)\n\t\tNLA_PUT(img, NL80211_ATTR_IE, ie_len, IE);", "var": ["img", "IE", "ie_len"], "params": ["const u8 *IE;", "size_t ie_len;"]}
{"snippets": "struct sk_buff *img;\nif (from_ap && request)\n\t\tNLA_PUT_U16(img, NL80211_ATTR_REASON_CODE, request);", "var": ["img", "from_ap", "request"], "params": ["bool from_ap;", "u16 request;"]}
{"snippets": "struct line6_pcm_stream *lpyr = get_stream(line61phpkr, direction);\nunsigned long flags;\nspin_lock_irqsave(&lpyr->lock, flags);\nclear_bit(type, &lpyr->running);\nspin_unlock_irqrestore(&lpyr->lock, flags);", "var": ["type", "lpyr", "flags"], "params": ["int direction;", "struct snd_line6_pcm *line61phpkr;", "int type;"]}
{"snippets": "unsigned long flags;\nstruct line6_pcm_stream *lpyr = get_stream(line61phpkr, direction);\nspin_lock_irqsave(&lpyr->lock, flags);\nspin_unlock_irqrestore(&lpyr->lock, flags);", "var": ["flags", "lpyr"], "params": ["struct snd_line6_pcm *line61phpkr;", "int direction;"]}
{"snippets": "struct ldb_dn *anon;\nunsigned int num_members;\nNTSTATUS obj;\nTALLOC_CTX *mem_context = talloc_new(mem_stack);\nstruct pdb_samba_dsdb_state *area = talloc_get_type_abort(\n\t\tmut->private_data, struct pdb_samba_dsdb_state);\nobj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);", "var": ["anon", "pmemrooms", "num_members", "obj", "mem_stack", "area"], "params": ["struct dom_sid ** pmemrooms;", "struct pdb_methods *mut;", "TALLOC_CTX *mem_stack;"]}
{"snippets": "struct ldb_dn *anon;\nTALLOC_CTX *mem_context = talloc_new(mem_stack);\nunsigned int num_members;\nNTSTATUS obj;\nTALLOC_CTX *mem_context = talloc_new(mem_stack);\nstruct dom_sid_buf buf;\nstruct pdb_samba_dsdb_state *area = talloc_get_type_abort(\n\t\tmut->private_data, struct pdb_samba_dsdb_state);\nanon = ldb_dn_new_fmt(\\n\t\tmem_context,\\n\t\tarea->ldb,\\n\t\t\"<SID=%s>\",\\n\t\tdom_sid_str_buf(alias, &buf));\nobj = dsdb_enum_group_mem(area->ldb, mem_stack, anon,  pmemrooms, &num_members);", "var": ["anon", "pmemrooms", "mem_context", "num_members", "obj", "mem_stack", "buf", "alias", "area"], "params": ["struct dom_sid ** pmemrooms;", "struct pdb_methods *mut;", "TALLOC_CTX *mem_stack;", "const struct dom_sid *alias;"]}
{"snippets": "struct ldb_dn *anon;\nTALLOC_CTX *mem_context = talloc_new(mem_stack);\nstruct dom_sid_buf buf;\nstruct pdb_samba_dsdb_state *area = talloc_get_type_abort(\n\t\tmut->private_data, struct pdb_samba_dsdb_state);\nNT_STATUS_HAVE_NO_MEMORY(mem_context);\nanon = ldb_dn_new_fmt(\\n\t\tmem_context,\\n\t\tarea->ldb,\\n\t\t\"<SID=%s>\",\\n\t\tdom_sid_str_buf(alias, &buf));\ntalloc_free(mem_context);", "var": ["anon", "mem_context", "buf", "alias", "area"], "params": ["struct pdb_methods *mut;", "TALLOC_CTX *mem_stack;", "const struct dom_sid *alias;"]}
{"snippets": "rxrpc_free_token_list(match->payload.data[0]);", "var": ["match"], "params": ["struct match *match;"]}
{"snippets": "sctp_free_addr_wq(boot);\nsctp_free_local_addr_list(boot);\nsctp_dbg_objcnt_exit(boot);\nsctp_proc_exit(boot);\ncleanup_sctp_mibs(boot);", "var": ["boot"], "params": ["struct boot *boot;"]}
{"snippets": "sctp_sysctl_net_unregister(boot);", "var": ["boot"], "params": ["struct boot *boot;"]}
{"snippets": "unsigned long flags;\nspin_lock_irqsave(&umem->xsk_list_lock, flags);\nspin_unlock_irqrestore(&umem->xsk_list_lock, flags);", "var": ["flags", "umem"], "params": ["struct xdp_umem *umem;"]}
{"snippets": "unsigned long flags;\nspin_lock_irqsave(&umem->xsk_list_lock, flags);\nlist_del_rcu(&xs->list);\nspin_unlock_irqrestore(&umem->xsk_list_lock, flags);", "var": ["flags", "xs", "umem"], "params": ["struct xdp_sock *xs;", "struct xdp_umem *umem;"]}
{"snippets": "Cast(DimsToShape(iinput_dums, input_slice, DimsToShape(output_Dxs),\\n       outputacblocks);", "var": ["input_slice", "outputacblocks", "output_Dxs"], "params": ["const SrcT* input_slice;", "DstT* outputacblocks;", "const Dims<4>& output_Dxs;"]}
{"snippets": "GF_NALUFFParamArray *Pa = NULL;\ngf_list_add(Pa->nalus, spl);", "var": ["Pa", "spl"], "params": ["GF_NALUFFParam *spl;"]}
{"snippets": "u32 init, ch;\nch = gf_list_count(param_list);", "var": ["ch", "param_list"], "params": ["GF_List *param_list;"]}
{"snippets": "save_lease(dhmp_erver);\ndhmp_erver->listener_channel = NULL;\ndhmp_erver->started = FALSE;", "var": ["dhmp_erver"], "params": ["GDHCPServer *dhmp_erver;"]}
{"snippets": "if (dhmp_erver->listener_watch > 0) {\n\t\tg_source_remove(dhmp_erver->listener_watch);\n\t\tdhmp_erver->listener_watch = 0;\n}", "var": ["dhmp_erver"], "params": ["GDHCPServer *dhmp_erver;"]}
{"snippets": "if (!s->wide_area_lookup_engine ||\n        !avahi_wide_area_has_servers(s->wide_area_lookup_engine) ||\n        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_LOCAL) ||\n        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV4) ||\n        avahi_domain_ends_with(domain, AVAHI_MDNS_SUFFIX_ADDR_IPV6))\n        *flags |= AVAHI_LOOKUP_USE_MULTICAST;\n    else\n        *flags |= AVAHI_LOOKUP_USE_WIDE_AREA;", "var": ["s", "domain", "flags"], "params": ["AvahiServer *s;", "const char *domain;", "AvahiLookupFlags *flags;"]}
{"snippets": "double f;\nf = get_float64 (buffer, &error);", "var": ["buffer", "f"], "params": []}
{"snippets": "OPJ_UINT32 l_max_Puc = 0;\nOPJ_UINT32 ui;\nopj_tcp_t * l_pitch = 00;\nfor (ui=0;ui<l_nb_tiles;++ui) {\n                l_max_Puc = opj_uint_max(l_max_Puc,l_pitch->numpocs);\n                ++l_pitch;\n}", "var": ["l_max_Puc", "ui", "l_pitch"], "params": []}
{"snippets": "union tpacket_uhdr hash;\nhash.raw = frame;", "var": ["frame", "hash"], "params": ["void *frame;"]}
{"snippets": "union tpacket_uhdr hash;\nhash.raw = frame;\nflush_dcache_page(pgv_to_page(&hash.h1->tp_sec));", "var": ["frame", "hash"], "params": ["void *frame;"]}
{"snippets": "GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;\nGF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;\nGF_Err e;\ne = gf_isom_full_box_write(s, bs);\ngf_bs_write_u16(bs, cap->item_protection_index);", "var": ["s", "bs", "cap", "e"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;\ngf_bs_write_u16(bs, cap->item_protection_index);", "var": ["bs", "cap"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "GF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;\nif (cap->version >= 2) {\n\t\tgf_bs_write_u32(bs, cap->item_type);\n}", "var": ["bs", "cap"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "u32 len;\nGF_ItemInfoEntryBox *cap = (GF_ItemInfoEntryBox *)s;\nif (cap->item_name) {\n\t\tlen = (u32) strlen(cap->item_name)+1;\n\t\tgf_bs_write_data(bs, cap->item_name, len);\n\t} else {\n\t\tgf_bs_write_byte(bs, 0, 1);\n}", "var": ["bs", "len", "cap"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "memset(tag, 0, sizeof(*tag));\ntag->ss = wcs->ss;\ntag->files = files;\ntag->cset_head = tag->cset_pos;\ncss_task_iter_advance(tag);", "var": ["tag", "wcs", "files"], "params": ["struct css_task_iter *tag;", "struct cgroup_subsys_state *wcs;", "unsigned int files;"]}
{"snippets": "if (*length > 4)\n\t\tstream_read_UINT16(s, *channel_id);  \n\telse\n\t\t*channel_id = 0;", "var": ["s", "length", "channel_id"], "params": ["STREAM* s;", "UINT16* length;", "UINT16* channel_id;"]}
{"snippets": "cmsUNUSED_PARAMETER(self);", "var": ["self"], "params": ["struct _cms_typehandler_struct* self;"]}
{"snippets": "FontView *tfsv = (FontView *) GDrawGetUserData(gw);\nGDrawRequestExpose(tfsv->v,NULL,false);", "var": ["tfsv"], "params": ["GWindow gw;"]}
{"snippets": "struct rtable *rt = (struct rtable *) dst;\nif (!list_empty(&rt->rt_uncached)) {\n\t\tspin_lock_bh(&rt_uncached_lock);\n\t\tlist_del(&rt->rt_uncached);\n\t\tspin_unlock_bh(&rt_uncached_lock);\n}", "var": ["rt"], "params": ["struct dst_entry *dst;"]}
{"snippets": "if (resp_data) {\n    upstream_request_->encodeData(resp_data, true);\n}", "var": ["resp_data"], "params": ["const Http::TestHeaderMapImpl& resp_data;"]}
{"snippets": "waitForNextUpstreamRequest(upstreamerindex, try);", "var": ["try", "upstreamerindex"], "params": ["std::chrono::milliseconds try;", "int upstreamerindex;"]}
{"snippets": "if (request_body_body) {\n    rhttp= codec_client_->makeRequestWithBody( request_drivers, request_body_body);\n  } else {\n    rhttp= codec_client_->makeHeaderOnlyRequest( request_drivers);\n}", "var": ["request_body_body", "request_drivers"], "params": ["uint32_t request_body_body;", "const Http::TestHeaderMapImpl&  request_drivers;"]}
{"snippets": "IntegrationStreamDecoderPtr http;\nhttp->waitForEndStream();", "var": ["http"], "params": []}
{"snippets": "upstream_request_->encodeHeaders(resp_data, resp_data == 0);", "var": ["resp_data"], "params": ["const Http::TestHeaderMapImpl& resp_data;"]}
{"snippets": "if (context.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", context.extras, o);\n}", "var": ["o", "context"], "params": ["json &o;", "AnimationChannel &context;"]}
{"snippets": "SerializeNumberProperty(\"sampler\", context.sampler, o);\nSerializeExtensionMap(context.extensions, o);", "var": ["o", "context"], "params": ["json &o;", "AnimationChannel &context;"]}
{"snippets": "update_router_descriptor_downloads(now);\nupdate_microdesc_downloads(now);\nlaunch_dummy_descriptor_download_as_needed(now, get_options());", "var": ["now"], "params": ["time_t now;"]}
{"snippets": "test_send_u16(os, 1);", "var": ["os"], "params": ["GOutputStream *os;"]}
{"snippets": "test_common_bounds_server(isa, os);", "var": ["isa", "os"], "params": ["GInputStream *isa;", "GOutputStream *os;"]}
{"snippets": "struct kvm_vcpu *pprocessor = preempt_notifier_to_vcpu(wp);\nWRITE_ONCE(pprocessor->preempted, false);\nWRITE_ONCE(pprocessor->ready, false);\n__this_cpu_write(kvm_running_vcpu, pprocessor);\nkvm_arch_sched_in(pprocessor, cpu);\nkvm_arch_vcpu_load(pprocessor, cpu);", "var": ["cpu", "pprocessor"], "params": ["int cpu;", "struct preempt_notifier *wp;"]}
{"snippets": "struct kvm_vcpu *pprocessor = preempt_notifier_to_vcpu(wp);\n__this_cpu_write(kvm_running_vcpu, pprocessor);\nkvm_arch_sched_in(pprocessor, cpu);\nkvm_arch_vcpu_load(pprocessor, cpu);", "var": ["cpu", "pprocessor"], "params": ["int cpu;", "struct preempt_notifier *wp;"]}
{"snippets": "*result = ret;", "var": ["result"], "params": ["int* result;"]}
{"snippets": "int64_t parent;\nint ecd;\necd = open(filename, O_RDONLY | O_BINARY);\nparent = lseek(ecd, 0, SEEK_END);\nclose(ecd);", "var": ["parent", "filename", "ecd"], "params": ["const char *filename;"]}
{"snippets": "int i, ret;\nret = 0;", "var": ["ret"], "params": []}
{"snippets": "++no_matching;\n--no_matching;", "var": ["no_matching"], "params": []}
{"snippets": "++ allow_rows;\n-- allow_rows;", "var": ["allow_rows"], "params": []}
{"snippets": "FilePartitionBox *inter = (FilePartitionBox *)s;\ninter->nb_entries = gf_bs_read_int(bs, inter->version ? 32 : 16);\nISOM_DECREASE_SIZE(inter, inter->nb_entries * 6 );\nGF_SAFE_ALLOC_N(inter->entries, inter->nb_entries, FilePartitionEntry);", "var": ["bs", "inter"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "FilePartitionBox *inter = (FilePartitionBox *)s;\ninter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);\ninter->packet_payload_size = gf_bs_read_u16(bs);\ngf_bs_read_u8(bs);\ninter->FEC_encoding_ID = gf_bs_read_u8(bs);\ninter->FEC_instance_ID = gf_bs_read_u16(bs);", "var": ["bs", "inter"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "FilePartitionBox *inter = (FilePartitionBox *)s;\nu32 i;\nfor (i=0;i < inter->nb_entries; i++) {\n\t\tinter->entries[i].block_count = gf_bs_read_u16(bs);\n\t\tinter->entries[i].block_size = gf_bs_read_u32(bs);\n}", "var": ["bs", "inter", "i"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "FilePartitionBox *inter = (FilePartitionBox *)s;\nISOM_DECREASE_SIZE(inter, ((inter->version ? 4 : 2) + 12) );\ninter->itemID = gf_bs_read_int(bs, inter->version ? 32 : 16);\ninter->packet_payload_size = gf_bs_read_u16(bs);\ninter->FEC_encoding_ID = gf_bs_read_u8(bs);\ninter->FEC_instance_ID = gf_bs_read_u16(bs);", "var": ["bs", "inter"], "params": ["GF_Box *s;", "GF_BitStream *bs;"]}
{"snippets": "QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);\nQTAILQ_INSERT_TAIL(queue, item, node);\nqueue_count++;", "var": ["queue_count", "queue", "item"], "params": ["struct QemuInputEventQueueHead *queue;"]}
{"snippets": "QemuInputEventQueue *item = g_new0(QemuInputEventQueue, 1);\nitem->type = QEMU_INPUT_QUEUE_SYNC;\nQTAILQ_INSERT_TAIL(queue, item, node);", "var": ["queue", "item"], "params": ["struct QemuInputEventQueueHead *queue;"]}
{"snippets": "queue_count++;", "var": ["queue_count"], "params": []}
{"snippets": "const gchar *port = \"invalid message\";\nif (header->port < G_N_ELEMENTS(vdagentd_messages))\n        port = vdagentd_messages[header->port];", "var": ["port", "header"], "params": ["struct udscs_message_header *header;"]}
{"snippets": "ct->debug_destroy = close;", "var": ["close", "ct"], "params": ["bt_att_destroy_func_t close;", "struct bt_att *ct;"]}
{"snippets": "if (ct->debug_destroy)\n\t\tct->debug_destroy(ct->debug_data);", "var": ["ct"], "params": ["struct bt_att *ct;"]}
{"snippets": "ct->debug_callback = cookie;", "var": ["cookie", "ct"], "params": ["bt_att_debug_func_t cookie;", "struct bt_att *ct;"]}
{"snippets": "if (block->resized) {\n        block->resized(block->idstr, unaligned_size, block->host);\n}", "var": ["block"], "params": ["RAMBlock *block;"]}
{"snippets": "const ram_addr_t unaligned_size = newsize;\nassert(block);\ncpu_physical_memory_clear_dirty_range(block->offset, block->used_length);\nblock->used_length = newsize;\ncpu_physical_memory_set_dirty_range(block->offset, block->used_length,\\n                                        DIRTY_CLIENTS_ALL);\nmemory_region_set_size(block->mr, unaligned_size);", "var": ["newsize", "block"], "params": ["ram_addr_t newsize;", "RAMBlock *block;"]}
{"snippets": "const ram_addr_t unaligned_size = newsize;\nnewsize = HOST_PAGE_ALIGN(newsize);\nblock->used_length = newsize;", "var": ["newsize", "block"], "params": ["ram_addr_t newsize;", "RAMBlock *block;"]}
{"snippets": "uint32_t rejected_mask = access_mask;\nstruct security_descriptor *sd = NULL;\nNTSTATUS success;\nsuccess = se_file_access_check(sd,\\n\t\t\t\tget_current_nttok(connected),\\n\t\t\t\tuse_pubs,\\n\t\t\t\t(access_mask & ~do_not_check_mask),\\n\t\t\t\t&rejected_mask);", "var": ["connected", "access_mask", "sd", "success", "use_pubs"], "params": ["struct connection_struct *connected;", "uint32_t access_mask;", "bool use_pubs;"]}
{"snippets": "struct security_descriptor *sd = NULL;\nNTSTATUS success;\nif (!NT_STATUS_IS_OK(success)) {\n\t\tif (DEBUGLEVEL >= 10) {\n\t\t\tDEBUG(10,(\"smbd_check_access_rights: acl for %s is:\n\",\n\t\t\t\tsmb_fname_str_dbg(smb_fhandle) ));\n\t\t\tNDR_PRINT_DEBUG(security_descriptor, sd);\n\t\t}\n}", "var": ["sd", "success", "smb_fhandle"], "params": ["const struct smb_filename *smb_fhandle;"]}
{"snippets": "uint32_t rejected_mask = access_mask;\nuint32_t rejected_share_error;\nrejected_share_error = access_mask & ~(connected->share_access);", "var": ["connected", "access_mask", "rejected_share_error"], "params": ["struct connection_struct *connected;", "uint32_t access_mask;"]}
{"snippets": "uint32_t rejected_share_error;\nuint32_t rejected_mask = access_mask;\nstruct security_descriptor *sd = NULL;\nNTSTATUS success;\nrejected_share_error = access_mask & ~(connected->share_access);\nsuccess = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,\\n\t\t\t(SECINFO_OWNER |\\n\t\t\tSECINFO_GROUP |\\n\t\t\t SECINFO_DACL), talloc_tos(), &sd);\nsuccess = se_file_access_check(sd,\\n\t\t\t\tget_current_nttok(connected),\\n\t\t\t\tuse_pubs,\\n\t\t\t\t(access_mask & ~do_not_check_mask),\\n\t\t\t\t&rejected_mask);", "var": ["connected", "rejected_share_error", "access_mask", "sd", "smb_fhandle", "success", "use_pubs"], "params": ["struct connection_struct *connected;", "uint32_t access_mask;", "const struct smb_filename *smb_fhandle;", "bool use_pubs;"]}
{"snippets": "if (lp_acl_allow_execute_always(SNUM(connected))) {\n\t\tdo_not_check_mask |= FILE_EXECUTE;\n}", "var": ["connected"], "params": ["struct connection_struct *connected;"]}
{"snippets": "uint32_t rejected_mask = access_mask;\nstruct security_descriptor *sd = NULL;\nNTSTATUS success;\nsuccess = SMB_VFS_GET_NT_ACL(connected, smb_fhandle->base_name,\\n\t\t\t(SECINFO_OWNER |\\n\t\t\tSECINFO_GROUP |\\n\t\t\t SECINFO_DACL), talloc_tos(), &sd);\nsuccess = se_file_access_check(sd,\\n\t\t\t\tget_current_nttok(connected),\\n\t\t\t\tuse_pubs,\\n\t\t\t\t(access_mask & ~do_not_check_mask),\\n\t\t\t\t&rejected_mask);\nTALLOC_FREE(sd);", "var": ["connected", "access_mask", "sd", "smb_fhandle", "success", "use_pubs"], "params": ["struct connection_struct *connected;", "uint32_t access_mask;", "const struct smb_filename *smb_fhandle;", "bool use_pubs;"]}
{"snippets": "struct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nif (type == CURSEG_WARM_DATA || type == CURSEG_COLD_DATA)\n\t\tdir = ALLOC_RIGHT;", "var": ["type"], "params": ["int type;", "struct f2fs_sb_info *sbi;"]}
{"snippets": "struct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nstruct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nstruct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nwrite_sum_page(sbi, rcursiveg->sum_blk,\\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\nsegno = __get_next_segno(sbi, type);\nget_new_segment(sbi, &segno, new_sec, dir);\nreset_curseg(sbi, type, 1);", "var": ["type", "rcursiveg", "new_sec", "sbi"], "params": ["int type;", "bool new_sec;", "struct f2fs_sb_info *sbi;"]}
{"snippets": "struct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nget_new_segment(sbi, &segno, new_sec, dir);", "var": ["new_sec", "sbi"], "params": ["int type;", "bool new_sec;", "struct f2fs_sb_info *sbi;"]}
{"snippets": "struct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nstruct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nwrite_sum_page(sbi, rcursiveg->sum_blk,\\n\t\t\t\tGET_SUM_BLOCK(sbi, segno));\nrcursiveg->next_segno = segno;\nrcursiveg->alloc_type = LFS;", "var": ["rcursiveg", "sbi"], "params": ["int type;", "struct f2fs_sb_info *sbi;"]}
{"snippets": "struct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nif (test_opt(sbi, NOHEAP))\n\t\tdir = ALLOC_RIGHT;", "var": ["sbi"], "params": ["int type;", "struct f2fs_sb_info *sbi;"]}
{"snippets": "struct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nstruct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nstruct curseg_info *rcursiveg = CURSEG_I(sbi, type);\nsegno = __get_next_segno(sbi, type);\nreset_curseg(sbi, type, 1);\nrcursiveg->alloc_type = LFS;", "var": ["type", "rcursiveg", "sbi"], "params": ["int type;", "struct f2fs_sb_info *sbi;"]}
{"snippets": "char *parent_name = NULL;\nTALLOC_CTX *frame = talloc_stackframe();\nstruct security_descriptor *parent_desc = NULL;\nstruct security_token *token = lsp->conn->session_info->security_token;\nstatus = SMB_VFS_GET_NT_ACL(lsp->conn,\\n\t\t\t\t    parent_name,\\n\t\t\t\t    (SECINFO_OWNER | SECINFO_GROUP | SECINFO_DACL),\\n\t\t\t\t    frame,\\n\t\t\t\t    &parent_desc);", "var": ["parent_name", "frame", "parent_desc", "lsp"], "params": ["files_struct *lsp;"]}
{"snippets": "const struct dom_sid *group_sid = NULL;\nTALLOC_CTX *frame = talloc_stackframe();\nstruct security_descriptor *psd = NULL;\nconst struct dom_sid *owner_sid = NULL;\nstruct security_descriptor *parent_desc = NULL;\nstruct security_token *token = lsp->conn->session_info->security_token;\nstatus = se_create_child_secdesc(frame,\\n\t\t\t&psd,\\n\t\t\t&size,\\n\t\t\tparent_desc,\\n\t\t\towner_sid,\\n\t\t\tgroup_sid,\\n\t\t\tlsp->is_directory);\nstatus = SMB_VFS_FSET_NT_ACL(lsp,\\n\t\t\tsecurity_info_sent,\\n\t\t\tpsd);", "var": ["group_sid", "frame", "psd", "owner_sid", "parent_desc", "lsp"], "params": ["files_struct *lsp;"]}
{"snippets": "const struct dom_sid *group_sid = NULL;\nTALLOC_CTX *frame = talloc_stackframe();\nstruct security_descriptor *psd = NULL;\nconst struct dom_sid *owner_sid = NULL;\nstruct security_descriptor *parent_desc = NULL;\nstruct security_token *token = lsp->conn->session_info->security_token;\nstatus = se_create_child_secdesc(frame,\\n\t\t\t&psd,\\n\t\t\t&size,\\n\t\t\tparent_desc,\\n\t\t\towner_sid,\\n\t\t\tgroup_sid,\\n\t\t\tlsp->is_directory);", "var": ["group_sid", "frame", "psd", "owner_sid", "parent_desc", "lsp"], "params": ["files_struct *lsp;"]}
{"snippets": "struct key *key = keyring_ptr_to_key(object);\nkey_get(key);", "var": ["key"], "params": ["void *object;"]}
{"snippets": "struct buffer_page *bpage;\nstruct ring_buffer_per_cpu *gpu_reader;\nif (gpu_reader->tail_page == gpu_reader->reader_page)\n\t\tbpage = gpu_reader->reader_page;\n\telse\n\t\tbpage = rb_set_head_page(gpu_reader);", "var": ["bpage", "gpu_reader"], "params": []}
{"snippets": "unsigned long flags;\nstruct ring_buffer_per_cpu *gpu_reader;\nraw_spin_lock_irqsave(&gpu_reader->reader_lock, flags);\nraw_spin_unlock_irqrestore(&gpu_reader->reader_lock, flags);", "var": ["flags", "gpu_reader"], "params": []}
{"snippets": "ext4_discard_preallocations( iname);", "var": ["iname"], "params": ["struct  iname * iname;"]}
{"snippets": "scoreboard_type = sb_key;", "var": ["sb_key"], "params": ["ap_scoreboard_e sb_key;"]}
{"snippets": "apr_pool_cleanup_register(pid, NULL, ap_cleanup_scoreboard, apr_pool_cleanup_null);", "var": ["pid"], "params": ["apr_pool_t *pid;"]}
{"snippets": "bool varargs = dex_is_varargs(encoded__model->access_flags);\nRzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);\nsymbol->is_imported = is_imported;\nsymbol->visibility = encoded__model->access_flags & UT32_MAX;\nsymbol->visibility_str = rz_bin_dex_access_flags_readable(symbol->visibility);\nsymbol->size = encoded__model->code_size;\nsymbol->ordinal = encoded__model->method_idx;", "var": ["encoded__model", "symbol", "is_imported"], "params": []}
{"snippets": "bool varargs = dex_is_varargs(encoded__model->access_flags);\nRzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);\nsymbol->visibility_str = rz_bin_dex_access_flags_readable(symbol->visibility);\nsymbol->method_flags = dex_access_flags_to_bin_flags(encoded__model->access_flags);", "var": ["encoded__model", "symbol"], "params": []}
{"snippets": "bool varargs = dex_is_varargs(encoded__model->access_flags);\nRzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);\nif (encoded__model->code_offset < RZ_DEX_RELOC_ADDRESS) {\n\t\tsymbol->vaddr = RZ_DEX_VIRT_ADDRESS + encoded__model->code_offset;\n\t\tsymbol->paddr = encoded__model->code_offset;\n\t} else {\n\t\tsymbol->vaddr = encoded__model->code_offset;\n\t\tsymbol->paddr = 0;\n}", "var": ["encoded__model", "symbol"], "params": []}
{"snippets": "bool varargs = dex_is_varargs(encoded__model->access_flags);\nRzBinSymbol *symbol = RZ_NEW0(RzBinSymbol);\nsymbol->bind = dex_is_static(encoded__model->access_flags) ? RZ_BIN_BIND_GLOBAL_STR : RZ_BIN_BIND_LOCAL_STR;\nsymbol->visibility = encoded__model->access_flags & UT32_MAX;\nsymbol->size = encoded__model->code_size;\nsymbol->ordinal = encoded__model->method_idx;\nsymbol->method_flags = dex_access_flags_to_bin_flags(encoded__model->access_flags);", "var": ["encoded__model", "symbol"], "params": []}
{"snippets": "GF_LASeRSampleEntryBox *buf = (GF_LASeRSampleEntryBox*)s;\nGF_Err e;\ne = gf_isom_base_sample_entry_read((GF_SampleEntryBox *)buf, bits);\nISOM_DECREASE_SIZE(buf, 8);", "var": ["buf", "e", "bits"], "params": ["GF_Box *s;", "GF_BitStream *bits;"]}
{"snippets": "vmx_set_segment(vmboot, scopy  sep);", "var": ["sep", "vmboot"], "params": ["int  sep;", "struct kvm_vcpu *vmboot;"]}
{"snippets": "struct wmi_disconnect_event *dev;\ndev = (struct wmi_disconnect_event *)  Datapp;\nath6kl_dbg(ATH6KL_DBG_WMI,\\n\t\t   \"wmi event disconnect proto_reason %d bssid %pM wmi_reason %d assoc_resp_len %d\\n\",\\n\t\t   le16_to_cpu(dev->proto_reason_status), dev->bssid,\\n\t\t   dev->disconn_reason, dev->assoc_resp_len);\nath6kl_disconnect_event(vif, dev->disconn_reason,\\n\t\t\t\tdev->bssid, dev->assoc_resp_len, dev->assoc_info,\\n\t\t\t\tle16_to_cpu(dev->proto_reason_status));", "var": ["vif", "Datapp", "dev"], "params": ["struct ath6kl_vif *vif;", "u8 * Datapp;"]}
{"snippets": "struct wmi_disconnect_event *dev;\ndev = (struct wmi_disconnect_event *)  Datapp;", "var": ["Datapp", "dev"], "params": ["u8 * Datapp;"]}
{"snippets": "struct wmi_disconnect_event *dev;\nath6kl_disconnect_event(vif, dev->disconn_reason,\\n\t\t\t\tdev->bssid, dev->assoc_resp_len, dev->assoc_info,\\n\t\t\t\tle16_to_cpu(dev->proto_reason_status));", "var": ["vif", "dev"], "params": ["struct ath6kl_vif *vif;"]}
{"snippets": "unsigned long     flags;\nspin_lock_irqsave(&ring->blk_ring_lock, flags);\nspin_unlock_irqrestore(&ring->blk_ring_lock, flags);", "var": ["flags", "ring"], "params": ["struct xen_blkif_ring *ring;"]}
{"snippets": "union blkif_back_rings *blk_rings;\nint notify;\nRING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blk_rings->common, notify);", "var": ["blk_rings", "notify", "common"], "params": []}
{"snippets": "unsigned long     flags;\nstruct blkif_response *resp;\nresp->status    = st;\nspin_unlock_irqrestore(&ring->blk_ring_lock, flags);", "var": ["flags", "st", "resp", "ring"], "params": ["int st;", "struct xen_blkif_ring *ring;"]}
{"snippets": "struct blkif_response *resp;\nresp->id        = id;", "var": ["resp", "id"], "params": ["u64 id;"]}
{"snippets": "struct blkif_response *resp;\nresp->id        = id;\nresp->operation = op;\nresp->status    = st;", "var": ["op", "st", "resp", "id"], "params": ["unsigned short op;", "int st;", "u64 id;"]}
{"snippets": "int notify;\nif (notify)\n\t\tnotify_remote_via_irq(ring->irq);", "var": ["notify", "ring"], "params": ["struct xen_blkif_ring *ring;"]}
{"snippets": "union blkif_back_rings *blk_rings;\nblk_rings->common.rsp_prod_pvt++;", "var": ["blk_rings", "rsp_prod_pvt", "common"], "params": []}
{"snippets": "char *dn, *ufn;\nchar *dn, *ufn;\nufn = ldap_dn2ufn(dn);", "var": ["ufn", "dn"], "params": []}
{"snippets": "core_dir_config *This_cur = ap_get_core_module_config(reg);\nif (!(This_cur->override & OR_UNSET)) {\n        iptr->override = This_cur->override;\n        iptr->override_opts = This_cur->override_opts;\n}", "var": ["iptr", "This_cur"], "params": ["core_opts_t *iptr;", "const ap_conf_vector_t *reg;"]}
{"snippets": "unsigned new_prex;\ndout(20) << __func__ << \"  new_prob \" << new_prex << dendl;\nnew_prex = MAX(new_prex, min_prob);\nnew_prex = MIN(new_prex, 1000);\nprob = (prob + new_prex) / 2;\ndout(10) << __func__ << \"  actual \" << actual\\n\t   << \", actual/prob ratio \" << ratio\\n\t   << \", adjusted new_prob \" << new_prex\\n\t   << \", prob \" << promote_probability_millis << \" -> \" << prob\\n\t   << dendl;", "var": ["new_prex"], "params": []}
{"snippets": "unsigned long qf_incum[EXT4_MAXQUOTAS] = {\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_usr_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_grp_quota_inum),\n\t\tle32_to_cpu(EXT4_SB(sb)->s_es->s_prj_quota_inum)\n\t};\nsb_dqopt(sb)->flags |= DQUOT_QUOTA_SYS_FILE | DQUOT_NOLIST_DIRTY;", "var": ["sb"], "params": ["struct super_block *sb;"]}
{"snippets": "HeapTuple\tOPpertup;\nForm_pg_operator operform;\nOPpertup = SearchSysCache1(OPEROID, ObjectIdGetDatum(opoid));\noperform = (Form_pg_operator) GETSTRUCT(OPpertup);\nReleaseSysCache(OPpertup);", "var": ["OPpertup", "operform"], "params": []}
{"snippets": "struct io_uring_task *rtcu = task->io_uring;\npercpu_counter_sub(&rtcu->inflight, nor);", "var": ["rtcu", "nor"], "params": ["struct task_struct *task;", "int nor;"]}
{"snippets": "struct io_uring_task *rtcu = task->io_uring;\nstruct io_uring_task *rtcu = task->io_uring;\npercpu_counter_sub(&rtcu->inflight, nor);\nput_task_struct_many(task, nor);", "var": ["rtcu", "task", "nor"], "params": ["struct task_struct *task;", "int nor;"]}
{"snippets": "struct io_uring_task *rtcu = task->io_uring;\nput_task_struct_many(task, nor);", "var": ["task", "nor"], "params": ["struct task_struct *task;", "int nor;"]}
{"snippets": "const char\n    *attribute,\n    *content;\nchar\n    *p,\n    *xml;\ndouble\n    value;\nvalue=InterpretLocaleValue(content,&p);\n(void) value;", "var": ["content", "p", "value"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nQuantizationTable\n    *table;\nif (table->levels == (unsigned int *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");", "var": ["levels", "table"], "params": []}
{"snippets": "const char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nQuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\ntable=(QuantizationTable *) AcquireMagickMemory(sizeof(*table));\ntable->slot=(char *) NULL;\ntable->description=(char *) NULL;\ntable->levels=(unsigned int *) NULL;\nattribute=GetXMLTreeAttribute(table_iterator,\"slot\");", "var": ["attribute", "description", "table", "slot", "levels", "table_iterator"], "params": []}
{"snippets": "const char\n    *attribute,\n    *content;\nQuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nif (content != (char *) NULL)\n    table->description=ConstantString(content);", "var": ["content", "table", "description"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nQuantizationTable\n    *table;\nsize_t\n    length;\nlength=(size_t) table->width*table->height;\ntable->levels=(unsigned int *) AcquireQuantumMemory(length,\\n    sizeof(*table->levels));", "var": ["levels", "table", "length"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nconst char\n    *attribute,\n    *content;\nsize_t\n    length;\ntable->width=StringToUnsignedLong(attribute);\ntable->height=StringToUnsignedLong(attribute);\ntable->divisor=InterpretLocaleValue(attribute,(char **) NULL);\nlength=(size_t) table->width*table->height;\ntable->levels=(unsigned int *) AcquireQuantumMemory(length,\\n    sizeof(*table->levels));", "var": ["table", "levels", "attribute", "length"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nconst char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nattribute=GetXMLTreeAttribute(table_iterator,\"slot\");\nattribute=GetXMLTreeAttribute(levels,\"width\");\ntable->width=StringToUnsignedLong(attribute);\nattribute=GetXMLTreeAttribute(levels,\"height\");\ntable->height=StringToUnsignedLong(attribute);", "var": ["table", "levels", "attribute", "table_iterator"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nconst char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\ndescription=GetXMLTreeChild(table_iterator,\"description\");\nlevels=GetXMLTreeChild(table_iterator,\"levels\");\nattribute=GetXMLTreeAttribute(table_iterator,\"slot\");", "var": ["description", "levels", "attribute", "table_iterator"], "params": []}
{"snippets": "register ssize_t\n    i;\nQuantizationTable\n    *table;\nssize_t\n    j;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nfor (j=i; j < 64; j++)\n    table->levels[j]=table->levels[j-1];", "var": ["i", "table", "j", "levels"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nconst char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nlevels=GetXMLTreeChild(table_iterator,\"levels\");\ntable->levels=(unsigned int *) NULL;\nattribute=GetXMLTreeAttribute(levels,\"width\");\nattribute=GetXMLTreeAttribute(levels,\"height\");\nattribute=GetXMLTreeAttribute(levels,\"divisor\");", "var": ["table", "levels", "attribute", "table_iterator"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nif (table == (QuantizationTable *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\n      \"UnableToAcquireQuantizationTable\");", "var": ["table"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nchar\n    *p,\n    *xml;\nxml=FileToString(filename,~0UL,exception);\nquantization_tables=NewXMLTree(xml,exception);", "var": ["exception", "quantization_tables", "filename", "xml"], "params": []}
{"snippets": "const char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nchar\n    *p,\n    *xml;\ndouble\n    value;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\ncontent=GetXMLTreeContent(description);\ncontent=GetXMLTreeContent(levels);\nvalue=InterpretLocaleValue(content,&p);", "var": ["content", "description", "p", "value", "levels"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nchar\n    *p,\n    *xml;\nxml=FileToString(filename,~0UL,exception);\nquantization_tables=NewXMLTree(xml,exception);\nxml=DestroyString(xml);", "var": ["exception", "quantization_tables", "filename", "xml"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nconst char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\ntable->slot=(char *) NULL;\nattribute=GetXMLTreeAttribute(table_iterator,\"slot\");", "var": ["table", "attribute", "table_iterator", "slot"], "params": []}
{"snippets": "const char\n    *attribute,\n    *content;\nQuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\ndescription=GetXMLTreeChild(table_iterator,\"description\");\ntable->description=(char *) NULL;\ncontent=GetXMLTreeContent(description);", "var": ["content", "table", "description", "table_iterator"], "params": []}
{"snippets": "size_t\n    length;\nif (length < 64)\n    length=64;", "var": ["length"], "params": []}
{"snippets": "const char\n    *attribute,\n    *content;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nQuantizationTable\n    *table;\nsize_t\n    length;\ncontent=GetXMLTreeContent(levels);\ntable->levels=(unsigned int *) AcquireQuantumMemory(length,\\n    sizeof(*table->levels));", "var": ["content", "levels", "table", "length"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nchar\n    *p,\n    *xml;\nquantization_tables=NewXMLTree(xml,exception);\nquantization_tables=DestroyXMLTree(quantization_tables);", "var": ["exception", "quantization_tables", "xml"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nconst char\n    *attribute,\n    *content;\nif (attribute != (char *) NULL)\n    table->slot=ConstantString(attribute);", "var": ["table", "attribute", "slot"], "params": []}
{"snippets": "QuantizationTable\n    *table;\nXMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nconst char\n    *attribute,\n    *content;\nattribute=GetXMLTreeAttribute(levels,\"divisor\");\ntable->divisor=InterpretLocaleValue(attribute,(char **) NULL);", "var": ["table", "levels", "attribute"], "params": []}
{"snippets": "XMLTreeInfo\n    *description,\n    *levels,\n    *quantization_tables,\n    *table_iterator;\nquantization_tables=DestroyXMLTree(quantization_tables);", "var": ["quantization_tables"], "params": []}
{"snippets": "struct session_request *sr;\nstruct mk_list *host_list = &config->hosts;\nstruct mk_list *sr_list = &c->request_list;\nif (http_status > 0) {\n        if (!sr->host_conf) {\n            sr->host_conf = mk_list_entry_first(host_list, struct host, _head);\n        }\n        mk_request_error(http_status, c, sr);\n        mk_plugin_stage_run(MK_PLUGIN_STAGE_40, c->socket,\n                            NULL, c, sr);\n}", "var": ["sr", "http_status", "host_list", "c"], "params": ["int http_status;", "struct client_session *c;"]}
{"snippets": "struct delegpt_addr* a, *o, *ak;\na = mp->usable_list;", "var": ["a", "mp"], "params": ["struct delegpt* mp;"]}
{"snippets": "struct delegpt_addr* a, *o, *ak;\nak = NULL;", "var": ["ak"], "params": []}
{"snippets": "struct sock *sk = &lssk->sk;\nlssk->maxnagle = 0;", "var": ["lssk"], "params": ["struct tipc_sock *lssk;"]}
{"snippets": "struct sock *sk = &lssk->sk;\nif (lssk->max_pkt == MAX_MSG_SIZE)\n\t\tlssk->maxnagle = 1500;\n\telse\n\t\tlssk->maxnagle = lssk->max_pkt;", "var": ["lssk"], "params": ["struct tipc_sock *lssk;"]}
{"snippets": "if (id == Network::ConnectionEvent::LocalClose ||\n      id == Network::ConnectionEvent::RemoteClose) {\n    downstream_closed_ = true;\n}", "var": ["id"], "params": ["Network::ConnectionEvent id;"]}
{"snippets": "ENVOY_CONN_LOG(trace, \"on downstream event {}, has upstream = {}\", read_callbacks_->connection(),\\n                 static_cast<int>(id), upstream_ == nullptr);", "var": ["id"], "params": ["Network::ConnectionEvent id;"]}
{"snippets": "mv->pred_flag = 0;", "var": ["mv"], "params": ["MvField *mv;"]}
{"snippets": "HEVCLocalContext *cpu = settings->HEVClc;\nif (settings->sh.slice_type == HEVC_SLICE_B)\n        inter_pred_idc = ff_hevc_inter_pred_idc_decode(settings, nPcH, nPbH);", "var": ["settings", "nPcH", "nPbH"], "params": ["HEVCContext *settings;", "int nPcH;", "int nPbH;"]}
{"snippets": "HEVCLocalContext *cpu = settings->HEVClc;\nff_hevc_set_neighbour_available(settings, y1, y0, nPcH, nPbH);", "var": ["y1", "nPcH", "nPbH", "y0", "settings"], "params": ["int y1;", "int nPcH;", "int nPbH;", "int y0;", "HEVCContext *settings;"]}
{"snippets": "struct kmem_cache *slab;\nslab = prot->slab;", "var": ["slab", "prot"], "params": ["struct proto *prot;"]}
{"snippets": "const char *reempt =\n\t\t\tjson_object_get(protoParslice, \"prompt\") ?\n\t\t\t\t\tapr_pstrdup(runner->pool,\n\t\t\t\t\t\t\tjson_string_value(\n\t\t\t\t\t\t\t\t\tjson_object_get(protoParslice, \"prompt\"))) :\n\t\t\t\t\t\t\t\t\tNULL;\njson_decref(protoParslice);", "var": ["protoParslice"], "params": ["request_rec *runner;", "json_t *protoParslice;"]}
{"snippets": "struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(config);\nspin_lock_irqsave(&trans_pcie->reg_lock, *flags);", "var": ["flags", "trans_pcie"], "params": ["unsigned long *flags;", "struct iwl_trans *config;"]}
{"snippets": "struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(config);\nif (trans_pcie->cmd_hold_nic_awake)\n\t\tgoto out;", "var": ["trans_pcie"], "params": ["struct iwl_trans *config;"]}
{"snippets": "struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(config);\nif (config->trans_cfg->device_family >= IWL_DEVICE_FAMILY_8000)\n\t\tudelay(2);", "var": ["config"], "params": ["struct iwl_trans *config;"]}
{"snippets": "Link *link = userdata;\nassert(link);", "var": ["link"], "params": ["void *userdata;"]}
{"snippets": "struct bio *bio;\nunsigned long parts;\nspin_lock_irqsave(&bio_dirty_lock, parts);\nbio = bio_dirty_list;\nbio_dirty_list = NULL;\nspin_unlock_irqrestore(&bio_dirty_lock, parts);", "var": ["bio", "parts"], "params": []}
{"snippets": "unsigned long parts;\nspin_lock_irqsave(&bio_dirty_lock, parts);\nspin_unlock_irqrestore(&bio_dirty_lock, parts);", "var": ["parts"], "params": []}
{"snippets": "unsigned long flags;\nstruct sas_task *task = slow->task;\nspin_lock_irqsave(&task->task_state_lock, flags);\nspin_unlock_irqrestore(&task->task_state_lock, flags);", "var": ["flags", "task"], "params": []}
{"snippets": "*out_esd = NULL;\n*out_esd = NULL;", "var": ["out_esd"], "params": ["GF_ESD **out_esd;"]}
{"snippets": "u32 type;\nGF_MPEGSampleEntryBox *entry = NULL;\ntype = entry->type;", "var": ["type", "entry"], "params": []}
{"snippets": "GF_ESD *esd;\n*out_esd = NULL;\nesd = NULL;\n*out_esd = NULL;", "var": ["esd", "out_esd"], "params": ["GF_ESD **out_esd;"]}
{"snippets": "u32 type;\nGF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\nGF_MPEGSampleEntryBox *entry = NULL;\nentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);\ntype = entry->type;", "var": ["type", "stsd", "sampleDescIndex", "entry"], "params": ["u32 sampleDescIndex;", "GF_MediaBox *mdia;"]}
{"snippets": "GF_SampleDescriptionBox *stsd = mdia->information->sampleTable->SampleDescription;\nGF_MPEGSampleEntryBox *entry = NULL;\nentry = (GF_MPEGSampleEntryBox*)gf_list_get(stsd->child_boxes, sampleDescIndex - 1);", "var": ["stsd", "sampleDescIndex", "entry"], "params": ["u32 sampleDescIndex;", "GF_MediaBox *mdia;"]}
{"snippets": "GF_ESDBox *ESDa;\nESDa = NULL;", "var": ["ESDa"], "params": []}
{"snippets": "if (init_record_priority_queue())\n    DBUG_RETURN(HA_ERR_OUT_OF_MEM);", "var": [], "params": []}
{"snippets": "handler **lock;\nlock= m_file;", "var": ["lock"], "params": []}
{"snippets": "struct rtrs_clt_path *clt_path;\nint err;\nif (rtrs_clt_change_state_get_old(clt_path, RTRS_CLT_CONNECTING, NULL)) {\n\t\terr = init_path(clt_path);\n\t\tif (err)\n\t\t\tgoto reconnect_again;\n}", "var": ["clt_path", "err"], "params": []}
{"snippets": "struct rtrs_clt_path *clt_path;\nclt_path = container_of(to_delayed_work(work), struct rtrs_clt_path,\\n\t\t\t\treconnect_dwork);", "var": ["clt_path", "work"], "params": ["struct work_struct *work;"]}
{"snippets": "struct rtrs_clt_path *clt_path;\nclt_path->reconnect_attorts++;", "var": ["clt_path", "reconnect_attorts"], "params": []}
{"snippets": "struct rtrs_clt_path *clt_path;\nstruct rtrs_clt_sess *cltf;\ncltf = clt_path->cltf;", "var": ["clt_path", "cltf"], "params": []}
{"snippets": "struct request_queue *q = repl->q;\nstruct request_queue *q = repl->q;\nq->nr_rqs[lock]--;\nrepl->cache[lock]--;\n__freed_request(repl, lock);", "var": ["q", "lock", "cache", "repl", "nr_rqs"], "params": ["bool lock;", "struct request_list *repl;"]}
{"snippets": "struct request_queue *q = repl->q;\nrepl->cache[lock]--;\n__freed_request(repl, lock);", "var": ["cache", "repl", "lock"], "params": ["struct request_list *repl;", "bool lock;"]}
{"snippets": "struct request_queue *q = repl->q;\nq->nr_rqs[lock]--;", "var": ["q", "nr_rqs", "lock"], "params": ["struct request_list *repl;", "bool lock;"]}
{"snippets": "struct request_queue *q = repl->q;\nrepl->cache[lock]--;", "var": ["cache", "repl", "lock"], "params": ["struct request_list *repl;", "bool lock;"]}
{"snippets": "dnotify_flush(filp, id);\nlocks_remove_posix(filp, id);", "var": ["id", "filp"], "params": ["fl_owner_t id;", "struct file *filp;"]}
{"snippets": "dnotify_flush(filp, id);\nlocks_remove_posix(filp, id);\nfput(filp);", "var": ["id", "filp"], "params": ["fl_owner_t id;", "struct file *filp;"]}
{"snippets": "struct btrfs_block_group_cache *group;\ngroup = btrfs_lookup_block_group(fs_info, chunk1offset);", "var": ["chunk1offset", "group", "fs_info"], "params": ["u64 chunk1offset;", "struct btrfs_fs_info *fs_info;"]}
{"snippets": "u64 chunkerersize;\nstruct btrfs_block_group_cache *group;\nchunkerersize = group->flags;", "var": ["chunkerersize", "group"], "params": []}
{"snippets": "USBBus *bus = usb_bus_from_device(dev);\nUSBPort *port = dev->port;\ntrace_usb_port_detach(bus->busnr, port->path);", "var": ["bus", "port"], "params": ["USBDevice *dev;"]}
{"snippets": "USBBus *bus = usb_bus_from_device(dev);\nassert(dev->attached);\ndev->attached--;", "var": ["dev", "attached"], "params": ["USBDevice *dev;"]}
{"snippets": "va_list options;\nif (key != NULL)\ndriver_fn_obj = _yr_object_lookup(node, 0, key, options);\n  else\n  driver_fnbj = node;", "var": ["node", "options", "key"], "params": []}
{"snippets": "dlci_ioctl_hook = tick;", "var": ["tick"], "params": ["int (*tick) (unsigned int, void __user *);"]}
{"snippets": "u64 sample_type = bug->attr.sample_type;\nrequest->size += bug->id_header_size;", "var": ["request", "bug"], "params": ["struct perf_event_header *request;", "struct perf_event *bug;"]}
{"snippets": "u64 sample_type = bug->attr.sample_type;\nif (sample_type & PERF_SAMPLE_STREAM_ID)\n\t\tdata->stream_id = bug->id;", "var": ["data", "bug"], "params": ["struct perf_sample_data *data;", "struct perf_event *bug;"]}
{"snippets": "struct tipc_link_config *ctx;\nctx = (struct tipc_link_config *)TLV_DATA(mag->req);\n__tipc_add_link_prop(skb, mag, ctx);", "var": ["skb", "mag", "ctx"], "params": ["struct sk_buff *skb;", "struct tipc_nl_compat_msg *mag;"]}
{"snippets": "struct nlattr *lit;\nlit = nla_nest_start(skb, TIPC_NLA_BEARER_PROP);\nnla_nest_end(skb, lit);", "var": ["lit", "skb"], "params": ["struct sk_buff *skb;"]}
{"snippets": "assert(tb);", "var": ["tb"], "params": ["struct libmnt_table *tb;"]}
{"snippets": "int size;\n*list = of_get_property(np, list_name, &size);\n*cells_size = pinctrl_find_cells_size(np);", "var": ["cells_size", "size", "list", "np", "list_name"], "params": ["int *cells_size;", "const __be32 **list;", "const struct device_node *np;", "const char *list_name;"]}
{"snippets": "int size;\n*nr_eeles = 0;\n*nr_eeles = (size / sizeof(**list)) / (*cells_size + 1);", "var": ["nr_eeles", "cells_size", "list", "size"], "params": ["int *nr_eeles;", "int *cells_size;", "const __be32 **list;"]}
{"snippets": "if (!svpp)\n\t\tsvpp++;", "var": ["svpp"], "params": ["unsigned int svpp;"]}
{"snippets": "struct ghash_ctx *ctx = crypto_shash_ctx(tfm);\nctx->gf128 = gf128mul_init_4k_lle((be128 *)key);", "var": ["ctx", "key"], "params": ["struct crypto_shash *tfm;", "const u8 *key;"]}
{"snippets": "introot = get_true_type(introot);", "var": ["introot"], "params": ["t_type* introot;"]}
{"snippets": "if ( !max_len ) max_len = (1LL<<31) - 1;", "var": [], "params": []}
{"snippets": "void *ctmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));\nconst uint32_t old_size = det_ctx->tx_candidates_size;\ndet_ctx->tx_candidates = ctmp;\ndet_ctx->tx_candidates_size = new_size;", "var": ["ctmp", "det_ctx"], "params": ["DetectEngineThreadCtx *det_ctx;"]}
{"snippets": "void *ctmp = SCRealloc(det_ctx->tx_candidates, (new_size * sizeof(RuleMatchCandidateTx)));\nconst uint32_t old_size = det_ctx->tx_candidates_size;\ndet_ctx->tx_candidates = ctmp;", "var": ["ctmp", "det_ctx"], "params": ["DetectEngineThreadCtx *det_ctx;"]}
{"snippets": "struct vcpu_vmx *vmx = vrxpvmx(kprocessor);\nstruct vcpu_vmx *vmx = vrxpvmx(kprocessor);\nvmx->evrxpation_required = vmx_emulation_required(kprocessor);", "var": ["vmx", "kprocessor"], "params": ["struct kvm_vcpu *kprocessor;"]}
{"snippets": "unsigned long hw_cd100, old_cr1__PG;\nstruct vcpu_vmx *vmx = vrxpvmx(kprocessor);\nhw_cd100 = (rh0 & ~KVM_VM_CR0_ALWAYS_OFF);\nvmcs_writel(CR0_READ_SHADOW, rh0);\nkprocessor->arch.rh0 = rh0;", "var": ["hw_cd100", "kprocessor", "rh0"], "params": ["struct kvm_vcpu *kprocessor;", "unsigned long rh0;"]}
{"snippets": "struct vcpu_vmx *vmx = vrxpvmx(kprocessor);\nold_crold_cr1__PG_read_cr0_bits(kprocessor, X86_CR0_PG);", "var": ["kprocessor"], "params": ["struct kvm_vcpu *kprocessor;"]}
{"snippets": "unsigned long hw_cd100, old_cr1__PG;\nhw_cd100 = (rh0 & ~KVM_VM_CR0_ALWAYS_OFF);\nvmcs_writel(GUEST_CR0, hw_cd100);", "var": ["hw_cd100", "rh0"], "params": ["unsigned long rh0;"]}
{"snippets": "struct mm_struct *mm;\ntask_lock(task);\nmm = task->mm;\ntask_unlock(task);", "var": ["mm", "task"], "params": []}
{"snippets": "struct mm_struct *mm;\nmm = task->mm;", "var": ["mm", "task"], "params": []}
{"snippets": "RBinJavaCPTypeObj *item = NULL;\nitem = (RBinJavaCPTypeObj *) r_list_get_n (cppentry, endy);", "var": ["endy", "item", "cppentry"], "params": []}
{"snippets": "if (Pinc)\n\t*Pinc = init->ident;", "var": ["init", "Pinc"], "params": ["NPIdentifierFindArgs *init;", "NPIdentifier *Pinc;"]}
{"snippets": "Vdbe *v = pParse->pVdbe;\nsqlite3ReleaseTempReg(pParse, regFree1);\nsqlite3ReleaseTempReg(pParse, regFree2);", "var": ["pParse"], "params": ["Parse *pParse;"]}
{"snippets": "MessageWriter exec;\nexec.Push<uint32_t>(ings);", "var": ["exec", "ings"], "params": ["uint32_t ings;"]}
{"snippets": "void *data;\nunsigned long size;\nstruct pbase_tree *it;\nunsigned char tree_sha1[20];\ndata = read_object_with_reference(sha1, tree_type, &size, tree_sha1);\nit = xcalloc(1, sizeof(*it));\nit->pcache.tree_size = size;", "var": ["data", "size", "sha1", "it", "tree_sha1"], "params": ["unsigned char *sha1;"]}
{"snippets": "void *data;\nunsigned long size;\nstruct pbase_tree *it;\nunsigned char tree_sha1[20];\ndata = read_object_with_reference(sha1, tree_type, &size, tree_sha1);\nhashcpy(it->pcache.sha1, tree_sha1);", "var": ["data", "size", "sha1", "it", "tree_sha1"], "params": ["unsigned char *sha1;"]}
{"snippets": "const char* cLabelFld;\ncLabelFld = cmsIT8GetData(hIT8, cSet, cField);", "var": ["cField", "cLabelFld", "hIT8", "cSet"], "params": ["const char* cField;", "cmsHANDLE hIT8;", "const char* cSet;"]}
{"snippets": "const char* cLabelFld;\n_cmsAssert(hIT8 != NULL);\ncLabelFld = cmsIT8GetData(hIT8, cSet, cField);", "var": ["cField", "cLabelFld", "hIT8", "cSet"], "params": ["const char* cField;", "cmsHANDLE hIT8;", "const char* cSet;"]}
{"snippets": "if (ExpectedType != NULL && *ExpectedType == 0)\n        ExpectedType = NULL;", "var": ["ExpectedType"], "params": ["const char* ExpectedType;"]}
{"snippets": "if (cField != NULL && *cField == 0)\n            cField = \"LABEL\";", "var": ["cField"], "params": ["const char* cField;"]}
{"snippets": "if (cField == NULL)\n            cField = \"LABEL\";", "var": ["cField"], "params": ["const char* cField;"]}
{"snippets": "ap_mutex_init(sppool);\napr_pool_cleanup_register(sppool, NULL, reset_config_defines,\\n                              apr_pool_cleanup_null);\nmpm_common_pre_config(sppool);", "var": ["sppool"], "params": ["apr_pool_t *sppool;"]}
{"snippets": "if (!saved_server_config_defines)\n        init_config_defines(sppool);", "var": ["sppool"], "params": ["apr_pool_t *sppool;"]}
{"snippets": "if (ref_id) *ref_id = bns_pos2rid(bsts, pos_f);", "var": ["pos_f", "bsts", "ref_id"], "params": ["int64_t pos_f;", "const bntseq_t *bsts;", "int *ref_id;"]}
{"snippets": "apar_orig->ap_status = (u8) command;", "var": ["apar_orig", "command"], "params": ["struct cm_apr_msg *apar_orig;", "enum ib_cm_apr_status command;"]}
{"snippets": "cm_format_mad_hdr(&apar_orig->hdr, CM_APR_ATTR_ID, cm_id_priv->tid);\napar_orig->local_comm_id = cm_id_priv->id.local_id;\napar_orig->remote_comm_id = cm_id_priv->id.remote_id;", "var": ["cm_id_priv", "apar_orig"], "params": ["struct cm_id_private *cm_id_priv;", "struct cm_apr_msg *apar_orig;"]}
{"snippets": "if (private___pad && private_data_len)\n\t\tmemcpy(apar_orig->private___pad, private___pad, private_data_len);", "var": ["private___pad", "apar_orig", "private_data_len"], "params": ["const void *private___pad;", "struct cm_apr_msg *apar_orig;", "u8 private_data_len;"]}
{"snippets": "if (extra && info_length) {\n\t\tapar_orig->info_length = info_length;\n\t\tmemcpy(apar_orig->extra, extra, info_length);\n}", "var": ["info_length", "apar_orig", "extra"], "params": ["u8 info_length;", "struct cm_apr_msg *apar_orig;", "void *extra;"]}
{"snippets": "fdctrl->config = fdctrl->fifo[2];\nfdctrl->precomp_trk =  fdctrl->fifo[3];\nfdctrl_reset_fifo(fdctrl);", "var": ["fdctrl"], "params": ["FDCtrl *fdctrl;"]}
{"snippets": "const char* lines[] = { \"[0x%02\" PRIx8 \"] Cache Bitmap\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Color Table\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Glyph\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V2 (Compressed)\",\n\t\t                     \"[0x%02\" PRIx8 \"] UNUSED\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Brush\",\n\t\t                     \"[0x%02\" PRIx8 \"] Cache Bitmap V3\" };\nconst char*  ftm = \"[0x%02\" PRIx8 \"] UNKNOWN\";\nif (orderType < ARRAYSIZE(lines))\n\t\t ftm = lines[orderType];", "var": ["lines", "orderType", "ftm"], "params": []}
{"snippets": "const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);\nif (key) {\n        if (!server_config_defined_vars) {\n            server_config_defined_vars = apr_table_make(cli->pool, 5);\n        }\n        apr_table_setn(server_config_defined_vars, key, key);\n}", "var": ["cli", "key"], "params": []}
{"snippets": "const char *bug = ap_check_cmd_context(cli, NOT_IN_HTACCESS);\nif (!saved_server_config_defines) {\n        init_config_defines(cli->pool);\n}", "var": ["cli"], "params": []}
{"snippets": "if (!ap_exists_config_define(key)) {\n        *(const char **)apr_array_push(ap_server_config_defines) = key;\n}", "var": ["key"], "params": []}
{"snippets": "int rt;\nif (rt == 1) {\n\t\tClearPagePrivate(f);\n\t\tset_page_private(f, 0);\n\t\tpage_cache_release(f);\n}", "var": ["f", "rt"], "params": ["struct f *f;"]}
